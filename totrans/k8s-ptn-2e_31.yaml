- en: Chapter 25\. Secure Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No real-world application lives in isolation. Instead, each connects to external
    systems in one way or the other. Such external systems could include value-add
    services provided by the big cloud providers, other microservices that your service
    connects to, or a database. Regardless of which remote services your application
    connects to, you will likely need to go through authentication, which involves
    sending over credentials such as username and password or some other security
    token. This confidential information must be stored somewhere close to your application
    securely and safely. This chapter’s *Secure Configuration* pattern is about the
    best ways to keep your credentials as secure as possible when running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in [Chapter 20, “Configuration Resource”](ch20.html#ConfigurationResource),
    despite what its name implies, Secret resources are not encrypted but are only
    Base64 encoded. Nevertheless, Kubernetes does its best to restrict access to a
    Secret’s content with the techniques described in [“How Secure Are Secrets?”](ch20.html#config-resource-secrets-secure).
  prefs: []
  type: TYPE_NORMAL
- en: However, as soon as Secret resources are stored outside the cluster, they are
    naked and vulnerable. With the advent of GitOps as a prevalent paradigm for deploying
    and maintaining server-side applications, this security challenge is even more
    pressing. Should Secrets be stored on remote Git repositories? If so, then they
    must not be stored unencrypted. However, when those are committed encrypted in
    a source code management system like Git, where do they get decrypted on their
    way into a Kubernetes cluster?
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when credentials are stored encrypted within the cluster, it is not guaranteed
    that nobody else can access that confidential information. While you can granularly
    regulate access to Kubernetes resources with RBAC rules,^([1](ch25.html#idm45902086863808))
    at least one person has access to all data stored in the cluster: your cluster
    administrator. You might or might not be able to trust the cluster administrator.
    It all depends on the context in which your application operates. Are you running
    a Kubernetes cluster in the cloud operated by somebody else? Or is your application
    deployed on a big company-wide Kubernetes platform, and you need to know who is
    running this cluster? Different solutions are required depending on these trust
    boundaries and confidentiality requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Secrets are the Kubernetes answer for confidential configuration in-cluster
    storage. We talked in depth about Secrets in [Chapter 20, “Configuration Resource”](ch20.html#ConfigurationResource),
    so let’s now have a look at how we can improve various security aspects of Secrets
    with additional techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most straightforward solution for secure configuration is decoding encrypted
    information within the application itself. This approach always works, and not
    just when running on Kubernetes. But it takes considerable work to implement this
    within your code, and it couples your business logic with this aspect of securing
    your configuration. There are better, more transparent ways to do this on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The support for secure configuration on Kubernetes falls roughly into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-cluster encryption
  prefs: []
  type: TYPE_NORMAL
- en: This stores encrypted configuration information outside of Kubernetes, which
    nonauthorized persons can also read. The transformation into Kubernetes Secrets
    happens just before entering the cluster (e.g., when applying a resource via the
    API server) or inside the cluster by a permanently running operator process.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized secret management
  prefs: []
  type: TYPE_NORMAL
- en: This uses specialized services that are either already offered by cloud providers
    (e.g., AWS Secrets Manager or Azure Key Vault) or are part of an in-house vault
    service (e.g., HashiCorp Vault) for storing confidential configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: While out-of-cluster encryption techniques always eventually create a Secret
    within the cluster that your application can use, the support for external secret
    management systems (SMSs) provided by Kubernetes add-ons uses various other techniques
    to bring the confidential information to the deployed workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-Cluster Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The gist of the out-of-cluster technique is simple: pick up secret and confidential
    data from outside the cluster and transform it into a Kubernetes Secret. A lot
    of projects have been grown that implement this technique. This chapter looks
    at the three most prominent ones (as of 2023): Sealed Secrets, External Secrets,
    and sops.'
  prefs: []
  type: TYPE_NORMAL
- en: Sealed Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the oldest Kubernetes add-ons for helping with encrypted secrets is *Sealed
    Secrets*, introduced by Bitnami in 2017. The idea is to store the encrypted data
    for a Secret in a CustomResourceDefinition (CRD) SealedSecret. In the background,
    an operator monitors such resources and creates one Kubernetes Secret for each
    SealedSecret with the decrypted content. To learn more about CRDs and operators
    in general, check out [Chapter 28, “Operator”](ch28.html#Operator), which explains
    this pattern in detail. While the decryption happens within the cluster, the *encryption*
    happens outside by a CLI tool called `kubeseal`, which takes a Secret and translates
    it to a SealedSecret that can be stored safely in a source code management system
    like Git.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-1](#img-secure-configuration-sealed-secrets) shows the setup for
    Sealed Secrets.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sealed Secrets](assets/kup2_2501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-1\. Sealed Secrets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Secrets are encrypted with AES-256-GCM symmetrically as a session key, and the
    session key is encrypted asymmetrically with RSA-OAEP, the same setup TLS uses.
  prefs: []
  type: TYPE_NORMAL
- en: The secret private key is stored within the cluster and is automatically created
    by the SealedSecret Operator. It is up to the administrator to back up this key
    and rotate it if needed. The public key used by `kubeseal` can be fetched directly
    from the cluster or accessed directly from a file. You also can safely store the
    public key in Git along with your SealedSecret.
  prefs: []
  type: TYPE_NORMAL
- en: 'SealedSecrets support three scopes that you can select when creating a SealedSecret
    from a Secret:'
  prefs: []
  type: TYPE_NORMAL
- en: Strict
  prefs: []
  type: TYPE_NORMAL
- en: This freezes the namespace and name of the SealedSecret. This mode means you
    can create the SealedSecret only in the same namespace and with the same name
    as the original Secret in any target cluster. This mode is the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace-wide
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to apply the SealedSecret to a different name than the initial
    Secret but still pins it to the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster-wide
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to apply the SealedSecret to different namespaces, as it was
    initially created to do, and the name can be changed too.
  prefs: []
  type: TYPE_NORMAL
- en: These scopes can be selected when creating the SealedSecret with `kubeseal`.
    Still, you can also add the nonstrict scopes with the annotations listed in [Table 25-1](#table-secure-configuration-sealed-secret-annotations)
    on the original Secret before encryption or on the SealedSecret directly.
  prefs: []
  type: TYPE_NORMAL
- en: Table 25-1\. Annotation
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| sealedsecrets.bitnami.com/namespace-wide | `"true"` | Enable namespace-wide
    scope when set to `true`—i.e., different name but same namespace |'
  prefs: []
  type: TYPE_TB
- en: '| sealedsecrets.bitnami.com/cluster-wide | `"true"` | Enable cluster-wide scope
    when set to `true`—i.e., name and namespace can be changed on the SealedSecret
    after encryption |'
  prefs: []
  type: TYPE_TB
- en: '[Example 25-1](#ex-secure-configuration-sealed-secret-resource) shows a SealedSecret
    created by `kubeseal` that can be directly stored in Git.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-1\. SealedSecret created with `kubeseal`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_secure_configuration_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Command to create a SealedSecret from the secret stored in *mysecret.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_secure_configuration_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation that indicates that this SealedSecret can have any name and be applied
    to any namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_secure_configuration_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The secret values are encrypted individually (and shortened here for the sake
    of demonstration).
  prefs: []
  type: TYPE_NORMAL
- en: A Sealed Secret is a tool that allows you to store encrypted secrets in a publicly
    available location, such as a GitHub repository. It is important to properly back
    up the secret key, as without it, it will not be possible to decrypt the secrets
    if the operator is uninstalled. One potential drawback of Sealed Secrets is that
    they require a server-side operator to be continuously running in the cluster
    in order to perform the decryption.
  prefs: []
  type: TYPE_NORMAL
- en: External Secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [External Secrets Operator](https://oreil.ly/4kC1b) is a Kubernetes operator
    that integrates a growing list of external SMSs. The main difference between External
    Secrets and Sealed Secrets is that you do not manage the encrypted data storage
    yourself but rely on an external SMS to do the hard work, including encryption,
    decryption, and secure persistence. That way, you benefit from all the features
    of your cloud’s SMS, like key rotation and a dedicated user interface. SMS also
    provides an excellent way of separating concerns so that different roles can manage
    the application deployments and the secrets separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-2](#img-secure-configuration-external-secrets) shows the External
    Secrets architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '![External Secrets](assets/kup2_2502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-2\. External Secrets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A central operator reconciles two custom resources:'
  prefs: []
  type: TYPE_NORMAL
- en: SecretStore is the resource that holds the type and configuration of the external
    SMS to access. [Example 25-2](#ex-secure-configuration-external-secrets-store)
    gives an example of a store that connects to AWS Secret Manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ExternalSecret references a SecretStore, and the operator will create a corresponding
    Kubernetes Secret filled with the data fetched from the external SMS. For example,
    [Example 25-3](#ex-secure-configuration-external-secrets-secret) references a
    secret in the AWS Secret Manager and exposes the value within the specified target
    Secret.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 25-2\. SecretStore for connecting to AWS Secret Manager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_secure_configuration_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Provider `aws` configures the usage of the AWS Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_secure_configuration_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to a Secret that holds the access keys for talking with the AWS Secret
    Manager. A Secret with the name `awssm-secret` contains the keys `access-key`
    and `secret-access-key` used to authenticate against the AWS Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-3\. ExternalSecret that will be transformed into a Secret
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_secure_configuration_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to the SecretStore object that holds the connection parameters for
    AWS Secret Manager.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_secure_configuration_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Secret to create.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_secure_configuration_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The username that will be looked up under `cluster/DB-username` in AWS Secret
    Manager and put under the key `username` in the resulting Secret.
  prefs: []
  type: TYPE_NORMAL
- en: You have a lot of flexibility in defining the mapping of the external secret
    data to the content of the mirrored Secret—for example, using a template to create
    a configuration with a particular structure. See the [External Secrets documentation](https://oreil.ly/Oj4Qq)
    for more information. One significant advantage of this solution over a client-side
    solution is that only the server-side operator knows the credentials to authenticate
    against the external SMS.
  prefs: []
  type: TYPE_NORMAL
- en: The External Secrets Operator project merges several other Secret-syncing projects.
    In 2023, it is already the dominant solution for this specific use case of mapping
    and syncing an externally defined secret to a Kubernetes Secret. However, it has
    the same cost as a server-side component that runs all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Sops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do we need a server-side component to work with Secrets in a GitOps world where
    all resources are stored in a Git repository? Luckily, solutions exist that work
    entirely outside of a Kubernetes cluster. A pure client-side solution is [sops](https://oreil.ly/HH9GE)
    (“Secret OPerationS”) by Mozilla. Sops is not specific to Kubernetes but allows
    you to encrypt and decrypt any YAML or JSON file to safely store those in a source
    code repository. It does this by encrypting all values of such a document but
    leaving the keys untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use various methods for encryption with sops:'
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric local encryption via [`age`](https://oreil.ly/DH4RE) with the keys
    stored locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the secret encryption key in a centralized key management system (KMS).
    Supported platforms are AWS KMS, Google KMS, and Azure Key Vault as external cloud
    providers and HashiCorp Vault as an SMS you can host on your own. The identity
    management of those platforms allows for fine-granular access control to the encryption
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sops is a CLI tool you can run locally on your machine or within a cluster (e.g.,
    as part of a CI pipeline). Especially for the latter use case and if you are running
    in one of the big clouds, leveraging one of their KMSs provides a smooth integration.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-3](#img-secure-configuration-sops) illustrates how sops handles
    encryption and decryption on the client side.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sops](assets/kup2_2503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-3\. Sops for decrypting and encrypting resource files
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Example 25-4](#ex-secure-configuration-sops-encrypt) shows how to use sops
    to create an encrypted version of a ConfigMap.^([2](ch25.html#idm45902086415408))
    This example uses `age` and a freshly generated keypair for the encryption, which
    should be stored safely.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-4\. Sops for creating encrypted secrets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_secure_configuration_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a secret key with `age` and store it in *keys.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_secure_configuration_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The ConfigMap to encrypt.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_secure_configuration_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` field is changed to `name_unencrypted` to prevent it from getting
    encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_secure_configuration_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Call sops with the public part of the `age` key, and store the result in *configmap_encrypted.yml*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_secure_configuration_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Each value is replaced with an encrypted version in `ENC[...]` (output shortened
    for readability).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_secure_configuration_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` of the ConfigMap is left untouched.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_secure_configuration_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: An extra section, `sops` is appended to contain metadata that is needed for
    decryption.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_secure_configuration_CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted session key that is used for symmetrical decryption. This key itself
    is encrypted asymmetrically by `age`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, every value of the ConfigMap resource gets encrypted, even those
    that are not confidential, like resource types or the name of the resource. You
    can skip the encryption for specific values by appending an `_unencrypted` suffix
    to the key (which gets stripped off later when doing the decryption).
  prefs: []
  type: TYPE_NORMAL
- en: The generated *configmap_encrypted.yml* can safely be stored in Git or any other
    source control management. As shown in [Example 25-5](#ex-secure-configuration-sops-decrypt),
    you need the private key to decrypt the ciphered ConfigMap to apply it to the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-5\. Decrypt sops-encoded resource and apply it to Kubernetes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_secure_configuration_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Point sops to the private key to decrypt the session key.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_secure_configuration_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Decrypt and apply to Kubernetes. Note that every `_unencrypted` suffix on the
    resource keys is removed during sops decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Sops is an excellent solution for easy GitOps-style integration of Secrets without
    worrying about installing and maintaining Kubernetes add-ons. However, while your
    configuration can now be stored securely in Git, it is essential to understand
    that as soon as those configurations have been handed over to the cluster, anybody
    with elevated access rights can read that data directly via the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: If this is not something you can tolerate, we need to dig deeper into the toolbox
    and look again at centralized SMSs.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized Secret Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in [“How Secure Are Secrets?”](ch20.html#config-resource-secrets-secure),
    Secrets are as secure as possible. Still, any administrator with cluster-wide
    read access can read every Secret stored unencrypted. Depending on your trust
    relationship with your cluster operators and security requirements, this might
    or might not be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Besides baking individual secret handling into your application code, an alternative
    is to keep the secure information outside the cluster in the external SMS and
    request the confidential information on demand over secure channels.
  prefs: []
  type: TYPE_NORMAL
- en: There is a growing number of such SMSs out there, and every cloud provider offers
    its variant. We won’t go into many details here for those individual offerings
    but focus on the mechanism of how such systems integrate into Kubernetes. You
    will find a list of relevant products as of 2023 in [“More Information”](#sect-secure-configuration-more-information).
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Store CSI Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Container Storage Interface (CSI) is a Kubernetes API for exposing storage
    systems to containerized applications. CSI shows the path for third-party storage
    providers to plug in new types of storage that can be mounted as volumes in Kubernetes.
    Of particular interest in the context of this pattern is the [Secrets Store CSI
    Driver](https://oreil.ly/vm0F3). This driver, developed and maintained by the
    Kubernetes community, allows access to various centralized SMSs and mounts them
    as regular Kubernetes volumes. The difference from a mounted Secret volume as
    described in [Chapter 20, “Configuration Resource”](ch20.html#ConfigurationResource),
    is that nothing is stored in the Kubernetes etcd database but securely outside
    the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The Secrets Store CSI Driver supports the SMS from major cloud vendors (AWS,
    Azure, and GCP) and HashiCorp Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes setup for connecting a secret manager via the CSI driver involves
    performing these two administrative tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Secrets Store CSI Driver and configuration for accessing a specific
    SMS. Cluster-admin permissions are required for the installation process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring access rules and policies. Several provider-specific steps need
    to be completed, but the result is that a Kubernetes service account is mapped
    to a secret manager-specific role that allows access to the secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 25-4](#img-secure-configuration-secrets-store-csi) shows the overall
    setup needed for enabling the Secrets Store CSI Driver with a HashiCorp Vault
    backend.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secrets Store CSI Provider](assets/kup2_2504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-4\. Secrets Store CSI Driver
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After the setup is done, the usage of secret volumes is straightforward. First,
    you must define a SecretProviderClass, as demonstrated in [Example 25-6](#ex-secure-configuration-csi-provider).
    In this resource, you select the backend provider for the secret manager. For
    our example, we selected HashiCorp’s Vault. In the `parameters` section, the provider-specific
    configuration is added, which contains the connection parameter to the vault,
    the role to impersonate, and a pointer to the secret information that Kubernetes
    will mount into a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-6\. Configuration of how to access a secret manager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_secure_configuration_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Type of provider to use (`azure`, `gcp`, `aws`, or `vault` as of 2023).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_secure_configuration_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Connection URL to the Vault service instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_secure_configuration_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Vault-specific authentication role contains the Kubernetes service account allowed
    to connect.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_secure_configuration_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the file that should be mapped into the mounted volume.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_secure_configuration_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Path to the stored secret in the vault.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_secure_configuration_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Key to pick from the Vault secret.
  prefs: []
  type: TYPE_NORMAL
- en: This secret manager configuration can then be referenced by its name when used
    as a Pod volume. [Example 25-7](#ex-secure-configuration-csi-pod) shows a Pod
    that mounts the secrets configured in [Example 25-6](#ex-secure-configuration-csi-provider).
    One key aspect is the service account `vault-access-sa` with which this Pod runs.
    This service account must be configured on the Vault side to be part of the role
    `database` referenced in the SecretProviderClass.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this Vault configuration in our complete working and self-contained
    [example](https://oreil.ly/7w89_), along with setup instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Example 25-7\. Pod mounting a CSI volume from Vault
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_secure_configuration_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Service account that is used to authenticate against Vault.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_secure_configuration_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Directory in which to mount the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_secure_configuration_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of a CSI Driver, which points to the Secret Store CSI driver.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_secure_configuration_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to the SecretProviderClass that provides the connection to the Vault
    service.
  prefs: []
  type: TYPE_NORMAL
- en: While the setup for a CSI Secret Storage drive is quite complex, the usage is
    straightforward, and you can avoid storing confidential data within Kubernetes.
    However, there are more moving parts than with Secrets alone, so more things can
    go wrong, and it’s harder to troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a final alternative for offering secrets to applications via well-known
    Kubernetes abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Pod injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, an application can always access external SMSs via proprietary
    client libraries. This approach’s disadvantage is that you still have to store
    the credentials to access the SMS along your application and add a hard dependency
    within your code to a particular SMS. The CSI abstraction for projecting secret
    information into volumes visible as files for the deployed application is much
    more decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternative solutions leverage other well-known patterns described in this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: An *Init Container* (see [Chapter 15](ch15.html#InitContainer)) fetches the
    confidential data from an SMS and then copies it to a shared local volume that
    is mounted by the application container. The secret data is fetched only once
    before the main container starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *Sidecar* (see [Chapter 16](ch16.html#Sidecar)) syncs the secret data from
    the SMS to a local ephemeral volume that is also accessed by the application.
    The benefit of the sidecar approach is that it can update the secrets locally
    in case the SMS starts to rotate the secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can leverage these patterns on your own for your applications, but this
    is tedious. It is much better to let an external controller inject the init container
    or sidecar into your application.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent example of such an injector is the HashiCorp [Vault Sidecar Agent
    Injector](https://oreil.ly/T1y41). This injector is implemented as a so-called
    *mutating webhook*, a variant of a controller (see [Chapter 27, “Controller”](ch27.html#Controller)),
    that allows modification of any resource when it is created. When a Pod specification
    contains a particular, vault-specific annotation, the vault controller will modify
    this specification to add a container for syncing with Vault and to mount a volume
    for the secret data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 25-5](#img-secure-configuration-pod-injector) visualizes this technique,
    which is entirely transparent to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: While you still need to install the Vault Injector controller, it has fewer
    moving parts than hooking up a CSI secret storage volume with the provider deployment
    for a particular SMS product. Still, you can access all the secrets by just reading
    a file without using a proprietary client library.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vault Injector](assets/kup2_2505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 25-5\. Vault Injector
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen the many ways you can make access to your confidential
    information more secure, the question is, which one is the best?
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, it depends:'
  prefs: []
  type: TYPE_NORMAL
- en: If your main goal is a simple way to encrypt Secrets stored in public-readable
    places like a remote Git repository, the pure *client-side* encryption that *Sops*
    offers is perfect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The secret synchronization that the *External Secrets Operator* implements is
    a good choice when separating the concerns of retrieving credentials in a remote
    SMS and using them is essential.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ephemeral volume projection of secret information provided by *Secret Storage
    CSI Providers* is the right choice for you when you want to ensure that no confidential
    information is stored permanently in the cluster except the access tokens for
    accessing external vaults.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sidebar injections like the *Vault Sidecar Agent Injector* have the benefit
    of shielding from a direct access to an SMS. They are easily approachable at the
    cost of blurring the boundary between developers and administrator because of
    security annotations leaking into application deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the listed projects are the most prominent as of this writing in 2023.
    The landscape is constantly evolving, so by the time you read this book, there
    might be new contenders (or some existing projects might have stopped). However,
    the techniques used (client-side encryption, Secret synchronization, volume projections,
    and sidecar injections) are universal and will be part of future solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'But a clear warning at the end: regardless of how securely and safely you can
    access your secret configuration, if somebody with evil intentions has full root
    access to your cluster and containers, a means to get to that data will always
    exist. This pattern makes these kinds of exploits as difficult as possible by
    adding an extra layer on the Kubernetes Secret abstraction.'
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Secure Configuration Example](https://oreil.ly/-ROVS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alex Soto Bueno and Andrew Block’s *Kubernetes Secrets Management* (Manning,
    2022)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes: Sealed Secrets](https://oreil.ly/sLSSI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sealed Secrets](https://oreil.ly/XRkqy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[External Secrets Operator](https://oreil.ly/2VdMM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes External Secrets](https://oreil.ly/VLVi8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sops](https://oreil.ly/HH9GE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes Secrets Store CSI Driver](https://oreil.ly/2_27G)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Retrieve HashiCorp Vault Secrets with Kubernetes CSI](https://oreil.ly/NFU1g)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HashiCorp Vault](https://oreil.ly/JUjiP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secret Management Systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Azure Key Vault](https://oreil.ly/LWLvX)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[AWS Secrets Manager](https://oreil.ly/eJ-dk)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[AWS Systems Manager Parameter Store](https://oreil.ly/nYaCF)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GCP Secret Manager](https://oreil.ly/caLls)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch25.html#idm45902086863808-marker)) RBAC rules are explained in detail
    in [Chapter 26, “Access Control”](ch26.html#AccessControl).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch25.html#idm45902086415408-marker)) In the real world, you should use
    a Secret for this kind of confidential information, but here we use a ConfigMap
    to demonstrate that you can use *any* resource file with sops.
  prefs: []
  type: TYPE_NORMAL
