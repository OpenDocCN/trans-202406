- en: Chapter 25\. Secure Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第25章 安全配置
- en: No real-world application lives in isolation. Instead, each connects to external
    systems in one way or the other. Such external systems could include value-add
    services provided by the big cloud providers, other microservices that your service
    connects to, or a database. Regardless of which remote services your application
    connects to, you will likely need to go through authentication, which involves
    sending over credentials such as username and password or some other security
    token. This confidential information must be stored somewhere close to your application
    securely and safely. This chapter’s *Secure Configuration* pattern is about the
    best ways to keep your credentials as secure as possible when running on Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的应用程序都不是孤立存在的。相反，每个应用程序都以某种方式连接到外部系统。这些外部系统可能包括由大型云提供商提供的增值服务、您的服务连接的其他微服务或数据库。无论您的应用程序连接到哪些远程服务，您可能需要进行身份验证，这涉及发送诸如用户名和密码或其他安全令牌等凭据。这些机密信息必须安全地存储在靠近您的应用程序的地方。本章的“安全配置”模式就是要探讨在运行在
    Kubernetes 上时保持凭证尽可能安全的最佳方法。
- en: Problem
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: As you learned in [Chapter 20, “Configuration Resource”](ch20.html#ConfigurationResource),
    despite what its name implies, Secret resources are not encrypted but are only
    Base64 encoded. Nevertheless, Kubernetes does its best to restrict access to a
    Secret’s content with the techniques described in [“How Secure Are Secrets?”](ch20.html#config-resource-secrets-secure).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 [第20章，“配置资源”](ch20.html#ConfigurationResource) 中所学到的，尽管其名称暗示着 Secret 资源是加密的，但实际上它们只是
    Base64 编码的。尽管如此，Kubernetes 通过所描述的技术尽最大努力限制对 Secret 内容的访问，详见 [“Secrets 有多安全？”](ch20.html#config-resource-secrets-secure)。
- en: However, as soon as Secret resources are stored outside the cluster, they are
    naked and vulnerable. With the advent of GitOps as a prevalent paradigm for deploying
    and maintaining server-side applications, this security challenge is even more
    pressing. Should Secrets be stored on remote Git repositories? If so, then they
    must not be stored unencrypted. However, when those are committed encrypted in
    a source code management system like Git, where do they get decrypted on their
    way into a Kubernetes cluster?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦 Secret 资源存储在集群外部，它们就会暴露且易受攻击。随着 GitOps 作为部署和维护服务器端应用程序的主流范式的出现，这一安全挑战变得更加紧迫。秘密应该存储在远程
    Git 存储库中吗？如果是这样，那么它们就不能以未加密形式存储。然而，当这些秘密以加密形式提交到 Git 等源代码管理系统时，在进入 Kubernetes
    集群的过程中，它们何时解密？
- en: 'Even when credentials are stored encrypted within the cluster, it is not guaranteed
    that nobody else can access that confidential information. While you can granularly
    regulate access to Kubernetes resources with RBAC rules,^([1](ch25.html#idm45902086863808))
    at least one person has access to all data stored in the cluster: your cluster
    administrator. You might or might not be able to trust the cluster administrator.
    It all depends on the context in which your application operates. Are you running
    a Kubernetes cluster in the cloud operated by somebody else? Or is your application
    deployed on a big company-wide Kubernetes platform, and you need to know who is
    running this cluster? Different solutions are required depending on these trust
    boundaries and confidentiality requirements.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 即使凭证以加密形式存储在集群内部，也不能保证没有其他人可以访问这些机密信息。尽管您可以通过 RBAC 规则对 Kubernetes 资源进行细粒度访问控制^([1](ch25.html#idm45902086863808))，但至少有一个人可以访问集群中存储的所有数据：您的集群管理员。您可能能够信任集群管理员，也可能不能。这完全取决于您的应用程序运行的上下文。您是否在由他人操作的云中运行
    Kubernetes 集群？或者您的应用程序部署在大型公司范围的 Kubernetes 平台上，您需要知道谁在管理此集群？根据这些信任边界和保密要求，需要不同的解决方案。
- en: Secrets are the Kubernetes answer for confidential configuration in-cluster
    storage. We talked in depth about Secrets in [Chapter 20, “Configuration Resource”](ch20.html#ConfigurationResource),
    so let’s now have a look at how we can improve various security aspects of Secrets
    with additional techniques.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群内部，Secrets 是 Kubernetes 提供的用于保护配置的答案。我们在 [第20章，“配置资源”](ch20.html#ConfigurationResource)
    中详细讨论了 Secrets，现在让我们看看如何通过额外技术来改善 Secrets 的各种安全方面。
- en: Solution
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: The most straightforward solution for secure configuration is decoding encrypted
    information within the application itself. This approach always works, and not
    just when running on Kubernetes. But it takes considerable work to implement this
    within your code, and it couples your business logic with this aspect of securing
    your configuration. There are better, more transparent ways to do this on Kubernetes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安全配置来说，最直接的解决方案是在应用程序内部解码加密信息。这种方法始终有效，不仅在 Kubernetes 上运行时有效。但是，在你的代码中实现这一点需要相当大的工作量，并且将你的业务逻辑与配置安全相关的方面耦合在一起。在
    Kubernetes 上有更好、更透明的方法来实现这一点。
- en: 'The support for secure configuration on Kubernetes falls roughly into two categories:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上支持安全配置大致可分为两类：
- en: Out-of-cluster encryption
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集群外加密
- en: This stores encrypted configuration information outside of Kubernetes, which
    nonauthorized persons can also read. The transformation into Kubernetes Secrets
    happens just before entering the cluster (e.g., when applying a resource via the
    API server) or inside the cluster by a permanently running operator process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加密的配置信息存储在 Kubernetes 之外，即使未授权的人也可以读取。在进入集群之前（例如，通过 API 服务器应用资源时）或者集群内部通过一个持续运行的操作器进程，会将其转换为
    Kubernetes Secrets。
- en: Centralized secret management
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式秘密管理
- en: This uses specialized services that are either already offered by cloud providers
    (e.g., AWS Secrets Manager or Azure Key Vault) or are part of an in-house vault
    service (e.g., HashiCorp Vault) for storing confidential configuration data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用专门的服务，这些服务已经由云提供商提供（例如 AWS Secrets Manager 或 Azure Key Vault），或者是内部金库服务的一部分（例如
    HashiCorp Vault），用于存储机密配置数据。
- en: While out-of-cluster encryption techniques always eventually create a Secret
    within the cluster that your application can use, the support for external secret
    management systems (SMSs) provided by Kubernetes add-ons uses various other techniques
    to bring the confidential information to the deployed workloads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在集群外加密技术最终会创建一个 Secret 在集群中，供你的应用程序使用，但 Kubernetes 附加的外部秘密管理系统（SMSs）支持使用各种其他技术将机密信息传递到部署的工作负载中。
- en: Out-of-Cluster Encryption
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集群外加密
- en: 'The gist of the out-of-cluster technique is simple: pick up secret and confidential
    data from outside the cluster and transform it into a Kubernetes Secret. A lot
    of projects have been grown that implement this technique. This chapter looks
    at the three most prominent ones (as of 2023): Sealed Secrets, External Secrets,
    and sops.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 集群外技术的要义很简单：从集群外部获取秘密和机密数据，并将其转换为 Kubernetes Secret。已经有很多项目在实现这种技术。本章将着眼于三个最显著的项目（截至
    2023 年）：Sealed Secrets、External Secrets 和 sops。
- en: Sealed Secrets
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密封的密钥
- en: One of the oldest Kubernetes add-ons for helping with encrypted secrets is *Sealed
    Secrets*, introduced by Bitnami in 2017. The idea is to store the encrypted data
    for a Secret in a CustomResourceDefinition (CRD) SealedSecret. In the background,
    an operator monitors such resources and creates one Kubernetes Secret for each
    SealedSecret with the decrypted content. To learn more about CRDs and operators
    in general, check out [Chapter 28, “Operator”](ch28.html#Operator), which explains
    this pattern in detail. While the decryption happens within the cluster, the *encryption*
    happens outside by a CLI tool called `kubeseal`, which takes a Secret and translates
    it to a SealedSecret that can be stored safely in a source code management system
    like Git.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助加密秘密的最古老的 Kubernetes 附加组件之一是 *Sealed Secrets*，由 Bitnami 在 2017 年引入。其思想是将 Secret
    的加密数据存储在一个 CustomResourceDefinition（CRD）SealedSecret 中。在后台，一个操作器监视这些资源，并为每个 SealedSecret
    创建一个 Kubernetes Secret，其中包含解密后的内容。要详细了解 CRD 和操作器的一般情况，请查看[第 28 章，“操作器”](ch28.html#Operator)。虽然解密是在集群内部进行的，但
    *加密* 是在外部通过一个名为 `kubeseal` 的 CLI 工具进行的，该工具将一个 Secret 转换为一个可以安全存储在类似 Git 的源代码管理系统中的
    SealedSecret。
- en: '[Figure 25-1](#img-secure-configuration-sealed-secrets) shows the setup for
    Sealed Secrets.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-1](#img-secure-configuration-sealed-secrets) 展示了 Sealed Secrets 的设置。'
- en: '![Sealed Secrets](assets/kup2_2501.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![密封的密钥](assets/kup2_2501.png)'
- en: Figure 25-1\. Sealed Secrets
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 25-1\. 密封的密钥
- en: Secrets are encrypted with AES-256-GCM symmetrically as a session key, and the
    session key is encrypted asymmetrically with RSA-OAEP, the same setup TLS uses.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets 使用 AES-256-GCM 对称加密作为会话密钥加密，会话密钥使用 RSA-OAEP 非对称加密，与 TLS 相同的设置。
- en: The secret private key is stored within the cluster and is automatically created
    by the SealedSecret Operator. It is up to the administrator to back up this key
    and rotate it if needed. The public key used by `kubeseal` can be fetched directly
    from the cluster or accessed directly from a file. You also can safely store the
    public key in Git along with your SealedSecret.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密私钥存储在集群内部，并由 SealedSecret Operator 自动创建。管理员需要负责备份并根据需要轮转此密钥。`kubeseal` 使用的公钥可以直接从集群获取，也可以直接从文件访问。您还可以安全地将公钥与您的
    SealedSecret 一起存储在 Git 中。
- en: 'SealedSecrets support three scopes that you can select when creating a SealedSecret
    from a Secret:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 SealedSecret 时，SealedSecrets 支持三个范围可供选择：
- en: Strict
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式
- en: This freezes the namespace and name of the SealedSecret. This mode means you
    can create the SealedSecret only in the same namespace and with the same name
    as the original Secret in any target cluster. This mode is the default behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将冻结 SealedSecret 的命名空间和名称。这意味着您只能在任何目标集群中以与原始 Secret 相同的名称和相同的命名空间中创建 SealedSecret。这是默认行为。
- en: Namespace-wide
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间范围
- en: This allows you to apply the SealedSecret to a different name than the initial
    Secret but still pins it to the same namespace.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您将 SealedSecret 应用于与初始 Secret 不同的名称，但仍将其固定在相同的命名空间。
- en: Cluster-wide
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集群范围
- en: This allows you to apply the SealedSecret to different namespaces, as it was
    initially created to do, and the name can be changed too.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您将 SealedSecret 应用于不同的命名空间，正如最初创建的那样，名称也可以更改。
- en: These scopes can be selected when creating the SealedSecret with `kubeseal`.
    Still, you can also add the nonstrict scopes with the annotations listed in [Table 25-1](#table-secure-configuration-sealed-secret-annotations)
    on the original Secret before encryption or on the SealedSecret directly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `kubeseal` 创建 SealedSecret 时可以选择这些范围。但是，您也可以在加密前或直接在 SealedSecret 上使用 [表
    25-1](#table-secure-configuration-sealed-secret-annotations) 中列出的注释添加非严格范围。
- en: Table 25-1\. Annotation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 25-1\. 注释
- en: '| Annotation | Value | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 注释 | 值 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| sealedsecrets.bitnami.com/namespace-wide | `"true"` | Enable namespace-wide
    scope when set to `true`—i.e., different name but same namespace |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| sealedsecrets.bitnami.com/namespace-wide | `"true"` | 当设置为 `true` 时启用命名空间范围——即不同名称但相同命名空间
    |'
- en: '| sealedsecrets.bitnami.com/cluster-wide | `"true"` | Enable cluster-wide scope
    when set to `true`—i.e., name and namespace can be changed on the SealedSecret
    after encryption |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| sealedsecrets.bitnami.com/cluster-wide | `"true"` | 当设置为 `true` 时启用集群范围——即加密后可以更改
    SealedSecret 的名称和命名空间 |'
- en: '[Example 25-1](#ex-secure-configuration-sealed-secret-resource) shows a SealedSecret
    created by `kubeseal` that can be directly stored in Git.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 25-1](#ex-secure-configuration-sealed-secret-resource) 展示了使用 `kubeseal`
    创建的 SealedSecret，可以直接存储在 Git 中。'
- en: Example 25-1\. SealedSecret created with `kubeseal`
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 25-1\. 使用 `kubeseal` 创建的 SealedSecret
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_secure_configuration_CO1-1)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secure_configuration_CO1-1)'
- en: Command to create a SealedSecret from the secret stored in *mysecret.yaml*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令从 *mysecret.yaml* 中存储的秘密创建一个 SealedSecret。
- en: '[![2](assets/2.png)](#co_secure_configuration_CO1-2)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secure_configuration_CO1-2)'
- en: Annotation that indicates that this SealedSecret can have any name and be applied
    to any namespace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注释表明这个 SealedSecret 可以有任何名称并且可以应用于任何命名空间。
- en: '[![3](assets/3.png)](#co_secure_configuration_CO1-3)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secure_configuration_CO1-3)'
- en: The secret values are encrypted individually (and shortened here for the sake
    of demonstration).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，这里只是对密钥值进行了单独加密。
- en: A Sealed Secret is a tool that allows you to store encrypted secrets in a publicly
    available location, such as a GitHub repository. It is important to properly back
    up the secret key, as without it, it will not be possible to decrypt the secrets
    if the operator is uninstalled. One potential drawback of Sealed Secrets is that
    they require a server-side operator to be continuously running in the cluster
    in order to perform the decryption.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Sealed Secret 是一种工具，允许您将加密的秘密存储在公开可用的位置，例如 GitHub 存储库。正确备份秘密密钥非常重要，因为如果卸载操作员，则无法解密秘密。Sealed
    Secrets 的一个潜在缺点是，它们需要在集群中持续运行服务器端操作员才能执行解密操作。
- en: External Secrets
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 外部 Secrets
- en: The [External Secrets Operator](https://oreil.ly/4kC1b) is a Kubernetes operator
    that integrates a growing list of external SMSs. The main difference between External
    Secrets and Sealed Secrets is that you do not manage the encrypted data storage
    yourself but rely on an external SMS to do the hard work, including encryption,
    decryption, and secure persistence. That way, you benefit from all the features
    of your cloud’s SMS, like key rotation and a dedicated user interface. SMS also
    provides an excellent way of separating concerns so that different roles can manage
    the application deployments and the secrets separately.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[外部秘密操作员](https://oreil.ly/4kC1b)是一个 Kubernetes 操作员，集成了越来越多的外部 SMS。外部秘密与密封密钥的主要区别在于，您不管理加密数据存储，而是依赖外部
    SMS 来执行加密、解密和安全持久化等工作。这样，您就可以从云 SMS 的所有功能中受益，例如密钥轮换和专用用户界面。SMS 还提供了一个很好的分离关注点的方式，使不同的角色可以分别管理应用部署和秘密。'
- en: '[Figure 25-2](#img-secure-configuration-external-secrets) shows the External
    Secrets architecture.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-2](#img-secure-configuration-external-secrets) 展示了外部秘密的架构。'
- en: '![External Secrets](assets/kup2_2502.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![外部秘密](assets/kup2_2502.png)'
- en: Figure 25-2\. External Secrets
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 25-2\. 外部秘密
- en: 'A central operator reconciles two custom resources:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中央操作员协调两个自定义资源：
- en: SecretStore is the resource that holds the type and configuration of the external
    SMS to access. [Example 25-2](#ex-secure-configuration-external-secrets-store)
    gives an example of a store that connects to AWS Secret Manager.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SecretStore 是保存访问外部 SMS 类型和配置的资源。[示例 25-2](#ex-secure-configuration-external-secrets-store)
    提供了一个连接到 AWS Secret Manager 的存储示例。
- en: ExternalSecret references a SecretStore, and the operator will create a corresponding
    Kubernetes Secret filled with the data fetched from the external SMS. For example,
    [Example 25-3](#ex-secure-configuration-external-secrets-secret) references a
    secret in the AWS Secret Manager and exposes the value within the specified target
    Secret.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ExternalSecret 引用了一个 SecretStore，并且操作员将创建一个对应的 Kubernetes Secret，其中填充了从外部 SMS
    中获取的数据。例如，[示例 25-3](#ex-secure-configuration-external-secrets-secret) 引用了 AWS
    Secret Manager 中的一个秘密，并在指定的目标 Secret 中公开该值。
- en: Example 25-2\. SecretStore for connecting to AWS Secret Manager
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 25-2\. 连接到 AWS Secret Manager 的 SecretStore
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_secure_configuration_CO2-1)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secure_configuration_CO2-1)'
- en: Provider `aws` configures the usage of the AWS Secret Manager.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Provider `aws` 配置了使用 AWS Secret Manager。
- en: '[![2](assets/2.png)](#co_secure_configuration_CO2-2)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secure_configuration_CO2-2)'
- en: Reference to a Secret that holds the access keys for talking with the AWS Secret
    Manager. A Secret with the name `awssm-secret` contains the keys `access-key`
    and `secret-access-key` used to authenticate against the AWS Secret Manager.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 引用一个包含与 AWS Secret Manager 通信所需的访问密钥的 Secret。名为 `awssm-secret` 的 Secret 包含用于对
    AWS Secret Manager 进行身份验证的 `access-key` 和 `secret-access-key`。
- en: Example 25-3\. ExternalSecret that will be transformed into a Secret
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 25-3\. 将被转换为 Secret 的 ExternalSecret
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_secure_configuration_CO3-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secure_configuration_CO3-1)'
- en: Reference to the SecretStore object that holds the connection parameters for
    AWS Secret Manager.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SecretStore 对象的引用，该对象包含与 AWS Secret Manager 的连接参数。
- en: '[![2](assets/2.png)](#co_secure_configuration_CO3-2)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secure_configuration_CO3-2)'
- en: Name of the Secret to create.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建的 Secret 的名称。
- en: '[![3](assets/3.png)](#co_secure_configuration_CO3-3)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secure_configuration_CO3-3)'
- en: The username that will be looked up under `cluster/DB-username` in AWS Secret
    Manager and put under the key `username` in the resulting Secret.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS Secret Manager 下查找的将要被查找的用户名，并在生成的 Secret 中放置在键 `username` 下。
- en: You have a lot of flexibility in defining the mapping of the external secret
    data to the content of the mirrored Secret—for example, using a template to create
    a configuration with a particular structure. See the [External Secrets documentation](https://oreil.ly/Oj4Qq)
    for more information. One significant advantage of this solution over a client-side
    solution is that only the server-side operator knows the credentials to authenticate
    against the external SMS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义外部秘密数据映射到镜像秘密内容方面，您有很大的灵活性，例如可以使用模板创建具有特定结构的配置。有关更多信息，请参阅[外部秘密文档](https://oreil.ly/Oj4Qq)。与客户端解决方案相比，这种解决方案的一个显著优势是只有服务器端操作员知道用于对外部
    SMS 进行身份验证的凭据。
- en: The External Secrets Operator project merges several other Secret-syncing projects.
    In 2023, it is already the dominant solution for this specific use case of mapping
    and syncing an externally defined secret to a Kubernetes Secret. However, it has
    the same cost as a server-side component that runs all the time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 Secrets Operator 项目合并了几个其他同步项目。在 2023 年，它已经成为映射和同步外部定义秘密到 Kubernetes Secret
    的主要解决方案。然而，它与一直运行的服务器端组件具有相同的成本。
- en: Sops
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sops
- en: Do we need a server-side component to work with Secrets in a GitOps world where
    all resources are stored in a Git repository? Luckily, solutions exist that work
    entirely outside of a Kubernetes cluster. A pure client-side solution is [sops](https://oreil.ly/HH9GE)
    (“Secret OPerationS”) by Mozilla. Sops is not specific to Kubernetes but allows
    you to encrypt and decrypt any YAML or JSON file to safely store those in a source
    code repository. It does this by encrypting all values of such a document but
    leaving the keys untouched.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 的世界中，是否需要服务器端组件来处理 Secrets，其中所有资源都存储在 Git 存储库中？幸运的是，存在完全在 Kubernetes
    集群之外工作的解决方案。Mozilla 提供了一种名为 [sops](https://oreil.ly/HH9GE)（“Secret OPerationS”）的纯客户端解决方案。Sops
    并非专为 Kubernetes 设计，但允许您加密和解密任何 YAML 或 JSON 文件，以安全地存储它们在源代码存储库中。它通过加密文档的所有值但保持键不变来实现这一点。
- en: 'We can use various methods for encryption with sops:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方法来使用 sops 进行加密：
- en: Asymmetric local encryption via [`age`](https://oreil.ly/DH4RE) with the keys
    stored locally.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 [`age`](https://oreil.ly/DH4RE) 进行非对称本地加密，并在本地存储密钥。
- en: Storing the secret encryption key in a centralized key management system (KMS).
    Supported platforms are AWS KMS, Google KMS, and Azure Key Vault as external cloud
    providers and HashiCorp Vault as an SMS you can host on your own. The identity
    management of those platforms allows for fine-granular access control to the encryption
    key.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将密钥存储在集中式密钥管理系统（KMS）中。支持的平台包括 AWS KMS、Google KMS 和 Azure Key Vault 作为外部云提供商，以及
    HashiCorp Vault 作为您可以自行托管的 SMS。这些平台的身份管理允许对加密密钥进行精细的访问控制。
- en: Sops is a CLI tool you can run locally on your machine or within a cluster (e.g.,
    as part of a CI pipeline). Especially for the latter use case and if you are running
    in one of the big clouds, leveraging one of their KMSs provides a smooth integration.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Sops 是一个 CLI 工具，您可以在本地计算机上或集群内（例如作为 CI 流水线的一部分）运行。特别是对于后一种用例，如果您在其中一个大型云平台上运行，利用它们的
    KMS 提供了平滑的集成。
- en: '[Figure 25-3](#img-secure-configuration-sops) illustrates how sops handles
    encryption and decryption on the client side.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 25-3](#img-secure-configuration-sops) 说明了 sops 如何在客户端处理加密和解密。'
- en: '![Sops](assets/kup2_2503.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Sops](assets/kup2_2503.png)'
- en: Figure 25-3\. Sops for decrypting and encrypting resource files
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 25-3\. 用于解密和加密资源文件的 sops
- en: '[Example 25-4](#ex-secure-configuration-sops-encrypt) shows how to use sops
    to create an encrypted version of a ConfigMap.^([2](ch25.html#idm45902086415408))
    This example uses `age` and a freshly generated keypair for the encryption, which
    should be stored safely.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 25-4](#ex-secure-configuration-sops-encrypt) 展示了如何使用 sops 创建 ConfigMap
    的加密版本的示例。^([2](ch25.html#idm45902086415408)) 本示例使用 `age` 和一个新生成的密钥对进行加密，应安全地存储。'
- en: Example 25-4\. Sops for creating encrypted secrets
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 25-4\. 使用 sops 创建加密密钥的示例
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_secure_configuration_CO4-1)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secure_configuration_CO4-1)'
- en: Create a secret key with `age` and store it in *keys.txt*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `age` 创建一个秘密密钥并将其存储在 *keys.txt* 中。
- en: '[![2](assets/2.png)](#co_secure_configuration_CO4-2)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secure_configuration_CO4-2)'
- en: The ConfigMap to encrypt.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密的 ConfigMap。
- en: '[![3](assets/3.png)](#co_secure_configuration_CO4-3)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secure_configuration_CO4-3)'
- en: The `name` field is changed to `name_unencrypted` to prevent it from getting
    encrypted.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 字段更改为 `name_unencrypted` 以防止其被加密。'
- en: '[![4](assets/4.png)](#co_secure_configuration_CO4-4)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secure_configuration_CO4-4)'
- en: Call sops with the public part of the `age` key, and store the result in *configmap_encrypted.yml*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `age` 密钥的公共部分调用 sops，并将结果存储在 *configmap_encrypted.yml* 中。
- en: '[![5](assets/5.png)](#co_secure_configuration_CO4-5)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_secure_configuration_CO4-5)'
- en: Each value is replaced with an encrypted version in `ENC[...]` (output shortened
    for readability).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个值都替换为 `ENC[...]` 的加密版本（为了可读性，输出已缩短）。
- en: '[![6](assets/6.png)](#co_secure_configuration_CO4-6)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_secure_configuration_CO4-6)'
- en: The `name` of the ConfigMap is left untouched.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 的 `name` 保持不变。
- en: '[![7](assets/7.png)](#co_secure_configuration_CO4-7)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_secure_configuration_CO4-7)'
- en: An extra section, `sops` is appended to contain metadata that is needed for
    decryption.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 追加一个额外的 `sops` 部分，包含解密所需的元数据。
- en: '[![8](assets/8.png)](#co_secure_configuration_CO4-8)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_secure_configuration_CO4-8)'
- en: Encrypted session key that is used for symmetrical decryption. This key itself
    is encrypted asymmetrically by `age`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 用于对称解密的加密会话密钥。此密钥本身由`age`进行非对称加密。
- en: As you can see, every value of the ConfigMap resource gets encrypted, even those
    that are not confidential, like resource types or the name of the resource. You
    can skip the encryption for specific values by appending an `_unencrypted` suffix
    to the key (which gets stripped off later when doing the decryption).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，ConfigMap资源的每个值都被加密，即使是那些不是机密的值，如资源类型或资源名称。您可以通过在键后添加`_unencrypted`后缀（解密时会自动去除）来跳过特定值的加密。
- en: The generated *configmap_encrypted.yml* can safely be stored in Git or any other
    source control management. As shown in [Example 25-5](#ex-secure-configuration-sops-decrypt),
    you need the private key to decrypt the ciphered ConfigMap to apply it to the
    cluster.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的*configmap_encrypted.yml*可以安全地存储在Git或任何其他源代码管理工具中。正如[示例 25-5](#ex-secure-configuration-sops-decrypt)中所示，您需要私钥来解密加密的ConfigMap以应用到集群。
- en: Example 25-5\. Decrypt sops-encoded resource and apply it to Kubernetes
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 25-5\. 解密经sops编码的资源并应用到Kubernetes
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_secure_configuration_CO5-1)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secure_configuration_CO5-1)'
- en: Point sops to the private key to decrypt the session key.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解密会话密钥的关键步骤是使用私钥来解密。
- en: '[![2](assets/2.png)](#co_secure_configuration_CO5-2)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secure_configuration_CO5-2)'
- en: Decrypt and apply to Kubernetes. Note that every `_unencrypted` suffix on the
    resource keys is removed during sops decryption.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 解密并应用到Kubernetes。请注意，在sops解密期间，每个资源键上的`_unencrypted`后缀都会被移除。
- en: Sops is an excellent solution for easy GitOps-style integration of Secrets without
    worrying about installing and maintaining Kubernetes add-ons. However, while your
    configuration can now be stored securely in Git, it is essential to understand
    that as soon as those configurations have been handed over to the cluster, anybody
    with elevated access rights can read that data directly via the Kubernetes API.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Sops是一个出色的解决方案，可以轻松实现GitOps风格的秘密集成，无需担心安装和维护Kubernetes插件。但是，请注意，一旦配置被交给集群，任何具有高级访问权限的人员可以直接通过Kubernetes
    API读取这些数据。
- en: If this is not something you can tolerate, we need to dig deeper into the toolbox
    and look again at centralized SMSs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您无法容忍的事情，我们需要深入研究工具箱，并重新审视集中式SMS。
- en: Centralized Secret Management
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中式秘密管理
- en: As explained in [“How Secure Are Secrets?”](ch20.html#config-resource-secrets-secure),
    Secrets are as secure as possible. Still, any administrator with cluster-wide
    read access can read every Secret stored unencrypted. Depending on your trust
    relationship with your cluster operators and security requirements, this might
    or might not be a problem.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[《“秘密有多安全？”》](ch20.html#config-resource-secrets-secure)中解释的那样，秘密尽可能安全。尽管如此，任何具有集群范围读取权限的管理员都可以读取所有未加密存储的秘密。根据您与集群操作者的信任关系和安全要求，这可能是个问题或不是问题。
- en: Besides baking individual secret handling into your application code, an alternative
    is to keep the secure information outside the cluster in the external SMS and
    request the confidential information on demand over secure channels.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将个别秘密处理集成到您的应用代码中之外，另一个选择是将安全信息保持在集群外部的外部SMS中，并通过安全通道按需请求机密信息。
- en: There is a growing number of such SMSs out there, and every cloud provider offers
    its variant. We won’t go into many details here for those individual offerings
    but focus on the mechanism of how such systems integrate into Kubernetes. You
    will find a list of relevant products as of 2023 in [“More Information”](#sect-secure-configuration-more-information).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这类SMS的数量在不断增加，每个云提供商都提供其变体。我们不会详细介绍每个单独提供的内容，而是专注于这些系统如何集成到Kubernetes中的机制。您可以在[“更多信息”](#sect-secure-configuration-more-information)中找到截至2023年的相关产品列表。
- en: Secrets Store CSI Driver
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 秘密存储CSI驱动程序
- en: The Container Storage Interface (CSI) is a Kubernetes API for exposing storage
    systems to containerized applications. CSI shows the path for third-party storage
    providers to plug in new types of storage that can be mounted as volumes in Kubernetes.
    Of particular interest in the context of this pattern is the [Secrets Store CSI
    Driver](https://oreil.ly/vm0F3). This driver, developed and maintained by the
    Kubernetes community, allows access to various centralized SMSs and mounts them
    as regular Kubernetes volumes. The difference from a mounted Secret volume as
    described in [Chapter 20, “Configuration Resource”](ch20.html#ConfigurationResource),
    is that nothing is stored in the Kubernetes etcd database but securely outside
    the cluster.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 容器存储接口（CSI）是Kubernetes API，用于向容器化应用程序公开存储系统。CSI显示了第三方存储提供程序插入新类型的存储系统以便作为Kubernetes卷挂载的路径。在本模式的上下文中特别感兴趣的是[Secrets
    Store CSI Driver](https://oreil.ly/vm0F3)。这个由Kubernetes社区开发和维护的驱动程序允许访问各种集中式SMS，并将它们作为常规的Kubernetes卷挂载。与描述在[第20章，“配置资源”](ch20.html#ConfigurationResource)中的挂载的秘密卷的不同之处在于，没有任何内容存储在Kubernetes
    etcd数据库中，而是安全地存储在集群外部。
- en: The Secrets Store CSI Driver supports the SMS from major cloud vendors (AWS,
    Azure, and GCP) and HashiCorp Vault.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets Store CSI Driver支持主要云供应商（AWS、Azure和GCP）和HashiCorp Vault的SMS。
- en: 'The Kubernetes setup for connecting a secret manager via the CSI driver involves
    performing these two administrative tasks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过CSI驱动程序连接秘密管理器的Kubernetes设置涉及执行这两个管理任务：
- en: Installing the Secrets Store CSI Driver and configuration for accessing a specific
    SMS. Cluster-admin permissions are required for the installation process.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Secrets Store CSI Driver并配置访问特定SMS的步骤。安装过程需要集群管理员权限。
- en: Configuring access rules and policies. Several provider-specific steps need
    to be completed, but the result is that a Kubernetes service account is mapped
    to a secret manager-specific role that allows access to the secrets.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置访问规则和策略。需要完成几个特定于提供程序的步骤，但结果是将Kubernetes服务账户映射到允许访问秘密的秘密管理器特定角色。
- en: '[Figure 25-4](#img-secure-configuration-secrets-store-csi) shows the overall
    setup needed for enabling the Secrets Store CSI Driver with a HashiCorp Vault
    backend.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25-4](#img-secure-configuration-secrets-store-csi) 显示了启用具有HashiCorp Vault后端的Secrets
    Store CSI Driver所需的整体设置。'
- en: '![Secrets Store CSI Provider](assets/kup2_2504.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Secrets Store CSI Provider](assets/kup2_2504.png)'
- en: Figure 25-4\. Secrets Store CSI Driver
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图25-4\. Secrets Store CSI Driver
- en: After the setup is done, the usage of secret volumes is straightforward. First,
    you must define a SecretProviderClass, as demonstrated in [Example 25-6](#ex-secure-configuration-csi-provider).
    In this resource, you select the backend provider for the secret manager. For
    our example, we selected HashiCorp’s Vault. In the `parameters` section, the provider-specific
    configuration is added, which contains the connection parameter to the vault,
    the role to impersonate, and a pointer to the secret information that Kubernetes
    will mount into a Pod.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，使用秘密卷非常简单。首先，必须定义一个SecretProviderClass，如[例 25-6](#ex-secure-configuration-csi-provider)所示。在此资源中，选择秘密管理器的后端提供程序。在我们的示例中，我们选择了HashiCorp的Vault。在`parameters`部分中，添加了提供程序特定的配置，其中包含与Vault的连接参数、要模拟的角色以及Kubernetes将挂载到Pod中的秘密信息的指针。
- en: Example 25-6\. Configuration of how to access a secret manager
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例25-6\. 访问秘密管理器的配置示例
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_secure_configuration_CO6-1)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secure_configuration_CO6-1)'
- en: Type of provider to use (`azure`, `gcp`, `aws`, or `vault` as of 2023).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的提供者类型（截至2023年为`azure`、`gcp`、`aws`或`vault`）。
- en: '[![2](assets/2.png)](#co_secure_configuration_CO6-2)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secure_configuration_CO6-2)'
- en: Connection URL to the Vault service instance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到Vault服务实例的连接URL。
- en: '[![3](assets/3.png)](#co_secure_configuration_CO6-3)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secure_configuration_CO6-3)'
- en: Vault-specific authentication role contains the Kubernetes service account allowed
    to connect.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Vault特定的认证角色包含允许连接的Kubernetes服务账户。
- en: '[![4](assets/4.png)](#co_secure_configuration_CO6-4)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secure_configuration_CO6-4)'
- en: Name of the file that should be mapped into the mounted volume.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应该映射到挂载卷中的文件名称。
- en: '[![5](assets/5.png)](#co_secure_configuration_CO6-5)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_secure_configuration_CO6-5)'
- en: Path to the stored secret in the vault.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在保险库中的秘密路径。
- en: '[![6](assets/6.png)](#co_secure_configuration_CO6-6)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_secure_configuration_CO6-6)'
- en: Key to pick from the Vault secret.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从Vault秘密中选择的密钥。
- en: This secret manager configuration can then be referenced by its name when used
    as a Pod volume. [Example 25-7](#ex-secure-configuration-csi-pod) shows a Pod
    that mounts the secrets configured in [Example 25-6](#ex-secure-configuration-csi-provider).
    One key aspect is the service account `vault-access-sa` with which this Pod runs.
    This service account must be configured on the Vault side to be part of the role
    `database` referenced in the SecretProviderClass.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为 Pod 卷使用时，此秘密管理器配置可以通过其名称进行引用。[示例 25-7](#ex-secure-configuration-csi-pod)展示了一个挂载在
    [示例 25-6](#ex-secure-configuration-csi-provider) 配置的秘密的 Pod。一个关键的方面是服务账户 `vault-access-sa`，该
    Pod 使用该账户运行。必须在 Vault 侧配置此服务账户以成为 SecretProviderClass 中引用的 `database` 角色的一部分。
- en: You can find this Vault configuration in our complete working and self-contained
    [example](https://oreil.ly/7w89_), along with setup instructions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们完整的工作和自包含的[示例](https://oreil.ly/7w89_)中找到此 Vault 配置，以及设置说明。
- en: Example 25-7\. Pod mounting a CSI volume from Vault
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 25-7\. Pod 从 Vault 挂载 CSI 卷
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_secure_configuration_CO7-1)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secure_configuration_CO7-1)'
- en: Service account that is used to authenticate against Vault.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 用于对 Vault 进行身份验证的服务账户。
- en: '[![2](assets/2.png)](#co_secure_configuration_CO7-2)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secure_configuration_CO7-2)'
- en: Directory in which to mount the secrets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用于挂载秘密的目录。
- en: '[![3](assets/3.png)](#co_secure_configuration_CO7-3)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secure_configuration_CO7-3)'
- en: Declaration of a CSI Driver, which points to the Secret Store CSI driver.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CSI 驱动程序的声明，指向秘密存储 CSI 驱动程序。
- en: '[![4](assets/4.png)](#co_secure_configuration_CO7-4)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secure_configuration_CO7-4)'
- en: Reference to the SecretProviderClass that provides the connection to the Vault
    service.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 引用提供到 Vault 服务的 SecretProviderClass。
- en: While the setup for a CSI Secret Storage drive is quite complex, the usage is
    straightforward, and you can avoid storing confidential data within Kubernetes.
    However, there are more moving parts than with Secrets alone, so more things can
    go wrong, and it’s harder to troubleshoot.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CSI Secret Storage 驱动程序的设置非常复杂，但使用起来很简单，您可以避免在 Kubernetes 中存储机密数据。但是，比仅使用
    Secrets 更复杂，因此出错的可能性更大，而且故障排除更为困难。
- en: Let’s look at a final alternative for offering secrets to applications via well-known
    Kubernetes abstractions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过众所周知的 Kubernetes 抽象向应用程序提供秘密的最终替代方案。
- en: Pod injection
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod 注入
- en: As mentioned, an application can always access external SMSs via proprietary
    client libraries. This approach’s disadvantage is that you still have to store
    the credentials to access the SMS along your application and add a hard dependency
    within your code to a particular SMS. The CSI abstraction for projecting secret
    information into volumes visible as files for the deployed application is much
    more decoupled.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序始终可以通过专有客户端库访问外部 SMS。这种方法的缺点在于，您仍然需要存储用于访问 SMS 的凭据，并且在您的代码中为特定的 SMS
    添加了硬依赖。将秘密信息投影到可作为文件看到的卷中以供部署的应用程序使用的 CSI 抽象更为解耦。
- en: 'Alternative solutions leverage other well-known patterns described in this
    book:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 备选方案利用了本书中描述的其他众所周知的模式：
- en: An *Init Container* (see [Chapter 15](ch15.html#InitContainer)) fetches the
    confidential data from an SMS and then copies it to a shared local volume that
    is mounted by the application container. The secret data is fetched only once
    before the main container starts.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Init Container*（见[第 15 章](ch15.html#InitContainer)）从 SMS 获取机密数据，然后将其复制到由应用程序容器挂载的共享本地卷中。主容器启动之前只获取一次机密数据。'
- en: A *Sidecar* (see [Chapter 16](ch16.html#Sidecar)) syncs the secret data from
    the SMS to a local ephemeral volume that is also accessed by the application.
    The benefit of the sidecar approach is that it can update the secrets locally
    in case the SMS starts to rotate the secrets.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sidecar*（见[第 16 章](ch16.html#Sidecar)）将秘密数据从 SMS 同步到本地临时卷，应用程序也可以访问该卷。Sidecar
    方法的好处在于，它可以在 SMS 开始轮换秘密时在本地更新秘密。'
- en: You can leverage these patterns on your own for your applications, but this
    is tedious. It is much better to let an external controller inject the init container
    or sidecar into your application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自行利用这些模式为您的应用程序提供支持，但这很繁琐。更好的方法是让外部控制器注入初始化容器或 sidecar 到您的应用程序中。
- en: An excellent example of such an injector is the HashiCorp [Vault Sidecar Agent
    Injector](https://oreil.ly/T1y41). This injector is implemented as a so-called
    *mutating webhook*, a variant of a controller (see [Chapter 27, “Controller”](ch27.html#Controller)),
    that allows modification of any resource when it is created. When a Pod specification
    contains a particular, vault-specific annotation, the vault controller will modify
    this specification to add a container for syncing with Vault and to mount a volume
    for the secret data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的注入器示例是HashiCorp的[Vault Sidecar Agent Injector](https://oreil.ly/T1y41)。这个注入器被实现为所谓的*mutating
    webhook*，这是控制器的一种变体（见[第27章，“Controller”](ch27.html#Controller)），允许在创建时修改任何资源。当Pod规范包含特定的vault注解时，vault控制器将修改此规范，添加一个用于与Vault同步的容器，并挂载用于秘密数据的卷。
- en: '[Figure 25-5](#img-secure-configuration-pod-injector) visualizes this technique,
    which is entirely transparent to the user.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[图25-5](#img-secure-configuration-pod-injector)展示了这种对用户完全透明的技术。'
- en: While you still need to install the Vault Injector controller, it has fewer
    moving parts than hooking up a CSI secret storage volume with the provider deployment
    for a particular SMS product. Still, you can access all the secrets by just reading
    a file without using a proprietary client library.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您仍然需要安装Vault Injector控制器，但与为特定SMS产品的提供程序部署连接CSI秘密存储卷相比，它的移动部件更少。然而，您只需读取文件而无需使用专有客户端库即可访问所有秘密。
- en: '![Vault Injector](assets/kup2_2505.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![Vault注入器](assets/kup2_2505.png)'
- en: Figure 25-5\. Vault Injector
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图25-5\. Vault注入器
- en: Discussion
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论
- en: Now that we have seen the many ways you can make access to your confidential
    information more secure, the question is, which one is the best?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了许多使访问您的机密信息更安全的方法，问题是，哪种方法是最好的？
- en: 'As usual, it depends:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，这取决于：
- en: If your main goal is a simple way to encrypt Secrets stored in public-readable
    places like a remote Git repository, the pure *client-side* encryption that *Sops*
    offers is perfect.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的主要目标是以简单的方式加密存储在公共可读位置（如远程Git存储库）中的Secrets，那么*Sops*提供的纯*客户端*加密是完美的选择。
- en: The secret synchronization that the *External Secrets Operator* implements is
    a good choice when separating the concerns of retrieving credentials in a remote
    SMS and using them is essential.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*External Secrets Operator*实现的秘密同步在分离从远程SMS检索凭据并使用它们的关注点时是一个很好的选择。'
- en: The ephemeral volume projection of secret information provided by *Secret Storage
    CSI Providers* is the right choice for you when you want to ensure that no confidential
    information is stored permanently in the cluster except the access tokens for
    accessing external vaults.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*Secret Storage CSI Providers*提供的秘密信息的临时卷投影是您在希望确保除了用于访问外部vault的访问令牌之外在集群中永久存储任何机密信息都不被存储时的正确选择。
- en: Sidebar injections like the *Vault Sidecar Agent Injector* have the benefit
    of shielding from a direct access to an SMS. They are easily approachable at the
    cost of blurring the boundary between developers and administrator because of
    security annotations leaking into application deployment.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像*Vault Sidecar Agent Injector*这样的侧边注入器有利于防止直接访问SMS。它们易于接近，但由于安全注解泄漏到应用部署中，模糊了开发人员和管理员之间的界限。
- en: Note that the listed projects are the most prominent as of this writing in 2023.
    The landscape is constantly evolving, so by the time you read this book, there
    might be new contenders (or some existing projects might have stopped). However,
    the techniques used (client-side encryption, Secret synchronization, volume projections,
    and sidecar injections) are universal and will be part of future solutions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所列出的项目截至2023年在写作时最为突出。技术不断发展变化，因此在您阅读本书时，可能会有新的竞争者（或一些现有项目可能已经停止）。然而，使用的技术（客户端加密、秘密同步、卷投影和侧边注入）是通用的，并将成为未来解决方案的一部分。
- en: 'But a clear warning at the end: regardless of how securely and safely you can
    access your secret configuration, if somebody with evil intentions has full root
    access to your cluster and containers, a means to get to that data will always
    exist. This pattern makes these kinds of exploits as difficult as possible by
    adding an extra layer on the Kubernetes Secret abstraction.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但最后要明确警告：无论您如何安全地访问和保护您的秘密配置，如果有恶意意图的人拥有对您的集群和容器的完全root访问权限，总会存在获取这些数据的手段。通过在Kubernetes
    Secret抽象上添加额外的层，这种模式使这类利用变得尽可能困难。
- en: More Information
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: '[Secure Configuration Example](https://oreil.ly/-ROVS)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[安全配置示例](https://oreil.ly/-ROVS)'
- en: Alex Soto Bueno and Andrew Block’s *Kubernetes Secrets Management* (Manning,
    2022)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alex Soto Bueno 和 Andrew Block 的 *Kubernetes Secrets Management*（Manning，2022）
- en: '[Kubernetes: Sealed Secrets](https://oreil.ly/sLSSI)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes: Sealed Secrets](https://oreil.ly/sLSSI)'
- en: '[Sealed Secrets](https://oreil.ly/XRkqy)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sealed Secrets](https://oreil.ly/XRkqy)'
- en: '[External Secrets Operator](https://oreil.ly/2VdMM)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[External Secrets Operator](https://oreil.ly/2VdMM)'
- en: '[Kubernetes External Secrets](https://oreil.ly/VLVi8)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes 外部 Secrets](https://oreil.ly/VLVi8)'
- en: '[Sops](https://oreil.ly/HH9GE)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Sops](https://oreil.ly/HH9GE)'
- en: '[Kubernetes Secrets Store CSI Driver](https://oreil.ly/2_27G)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes Secrets Store CSI Driver](https://oreil.ly/2_27G)'
- en: '[Retrieve HashiCorp Vault Secrets with Kubernetes CSI](https://oreil.ly/NFU1g)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 Kubernetes CSI 检索 HashiCorp Vault Secrets](https://oreil.ly/NFU1g)'
- en: '[HashiCorp Vault](https://oreil.ly/JUjiP)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HashiCorp Vault](https://oreil.ly/JUjiP)'
- en: 'Secret Management Systems:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Secret 管理系统:'
- en: '[Azure Key Vault](https://oreil.ly/LWLvX)'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Azure Key Vault](https://oreil.ly/LWLvX)'
- en: '[AWS Secrets Manager](https://oreil.ly/eJ-dk)'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AWS Secrets Manager](https://oreil.ly/eJ-dk)'
- en: '[AWS Systems Manager Parameter Store](https://oreil.ly/nYaCF)'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AWS 系统管理器参数存储](https://oreil.ly/nYaCF)'
- en: '[GCP Secret Manager](https://oreil.ly/caLls)'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GCP Secret Manager](https://oreil.ly/caLls)'
- en: ^([1](ch25.html#idm45902086863808-marker)) RBAC rules are explained in detail
    in [Chapter 26, “Access Control”](ch26.html#AccessControl).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch25.html#idm45902086863808-marker)) RBAC 规则在 [第 26 章，“访问控制”](ch26.html#AccessControl)
    中有详细解释。
- en: ^([2](ch25.html#idm45902086415408-marker)) In the real world, you should use
    a Secret for this kind of confidential information, but here we use a ConfigMap
    to demonstrate that you can use *any* resource file with sops.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch25.html#idm45902086415408-marker)) 在现实世界中，你应该为这种机密信息使用一个 Secret，但这里我们使用
    ConfigMap 来演示你可以使用 *任何* 资源文件与 sops 一起使用。
