<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 18. Accessing Kubernetes from Common Programming Languages" data-type="chapter" epub:type="chapter"><div class="chapter" id="k8s_programming_languages">
<h1><span class="label">Chapter 18. </span>Accessing Kubernetes from Common Programming Languages</h1>
<p>Though most of this book is dedicated to using declarative YAML <a data-primary="programming languages, accessing Kubernetes from" data-type="indexterm" id="ix_proglng"/>configurations, either directly via <code>kubectl</code> or through tools like Helm, there are situations
when it is necessary to interact with the Kubernetes API directly from a
programming language.<a data-primary="YAML" data-secondary="declarative YAML configurations" data-type="indexterm" id="idm45664072064608"/><a data-primary="configurations" data-secondary="declarative YAML configurations" data-type="indexterm" id="idm45664072063616"/> For example, the authors of the <a href="https://helm.sh">Helm tool</a> itself needed
to write that application in a programming language.<a data-primary="Helm tool" data-type="indexterm" id="idm45664072061872"/> More generally, this is common if you need to write some additional tool, like a <code>kubectl</code> plug-in, or a more complex piece of code, like a Kubernetes operator.</p>
<p>Much of the Kubernetes ecosystem is written in the Go programming language. As a result, the Go language has the richest and most extensive client.<a data-primary="Go language" data-type="indexterm" id="idm45664072060080"/> However, there are a high-quality clients for most common programming languages (and even some uncommon ones as well). Because there is already so much documentation and so many examples of how to use the Go client, this chapter will cover the basics of interacting with the Kubernetes API server with examples in Python, Java, and .NET.</p>
<section data-pdf-bookmark="The Kubernetes API: A Client’s Perspective" data-type="sect1"><div class="sect1" id="idm45664072058736">
<h1>The Kubernetes API: A Client’s Perspective</h1>
<p>At the end of the day, the<a data-primary="programming languages, accessing Kubernetes from" data-secondary="Kubernetes API, client's perspective" data-type="indexterm" id="ix_proglngclient"/><a data-primary="clients" data-type="indexterm" id="ix_client"/> Kubernetes API server is just an HTTP(S) server and
that is exactly how each client library perceives it, though each client has a
lot of additional logic that implements the various API calls and serializes to
and from JSON. Given this, you might be tempted to simply use a plain HTTP
client to work with the Kubernetes APIs, but the client libraries wrap
these various HTTP calls into meaningful APIs that make your code more readable (e.g., <code>readNamespacedPod(...)</code>), and meaningful typed object-models that facilitate static type checking and therefore result in fewer bugs (e.g., <code>Deployment</code>). Perhaps more importantly, the client libraries also implement
Kubernetes-specific capabilities, like loading 
<span class="keep-together">authorization</span>
<span class="keep-together">information</span> from
a <em>kubeconfig</em> file or from a Pod’s environment. The clients also provide
implementations of the non-RESTful parts of the Kubernetes API surface area
like port-forward, logs, and watches. We’ll describe these advanced capabilities in later sections.</p>
<section data-pdf-bookmark="OpenAPI and Generated Client Libraries" data-type="sect2"><div class="sect2" id="idm45664072051648">
<h2>OpenAPI and Generated Client Libraries</h2>
<p>The set of resources and functions in the Kubernetes API is huge.<a data-primary="OpenAPI and generated client libraries" data-type="indexterm" id="idm45664072050256"/><a data-primary="clients" data-secondary="OpenAPI and generated client libraries" data-type="indexterm" id="idm45664072049456"/> There are many different resources in different API groups and many different operations on each of these  resources. Keeping up with all of these different resources and resource versions would be a massive (and unmistakably boring) undertaking if developers had to hand-author all of these API calls. Especially when considering that clients have to be handwritten across each of the programming languages. Instead, the clients take a different approach, and the basics of interacting with the Kubernetes API server are all generated by a computer program that is sort of like a compiler in reverse. The code generator for the API clients takes a data specification for the Kubernetes API and uses this specification to generate a client for a specific language.</p>
<p>The Kubernetes API is expressed in a format known as OpenAPI, which is the most common schema for representing RESTful APIs.<a data-primary="RESTful API" data-type="indexterm" id="idm45664072047840"/> To give you a sense of the size of the Kubernetes API, the <a href="https://oreil.ly/3gRIW">OpenAPI specification</a> found on GitHub is over four megabytes in size. That’s a pretty big text file! The official Kubernetes client libraries are all generated using the same core code generation logic, which can be found on <a href="https://oreil.ly/F39uK">GitHub</a>. It is unlikely that you will actually have to generate the client libraries yourself, but nonetheless, it is useful to understand the process by which these libraries are created. In particular, because most of the client code is generated, updates and fixes can’t be made directly in the generated client code, since it would be overwritten the next time the API was generated. Instead, when an error in a client is found, fixes need to be made to either the OpenAPI specification (if the error is in the specification itself) or the code generator (if the error is in the generated code). Although this process can seem excessively complex, it is the only way that a small number of Kubernetes client authors can keep up with the breadth of the Kubernetes API.</p>
</div></section>
<section data-pdf-bookmark="But What About kubectl x?" data-type="sect2"><div class="sect2" id="idm45664072045232">
<h2>But What About kubectl x?</h2>
<p>When you start implementing your own logic for <a data-primary="kubectl tool" data-secondary="Kubernetes API and" data-type="indexterm" id="idm45664072043536"/><a data-primary="clients" data-secondary="kubectl" data-type="indexterm" id="idm45664072042560"/>interacting with the Kubernetes API, it probably won’t be long before you find yourself asking how to do <code>kubectl x</code>. Most people start with the <code>kubectl</code> tool when they learn Kubernetes and consequently expect that there is a 1-1 mapping between the capabilities in <code>kubectl</code> and the Kubernetes API. While some commands are directly represented in the Kubernetes API (e.g., <code>kubectl get pods</code>), most of the more sophisticated features are actually a larger number of API calls with complex logic in the <code>kubectl</code> tool.</p>
<p>This balance between client-side and server-side features has been a design trade-off since the beginning of Kubernetes. Many features that are now present in the API server began as client-side implementations in <code>kubectl</code>. For example, the rollout capabilities now implemented on the server by the Deployment resource were previously implemented in the client. Likewise, until recently, <code>kubectl apply ...</code> was only available within the command-line tool, but was migrated to the server as the server-side <code>apply</code> capabilities that will be discussed later in this chapter.</p>
<p>Despite the general trajectory toward server-side implementations, there are still significant capabilities that remain in the client. Each of these capabilities must be reimplemented in each client library. Parity with the <code>kubectl</code> command line tool varies between languages. The Java client in particular has built a thick client that emulates much of the <code>kubectl</code> functionality.</p>
<p>If you can’t find the functionality that you are looking for in your client library, a useful trick is to add the <code>--v=10</code> flag to your <code>kubectl</code> command. That will turn on verbose logging, including all of the HTTP requests and responses sent to the Kubernetes API server.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="--v=10 for comprehensive logging" data-tertiary-sortas="v=10" data-type="indexterm" id="idm45664072033616"/> You can use this logging to reconstruct much of what <code>kubectl</code> is doing. If you still need to dig deeper, the <code>kubectl</code> source code is also available within the Kubernetes repository.<a data-primary="clients" data-startref="ix_client" data-type="indexterm" id="idm45664072031024"/><a data-primary="programming languages, accessing Kubernetes from" data-secondary="Kubernetes API, client's perspective" data-startref="ix_proglngclient" data-type="indexterm" id="idm45664072029968"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Programming the Kubernetes API" data-type="sect1"><div class="sect1" id="idm45664072028512">
<h1>Programming the Kubernetes API</h1>
<p>Now you have a deeper perspective about how the Kubernetes API
works and how the client and server interact.<a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-type="indexterm" id="ix_proglngpgr"/> In the following sections, we’ll
go through how to authenticate to the Kubernetes API server and interact with
resources. We’ll close with advanced topics from writing operators to
interacting with Pods for interactive operations.</p>
<section data-pdf-bookmark="Installing the Client Libraries" data-type="sect2"><div class="sect2" id="idm45664072024672">
<h2>Installing the Client Libraries</h2>
<p>Before you can start programming with the Kubernetes API, you need to find
the client libraries.<a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-tertiary="installing client libraries" data-type="indexterm" id="idm45664072023296"/><a data-primary="clients" data-secondary="installing client libraries to program Kubernetes API" data-type="indexterm" id="idm45664072021936"/> We will be using the official client libraries produced
by the Kubernetes project itself, though there are also a number of
high-quality clients developed as independent projects.<a data-primary="Python" data-secondary="client library" data-type="indexterm" id="idm45664072020640"/><a data-primary="Java" data-secondary="client library" data-type="indexterm" id="idm45664072019696"/><a data-primary="JavaScript client library" data-type="indexterm" id="idm45664072018752"/><a data-primary=".NET" data-primary-sortas="NET" data-secondary="client library" data-type="indexterm" id="idm45664072018064"/> The client libraries
are all hosted under the kubernetes-client repository on GitHub:</p>
<ul>
<li>
<p><a href="https://oreil.ly/ku6mT">Python</a></p>
</li>
<li>
<p><a href="https://oreil.ly/aUSkD">Java</a></p>
</li>
<li>
<p><a href="https://oreil.ly/9J8iy">.NET</a></p>
</li>
</ul>
<p class="pagebreak-before less_space">Each of these projects features a compatibility matrix to show which versions
of the client work with which versions of the Kubernetes API and also give
instructions for installing the libraries using the package managers (e.g.,
<code>npm</code>) associated with a particular programming language.<sup><a data-type="noteref" href="ch18.xhtml#idm45664072010864" id="idm45664072010864-marker">1</a></sup></p>
</div></section>
<section data-pdf-bookmark="Authenticating to the Kubernetes API" data-type="sect2"><div class="sect2" id="idm45664072009328">
<h2>Authenticating to the Kubernetes API</h2>
<p>The Kubernetes API server wouldn’t be very safe if it allowed anyone in the
world to access it and read or write the resources that it orchestrates.<a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-tertiary="authenticating to the Kubernetes API" data-type="indexterm" id="idm45664072007136"/>
Consequently, the first step in programming the Kubernetes API is connecting
to it and identifying yourself for authentication.<a data-primary="authentication" data-secondary="authenticating to Kubernetes API" data-type="indexterm" id="idm45664072005472"/> Because the API server is
an HTTP server at its core, these methods of authentication are core
HTTP authentication methods. The very first implementations of Kubernetes
used basic HTTP authentication via a user and password combination,
but this approach has been deprecated in favor of more
modern authentication infrastructure.</p>
<p>If you have been using the <code>kubectl</code> command-line tool for your interactions
with Kubernetes, you may not have considered the implementation details of
authentication.<a data-primary="kubectl tool" data-secondary="authentication information, obtaining" data-type="indexterm" id="idm45664072003088"/> Fortunately, the client libraries generally make it easy to connect to the
API. However, a basic understanding of how Kubernetes authentication works
is still useful for debugging when things go wrong.</p>
<p>There are two basic ways that the <code>kubectl</code> tool and clients obtain
authentication information: from a kubeconfig file and from the context of a Pod within the Kubernetes cluster.<a data-primary="clients" data-secondary="obtaining authentication information" data-type="indexterm" id="idm45664072000960"/><a data-primary="kubeconfig file for authentication information" data-type="indexterm" id="idm45664071999920"/></p>
<p>Code that is not running inside a Kubernetes cluster requires a kubeconfig
file to provide the necessary information for authentication. By default, the
client searches for this file in <em>${HOME}/.kube/config</em> or the <code>$KUBECONFIG</code>
environment variables. If the <code>KUBECONFIG</code> variable is present, it takes
precedence over any config file located in the default home location. The
kubeconfig file contains all of the information necessary to access the
Kubernetes API server.<a data-primary="Java" data-secondary="creating Kubernetes API client" data-type="indexterm" id="idm45664071997328"/><a data-primary="Python" data-secondary="creating Kubernetes API client" data-type="indexterm" id="idm45664071996336"/><a data-primary=".NET" data-primary-sortas="NET" data-secondary="creating Kubernetes API client" data-type="indexterm" id="idm45664071995376"/> The clients all have easy-to-use calls to create
a client either from the default locations or from a kubeconfig file supplied
in the code itself:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">config</code><code class="o">.</code><code class="n">load_kube_config</code><code class="p">()</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">ApiClient</code> <code class="n">client</code> <code class="o">=</code> <code class="n">Config</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">();</code>
<code class="n">Configuration</code><code class="o">.</code><code class="na">setDefaultApiClient</code><code class="o">(</code><code class="n">client</code><code class="o">);</code></pre>
<p class="pagebreak-before less_space"><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">config</code> <code class="p">=</code> <code class="n">KubernetesClientConfiguration</code><code class="p">.</code><code class="n">BuildDefaultConfig</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Kubernetes</code><code class="p">(</code><code class="n">config</code><code class="p">);</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Authentication for many cloud providers occurs via an external executable
that knows how to generate a token for the Kubernetes cluster. <a data-primary="cloud" data-secondary="authentication for cloud providers" data-type="indexterm" id="idm45664071922880"/><a data-primary="authentication" data-secondary="for cloud providers" data-secondary-sortas="cloud" data-type="indexterm" id="idm45664071930752"/>This
executable is often installed as part of the cloud provider’s command-line
tooling. When you write code to interact with the Kubernetes API, you need
to make sure that this executable is also available in the context where
the code is running so that it can be executed to obtain the token.</p>
</div>
<p>Within the context of a Pod in a Kubernetes
cluster, the code running in the Pod has access to a Kubernetes service
account that is associated with that Pod.<a data-primary="service accounts" data-type="indexterm" id="idm45664071757920"/> The files containing the
relevant token and certificate authority are placed into the Pod by Kubernetes
as a volume when the Pod is created. Within a Kubernetes cluster, the
API server is always available at a fixed DNS name, generally <code>kubernetes</code>.
Because all of the necessary data is present in the Pod, a kubeconfig file
is unnecessary and the client can synthesize its configuration from its
context.<a data-primary="Java" data-secondary="creating in-cluster client" data-type="indexterm" id="idm45664071756704"/><a data-primary="Python" data-secondary="creating in-cluster client" data-type="indexterm" id="idm45664071975632"/><a data-primary=".NET" data-primary-sortas="NET" data-secondary="creating in-cluster client" data-type="indexterm" id="idm45664071974720"/> The clients all have easy-to-use calls to create such an “in cluster” client:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">config</code><code class="o">.</code><code class="n">load_incluster_config</code><code class="p">()</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">ApiClient</code> <code class="n">client</code> <code class="o">=</code> <code class="n">ClientBuilder</code><code class="o">.</code><code class="na">cluster</code><code class="o">().</code><code class="na">build</code><code class="o">();</code>
<code class="n">Configuration</code><code class="o">.</code><code class="na">setDefaultApiClient</code><code class="o">(</code><code class="n">client</code><code class="o">);</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">config</code> <code class="p">=</code> <code class="n">KubernetesClientConfiguration</code><code class="p">.</code><code class="n">InClusterConfig</code><code class="p">()</code>
<code class="kt">var</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Kubernetes</code><code class="p">(</code><code class="n">config</code><code class="p">);</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The default service account associated with Pods has minimal roles (RBAC)
granted to it. This means that by default, the code running in a Pod can’t
do much with the Kubernetes API. If you are getting authorization errors,
you may need to adjust the service account to one that is specific to your
code and has access to the necessary roles in the cluster.</p>
</div>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Accessing the Kubernetes API" data-type="sect2"><div class="sect2" id="idm45664072008336">
<h2>Accessing the Kubernetes API</h2>
<p>The most common ways that people interact with the Kubernetes
API is via basic operations like creating, listing, and deleting resources.<a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-tertiary="accessing the Kubernetes API" data-type="indexterm" id="idm45664071679024"/>
Because all of the clients are generated from the same OpenAPI specification,
they all follow the same rough pattern. Before diving into the code, there
are a couple more details of the Kubernetes API that are necessary to
understand.</p>
<p>In Kubernetes, there is a distinction between
namespaced and cluster-level resources.<a data-primary="namespaced resources" data-type="indexterm" id="idm45664071677360"/><a data-primary="cluster-level resources" data-type="indexterm" id="idm45664071645232"/><a data-primary="resources" data-secondary="namespaced and cluster-level" data-type="indexterm" id="idm45664071644560"/> <em>Namespaced</em> resources exist within
a Kubernetes namespace; for example, a Pod or Deployment may exist in the
<code>kube-system</code> namespace. <em>Cluster-level</em> resources exist only once throughout the entire cluster. The most obvious example of such a resource is a Namespace, but other cluster-level resources include CustomResourceDefinitions and ClusterRoleBindings.<a data-primary="CustomResourceDefinition" data-type="indexterm" id="idm45664071641904"/><a data-primary="ClusterRoleBindings" data-type="indexterm" id="idm45664071641232"/> This distinction is important because it is
preserved in the function calls that you use to access the resources. For
example, to list Pods in the <code>default</code> namespace in Python, you would write
<code>api.list_namespaced_pods('default')</code>. <a data-primary="Python" data-secondary="listing Pods in default namespace" data-type="indexterm" id="idm45664071639584"/><a data-primary="namespaces" data-secondary="listing in Python" data-type="indexterm" id="idm45664071638544"/>To list Namespaces, you would write
<code>api.list_namespaces()</code>.</p>
<p>The second concept you need to understand is an <em>API group</em>. <a data-primary="API group" data-type="indexterm" id="idm45664071636160"/><a data-primary="groups" data-secondary="API group for resources" data-type="indexterm" id="idm45664071635424"/>In Kubernetes, all of the resources
are grouped into different sets of APIs. This is largely hidden from users
of the <code>kubectl</code> tool, though you may have seen it within the
<code>apiVersion</code> field in a YAML specification of a Kubernetes object. When
programming against the Kubernetes API, this grouping becomes important,
because often each API group has its own client for
interacting with that set of resources. For example, to
create a client to interact with a Deployment resource (which exists in the
<code>apps/v1</code> API group and version) you create a <code>new AppsV1Api()</code> object that
knows how to interact with all resources in the <code>apps/v1</code> API group and version. An example of how to create a client for an API group is shown in
the following section.</p>
</div></section>
<section data-pdf-bookmark="Putting It All Together: Listing and Creating Pods &#10;in Python, Java, and .NET" data-type="sect2"><div class="sect2" id="idm45664071632048">
<h2>Putting It All Together: Listing and Creating Pods 
<span class="keep-together">in Python, Java, and .NET</span></h2>
<p>We’re now ready to actually write some code.<a data-primary="Python" data-secondary="listing and creating Pods in" data-type="indexterm" id="idm45664071606288"/><a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-tertiary="listing and creating Pods" data-type="indexterm" id="idm45664071605440"/><a data-primary="Java" data-secondary="listing and creating Pods in" data-type="indexterm" id="idm45664071604304"/><a data-primary=".NET" data-primary-sortas="NET" data-secondary="listing and creating Pods in" data-type="indexterm" id="idm45664071603344"/> Begin by creating
a client object, then use that to list the Pods in the “default” namespace; here is code to do that in Python, Java, and .NET:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">config</code><code class="o">.</code><code class="n">load_kube_config</code><code class="p">()</code>
<code class="n">api</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">CoreV1Api</code><code class="p">()</code>
<code class="n">pod_list</code> <code class="o">=</code> <code class="n">api</code><code class="o">.</code><code class="n">list_namespaced_pod</code><code class="p">(</code><code class="s1">'default'</code><code class="p">)</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">ApiClient</code> <code class="n">client</code> <code class="o">=</code> <code class="n">Config</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">();</code>
<code class="n">Configuration</code><code class="o">.</code><code class="na">setDefaultApiClient</code><code class="o">(</code><code class="n">client</code><code class="o">);</code>
<code class="n">CoreV1Api</code> <code class="n">api</code> <code class="o">=</code> <code class="k">new</code> <code class="n">CoreV1Api</code><code class="o">();</code>
<code class="n">V1PodList</code> <code class="n">list</code> <code class="o">=</code> <code class="n">api</code><code class="o">.</code><code class="na">listNamespacedPod</code><code class="o">(</code><code class="s">"default"</code><code class="o">);</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">config</code> <code class="p">=</code> <code class="n">KubernetesClientConfiguration</code><code class="p">.</code><code class="n">BuildDefaultConfig</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Kubernetes</code><code class="p">(</code><code class="n">config</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">list</code> <code class="p">=</code> <code class="n">client</code><code class="p">.</code><code class="n">ListNamespacedPod</code><code class="p">(</code><code class="s">"default"</code><code class="p">);</code></pre>
<p>Once you have figured out how to list, read, and delete objects, the next
common task is creating new objects. The API call to create the object
is easy enough to figure out (e.g., <code>create_namespaced_pod</code> in Python), but
actually defining the new Pod resources can be more complicated.</p>
<p>Here’s how you create a Pod in Python, Java, and .NET:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">container</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">V1Container</code><code class="p">(</code>
     <code class="n">name</code><code class="o">=</code><code class="s2">"myapp"</code><code class="p">,</code>
     <code class="n">image</code><code class="o">=</code><code class="s2">"my_cool_image:v1"</code><code class="p">,</code>
 <code class="p">)</code>


<code class="n">pod</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">V1Pod</code><code class="p">(</code>
    <code class="n">metadata</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">V1ObjectMeta</code><code class="p">(</code>
      <code class="n">name</code><code class="o">=</code><code class="s2">"myapp"</code><code class="p">,</code>
    <code class="p">),</code>
    <code class="n">spec</code><code class="o">=</code><code class="n">client</code><code class="o">.</code><code class="n">V1PodSpec</code><code class="p">(</code><code class="n">containers</code><code class="o">=</code><code class="p">[</code><code class="n">container</code><code class="p">]),</code>
<code class="p">)</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">V1Pod</code> <code class="n">pod</code> <code class="o">=</code>
    <code class="k">new</code> <code class="nf">V1PodBuilder</code><code class="o">()</code>
        <code class="o">.</code><code class="na">withNewMetadata</code><code class="o">().</code><code class="na">withName</code><code class="o">(</code><code class="s">"myapp"</code><code class="o">).</code><code class="na">endMetadata</code><code class="o">()</code>
        <code class="o">.</code><code class="na">withNewSpec</code><code class="o">()</code>
          <code class="o">.</code><code class="na">addNewContainer</code><code class="o">()</code>
            <code class="o">.</code><code class="na">withName</code><code class="o">(</code><code class="s">"myapp"</code><code class="o">)</code>
            <code class="o">.</code><code class="na">withImage</code><code class="o">(</code><code class="s">"my_cool_image:v1"</code><code class="o">)</code>
          <code class="o">.</code><code class="na">endContainer</code><code class="o">()</code>
        <code class="o">.</code><code class="na">endSpec</code><code class="o">()</code>
        <code class="o">.</code><code class="na">build</code><code class="o">();</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">pod</code> <code class="p">=</code> <code class="k">new</code> <code class="n">V1Pod</code><code class="p">()</code>
<code class="p">{</code>
    <code class="n">Metadata</code> <code class="p">=</code> <code class="k">new</code> <code class="n">V1ObjectMeta</code><code class="p">{</code> <code class="n">Name</code> <code class="p">=</code> <code class="s">"myapp"</code><code class="p">,</code> <code class="p">},</code>
    <code class="n">Spec</code> <code class="p">=</code> <code class="k">new</code> <code class="n">V1PodSpec</code>
    <code class="p">{</code>
        <code class="n">Containers</code> <code class="p">=</code> <code class="k">new</code><code class="p">[]</code> <code class="p">{</code>
          <code class="k">new</code> <code class="nf">V1Container</code><code class="p">()</code> <code class="p">{</code>
            <code class="n">Name</code> <code class="p">=</code> <code class="s">"myapp"</code><code class="p">,</code> <code class="n">Image</code> <code class="p">=</code> <code class="s">"my_cool_image:v1"</code><code class="p">,</code>
          <code class="p">},</code>
        <code class="p">},</code>
    <code class="p">}</code>
 <code class="p">};</code></pre>
</div></section>
<section data-pdf-bookmark="Creating and Patching Objects" data-type="sect2"><div class="sect2" id="idm45664071631424">
<h2>Creating and Patching Objects</h2>
<p>When you explore the client API for Kubernetes, you will notice that there are seemingly three different ways to manipulate resources,
namely <code>create</code>, <code>replace</code>, and <code>patch</code>. <a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-tertiary="creating and patching objects" data-type="indexterm" id="idm45664071253088"/><a data-primary="resources" data-secondary="creating, patching, and replacing" data-type="indexterm" id="idm45664071251904"/>These three verbs represent slightly different semantics for interacting with resources:</p>
<dl>
<dt>Create</dt>
<dd>
<p>As you can tell from the name, this creates a new resource. However, it will fail if the resource already exists.<a data-primary="creating resources" data-type="indexterm" id="idm45664071211552"/></p>
</dd>
<dt>Replace</dt>
<dd>
<p>This replaces an existing resource completely, without looking at the existing resource.<a data-primary="replacing resources" data-type="indexterm" id="idm45664071209520"/> When you use <code>replace</code>, you have to specify a complete resource.</p>
</dd>
<dt>Patch</dt>
<dd>
<p>This modifies an existing resource, leaving untouched the parts of the resource that did not change.<a data-primary="patching resources" data-type="indexterm" id="idm45664071206848"/> When using <code>patch</code>, you use a special Patch resource rather than sending the resource (e.g., the Pod) that you are modifying.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Patching a resource can be complicated. In many cases, it is easier to just replace it. However, in some
cases, especially with large resources, patching the resource can be much more
efficient in terms of network bandwidth and API server processing.
Additionally, multiple actors can patch
different parts of the resource simultaneously without
worrying about write conflicts, which reduces overhead.</p>
</div>
<p>To patch a Kubernetes resource, you have to create a Patch object representing
the change that you want to make to the resource. There are three
formats for this patch supported by Kubernetes: JSON Patch, JSON Merge
Patch, and strategic merge patch. The first two patch formats are RFC
standards used in other places, and the third is a Kubernetes-developed patch
format. Each of the patch formats has advantages and disadvantages. In
these examples, we will use JSON Patch because it is the simplest to
understand.</p>
<p>Here’s how you patch<a data-primary="Java" data-secondary="patching a Deployment" data-type="indexterm" id="idm45664071203376"/><a data-primary="deployments" data-secondary="patching a Deployment" data-type="indexterm" id="idm45664071202368"/><a data-primary="Python" data-secondary="patching a Deployment" data-type="indexterm" id="idm45664071201424"/> a Deployment to increase the replicas to three:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">deployment</code><code class="o">.</code><code class="n">spec</code><code class="o">.</code><code class="n">replicas</code> <code class="o">=</code> <code class="mi">3</code>

<code class="n">api_response</code> <code class="o">=</code> <code class="n">api_instance</code><code class="o">.</code><code class="n">patch_namespaced_deployment</code><code class="p">(</code>
    <code class="n">name</code><code class="o">=</code><code class="s2">"my-deployment"</code><code class="p">,</code>
    <code class="n">namespace</code><code class="o">=</code><code class="s2">"some-namespace"</code><code class="p">,</code>
    <code class="n">body</code><code class="o">=</code><code class="n">deployment</code><code class="p">)</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="c1">// JSON-patch format</code>
<code class="kd">static</code> <code class="n">String</code> <code class="n">jsonPatch</code> <code class="o">=</code>
  <code class="s">"[{\"op\":\"replace\",\"path\":\"/spec/replicas\",\"value\":3}]"</code><code class="o">;</code>

<code class="n">V1Deployment</code> <code class="n">patched</code> <code class="o">=</code>
          <code class="n">PatchUtils</code><code class="o">.</code><code class="na">patch</code><code class="o">(</code>
              <code class="n">V1Deployment</code><code class="o">.</code><code class="na">class</code><code class="o">,</code>
              <code class="o">()</code> <code class="o">-&gt;</code>
                  <code class="n">api</code><code class="o">.</code><code class="na">patchNamespacedDeploymentCall</code><code class="o">(</code>
                      <code class="s">"my-deployment"</code><code class="o">,</code>
                      <code class="s">"some-namespace"</code><code class="o">,</code>
                      <code class="k">new</code> <code class="nf">V1Patch</code><code class="o">(</code><code class="n">jsonPatchStr</code><code class="o">),</code>
                      <code class="kc">null</code><code class="o">,</code>
                      <code class="kc">null</code><code class="o">,</code>
                      <code class="kc">null</code><code class="o">,</code>
                      <code class="kc">null</code><code class="o">,</code>
                      <code class="kc">null</code><code class="o">),</code>
              <code class="n">V1Patch</code><code class="o">.</code><code class="na">PATCH_FORMAT_JSON_PATCH</code><code class="o">,</code>
              <code class="n">api</code><code class="o">.</code><code class="na">getApiClient</code><code class="o">());</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">jsonPatch</code> <code class="p">=</code> <code class="s">@"</code>
<code class="s">[{</code>
<code class="s">    ""op"": ""replace"",</code>
<code class="s">    ""path"": ""/spec/replicas"",</code>
<code class="s">    ""value"": 3</code>
<code class="s">}]"</code><code class="p">;</code>

<code class="n">client</code><code class="p">.</code><code class="n">PatchNamespacedPod</code><code class="p">(</code>
  <code class="k">new</code> <code class="nf">V1Patch</code><code class="p">(</code><code class="n">patchStr</code><code class="p">,</code> <code class="n">V1Patch</code><code class="p">.</code><code class="n">PatchType</code><code class="p">.</code><code class="n">JsonPatch</code><code class="p">),</code>
  <code class="s">"my-deployment"</code><code class="p">,</code>
  <code class="s">"some-namespace"</code><code class="p">);</code></pre>
<p>In each of these code<a data-primary=".NET" data-primary-sortas="NET" data-secondary="patching a Deployment" data-type="indexterm" id="idm45664070986032"/> samples, the Deployment resource has been patched to
set the number of replicas in the deployment to three.</p>
</div></section>
<section data-pdf-bookmark="Watching Kubernetes APIs for Changes" data-type="sect2"><div class="sect2" id="idm45664071255344">
<h2>Watching Kubernetes APIs for Changes</h2>
<p>Resources in Kubernetes are declarative.<a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-tertiary="watching Kubernetes APIs for changes" data-type="indexterm" id="idm45664071022352"/><a data-primary="watching Kubernetes APIs for changes" data-type="indexterm" id="idm45664071021200"/> They represent the desired state
of the system. To make that desired state a reality, a program must watch
the desired state for changes and take action to make the current state of
the world match the desired state.</p>
<p>Because of this pattern, one of the most common tasks when programming against the Kubernetes API is
to watch for changes to a resource and then take some action based on those
changes. The easiest way to do this is through polling.<a data-primary="polling" data-type="indexterm" id="idm45664071020048"/> <em>Polling</em> simply calls
the list function described above at a constant interval (such as every 60
seconds) and enumerates all of the resources that the code is interested in.
While this code is easy to write, it has numerous drawbacks for both the
client code and the API server. Polling introduces unnecessary latency, since
waiting for the polling cycle to come around introduces delays for changes
that occur just after the previous poll completed. Additionally, polling
causes heavier load on the API server because it repeatedly returns resources
that haven’t changed. While many simple clients begin by using polling, too
many clients polling the API server can overload it and add latency.</p>
<p>To solve this problem, the Kuberentes API also provides <em>watch</em>, or
event-based, semantics.<a data-primary="events" data-secondary="watch or event-based semantics" data-type="indexterm" id="idm45664071017968"/>
Using a <code>watch</code> call, you can register interest in specific changes with the
API server and, instead of repeatedly polling, the API server will send
notifications whenever a change occurs. In practical terms, the client
performs a hanging GET to the HTTP API server. The TCP connection that
underlies this HTTP request stays open for the duration of the watch, and
the server writes a response to that stream (but does not close the stream)
whenever a change occurs.</p>
<p>From a programmatic perspective, <code>watch</code> semantics enable event-based
programming, changing a <code>while</code> loop that repeatedly polls into a collection
of callbacks. <a data-primary="Java" data-secondary="watching Pods for changes" data-type="indexterm" id="idm45664071015232"/><a data-primary="Python" data-secondary="watching Pods for changes" data-type="indexterm" id="idm45664071014192"/>Here are examples of watching Pods for changes:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">config</code><code class="o">.</code><code class="n">load_kube_config</code><code class="p">()</code>
<code class="n">api</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">CoreV1Api</code><code class="p">()</code>
<code class="n">w</code> <code class="o">=</code> <code class="n">watch</code><code class="o">.</code><code class="n">Watch</code><code class="p">()</code>

<code class="k">for</code> <code class="n">event</code> <code class="ow">in</code> <code class="n">w</code><code class="o">.</code><code class="n">stream</code><code class="p">(</code><code class="n">v1</code><code class="o">.</code><code class="n">list_namespaced_pods</code><code class="p">,</code> <code class="s2">"some-namespace"</code><code class="p">):</code>
  <code class="nb">print</code><code class="p">(</code><code class="n">event</code><code class="p">)</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting">    <code class="n">ApiClient</code> <code class="n">client</code> <code class="o">=</code> <code class="n">Config</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">();</code>
    <code class="n">CoreV1Api</code> <code class="n">api</code> <code class="o">=</code> <code class="k">new</code> <code class="n">CoreV1Api</code><code class="o">();</code>

    <code class="n">Watch</code><code class="o">&lt;</code><code class="n">V1Namespace</code><code class="o">&gt;</code> <code class="n">watch</code> <code class="o">=</code>
        <code class="n">Watch</code><code class="o">.</code><code class="na">createWatch</code><code class="o">(</code>
            <code class="n">client</code><code class="o">,</code>
            <code class="n">api</code><code class="o">.</code><code class="na">listNamespacedPodCall</code><code class="o">(</code>
                <code class="s">"some-namespace"</code><code class="o">,</code>
                <code class="kc">null</code><code class="o">,</code>
                <code class="kc">null</code><code class="o">,</code>
                <code class="kc">null</code><code class="o">,</code>
                <code class="kc">null</code><code class="o">,</code>
                <code class="kc">null</code><code class="o">,</code>
                <code class="n">Integer</code><code class="o">.</code><code class="na">MAX_VALUE</code><code class="o">,</code>
                <code class="kc">null</code><code class="o">,</code>
                <code class="kc">null</code><code class="o">,</code>
                <code class="mi">60</code><code class="o">,</code>
                <code class="n">Boolean</code><code class="o">.</code><code class="na">TRUE</code><code class="o">);</code>
            <code class="k">new</code> <code class="n">TypeToken</code><code class="o">&lt;</code><code class="n">Watch</code><code class="o">.</code><code class="na">Response</code><code class="o">&lt;</code><code class="n">V1Pod</code><code class="o">&gt;&gt;()</code> <code class="o">{}.</code><code class="na">getType</code><code class="o">());</code>

    <code class="k">try</code> <code class="o">{</code>
      <code class="k">for</code> <code class="o">(</code><code class="n">Watch</code><code class="o">.</code><code class="na">Response</code><code class="o">&lt;</code><code class="n">V1Pod</code><code class="o">&gt;</code> <code class="n">item</code> <code class="o">:</code> <code class="n">watch</code><code class="o">)</code> <code class="o">{</code>
        <code class="n">System</code><code class="o">.</code><code class="na">out</code><code class="o">.</code><code class="na">printf</code><code class="o">(</code>
          <code class="s">"%s : %s%n"</code><code class="o">,</code> <code class="n">item</code><code class="o">.</code><code class="na">type</code><code class="o">,</code> <code class="n">item</code><code class="o">.</code><code class="na">object</code><code class="o">.</code><code class="na">getMetadata</code><code class="o">().</code><code class="na">getName</code><code class="o">());</code>
      <code class="o">}</code>
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>
      <code class="n">watch</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>
    <code class="o">}</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">config</code> <code class="p">=</code> <code class="n">KubernetesClientConfiguration</code><code class="p">.</code><code class="n">BuildConfigFromConfigFile</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Kubernetes</code><code class="p">(</code><code class="n">config</code><code class="p">);</code>

<code class="kt">var</code> <code class="n">watch</code> <code class="p">=</code>
  <code class="n">client</code><code class="p">.</code><code class="n">ListNamespacedPodWithHttpMessagesAsync</code><code class="p">(</code><code class="s">"default"</code><code class="p">,</code> <code class="n">watch</code><code class="p">:</code> <code class="k">true</code><code class="p">);</code>
<code class="k">using</code> <code class="p">(</code><code class="n">watch</code><code class="p">.</code><code class="n">Watch</code><code class="p">&lt;</code><code class="n">V1Pod</code><code class="p">,</code> <code class="n">V1PodList</code><code class="p">&gt;((</code><code class="n">type</code><code class="p">,</code> <code class="n">item</code><code class="p">)</code> <code class="p">=&gt;</code>
<code class="p">{</code>
  <code class="n">Console</code><code class="p">.</code><code class="n">WriteLine</code><code class="p">(</code><code class="n">item</code><code class="p">);</code>
<code class="p">}</code></pre>
<p>In each of these examples, rather <a data-primary=".NET" data-primary-sortas="NET" data-secondary="watching Pods for changes" data-type="indexterm" id="idm45664070740416"/>than a repetitive polling loop, the
watch API call delivers each change to a resource to a callback provided by
the user. This both reduces latency and load on the Kubernetes API server.</p>
</div></section>
<section data-pdf-bookmark="Interacting with Pods" data-type="sect2"><div class="sect2" id="idm45664071023424">
<h2>Interacting with Pods</h2>
<p>The Kubernetes API also provides functions for directly interacting with the
applications running in a Kubernetes Pod.<a data-primary="Pods" data-secondary="interacting with" data-type="indexterm" id="idm45664070656672"/><a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-tertiary="interacting with Pods" data-type="indexterm" id="idm45664070655696"/>
The <code>kubectl</code> tool provides a number of
commands for interacting with Pods, namely <code>logs</code>, <code>exec</code>, and <code>port-forward</code>,
and it is possible to use each of these from within custom code as well.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Because the <code>logs</code>, <code>exec</code>, and <code>port-forward</code> APIs are nonstandard in
a RESTful sense, they
require custom logic in the client libraries and are thus somewhat less
consistent between the different clients. Unfortunately, there is no option
other than learning the implementation for each language.</p>
</div>
<p>When getting the logs for a Pod, you have to decide if you are going to
read the Pod logs to get a snapshot of their current state or if you are going to stream them to receive new logs as they happen. If you
stream the logs (the equivalent of <code>kubectl logs -f ...</code>), you
create an open connection to the API server, and new log lines are written
to this stream as they are written to the Pod. If not, you simply receive
the current contents of the logs.<a data-primary="logs" data-secondary="reading and streaming logs for a Pod" data-type="indexterm" id="idm45664070649200"/><a data-primary="Java" data-secondary="reading and streaming logs for a Pod" data-type="indexterm" id="idm45664070648256"/><a data-primary="Python" data-secondary="reading and streaming logs for a Pod" data-type="indexterm" id="idm45664070647344"/></p>
<p>Here’s how you both read and stream the logs:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">config</code><code class="o">.</code><code class="n">load_kube_config</code><code class="p">()</code>
<code class="n">api</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">CoreV1Api</code><code class="p">()</code>
<code class="n">log</code> <code class="o">=</code> <code class="n">api_instance</code><code class="o">.</code><code class="n">read_namespaced_pod_log</code><code class="p">(</code>
  <code class="n">name</code><code class="o">=</code><code class="s2">"my-pod"</code><code class="p">,</code> <code class="n">namespace</code><code class="o">=</code><code class="s2">"some-namespace"</code><code class="p">)</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">V1Pod</code> <code class="n">pod</code> <code class="o">=</code> <code class="o">...;</code> <code class="c1">// some code to define or get a Pod here</code>
<code class="n">PodLogs</code> <code class="n">logs</code> <code class="o">=</code> <code class="k">new</code> <code class="n">PodLogs</code><code class="o">();</code>
<code class="n">InputStream</code> <code class="n">is</code> <code class="o">=</code> <code class="n">logs</code><code class="o">.</code><code class="na">streamNamespacedPodLog</code><code class="o">(</code><code class="n">pod</code><code class="o">);</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="n">IKubernetes</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Kubernetes</code><code class="p">(</code><code class="n">config</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">response</code> <code class="p">=</code> <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">ReadNamespacedPodLogWithHttpMessagesAsync</code><code class="p">(</code>
    <code class="s">"my-pod"</code><code class="p">,</code> <code class="s">"my-namespace"</code><code class="p">,</code> <code class="n">follow</code><code class="p">:</code> <code class="k">true</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">stream</code> <code class="p">=</code> <code class="n">response</code><code class="p">.</code><code class="n">Body</code><code class="p">;</code></pre>
<p>Another <a data-primary=".NET" data-primary-sortas="NET" data-secondary="reading and streaming logs for a Pod" data-type="indexterm" id="idm45664070528640"/>common task is to execute some command within a Pod and get the
output of running that task. You can use the <code>kubectl exec ...</code> command
on the command line.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="exec" data-type="indexterm" id="idm45664070513920"/> Under the hood, the API that implements this is creating
a WebSocket connection to the API server.<a data-primary="WebSockets" data-type="indexterm" id="idm45664070483088"/> WebSockets enable multiple streams
of data (in this case, <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>) to coexist on the same
HTTP connection. If you’ve never had experience with WebSockets, don’t
worry; the details of interacting with WebSockets are handled by the
client libraries.<a data-primary="Python" data-secondary="exec the ls /foo command in a Pod" data-type="indexterm" id="idm45664070481312"/><a data-primary="Java" data-secondary="exec the ls /foo command in a Pod" data-type="indexterm" id="idm45664070480464"/></p>
<p>Here’s how you execute the <code>ls /foo</code> command in a Pod:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">cmd</code> <code class="o">=</code> <code class="p">[</code> <code class="s1">'ls'</code><code class="p">,</code> <code class="s1">'/foo'</code> <code class="p">]</code>
<code class="n">response</code> <code class="o">=</code> <code class="n">stream</code><code class="p">(</code>
    <code class="n">api_instance</code><code class="o">.</code><code class="n">connect_get_namespaced_pod_exec</code><code class="p">,</code>
    <code class="s2">"my-pod"</code><code class="p">,</code>
    <code class="s2">"some-namespace"</code><code class="p">,</code>
    <code class="n">command</code><code class="o">=</code><code class="n">cmd</code><code class="p">,</code>
    <code class="n">stderr</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code>
    <code class="n">stdin</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code>
    <code class="n">stdout</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code>
    <code class="n">tty</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">ApiClient</code> <code class="n">client</code> <code class="o">=</code> <code class="n">Config</code><code class="o">.</code><code class="na">defaultClient</code><code class="o">();</code>
<code class="n">Configuration</code><code class="o">.</code><code class="na">setDefaultApiClient</code><code class="o">(</code><code class="n">client</code><code class="o">);</code>
<code class="n">Exec</code> <code class="n">exec</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Exec</code><code class="o">();</code>
<code class="kd">final</code> <code class="n">Process</code> <code class="n">proc</code> <code class="o">=</code>
  <code class="n">exec</code><code class="o">.</code><code class="na">exec</code><code class="o">(</code><code class="s">"some-namespace"</code><code class="o">,</code>
            <code class="s">"my-pod"</code><code class="o">,</code>
            <code class="k">new</code> <code class="n">String</code><code class="o">[]</code> <code class="o">{</code><code class="s">"ls"</code><code class="o">,</code> <code class="s">"/foo"</code><code class="o">},</code>
            <code class="kc">true</code><code class="o">,</code>
            <code class="kc">true</code> <code class="cm">/*tty*/</code><code class="o">);</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">config</code> <code class="p">=</code> <code class="n">KubernetesClientConfiguration</code><code class="p">.</code><code class="n">BuildConfigFromConfigFile</code><code class="p">();</code>
<code class="n">IKubernetes</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Kubernetes</code><code class="p">(</code><code class="n">config</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">webSocket</code> <code class="p">=</code>
    <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">WebSocketNamespacedPodExecAsync</code><code class="p">(</code>
      <code class="s">"my-pod"</code><code class="p">,</code> <code class="s">"some-namespace"</code><code class="p">,</code> <code class="s">"ls /foo"</code><code class="p">,</code> <code class="s">"my-container-name"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">demux</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamDemuxer</code><code class="p">(</code><code class="n">webSocket</code><code class="p">);</code>
<code class="n">demux</code><code class="p">.</code><code class="n">Start</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">stream</code> <code class="p">=</code> <code class="n">demux</code><code class="p">.</code><code class="n">GetStream</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">1</code><code class="p">);</code></pre>
<p>In addition<a data-primary=".NET" data-primary-sortas="NET" data-secondary="exec the ls /foo command in a Pod" data-type="indexterm" id="idm45664070265696"/> to running commands in a Pod, you can also port-forward network
connections from a Pod to code running on the local machine. Like <code>exec</code>, the
port-forwarded traffic goes over a WebSocket. It is up to your code what
it does with this port-forwarded socket. You could simply send a single
request and receive a response as a string of bytes, or you could build
a complete proxy server (like what <code>kubectl port-forward</code> does) to serve
arbitrary requests through this proxy.</p>
<p>Regardless of what you intend to do with the connection, here’s<a data-primary="port forwarding" data-secondary="setting up in Java, Python, and .NET" data-type="indexterm" id="idm45664070236352"/><a data-primary="Java" data-secondary="setting up port forwarding" data-type="indexterm" id="idm45664070235376"/><a data-primary="Python" data-secondary="setting up port forwarding" data-type="indexterm" id="idm45664070234464"/> how you
set up port-forwarding:</p>
<p><em>Python</em></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">pf</code> <code class="o">=</code> <code class="n">portforward</code><code class="p">(</code>
    <code class="n">api_instance</code><code class="o">.</code><code class="n">connect_get_namespaced_pod_portforward</code><code class="p">,</code>
    <code class="s1">'my-pod'</code><code class="p">,</code> <code class="s1">'some-namespace'</code><code class="p">,</code>
    <code class="n">ports</code><code class="o">=</code><code class="s1">'8080'</code><code class="p">,</code>
<code class="p">)</code></pre>
<p><em>Java</em></p>
<pre data-code-language="java" data-type="programlisting"><code class="n">PortForward</code> <code class="n">fwd</code> <code class="o">=</code> <code class="k">new</code> <code class="n">PortForward</code><code class="o">();</code>

<code class="n">List</code><code class="o">&lt;</code><code class="n">Integer</code><code class="o">&gt;</code> <code class="n">ports</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ArrayList</code><code class="o">&lt;&gt;();</code>
<code class="kt">int</code> <code class="n">localPort</code> <code class="o">=</code> <code class="mi">8080</code><code class="o">;</code>
<code class="kt">int</code> <code class="n">targetPort</code> <code class="o">=</code> <code class="mi">8080</code><code class="o">;</code>
<code class="n">ports</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">targetPort</code><code class="o">);</code>
<code class="kd">final</code> <code class="n">PortForward</code><code class="o">.</code><code class="na">PortForwardResult</code> <code class="n">result</code> <code class="o">=</code>
    <code class="n">fwd</code><code class="o">.</code><code class="na">forward</code><code class="o">(</code><code class="s">"some-namespace"</code><code class="o">,</code> <code class="s">"my-pod"</code><code class="o">,</code> <code class="n">ports</code><code class="o">);</code></pre>
<p><em>.NET</em></p>
<pre data-code-language="csharp" data-type="programlisting"><code class="kt">var</code> <code class="n">config</code> <code class="p">=</code> <code class="n">KubernetesClientConfiguration</code><code class="p">.</code><code class="n">BuildConfigFromConfigFile</code><code class="p">();</code>
<code class="n">IKubernetes</code> <code class="n">client</code> <code class="p">=</code> <code class="k">new</code> <code class="n">Kubernetes</code><code class="p">(</code><code class="n">config</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">webSocket</code> <code class="p">=</code> <code class="k">await</code> <code class="n">client</code><code class="p">.</code><code class="n">WebSocketNamespacedPodPortForwardAsync</code><code class="p">(</code>
  <code class="s">"some-namespace"</code><code class="p">,</code> <code class="s">"my-pod"</code><code class="p">,</code> <code class="k">new</code> <code class="kt">int</code><code class="p">[]</code> <code class="p">{</code><code class="m">8080</code><code class="p">},</code> <code class="s">"v4.channel.k8s.io"</code><code class="p">);</code>
<code class="kt">var</code> <code class="n">demux</code> <code class="p">=</code> <code class="k">new</code> <code class="n">StreamDemuxer</code><code class="p">(</code><code class="n">webSocket</code><code class="p">,</code> <code class="n">StreamType</code><code class="p">.</code><code class="n">PortForward</code><code class="p">);</code>
<code class="n">demux</code><code class="p">.</code><code class="n">Start</code><code class="p">();</code>
<code class="kt">var</code> <code class="n">stream</code> <code class="p">=</code> <code class="n">demux</code><code class="p">.</code><code class="n">GetStream</code><code class="p">((</code><code class="kt">byte?</code><code class="p">)</code><code class="m">0</code><code class="p">,</code> <code class="p">(</code><code class="kt">byte?</code><code class="p">)</code><code class="m">0</code><code class="p">);</code></pre>
<p>Each of these examples creates a<a data-primary=".NET" data-primary-sortas="NET" data-secondary="setting up port forwarding" data-type="indexterm" id="idm45664070058208"/> connection from port
8080 in a Pod to port 8080 in your program. The code returns the byte streams necessary, communicating across this port-forwarding channel. You can use
these streams for sending and receiving messages.<a data-primary="programming languages, accessing Kubernetes from" data-secondary="programming the Kubernetes API" data-startref="ix_proglngpg" data-type="indexterm" id="idm45664070006432"/></p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect2"><div class="sect2" id="idm45664070657936">
<h2>Summary</h2>
<p>The Kubernetes API provides rich and powerful functionality for you to
write custom code. Writing your applications
in the language that best suits a task or a persona shares
the power of the orchestration API with as many
Kubernetes users as possible. When you’re ready to move beyond scripting calls
to the <code>kubectl</code> executable, the Kubernetes client libraries provide a way
to dive deep into the API to build an operator, a monitoring agent, a new user
interface, or whatever your imagination can dream up.<a data-primary="programming languages, accessing Kubernetes from" data-startref="ix_proglng" data-type="indexterm" id="idm45664070004000"/></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45664072010864"><sup><a href="ch18.xhtml#idm45664072010864-marker">1</a></sup> We did not include <a href="https://oreil.ly/8mw5F">JavaScript</a> examples for brevity, but it is also actively developed.</p></div></div></section></div></body></html>