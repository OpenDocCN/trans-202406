<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Dates and Fixed Income Securities"><div class="chapter" id="idm45807806646688">
<h1><span class="label">Chapter 4. </span>Dates and Fixed Income Securities</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45807806645712">
<h5>A Note for Early Release Readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 9th chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <em>learnmodcppfinance@gmail.com</em>.</p>
</div></aside>

<p>Dates and date calculations might not seem like the most compelling topic to discuss, but they are vitally important in quantitative finance, particularly in fixed income trading and analytics.</p>

<p>As with distributional random number generation in the past, financial C++ programmers were left with similar options:  either write their own date classes and functions or use a commercial or open source external library.  This has changed with C++20.  It includes a date class that is determined by the integer year, month, and day values.  This class relies both on the already existing (since C++11) <code>std::chrono</code> foundation of durations, timepoints, and the system clock – ie, chronological computations – as well as calendrical computations, which are based on the number of days relative to the epoch and take into account the non-uniform number of days in each month.</p>

<p>While the goal of this chapter is to demonstrate how to use the new date features in financial applications, the author of <code>std::chrono</code>, Howard Hinnant, provides more details on his GitHub site containing the original development code for <code>std::chrono</code> dates{1}.  (This will be referred to as “the GitHub date code site” going forward).</p>

<p>Adding years and months can be effected by using calendrical options in <code>std::chrono</code>, but adding days requires conversion to a chronological timepoint.  These are important operations to be discussed in due course, but first let us cover how dates are represented and instantiated in C++20.  From there, we will look at common date calculations that are required in finance, a class that encapsulates the functions for us, day count conventions and yield curves, and finally an application in valuing a coupon-paying bond.</p>






<section data-type="sect1" data-pdf-bookmark="Representation of a Date"><div class="sect1" id="idm45807806637968">
<h1>Representation of a Date</h1>

<p>C++11 introduced the <code>std::chrono</code> library into the Standard Library, which provided the following abstractions:</p>

<ul>
<li>
<p>Duration of time:  A method of measurement over a given time interval, such as in units of minutes, days, milliseconds, etc</p>
</li>
<li>
<p>Timepoint:  A duration of time relative to an epoch, such as the UNIX epoch 1970-1-1</p>
</li>
<li>
<p>Clock:  The object that specifies the epoch and normalizes duration measurements {0}</p>
</li>
</ul>

<p>Dates in <code>std::chrono</code> are based on these chronological foundations, but as part of the new C++20 features, conversions to calendrical forms are also now available.  These can be used for calculations involving years and months.</p>

<p>A standard date in <code>std::chrono</code> is represented by an object of the class <code>std::chrono::year_month_day</code>.  There are a variety of constructors for this class, among which several are discussed here.</p>

<p>First, a constructor taking in the year, month, and day is provided.  But instead of integer values for each, these constructor arguments must be defined as separate <code>std::chrono::year</code>, <code>std::chrono::month</code>, and <code>std::chrono::day</code> objects.
For example, to create an object holding the date 14 November 2002, we would create it as follows.</p>

<pre data-type="programlisting">import &lt;chrono&gt;;

std::chrono::year_month_day ymd{ std::chrono::year{2002},
	std::chrono::month{11}, std::chrono::day{14} };</pre>

<p>Alternatively, individual constant <code>month</code> objects are defined in <code>std::chrono</code> by name, so an equivalent approach to constructing the same month above is to replace the constructed month object in the previous example with the pre-defined <code>November</code> instance:</p>

<pre data-type="programlisting">std::chrono::year_month_day ymd_alt{ std::chrono::year{2002},
	std::chrono::November, std::chrono::day(14) };</pre>

<p>For assignment, the <code>/</code> operator has also been overloaded to define a <code>year_month_day</code> object:</p>

<pre data-type="programlisting">ymd = std::chrono::year{ 2002 } / std::chrono::month{11} / std::chrono::day{14};</pre>

<p>Different orders can be used, along with integer types, as long as the first argument is obvious.  For yyyy/mm/dd format, putting</p>

<pre data-type="programlisting">ymd = std::chrono::year{ 2002 } / 11 / 14;</pre>

<p>would yield the same result, with the compiler interpreting the 11 and 14 as <code>unsigned</code> types.  mm/dd/yyyy format can also be used:
<code>auto mdy = std::chrono::November / 14 / 2002;</code></p>

<p>In this case, the 14 is recognized as <code>unsigned</code>, and the year as an <code>int</code>.  In <code>std::chrono</code>, <code>month</code> and <code>day</code> types can be cast to <code>unsigned</code>, while a <code>year</code> can only be cast to an <code>int</code>.
The examples above are non-exhaustive, and a more comprehensive list can be found on the GitHub date code site{1}.</p>

<p>Note that the output stream operator is overloaded for <code>year_month_day</code>, so any of the above can be output to the console with <code>cout</code>.  For example,</p>

<pre data-type="programlisting">cout &lt;&lt; ymd &lt;&lt; endl;</pre>

<p>will display the date on the screen as
<code>2002-11-14</code></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="1.1 Serial Representation and Date Differences"><div class="sect1" id="idm45807806612400">
<h1>1.1 Serial Representation and Date Differences</h1>

<p>A <code>year_month_day</code> date can also be measured in terms of the number of days since an epoch, with the <code>system_clock</code> default being the UNIX epoch January 1, 1970.  Similar to Excel – whose epoch is January 1, 1900 – this representation can be convenient for certain types of date arithmetic in finance, particularly in determining the number of days between two dates.  Unlike Excel, however, the UNIX epoch is represented by 0 rather than 1, in the sense that serial dates are measured in <em>days since the epoch</em>.  Consider the following example, with dates 1970-1-1 and 1970-1-2.</p>

<pre data-type="programlisting">std::chrono::year_month_day epoch{ date::year{1970}, date::month{1}, date::day{1} };
std::chrono::year_month_day epoch_plus_1{ date::year{1970}, date::month{1}, date::day{2} };</pre>

<p>Then, the respective serial dates can be accessed as follows:</p>

<pre data-type="programlisting">int first_days_test =
	std::chrono::sys_days(epoch).time_since_epoch().count();		// 0

first_days_test =
	std::chrono::sys_days(epoch_plus_1).time_since_epoch().count();	// 1</pre>

<p>These return <code>int</code> values 0 and 1, respectively.
Also unlike Excel, <code>std::chrono</code> dates before the epoch are also valid but carry a negative integer value.  In the statement that follows, the returned value is -1.</p>

<pre data-type="programlisting">first_days_test =
	std::chrono::sys_days(epoch_minus_1).time_since_epoch().count();	// -1</pre>

<p>For typical financial trading, it is usually not necessary to go back before 1970, but in some fields, such as actuarial valuations of pension liabilities, many retirees were born before this date.  Historical simulations of markets also might use data going back many decades.</p>

<p>Recalling that the <code>year_month_day</code> class is built upon the three <code>std::chrono</code> abstractions listed at the outset, technically what is happening here is the <code>sys_days</code> operator returns the <code>ymd</code> date as a <code>std::chrono::time_point</code> object, where <code>sys_days</code> is an alias for <code>time_point</code>.  Then, its <code>time_since_epoch</code> member function returns a <code>std::chrono::duration</code> type.  The corresponding integer value is then accessed with the <code>count</code> function.</p>

<p>An important calculation to have in finance is the number of days between two dates.  Using <code>ymd</code> again as 2002-11-14, and initializing <code>ymd_later</code> to six months later – 2003-5-14 – take the difference between the two <code>sys_days</code> objects obtained with <code>sys_days</code> and apply the <code>count</code> function to the difference:</p>

<pre data-type="programlisting">// ymd = 2002-11-14
// ymd_later = 2003-5-14

auto diff = (std::chrono::sys_days(ymd_later) –
	std::chrono::sys_days(ymd)).count();		// 181</pre>

<p>The result of 181 is again returned as an <code>int</code>.</p>

<p>Next, when working with dates, there are several checks that are often necessary to perform, namely whether a date is valid, whether it is in a leap year, finding the number of days in a month, and whether a date is a weekend.  Some of the machinery for this is immediate with functions conveniently contained in <code>std::chrono</code>, but in other cases, there will be a little more work involved.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="1.2 Accessor Functions for Year, Month, and Day"><div class="sect1" id="idm45807806592720">
<h1>1.2 Accessor Functions for Year, Month, and Day</h1>

<p>Accessor functions on <code>year_month_day</code> are provided for obtaining the year, month and day, but they are returned as their respective <code>year</code>, <code>month</code>, and <code>day</code> objects.</p>

<pre data-type="programlisting">year()		// returns std::chrono::year
month()		// returns std::chrono::month
day()		// returns std::chrono::day</pre>

<p>Suppose we have two <code>year_month_day</code> objects <code>date1</code> and <code>date2</code>  Then, conveniently, applying the <code>count</code> function on the difference (a <code>duration</code>), the results are <code>int</code> types.</p>

<pre data-type="programlisting">(date2.year() - date1.year()).count()		// returns int
(date2.month() - date1.month()).count()		// returns int
(date2.day() - date1.day()).count()			// returns int</pre>

<p>Each of the individually accessed year, month, and day components can also be cast to integers (in the mathematical sense), but an important point to be aware of is a <code>year</code> can be cast to an <code>int</code>, but for a <code>month</code> or <code>day</code>, these need to be cast to <code>unsigned</code>.</p>

<pre data-type="programlisting">auto the_year = static_cast&lt;int&gt;(date1.year());
auto the_month = static_cast&lt;unsigned&gt;(date1.month());
auto the_day = static_cast&lt;unsigned&gt;(date1.day());</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Going forward, for convenience we will use the namespace alias
<code>namespace date = std::chrono;</code></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="1.3&#9;Validity of a Date"><div class="sect1" id="idm45807806579120">
<h1>1.3	Validity of a Date</h1>

<p>It is possible to set <code>year_month_day</code> objects to invalid dates.  For example, as will be seen shortly, adding a month to a date of January 31 will result in February 31.  In addition, the constructor will also allow month and day values out of range.  Instead of throwing an exception, it is left up to the programmer to check if a date is valid.  Fortunately, this is easily accomplished with the boolean <code>ok</code> member function.  In the following example, the <code>ymd</code> date (same as above) is valid, while the two that follow are obviously not.</p>

<pre data-type="programlisting">// date is now an alias for std::chrono

date::year_month_day ymd{ date::year{2002},
	date::month{11}, date::day{14} };

bool torf = ymd.ok();			// true

date::year_month_day negative_year{ date::year{-1000},
	date::October, date::day{10} };

torf = negative_year.ok();		// true – negative year is valid

date::year_month_day ymd_invalid{ date::year{2018},
	date::month{2}, date::day{31} };

torf = ymd_invalid.ok();			// false

date::year_month_day ymd_completely_bogus{ date::year{-2004},
	date::month{19}, date::day{58} };

torf = ymd_completely_bogus.ok();	// false</pre>

<p>The <code>ok</code> member function will come in handy in subsequent examples, particularly in cases where a date operation results in the correct year and month, but an incorrect day setting in end-of-the month cases.  This will be addressed shortly.  The upshot is it is up to the consumer of the <code>year_month_day</code> class to check for validity, as it does not throw an exception or adjust automatically.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="1.4&#9;Leap Years and Last Day of the Month"><div class="sect1" id="idm45807806573328">
<h1>1.4	Leap Years and Last Day of the Month</h1>

<p>You can easily check whether a date is a leap year or not.  A boolean member function, not surprisingly called <code>is_leap</code>, takes care of this for us:</p>

<pre data-type="programlisting">date::year_month_day ymd_leap{ date::year{2016},
	date::month{10}, date::day{26} };

torf = ymd_leap.year().is_leap()		// true</pre>

<p>There is no member function available on <code>year_month_day</code> that will return the last day of the month.  A workaround exists using a separate class in std::chrono that represents an end-of-month date, <code>year_month_day_last</code>, from which the last day of its month can also be accessed as before, and then cast to unsigned.</p>

<pre data-type="programlisting">date::year_month_day_last
	eom_apr{ date::year{ 2009 } / date:April / date::last };

auto last_day = static_cast&lt;unsigned&gt;(eom_apr.day());	// result = 30</pre>

<p>This can also be used as a device to check whether a date falls on the end of a month:</p>

<pre data-type="programlisting">date::year_month_day ymd_eom{ date::year{2009},
	date::month{4}, date::day{30} };

bool torf = ymd_eom == eom_apr;		// Returns true (torf = "true or false")</pre>

<p>The last day of the month for an arbitrary date can also be determined:</p>

<pre data-type="programlisting">date::year_month_day ymd = date::year{ 2024 } / 2 / 21;

year_month_day_last
	eom{ date::year{ ymd.year() } / date::month{ ymd.month() } / date::last };

last_day = static_cast&lt;unsigned&gt;(eom.day());	// result = 29</pre>

<p>It should also be noted a <code>year_month_day_last</code> type is implicitly convertible to a <code>year_month_day</code> via reassignment:</p>

<pre data-type="programlisting">ymd = eom_apr;			// ymd is now 2009-04-30</pre>

<p>More background can be found in {2}.</p>

<p>Although this works, it carries the overhead of creating a <code>year_month_day_last</code> each time it is called, and additional object copy if reassigned, as shown in the last line of the code example just above.  While your mileage may vary, it is possible this could have a negative performance impact in financial systems managing heavy trading volume and large portfolios containing fixed income securities.</p>

<p>A set of “<code>chrono</code>-Compatible Low-Level Date Algorithms” is provided elsewhere on the the GitHub date code site{3}.  These alternatives apply methods that are independent of <code>year_month_day</code> class methods, and their description in the documentation states these low level algorithms are “key algorithms that enable one to write their own date class”.  This is the direction in which we are eventually headed.</p>

<p>To determine the last day of the month, a more efficient user-defined function can be derived from code provided in this set of algorithms, as follows:</p>

<pre data-type="programlisting">// User-defined last_day_of_the_month
unsigned last_day_of_the_month(const std::chrono::year_month_day&amp; ymd)
{
    constexpr std::array&lt;unsigned, 12&gt;
        normal_end_dates{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    if (!(ymd.month() == date::February &amp;&amp; ymd.year().is_leap()))
    {
        unsigned m = static_cast&lt;unsigned&gt;(ymd.month());
        return normal_end_dates[m - 1];
    }
    else
    {
        return 29;
    }
}</pre>

<p>This is more of a brute force approach in hard-coding the days in each month of a non-leap year, but it does obviate additional object creation and copying.</p>

<p>One other point is the use here of <code>constexpr</code>, another language feature added to C++11.  Because the length of the <code>array</code> and its contents are known a priori, <code>constexpr</code> instructs the compiler to initialize <code>end_dates</code> at compile time, thus eliminating re-initialization every time the <code>last_day_of_the_month</code> function is called.  Two related points follow:</p>
<ol>
<li>
<p>Using <code>constexpr</code> in this specific case may or may not have a significant impact on performance, but it is possible in cases where the function is called many times in  computationally intensive code, such as in portfolio risk simulations and calculations.</p>
</li>
<li>
<p>Most financial data, such as market and trade data, will be inevitably dynamic and thus unknown at compile time, so <code>constexpr</code> may be of limited use in financial applications.  The example above, however, demonstrates an example of how and when it can potentially be used effectively.</p>
</li>

</ol>
</div></section>






<section data-type="sect1" data-pdf-bookmark="1.5&#9;Weekdays and Weekends"><div class="sect1" id="idm45807806551200">
<h1>1.5	Weekdays and Weekends</h1>

<p>Similar to end of the month dates, there is no member function to check whether a date falls on a weekend.  There is again a workaround from which we can derive the result we need.</p>

<p><code>std::chrono</code> contains a <code>weekday</code> class that represents the day of the week – Monday through Sunday – not just weekdays per se (the terminology here might be slightly confusing).  It can be constructed by again applying the <code>sys_days</code> operator in the constructor argument.</p>

<pre data-type="programlisting">// Define a year_month_day date that falls on a business day (Wednesday)

date::year_month_day ymd_biz_day{ date::year{2022},
	date::month{10}, date::day{26} };	// Wednesday

// Its day of the week can be constructed as a weekday object:
date::weekday dw{ date::sys_days(ymd_biz_day) };</pre>

<p>The day of the week can be identified by an <code>unsigned</code> integer value returned from the <code>iso_encoding</code> member function, where values 1 through 7 represent Monday through Sunday, respectively.  The stream operator is overloaded so that the abbreviated day of the week is displayed.</p>

<pre data-type="programlisting">unsigned iso_code = dw.iso_encoding();
cout &lt;&lt; ymd_biz_day &lt;&lt; ", " &lt;&lt; dw &lt;&lt; ", " &lt;&lt; iso_code &lt;&lt; endl;</pre>

<p>The output is then
<code>2022-10-26, Wed, 3</code>
This allows us to define our own function, in this case a lambda, to determine whether a date falls on a weekend or not.</p>

<pre data-type="programlisting">auto is_weekend = [](const date::year_month_day&amp; ymd)-&gt;bool
{
	date::weekday dw{ date::sys_days(ymd) };
	return dw.iso_encoding() &gt;= 6;
};</pre>

<p>Now, also construct a <code>year_month_day</code> date that falls on a Saturday:</p>

<pre data-type="programlisting">date::year_month_day ymd_weekend{ date::year{2022},
	date::month{10}, date::day{29} };	// Saturday</pre>

<p>Then, we can use the lambda to test whether each day is a business day or not.</p>

<pre data-type="programlisting">torf = is_weekend(ymd_biz_day);		// false (Wed)
torf = is_weekend(ymd_weekend);		// true (Sat)</pre>

<p>Supplemental information on weekends in <code>std::chrono</code> can be found in {4}.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="1.6 Adding Years, Months, and Days"><div class="sect1" id="idm45807806538432">
<h1>1.6 Adding Years, Months, and Days</h1>

<p>One more set of important date operations of finance is adding years, months, and days to existing dates.  These are particularly useful for generating schedules of fixed payments.  Adding years or months is very similar – relying on the <code>+=</code> operator – but adding days involves a different approach.</p>








<section data-type="sect2" data-pdf-bookmark="1.6.1&#9;Adding Years"><div class="sect2" id="idm45807806536240">
<h2>1.6.1	Adding Years</h2>

<p>Adding years is very straightforward.  For example, add two years to 2002-11-14, and then add another 18 years to the result.  Note that the number of years being added needs to be expressed as a <code>std::chrono::years</code> object, an alias for a <code>duration</code> representing one year.</p>

<pre data-type="programlisting">// Start with 2002-11-14
date::year_month_day ymd{ date::year{2002}, date::month{11}, date::day{14} };

ymd += date::years{ 2 };		// ymd is now 2004-11-14
ymd += date::years{ 18 };		// ymd is now 2022-11-14</pre>

<p>We run into a problem, however, if the date is the last day of February in a leap year.  Adding two years to 2016-02-29 results in an invalid year.</p>

<pre data-type="programlisting">date::year_month_day
	ymd_feb_end{ date::year{2016}, date::month{2}, date::day{29} };

ymd_feb_end += date::years{ 2 };	// Invalid result: 2018-02-29</pre>

<p>Dates in <code>std::chrono</code> will again neither throw an exception or adjust the day, so it is up to the developer to handle the case where years are added to a February 29 date in a leap year.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="1.6.2&#9;Adding Months and End-of-the-Month Cases"><div class="sect2" id="idm45807806530160">
<h2>1.6.2	Adding Months and End-of-the-Month Cases</h2>

<p>Adding months to a <code>year_month_day</code> object is similar to adding years, but this now requires handling multiple end-of-month edge cases due to different numbers of days in different months, plus again the case of a February in a leap year.</p>

<p>When no end-of-month date is involved, the operation is straightforward, similar to adding years, using the addition assignment operator.  Similar to adding years, the number of months needs to be represented as a <code>duration</code> object, in this case an alias for a period of one month.</p>

<pre data-type="programlisting">date::year_month_day ymd{ date::year{2002}, date::month{11}, date::day{14} };
ymd += date::months(1);			// Result: 2002-12-14
ymd += date::months(18);		// Result: 2004-06-14</pre>

<p>Subtraction assignment is also available:</p>

<pre data-type="programlisting">ymd -= date::months(2);		// Result: 2004-04-14</pre>

<p>With end-of-the-month cases as well, the <code>+=</code> operation can again result in invalid dates.  To see this, construct the following end-of-month dates:</p>

<pre data-type="programlisting">date::year_month_day ymd_eom_1{ date::year{2015}, date::month{1},
	date::day{31} };
date::year_month_day ymd_eom_2{ date::year{2014}, date::month{8},
	date::day{31} };
date::year_month_day ymd_eom_3{ date::year{2016}, date::month{2},
	date::day{29} };</pre>

<p>Naively attempting month addition results in invalid dates:</p>

<pre data-type="programlisting">ymd_eom_1 += date::months{ 1 };		// 2015-02-31 is not a valid date
ymd_eom_2 += date::months{ 1 };		// 2014-09-31 is not a valid date
ymd_eom_3 += date::months{ 12 };	// 2017-02-29 is not a valid date</pre>

<p>Although the results are not valid, the year and month of each is correct.  That is, for example, adding one month to 2015-01-31 should map to 2015-02-28.</p>

<p>Going the other way, if we were to start on 2015-02-28 and add one month, the result will be correct:  2015-03-28.</p>

<p>Recalling the <code>last_day_of_the_month</code> function defined previously, a workaround is fairly straightforward.  Addition assignment is naively applied, but if the result is invalid, it must be due to the day value exceeding the actual number of days in a month.  In this case, because the resulting year and month will be valid, it just becomes a case of resetting the day with the number of days in the month.</p>

<pre data-type="programlisting">auto add_months = [](date::year_month_day&amp; ymd, unsigned mths) -&gt; void
{
    ymd += date::months(mths);    // Naively attempt the addition

    if (!ymd.ok())
    {
        ymd = ymd.year() / ymd.month() / date::day{ last_day_of_the_month(ymd) };
    }
}</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="1.6.3&#9;Adding Days"><div class="sect2" id="idm45807806517904">
<h2>1.6.3	Adding Days</h2>

<p>Unlike for years and months, there is no <code>+=</code> operator defined for adding days.  For this reason, we will need to obtain the <code>sys_days</code> equivalent before adding the number of days.</p>

<pre data-type="programlisting">date::year_month_day ymd{date::year(2022), date::month(10), date::day(7)};

// Obtain the sys_days equivalent of ymd, and then add three days:
auto add_days = date::sys_days(ymd3) + date::days(3);  // ymd still = 2022/10/07</pre>

<p>Note that at this point, <code>ymd</code> has not been modified, and the result, <code>add_days</code>, is also a <code>sys_days</code> type.  To set a <code>year_month_day</code> object to the equivalent, the assignment operator provides implicit conversion.  Similar to previous applications of <code>sys_days</code>, we can just update the original <code>ymd</code> date to three days later:</p>

<pre data-type="programlisting">ymd = add_days;	// Implicit conversion to year_month_day
				// ymd is now = 2022-10-10</pre>

<p>More information on adding days can be found in {5}.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="A Date Class Wrapper"><div class="sect1" id="idm45807806509600">
<h1>A Date Class Wrapper</h1>

<p>As you can probably see by now, managing all the intricacies of <code>std::chrono</code> dates can eventually become complicated.  For this reason, we will now outline the typical requirements for financial date calculations and declare them in a class based on a <code>year_month_day</code> member.  This way, the adjustments and <code>year_month_day</code> function calls are implemented once behind interfacing member functions and operators that are arguably more intuitive for the consumer.
These can be divided into two broad categories, namely checking possible states of a date, and performing arithmetic operations on dates.  A summary of what we have covered so far is provided in the list of requirements below.  Most of these results will be integrated into the class implementation.</p>

<p><strong>State</strong></p>

<ul>
<li>
<p>Days in month</p>
</li>
<li>
<p>Leap year</p>
</li>
</ul>

<p><strong>Arithmetic Operations</strong></p>

<ul>
<li>
<p>Number of days between two dates</p>
</li>
<li>
<p>Addition</p>

<ul>
<li>
<p>Years</p>
</li>
<li>
<p>Days</p>
</li>
<li>
<p>Months</p>
</li>
</ul>
</li>
</ul>

<p>Additional functionality that we will want to have is listed next.  These additional requirements will be also be part of the implementation.</p>

<p><strong>Accessors</strong></p>

<ul>
<li>
<p>Year, Month, Day</p>
</li>
<li>
<p>Serial date integer representation (days since epoch)</p>
</li>
<li>
<p><code>year_month_day</code> data member</p>
</li>
</ul>

<p><strong>Comparison operators</strong></p>

<pre data-type="programlisting">==
&lt;=&gt;</pre>

<p>To begin, the class declaration will give us an implementation roadmap to follow.</p>








<section data-type="sect2" data-pdf-bookmark="Class Declaration"><div class="sect2" id="idm45807806490944">
<h2>Class Declaration</h2>

<p>We will incorporate the requirements listed above into a class called <code>ChronoDate</code>.  It will wrap a <code>std::chrono::year_month_day</code> object along with some of its associated member functions that are useful in financial calculations.  The only other data member will be the serial date representation of the date object.</p>

<p>Before working through the member functions, let us start with the constructors.</p>










<section data-type="sect3" data-pdf-bookmark="Constructors"><div class="sect3" id="idm45807806487840">
<h3>Constructors</h3>

<p>For convenience, a constructor is provided that takes in integer values for year, month, and day, rather than requiring the user to create individual <code>year</code>, <code>month</code>, and <code>day</code> objects.
ChronoDate{ int year, unsigned month, unsigned day };
Note that the argument for the year is an <code>int</code>, while those for the month and day are <code>unsigned</code>.  This is due to the design of the <code>year_month_day</code> class, as previously discussed.</p>

<p>As we will see for convenience later, a second constructor will take in a <code>year_month_day</code> object:</p>

<pre data-type="programlisting">ChronoDate{ date::year_month_day };</pre>

<p>And finally, a default constructor will construct a <code>ChronoDate</code> set to the UNIX epoch.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Public Member Functions and Operators"><div class="sect2" id="idm45807806480464">
<h2>Public Member Functions and Operators</h2>

<p>These should mostly be self-explanatory from the member function declarations below.  Furthermore, it will mainly be a case of integrating the previously developed functionality into the respective member functions.  As for the comparison operators <code>==</code> and ```&lt;⇒```, as well as the friend stream operator, these are already defined on the <code>year_month_day</code> class, so it is simply a matter of wrapping them into the same operators on <code>ChronoDate</code>.</p>

<p>There is one remaining public function in the declaration not yet covered, <code>weekend_roll</code>, which will be used to roll a date to the nearest business day in the event a date falls on a Saturday or Sunday.  Its implementation will be covered shortly.</p>

<pre data-type="programlisting">// Check state:
int days_in_month() const;
bool leap_year() const;

// Arithmetic operations:
unsigned operator - (const ChronoDate&amp; rhs) const;
ChronoDate&amp; add_years(int rhs_years);
ChronoDate&amp; add_months(int rhs_months);
ChronoDate&amp; add_days(int rhs_days);

// Accessors
int year() const;
unsigned month() const;
unsigned day() const;
int serial_date() const;
date::year_month_day ymd() const;

// Modfying function
ChronoDate&amp; weekend_roll(); 		 // Roll to business day if weekend

// Operators
bool operator == (const ChronoDate&amp; rhs) const;
std::strong_ordering operator &lt;=&gt; (const ChronoDate&amp; rhs) const;

// friend operator so that we can output date details with cout
friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const ChronoDate&amp; rhs);</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Private Members and Helper Function"><div class="sect2" id="idm45807805810576">
<h2>Private Members and Helper Function</h2>

<p>Two private member variables will store the underlying <code>year_month_day</code> object and serial representation of the date.  One private function will wrap the function calls required to obtain the number of days since the UNIX epoch, so that the serial date can be set at construction, as well as updated anytime the state of an object of the class is modified.</p>

<pre data-type="programlisting">private:
    date::year_month_day date_;
    int serial_date_;
    void reset_serial_date_();</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Class Implementation"><div class="sect2" id="idm45807805807392">
<h2>Class Implementation</h2>

<p>As we have almost all of the necessary functionality, what remains is mostly a case of wrapping it into the member functions, plus implementing the <code>weekend_roll</code> function and a couple of private helper functions.  In addition, two constructors are presented, as well as the private <code>reset_serial_date_</code> method that will calculate and set the serial representation of the date, either at construction, or whenever the state of an active <code>ChronoDate</code> is modified.</p>










<section data-type="sect3" data-pdf-bookmark="Constructors"><div class="sect3" id="idm45807805804240">
<h3>Constructors</h3>

<p>The implementation of the first declared constructor allows one to create an instance of <code>ChronoDate</code> with integer values (<code>int</code> and <code>unsigned</code>) rather than require individual instances of <code>year</code>, <code>month</code>, and <code>day</code> objects.</p>

<pre data-type="programlisting">ChronoDate::ChronoDate(int year, unsigned month, unsigned day) :
	date_{ date::year{year} / date::month{month} / date::day{day} }
{
	if(!date_.ok())		// std::chrono member function to check if valid date
	{
		throw std::exception e{ "ChronoDate constructor: Invalid date." };
	}
	reset_serial_date_();
}</pre>

<p>Recall also that because it is possible to construct invalid <code>year_month_day</code> objects, such as February 30, a validation check is also included in the constructor, utilizing the <code>ok</code> member function on <code>year_month_day</code>.  One more setting that needs to occur when a date is constructed is the serial date.  This is delegated to the private method  <code>reset_serial_date_</code>.  As shown at the outset of the chapter, this is an application of  <code>sys_days</code> operator to provide the number of days since the UNIX epoch.</p>

<pre data-type="programlisting">void ChronoDate::reset_serial_date_()
{
	serial_date_ = date::sys_days(date_).time_since_epoch().count();
}</pre>

<p>This function will also be called from each modifying member function.</p>

<p>Finally, the default constructor just sets the date to the UNIX epoch, and initializes the serial date to 0:</p>

<pre data-type="programlisting">ChronoDate::ChronoDate():date_{date::year(1970), date::month{1}, date::day{1} } :
    serial_date_{0} {}</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Member Functions and Operators"><div class="sect3" id="idm45807805793120">
<h3>Member Functions and Operators</h3>

<p>The following describes implementation of the functions previously introduced in the declaration section.</p>












<section data-type="sect4" data-pdf-bookmark="Accessors"><div class="sect4" id="idm45807805791552">
<h4>Accessors</h4>

<p>Implementation of accessors for the serial date and <code>year_month_day</code> members is trivial, but a little more work is involved in returning integer values for the year, month, and day.  a <code>std::chrono::year</code> object can be cast to an <code>int</code>, while <code>month</code> and <code>day</code> are castable to <code>unsigned</code> types.  With this in mind, their accessors are straightforward to implement:</p>

<pre data-type="programlisting">int ChronoDate::year() const
{
	return static_cast&lt;int&gt;(date_.year());
}

unsigned ChronoDate::month() const
{
	return static_cast&lt;unsigned&gt;(date_.month());
}

unsigned ChronoDate::day() const
{
	return static_cast&lt;unsigned&gt;(date_.day());
}</pre>
</div></section>












<section data-type="sect4" data-pdf-bookmark="State Methods"><div class="sect4" id="idm45807805786096">
<h4>State Methods</h4>

<p>Checking whether a date is in a leap year simply involves wrapping the respective <code>year_month_day</code> member function.</p>

<pre data-type="programlisting">bool ChronoDate::leap_year() const
{
	return date_.year().is_leap();
}</pre>

<p>Obtaining the number of days in the month is more involved, but it is just a rehash of the function adapted from the <code>std::chrono</code> low-level algorithms in Section [1.4].</p>

<pre data-type="programlisting">unsigned ChronoDate::days_in_month() const
{
	unsigned m = static_cast&lt;unsigned&gt;(date_.month());
	std::array&lt;unsigned, 12&gt;
        normal_end_dates{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

	return (m != 2 || !date_.year().is_leap() ? normal_end_dates[m - 1] : 29);
}</pre>
</div></section>












<section data-type="sect4" data-pdf-bookmark="Arithmetic Operations"><div class="sect4" id="idm45807805781216">
<h4>Arithmetic Operations</h4>

<p>These are the core member functions that will be used for typical fixed income applications, such as in calculating year fractions and generating payment schedules.
To start, let us revisit calculation of the number of days between two dates.  As we already store the serial date on the class and update it only at construction or when a date is modified, we can remove the <code>sys_days</code> conversions and function calls, and implement the subtraction operator as the difference between the integer equivalents.</p>

<pre data-type="programlisting">unsigned ChronoDate::operator - (const ChronoDate&amp; rhs) const
{
	return this-&gt;serial_date_ - rhs.serial_date_;
}</pre>

<p>Adding years and months are also pretty straightforward, as we now have ways to handle pesky end-of-month issues when they arise.  The only issue when adding years is if the resulting date lands on the 29th of February in a non-leap year, so this case is easily addressed by resetting the day value to 28.  Note that because the result is based on the underlying <code>year_month_day</code> <code>+=</code> operator, the state of the object is modified, and thus it becomes necessary to update the serial date as well.</p>

<pre data-type="programlisting">ChronoDate&amp; ChronoDate::add_years(int rhs_years)
{
	// Proceed naively:
	date_ += date::years(rhs_years);

	if (!date_.ok())
	{
		date_ = date_.year() / date_.month() / 28;
	}

	reset_serial_date_();

	return *this;
}</pre>

<p>When adding months to a date, the situation becomes more problematic with varying days in each month plus a leap year condition in February, but with the <code>days_in_month</code> member function now available, it becomes a reasonably easy exercise.  The addition of months is again naively attempted, with the number of days adjusted if the resulting month is invalid.  The only way this incorrect state can occur is if the naïve result has more days than in its respective month.</p>

<pre data-type="programlisting">ChronoDate&amp; ChronoDate::add_months(int rhs_months)
{
	date_ += date::months(rhs_months);    // Naively attempt the addition

	// If the date is invalid, it is because the
	// result is an invalid end-of-month:
	if (!date_.ok())
	{
		date_ = date_.year() / date_.month() / date::day{ days_in_month() };
	}

	reset_serial_date_();

	return *this;
}</pre>

<p>As seen earlier, there is no addition assignment operator for adding days, so in <code>std::chrono</code> this will require conversion to <code>sys_days</code>.</p>

<pre data-type="programlisting">ChronoDate&amp; ChronoDate::add_days(int rhs_days)
{
	date_ = date::sys_days(date_) + date::days(rhs_days);

	return *this;
}</pre>

<p>Note that the sum of the <code>sys_days</code> and the <code>days</code> to be added are implicitly converted back to a <code>year_month_day</code> object when assigned to the <code>date_</code> member.  Further details behind this are also available in {5}.</p>
</div></section>












<section data-type="sect4" data-pdf-bookmark="Business Day Roll Rule"><div class="sect4" id="idm45807805768160">
<h4>Business Day Roll Rule</h4>

<p>One important function we have not discussed yet is that which will roll a weekend date to the next business date.</p>

<p>In practice, there are various commonly used roll methods.  For the purposes of this discussion, we will choose one that is used quite often in practice, namely the Modified Following rule.  Before proceeding, let us revisit determining the day of the week using the <code>weekday</code> class contained in <code>std::chrono</code>.</p>

<p>As mentioned earlier, the term “weekday” may be a little confusing.  It does not mean “weekday” as in Monday through Friday, but rather “day of the week”.  The <code>iso_encoding</code> member function will return an integer code for each day of the week, beginning with 1 for Monday and 7 for Sunday; therefore, a value of 6 or 7 will indicate the date falls on a weekend.</p>

<p>The <code>weekend_roll</code> function will just reuse this functionality to first determine if the date falls on a weekend.  If it does, it will first naively roll forward to the next Monday.  However, if this new date advances to the next month, it will roll back to the previous business date, namely the Friday of the original month.  This is why the original month is stored first.</p>

<pre data-type="programlisting">ChronoDate&amp; ChronoDate::weekend_roll() {
    date::weekday wd{ sys_days(date_) };
    month orig_mth{ date_.month() };

    unsigned wdn{ wd.iso_encoding() }; // Mon =  1, ..., Sat = 6, Sun = 7
    if (wdn &gt; 5) date_ = sys_days(date_) + days(8 - wdn);

    // If advance to next month, roll back; also handle roll to January
    if (orig_mth &lt; date_.month()
        || (orig_mth == December &amp;&amp; date_.month() == January))
            date_ = sys_days(date_) - days(3);

    reset_serial_date_();
    return *this;
}</pre>

<p>A rolled date will be modified, so it is necessary to update the serial date here as well.</p>
</div></section>












<section data-type="sect4" data-pdf-bookmark="Comparison and Streaming Operators"><div class="sect4" id="idm45807805761168">
<h4>Comparison and Streaming Operators</h4>

<p>The comparison operators <code>==</code> and ```&lt;⇒``` are immediate as these are defined for <code>year_month_day</code>.  We just need to be sure to use <code>std::strong_ordering</code> as the return type for ```&lt;⇒```, as it is ultimately two integer values – the days since the epoch – that are being compared.</p>

<pre data-type="programlisting">bool ChronoDate::operator == (const ChronoDate&amp; rhs) const
{
	return date_ == rhs.date_;
}

std::strong_ordering ChronoDate::operator &lt;=&gt; (const ChronoDate&amp; rhs) const
{
	return date_ &lt;=&gt; rhs.date_;
}</pre>

<p>We can also piggyback off of the stream operator for <code>year_month_day</code> and define it as a <code>friend</code> operator on <code>ChronoDate</code>.</p>

<pre data-type="programlisting">// This is a 'friend' of the ChronoDate class
export std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const ChronoDate&amp; rhs)
{
	os &lt;&lt; rhs.ymd();
	return os;
}</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Because this operator is a <code>friend</code> of the <code>ChronoDate</code> class, a separate <code>export</code> of the implementation is needed even when included in the same module.</p>
</div>

<p>With the <code>ChronoDate</code> class now ready to go, we can move on to day count conventions and other components that are typically required for programming related to fixed income trading.</p>
</div></section>
</div></section>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Day Count Bases"><div class="sect1" id="idm45807805750320">
<h1>Day Count Bases</h1>

<p>Day count bases are used to convert the interval between two dates into time measured in units of years, or <em>year fractions</em>, as commonly referred to in fixed income trading.  Day count bases are used whenever an interest calculation is made.  Interest rates are defined by three attributes: an annual percentage value, e.g. 3%, a type, e.g. simple or compound, and a day count basis. Consider a term deposit where 1000 dollars is invested at 3% compound interest, the investment being made on 25 October 2022 and maturing on 31 December 2023. The formula for calculating F, the value of the investment at maturity, is</p>
<div data-type="equation">
<math alttext="upper F equals 1000 left-parenthesis 1 plus 0.03 right-parenthesis Superscript t" display="block">
  <mrow>
    <mi>F</mi>
    <mo>=</mo>
    <mn>1000</mn>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>.</mo><mn>03</mn><mo>)</mo></mrow> <mi>t</mi> </msup>
  </mrow>
</math>
</div>

<p>The value of <em>t</em> depends on the day count basis. Money market calculations in the US and the EU are most likely to use the Actual/360 day count basis:</p>
<div data-type="equation">
<math alttext="upper A c t Baseline 360 left-parenthesis d 1 comma d 2 right-parenthesis equals StartFraction d 2 minus d 1 Over 360 EndFraction" display="block">
  <mrow>
    <mi>A</mi>
    <mi>c</mi>
    <mi>t</mi>
    <mn>360</mn>
    <mrow>
      <mo>(</mo>
      <msub><mi>d</mi> <mn>1</mn> </msub>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mfrac><mrow><msub><mi>d</mi> <mn>2</mn> </msub><mo>-</mo><msub><mi>d</mi> <mn>1</mn> </msub></mrow> <mn>360</mn></mfrac>
  </mrow>
</math>
</div>

<p>In UK, Canadian, and Australian money markets, the Actual/365 day count basis — where the 360 swapped for 365 — is more common.  Other common day count bases used in broader fixed income trading include the 30/360 method, which assumes every month has 30 days, and a year has 360 days.  The Actual/Actual method uses the actual number of days in both the numerator and denominator.  In equity portfolio management, An Actual/252 basis is often used, where 252 business days per year are assumed.</p>

<p>Implementing day count conventions in C++ is an example of where interface inheritance can be useful.  We can define a pure abstract base class that mandates the implementation of the day count-adjusted year fraction, and then leave it to the derived classes to implement the specific calculations.</p>

<p>The interface simply declares a pure virtual <code>operator()</code> for the calculations on the derived classes.</p>

<pre data-type="programlisting">export class DayCount
{
public:
	virtual double operator()
        (const ChronoDate&amp; date1, const ChronoDate&amp; date2) const = 0;

	virtual ~DayCount() = default;
};</pre>

<p>The Actual/365 year fraction calculation is trivial:</p>

<pre data-type="programlisting">export class Act365 : public DayCount
{
public:
	double operator() (const ChronoDate&amp; date1, const ChronoDate&amp; date2) const
        override
    {
        return (date2 - date1) / 365.0;
    }
};</pre>

<p>An <code>Act360</code> class would be the same, except with the denominator replaced by 360.</p>

<p>The 30/360 case is a bit more complicated, in that the numerator must first be calculated according to the formula {put here}.</p>

<p>End-of-month adjustments for the day values will depend on the particular form of the 30/360, of which there are several that can depend upon the geographical location of a trading desk.  In the United States, the ISDA version (International Swaps and Derivatives Association){6} is commonly used and is implemented in the example below as the private <code>date_diff_</code> helper function.  The result is then divided by 360 in the public operator override.</p>

<pre data-type="programlisting">export class Thirty360 : public DayCount
{
public:
	double operator()
        (const ChronoDate&amp; date1, const ChronoDate&amp; date2) const override
    {
        return static_cast&lt;double&gt;( date_diff_(date1, date2)) / 360.0;
    }

private:
	unsigned date_diff_(const ChronoDate&amp; date1, const ChronoDate&amp; date2) const
	{
	    unsigned d1, d2;
        d1 = date1.day();
        d2 = date2.day();

        auto f = [](unsigned&amp; d) {
	    if (d == 31)
		{
			d = 30;
		}
	}

        f(d1);
        f(d2);

        return 360 * (date2.year() - date1.year()) + 30 * (date2.month() –
            date1.month()) + d2 - d1;
    }
};</pre>

<p>Then, for some examples:</p>

<pre data-type="programlisting">	Act365 act_365{};
	Act360 act_360{};
	Thirty360 thirty_360{};

	ChronoDate sd1{ 2021, 4, 26 };
	ChronoDate ed1{ 2023, 10, 26 };
	ChronoDate sd2{ 2022, 10, 10 };
	ChronoDate ed2{ 2023, 4, 10 };

	auto yf_act_365_01 = act_365(sd1, ed1);	// 2.50137
	auto yf_act_365_02 = act_365(sd2, ed2);	// 0.49863

	auto yf_act_360_01 = act_360(sd1, ed1);	// 2.53611
	auto yf_act_360_02 = act_360(sd2, ed2);	// 0.505556

	auto yf_thirty_01 = thirty_360(sd1, ed1);	// 2.5
	auto yf_thirty_02 = thirty_360(sd2, ed2);	// 0.5</pre>

<p>The results are shown in the comments.  Note that only the 30/360 day count basis yields year fractions to half of a year exactly.</p>

<p>As a quick application of day count bases {5.5} (Steiner), consider obtaining the price of a short-term government Treasury Bill.  In the US, these have maturities from four months to a year, and pricing is based on an Actual/365 basis.  In the UK, maturities may be up to six months and carry an Actual/360 basis.  We can write a valuation function that will accommodate an arbitrary day count basis via runtime polymorphism, so both US and UK cases can priced using the same function.</p>

<pre data-type="programlisting">double treasury_bill(const ChronoDate&amp; sett_date,
	const ChronoDate&amp; maturity_date, double mkt_yield, double face_value,
	const DayCount&amp; dc)
{
	// pp 40-41, Steiner
	return face_value / (1.0 + mkt_yield * dc(sett_date, maturity_date));
}</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Yield Curves"><div class="sect1" id="idm45807805733296">
<h1>Yield Curves</h1>

<p>A yield curve is derived from market data — a set of fixed points over discrete dates — as of its settle date (the day the prices are observed, eg the current trading day). The valuation process of fixed income positions depends on a normalized yield curve from discount factors can be obtained, so as to calculate present values of each future payment.  A review of this process is detailed in the next section.  These results will then be implemented within in the design of a yield curve class that follows afterward.</p>








<section data-type="sect2" data-pdf-bookmark="Deriving a Yield Curve from Market Data"><div class="sect2" id="idm45807805731872">
<h2>Deriving a Yield Curve from Market Data</h2>

<p>Essentially a yield is an interest rate, looked at from a different perspective. If money is invested in a deposit account at a known rate of interest, then the accumulated value of the investment at some future date can be calculated. However, suppose we can invest 1000 dollars on 25 October 2022 and receive 1035.60 dollars on 31 December 2023. In order to compare this investment with other investments we calculate its yield. Assuming compounded interest and Actual/365 day count basis, then</p>
<div data-type="equation">
<math alttext="1000 left-parenthesis 1 plus y right-parenthesis Superscript 432 slash 365 Baseline equals 1035.60" display="block">
  <mrow>
    <mn>1000</mn>
    <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mi>y</mi><mo>)</mo></mrow> <mrow><mn>432</mn><mo>/</mo><mn>365</mn></mrow> </msup>
    <mo>=</mo>
    <mn>1035</mn>
    <mo>.</mo>
    <mn>60</mn>
  </mrow>
</math>
</div>

<p>from which we find the yield</p>
<div data-type="equation">
<math alttext="y equals exp left-parenthesis ln left-parenthesis 1035.60 slash 1000 right-parenthesis times 365 slash 432 right-parenthesis minus 1 equals 3 percent-sign" display="block">
  <mrow>
    <mi>y</mi>
    <mo>=</mo>
    <mo form="prefix">exp</mo>
    <mo>(</mo>
    <mo form="prefix">ln</mo>
    <mo>(</mo>
    <mn>1035</mn>
    <mo>.</mo>
    <mn>60</mn>
    <mo>/</mo>
    <mn>1000</mn>
    <mo>)</mo>
    <mo>×</mo>
    <mn>365</mn>
    <mo>/</mo>
    <mn>432</mn>
    <mo>)</mo>
    <mo>-</mo>
    <mn>1</mn>
    <mo>=</mo>
    <mn>3</mn>
    <mo>%</mo>
  </mrow>
</math>
</div>

<p>In general, the yield curve is a function of time, say <math alttext="y left-parenthesis t right-parenthesis">
  <mrow>
    <mi>y</mi>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
  </mrow>
</math>, and is constructed from market data, such as Treasury Bills, swaps and bonds.  The time values are in units of years (or year fractions).</p>

<p>These products all have known future cash flows, and are known as fixed income securities. In addition, each type of fixed income security has its own yield type (simple, discount or compounded), and its own day count basis, and these may vary within a single product group. To avoid the use of multiple interest types and day count bases, yield curves typically define their yields as continuously compounded with an Actual/365 day count basis.</p>

<p>To illustrate how the inputs to the yield curve are derived, consider a US Treasury Bill; the yield type is discount, the day count basis is Act/360, and the market quote is the yield on the bill. Suppose the face value is <em>F</em>, the maturity date is <em>m</em>, the market yield is <math alttext="y Subscript m">
  <msub><mi>y</mi> <mi>m</mi> </msub>
</math>  for settlement on <em>s</em>. Then, the price, <em>P</em>, of the bill is</p>
<div data-type="equation">
<math alttext="upper P equals upper F left-parenthesis 1 minus normal upper A normal c normal t Baseline 360 left-parenthesis s comma m right-parenthesis y Subscript m Baseline right-parenthesis" display="block">
  <mrow>
    <mi>P</mi>
    <mo>=</mo>
    <mi>F</mi>
    <mfenced separators="" open="(" close=")">
      <mn>1</mn>
      <mo>-</mo>
      <mi> Act </mi>
      <mn>360</mn>
      <mrow>
        <mo>(</mo>
        <mi>s</mi>
        <mo>,</mo>
        <mi>m</mi>
        <mo>)</mo>
      </mrow>
      <mspace width="0.166667em"/>
      <msub><mi>y</mi> <mi>m</mi> </msub>
    </mfenced>
  </mrow>
</math>
</div>

<p>For the yield curve, the corresponding yield is <math alttext="y left-parenthesis t right-parenthesis">
  <mrow>
    <mi>y</mi>
    <mo>(</mo>
    <mi>t</mi>
    <mo>)</mo>
  </mrow>
</math>, where <math alttext="t equals normal upper A normal c normal t Baseline 365 left-parenthesis s comma m right-parenthesis">
  <mrow>
    <mi>t</mi>
    <mo>=</mo>
    <mi> Act </mi>
    <mn>365</mn>
    <mo>(</mo>
    <mi>s</mi>
    <mo>,</mo>
    <mi>m</mi>
    <mo>)</mo>
  </mrow>
</math>, so that</p>
<div data-type="equation">
<math alttext="upper P e Superscript t y left-parenthesis t right-parenthesis Baseline equals upper F" display="block">
  <mrow>
    <mi>P</mi>
    <msup><mi>e</mi> <mrow><mi>t</mi><mi>y</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow> </msup>
    <mo>=</mo>
    <mi>F</mi>
  </mrow>
</math>
</div>

<p>The value of $y(t)$ can be found from these two equations.  It is</p>
<div data-type="equation">
<math alttext="y left-parenthesis t right-parenthesis equals StartFraction minus ln left-parenthesis 1 minus normal upper A normal c normal t Baseline 360 left-parenthesis s comma m right-parenthesis y Subscript m Baseline right-parenthesis Over t EndFraction" display="block">
  <mrow>
    <mi>y</mi>
    <mrow>
      <mo>(</mo>
      <mi>t</mi>
      <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mfrac><mrow><mo>-</mo><mo form="prefix">ln</mo><mo>(</mo><mn>1</mn><mo>-</mo><mi> Act </mi><mn>360</mn><mrow><mo>(</mo><mi>s</mi><mo>,</mo><mi>m</mi><mo>)</mo></mrow><msub><mi>y</mi> <mi>m</mi> </msub><mo>)</mo></mrow> <mi>t</mi></mfrac>
  </mrow>
</math>
</div>

<p>It is essential that any set of interest rate products used to create a yield curve have the same settle date. Let the maturity dates for the products be <em>d</em><sub>1</sub>,&lt; <em>d</em><sub>2</sub> &lt; …​ &lt; <em>d<sub>n</sub></em>, with <em>s</em> &lt; <em>d</em><sub>1</sub>, and the associated yields be <em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, …​, <em>y</em><sub>n</sub>, where <math alttext="y Subscript i Baseline equals y left-parenthesis t Subscript i Baseline right-parenthesis">
  <mrow>
    <msub><mi>y</mi> <mi>i</mi> </msub>
    <mo>=</mo>
    <mi>y</mi>
    <mrow>
      <mo>(</mo>
      <msub><mi>t</mi> <mi>i</mi> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math> and <em>t<sub>i</sub></em> = Act365(<em>s</em>,<em>d<sub>i</sub></em>). Since the yields are calculated for a date interval whose first date is the settlement date, these yields are known as spot yields.</p>

<p>There are many continuous curve which pass through the points</p>
<div data-type="equation">
<math alttext="left-parenthesis t 1 comma y 1 right-parenthesis comma left-parenthesis t 2 comma y 2 right-parenthesis comma ellipsis comma left-parenthesis t Subscript n Baseline comma y Subscript n Baseline right-parenthesis" display="block">
  <mrow>
    <mrow>
      <mo>(</mo>
      <msub><mi>t</mi> <mn>1</mn> </msub>
      <mo>,</mo>
      <msub><mi>y</mi> <mn>1</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
      <mo>(</mo>
      <msub><mi>t</mi> <mn>2</mn> </msub>
      <mo>,</mo>
      <msub><mi>y</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mo>⋯</mo>
    <mo>,</mo>
    <mrow>
      <mo>(</mo>
      <msub><mi>t</mi> <mi>n</mi> </msub>
      <mo>,</mo>
      <msub><mi>y</mi> <mi>n</mi> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>

<p>The choice of an appropriate curve is a business decision made by the user of the yield curve.  This typically based on a curve-fitting technique employing a particular interpolation method.</p>










<section data-type="sect3" data-pdf-bookmark="Discount Factors"><div class="sect3" id="idm45807805703568">
<h3>Discount Factors</h3>

<p>Consider a unit payment amount made at time <em>m</em>. What is its value on a settle date, <em>s</em> &lt; <em>m</em>? Let <em>P</em>(<em>s</em>,<em>m</em>) be the price, paid on the settle date, let <em>t</em>=Act365(<em>s</em>,<em>m</em>) and let <em>y</em>(<em>t</em>) be the associated yield. Then</p>
<div data-type="equation">
<math alttext="upper P left-parenthesis s comma m right-parenthesis e Superscript t y left-parenthesis t right-parenthesis Baseline equals 1" display="block">
  <mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <mi>m</mi>
      <mo>)</mo>
    </mrow>
    <msup><mi>e</mi> <mrow><mi>t</mi><mi>y</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow> </msup>
    <mo>=</mo>
    <mn>1</mn>
  </mrow>
</math>
</div>

<p>from which <em>P</em>(<em>s</em>,<em>m</em>) = e<sup><em>-ty</em>(<em>t</em>)</sup>. Now <em>P</em>(<em>s</em>,<em>m</em>) is the present value, as seen on date <em>s</em> for unit payment made on date <em>m</em>.  In other words, it is the discount factor for the period <em>s</em> to <em>m</em>. Since <em>y</em>(<em>t</em>) is a spot yield, this is a spot discount factor.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Forward Discount Factors"><div class="sect3" id="idm45807805688320">
<h3>Forward Discount Factors</h3>

<p>How do we calculate the discount factor for a period which begins at time <em>d</em><sub>1</sub> and ends at time <em>d</em><sub>2</sub>, where <em>s</em> &lt; <em>d</em><sub>1</sub> \leq d_2?</p>

<p>Consider a unit payment to be made at time <em>d</em><sub>2</sub> and let its value at <em>d</em><sub>1</sub> be represented by <em>P</em>(<em>s</em>; <em>d</em><sub>1</sub>,<em>d</em><sub>2</sub>).  Its spot value – hence the parameter <em>s</em> – is</p>
<div data-type="equation">
<math alttext="upper P left-parenthesis s comma d 1 right-parenthesis upper P left-parenthesis s semicolon d 1 comma d 2 right-parenthesis" display="block">
  <mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>1</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>;</mo>
      <msub><mi>d</mi> <mn>1</mn> </msub>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>

<p>To avoid arbitrage opportunities we must have</p>
<div data-type="equation">
<math alttext="upper P left-parenthesis s comma d 2 right-parenthesis equals upper P left-parenthesis s comma d 1 right-parenthesis upper P left-parenthesis s semicolon d 1 comma d 2 right-parenthesis comma s o t h a t" display="block">
  <mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>1</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>;</mo>
      <msub><mi>d</mi> <mn>1</mn> </msub>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mi>s</mi>
    <mi>o</mi>
    <mi>t</mi>
    <mi>h</mi>
    <mi>a</mi>
    <mi>t</mi>
  </mrow>
</math>
</div>
<div data-type="equation">
<math alttext="upper P left-parenthesis s semicolon d 1 comma d 2 right-parenthesis equals StartFraction upper P left-parenthesis s comma d 2 right-parenthesis Over upper P left-parenthesis s comma d 1 right-parenthesis EndFraction" display="block">
  <mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>;</mo>
      <msub><mi>d</mi> <mn>1</mn> </msub>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mfrac><mrow><mi>P</mi><mo>(</mo><mi>s</mi><mo>,</mo><msub><mi>d</mi> <mn>2</mn> </msub><mo>)</mo></mrow> <mrow><mi>P</mi><mo>(</mo><mi>s</mi><mo>,</mo><msub><mi>d</mi> <mn>1</mn> </msub><mo>)</mo></mrow></mfrac>
  </mrow>
</math>
</div>

<p>Substituting for the spot discount factors:</p>
<div data-type="equation">
<math alttext="upper P left-parenthesis s semicolon d 1 comma d 2 right-parenthesis equals StartFraction e Superscript minus t 2 y left-parenthesis t 2 right-parenthesis Baseline Over e Superscript minus t 1 y left-parenthesis t 1 right-parenthesis Baseline EndFraction equals e Superscript t 1 y left-parenthesis t 1 right-parenthesis minus t 2 y left-parenthesis t 2 right-parenthesis" display="block">
  <mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>;</mo>
      <msub><mi>d</mi> <mn>1</mn> </msub>
      <mo>,</mo>
      <msub><mi>d</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>=</mo>
    <mfrac><msup><mi>e</mi> <mrow><mo>-</mo><msub><mi>t</mi> <mn>2</mn> </msub><mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi> <mn>2</mn> </msub><mo>)</mo></mrow></mrow> </msup> <msup><mi>e</mi> <mrow><mo>-</mo><msub><mi>t</mi> <mn>1</mn> </msub><mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi> <mn>1</mn> </msub><mo>)</mo></mrow></mrow> </msup></mfrac>
    <mo>=</mo>
    <msup><mi>e</mi> <mrow><msub><mi>t</mi> <mn>1</mn> </msub><mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi> <mn>1</mn> </msub><mo>)</mo></mrow><mo>-</mo><msub><mi>t</mi> <mn>2</mn> </msub><mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi> <mn>2</mn> </msub><mo>)</mo></mrow></mrow> </msup>
  </mrow>
</math>
</div>

<p>Since <em>d</em><sub>1</sub> &gt; <em>s</em>, <em>P</em>(<em>s</em>;_d_<sub>1</sub>,<em>d</em><sub>2</sub>) is a forward discount factor.</p>

<p>The next sections will describe a framework for yield curves in C++, followed by a simple example of a yield curve and its use to value a bond</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="A Yield Curve Class"><div class="sect2" id="idm45807805667712">
<h2>A Yield Curve Class</h2>

<p>The essential function on a yield curve class will return a continuously compounded forward discount factor between two arbitrary dates, as detailed in the previous section.  Fitting the resulting curve through the points <math alttext="left-parenthesis t 1 comma y 1 right-parenthesis comma left-parenthesis t 2 comma y 2 right-parenthesis comma ellipsis comma left-parenthesis t Subscript n Baseline comma y Subscript n Baseline right-parenthesis">
  <mrow>
    <mrow>
      <mo>(</mo>
      <msub><mi>t</mi> <mn>1</mn> </msub>
      <mo>,</mo>
      <msub><mi>y</mi> <mn>1</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mrow>
      <mo>(</mo>
      <msub><mi>t</mi> <mn>2</mn> </msub>
      <mo>,</mo>
      <msub><mi>y</mi> <mn>2</mn> </msub>
      <mo>)</mo>
    </mrow>
    <mo>,</mo>
    <mo>⋯</mo>
    <mo>,</mo>
    <mrow>
      <mo>(</mo>
      <msub><mi>t</mi> <mi>n</mi> </msub>
      <mo>,</mo>
      <msub><mi>y</mi> <mi>n</mi> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math> can be based on a plethora of numerical methods in the literature.  As examples, these can range from a simple linearly interpolated yield curve, to more sophisticated examples such as a cubic spline-interpolated curve, Smoothest Yield Curves {7}, or the Monotone Convex Method {8}.</p>

<p>At a high level then, we could define an abstract base class that</p>
<ol>
<li>
<p>Provides a common method to convert market yield data into continuously compounded yields, based on the results above {[4.1]}</p>
</li>
<li>
<p>Requires a derived class to implement its own curve-fitting method as a private member function</p>
</li>

</ol>

<p>{UML Diagram Here}</p>

<p>The base class will contain a non-virtual public function that calculates the forward discount factor between two dates, using interpolated yields from the overridden <code>yield_curve_</code> method on each derived class.  The interpolated yields determined from each derived class are assumed to be continuously compounded with the Act/365 day count basis. The overridden <code>yield_curve_</code> method will depend on market data, related to a specific settle date.</p>

<pre data-type="programlisting">export class YieldCurve
{
public:
	// d1 &lt;= d2 &lt; infinity
	double discount_factor(const ChronoDate&amp; d1, const ChronoDate&amp; d2) const;
	virtual ~YieldCurve() = default;

protected:
	ChronoDate settle_;

private:
	Act365 act365_{};

	virtual double yield_curve_(double t) const = 0;
};</pre>

<p>The implementation of <code>discount_factor</code> then follows the mathematical derivation presented in [[4.1.2]].  Note that if the first date <code>d1</code> is the settle date, the result defaults to the spot discount factor at date <code>d2</code>.</p>

<pre data-type="programlisting">double YieldCurve::discount_factor(const ChronoDate&amp; d1, const ChronoDate&amp; d2) const
{
	if (d2 &lt; d1)
		throw std::exception("YieldCurve::discount_factor: d2 &lt; d1");

	if (d1 &lt; settle_ || d2 &lt; settle_)
		throw std::exception("YieldCurve::discount_factor: date &lt; settle");

	// P(t1, t2) = exp( -(t2-t1) * f(t1, t2) )

	// if d1 == settle_ then P(t1,t2) = P(0,t2) = exp(-t2 * y2 )
	double t2 = act365_(settle_, d2);
	double y2 = yield_curve_(t2);
	if (d1 == settle_) return exp(-t2 * y2);

	double t1 = act365_(settle_, d1);
	double y1 = yield_curve_(t1);
	// (t2-t1) f(t1,t2) = t2 * y2 - t1 * y1
	return exp(t1 * y1 - t2 * y2);
}</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="A Linearly Interpolated Yield Curve Class Implementation"><div class="sect2" id="idm45807805656176">
<h2>A Linearly Interpolated Yield Curve Class Implementation</h2>

<p>The simplest curve fitting method – but still sometimes used in practice – is linear interpolation.  More sophisticated interpolation methods also exist, such as those referenced above, but these require considerably more mathematical horsepower.  So to keep the discussion concise, we will limit the example here to the linearly interpolated case, but it is important to remember that more advanced methods can also be integrated into the same inheritance structure.</p>

<pre data-type="programlisting">export class LinearInterpYieldCurve final : public YieldCurve
{
public:
	LinearInterpYieldCurve(
		const ChronoDate&amp; settle_date,
		const vector&lt;double&gt;&amp; maturities,   	// In Act/365 years.
		const vector&lt;double&gt;&amp; spot_yields); 	// Continuously compounded,
												// Act/365 day count basis

private:
	vector&lt;double&gt; maturities_; // maturities in years
	vector&lt;double&gt; yields_;

	double yield_curve_(const double t) const override;
};</pre>

<p>The constructor will take in the maturities associated with each of the yield data points relative to the settle date, based on the Actual/365 day count basis.  The corresponding spot yield values follow in the vector in the third argument.  Its implementation will check whether the maturity and yield vectors are of the same length, and whether the settle date value is negative.  If either is true, an exception is thrown.  For the purposes of demonstration, we will just assume the maturities are in ascending order, but in production this would be another invariant to check.</p>

<pre data-type="programlisting">LinearInterpYieldCurve::LinearInterpYieldCurve(
	const ChronoDate&amp; settle_date,
	const vector&lt;double&gt;&amp; maturities,
	const vector&lt;double&gt;&amp; spot_yields) : maturities_{ maturities },
		yields_{ spot_yields }	// Maybe move semantics instead?
{
	settle_ = settle_date;

	if (maturities.size() != spot_yields.size())
    throw std::exception("LinearInterpYieldCurve: maturities and spot_yields are different lengths");

	if (maturities.front() &lt; 0.0 )
	  throw std::exception("LinearInterpYieldCurve: first maturity cannot be negative");

	// Assume maturities are in order
}</pre>

<p>The linear interpolation method is implemented in the mandated <code>yield_curve_</code> private member function.  If the year fraction at which a yield is to be interpolated exceeds the maximum time value in the data, the result is just the last yield value.  Otherwise, the <code>while</code> loop locates the interval of time points that surrounds the input value of time <code>t</code>.  Then, the proportionally weighted yield is calculated and returned.</p>

<pre data-type="programlisting">double LinearInterpYieldCurve::yield_curve_(const double t) const
{
	// interp_yield called from discount_factor, so maturities_front() &lt;= t

	if (t &gt;= maturities_.back())
	{
		auto check{ maturities_.back() };
		return yields_.back();
	}

	// Now know maturities_front() &lt;= t &lt; maturities_.back()
	size_t indx{ 0 };
	while (maturities_[indx + 1] &lt; t) ++indx;
	return yields_[indx] + (yields_[indx + 1] - yields_[indx])
		/ (maturities_[indx + 1] - maturities_[indx]) * (t - maturities_[indx]);
}</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="A Bond Class"><div class="sect1" id="idm45807805648848">
<h1>A Bond Class</h1>

<p>We are now in position to utilize objects of the preceding classes, along with a user-defined <code>Bond</code> class, to calculate the value of a coupon-paying bond.  Common examples of bonds in the include government-issued Treasury Bonds, agency bonds (issued by a government-sponsored enterprise such as the Government National Mortgage Association (GNMA) in the US), corporate bonds, and local state and municipal bonds.  As debt obligations, a series of regular payments over time is made in exchange for an amount borrowed by the issuer.  The main difference with a traditional loan is the principal amount, ie the face value, is returned when the bond matures, rather than being amortized over time.</p>








<section data-type="sect2" data-pdf-bookmark="Bond Payments and Valuation"><div class="sect2" id="idm45807805646896">
<h2>Bond Payments and Valuation</h2>

<p>Before proceeding with further code development, it is probably worthwhile to summarize the mechanics of how bond payments are structured, and how a bond is commonly valued.  The details behind this are very important in writing real world bond trading software, yet it is surprising they are so often glossed over in computational finance courses and textbooks.  The following discussion will then essentially become the design requirements for a <code>Bond</code> class, to subsequently follow.</p>

<p>The general idea is that a bond pays fixed amounts on dates in a regular schedule; for example, suppose a bond has a face value of $1000 and pays 5% of its face value every six months. Then the payment frequency is twice per year, and the coupon amount would be</p>
<div data-type="equation">
<math alttext="StartFraction 0.05 left-parenthesis 1000 right-parenthesis Over 2 EndFraction equals 25" display="block">
  <mrow>
    <mfrac><mrow><mn>0</mn><mo>.</mo><mn>05</mn><mo>(</mo><mn>1000</mn><mo>)</mo></mrow> <mn>2</mn></mfrac>
    <mo>=</mo>
    <mn>25</mn>
  </mrow>
</math>
</div>

<p>In general, the formula is</p>
<div data-type="equation">
<math alttext="r e g u l a r c o u p o n a m o u n t equals left-parenthesis c o u p o n r a t e right-parenthesis StartFraction left-parenthesis f a c e v a l u e right-parenthesis Over left-parenthesis c o u p o n f r e q u e n c y right-parenthesis EndFraction" display="block">
  <mrow>
    <mi>r</mi>
    <mi>e</mi>
    <mi>g</mi>
    <mi>u</mi>
    <mi>l</mi>
    <mi>a</mi>
    <mi>r</mi>
    <mspace width="0.277778em"/>
    <mi>c</mi>
    <mi>o</mi>
    <mi>u</mi>
    <mi>p</mi>
    <mi>o</mi>
    <mi>n</mi>
    <mspace width="0.277778em"/>
    <mi>a</mi>
    <mi>m</mi>
    <mi>o</mi>
    <mi>u</mi>
    <mi>n</mi>
    <mi>t</mi>
    <mo>=</mo>
    <mrow>
      <mo>(</mo>
      <mi>c</mi>
      <mi>o</mi>
      <mi>u</mi>
      <mi>p</mi>
      <mi>o</mi>
      <mi>n</mi>
      <mspace width="0.277778em"/>
      <mi>r</mi>
      <mi>a</mi>
      <mi>t</mi>
      <mi>e</mi>
      <mo>)</mo>
    </mrow>
    <mfrac><mrow><mo>(</mo><mi>f</mi><mi>a</mi><mi>c</mi><mi>e</mi><mspace width="0.277778em"/><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>o</mi><mi>n</mi><mspace width="0.277778em"/><mi>f</mi><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>)</mo></mrow></mfrac>
  </mrow>
</math>
</div>

<p>The first task is to create a list of dates when payments are due and the coupon payment amounts for each of those dates. Along with the face value and annual coupon rate, the contractual conditions of the bond also include the following four dates:</p>

<ul>
<li>
<p>Issue date</p>
</li>
<li>
<p>First coupon date</p>
</li>
<li>
<p>Penultimate coupon date</p>
</li>
<li>
<p>Maturity date</p>
</li>
</ul>

<p>The <em>issue date</em> is the date on which the bond is first put on sale.  A stream of fixed payments is typically paid, eg every six months, beginning with the <em>first coupon date</em>.  The second to last payment occurs on the <em>penultimate coupon date</em>, and the final payment, consisting of the last coupon payment plus repayment of the face value, occurs on the <em>maturity date</em>.  We will again assume the coupon day is less than 29, to avoid problems with end of month cases.</p>










<section data-type="sect3" data-pdf-bookmark="Determining the Payment Schedule"><div class="sect3" id="idm45807805633504">
<h3>Determining the Payment Schedule</h3>

<p>Returning to the example above, of a bond which pays 5% coupon on a face value of $1000 with a coupon frequency of 2, when will the payments be made?</p>

<p>For coupons between the first coupon date and the penultimate date, payment <em>due dates</em> fall on a <em>regular schedule</em>.  This means a constant payment of $25 is due every six months.  To ensure these dates belong to a regular schedule of due dates, in general there are restrictions on the first and penultimate coupon dates, and the coupon frequency.  These two dates must be business days having the same day of the month, the coupon frequency must be a divisor of twelve, and the two dates must differ by a multiple of 12/(coupon frequency) months.</p>

<p>Since the due dates may not fall on business dates, the bond also has associated <em>payment dates</em> that are adjusted for weekends and holidays.  To simplify matters we will assume there are no holidays except Saturday and Sunday, as well as assume payments will not occur on any day with value greater than 28, so that if a due date falls on a weekend, the regular coupon payment will be made on the following Monday.</p>

<p>For example, suppose the bond has a first coupon date of 17 Mar 2023 and a penultimate coupon date of 17 Mar 2025. The two dates differ by 36 months, which is a multiple of 12/2=6, as required. Then, the intermediate due dates are 17 Sep 2023, 17 Mar 2024, …​, 17 Mar 2025.  These due dates will not all fall on business days, so each will need to be checked and rolled forward if necessary to qualify as payment dates.</p>

<p>If the first and final payments also occur regular periods, they will be \$25 and \$1025, respectively.  However, first and last coupon periods may or may not be regular.  The usually cited case is an irregular first payment period, but there can also be cases over of an irregular period from penultimate to maturity date.</p>

<p>In the case of a short first period, the coupon payment is calculated by multiplying the annual coupon rate by the ratio of actual days in the period over the number of days in what would be a normal first period.  Again, let us use the example of a \$1000 face value bond paying an annual coupon of 5% semiannually (\$25 regular coupon payments).  Suppose a ten-year bond is issued on 2022-7-12, with a first payment date of 2022-12-21.  Subsequent payment dates are then on 21 June and 21 December.  If the first payment period had been regular, the issue date would have been 2022-6-21.  This date is called the <em>first prior date</em>.  Now, the first payment is prorated as follows:</p>
<div data-type="equation">
<math alttext="StartFraction left-parenthesis c o u p o n p a y m e n t right-parenthesis left-parenthesis n u m b e r o f d a y s f r o m i s s u e t o Baseline 1 s t p m t right-parenthesis Over left-parenthesis n u m b e r o f d a y s f r o m Baseline 1 s t p r i o r t o Baseline 1 s t p m t EndFraction equals" display="block">
  <mrow>
    <mfrac><mrow><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>o</mi><mi>n</mi><mspace width="0.277778em"/><mi>p</mi><mi>a</mi><mi>y</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>)</mo><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="0.277778em"/><mi>o</mi><mi>f</mi><mspace width="0.277778em"/><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mspace width="0.277778em"/><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mspace width="0.277778em"/><mi>i</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>e</mi><mspace width="0.277778em"/><mi>t</mi><mi>o</mi><mspace width="0.277778em"/><mn>1</mn><mi>s</mi><mi>t</mi><mspace width="0.277778em"/><mi>p</mi><mi>m</mi><mi>t</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="0.277778em"/><mi>o</mi><mi>f</mi><mspace width="0.277778em"/><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mspace width="0.277778em"/><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mspace width="0.277778em"/><mn>1</mn><mi>s</mi><mi>t</mi><mspace width="0.277778em"/><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mspace width="0.277778em"/><mi>t</mi><mi>o</mi><mspace width="0.277778em"/><mn>1</mn><mi>s</mi><mi>t</mi><mspace width="0.277778em"/><mi>p</mi><mi>m</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo>
  </mrow>
</math>
</div>
<div data-type="equation">
<math alttext="25 left-parenthesis StartFraction 162 Over 183 EndFraction right-parenthesis equals normal dollar-sign 22.13" display="block">
  <mrow>
    <mn>25</mn>
    <mo>(</mo>
    <mfrac><mn>162</mn> <mn>183</mn></mfrac>
    <mo>)</mo>
    <mo>=</mo>
    <mi>$</mi>
    <mn>22</mn>
    <mo>.</mo>
    <mn>13</mn>
  </mrow>
</math>
</div>

<p><img src="Images/Fig_9_1.png" alt="Figure 9-1: Irregular short first coupon period" width="600"/></p>

<p>In the case of a long first period, suppose we have a bond with the same terms as in the short period example, but where the issue date is now 2022-5-12.</p>

<p><img src="Images/Fig_9_2.png" alt="Figure 9-2: Irregular long first coupon period" width="600"/></p>

<p>In this case, the first coupon payment will be the regular coupon of $25 over the period from the first prior date to issue, <em>plus</em> a partial payment (in red) over the interval between issue and first prior date.  This extra payment is prorated over the six-month period from the <em>second prior date</em> to the first.  That is,</p>
<div data-type="equation">
<math alttext="StartFraction left-parenthesis c o u p o n p a y m e n t right-parenthesis left-parenthesis n u m b e r o f d a y s f r o m i s s u e t o Baseline 1 s t p r i o r right-parenthesis Over left-parenthesis n u m b e r o f d a y s f r o m Baseline 2 n d p r i o r t o Baseline 1 s t p r i o r right-parenthesis EndFraction equals" display="block">
  <mrow>
    <mfrac><mrow><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>o</mi><mi>n</mi><mspace width="0.277778em"/><mi>p</mi><mi>a</mi><mi>y</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>)</mo><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="0.277778em"/><mi>o</mi><mi>f</mi><mspace width="0.277778em"/><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mspace width="0.277778em"/><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mspace width="0.277778em"/><mi>i</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>e</mi><mspace width="0.277778em"/><mi>t</mi><mi>o</mi><mspace width="0.277778em"/><mn>1</mn><mi>s</mi><mi>t</mi><mspace width="0.277778em"/><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mspace width="0.277778em"/><mi>o</mi><mi>f</mi><mspace width="0.277778em"/><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mspace width="0.277778em"/><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mspace width="0.277778em"/><mn>2</mn><mi>n</mi><mi>d</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mspace width="0.277778em"/><mi>t</mi><mi>o</mi><mspace width="0.277778em"/><mn>1</mn><mi>s</mi><mi>t</mi><mspace width="0.277778em"/><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mo>)</mo></mrow></mfrac>
    <mo>=</mo>
  </mrow>
</math>
</div>
<div data-type="equation">
<math alttext="25 left-parenthesis StartFraction 40 Over 182 EndFraction right-parenthesis equals normal dollar-sign 5.49" display="block">
  <mrow>
    <mn>25</mn>
    <mo>(</mo>
    <mfrac><mn>40</mn> <mn>182</mn></mfrac>
    <mo>)</mo>
    <mo>=</mo>
    <mi>$</mi>
    <mn>5</mn>
    <mo>.</mo>
    <mn>49</mn>
  </mrow>
</math>
</div>

<p>The total first coupon payment is then 25 + 5.49 = 30.49</p>

<p>Calculating prorated payments over irregular final periods are similar, except that prior payment periods preceding issue, extra payment periods extending later than maturity are utilized.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Valuing a Bond"><div class="sect3" id="idm45807805562080">
<h3>Valuing a Bond</h3>

<p>The issuer sells bonds on the issue date, pays the owners of the bonds the coupon amounts and, at maturity, also pays back the face value of the bond. The owner of a bond may then sell it on the secondary market, in which case the buyer and seller agree to a business date, known as the bond settle date, on which the sale will take place. On this settle date the seller receives his money, and the buyer becomes the registered owner, with the right to receive all payments which fall due after the settle date. Should the owner of the bond wish to value the bond at any time, this can be done by calculating the discounted value of the bond, using a yield curve of his own choice, and the discount factors calculated for the periods from the settlement date to the corresponding payment dates.</p>

<p><img src="Images/Fig_9_3.png" alt="Figure 9-3: Bond valuation at settle date" width="600"/></p>

<p>Revisiting the example in Figure 9-1, suppose a bond is exchanged for cash on 2023-10-24, as indicated by the red hash mark in Figure 9-3 above.  All preceding coupon payments have been paid to the previous owner, so the value of the bond will only depend on payments beginning with the third coupon payment through maturity.
If the bond and yield curve settle dates are the same, then using the discount factor notation above, the value of the bond on this date will be</p>
<div data-type="equation">
<math alttext="25 left-parenthesis upper P left-parenthesis s comma d 3 right-parenthesis plus ellipsis plus upper P left-parenthesis s comma d Subscript p Baseline right-parenthesis right-parenthesis plus left-parenthesis 1000 plus 25 right-parenthesis upper P left-parenthesis s comma d Subscript m Baseline right-parenthesis" display="block">
  <mrow>
    <mn>25</mn>
    <mrow>
      <mo>(</mo>
      <mi>P</mi>
      <mrow>
        <mo>(</mo>
        <mi>s</mi>
        <mo>,</mo>
        <msub><mi>d</mi> <mn>3</mn> </msub>
        <mo>)</mo>
      </mrow>
      <mo>+</mo>
      <mo>⋯</mo>
      <mo>+</mo>
      <mi>P</mi>
      <mrow>
        <mo>(</mo>
        <mi>s</mi>
        <mo>,</mo>
        <msub><mi>d</mi> <mi>p</mi> </msub>
        <mo>)</mo>
      </mrow>
      <mo>)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
      <mo>(</mo>
      <mn>1000</mn>
      <mo>+</mo>
      <mn>25</mn>
      <mo>)</mo>
    </mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>,</mo>
      <msub><mi>d</mi> <mi>m</mi> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>

<p>where <em>s</em> = 2023-10-24 is the yield curve settlement date, <em>d<sub>p</sub></em> = 2032-6-21 is the penultimate coupon date, and <em>d<sub>m</sub></em> = 2032-12-21 is the maturity date.</p>

<p>It is also possible for a bond settle date to occur after the yield curve settle date.  Suppose the bond transaction is to occur two business days after the yield curve settle date.  If we let <em>s<sub>b</sub></em> = 2023-10-26, then the bond value becomes</p>
<div data-type="equation">
<math alttext="25 left-parenthesis upper P left-parenthesis s semicolon s Subscript b Baseline comma d 3 right-parenthesis plus ellipsis plus upper P left-parenthesis s semicolon s Subscript b Baseline comma d Subscript p Baseline right-parenthesis right-parenthesis plus left-parenthesis 1000 plus 25 right-parenthesis upper P left-parenthesis s semicolon s Subscript b Baseline comma d Subscript m Baseline right-parenthesis" display="block">
  <mrow>
    <mn>25</mn>
    <mrow>
      <mo>(</mo>
      <mi>P</mi>
      <mrow>
        <mo>(</mo>
        <mi>s</mi>
        <mo>;</mo>
        <msub><mi>s</mi> <mi>b</mi> </msub>
        <mo>,</mo>
        <msub><mi>d</mi> <mn>3</mn> </msub>
        <mo>)</mo>
      </mrow>
      <mo>+</mo>
      <mo>⋯</mo>
      <mo>+</mo>
      <mi>P</mi>
      <mrow>
        <mo>(</mo>
        <mi>s</mi>
        <mo>;</mo>
        <msub><mi>s</mi> <mi>b</mi> </msub>
        <mo>,</mo>
        <msub><mi>d</mi> <mi>p</mi> </msub>
        <mo>)</mo>
      </mrow>
      <mo>)</mo>
    </mrow>
    <mo>+</mo>
    <mrow>
      <mo>(</mo>
      <mn>1000</mn>
      <mo>+</mo>
      <mn>25</mn>
      <mo>)</mo>
    </mrow>
    <mi>P</mi>
    <mrow>
      <mo>(</mo>
      <mi>s</mi>
      <mo>;</mo>
      <msub><mi>s</mi> <mi>b</mi> </msub>
      <mo>,</mo>
      <msub><mi>d</mi> <mi>m</mi> </msub>
      <mo>)</mo>
    </mrow>
  </mrow>
</math>
</div>

<p>Discounted valuations are also routine calculations in trading and risk management software.  Modern professional traders use this value as a benchmark for determining the fair (or equilibrium) market price of a bond.  Risk managers will calculate bonds under multiple shocked or random yield curve scenarios to derive measures of their portfolio exposures to market risk.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="A Bond Class"><div class="sect2" id="idm45807805550448">
<h2>A Bond Class</h2>

<p>Our task now is to implement the requirements above in a user-defined <code>Bond</code> class, using the contractual terms of a bond as input data.  First, let us here consolidate and review the essential data inputs associated with a bond issue.</p>

<ul>
<li>
<p>Face value</p>
</li>
<li>
<p>Annual coupon rate</p>
</li>
<li>
<p>Number of coupon payments per year (coupon frequency)</p>
</li>
<li>
<p>Issue date</p>
</li>
<li>
<p>First coupon date</p>
</li>
<li>
<p>Penultimate coupon date</p>
</li>
<li>
<p>Maturity date</p>
</li>
<li>
<p>Day count basis</p>
</li>
</ul>

<p>Our <code>Bond</code> class can be formally summarized as shown in the class declaration below.</p>

<pre data-type="programlisting">export class Bond
{
public:
	Bond(string bond_id, const ChronoDate&amp; issue_date, const ChronoDate&amp; first_coupon_date,
		const ChronoDate&amp; penultimate_couppn_date, const ChronoDate&amp; maturity_date,
		int coupon_frequency, double coupon_rate, double face_value);

	double discounted_value(const ChronoDate&amp; bond_settle_date,
		const YieldCurve&amp; yield_curve);

	string bond_id() const;

private:
	string bond_id_;

	vector&lt;ChronoDate&gt; due_dates_;    	// Dates on which payments are due,
										// whether business days or not.
	vector&lt;ChronoDate&gt; payment_dates_;	// Business dates on which payments are made.
	vector&lt;double&gt; payment_amounts_;
};</pre>

<p>Note that all the contractual information is captured in the constructor, and valuation of the bond will be delegated to the public <code>discounted_value</code> function.  This separates what is essentially the “interface” – namely the input and processing of contractual bond data – from the “implementation” where the bond value is calculated.  Per the discussion in {[5.1]}, this valuation function is based on the bond settlement date and the market yield curve, inputs that are independent from the constructor arguments.  One specific advantage to this is a single <code>Bond</code> instance can be created, and its valuation function called many times under different market scenarios for risk reporting purposes, as noted previously.</p>

<p>There are three vectors of equal length, <code>due_dates_</code>, <code>payment_dates_</code>, and <code>payment_amounts_</code>, corresponding to the respective descriptions in Section {[5.1.1]} {Determining the Payment Schedule} above.  All three are necessary for calculating the discounted value of a bond.</p>

<p>A bond ID field is also generally required for both trading and risk applications, so it is added as a constructor argument and data member, along with a public accessor.  The <code>coupon_frequency</code> parameter represents the number of coupon payments per year – ie 2 for semiannual, and 4 for quarterly – as defined in the bond contract.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Bond Class Implementation"><div class="sect2" id="idm45807805533728">
<h2>Bond Class Implementation</h2>

<p>Next, we will work through the class implementation step by step.  The constructor will generate the due and payment dates, and the payment amounts.  Note that <code>first_coupon_date</code>, <code>penultimate_coupon_date</code> and <code>maturity_date</code> are due dates which fall on business days.  The <code>first_coupon_date</code> and <code>penultimate_coupon_date</code> input objects are also dates that are part of the regular schedule of due dates.  The maturity date may or may not be part of the regular schedule of due dates, as discussed previously.</p>

<pre data-type="programlisting">Bond::Bond(string bond_id, const ChronoDate&amp; issue_date, const ChronoDate&amp; first_coupon_date,
	const ChronoDate&amp; penultimate_coupon_date, const ChronoDate&amp; maturity_date,
	int coupon_frequency, double coupon_rate, double face_value) : bond_id_(bond_id)
{

 	// (1) Number of months in coupon period:
	const int months_in_regular_coupon_period = 12 / coupon_frequency;

	// (2) Regular coupon payment:
	const double regular_coupon_payment = coupon_rate * face_value / coupon_frequency;

	// (3) Generate vectors containing due dates, payment dates,
	// and regular coupon payment amounts:
	for (ChronoDate regular_due_date{ first_coupon_date };
		regular_due_date &lt;= penultimate_coupon_date;
		regular_due_date.add_months(months_in_regular_coupon_period))
	{
		// The due and payment Dates
		due_dates_.push_back(regular_due_date);
		ChronoDate payment_date{ regular_due_date };

		// (4) Roll any due dates falling on a weekend:
		payment_dates_.push_back(payment_date.weekend_roll());
		// Assume all coupons are regular; deal with short first period later.
		payment_amounts_.push_back(regular_coupon_payment);
	}

	// (5) If first coupon is irregular, amend the coupon payment:
	// Calculate the first_prior, the last regular date before first_coupon_date.
	ChronoDate first_prior{ first_coupon_date };
	first_prior.add_months(-months_in_regular_coupon_period);
	if (first_prior != issue_date) // if true then irregular coupon
	{
		if (first_prior &lt; issue_date) // if true then short coupon period
		{
			double coupon_fraction =
				static_cast&lt;double&gt;(first_coupon_date - issue_date) /
				static_cast&lt;double&gt;(first_coupon_date - first_prior );
			payment_amounts_[0] *= coupon_fraction;
		}
		else // issue_date &lt; first_prior, so long coupon period
		{
			// long_first_coupon = regular_coupon + extra_interest
			// Calculate the second_prior, the last regular date before the first_prior
			ChronoDate second_prior{ first_prior };
			second_prior.add_months(-months_in_regular_coupon_period);
			double coupon_fraction =
				static_cast&lt;double&gt;(first_prior - issue_date) /
					static_cast&lt;double&gt;(first_prior - second_prior);
			payment_amounts_[0] += coupon_fraction * regular_coupon_payment;
		}
	}


  // (6) The maturity date is a due date which falls on a business day:
	due_dates_.push_back( maturity_date );
	payment_dates_.push_back( maturity_date );
	// Assume maturity date is a regular due date:
	double final_coupon{ regular_coupon_payment };

  // (7) If final coupon period is irregular amend the coupon payment
  // Calculate maturity_regular_date, the first regular date after penultimate_coupon_date
	ChronoDate maturity_regular_date{ penultimate_coupon_date };
	maturity_regular_date.add_months(months_in_regular_coupon_period);
	if (maturity_regular_date != maturity_date) // if true then irregular coupon period
	{
		if (maturity_date &lt; maturity_regular_date) // if true then short coupon period
		{
			double coupon_fraction =
				static_cast&lt;double&gt;(maturity_date - penultimate_coupon_date) /
				static_cast&lt;double&gt;(maturity_regular_date - penultimate_coupon_date);
			final_coupon *= coupon_fraction;
		}
		else  // maturity_regular_date &lt; maturity_date, do long coupon period
		{
			// final_coupon = regular_coupon_amount + extra_interest
			// Calculate the next_regular_date, the first regular date
			// after the maturity_regular_date
			ChronoDate next_regular_date{ maturity_regular_date };
			next_regular_date.add_months(months_in_regular_coupon_period);
			double extra_coupon_fraction =
				static_cast&lt;double&gt;(maturity_date - maturity_regular_date) /
			static_cast&lt;double&gt;(next_regular_date - maturity_regular_date);
			final_coupon += extra_coupon_fraction * regular_coupon_payment;
	  }
	}

	// (8) Calculate final payment:
	payment_amounts_.push_back(face_value + final_coupon);

}</pre>

<p>First (1), although the <code>coupon_frequency</code> value is defined in the bond contract, and often stored in a bond database, it is easier to use the length of the regular coupon period – eg 3 months, 6 months, etc – in the tasks that follow.  This equivalent number of months is calculated as shown above and stored as the constant integer value <code>months_in_regular_coupon_period</code>.  Next (2), following the formula presented above {[5.1]}, <code>regular_coupon_payment</code> stores this value as a constant.  Recall that regular coupon periods are those which span two adjacent due dates, and all coupon periods except the first and last are guaranteed to be regular.</p>










<section data-type="sect3" data-pdf-bookmark="Generating the Date and Payment Vectors"><div class="sect3" id="idm45807805523088">
<h3>Generating the Date and Payment Vectors</h3>

<p>Now (3), the constructor implementation will generate the due and payment dates, and the payment amounts.  The <code>due_dates_</code> vector will contain the regular dates that get generated for each respective coupon period – eg every six months – up to the contractual penultimate coupon date.  These are not adjusted for weekends.  Because the <code>+=</code> operator for months on <code>std::chrono::year_month_day</code> guarantees the same day value, with the correct year and month result, we are OK as long as the successive date is valid.  Bonds have many variations, but since this is not production code it is simplified by assuming the coupon day is less than 29.  This avoids end of month calculations.</p>

<p>At point (4), the <code>weekend_roll</code> member function is applied to successive copies of each due date and pushed onto the <code>payment_dates_</code> vector prior to the penultimate payment date.  Thus, any due date falling on a weekend is rolled to the next business date.  The regular coupon payment amount is also appended to the <code>payment_amounts_</code> vector corresponding to each regular date.</p>

<p>In the previous step, the first coupon payment was naively set to the regular amount, so in (5), a check is made whether the first payment period is irregular.  If so, a nested conditional statement determines whether this period is short or long.  In the event of a short period, the first prior date is found by subtracting the number of months in a regular period from the first payment date, and then the prorated coupon is calculated.  In the event of a long period, the second prior date is determined, and then the prorated coupon over the interval from issue to the first prior date is calculated.  The total first coupon payment is then this prorated amount plus a regular payment {[see 5.1.1]}.</p>

<p>The maturity date is a business day and is appended to each date vector.  It is provisionally assumed to follow a normal payment period, and thus the final payment is set to the regular coupon amount plus the face value of the bond at this point (6).  Then, one more conditional statement checks if the final period is regular or not.  If so, an adjustment is made to the final payment.  Similar calculations to an irregular first period are performed, but using prospective rather than retrospective extensions (7).</p>

<p>Finally (8), the final payment consisting of the final coupon payment and return of face value is appended to the vector of payments.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Bond Valuation"><div class="sect3" id="idm45807805515520">
<h3>Bond Valuation</h3>

<p>Although bonds can be traded at whichever price a buyer and seller agree, traders will usually require having access to the benchmark “fair” price, namely the sum of the discounted payments remaining as of the bond settlement date.
As noted in Section {[5.1.2]}, the buyer of a bond becomes entitled to receive all payments that are due strictly <em>after</em> the settlement date.  This introduces a special case that is addressed in the code, namely if bond settlement occurs on a due date, the coupon payment is paid to the seller.  Therefore, only those coupon payments due after settlement add to the bond value in the form of discounted amounts.  If a due date falls on a weekend, it cannot be a settle date, and therefore the payment date is rolled to the next Monday and is payable to the buyer.  It is for this reason the <code>Bond</code> class has both due date and payment date vectors as data members.</p>

<pre data-type="programlisting">double Bond::discounted_value(const ChronoDate&amp; bond_settle_date,
     const YieldCurve&amp; yield_curve)
{
	// The buyer receives the payments which fall due after the bond_settle_date
	// If the bond_settle_date falls on a due_date the seller receives the payment
	double pv{ 0.0 };
	for (size_t i{ 0 }; i &lt; due_dates_.size(); i++)
	{
		if (bond_settle_date &lt; due_dates_[i])
			pv += yield_curve.discount_factor(bond_settle_date, payment_dates_[i])
				* payment_amounts_[i];
	}
	return pv;
}</pre>

<p>The code will loop through the <code>due_dates_</code> member vector until the first due date strictly later than settlement is located.  At this point, each remaining payment – starting with the same current index as <code>due_dates_</code> — is obtained from the <code>payment_amounts_</code> vector.  Each payment value is discounted from the payment date back to the bond settlement date.  The discount factor that multiplies each payment is easily obtained by the eponymous member function on the <code>yield_curve</code> input object.  The cumulative sum of these discounted payments is then returned as the fair market value of the bond.</p>

<p>As you may notice, this valuation function is short and compact, as the due dates have been generated by the constructor, along with the payment dates adjusted for business days where necessary.  The payment amounts – including the final payment comprised of the last coupon payment and return of face value – were also computed by the constructor, including any adjustment to the first payment in the event of an irregular short or long payment period.</p>

<p>The discount factors back to the bond settlement date are easily obtained from the member function <code>discounted_value</code> on the input <code>yield_curve</code> object, while all the date functionality is wrapped in the <code>ChronoDate</code> class.  In essence, the <code>discounted_value</code> function doesn’t “need to care” about how the discount factors or date calculations are obtained.  It just uses public member functions on the objects to get the information it needs and computes the result.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="A Bond Valuation Example"><div class="sect2" id="idm45807805505152">
<h2>A Bond Valuation Example</h2>

<p>We can now put the individual classes previously presented into an example of pricing a bond.  Recall that the <code>YieldCurve</code> abstract base class will required a derived curve fitting method.  Again, there are many different approaches available, ranging from simple to highly advanced, but to keep the example concise, we will use linear interpolation.  In constructing a <code>Bond</code> object, we will need to supply the face value, issue date, first coupon date, penultimate payment date, and maturity of the bond, along with its face value.</p>

<p>{UML diagram here}
As an example, suppose the term sheet of a 20-year bond is as follows:</p>
<table>
<caption><span class="label">Table 4-1. </span>Table 9-1:  Contractual bond terms - example</caption>
<thead>
<tr>
<th/>
<th/>
</tr>
</thead>
<tbody>
<tr>
<td><p>Face Value</p></td>
<td><p>$1000</p></td>
</tr>
<tr>
<td><p>Annual Coupon Rate</p></td>
<td><p>6.2%</p></td>
</tr>
<tr>
<td><p>Payment Frequency</p></td>
<td><p>Every six months (semiannual)</p></td>
</tr>
<tr>
<td><p>Issue Date</p></td>
<td><p>Mon 8 May 2023</p></td>
</tr>
<tr>
<td><p>First Coupon Date</p></td>
<td><p>Tue 7 Nov 2023</p></td>
</tr>
<tr>
<td><p>Penultimate Coupon Date</p></td>
<td><p>Wed 7 May 2042</p></td>
</tr>
<tr>
<td><p>Maturity Date</p></td>
<td><p>Fri 7 Nov 2042</p></td>
</tr>
</tbody>
</table>

<p>Data in practice would be taken in from an interface and converted to <code>ChronoDate</code> types, but we can replicate the result as follows:</p>

<pre data-type="programlisting">std::string bond_id = "20 yr bond"; // normal 20 year bond

ChronoDate issue_date{ 2023, 5, 8 };		   		// (Mon)
ChronoDate first_coupon_date{ 2023, 11, 7 };       	// Short first coupon (Tue)
ChronoDate penultimate_coupon_date{ 2042, 5, 7 };  	// (Wed)
ChronoDate maturity_date{ 2042, 11, 7 };           	// Long final coupon (Fri)

int coupon_frequency{ 2 };
double coupon_rate{ 0.062 };
double face_value{ 1000.00 };
Construction of the bond is then straightforward:
Bond bond_20_yr{ bond_id, issue_date, first_coupon_date, penultimate_coupon_date,
		maturity_date, coupon_frequency, coupon_rate, face_value, day_count };</pre>

<p>Recall, however, the due dates, payment dates, and payment amounts are all generated and adjusted in the body of the constructor.  Each due date will carry a day value of 7, and the payment dates are the same except for the due dates falling on weekends that are rolled to the next Monday:</p>

<p>2026-11-09, 2027-11-08, 2028-05-08,</p>

<p>2032-11-08, 2033-05-09, 2034-05-08,</p>

<p>2037-11-09, 2038-11-08, 2039-05-09</p>

<p>The regular coupon amount is</p>
<div data-type="equation">
<math alttext="StartFraction 1000 left-parenthesis 0.0625 right-parenthesis Over 2 EndFraction equals normal dollar-sign 31.00" display="block">
  <mrow>
    <mfrac><mrow><mn>1000</mn><mo>(</mo><mn>0</mn><mo>.</mo><mn>0625</mn><mo>)</mo></mrow> <mn>2</mn></mfrac>
    <mo>=</mo>
    <mi>$</mi>
    <mn>31</mn>
    <mo>.</mo>
    <mn>00</mn>
  </mrow>
</math>
</div>

<p>The only irregular period will be the from settle to the first coupon date, 2023-05-08 to 2023-11-07, resulting in the calculated coupon amount as</p>
<div data-type="equation">
<math alttext="31 left-parenthesis StartFraction 183 Over 184 EndFraction right-parenthesis equals normal dollar-sign 24.86" display="block">
  <mrow>
    <mn>31</mn>
    <mo>(</mo>
    <mfrac><mn>183</mn> <mn>184</mn></mfrac>
    <mo>)</mo>
    <mo>=</mo>
    <mi>$</mi>
    <mn>24</mn>
    <mo>.</mo>
    <mn>86</mn>
  </mrow>
</math>
</div>

<p>where <math alttext="StartFraction 183 Over 184 EndFraction">
  <mfrac><mn>183</mn> <mn>184</mn></mfrac>
</math> is the ratio of the actual number of days in the first period by the number of days from the first prior date to first coupon date.</p>

<p>Next, suppose we want to value the bond on a date between issue and first coupon date, say Tuesday, 10 October 2023.  Suppose also market data as of this date imply the following spot yields:</p>
<table>
<caption><span class="label">Table 4-2. </span>Table 9-2:  Spot yields - example (figures rounded)</caption>
<thead>
<tr>
<th>Period</th>
<th>Maturity</th>
<th>Year Fraction</th>
<th>Yield</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Overnight</p></td>
<td><p>2023-10-11</p></td>
<td><p>0.00274</p></td>
<td><p>2%</p></td>
</tr>
<tr>
<td><p>3 Month</p></td>
<td><p>2024-01-10</p></td>
<td><p>0.25205</p></td>
<td><p>2.19%</p></td>
</tr>
<tr>
<td><p>6 Month</p></td>
<td><p>2024-04-10</p></td>
<td><p>0.50137</p></td>
<td><p>2.37%</p></td>
</tr>
<tr>
<td><p>1 Year</p></td>
<td><p>2024-10-10</p></td>
<td><p>1.00274</p></td>
<td><p>2.67%</p></td>
</tr>
<tr>
<td><p>2 Year</p></td>
<td><p>2025-10-10</p></td>
<td><p>2.00274</p></td>
<td><p>3.12%</p></td>
</tr>
<tr>
<td><p>3 Year</p></td>
<td><p>2026-10-12</p></td>
<td><p>3.00822</p></td>
<td><p>3.43%</p></td>
</tr>
<tr>
<td><p>5 Year</p></td>
<td><p>2028-10-10</p></td>
<td><p>5.00548</p></td>
<td><p>3.78%</p></td>
</tr>
<tr>
<td><p>7 Year</p></td>
<td><p>2030-10-10</p></td>
<td><p>7.00548</p></td>
<td><p>3.93%</p></td>
</tr>
<tr>
<td><p>10 Year</p></td>
<td><p>2033-10-10</p></td>
<td><p>10.0082</p></td>
<td><p>4%</p></td>
</tr>
<tr>
<td><p>15 Year</p></td>
<td><p>2038-10-11</p></td>
<td><p>15.0137</p></td>
<td><p>4.01%</p></td>
</tr>
<tr>
<td><p>20 Year</p></td>
<td><p>2043-10-12</p></td>
<td><p>20.0192</p></td>
<td><p>4.01%</p></td>
</tr>
<tr>
<td><p>30 Year</p></td>
<td><p>2053-10-10</p></td>
<td><p>30.0219</p></td>
<td><p>4%</p></td>
</tr>
</tbody>
</table>

<p>Create two vectors containing the maturities (as year fractions) and discount bond prices above (again, in place of containers that would normally be initialized in an interface):</p>

<pre data-type="programlisting">std::vector&lt;double&gt; maturities{0.00273973, 0.252055, . . ., 30.0219};
std::vector&lt;double&gt; spot_yields{0.0200219, 0.021924, . . ., 0.0400049};</pre>

<p>And also the settlement date:</p>

<pre data-type="programlisting">ChronoDate spot_settle_date{ 2023, 10, 10 };</pre>

<p>With these, we can create an instance of a linearly interpolated yield curve:</p>

<pre data-type="programlisting">LinearInterpYieldCurve yc{ spot_settle_date, maturities , spot_yields };</pre>

<p>Then, to value the bond as of the same settlement date, provide the settlement date and yield curve data to the corresponding member function on the <code>Bond</code> object:</p>

<pre data-type="programlisting">double value = bond_20_yr.discounted_value(spot_settle_date, yc);</pre>

<p>This function will locate the first due date after settlement (in this case the first coupon date), compute each continuously compounded discount factor from each payment date back to the settle date using interpolated rates off of the yield curve, multiply each payment by this discount factor, and sum the discounted values to determine the discounted value of the bond.  In this example, the result is $1315.34.</p>

<p>Note the design separating the bond data “interface” from the “implementation” provides flexibility in two respects.  First, as noted above, a <code>Bond</code> object can be created once, and then multiple random or shocked yield curve scenarios can be applied to the valuation of the same bond.  This can make calculations of risk measures more efficient by obviating the need to create a whole new <code>Bond</code> object for each scenario.  Thousands of scenarios are often applied in these situations, and there can be thousands of bonds in a portfolio, held in multiple bond portfolios across all the international trading operations within a financial institution.  Avoiding new object creation at every step can make a measurable difference in the time required to calculate risk values.</p>

<p>The other case could be where the bond settlement date is set for some point in the (near) future, but an expected valuation as of current market conditions is needed today.  As long as the bond settlement date is on or after yield curve settlement, the valuation will be valid.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Summary"><div class="sect2" id="idm45807805431392">
<h2>Summary</h2>

<p>TBD</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="References"><div class="sect2" id="idm45807805429776">
<h2>References</h2>

<p>{0} Nicolai Josuttis, The C++ Standard Library 2E, Sec 5.7.1, pp 143-44</p>

<p>{1} <code>std::chrono</code> date GitHub repository:  <a href="https://github.com/HowardHinnant/date" class="bare"><em class="hyperlink">https://github.com/HowardHinnant/date</em></a></p>

<p>{2} Howard Hinnant, Stack Overflow (Fact 5),
<a href="https://stackoverflow.com/questions/59418514/using-c20-chrono-how-to-compute-various-facts-about-a-date" class="bare"><em class="hyperlink">https://stackoverflow.com/questions/59418514/using-c20-chrono-how-to-compute-various-facts-about-a-date</em></a></p>

<p>{3} <code>chrono</code>-Compatible Low-Level Date Algorithms
<a href="https://howardhinnant.github.io/date_algorithms.html" class="bare"><em class="hyperlink">https://howardhinnant.github.io/date_algorithms.html</em></a></p>

<p>{4} Howard Hinnant, Stack Overflow, “C++ chrono: Determine Whether a Day is a Weekend”
<a href="https://stackoverflow.com/questions/52776999/c-chrono-determine-whether-day-is-a-weekend" class="bare"><em class="hyperlink">https://stackoverflow.com/questions/52776999/c-chrono-determine-whether-day-is-a-weekend</em></a></p>

<p>{5} Howard Hinnant, Stack Overflow, “How Do I Add a Number of Days to a Date in C++20 chrono”
<a href="https://stackoverflow.com/questions/62734974/how-do-i-add-a-number-of-days-to-a-date-in-c20-chrono" class="bare"><em class="hyperlink">https://stackoverflow.com/questions/62734974/how-do-i-add-a-number-of-days-to-a-date-in-c20-chrono</em></a></p>

<p>{6} ISDA 30/360 Day Count Basis
<a href="https://www.iso20022.org/15022/uhb/mt565-16-field-22f.htm" class="bare"><em class="hyperlink">https://www.iso20022.org/15022/uhb/mt565-16-field-22f.htm</em></a></p>

<p>{6.5} Steiner pp 40-41</p>

<p>{7} Kenneth J Adams, Smooth interpolation of zero curves, Algo Research Quarterly,
4(1/2):11-22, 2001</p>

<p>{8} Hagan and West, Interpolation Methods for Curve Construction, Applied Mathematical Finance,  Vol. 13, No. 2. 89-129, June 2006</p>

<p>{9} C++ Add months to chrono::system_clock::time_point, Stack Overflow, <a href="https://stackoverflow.com/questions/43010362/c-add-months-to-chronosystem-clocktime-point/43018120#43018120" class="bare"><em class="hyperlink">https://stackoverflow.com/questions/43010362/c-add-months-to-chronosystem-clocktime-point/43018120#43018120</em></a> (Not referenced directly)</p>
</div></section>
</div></section>
</div></section></div></body></html>