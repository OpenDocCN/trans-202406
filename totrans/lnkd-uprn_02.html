<html><head></head><body><section data-pdf-bookmark="Chapter 2. Intro to Linkerd" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="LUAR_intro_to_linkerd">
<h1 class="calibre7"><span class="calibre">Chapter 2. </span>Intro to Linkerd</h1>


<p class="author1">The year 2015 was a very good one for<a data-primary="Kubernetes" data-secondary="first release (2015)" data-type="indexterm" id="id424" class="calibre4"/><a data-primary="Cloud Native Computing Foundation (CNCF)" data-type="indexterm" id="id425" class="calibre4"/><a data-primary="Cloud Native Computing Foundation (CNCF)" data-secondary="Linkerd among first donated" data-type="indexterm" id="id426" class="calibre4"/><a data-primary="Linkerd" data-secondary="as first service mesh" data-secondary-sortas="first service mesh" data-type="indexterm" id="id427" class="calibre4"/><a data-primary="service meshes" data-secondary="Linkerd as first" data-type="indexterm" id="id428" class="calibre4"/><a data-primary="Buoyant, Inc." data-secondary="Linkerd as first service mesh" data-type="indexterm" id="id429" class="calibre4"/><a data-primary="Linkerd" data-secondary="about" data-tertiary="open source" data-type="indexterm" id="id430" class="calibre4"/><a data-primary="open source Linkerd" data-type="indexterm" id="id431" class="calibre4"/> cloud native computing: it brought us the first
Kubernetes release, the creation of the Cloud Native Computing Foundation
(CNCF), and the creation of Linkerd. Linkerd was one of the first five projects
donated to the CNCF, and it was the project that coined the term “service
mesh.” <a data-primary="Linkerd" data-secondary="history of" data-type="indexterm" id="ch2-hist" class="calibre4"/><a data-primary="history of Linkerd" data-type="indexterm" id="ch2-hist2" class="calibre4"/><a data-primary="Buoyant, Inc." data-secondary="Linkerd history" data-type="indexterm" id="ch2-hist3" class="calibre4"/><a data-primary="Buoyant, Inc." data-secondary="founding of" data-type="indexterm" id="id432" class="calibre4"/></p>

<p class="author1">In this chapter, you’ll learn more about Linkerd, where it comes from,
what makes it special, and how it works. We’ll keep the history lesson short, useful, and interesting, but if you want
to get right to the important information, feel free to skip ahead.</p>






<section data-pdf-bookmark="Where Does Linkerd Come From?" data-type="sect1" class="preface"><div class="preface" id="id7">
<h1 class="calibre8">Where Does Linkerd Come From?</h1>

<p class="author1">The Linkerd project was created in 2015 at Buoyant, Inc., by former Twitter
engineers William Morgan and Oliver Gould. The first public release of Linkerd
was in February 2016.<a data-primary="Morgan, William" data-type="indexterm" id="id433" class="calibre4"/><a data-primary="Gould, Oliver" data-type="indexterm" id="id434" class="calibre4"/> You can see a brief summary of its history in <a data-type="xref" href="#linkerd-timeline" class="calibre4">Figure 2-1</a>.</p>

<figure class="calibre23"><div class="figure" id="linkerd-timeline">
<img alt="luar 0201" src="assets/luar_0201.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-1. </span>A brief timeline of Linkerd</h6>
</div></figure>








<section data-pdf-bookmark="Linkerd1" data-type="sect2" class="preface"><div class="preface" id="id8">
<h2 class="calibre27">Linkerd1</h2>

<p class="author1">That first version of Linkerd, now called “Linkerd1,” was written mostly in
Scala and was largely based on the Finagle RPC library created at Twitter. It
was a multiplatform mesh that supported several different container
schedulers and offered a number of powerful features. However, using Finagle
required Linkerd1 to run on the Java Virtual Machine (JVM), and ultimately the
JVM’s performance was simply too high a cost to bear.</p>

<p class="author1">Linkerd1 is at its end of life. <a data-primary="Linkerd2 as Linkerd" data-type="indexterm" id="id435" class="calibre4"/>Going forward, when we talk about “Linkerd,”
we’ll be referring to modern Linkerd—Linkerd2.</p>
</div></section>








<section data-pdf-bookmark="Linkerd2" data-type="sect2" class="preface"><div class="preface" id="id119">
<h2 class="calibre27">Linkerd2</h2>

<p class="author1">In 2018, the Linkerd project left the Scala world behind with a ground-up
rewrite based on hard-won experience from Linkerd1 use in the real world. <a data-primary="Kubernetes" data-secondary="Linkerd exclusive support for" data-type="indexterm" id="id436" class="calibre4"/><a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Kubernetes exclusive support" data-type="indexterm" id="id437" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="Kubernetes exclusive support" data-type="indexterm" id="id438" class="calibre4"/><a data-primary="Linkerd" data-secondary="Kubernetes exclusively" data-type="indexterm" id="id439" class="calibre4"/>The
project dropped support for other container orchestration engines and moved to
exclusively supporting Kubernetes, with most of the code written in Go.
<a data-primary="communication" data-secondary="Rust proxy for" data-type="indexterm" id="id440" class="calibre4"/><a data-primary="Rust" data-secondary="Linkerd communication proxy" data-type="indexterm" id="id441" class="calibre4"/>Additionally, the developers chose to write a small, fast, purpose-built Rust
proxy (creatively called <code class="calibre9">linkerd2-proxy</code>) to manage application
communications, rather than adopting the Envoy proxy.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Linkerd and Rust</h1>
<p class="author1">When the Linkerd2 rewrite started,<a data-primary="Rust" data-secondary="memory safety of" data-type="indexterm" id="id442" class="calibre4"/><a data-primary="memory" data-secondary="Rust memory safety" data-type="indexterm" id="id443" class="calibre4"/> the Rust programming language had been
gaining attention for its memory safety, which enables developers to write
code that avoids many of the memory management vulnerabilities inherent to C
and C++, while still compiling to native code for high performance. The
downside was that Rust’s networking support was sometimes lacking features
needed by Linkerd2; in many cases, the Linkerd2 developers ended up adding
these features to Rust crates like <code class="calibre9">hyper</code> and <code class="calibre9">tokio</code>.</p>
</div>

<p class="author1">The driver behind the decisions<a data-primary="Kubernetes" data-secondary="Linkerd exclusive support for" data-tertiary="operational simplicity" data-type="indexterm" id="id444" class="calibre4"/><a data-primary="Linkerd" data-secondary="Kubernetes exclusively" data-tertiary="operational simplicity" data-type="indexterm" id="id445" class="calibre4"/> to focus on Kubernetes and to create a
purpose-built proxy was <em class="hyperlink">operational simplicity</em>: the idea that a project
should be able to deliver functionality and performance while still being
simple to learn and use. This concept has had a tremendous impact on the
Linkerd project as a whole, and it continues to be a major focus of Linkerd’s
development.</p>
</div></section>








<section data-pdf-bookmark="The Linkerd Proxy" data-type="sect2" class="preface"><div class="preface" id="id9">
<h2 class="calibre27">The Linkerd Proxy</h2>

<p class="author1">It’s worth repeating that <code class="calibre9">linkerd2-proxy</code> is <em class="hyperlink">not</em> a <a data-primary="communication" data-secondary="Rust proxy for" data-tertiary="purpose-built for Linkerd" data-type="indexterm" id="id446" class="calibre4"/><a data-primary="Rust" data-secondary="Linkerd communication proxy" data-tertiary="purpose-built for Linkerd" data-type="indexterm" id="id447" class="calibre4"/>general-purpose proxy;
it was purpose-built for use in Linkerd. It’s extremely fast and lightweight,
and as a user of Linkerd, you should almost never need to interact with it
directly—it is very much meant to be invisible in normal use, and most
Linkerd users never need to tune or debug <code class="calibre9">linkerd2-proxy</code>. (In fact, the
maintainers of Linkerd like to joke that the only <code class="calibre9">linkerd2-proxy</code> experts on
the planet are…the Linkerd maintainers.)</p>

<p class="author1">The Linkerd control plane, introduced in the next section, will be your main interface when working with
Linkerd.<a data-startref="ch2-hist" data-type="indexterm" id="id448" class="calibre4"/><a data-startref="ch2-hist2" data-type="indexterm" id="id449" class="calibre4"/><a data-startref="ch2-hist3" data-type="indexterm" id="id450" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="main interface for Linkerd" data-type="indexterm" id="id451" class="calibre4"/></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Linkerd Architecture" data-type="sect1" class="preface"><div class="preface" id="id10">
<h1 class="calibre8">Linkerd Architecture</h1>

<p class="author1">Because Linkerd is written to be<a data-primary="Linkerd" data-secondary="architecture" data-type="indexterm" id="id452" class="calibre4"/><a data-primary="architecture of Linkerd" data-type="indexterm" id="id453" class="calibre4"/><a data-primary="service meshes" data-secondary="architecture" data-type="indexterm" id="id454" class="calibre4"/><a data-primary="Kubernetes API" data-secondary="Linkerd management via" data-type="indexterm" id="id455" class="calibre4"/><a data-primary="APIs" data-secondary="Kubernetes API" data-tertiary="Linkerd management via" data-type="indexterm" id="id456" class="calibre4"/> Kubernetes-native, all of its control surface
is exposed in Kubernetes objects. You will manage, configure, and troubleshoot
Linkerd via the Kubernetes API.</p>

<p class="author1">Like other service meshes, Linkerd is<a data-primary="data plane of Linkerd" data-type="indexterm" id="id457" class="calibre4"/><a data-primary="control plane of Linkerd" data-type="indexterm" id="id458" class="calibre4"/> broken into two main components: the
<em class="hyperlink">data plane</em>, which is the part of the mesh that handles application data
directly (primarily composed of the proxies), and the <em class="hyperlink">control plane</em>, which
manages the data plane. <a data-primary="Pods" data-secondary="Linkerd architecture" data-type="indexterm" id="id459" class="calibre4"/>This architecture is shown in
<a data-type="xref" href="#linkerd-architecture" class="calibre4">Figure 2-2</a>.</p>

<p class="author1">Linkerd works by taking advantage<a data-primary="sidecar model" data-secondary="Linkerd architecture" data-type="indexterm" id="id460" class="calibre4"/><a data-primary="Linkerd" data-secondary="architecture" data-tertiary="sidecar model of service meshes" data-type="indexterm" id="id461" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="sidecar model of service meshes" data-type="indexterm" id="id462" class="calibre4"/> of the Kubernetes concept of sidecars, which
allows every application container to be paired with a dedicated proxy that
handles all network traffic. The proxies—the data plane of the mesh—implement the advanced functionality of the mesh itself, mediating and measuring all the traffic passing through them.</p>

<figure class="calibre23"><div class="figure" id="linkerd-architecture">
<img alt="luar 0202" src="assets/luar_0202.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-2. </span>Linkerd’s internal architecture</h6>
</div></figure>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Kubernetes Sidecar Containers</h1>
<p class="author1">Kubernetes didn’t have a formal<a data-primary="sidecar model" data-secondary="Kubernetes sidecar containers" data-type="indexterm" id="id463" class="calibre4"/><a data-primary="Kubernetes" data-secondary="sidecar containers" data-type="indexterm" id="id464" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="sidecar model of service meshes" data-tertiary="Kubernetes sidecar containers" data-type="indexterm" id="id465" class="calibre4"/><a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Kubernetes sidecar containers" data-type="indexterm" id="id466" class="calibre4"/> sidecar container type until the adoption of
<a href="https://oreil.ly/ShohB" class="calibre4">KEP-753</a>
in Kubernetes 1.28. The sidecar <em class="hyperlink">concept</em> predates KEP-753 by many years,
though.</p>

<p class="author1">Linkerd does support KEP-753 sidecar containers as of Linkerd <code class="calibre9">edge-23.11.4</code>, if you’re running Kubernetes 1.28 or later.</p>
</div>

<p class="author1">Linkerd also supports the<a data-primary="control plane of Linkerd" data-secondary="extensions" data-type="indexterm" id="id467" class="calibre4"/><a data-primary="extensions" data-type="indexterm" id="id468" class="calibre4"/><a data-primary="microservices architecture" data-secondary="extensions" data-type="indexterm" id="id469" class="calibre4"/> concept of <em class="hyperlink">extensions</em>, extra
microservices that run as part of the control plane to implement optional
functionality (either in the cluster or in the Linkerd CLI). Some extensions
(such as the Viz and Multicluster extensions) are bundled with the official
Linkerd build; though they must be installed into the cluster separately, you
don’t need any extra tools to do so. Others (such as the SMI extension) must
be obtained separately before you can install them; the documentation for the
extension should tell you how to do this.</p>








<section data-pdf-bookmark="mTLS and Certificates" data-type="sect2" class="preface"><div class="preface" id="id11">
<h2 class="calibre27">mTLS and Certificates</h2>

<p class="author1">Linkerd relies heavily on <a data-primary="Linkerd" data-secondary="architecture" data-tertiary="mTLS and certificates" data-type="indexterm" id="id470" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="mTLS and certificates" data-type="indexterm" id="id471" class="calibre4"/><a data-primary="security" data-secondary="Transport Layer Security" data-type="indexterm" id="id472" class="calibre4"/><a data-primary="communication" data-secondary="Transport Layer Security" data-type="indexterm" id="id473" class="calibre4"/><a data-primary="TLS (Transport Layer Security)" data-type="indexterm" id="id474" class="calibre4"/><a data-primary="networking" data-see="communication" data-type="indexterm" id="id475" class="calibre4"/><a data-primary="Transport Layer Security" data-see="TLS" data-type="indexterm" id="id476" class="calibre4"/>Transport Layer Security (TLS), illustrated
in <a data-type="xref" href="#tls-architecture-diagram-1" class="calibre4">Figure 2-3</a>, for networking security—nearly all of the
communications shown in <a data-type="xref" href="#linkerd-architecture" class="calibre4">Figure 2-2</a> are protected using TLS.</p>

<figure class="calibre23"><div class="figure" id="tls-architecture-diagram-1">
<img alt="luar 0203" src="assets/luar_0203.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-3. </span>TLS architecture</h6>
</div></figure>

<p class="author1">TLS is the technology that’s underpinned data security and privacy on the
Internet for the last quarter century by allowing secure communication over
an insecure network, even if the parties communicating have never done so
before. It is a <em class="hyperlink">huge</em> topic, easily worth a book on its own. We’ll talk more
about it in <a data-type="xref" href="ch07.html#LUAR_mtls_and_certs" class="calibre4">Chapter 7</a>, <a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-tertiary="TLS and mTLS" data-type="indexterm" id="id477" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-tertiary="TLS and mTLS" data-type="indexterm" id="id478" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-tertiary="TLS and mTLS" data-type="indexterm" id="id479" class="calibre4"/><a data-primary="encryption" data-secondary="TLS for cluster communications" data-type="indexterm" id="id480" class="calibre4"/><a data-primary="mutual TLS" data-see="mTLS" data-type="indexterm" id="id481" class="calibre4"/>but at the architectural level, it’s
important to understand that Linkerd uses TLS to encrypt communications within
the cluster, and also as the foundation of identity within the mesh
(specifically using <em class="hyperlink">mutual TLS</em>, or <em class="hyperlink">mTLS</em>).</p>

<p class="author1">In TLS, encryption and identity<a data-primary="encryption" data-secondary="TLS for cluster communications" data-tertiary="keypairs of public and private keys" data-type="indexterm" id="id482" class="calibre4"/><a data-primary="identity" data-secondary="TLS keypairs" data-type="indexterm" id="id483" class="calibre4"/><a data-primary="keypairs of public and private keys" data-type="indexterm" id="id484" class="calibre4"/><a data-primary="private keys" data-type="indexterm" id="id485" class="calibre4"/><a data-primary="public keys" data-type="indexterm" id="id486" class="calibre4"/> both rely on <em class="hyperlink">keypairs</em>. A keypair consists of
a <em class="hyperlink">public key</em> and a <em class="hyperlink">private key</em>, where:</p>

<ul class="printings">
<li class="calibre6">
<p class="author1">The <em class="hyperlink">private</em> key must be known only to the single entity that the keypair 
<span class="calibre">identifies.</span></p>
</li>
<li class="calibre6">
<p class="author1">The <em class="hyperlink">public</em> key must be known to everyone who needs to communicate with that entity.</p>
</li>
</ul>

<p class="author1">The keypair allows an entity (say, a workload in the Linkerd mesh) to use the
private key to attest to its identity; other entities can use the public key
to verify that claim.</p>

<p class="author1">An important note about keypairs<a data-primary="keypairs of public and private keys" data-secondary="rotating the keys" data-type="indexterm" id="id487" class="calibre4"/><a data-primary="rotating the keys" data-type="indexterm" id="id488" class="calibre4"/><a data-primary="public keys" data-secondary="rotating the keys" data-type="indexterm" id="id489" class="calibre4"/><a data-primary="private keys" data-secondary="rotating the keys" data-type="indexterm" id="id490" class="calibre4"/> is that they need to have a limited lifetime,
so every so often we need a way to replace the keys in use for any given
entity. This is called <em class="hyperlink">rotating</em> the keys.</p>
</div></section>








<section data-pdf-bookmark="Certifying Authorities" data-type="sect2" class="preface"><div class="preface" id="id12">
<h2 class="calibre27">Certifying Authorities</h2>

<p class="author1">Since it’s very tedious to try to <a data-primary="Linkerd" data-secondary="architecture" data-tertiary="certifying authorities" data-type="indexterm" id="id491" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="mTLS and certificates" data-tertiary="certifying authorities" data-type="indexterm" id="id492" class="calibre4"/><a data-primary="certifying authorities (CAs)" data-type="indexterm" id="id493" class="calibre4"/><a data-primary="public keys" data-secondary="certifying authorities" data-type="indexterm" id="id494" class="calibre4"/><a data-primary="private keys" data-secondary="certifying authorities" data-type="indexterm" id="id495" class="calibre4"/><a data-primary="private keys" data-secondary="certificates" data-type="indexterm" id="id496" class="calibre4"/><a data-primary="keypairs of public and private keys" data-secondary="certifying authorities" data-type="indexterm" id="id497" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="TLS" data-type="indexterm" id="id498" class="calibre4"/><a data-primary="certificates" data-secondary="TLS" data-type="indexterm" id="id499" class="calibre4"/><a data-primary="TLS (Transport Layer Security)" data-secondary="X.509 certificates" data-type="indexterm" id="id500" class="calibre4"/><a data-primary="authentication" data-secondary="X.509 certificates" data-tertiary="TLS" data-type="indexterm" id="id501" class="calibre4"/>keep track of public and private keys
separately all the time, TLS uses keys that are bundled up in <em class="hyperlink">X.509
certificates</em> (mostly just called certificates), which give us a standard
format to save the keys and a standard way to allow using one certificate to
attest that another is valid. This is called <em class="hyperlink">issuing</em> a certificate or
<em class="hyperlink">signing</em> a certificate. Organizations that support the process of issuing
certificates are called <em class="hyperlink">certifying authorities</em> or <em class="hyperlink">CAs</em>. There are companies
that treat being a CA as a core part of their business (such as Let’s
Encrypt, Venafi, and most cloud providers) as well as software that permits
establishing CAs within our own organizations.</p>

<p class="author1">Using certificates to issue other certificates naturally creates a hierarchy
of certificates that form a chain of trust from a single root, as shown in
<a data-type="xref" href="#certificate-hierarchy-diagram-1" class="calibre4">Figure 2-4</a>.</p>

<figure class="calibre23"><div class="figure" id="certificate-hierarchy-diagram-1">
<img alt="luar 0204" src="assets/luar_0204.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-4. </span>The certificate trust hierarchy</h6>
</div></figure>

<p class="author1">Linkerd—like everything else that uses TLS—requires a properly configured
hierarchy of certificates in order to function. We’ll discuss this in more
detail in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#LUAR_deploying_linkerd" class="calibre4">3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.html#LUAR_mtls_and_certs" class="calibre4">7</a>.</p>
</div></section>








<section data-pdf-bookmark="The Linkerd Control Plane" data-type="sect2" class="preface"><div class="preface" id="id13">
<h2 class="calibre27">The Linkerd Control Plane</h2>

<p class="author1">As of this writing, the core Linkerd <a data-primary="Linkerd" data-secondary="architecture" data-tertiary="control plane" data-type="indexterm" id="id502" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="control plane" data-type="indexterm" id="id503" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="Linkerd architecture" data-type="indexterm" id="id504" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="Linkerd architecture" data-tertiary="proxy injector" data-type="indexterm" id="id505" class="calibre4"/><a data-primary="linkerd-proxy-injector" data-type="indexterm" id="id506" class="calibre4"/><a data-primary="Kubernetes" data-secondary="sidecar containers" data-tertiary="admission controller" data-type="indexterm" id="id507" class="calibre4"/><a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Kubernetes sidecar admission controller" data-type="indexterm" id="id508" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="sidecar model of service meshes" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="id509" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="id510" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="id511" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="id512" class="calibre4"/><a data-primary="proxy injector of control plane" data-type="indexterm" id="id513" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="Linkerd architecture" data-tertiary="identity controller" data-type="indexterm" id="id514" class="calibre4"/><a data-primary="identity controller of control plane" data-type="indexterm" id="id515" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="Linkerd architecture" data-tertiary="destination controller" data-type="indexterm" id="id516" class="calibre4"/><a data-primary="destination controller of control plane" data-type="indexterm" id="id517" class="calibre4"/>control plane is composed of three primary
components, as shown in <a data-type="xref" href="#linkerd-control-plane-architecture" class="calibre4">Figure 2-5</a>: the <em class="hyperlink">proxy
injector</em>, the <em class="hyperlink">identity controller</em>, and the <em class="hyperlink">destination controller</em>. We will
discuss these components in more detail in <a data-type="xref" href="ch15.html#LUAR_troubleshooting" class="calibre4">Chapter 15</a>.
Fundamentally, they are responsible for allowing you to add
individual applications to your service mesh and enabling the core security,
reliability, and observability features that Linkerd provides. In order to
provide these functions, these components interact directly with Linkerd’s TLS
certificates.</p>

<figure class="calibre23"><div class="figure" id="linkerd-control-plane-architecture">
<img alt="luar 0205" src="assets/luar_0205.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-5. </span>The Linkerd control plane</h6>
</div></figure>
</div></section>








<section class="preface" data-pdf-bookmark="Linkerd Extensions" data-type="sect2"><div class="preface" id="id120">
<h2 class="calibre27">Linkerd Extensions</h2>

<p class="author1"><a data-type="xref" href="#linkerd-control-plane-architecture" class="calibre4">Figure 2-5</a> shows some<a data-primary="Linkerd" data-secondary="architecture" data-tertiary="extensions" data-type="indexterm" id="id518" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="extensions" data-type="indexterm" id="id519" class="calibre4"/><a data-primary="extensions" data-secondary="Linkerd architecture" data-type="indexterm" id="id520" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="extensions" data-tertiary="Linkerd architecture" data-type="indexterm" id="id521" class="calibre4"/><a data-primary="APIs" data-secondary="Linkerd extension interactions" data-type="indexterm" id="id522" class="calibre4"/> extension deployments
running off to the side. Linkerd extensions have no special privileges; in
particular, the only way they can interact with the control plane or the proxy
is via published APIs. This allows them to be written by anyone.</p>

<p class="author1">Several extensions are maintained by the Linkerd maintainers to supply
functionality that many users want, but that isn’t <em class="hyperlink">required</em> by every Linkerd
installation; these include Linkerd Viz, Linkerd Multicluster, Linkerd Jaeger, Linkerd CNI,
and Linkerd SMI.</p>










<section data-pdf-bookmark="Linkerd Viz" data-type="sect3" class="preface"><div class="preface" id="id14">
<h3 class="calibre33">Linkerd Viz</h3>

<p class="author1">The Linkerd Viz extension provides<a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Linkerd Viz extension" data-type="indexterm" id="ch02-dash" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="Linkerd Viz extension" data-type="indexterm" id="ch02-dash2" class="calibre4"/><a data-primary="extensions" data-secondary="Linkerd architecture" data-tertiary="Linkerd Viz extension" data-type="indexterm" id="ch02-dash3" class="calibre4"/><a data-primary="Linkerd Viz extension" data-type="indexterm" id="ch02-dash4" class="calibre4"/><a data-primary="dashboards" data-secondary="Linkerd Viz extension" data-type="indexterm" id="ch02-dash5" class="calibre4"/><a data-primary="Linkerd CLI" data-secondary="Linkerd Viz extension components" data-type="indexterm" id="id523" class="calibre4"/><a data-primary="Viz extension" data-see="Linkerd Viz extension" data-type="indexterm" id="id524" class="calibre4"/><a data-primary="Linkerd" data-secondary="CLI" data-see="Linkerd CLI" data-type="indexterm" id="id525" class="calibre4"/> the Linkerd dashboard and its associated
components, as shown in <a data-type="xref" href="#linkerd-viz-architecture" class="calibre4">Figure 2-6</a>. It also provides some
additional CLI options that are useful when troubleshooting applications in
your cluster.</p>

<figure class="calibre23"><div class="figure" id="linkerd-viz-architecture">
<img alt="luar 0206" src="assets/luar_0206.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-6. </span>The Linkerd Viz extension</h6>
</div></figure>

<p class="author1">Viz is made up of the components described in the following sections.</p>












<section data-pdf-bookmark="Web" data-type="sect4" class="preface"><div class="preface" id="id15">
<h4 class="calibre34">Web</h4>

<p class="author1">The Web component of Linkerd Viz<a data-primary="Linkerd Viz extension" data-secondary="Web component" data-type="indexterm" id="id526" class="calibre4"/><a data-primary="Web component of Linkerd Viz extension" data-type="indexterm" id="id527" class="calibre4"/> provides the dashboard GUI used by many
Linkerd operators. You don’t actually need the GUI—everything it shows is
accessible from the command line—but it is very commonly used, and it can be very useful.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">The Linkerd Viz Dashboard Is Unauthenticated</h1>
<p class="author1">The Linkerd Viz dashboard doesn’t do<a data-primary="Linkerd Viz extension" data-secondary="dashboard unauthenticated" data-type="indexterm" id="id528" class="calibre4"/><a data-primary="authentication" data-secondary="Linkerd Viz dashboard unauthenticated" data-type="indexterm" id="id529" class="calibre4"/><a data-primary="dashboards" data-secondary="Linkerd Viz extension" data-tertiary="unauthenticated" data-type="indexterm" id="id530" class="calibre4"/> user authentication—there are simply
too many auth systems in use for it to be feasible. If you choose to expose
Linkerd Viz to the network, you’ll need to use an API gateway or the like to
protect access to Linkerd Viz according to your own policies. The dashboard
can’t change anything in your cluster, but it does expose an awful lot of
information.</p>

<p class="author1">You can also choose to<a data-primary="Linkerd CLI" data-secondary="dashboard viewed in browser" data-type="indexterm" id="id531" class="calibre4"/><a data-primary="dashboards" data-secondary="Linkerd Viz extension" data-tertiary="linkerd viz dashboard command" data-type="indexterm" id="id532" class="calibre4"/><a data-primary="linkerd" data-secondary="viz dashboard command for browser dashboard" data-type="indexterm" id="id533" class="calibre4"/><a data-primary="CLI" data-see="Linkerd CLI; Linkerd Viz extension; step CLI deployment tool" data-type="indexterm" id="id534" class="calibre4"/><a data-primary="command line interface" data-see="Linkerd CLI; Linkerd Viz extension; step CLI deployment tool" data-type="indexterm" id="id535" class="calibre4"/> leave the dashboard <em class="hyperlink">inaccessible</em> from outside the
cluster, and simply use the <code class="calibre9">linkerd viz dashboard</code> CLI command to bring up
the dashboard in a web browser, via a port forward.</p>
</div>
</div></section>












<section data-pdf-bookmark="Tap" data-type="sect4" class="preface"><div class="preface" id="id16">
<h4 class="calibre34">Tap</h4>

<p class="author1">Tap allows Linkerd to surface the<a data-primary="Linkerd Viz extension" data-secondary="Tap component" data-type="indexterm" id="id536" class="calibre4"/><a data-primary="Tap component of Linkerd Viz extension" data-type="indexterm" id="id537" class="calibre4"/><a data-primary="metadata via Tap of Linkerd Viz" data-type="indexterm" id="id538" class="calibre4"/> metadata about individual requests flowing
between your applications. Tap data is useful for debugging application issues
in live environments, since it permits watching request and response data
in real time.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Tap Doesn’t Show Request Bodies</h1>
<p class="author1">Tap can only show <em class="hyperlink">metadata</em>: paths, headers, etc. It cannot show request
<em class="hyperlink">bodies</em>. In a great many cases, of course, the metadata is all that’s needed
to understand what’s going on in an application.</p>

<p class="author1">For access to request bodies, you’ll need to incorporate application-level
request logging. Even in this situation, though, Tap can help narrow down the
microservices and request IDs of interest when examining more detailed logs.</p>
</div>
</div></section>












<section data-pdf-bookmark="Tap injector" data-type="sect4" class="preface"><div class="preface" id="id121">
<h4 class="calibre34">Tap injector</h4>

<p class="author1">For Linkerd Viz to surface metadata<a data-primary="metadata via Tap of Linkerd Viz" data-secondary="Tap injector" data-type="indexterm" id="id539" class="calibre4"/><a data-primary="Tap component of Linkerd Viz extension" data-secondary="Tap injector" data-type="indexterm" id="id540" class="calibre4"/> about requests, the metadata must be
collected from the individual proxies in the system. The Tap injector modifies the proxy injector so that new proxies will allow this metadata collection.</p>

<p class="author1">Note that the proxy injector can’t affect any proxy that’s already running! Any workloads started before the extension was installed will need to be restarted to provide Tap data to Linkerd Viz.</p>
</div></section>












<section data-pdf-bookmark="Metrics API" data-type="sect4" class="preface"><div class="preface" id="id122">
<h4 class="calibre34">Metrics API</h4>

<p class="author1">The metrics API is involved in <a data-primary="Linkerd Viz extension" data-secondary="metrics API" data-type="indexterm" id="id541" class="calibre4"/><a data-primary="metrics" data-secondary="Linkerd Viz extension metrics API" data-type="indexterm" id="id542" class="calibre4"/><a data-primary="APIs" data-secondary="Linkerd Viz extension metrics API" data-type="indexterm" id="id543" class="calibre4"/>collecting metrics for the Linkerd dashboard. It provides the underlying summary data for the Linkerd dashboard as well as the Linkerd CLI. Like all dashboard components, it is not involved in providing information to the Linkerd proxies.</p>
</div></section>












<section data-pdf-bookmark="Prometheus and Grafana" data-type="sect4" class="preface"><div class="preface" id="id17">
<h4 class="calibre34">Prometheus and Grafana</h4>

<p class="author1">Linkerd’s Viz extension ships with<a data-primary="Linkerd Viz extension" data-secondary="Prometheus instance" data-type="indexterm" id="id544" class="calibre4"/><a data-primary="Prometheus" data-secondary="instance with Linkerd Viz extension" data-type="indexterm" id="id545" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="Grafana dashboards" data-type="indexterm" id="id546" class="calibre4"/><a data-primary="dashboards" data-secondary="Grafana dashboards" data-tertiary="Linkerd Viz extension" data-type="indexterm" id="id547" class="calibre4"/><a data-primary="Grafana dashboards" data-secondary="Linkerd Viz extension" data-type="indexterm" id="id548" class="calibre4"/> a Prometheus instance. <a data-primary="Grafana dashboards" data-secondary="installation" data-tertiary="documentation URL" data-type="indexterm" id="id549" class="calibre4"/><a data-primary="dashboards" data-secondary="Grafana dashboards" data-tertiary="installation documentation URL" data-type="indexterm" id="id550" class="calibre4"/><a data-primary="resources online" data-secondary="Grafana installation documentation" data-type="indexterm" id="id551" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="Grafana installation" data-type="indexterm" id="id552" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="Grafana installation" data-type="indexterm" id="id553" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="Grafana installation" data-type="indexterm" id="id554" class="calibre4"/>If you choose to install Grafana (as described in the <a href="https://oreil.ly/FB_XN" class="calibre4">Linkerd documentation</a>), Linkerd publishes several open source Grafana dashboards as well.</p>

<p class="author1">You don’t actually need Linkerd Viz<a data-primary="Prometheus" data-secondary="native support by Linkerd proxy" data-type="indexterm" id="id555" class="calibre4"/><a data-primary="dashboards" data-secondary="Grafana dashboards" data-tertiary="native support by Linkerd proxy" data-type="indexterm" id="id556" class="calibre4"/><a data-primary="Grafana dashboards" data-secondary="native support by Linkerd proxy" data-type="indexterm" id="id557" class="calibre4"/> to use Prometheus and Grafana. The Linkerd
proxy supports Prometheus natively, so you can install Prometheus and
configure it to scrape the proxies directly if you like. Linkerd Viz is
simpler, though.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Always Use Your Own Prometheus</h1>
<p class="author1">By default, installing Linkerd Viz <a data-primary="production" data-secondary="Prometheus instance of Linkerd Viz" data-type="indexterm" id="id558" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="Prometheus instance" data-tertiary="not for production" data-type="indexterm" id="id559" class="calibre4"/><a data-primary="Prometheus" data-secondary="instance with Linkerd Viz extension" data-tertiary="not for production" data-type="indexterm" id="id560" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="Prometheus instance" data-type="indexterm" id="id561" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="Prometheus instance" data-type="indexterm" id="id562" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd Viz extension documentation" data-tertiary="Prometheus instance" data-type="indexterm" id="id563" class="calibre4"/><a data-primary="online resources" data-see="resources online" data-type="indexterm" id="id564" class="calibre4"/>will install an internal Prometheus
instance. <em class="hyperlink">Do not use this Prometheus in production</em>, as it does not have
persistent storage configured; instead, see the <a href="https://oreil.ly/hI6eF" class="calibre4">Linkerd documentation</a> and <a data-type="xref" href="ch10.html#EX12-production-prometheus" class="calibre4">Example 10-9</a> for information about using an external Prometheus instance.<a data-startref="ch02-dash" data-type="indexterm" id="id565" class="calibre4"/><a data-startref="ch02-dash2" data-type="indexterm" id="id566" class="calibre4"/><a data-startref="ch02-dash3" data-type="indexterm" id="id567" class="calibre4"/><a data-startref="ch02-dash4" data-type="indexterm" id="id568" class="calibre4"/><a data-startref="ch02-dash5" data-type="indexterm" id="id569" class="calibre4"/></p>
</div>
</div></section>
</div></section>










<section data-pdf-bookmark="Linkerd Multicluster" data-type="sect3" class="preface"><div class="preface" id="id18">
<h3 class="calibre33">Linkerd Multicluster</h3>

<p class="author1">The Linkerd Multicluster extension<a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Linkerd Multicluster extension" data-type="indexterm" id="id570" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="Linkerd Multicluster extension" data-type="indexterm" id="id571" class="calibre4"/><a data-primary="extensions" data-secondary="Linkerd architecture" data-tertiary="Linkerd Multicluster extension" data-type="indexterm" id="id572" class="calibre4"/><a data-primary="Linkerd Multicluster extension" data-type="indexterm" id="id573" class="calibre4"/><a data-primary="multicluster setups" data-secondary="Linkerd Multicluster extension" data-type="indexterm" id="id574" class="calibre4"/> provides users the ability to connect
clusters together over any public or private networks, as shown in
<a data-type="xref" href="#linkerd-multicluster-architecture" class="calibre4">Figure 2-7</a>. The Multicluster extension connects
clusters via a special gateway that allows all traffic to appear as if it
originates locally in the cluster. This allows users to avoid configuring any
special networking settings when connecting clusters. We’ll dive deeper into
multicluster connections in <a data-type="xref" href="ch12.html#LUAR_multicluster" class="calibre4">Chapter 12</a>.</p>

<figure class="calibre23"><div class="figure" id="linkerd-multicluster-architecture">
<img alt="luar 0207" src="assets/luar_0207.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-7. </span>Linkerd multicluster architecture</h6>
</div></figure>
</div></section>










<section data-pdf-bookmark="Linkerd Jaeger" data-type="sect3" class="preface"><div class="preface" id="id19">
<h3 class="calibre33">Linkerd Jaeger</h3>

<p class="author1">The Linkerd Jaeger extension <a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Linkerd Jaeger extension" data-type="indexterm" id="id575" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="Linkerd Jaeger extension" data-type="indexterm" id="id576" class="calibre4"/><a data-primary="extensions" data-secondary="Linkerd architecture" data-tertiary="Linkerd Jaeger extension" data-type="indexterm" id="id577" class="calibre4"/><a data-primary="Linkerd Jaeger extension" data-type="indexterm" id="id578" class="calibre4"/><a data-primary="distributed tracing" data-type="indexterm" id="id579" class="calibre4"/>allows Linkerd to participate in distributed
tracing, as embodied by <a href="https://oreil.ly/Dly9D" class="calibre4">the Jaeger project</a>.
Specifically, it allows Linkerd to emit and forward distributed tracing spans,
so that you can see proxy activity in the distributed trace. As shown in <a data-type="xref" href="#linkerd-jaeger-architecture" class="calibre4">Figure 2-8</a>, Linkerd Jaeger provides a collector, which forwards spans to a Jaeger instance, and an injector, which modifies the proxy injector so that new proxies will send data to the collector. As with Linkerd Viz, you’ll need to restart any workloads that were running before you installed Linkerd Jaeger!</p>

<p class="author1">It’s important to understand that while Linkerd can aid your application-based
tracing by providing details on how the proxies are contributing to your
distributed application’s flow, it cannot add tracing instrumentation to your
application. In order to take advantage of distributed tracing with Linkerd,
your application must first be configured to propagate tracing headers and
create and emit its own spans.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Always Use Your Own Jaeger Instance</h1>
<p class="author1">By default, Linkerd Jaeger will install<a data-primary="Linkerd Jaeger extension" data-secondary="Jaeger instance" data-type="indexterm" id="id580" class="calibre4"/><a data-primary="Jaeger instance with Linkerd Jaeger extension" data-type="indexterm" id="id581" class="calibre4"/><a data-primary="Linkerd Jaeger extension" data-secondary="Jaeger instance" data-tertiary="not for production" data-type="indexterm" id="id582" class="calibre4"/><a data-primary="Jaeger instance with Linkerd Jaeger extension" data-secondary="not for production" data-type="indexterm" id="id583" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="Jaeger instance" data-type="indexterm" id="id584" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="Jaeger instance" data-type="indexterm" id="id585" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="Jaeger instance" data-type="indexterm" id="id586" class="calibre4"/><a data-primary="production" data-secondary="Jaeger instance" data-type="indexterm" id="id587" class="calibre4"/> an internal Jaeger instance. Do not use this Jaeger instance in production, as it does not provide persistent storage; instead, see the <a href="https://oreil.ly/QgDXC" class="calibre4">Linkerd documentation</a> for information about using an external Jaeger instance.</p>
</div>

<figure class="calibre23"><div class="figure" id="linkerd-jaeger-architecture">
<img alt="luar 0208" src="assets/luar_0208.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 2-8. </span>Linkerd Jaeger architecture</h6>
</div></figure>
</div></section>










<section data-pdf-bookmark="Linkerd CNI" data-type="sect3" class="preface"><div class="preface" id="id20">
<h3 class="calibre33">Linkerd CNI</h3>

<p class="author1">When a Linkerd proxy starts running,<a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Linkerd CNI plugin" data-type="indexterm" id="id588" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="Linkerd CNI plugin" data-type="indexterm" id="id589" class="calibre4"/><a data-primary="Linkerd CNI (Container Network Interface) plugin" data-type="indexterm" id="id590" class="calibre4"/><a data-primary="CNI" data-see="Kubernetes CNI; Linkerd CNI plugin" data-type="indexterm" id="id591" class="calibre4"/><a data-primary="Container Network Interface" data-see="Kubernetes CNI; Linkerd CNI plugin" data-type="indexterm" id="id592" class="calibre4"/><a data-primary="plugin" data-see="Linkerd CNI plugin" data-type="indexterm" id="id593" class="calibre4"/><a data-primary="init container" data-secondary="about" data-type="indexterm" id="id594" class="calibre4"/> it needs to reconfigure the kernel’s
network layer so that the proxy can intercept and mediate network
communication for the application. There are two possible ways for Linkerd to
do this: the Linkerd <em class="hyperlink">init container</em> or the Linkerd <em class="hyperlink">Container Network
Interface (CNI) plugin</em>.</p>

<p class="author1">We’ll discuss this in much greater detail in <a data-type="xref" href="ch13.html#LUAR_cni_vs_init_containers" class="calibre4">Chapter 13</a>,
but it’s worth noting here that the CNI plugin works in conjunction with
the Kubernetes CNI to reconfigure the network stack in environments where
using the init container isn’t possible or isn’t desirable. <a data-primary="Linkerd CNI (Container Network Interface) plugin" data-secondary="installation" data-type="indexterm" id="id595" class="calibre4"/>If you do plan to
use the CNI, you must install the Linkerd CNI plugin before installing any
other Linkerd components. This is the only extension that can and must be
installed before Linkerd’s core control plane.</p>
</div></section>










<section data-pdf-bookmark="Linkerd SMI" data-type="sect3" class="preface"><div class="preface" id="id21">
<h3 class="calibre33">Linkerd SMI</h3>

<p class="author1">The Service Mesh Interface (SMI) <a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Linkerd Service Mesh Interface extension" data-type="indexterm" id="id596" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="Linkerd Service Mesh Interface extension" data-type="indexterm" id="id597" class="calibre4"/><a data-primary="Service Mesh Interface (SMI)" data-see="Linkerd SMI extension" data-type="indexterm" id="id598" class="calibre4"/><a data-primary="Linkerd SMI (Service Mesh Interface) extension" data-type="indexterm" id="id599" class="calibre4"/><a data-primary="Cloud Native Computing Foundation (CNCF)" data-secondary="Linkerd Service Mesh Interface" data-type="indexterm" id="id600" class="calibre4"/><a data-primary="APIs" data-secondary="Service Mesh Interface" data-type="indexterm" id="id601" class="calibre4"/><a data-primary="CNCF" data-see="Cloud Native Computing Foundation" data-type="indexterm" id="id602" class="calibre4"/><a data-primary="extensions" data-secondary="Linkerd architecture" data-tertiary="Linkerd Service Mesh Interface" data-type="indexterm" id="id603" class="calibre4"/>was a project out of the CNCF that
aimed to provide a standard, cross-platform API to control the behavior of a
service mesh. <a data-primary="CRDs (custom resource definitions)" data-secondary="SMI TrafficSplit CRD" data-type="indexterm" id="id604" class="calibre4"/><a data-primary="custom resource definitions" data-see="CRDs" data-type="indexterm" id="id605" class="calibre4"/>The Linkerd SMI extension allows Linkerd to do traffic splitting
using the SMI TrafficSplit custom resource definition (CRD).<sup class="calibre28"><a data-type="noteref" href="ch02.html#id606" id="id606-marker" class="calibre29">1</a></sup></p>

<p class="author1">SMI saw somewhat mixed adoption overall, <a data-primary="Gateway API" data-secondary="GAMMA initiative" data-type="indexterm" id="id607" class="calibre4"/><a data-primary="APIs" data-secondary="Gateway API" data-tertiary="GAMMA initiative" data-type="indexterm" id="id608" class="calibre4"/><a data-primary="GAMMA initiative" data-secondary="Service Mesh Interface informing" data-type="indexterm" id="id609" class="calibre4"/>and as of October 2023 the SMI
project was archived, with many of its concepts and goals used to inform
<a href="https://oreil.ly/J1BOK" class="calibre4">the GAMMA initiative within
Gateway API</a>, which Linkerd supports as of version 2.14.</p>
</div></section>
</div></section>
</div></section>






<section data-pdf-bookmark="Summary" data-type="sect1" class="preface"><div class="preface" id="id312">
<h1 class="calibre8">Summary</h1>

<p class="author1">Linkerd got started in 2015 and grew into its modern form, based on Rust and
Go and driven by the concept of operational simplicity, in 2018. That focus on
operational simplicity remains today and is borne out by Linkerd’s
architecture, with a small, purpose-built Rust data plane proxy, a Go control
plane that focuses on critical functionality, and a set of extensions for
optional functionality.</p>
</div></section>
<div data-type="footnotes" class="calibre30"><p data-type="footnote" id="id606" class="calibre31"><sup class="calibre32"><a href="ch02.html#id606-marker" class="calibre29">1</a></sup> There were other SMI CRDs, but other than TrafficSplit, they duplicate functionality that Linkerd already had APIs for.</p></div></div></section></body></html>