<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Handling Duplicates"><div class="chapter" id="nch-dups"><h1><span class="label">Chapter 18. </span>Handling Duplicates</h1><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820336996832"><h5>A note for Early Release readers</h5><p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p></div></aside><section data-type="sect1" data-pdf-bookmark="18.0 Introduction"><div class="sect1" id="nch-dups-dups-intro"><h1>18.0 Introduction</h1><p>Tables or result sets sometimes contain duplicate rows. In some cases this is
    acceptable. For example, if you conduct a web poll that records date and
    client IP number along with the votes, duplicate rows may be permitted
    because it’s possible for large numbers of votes to appear to originate
    from the same IP number for an Internet service that routes traffic from
    its customers through a single proxy host. In other cases, duplicates are
    unacceptable, and you’ll want to take steps to avoid them. Operations
    involved in handling duplicate rows include the following:</p><ul><li><p>Preventing duplicates from being created in the first place. If
        each row in a table is intended to represent a single entity (such as
        a person, an item in a catalog, or a specific observation in an
        experiment), the occurrence of duplicates makes it impossible to
        refer to each row unambiguously, so it’s best to make sure duplicates
        never occur.</p></li><li><p>Counting the number of duplicates to determine whether they are
        present and to what extent.</p></li><li><p>Identifying duplicated values (or the rows containing them) so
        you can see where they occur.</p></li><li><p>Eliminating duplicates to ensure that each row is unique. This
        may involve removing rows from a table to leave only unique rows or
        selecting a result set in such a way that no duplicates appear in the
        output. For example, to display a list of the states in which you have
        customers, you probably don’t want a long list of state names from all
        customer records. A list showing each state name only once suffices
        and is easier to understand.</p></li></ul><p>Several tools are at your disposal for dealing with duplicate rows.
    Choose them according to the objective that you want to achieve:</p><ul><li><p>When you create a table, include a primary key or unique index
        to prevent duplicates from being added to the table. MySQL uses the
        index as a constraint to enforce the requirement that each row in the
        table contains a unique key in the indexed column or columns.</p></li><li><p>In conjunction with a unique index, the <code>INSERT</code> <code>IGNORE</code> and <code>REPLACE</code> statements enable you to handle
        insertion of duplicate rows gracefully without generating errors. For
        bulk-loading operations, the same options are available in the form of
        the <code>IGNORE</code> or <code>REPLACE</code> modifiers for the <code>LOAD</code> <code>DATA</code>
        statement.</p></li><li><p>To determine whether a table contains duplicates, use <code>GROUP</code> <code>BY</code>
        to categorize rows into groups, and <code>COUNT()</code> to see how many rows are in each
        group. <a data-type="xref" href="ch10.xhtml#nch-sum">Chapter 10</a> describes these techniques in the
        context of producing summaries, but they’re useful for duplicate
        counting and identification as well. A counting summary groups values
        into categories to determine how frequently each one occurs.</p></li><li><p><code>SELECT</code> <code>DISTINCT</code> removes duplicate rows from a
        result set (see <a data-type="xref" href="ch05.xhtml#nch-select-select-nodup">Recipe 5.4</a> for more
        information). For an existing table that already contains duplicates,
        you can select unique rows into a second table and use it to replace
        the original table. Or, if you determine that there are
        <em><code>n</code></em> identical rows in a table, you can use
        <code>DELETE</code> … <code>LIMIT</code> to eliminate
        <em><code>n</code></em>–1 instances from that specific set of
        rows.</p></li></ul><p>Scripts related to the examples shown in this chapter are located in
    the <em class="filename">dups</em> directory of the <code>recipes</code> distribution. For scripts that create
    the tables used here, look in the <em class="filename">tables</em>
    directory.</p></div></section><section data-type="sect1" data-pdf-bookmark="18.1 Preventing Duplicates from Occurring in a Table"><div class="sect1" id="nch-dups-dups-prevent"><h1>18.1 Preventing Duplicates from Occurring in a Table</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820336891792"><h2>Problem</h2><p>You want to prevent a table from ever containing duplicates.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820336890816"><h2>Solution</h2><p>Use a <code>PRIMARY</code> <code>KEY</code> or a <code>UNIQUE</code> index.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820336888432"><h2>Discussion</h2><p>To ensure that rows in a table are unique, some column or
      combination of columns must be required to contain unique values in each
      row. When this requirement is satisfied, you can refer to any row in the
      table unambiguously by using its unique identifier. To make sure a table
      has this characteristic, include a <code>PRIMARY</code> <code>KEY</code>
      or <code>UNIQUE</code> index in the table
      structure. The following table contains no such index, so it permits
      duplicate rows:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">person</code>
<code class="p">(</code>
  <code class="n">last_name</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code>
  <code class="n">first_name</code>  <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code>
  <code class="n">address</code>     <code class="nb">CHAR</code><code class="p">(</code><code class="mi">40</code><code class="p">)</code>
<code class="p">);</code></pre><p>To prevent multiple rows with the same first and last name values
      from being created in this table, add a <code>PRIMARY</code> <code>KEY</code>
      to its definition. When you do this, the indexed columns must be
      <code>NOT</code> <code>NULL</code>, because a <code>PRIMARY</code> <code>KEY</code> prohibits <code>NULL</code> values:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">person</code>
<code class="p">(</code>
  <code class="n">last_name</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">first_name</code>  <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">address</code>     <code class="nb">CHAR</code><code class="p">(</code><code class="mi">40</code><code class="p">),</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">last_name</code><code class="p">,</code> <code class="n">first_name</code><code class="p">)</code>
<code class="p">);</code></pre><p>The presence of a unique index in a table normally causes an error
      to occur if you insert a row into the table that duplicates an existing
      row in the column or columns that define the index. <a data-type="xref" href="#nch-dups-dups-errors">Recipe 18.3</a> discusses how to handle such errors or
      modify MySQL’s duplicate-handling behavior.</p><p>Another way to enforce uniqueness is to add a <code>UNIQUE</code> index rather than a <code>PRIMARY</code> <code>KEY</code>
      to a table. The two types of indexes are similar, but a <code>UNIQUE</code> index can be created on columns that
      permit <code>NULL</code> values. For the <code>person</code> table, it’s likely that you’d require
      both the first and last names to be filled in. If so, you still declare
      the columns as <code>NOT</code> <code>NULL</code>, and the following table definition is effectively equivalent
      to the preceding one:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">person</code>
<code class="p">(</code>
  <code class="n">last_name</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">first_name</code>  <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">address</code>     <code class="nb">CHAR</code><code class="p">(</code><code class="mi">40</code><code class="p">),</code>
  <code class="k">UNIQUE</code> <code class="p">(</code><code class="n">last_name</code><code class="p">,</code> <code class="n">first_name</code><code class="p">)</code>
<code class="p">);</code></pre><p>If a <code>UNIQUE</code> index does happen
      to permit <code>NULL</code> values, <code>NULL</code> is special because it is the one value
      that can occur multiple times. The rationale for this is that it is not
      possible to know whether one unknown value is the same as another, so
      multiple unknown values are permitted.</p><p>Of course, you might want the <code>person</code> table to reflect the real world, in
      which people do sometimes have the same name. In this case, you cannot
      set up a unique index based on the name columns, because duplicate names
      must be permitted. Instead, each person must be assigned some sort of
      unique identifier, which becomes the value that distinguishes one row
      from another. In MySQL, it’s common to accomplish this by using an <code>AUTO_INCREMENT</code> column:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">person</code>
<code class="p">(</code>
  <code class="n">id</code>          <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="n">AUTO_INCREMENT</code><code class="p">,</code>
  <code class="n">last_name</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code>
  <code class="n">first_name</code>  <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code>
  <code class="n">address</code>     <code class="nb">CHAR</code><code class="p">(</code><code class="mi">40</code><code class="p">),</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">id</code><code class="p">)</code>
<code class="p">);</code></pre><p>In this case, when you create a row with an <code>id</code> value of <code>NULL</code>, MySQL assigns that column a unique ID
      automatically. Another possibility is to assign identifiers externally
      and use those IDs as unique keys. For example, citizens in a given
      country might have unique taxpayer ID numbers. If so, those numbers can
      serve as the basis for a unique index:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">person</code>
<code class="p">(</code>
  <code class="n">tax_id</code>      <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">last_name</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code>
  <code class="n">first_name</code>  <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">),</code>
  <code class="n">address</code>     <code class="nb">CHAR</code><code class="p">(</code><code class="mi">40</code><code class="p">),</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">tax_id</code><code class="p">)</code>
<code class="p">);</code></pre></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820336672320"><h2>See Also</h2><p>If an existing table already contains duplicate rows that you want
      to remove, see <a data-type="xref" href="#nch-dups-dups-elim-table">Recipe 18.5</a>. <a data-type="xref" href="ch15.xhtml#nch-sequences">Chapter 15</a> further discusses <code>AUTO_INCREMENT</code> columns.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="18.2 Having More than One Unique Key in the Table"><div class="sect1" id="nch-dups-dups-twokeys"><h1>18.2 Having More than One Unique Key in the Table</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820336606656"><h2>Problem</h2><p>
        You need two or more column sets in the table to have unique values.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820336605680"><h2>Solution</h2><p>
        Define as many unique keys as needed.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820336604736"><h2>Discussion</h2><p>
        It maybe possible that two or more column combinations that need to have unique values independently from each other. For example, table <code>person</code> from the last example in the <a data-type="xref" href="#nch-dups-dups-prevent">Recipe 18.1</a>, has a column <code>tax_id</code> representing a taxpayer ID, thus needs to store unique values. Still you may want to keep unique index on <code>(last_name, first_name)</code>. This way you can be sure that each person has its own taxpayer ID and any taxpayer ID belongs to the only one person.
      </p><p>
        Any table can have at most one primary key. Therefore you need to choose which key will be primary and which will be secondary unique key. As we describe in <a data-type="xref" href="ch21.xhtml#nch-queryperf-queryperf-create-index-innodbpk">Recipe 21.2</a> primary keys for InnoDB storage engine are included into all secondary indexes and it is critical for performance to define them using the smallest data type possible. Therefore it is straightforward to define primary key for the <code>tax_id</code> column and a key on <code>(last_name, first_name)</code> as a secondary unique index.
      </p><p>
        The resulting table definition will look like this:
      </p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="o">`</code><code class="n">person</code><code class="o">`</code> <code class="p">(</code>
  <code class="o">`</code><code class="n">tax_id</code><code class="o">`</code> <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="o">`</code><code class="n">last_name</code><code class="o">`</code> <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">DEFAULT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="o">`</code><code class="n">first_name</code><code class="o">`</code> <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">DEFAULT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="o">`</code><code class="n">address</code><code class="o">`</code> <code class="nb">CHAR</code><code class="p">(</code><code class="mi">40</code><code class="p">)</code> <code class="k">DEFAULT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="o">`</code><code class="n">tax_id</code><code class="o">`</code><code class="p">),</code>
  <code class="k">UNIQUE</code> <code class="k">KEY</code> <code class="o">`</code><code class="n">last_name</code><code class="o">`</code> <code class="p">(</code><code class="o">`</code><code class="n">last_name</code><code class="o">`</code><code class="p">,</code><code class="o">`</code><code class="n">first_name</code><code class="o">`</code><code class="p">)</code>
<code class="p">);</code></pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="18.3 Dealing with Duplicates When Loading Rows into a Table"><div class="sect1" id="nch-dups-dups-errors"><h1>18.3 Dealing with Duplicates When Loading Rows into a Table</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820336540144"><h2>Problem</h2><p>You’ve created a table with a unique index to prevent duplicate values in the indexed
      column or columns. But this results in an error if you attempt to insert
      a duplicate row, and you want to avoid having to deal with such
      errors.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820336460784"><h2>Solution</h2><p>One approach is to just ignore the error. Another is to use
      an <code>INSERT</code> <code>IGNORE</code>, <code>REPLACE</code>, or <code>INSERT</code> … <code>ON</code>
      <code>DUPLICATE</code> <code>KEY</code> <code>UPDATE</code>
      statement, each of which modifies MySQL’s duplicate-handling
      behavior. For bulk-loading operations, <code>LOAD</code> <code>DATA</code>
      has modifiers that enable you to specify how to handle
      duplicates.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820336459696"><h2>Discussion</h2><p>By default, MySQL generates an error when you insert a row that
      duplicates an existing unique key value. Suppose that the <code>person</code> table has the following structure, with
      a unique index on the <code>last_name</code> and
      <code>first_name</code> columns:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">person</code>
<code class="p">(</code>
  <code class="n">last_name</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">first_name</code>  <code class="nb">CHAR</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">address</code>     <code class="nb">CHAR</code><code class="p">(</code><code class="mi">40</code><code class="p">),</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">last_name</code><code class="p">,</code> <code class="n">first_name</code><code class="p">)</code>
<code class="p">);</code></pre><p>An attempt to insert a row with duplicate values in the indexed
      columns results in an error:</p><pre data-type="programlisting">mysql&gt; <strong><code>INSERT INTO person (last_name, first_name)</code></strong>
    -&gt; <strong><code>VALUES('Pinter', 'Marlene');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong><code>INSERT INTO person (last_name, first_name)</code></strong>
    -&gt; <strong><code>VALUES('Pinter', 'Marlene');</code></strong>
ERROR 1062 (23000): Duplicate entry 'Pinter-Marlene' for key 'person.PRIMARY'</pre><p>If you issue the statements from the <span class="command"><em>mysql</em></span> program interactively, you can simply
      say, <q>Okay, that didn’t work,</q> ignore the error, and
      continue. But if you write a program to insert the rows, an error may
      terminate the program. One way to avoid this is to modify the program’s
      error-handling behavior to trap the error and then ignore it. See <a data-type="xref" href="ch04.xhtml#nch-api-api-error">Recipe 4.2</a> for information about error-handling
      techniques.</p><p>To prevent the error from occurring in the first place, you might
      consider using a two-query method to solve the duplicate-row
      problem:</p><ul><li><p>Issue a <code>SELECT</code> to check
          whether the row is already present.</p></li><li><p>Issue an <code>INSERT</code> if the row
          is not present.</p></li></ul><p>But that doesn’t really work: another client might insert the same
      row after the <code>SELECT</code> and before the
      <code>INSERT</code>, in which case the error would
      still occur for your <code>INSERT</code>. To make
      sure that doesn’t happen, you could use a transaction or lock the
      tables, but then you’ve gone from two statements to four. MySQL provides
      three single-query solutions to the problem of handling duplicate rows.
      Choose from among them depending on the duplicate-handling behavior you
      want:</p><ul><li><p>To keep the original row when a duplicate occurs, use <code>INSERT</code> <code>IGNORE</code> rather than <code>INSERT</code>. If the row duplicates no existing
          row, MySQL inserts it as usual. If the row is a duplicate, the
          <code>IGNORE</code> keyword tells MySQL to
          discard it silently without generating an error:</p><pre data-type="programlisting">mysql&gt; <strong><code>INSERT IGNORE INTO person (last_name, first_name)</code></strong>
    -&gt; <strong><code>VALUES('Brown', 'Bartholomew');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong><code>INSERT IGNORE INTO person (last_name, first_name)</code></strong>
    -&gt; <strong><code>VALUES('Brown', 'Bartholomew');</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)</pre><p>The row count value indicates whether the row was inserted or
          ignored. From within a program, you can obtain this value by
          checking the rows-affected function provided by your API (see
          <a data-type="xref" href="ch04.xhtml#nch-api-api-statement">Recipe 4.4</a> and <a data-type="xref" href="ch12.xhtml#nch-meta-meta-rows">Recipe 12.1</a>).</p></li><li><p>To replace the original row with the new one when a duplicate
          occurs, use <code>REPLACE</code> rather than
          <code>INSERT</code>. If the row is new, it’s
          inserted just as with <code>INSERT</code>. If
          it’s a duplicate, the new row replaces the old one:</p><pre data-type="programlisting">mysql&gt; <strong><code>REPLACE INTO person (last_name, first_name, address)</code></strong>
    -&gt; <strong><code>VALUES('Baxter', 'Wallace', '57 3rd Ave.');</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong><code>REPLACE INTO person (last_name, first_name, address)</code></strong>
    -&gt; <strong><code>VALUES('Baxter', 'Wallace', '57 3rd Ave., Apt 102');</code></strong>
Query OK, 2 rows affected (0.00 sec)</pre><p>The rows-affected value in the second case is 2 because the
          original row is deleted and the new row is inserted in its
          place.</p></li><li><p>To modify columns of an existing row when a duplicate occurs,
          use <code>INSERT</code> … <code>ON</code> <code>DUPLICATE</code> <code>KEY</code> <code>UPDATE</code>. If the row is new, it’s inserted.
          If it’s a duplicate, the <code>ON</code>
          <code>DUPLICATE</code> <code>KEY</code> <code>UPDATE</code> clause indicates how to modify the
          existing row in the table. In other words, this statement can insert
          or update a row as necessary. The rows-affected count indicates what
          happened: 1 for an insert, 2 for an update.</p></li></ul><p><code>INSERT</code> <code>IGNORE</code> is more efficient than <code>REPLACE</code> because it doesn’t actually insert
      duplicates. Thus, it’s most applicable when you just want to make sure a
      copy of a given row is present in a table. <code>REPLACE</code>, on the other hand, is often more
      appropriate for tables in which other nonkey columns need to be
      replaced. <code>INSERT</code> … <code>ON</code> <code>DUPLICATE</code> <code>KEY</code> <code>UPDATE</code>
      is appropriate when you must insert a record if it doesn’t exist, but
      just update some of its columns if the new record is a duplicate in the
      indexed columns.</p><p>Suppose that you maintain a table named <code>passtbl</code> for a web application that contains
      email addresses and password hash values, and that is indexed by email
      address:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">passtbl</code>
<code class="p">(</code>
  <code class="n">email</code>    <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">60</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="n">password</code> <code class="n">VARBINARY</code><code class="p">(</code><code class="mi">60</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">email</code><code class="p">)</code>
<code class="p">);</code></pre><p>How do you create new rows for new users, but change passwords of
      existing rows for existing users? Here’s a typical algorithm for
      handling row maintenance:</p><ol><li><p>Issue a <code>SELECT</code> to check
          whether a row already exists with a given <code>email</code> value.</p></li><li><p>If no such row exists, add a new one with <code>INSERT</code>.</p></li><li><p>If the row does exist, update it with <code>UPDATE</code>.</p></li></ol><p>These steps must be performed within a transaction or with the
      tables locked to prevent other users from changing the tables while
      you’re using them. In MySQL, you can use <code>REPLACE</code> to simplify both cases to the same
      single-statement operation:</p><pre data-type="programlisting" data-code-language="sql">REPLACE INTO passtbl (email,password) VALUES(<em><code>address</code></em>,<em><code>hash_value</code></em>);</pre><p>If no row with the given email address exists, MySQL creates a new
      one. Otherwise, MySQL replaces it, in effect updating the <code>password</code> column of the row associated with the
      address.</p><p><code>INSERT</code> <code>IGNORE</code> and <code>REPLACE</code> are useful when you know exactly what
      values should be stored in the table when you attempt to insert a row.
      That’s not always the case. For example, you might want to insert a row
      if it doesn’t exist, but update only certain parts of it otherwise. This
      commonly occurs when you use a table for counting. Suppose that you
      record votes for candidates in polls, using the following table:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">poll_vote</code>
<code class="p">(</code>
  <code class="n">poll_id</code>      <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="n">AUTO_INCREMENT</code><code class="p">,</code>
  <code class="n">candidate_id</code> <code class="nb">INT</code> <code class="n">UNSIGNED</code><code class="p">,</code>
  <code class="n">vote_count</code>   <code class="nb">INT</code> <code class="n">UNSIGNED</code><code class="p">,</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">poll_id</code><code class="p">,</code> <code class="n">candidate_id</code><code class="p">)</code>
<code class="p">);</code></pre><p>The primary key is the combination of poll and candidate number.
      The table should be used like this:</p><ul><li><p>For the first vote received for a given poll candidate, insert
          a new row with a vote count of 1.</p></li><li><p>For subsequent votes for that candidate, increment the vote
          count of the existing record.</p></li></ul><p>Neither <code>INSERT</code> <code>IGNORE</code> nor <code>REPLACE</code> are appropriate here because for all
      votes except the first, you don’t know what the vote count should be.
      <code>INSERT</code> … <code>ON</code> <code>DUPLICATE</code> <code>KEY</code> <code>UPDATE</code>
      works better here. The following example shows how it works, beginning
      with an empty table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM poll_vote;</code></strong>
Empty set (0.00 sec)
mysql&gt; <strong><code>INSERT INTO poll_vote (poll_id,candidate_id,vote_count) VALUES(14,3,1)</code></strong>
    -&gt; <strong><code>ON DUPLICATE KEY UPDATE vote_count = vote_count + 1;</code></strong>
Query OK, 1 row affected (0.00 sec)
mysql&gt; <strong><code>SELECT * FROM poll_vote;</code></strong></pre><pre data-type="programlisting">+---------+--------------+------------+
| poll_id | candidate_id | vote_count |
+---------+--------------+------------+
|      14 |            3 |          1 |
+---------+--------------+------------+
1 row in set (0.00 sec)
mysql&gt; <strong><code>INSERT INTO poll_vote (poll_id,candidate_id,vote_count) VALUES(14,3,1)</code></strong>
    -&gt; <strong><code>ON DUPLICATE KEY UPDATE vote_count = vote_count + 1;</code></strong>
Query OK, 2 rows affected (0.00 sec)
mysql&gt; <strong><code>SELECT * FROM poll_vote;</code></strong>
+---------+--------------+------------+
| poll_id | candidate_id | vote_count |
+---------+--------------+------------+
|      14 |            3 |          2 |
+---------+--------------+------------+
1 row in set (0.00 sec)</pre><p>For the first <code>INSERT</code>, no row
      for the candidate exists, so the row is inserted. For the second
      <code>INSERT</code>, the row exists, so MySQL just
      updates the vote count. With <code>INSERT</code> …
      <code>ON</code> <code>DUPLICATE</code> <code>KEY</code> <code>UPDATE</code>,
      you need not check whether the row exists; MySQL does it for you. The
      row count indicates what action the <code>INSERT</code> statement performs: 1 for a new row and
      2 for an update to an existing row.</p><p>The techniques just described have the benefit of eliminating
      overhead that might otherwise be required for a transaction. But this
      benefit comes at the price of portability because they all involve
      MySQL-specific syntax. If portability is a high priority, you might
      prefer to use a transactional approach as we discuss in <a data-type="xref" href="ch20.xhtml#nch-xact">Chapter 20</a>.</p><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="nch-dups-dups-idku"><h5>Using INSERT ... ON DUPLICATE KEY UPDATE on a Table with Two or More Unique Keys</h5><p>
        When a table has two or more unique keys <code>INSERT ... ON DUPLICATE KEY UPDATE</code> can update any row that violates the unique constraint.
      </p><p>
        Assume that the table <code>person</code> from the <a data-type="xref" href="#nch-dups-dups-twokeys">Recipe 18.2</a> has two rows:
      </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">--------+-----------+------------+--------------------------+
</code><code class="o">|</code><code> </code><code class="n">tax_id</code><code> </code><code class="o">|</code><code> </code><code class="n">last_name</code><code> </code><code class="o">|</code><code> </code><code class="n">first_name</code><code> </code><code class="o">|</code><code> </code><code class="n">address</code><code>                  </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">--------+-----------+------------+--------------------------+
</code><code class="o">|</code><code>  </code><code class="mi">12345</code><code> </code><code class="o">|</code><code> </code><code class="n">Isaacson</code><code>  </code><code class="o">|</code><code> </code><code class="n">Jim</code><code>        </code><code class="o">|</code><code> </code><code class="mi">515</code><code> </code><code class="n">Fordam</code><code> </code><code class="n">St</code><code class="p">.</code><code class="p">,</code><code> </code><code class="n">Apt</code><code class="p">.</code><code> </code><code class="mi">917</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code>  </code><code class="mi">23941</code><code> </code><code class="o">|</code><code> </code><code class="n">Baxter</code><code>    </code><code class="o">|</code><code> </code><code class="n">Wallace</code><code>    </code><code class="o">|</code><code> </code><code class="mi">57</code><code> </code><code class="mi">3</code><code class="n">rd</code><code> </code><code class="n">Ave</code><code class="p">.</code><code>              </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">--------+-----------+------------+--------------------------+
</code><code class="mi">2</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
       And we want to add new row for Taylor McTavish:
     </p><pre data-type="programlisting" data-code-language="sql"><code class="k">INSERT</code> <code class="k">INTO</code> <code class="n">person</code> <code class="k">VALUES</code><code class="p">(</code><code class="mi">12345</code><code class="p">,</code> <code class="s1">'McTavish'</code><code class="p">,</code> <code class="s1">'Taylor'</code><code class="p">,</code> <code class="s1">'432 River Run'</code><code class="p">)</code> 
<code class="k">ON</code> <code class="n">DUPLICATE</code> <code class="k">KEY</code> <code class="k">UPDATE</code> <code class="n">address</code> <code class="o">=</code> <code class="s1">'432 River Run'</code><code class="p">;</code></pre><p>
      We expect that if no record for Taylor McTavish exists in the table, a new row will be inserted. Otherwise, the address will be updated. However, this is not exactly the case.
    </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">person</code><code> </code><code class="k">VALUES</code><code class="p">(</code><code class="mi">12345</code><code class="p">,</code><code> </code><code class="s1">'McTavish'</code><code class="p">,</code><code> </code><code class="s1">'Taylor'</code><code class="p">,</code><code> </code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="s1">'432 River Run'</code><code class="p">)</code><code> </code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ON</code><code> </code><code class="n">DUPLICATE</code><code> </code><code class="k">KEY</code><code> </code><code class="k">UPDATE</code><code> </code><code class="n">address</code><code> </code><code class="o">=</code><code> </code><code class="s1">'432 River Run'</code><code class="p">;</code></strong><code>
</code><code class="n">Query</code><code> </code><code class="n">OK</code><code class="p">,</code><code> </code><code class="mi">2</code><code> </code><code class="k">rows</code><code> </code><code class="n">affected</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code><code>

</code><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">--------+-----------+------------+---------------+
</code><code class="o">|</code><code> </code><code class="n">tax_id</code><code> </code><code class="o">|</code><code> </code><code class="n">last_name</code><code> </code><code class="o">|</code><code> </code><code class="n">first_name</code><code> </code><code class="o">|</code><code> </code><code class="n">address</code><code>       </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">--------+-----------+------------+---------------+
</code><code class="o">|</code><code>  </code><code class="mi">12345</code><code> </code><code class="o">|</code><code> </code><code class="n">Isaacson</code><code>  </code><code class="o">|</code><code> </code><code class="n">Jim</code><code>        </code><code class="o">|</code><code> </code><code class="mi">432</code><code> </code><code class="n">River</code><code> </code><code class="n">Run</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code>  </code><code class="mi">23941</code><code> </code><code class="o">|</code><code> </code><code class="n">Baxter</code><code>    </code><code class="o">|</code><code> </code><code class="n">Wallace</code><code>    </code><code class="o">|</code><code> </code><code class="mi">57</code><code> </code><code class="mi">3</code><code class="n">rd</code><code> </code><code class="n">Ave</code><code class="p">.</code><code>   </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">--------+-----------+------------+---------------+
</code><code class="mi">2</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
        A new row was not inserted even though a record for Taylor McTavish does not exist in the table. Instead, the row with <code>tax_id=12345</code>, belonging to Jim Isaacson, was modified and now stores address of Taylor McTavish.
      </p><p>
        MySQL does not allow you to specify if the row should be updated only if a particular unique key was violated. When the table has two or more unique keys it is easy to make a mistake and update the wrong row. We recommend that you avoid using <code>INSERT ... ON DUPLICATE KEY UPDATE</code> for modifying tables that have more than one unique key. You may consider using stored routines instead. We discuss stored routines in <a data-type="xref" href="ch11.xhtml#nch-routines">Chapter 11</a>
      </p></div></aside></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820336255888"><h2>See Also</h2><p>For bulk record-loading operations in which you use the <code>LOAD</code> <code>DATA</code>
      statement to load a set of rows from a file into a table, control
      duplicate-row handling using the statement’s <code>IGNORE</code> and <code>REPLACE</code> modifiers. These produce behavior
      analogous to that of the <code>INSERT</code>
      <code>IGNORE</code> and <code>REPLACE</code> statements. For more information, see
      <a data-type="xref" href="ch13.xhtml#nch-xfer-xfer-load-data">Recipe 13.1</a>.</p><p><a data-type="xref" href="ch15.xhtml#nch-sequences-seq-counter">Recipe 15.12</a> further demonstrates the use of
      <code>INSERT</code> … <code>ON</code> <code>DUPLICATE</code> <code>KEY</code> <code>UPDATE</code>
      for initializing and updating counts.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="18.4 Counting and Identifying Duplicates"><div class="sect1" id="nch-dups-dups-count"><h1>18.4 Counting and Identifying Duplicates</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820335934832"><h2>Problem</h2><p>You want to determine whether a table contains duplicates, and to what extent
      they occur. Or you want to see the rows that contain the duplicated
      values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820335888928"><h2>Solution</h2><p>Use a counting summary that displays duplicated values. To see the rows in which
      the duplicated values occur, join the summary to the original table to
      display the matching rows.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820335888048"><h2>Discussion</h2><p>Suppose that your website has a sign-up page that enables visitors
      to add themselves to your mailing list to receive periodic product
      catalog mailings. But you forgot to include a unique index in the table
      when you created it, and now you suspect that some people are signed up
      multiple times. Perhaps they forgot they were already on the list, or
      perhaps people added friends to the list who were already signed up.
      Either way, the result of having duplicate rows is that you mail out
      duplicate catalogs. This is an additional expense to you, and it annoys
      the recipients. This section discusses how to determine whether there
      are duplicate rows in a table, how prevalent they are, and how to
      display them. (For tables that do contain duplicates, <a data-type="xref" href="#nch-dups-dups-elim-table">Recipe 18.5</a> describes how to eliminate
      them.)</p><p>To determine whether duplicates occur in a table, use a counting
      summary (a topic covered in <a data-type="xref" href="ch10.xhtml#nch-sum">Chapter 10</a>). Summary
      techniques can be applied to identifying and counting duplicates by
      grouping rows with <code>GROUP</code>
      <code>BY</code> and counting the rows in each
      group using <code>COUNT()</code>. For the examples here, assume that catalog recipients are
      listed in a table named <code>catalog_list</code>
      that has the following contents:</p><pre data-type="programlisting">+-----------+-------------+--------------------------+
| last_name | first_name  | street                   |
+-----------+-------------+--------------------------+
| Isaacson  | Jim         | 515 Fordam St., Apt. 917 |
| Baxter    | Wallace     | 57 3rd Ave.              |
| McTavish  | Taylor      | 432 River Run            |
| Pinter    | Marlene     | 9 Sunset Trail           |
| BAXTER    | WALLACE     | 57 3rd Ave.              |
| Brown     | Bartholomew | 432 River Run            |
| Pinter    | Marlene     | 9 Sunset Trail           |
| Baxter    | Wallace     | 57 3rd Ave., Apt 102     |
+-----------+-------------+--------------------------+</pre><p>Suppose that you define <q>duplicate</q> using the
      <code>last_name</code> and <code>first_name</code> columns. That is, recipients with
      the same name are assumed to be the same person. The following
      statements characterize the table and assess the existence and extent of
      duplicate values:</p><ul><li><p>The total number of rows in the table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) AS rows FROM catalog_list;</code></strong>
+------+
| rows |
+------+
|    8 |
+------+</pre></li><li><p>The number of distinct names:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(DISTINCT last_name, first_name) AS 'distinct names'</code></strong>
    -&gt; <strong><code>FROM catalog_list;</code></strong>
+----------------+
| distinct names |
+----------------+
|              5 |
+----------------+</pre></li><li><p>The number of rows containing duplicated names:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) - COUNT(DISTINCT last_name, first_name)</code></strong>
    -&gt;   <strong><code>AS 'duplicate names'</code></strong>
    -&gt; <strong><code>FROM catalog_list;</code></strong>
+-----------------+
| duplicate names |
+-----------------+
|               3 |
+-----------------+</pre></li><li><p>The fraction of the rows that contain unique or nonunique
          names:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(DISTINCT last_name, first_name) / COUNT(*)</code></strong>
    -&gt;   <strong><code>AS 'unique',</code></strong>
    -&gt; <strong><code>1 - (COUNT(DISTINCT last_name, first_name) / COUNT(*))</code></strong>
    -&gt;   <strong><code>AS 'nonunique'</code></strong>
    -&gt; <strong><code>FROM catalog_list;</code></strong>
+--------+-----------+
| unique | nonunique |
+--------+-----------+
| 0.6250 |    0.3750 |
+--------+-----------+</pre></li></ul><p>Those statements help you characterize the extent of duplicates,
      but they don’t show you which values are duplicated. To see the
      duplicated names in the <code>catalog_list</code>
      table, use a summary statement that displays the nonunique values along
      with the counts:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*), last_name, first_name</code></strong>
    -&gt; <strong><code>FROM catalog_list</code></strong>
    -&gt; <strong><code>GROUP BY last_name, first_name</code></strong>
    -&gt; <strong><code>HAVING COUNT(*) &gt; 1;</code></strong>
+----------+-----------+------------+
| COUNT(*) | last_name | first_name |
+----------+-----------+------------+
|        3 | Baxter    | Wallace    |
|        2 | Pinter    | Marlene    |
+----------+-----------+------------+</pre><p>The statement includes a <code>HAVING</code>
      clause that restricts the output to include only those names that
      occur more than once. In general, to identify sets of values that are
      duplicated, do the following:</p><ol><li><p>Determine which columns contain the values that may be
          duplicated.</p></li><li><p>List those columns in the column selection list, along with
          <code>COUNT(*)</code>.</p></li><li><p>List the columns in the <code>GROUP</code> <code>BY</code> clause as well.</p></li><li><p>Add a <code>HAVING</code> clause that
          eliminates unique values by requiring group counts to be greater
          than one.</p></li></ol><p>Queries constructed that way have the following form:</p><pre data-type="programlisting" data-code-language="sql">SELECT COUNT(*), <em><code>column_list</code></em>
FROM <em><code>tbl_name</code></em>
GROUP BY <em><code>column_list</code></em>
HAVING COUNT(*) &gt; 1;</pre><p>It’s easy to generate duplicate-finding queries like that within a
      program, given database and table names and a nonempty set of column
      names. For example, here is a Perl function <code>make_dup_count_query()</code> that generates the
      proper query for finding and counting duplicated values in the specified
      columns:</p><pre data-type="programlisting" data-code-language="perl"><code class="k">sub</code> <code class="nf">make_dup_count_query</code>
<code class="p">{</code>
<code class="k">my</code> <code class="p">(</code><code class="nv">$db_name</code><code class="p">,</code> <code class="nv">$tbl_name</code><code class="p">,</code> <code class="nv">@col_name</code><code class="p">)</code> <code class="o">=</code> <code class="nv">@_</code><code class="p">;</code>

  <code class="k">return</code> <code class="s">"SELECT COUNT(*),"</code> <code class="o">.</code> <code class="nb">join</code> <code class="p">(</code><code class="s">","</code><code class="p">,</code> <code class="nv">@col_name</code><code class="p">)</code>
         <code class="o">.</code> <code class="s">"\nFROM $db_name.$tbl_name"</code>
         <code class="o">.</code> <code class="s">"\nGROUP BY "</code> <code class="o">.</code> <code class="nb">join</code> <code class="p">(</code><code class="s">","</code><code class="p">,</code> <code class="nv">@col_name</code><code class="p">)</code>
         <code class="o">.</code> <code class="s">"\nHAVING COUNT(*) &gt; 1"</code><code class="p">;</code>
<code class="p">}</code></pre><p><code>make_dup_count_query()</code> returns
      the query as a string. If you invoke it like this:</p><pre data-type="programlisting" data-code-language="perl"><code class="nv">$str</code> <code class="o">=</code> <code class="n">make_dup_count_query</code> <code class="p">(</code><code class="s">"cookbook"</code><code class="p">,</code> <code class="s">"catalog_list"</code><code class="p">,</code>
                             <code class="s">"last_name"</code><code class="p">,</code> <code class="s">"first_name"</code><code class="p">);</code></pre><p>the resulting value of <code>$str</code>
      is:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="k">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">),</code><code class="n">last_name</code><code class="p">,</code><code class="n">first_name</code>
<code class="k">FROM</code> <code class="n">cookbook</code><code class="p">.</code><code class="n">catalog_list</code>
<code class="k">GROUP</code> <code class="k">BY</code> <code class="n">last_name</code><code class="p">,</code><code class="n">first_name</code>
<code class="k">HAVING</code> <code class="k">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">;</code></pre><p>What you do with the query string is up to you. You can execute it
      from within the script that creates it, pass it to another program, or
      write it to a file for execution later. The <em class="filename">dups</em> directory of the <code>recipes</code> distribution contains a script named
      <span class="command"><em>dup_count.pl</em></span> that you can use to try
      the function (as well as some translations into other languages). <a data-type="xref" href="#nch-dups-dups-elim-table">Recipe 18.5</a> discusses use of <code>make_dup_count_query()</code> to implement a
      duplicate-removal technique.</p><p>Summary techniques are useful for assessing the existence of
      duplicates, how often they occur, and displaying which values are
      duplicated. But if duplicates are determined using only a subset of a
      table’s columns, a summary in itself cannot display the entire content
      of the rows that contain the duplicate values. (For example, the
      summaries shown thus far display counts of duplicated names in the
      <code>catalog_list</code> table or the names
      themselves, but don’t show the addresses associated with those names.)
      To see the original rows containing the duplicate names, join the
      summary information to the table from which it’s generated. The
      following example shows how to do this to display the <code>catalog_list</code> rows that contain duplicated
      names. The summary is written to a temporary table, which then is joined
      to the <code>catalog_list</code> table to produce
      the rows that match those names:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE tmp</code></strong>
    -&gt; <strong><code>SELECT COUNT(*) AS count, last_name, first_name FROM catalog_list</code></strong>
    -&gt; <strong><code>GROUP BY last_name, first_name HAVING count &gt; 1;</code></strong>
mysql&gt; <strong><code>SELECT catalog_list.*</code></strong>
    -&gt; <strong><code>FROM tmp INNER JOIN catalog_list USING (last_name, first_name)</code></strong>
    -&gt; <strong><code>ORDER BY last_name, first_name;</code></strong>
+-----------+------------+----------------------+
| last_name | first_name | street               |
+-----------+------------+----------------------+
| Baxter    | Wallace    | 57 3rd Ave.          |
| BAXTER    | WALLACE    | 57 3rd Ave.          |
| Baxter    | Wallace    | 57 3rd Ave., Apt 102 |
| Pinter    | Marlene    | 9 Sunset Trail       |
| Pinter    | Marlene    | 9 Sunset Trail       |
+-----------+------------+----------------------+</pre><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820335697824"><h5>Duplicate Identification and String Case Sensitivity</h5><p>For strings that have a case-insensitive collation, values that differ only in
        lettercase are considered the same for comparison purposes. To treat
        them as distinct values, compare them using a case-sensitive or binary
        collation. <a data-type="xref" href="ch07.xhtml#nch-strings-strings-compare">Recipe 7.7</a> shows how to
        do this.</p></div></aside></div></section></div></section><section data-type="sect1" data-pdf-bookmark="18.5 Eliminating Duplicates from a Table"><div class="sect1" id="nch-dups-dups-elim-table"><h1>18.5 Eliminating Duplicates from a Table</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820335685952"><h2>Problem</h2><p>You want to remove duplicate rows from a table, leaving only unique
      rows.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820335685072"><h2>Solution</h2><p>Select the unique rows from the table into a second table, then
      use that table to replace the original one. Or use <code>DELETE</code> … <code>LIMIT</code> <em><code>n</code></em> to remove
      all but one instance of a specific set of duplicate
      rows.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820335682784"><h2>Discussion</h2><p><a data-type="xref" href="#nch-dups-dups-prevent">Recipe 18.1</a> discusses how to prevent
      duplicates from being added to a table by creating it with a unique
      index. However, if you forget to include the index when you create a
      table, you may discover later that it contains duplicates and that it’s
      necessary to apply some sort of duplicate-removal technique. The
      <code>catalog_list</code> table used earlier is an
      example of this because it contains several instances in which the same
      person appears multiple times:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM catalog_list ORDER BY last_name, first_name;</code></strong>
+-----------+-------------+--------------------------+
| last_name | first_name  | street                   |
+-----------+-------------+--------------------------+
| Baxter    | Wallace     | 57 3rd Ave.              |
| BAXTER    | WALLACE     | 57 3rd Ave.              |
| Baxter    | Wallace     | 57 3rd Ave., Apt 102     |
| Brown     | Bartholomew | 432 River Run            |
| Isaacson  | Jim         | 515 Fordam St., Apt. 917 |
| McTavish  | Taylor      | 432 River Run            |
| Pinter    | Marlene     | 9 Sunset Trail           |
| Pinter    | Marlene     | 9 Sunset Trail           |
+-----------+-------------+--------------------------+</pre><p>To eliminate duplicates, you may use one of these two options:</p><ul><li><p>Select the table’s unique rows into another table, then use
          that table to replace the original one. This works when
          <q>duplicate</q> means <q>the entire row is the same as
          another.</q></p></li><li><p>To remove duplicates for a specific set of duplicate rows, use
          <code>DELETE</code> … <code>LIMIT</code> <em><code>n</code></em> to
          remove all but one row.</p></li></ul><p>This recipe discusses each duplicate-removal method. When deciding upon which method to choose for your circumstance, consider these questions::</p><ul><li><p>Does the method require the table to have a unique
          index?</p></li><li><p>If the columns in which duplicate values occur may contain
          <code>NULL</code>, will the method remove
          duplicate <code>NULL</code> values?</p></li><li><p>Does the method prevent duplicates from occurring in the
          future?</p></li></ul><section data-type="sect3" data-pdf-bookmark="Removing duplicates using table replacement"><div class="sect3" id="idm45820335672976"><h3>Removing duplicates using table replacement</h3><p>If a row is considered to duplicate another only if the entire
        row is the same, one way to eliminate duplicates from a table is to
        select its unique rows into a new table that has the same structure,
        and then replace the original table with the new one:</p><ol><li><p>Create a new table that has the same structure as the original one. <code>CREATE</code> <code>TABLE</code> … <code>LIKE</code> is useful for this (see <a data-type="xref" href="ch06.xhtml#nch-tblmgmt-tblmgmt-clone">Recipe 6.1</a>):</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE tmp LIKE catalog_list;</code></strong></pre></li><li><p>Use <code>INSERT</code> <code>INTO</code> … <code>SELECT</code> <code>DISTINCT</code> to select the unique rows from the original table into
            the new one:</p><pre data-type="programlisting">mysql&gt; <strong><code>INSERT INTO tmp SELECT DISTINCT * FROM catalog_list;</code></strong></pre><p>Select rows from the <code>tmp</code>
            table to verify that the new table contains no duplicates:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM tmp ORDER BY last_name, first_name;</code></strong>
+-----------+-------------+--------------------------+
| last_name | first_name  | street                   |
+-----------+-------------+--------------------------+
| Baxter    | Wallace     | 57 3rd Ave.              |
| Baxter    | Wallace     | 57 3rd Ave., Apt 102     |
| Brown     | Bartholomew | 432 River Run            |
| Isaacson  | Jim         | 515 Fordam St., Apt. 917 |
| McTavish  | Taylor      | 432 River Run            |
| Pinter    | Marlene     | 9 Sunset Trail           |
+-----------+-------------+--------------------------+</pre></li><li><p>After creating the new <code>tmp</code> table that contains unique rows, use
            it to replace the original <code>catalog_list</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>DROP TABLE catalog_list;</code></strong>
mysql&gt; <strong><code>RENAME TABLE tmp TO catalog_list;</code></strong></pre></li></ol><p>The effective result of this procedure is that <code>catalog_list</code> no longer contains
        duplicates.</p><p>This table-replacement method works in the absence of an index
        (although it might be slow for large tables). For tables that contain
        duplicate <code>NULL</code> values, it removes
        those duplicates. It does not prevent the occurrence of duplicates in
        the future.</p><p>This method requires rows to be completely identical to be
        considered duplicates. Thus, it treats as distinct those rows for
        Wallace Baxter that have slightly different <code>street</code> values.</p><p>If duplicates are defined only with respect to a subset of the
        columns in the table, create a new table that has a unique index for
        those columns, select rows into it using <code>INSERT</code> <code>IGNORE</code>, and replace the original table with
        the new one:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE tmp LIKE catalog_list;</code></strong>
mysql&gt; <strong><code>ALTER TABLE tmp ADD PRIMARY KEY (last_name, first_name);</code></strong>
mysql&gt; <strong><code>INSERT IGNORE INTO tmp SELECT * FROM catalog_list;</code></strong>
mysql&gt; <strong><code>SELECT * FROM tmp ORDER BY last_name, first_name;</code></strong>
+-----------+-------------+--------------------------+
| last_name | first_name  | street                   |
+-----------+-------------+--------------------------+
| Baxter    | Wallace     | 57 3rd Ave.              |
| Brown     | Bartholomew | 432 River Run            |
| Isaacson  | Jim         | 515 Fordam St., Apt. 917 |
| McTavish  | Taylor      | 432 River Run            |
| Pinter    | Marlene     | 9 Sunset Trail           |
+-----------+-------------+--------------------------+
mysql&gt; <strong><code>DROP TABLE catalog_list;</code></strong>
mysql&gt; <strong><code>RENAME TABLE tmp TO catalog_list;</code></strong></pre><p>The unique index prevents rows with duplicate key values from
        being inserted into <code>tmp</code>, and
        <code>IGNORE</code> tells MySQL not to stop with
        an error if a duplicate is found. One shortcoming of this method is
        that if the indexed columns can contain <code>NULL</code> values, you must use a <code>UNIQUE</code> index rather than a <code>PRIMARY</code> <code>KEY</code>, in which case the index will not remove
        duplicate <code>NULL</code> keys. (<code>UNIQUE</code> indexes permit multiple <code>NULL</code> values.) This method does prevent
        occurrence of duplicates in the future.</p></div></section><section data-type="sect3" data-pdf-bookmark="Removing duplicates of a particular row"><div class="sect3" id="idm45820335647104"><h3>Removing duplicates of a particular row</h3><p>You can use <code>LIMIT</code> to restrict
        the effect of a <code>DELETE</code> statement to
        a subset of the rows that it otherwise would delete. This makes the
        statement applicable to removing duplicate rows. Suppose that the
        original unindexed <code>catalog_list</code>
        table contains duplicates:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*), last_name, first_name</code></strong>
    -&gt; <strong><code>FROM catalog_list</code></strong>
    -&gt; <strong><code>GROUP BY last_name, first_name</code></strong>
    -&gt; <strong><code>HAVING COUNT(*) &gt; 1;</code></strong>
+----------+-----------+------------+
| COUNT(*) | last_name | first_name |
+----------+-----------+------------+
|        3 | Baxter    | Wallace    |
|        2 | Pinter    | Marlene    |
+----------+-----------+------------+</pre><p>To remove the extra instances of each name, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>DELETE FROM catalog_list WHERE last_name = 'Baxter'</code></strong>
    -&gt; <strong><code>AND first_name = 'Wallace' LIMIT 2;</code></strong>
mysql&gt; <strong><code>DELETE FROM catalog_list WHERE last_name = 'Pinter'</code></strong>
    -&gt; <strong><code>AND first_name = 'Marlene' LIMIT 1;</code></strong>
mysql&gt; <strong><code>SELECT * FROM catalog_list;</code></strong>
+-----------+-------------+--------------------------+
| last_name | first_name  | street                   |
+-----------+-------------+--------------------------+
| Isaacson  | Jim         | 515 Fordam St., Apt. 917 |
| McTavish  | Taylor      | 432 River Run            |
| Brown     | Bartholomew | 432 River Run            |
| Pinter    | Marlene     | 9 Sunset Trail           |
| Baxter    | Wallace     | 57 3rd Ave., Apt 102     |
+-----------+-------------+--------------------------+</pre><p>This technique works in the absence of a unique index, and it
        eliminates duplicate <code>NULL</code> values.
        It’s handy for removing duplicates only for a specific set of rows
        within a table. However, if there are many different sets of
        duplicates to remove, this is not a procedure you’d want to carry out
        by hand. The process can be automated by using the techniques
        discussed earlier in <a data-type="xref" href="#nch-dups-dups-count">Recipe 18.4</a> for
        determining which values are duplicated. There, we wrote a <code>make_dup_count_query()</code> function to generate
        the statement needed to count the number of duplicate values in a
        given set of columns in a table. The result of that statement can be
        used to generate a set of <code>DELETE</code> …
        <code>LIMIT</code> <em><code>n</code></em>
        statements that remove duplicate rows and leave only unique rows. The
        <em class="filename">dups</em> directory of the <code>recipes</code> distribution contains code that
        shows how to generate these statements.</p><p>In general, using <code>DELETE</code> …
        <code>LIMIT</code> <em><code>n</code></em>
        is likely to be slower than removing duplicates by using a second
        table or by adding a unique index. Those methods keep the data on the
        server side and let the server do all the work. <code>DELETE</code> … <code>LIMIT</code> <em><code>n</code></em> involves
        a lot of client-server interaction because it uses a <code>SELECT</code> statement to retrieve information
        about duplicates, followed by several <code>DELETE</code> statements to remove instances of
        duplicated rows. Also, this technique does not prevent duplicates from
        occurring in the future.</p></div></section></div></section></div></section></div></section></div></body></html>