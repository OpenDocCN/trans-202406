- en: Chapter 6\. Supply Chain Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 供应链安全
- en: Earlier chapters primarily focused on securing the Kubernetes cluster and its
    components, the OS infrastructure used to run cluster nodes, and the operational
    aspects for running workload on a cluster node with existing container images.
    This chapter takes a step back and drills into the process, best practices, and
    tooling for designing, building, and optimizing container images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 较早的章节主要集中在保护 Kubernetes 集群及其组件、用于运行集群节点的操作系统基础设施以及在现有容器镜像上运行工作负载的操作方面。本章退一步，深入探讨了设计、构建和优化容器镜像的过程、最佳实践和工具。
- en: Sometimes, you do not want to create your own container image but instead consume
    an existing one produced by a different team or company. Scanning container images
    for known vulnerabilities in a manual or automated fashion should be part of your
    vetting process before using them to run your workload. We’ll talk through some
    options relevant to the CKS exam used to identify, analyze, and mitigate security
    risks for pre-built container images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不想创建自己的容器镜像，而是消耗由其他团队或公司生产的现有镜像。在使用它们运行工作负载之前，手动或自动扫描已知漏洞的容器镜像应该成为你的审查过程的一部分。我们将讨论与
    CKS 考试相关的一些选项，用于识别、分析和减轻预构建容器镜像的安全风险。
- en: 'At a high level, this chapter covers the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，本章涵盖以下概念：
- en: Minimizing base image footprint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小基础镜像的占用空间
- en: Securing the supply chain
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护供应链
- en: Using static analysis of user workload
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户工作负载的静态分析
- en: Scanning images for known vulnerabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描已知漏洞的镜像
- en: Minimizing the Base Image Footprint
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减小基础镜像的占用空间
- en: The process for building a container image looks straightforward on the surface
    level; however, the devil is often in the details. It may not be obvious to someone
    new to the topic to refrain from building a container image that is unnecessarily
    too large in size, riddled with vulnerabilities, and not optimized for container
    layer caching. We’ll address all of those aspects in the course of this chapter
    with the help of the container engine Docker.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，构建容器镜像的过程似乎很简单；然而，魔鬼往往隐藏在细节中。对于新手来说，要避免构建过大、充满漏洞并且不优化容器层缓存的容器镜像可能并不明显。在本章的课程中，我们将在
    Docker 容器引擎的帮助下解决所有这些问题。
- en: 'Scenario: An Attacker Exploits Container Vulnerabilities'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景：攻击者利用容器漏洞
- en: One of the first decisions you have to make when defining a Dockerfile is the
    selection of a base image. The base image provides the operating system and additional
    dependencies, and it may expose shell access.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 Dockerfile 时，你需要做的第一个决定之一是选择一个基础镜像。基础镜像提供操作系统和额外的依赖项，并可能暴露 shell 访问权限。
- en: Some of the base images you can choose from on a public registry like Docker
    Hub are large in size and will likely contain functionality you don’t necessarily
    need to run your application inside of it. The operating system itself, as well
    as any dependencies available with the base image, can expose vulnerabilities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Docker Hub 这样的公共注册表上，你可以选择的一些基础镜像体积庞大，并且可能包含你不一定需要在其中运行应用程序的功能。操作系统本身以及基础镜像提供的任何依赖项都可能存在漏洞。
- en: In [Figure 6-1](#container-image-vulnerabilities-attacker), the attacker was
    able to figure out details about the container by gaining access to it. Those
    vulnerabilities can now be used as a launching pad for more advanced attacks.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6-1](#container-image-vulnerabilities-attacker) 中，攻击者能够通过访问容器获取关于其详细信息的信息。这些漏洞现在可以被用作更高级攻击的跳板。
- en: '![ckss 0601](assets/ckss_0601.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![ckss 0601](assets/ckss_0601.png)'
- en: Figure 6-1\. An attacker exploits container image vulnerabilities
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. 攻击者利用容器镜像漏洞
- en: It is recommended to use a base image with a minimal set of functionality and
    dependencies. The next couple of sections will explain the methods for creating
    a more optimized base image that’s faster to build, quicker to download from a
    container registry, and that will ultimately lead to a smaller attack surface
    simply by reducing the bloat. The next sections will touch on the most important
    techniques. You can find a more detailed list of best practices for writing Dockerfiles
    in the [Docker documentation](https://oreil.ly/43Diy).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用一个功能和依赖项最少的基础镜像。接下来的几节将解释创建更优化的基础镜像的方法，这将使构建速度更快，从容器注册表下载速度更快，并且通过减少臃肿的镜像来减小攻击面。接下来的几节将涉及最重要的技术。你可以在[Docker文档](https://oreil.ly/43Diy)中找到更详细的Dockerfile写作最佳实践列表。
- en: Picking a Base Image Small in Size
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择尺寸小的基础镜像
- en: 'Some container images can have a size of a gigabyte or even more. Do you really
    need all the functionality bundled with such a container image? Unlikely. Thankfully,
    many container producers upload a wide range of variations of their container
    images for the same release. One of those variations is an `alpine` image, a small,
    lightweight, and less vulnerable Linux distribution. As you can see in the following
    output, the downloaded `alpine` container image with the tag `3.17.0` only has
    a size of 7.05MB:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些容器镜像可能有千兆字节甚至更多的大小。您真的需要这种容器镜像捆绑的所有功能吗？可能性不大。幸运的是，许多容器生产商为同一个版本上传了各种变体的容器镜像。其中一个变体是`alpine`镜像，这是一个小巧、轻量且较少漏洞的Linux发行版。正如您在下面的输出中所看到的，下载的带有标签`3.17.0`的`alpine`容器镜像只有7.05MB的大小：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `alpine` container image comes with an `sh` shell you can use to troubleshoot
    the process running inside of the container. You can use the following command
    to open an interactive shell in a new container:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`alpine`容器镜像自带一个`sh` shell，您可以用来排查容器内运行的进程。您可以使用以下命令在一个新的容器中打开交互式shell：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While runtime troubleshooting functionality can be useful, offering a shell
    as part of a container image increases the size of it and potentially opens the
    door for attackers. Additionally, the more software there is inside of a container
    image, the more vulnerabilities it will have.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然运行时的故障排除功能可能很有用，但将shell作为容器镜像的一部分会增加其大小，并可能为攻击者打开大门。此外，容器镜像内的软件越多，其漏洞也会越多。
- en: 'You can further reduce the container image size and the attack surface by using
    a [distroless image](https://oreil.ly/J6Vra) offered by Google. The following
    command downloads the latest tag of the container image `gcr.io/distroless/static-debian11`
    and renders its details. The size of the container image is only 2.34MB:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用由Google提供的[distroless镜像](https://oreil.ly/J6Vra)进一步减小容器镜像的大小和攻击面。以下命令下载`gcr.io/distroless/static-debian11`容器镜像的最新标签，并显示其详情。容器镜像的大小仅为2.34MB：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A distroless container image does not ship with any shell, which you can observe
    by running the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Distroless容器镜像不包含任何shell，您可以通过运行以下命令观察到这一点：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Kubernetes offers the concept of ephemeral containers for troubleshooting distroless
    containers. Those containers are meant to be disposable and can be deployed for
    troubleshooting minimal containers that would usually not allow opening a shell.
    Discussing ephemeral containers is out of scope of this book, but you can find
    more information about them in the [Kubernetes documentation](https://oreil.ly/IRjP3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了用于故障排除distroless容器的临时容器的概念。这些容器被设计为可丢弃的，可以用于排查通常不允许打开shell的最小化容器。讨论临时容器超出了本书的范围，但您可以在[Kubernetes文档](https://oreil.ly/IRjP3)中找到更多信息。
- en: Using a Multi-Stage Approach for Building Container Images
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多阶段方法构建容器镜像
- en: As a developer, you can decide to build the application code as part of the
    instructions in a Dockerfile. This process may include compiling the code and
    building a binary that should become the entry point of the container image. Having
    all the necessarily tools and dependencies available to implement the process
    will automatically blow up the size of the container image, plus you won’t need
    those dependencies at runtime anymore.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，您可以决定将应用程序代码作为Dockerfile指令的一部分进行构建。这个过程可能包括编译代码和构建一个应该成为容器镜像入口点的二进制文件。拥有实施这一过程所需的所有工具和依赖项将自动增加容器镜像的大小，而且您在运行时也不再需要这些依赖项。
- en: The idea of a [multi-stage build in Docker](https://oreil.ly/znQc3) is that
    you separate the build stage from the runtime stage. As a result, all dependencies
    needed in the build stage will be discarded after the process has been performed
    and therefore do not end up in the final container image. This approach leads
    to a much smaller container image size by removing all the unnecessary cruft.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中使用[多阶段构建](https://oreil.ly/znQc3)的思想是将构建阶段与运行阶段分离。因此，构建阶段中需要的所有依赖项在完成进程后都会被丢弃，因此不会出现在最终的容器镜像中。这种方法通过去除所有不必要的内容，大大减小了容器镜像的大小。
- en: While we won’t go into the details of crafting and fully understanding multi-stage
    Dockerfile, I want to show you the differences on a high level. We’ll start by
    showing you a Dockerfile that builds and tests a simple program using the programming
    language Go, as shown in [Example 6-1](#dockerfile-single-stage). In essence,
    we are using a [base image](https://oreil.ly/nwLtT) that includes Go 1.19.4\.
    The Go runtime provides the `go` executes, which we’ll invoke to execute the tests
    and build the binary of the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会详细介绍制作和完全理解多阶段 Dockerfile 的细节，但我想在高层次上展示一下它们的区别。我们将首先展示一个 Dockerfile，它使用编程语言
    Go 构建和测试一个简单的程序，如[示例 6-1](#dockerfile-single-stage)所示。实质上，我们使用了一个包含 Go 1.19.4
    的[基础镜像](https://oreil.ly/nwLtT)。Go 运行时提供了`go`命令，我们将调用它来执行测试并构建应用程序的二进制文件。
- en: Example 6-1\. Building and testing a Go program using a Go base image
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 使用 Go 基础镜像构建和测试 Go 程序
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO1-1)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_supply_chain_security_CO1-1)'
- en: Uses a Go base image
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了一个 Go 基础镜像
- en: '[![2](assets/2.png)](#co_supply_chain_security_CO1-2)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_supply_chain_security_CO1-2)'
- en: Executes the tests against the application code
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 执行针对应用代码的测试。
- en: '[![3](assets/3.png)](#co_supply_chain_security_CO1-3)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_supply_chain_security_CO1-3)'
- en: Builds the binary of the Go application
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Go 应用程序的二进制文件。
- en: 'You can produce the image using the `docker build` command, as shown in the
    following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker build`命令生成镜像，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The size of the result container image is pretty big, 348MB, and there’s a
    good reason for it. It includes the Go runtime, even though we don’t actually
    need it anymore when starting the container. The `go build` command produced the
    binary that we can run as the container’s entry point:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果容器镜像的大小相当大，为 348MB，这其中有很好的理由。它包含了 Go 运行时，尽管在启动容器时实际上不再需要它。`go build`命令生成的二进制文件将作为容器启动时的命令运行：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next up, we’ll have a look at the multi-stage approach. In a multi-stage Dockerfile,
    you define at least two stages. In [Example 6-2](#dockerfile-multi-stage), we
    specify a stage aliased with `build` to run the tests and build the binary, similarly
    to what we’ve done earlier. A second stage copies the binary produced by the stage
    `build` into a dedicated directory; however, it uses the `alpine` base image to
    run it. When running the `docker build` command, the stage `build` will not be
    included in the final container image anymore.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看多阶段方法。在多阶段的 Dockerfile 中，您至少定义了两个阶段。在[示例 6-2](#dockerfile-multi-stage)中，我们指定了一个别名为`build`的阶段来运行测试并构建二进制文件，类似于之前的操作。第二个阶段将由阶段`build`生成的二进制文件复制到一个专用目录中；然而，它使用`alpine`基础镜像来运行它。在运行`docker
    build`命令时，阶段`build`将不再包含在最终的容器镜像中。
- en: Example 6-2\. Building and testing a Go program as part of a multi-stage Dockerfile
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 作为多阶段 Dockerfile 的一部分构建和测试 Go 程序
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO2-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_supply_chain_security_CO2-1)'
- en: Uses a Go base image for building and testing the program in the stage named
    `build`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为`build`的阶段中，使用了一个 Go 基础镜像来构建和测试程序。
- en: '[![2](assets/2.png)](#co_supply_chain_security_CO2-2)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_supply_chain_security_CO2-2)'
- en: Executes the tests against the application code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行针对应用代码的测试。
- en: '[![3](assets/3.png)](#co_supply_chain_security_CO2-3)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_supply_chain_security_CO2-3)'
- en: Builds the binary of the Go application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Go 应用程序的二进制文件。
- en: '[![4](assets/4.png)](#co_supply_chain_security_CO2-4)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_supply_chain_security_CO2-4)'
- en: Uses a much smaller base image for running the application in a container.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个更小的基础镜像来运行容器中的应用程序。
- en: '[![5](assets/5.png)](#co_supply_chain_security_CO2-5)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_supply_chain_security_CO2-5)'
- en: Copies the application binary produced in the `build` stage and uses it as the
    command to run when the container is started.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 复制在`build`阶段生成的应用程序二进制文件，并将其用作启动容器时运行的命令。
- en: 'The resulting container image size is significantly smaller when using the
    `alpine` base image, only 12MB. You can verify the outcome by running the `docker
    build` command again and inspecting the size of the container image by listing
    it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `alpine` 基础镜像时，生成的容器镜像大小显著较小，仅为 12MB。您可以通过再次运行 `docker build` 命令并列出容器镜像大小来验证结果：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Not only did we reduce the size, we also reduced the attack surface by including
    fewer dependencies. You can further reduce the size of the container image by
    incorporating a distroless base image instead of the `alpine` base image.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅减少了大小，还通过包含更少的依赖项减少了攻击面。通过使用 distroless 基础镜像而不是 `alpine` 基础镜像，你可以进一步减小容器镜像的大小。
- en: Reducing the Number of Layers
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少层数
- en: Every Dockerfile consists of an ordered list of instructions. Only some instructions
    create a read-only layer in the resulting container image. Those instructions
    are `FROM`, `COPY`, `RUN`, and `CMD`. All other instructions will not create a
    layer as they create temporary intermediate images. The more layers you add to
    the container image, the slower will be the build execution time and/or the bigger
    will be the size of the container image. Therefore, you need to be cautious about
    the instructions used in your Dockerfile to minimize the footprint of the container
    image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Dockerfile 都由一系列有序的指令组成。只有一些指令会在最终容器镜像中创建只读层。这些指令是 `FROM`、`COPY`、`RUN` 和
    `CMD`。所有其他指令不会创建层，因为它们会创建临时中间镜像。向容器镜像添加的层数越多，构建执行时间可能会越慢，容器镜像的大小可能会越大。因此，需要谨慎选择
    Dockerfile 中的指令，以尽量减小容器镜像的占用空间。
- en: It’s common practice to execute multiple commands in a row. You may define those
    commands using a list of `RUN` instructions on individual lines, as shown in [Example 6-3](#dockerfile-multiple-run-instructions).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会连续执行多个命令。您可以使用单独的 `RUN` 指令列表来定义这些命令，如 [示例 6-3](#dockerfile-multiple-run-instructions)
    所示。
- en: Example 6-3\. A Dockerfile specifying multiple `RUN` instructions
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 指定多个 `RUN` 指令的 Dockerfile
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each `RUN` instruction will create a layer, potentially adding to the size of
    the container image. It’s more efficient to string them together with `&&` to
    ensure that only a single layer will be produced. [Example 6-4](#dockerfile-combined-run-instructions)
    shows an example of this optimization technique.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `RUN` 指令将创建一个层，可能会增加容器镜像的大小。使用 `&&` 将它们串联在一起更有效，确保只生成单个层。[示例 6-4](#dockerfile-combined-run-instructions)
    展示了这种优化技术的示例。
- en: Example 6-4\. A Dockerfile specifying multiple `RUN` instructions
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 指定多个 `RUN` 指令的 Dockerfile
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using Container Image Optimization Tools
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器镜像优化工具
- en: 'It’s easy to forget about the optimization practices mentioned previously.
    The open source community developed a couple of tools that can help with inspecting
    a produced container image. Their functionalities provide useful tips for pairing
    down on unnecessary layers, files, and folders:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记之前提到的优化实践。开源社区开发了一些工具，可以帮助检查生成的容器镜像。它们的功能提供了有用的提示，可以减少不必要的层、文件和文件夹：
- en: DockerSlim
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: DockerSlim
- en: DockerSlim will optimize and secure your container image by analyzing your application
    and its dependencies. You can find more information in the tool’s [GitHub repository](https://oreil.ly/ZbeZl).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: DockerSlim 将通过分析应用程序及其依赖项来优化和保护您的容器镜像。您可以在该工具的 [GitHub 仓库](https://oreil.ly/ZbeZl)
    中获取更多信息。
- en: Dive
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Dive
- en: Dive is a tool for exploring the layers baked into a container image. It makes
    it easy to identify unnecessary layers, which you can further optimize on. The
    code and documentation for Dive are available in a [GitHub repository](https://oreil.ly/UBqqj).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Dive 是一个用于探索嵌入容器镜像中层的工具。它可以帮助您轻松识别不必要的层，进而进行进一步优化。Dive 的代码和文档可在 [GitHub 仓库](https://oreil.ly/UBqqj)
    中找到。
- en: This is only the short list of container image optimization tools. In [“Static
    Analysis of Workload”](#static-analysis-workload), we’ll have a look at other
    tools that focus on the static analysis of Dockerfiles and Kubernetes manifests.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是容器镜像优化工具的简短列表。在 [“工作负载的静态分析”](#static-analysis-workload) 中，我们将看看其他专注于 Dockerfile
    和 Kubernetes 清单的静态分析工具。
- en: Securing the Supply Chain
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护供应链
- en: A supply chain automates the process of producing a container image and operating
    it in a runtime environment, in this case Kubernetes. We already touched on a
    couple of tools that can be integrated into the supply chain to support the aspect
    of container image optimization. In this section, we’ll expand on practices that
    target security aspects. Refer to the book [*Container Security*](https://learning.oreilly.com/library/view/container-security/9781492056690/)
    by Liz Rice (O’Reilly) to learn more.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 供应链自动化生产容器镜像并在运行时环境中操作的过程，在这种情况下是 Kubernetes。我们已经提到了一些可以集成到供应链中以支持容器镜像优化方面的工具。在本节中，我们将扩展到针对安全方面的实践。参考书籍
    [*Container Security*](https://learning.oreilly.com/library/view/container-security/9781492056690/)
    作者 Liz Rice（O’Reilly）以获取更多信息。
- en: Signing Container Images
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签署容器镜像
- en: You can sign a container image before pushing it to a container registry. Signing
    can be achieved with the `docker trust sign` command, which adds a signature to
    the container image, the so-called image digest. An image digest is derived from
    the contents of the container image and commonly represented in the form of SHA256\.
    When consuming the container image, Kubernetes can compare the image digest with
    the contents of the image to ensure that it hasn’t been tampered with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在将容器镜像推送到容器注册表之前，您可以对其进行签名。签名可以通过`docker trust sign`命令实现，该命令会向容器镜像添加一个签名，即所谓的图像摘要。图像摘要是根据容器镜像的内容派生的，通常以SHA256的形式表示。在消费容器镜像时，Kubernetes可以将图像摘要与镜像内容进行比较，以确保其未被篡改。
- en: 'Scenario: An Attacker Injects Malicious Code into a Container Image'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景：攻击者将恶意代码注入容器镜像
- en: The Kubernetes component that verifies the image digest is the kubelet. If you
    configured the [image pull policy](https://oreil.ly/0wSjy) to `Always`, the kubelet
    will query for the image digest from the container registry even though it may
    have downloaded and verified the container image before.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 验证图像摘要的 Kubernetes 组件是 kubelet。如果您将 [image pull policy](https://oreil.ly/0wSjy)
    配置为 `Always`，即使 kubelet 在之前已经下载和验证过容器镜像，它也会从容器注册表中查询图像摘要。
- en: An attacker can try to modify the contents of an existing container image, inject
    malicious code, and upload it to the container registry with the same tag, as
    shown in [Figure 6-2](#no-image-digest-validation-attacker). The malicious code
    running in the container could then send sensitive information to a third-party
    server accessible by the attacker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以尝试修改现有容器镜像的内容，注入恶意代码，并将其上传到具有相同标签的容器注册表中，如 [图 6-2](#no-image-digest-validation-attacker)
    所示。然后，运行在容器中的恶意代码可能会将敏感信息发送到攻击者可访问的第三方服务器。
- en: '![ckss 0602](assets/ckss_0602.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![ckss 0602](assets/ckss_0602.png)'
- en: Figure 6-2\. An attacker injects malicious code into a container image
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 攻击者将恶意代码注入容器镜像
- en: Image checksum validation is not automatic
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器镜像的校验和验证不是自动进行的
- en: Image digest validation is an opt-in functionality in Kubernetes. When defining
    Pods, make sure you spell out the image digest explicitly for all container images.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图像摘要验证在 Kubernetes 中是一种选择性功能。在定义 Pod 时，请确保明确指定所有容器镜像的图像摘要。
- en: Validating Container Images
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证容器镜像
- en: In Kubernetes, you’re able to append the SHA256 image digest to the specification
    of a container. For example, this can be achieved with the attribute `spec.containers[].image`.
    The image digest is generally available in the container registry. For example,
    [Figure 6-3](#dockerhub-alpine-image-digest) shows the image digest for the container
    image [`alpine:3.17.0` on Docker Hub](https://oreil.ly/ZAV_H). In this example,
    the image digest is `sha256:c0d488a800e4127c334ad20d61d7bc21b4097540327217dfab52262adc02380c`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，您可以将 SHA256 图像摘要附加到容器的规范中。例如，可以通过属性`spec.containers[].image`来实现。图像摘要通常可以在容器注册表中找到。例如，[图
    6-3](#dockerhub-alpine-image-digest) 显示了 Docker Hub 上 `alpine:3.17.0` 容器镜像的图像摘要（https://oreil.ly/ZAV_H）。在此示例中，图像摘要为
    `sha256:c0d488a800e4127c334ad20d61d7bc21b4097540327217dfab52262adc02380c`。
- en: '![ckss 0603](assets/ckss_0603.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![ckss 0603](assets/ckss_0603.png)'
- en: Figure 6-3\. The image digest of the `alpine:3.17.0` container image on Docker
    Hub
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. Docker Hub 上 `alpine:3.17.0` 容器镜像的图像摘要
- en: Let’s see the image digest in action. Instead of using the tag, [Example 6-5](#container-valid-image-digest)
    specifies the container image by appending the image digest.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图像摘要的作用。而不是使用标签，[示例 6-5](#container-valid-image-digest) 通过附加图像摘要来指定容器镜像。
- en: Example 6-5\. A Pod using a valid container image digest
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 使用有效容器镜像摘要的 Pod
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating the Pod will work as expected. The image digest will be verified and
    the container transitions into the “Running” status:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Pod 将按预期工作。将验证镜像摘要，并将容器转换为“运行”状态：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Example 6-6](#container-invalid-image-digest) shows the same Pod definition;
    however, the image digest has been changed so that it does not match with the
    contents of the container image.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-6](#container-invalid-image-digest) 显示了相同的 Pod 定义；但是，已更改了镜像摘要，因此它与容器镜像的内容不匹配。'
- en: Example 6-6\. A Pod using an invalid container image digest
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 使用无效容器镜像摘要的 Pod
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You will see that Kubernetes can still create the Pod object but it can’t properly
    validate the hash of the container image. This results in the status “ErrImagePull.”
    As you can see from the event log, the container image couldn’t even be pulled
    from the container registry:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现 Kubernetes 仍然可以创建 Pod 对象，但无法正确验证容器镜像的哈希值。这将导致状态为“ErrImagePull”。正如事件日志中所示，甚至无法从容器注册表中拉取容器镜像：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using Public Image Registries
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用公共镜像注册表
- en: Whenever a Pod is created, the container runtime engine will download the declared
    container image from a container registry if it isn’t available locally yet. This
    runtime behavior can be further tweaked using the [image pull policy](https://oreil.ly/ZBMnH).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个 Pod 时，容器运行时引擎将从容器注册表下载声明的容器镜像（如果本地尚不可用）。可以使用[镜像拉取策略](https://oreil.ly/ZBMnH)来进一步调整此运行时行为。
- en: The prefix in the image name declares the domain name of the registry; e.g.,
    `gcr.io/google-containers/debian-base:v1.0.1` refers to the container image `google-containers/debian-base:v1.0.1`
    in the [Google Cloud container registry](https://oreil.ly/QFxfY), denoted by `gcr.io`.
    The container runtime will try to resolve it from `docker.io`, the [Docker Hub
    container registry](https://hub.docker.com) if you leave off the domain name in
    the container image declaration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图像名称中的前缀声明了注册表的域名；例如，`gcr.io/google-containers/debian-base:v1.0.1` 指的是 `google-containers/debian-base:v1.0.1`
    在[Google Cloud 容器注册表](https://oreil.ly/QFxfY)中，由 `gcr.io` 表示。如果在容器镜像声明中不指定域名，则容器运行时将尝试从
    `docker.io`，即[Docker Hub 容器注册表](https://hub.docker.com) 解析它。
- en: 'Scenario: An Attacker Uploads a Malicious Container Image'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情景：攻击者上传恶意容器镜像
- en: While it is convenient to resolve container images from public container registries,
    it doesn’t come without risks. Anyone with a login to those container registries
    can upload new images. Consuming container images usually doesn’t even require
    an account.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从公共容器注册表解析容器镜像很方便，但也伴随着风险。任何拥有这些容器注册表登录凭据的人都可以上传新的镜像。通常，使用容器镜像并不需要账户。
- en: As shown in [Figure 6-4](#public-registries-attacker), an attacker can upload
    a container image containing malicious code to a public registry using stolen
    credentials. Any container referencing the container image from that registry
    will automatically run the malicious code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 6-4 所示（#公共注册表攻击者），攻击者可以使用窃取的凭据上传包含恶意代码的容器镜像到公共注册表。任何引用该注册表中容器镜像的容器都将自动运行恶意代码。
- en: '![ckss 0604](assets/ckss_0604.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![ckss 0604](assets/ckss_0604.png)'
- en: Figure 6-4\. An attacker uploads a malicious container image
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. 攻击者上传恶意容器镜像
- en: On an enterprise level, you need to control which container registries you trust.
    It’s recommended to set up your own container registry within your company’s network,
    which you can fully control and govern. Alternatively, you can set up a private
    container registry in a cloud provider environment, not accessible by anyone else.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业级别上，您需要控制信任的容器注册表。建议在公司网络内设置自己的容器注册表，可以完全控制和管理。或者，您可以在云提供商环境中设置一个私有容器注册表，不允许任何其他人访问。
- en: One of the prominent binary repository managers you can choose from is [JFrog
    Artifactory](https://oreil.ly/jdF_6). The product fully supports storing, scanning,
    and serving container images. Any consumer of container images should only be
    allowed to pull images from your whitelisted container registry. All other container
    registries should be denied.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择其中一个主要的二进制仓库管理器，例如[JFrog Artifactory](https://oreil.ly/jdF_6)。该产品完全支持存储、扫描和提供容器镜像。任何使用容器镜像的消费者应仅允许从您的白名单容器注册表中拉取镜像。所有其他容器注册表都应该被拒绝。
- en: Whitelisting Allowed Image Registries with OPA GateKeeper
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 OPA GateKeeper 白名单允许的镜像注册表
- en: One way to govern container registry usage is with OPA Gatekeeper. We discussed
    the installation process and functionality of OPA Gatekeeper in [“Understanding
    Open Policy Agent (OPA) and Gatekeeper”](ch05.xhtml#opa-gatekeeper). Here, we’ll’
    touch on the constraint template and constraint for allowing trusted container
    registries.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 **OPA Gatekeeper** 控制容器注册表的使用方式。我们讨论了 [“理解开放策略代理（OPA）和 Gatekeeper”](ch05.xhtml#opa-gatekeeper)
    的安装过程和功能。在这里，我们将触及约束模板和允许信任容器注册表的约束条件。
- en: '[Example 6-7](#opa-whitelisted-repositories-constraint-template) shows the
    [constraint template](https://oreil.ly/hvgnr) I got directly from the OPA Gatekeeper
    library. As input properties, the constraint template defines an array of strings
    representing the prefixes of container registries. The Rego rules verify not only
    the assigned container images for the attribute `spec.containers[]` but also `spec.initContainers[]`
    and `spec.ephemeralContainers[]`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-7](#opa-whitelisted-repositories-constraint-template) 展示了我直接从 OPA Gatekeeper
    库获取的 [约束模板](https://oreil.ly/hvgnr)。作为输入属性，约束模板定义了一个字符串数组，表示容器注册表的前缀。Rego 规则不仅验证了属性
    `spec.containers[]` 的分配容器镜像，还验证了 `spec.initContainers[]` 和 `spec.ephemeralContainers[]`。'
- en: Example 6-7\. An OPA Gatekeeper constraint template for enforcing container
    registries
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. 用于执行容器注册表强制约束的 OPA Gatekeeper 约束模板。
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constraint shown in [Example 6-8](#opa-whitelisted-repositories-constraint)
    is in charge of defining which container registries we want to allow. You’d usually
    go with a domain name of a server hosted in your company’s network. Here, we are
    going to use `gcr.io/` for demonstration purposes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 6-8](#opa-whitelisted-repositories-constraint) 中显示的约束负责定义我们想要允许的容器注册表。通常会选择公司网络中托管的服务器的域名。在这里，我们将使用
    `gcr.io/` 作为演示目的。
- en: Example 6-8\. An OPA Gatekeeper constraint assigning Google Cloud registry as
    trusted repository
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. OPA Gatekeeper 约束，将 Google Cloud 注册表分配为受信任的存储库。
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s create both objects using the `apply` command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `apply` 命令创建这两个对象：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the constraint, we didn’t specify a namespace that the rules should apply
    to. Therefore, they’ll apply across all namespaces in the cluster. The following
    commands verify that the whitelisting rules work as expected. The following command
    tries to create a Pod using the `nginx` container image from Docker Hub. The creation
    of the Pod is denied with an appropriate error message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在约束中，我们没有指定规则应适用于的命名空间。因此，它们将适用于集群中的所有命名空间。以下命令验证白名单规则是否按预期工作。以下命令尝试使用来自 Docker
    Hub 的 `nginx` 容器镜像创建一个 Pod。创建 Pod 被拒绝，并显示适当的错误消息：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next command creates a Pod with a container image from the Google Cloud
    container registry. The operation is permitted and the Pod object is created:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令创建一个 Pod，其容器镜像来自 Google Cloud 容器注册表。操作被允许，并且创建了 Pod 对象：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Whitelisting Allowed Image Registries with the ImagePolicyWebhook Admission
    Controller Plugin
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ImagePolicyWebhook Admission Controller 插件为允许的镜像注册表设置白名单。
- en: Another way to validate the use of allowed image registries is to intercept
    a call to the API server when a Pod is about to be created. This mechanism can
    be achieved by enabling an admission controller plugin. Once configured, the logic
    of an admission controller plugin is automatically invoked when the API server
    receives the request, but after it could authenticate and authorize the caller.
    We already touched on the phases an API call has to go through in [“Processing
    a Request”](ch03.xhtml#processing-api-request).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种验证允许使用的镜像注册表的方法是拦截在创建 Pod 时向 API 服务器发出的调用。通过启用 Admission Controller 插件可以实现此机制。配置后，当
    API 服务器接收请求时，会自动调用 Admission Controller 插件的逻辑，但在验证调用者身份后。我们已经讨论了 API 调用必须经过的阶段，见
    [“处理请求”](ch03.xhtml#processing-api-request)。
- en: The admission controller provides a way to approve, deny, or mutate a request
    before the request takes effect. For example, we can inspect the data sent with
    the API request to create a Pod, iterate over the assigned container images, and
    execute custom logic to validate the container image notation. If the container
    image doesn’t stick to the expected conventions, we can deny the creation of the
    Pod. [Figure 6-5](#imagepolicywebhook-admission-controller-plugin) illustrates
    the high-level workflow.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Admission Controller 提供了在请求生效之前批准、拒绝或变更请求的方式。例如，我们可以检查与创建 Pod 的 API 请求一起发送的数据，迭代分配的容器镜像，并执行自定义逻辑以验证容器镜像的表示法。如果容器镜像不符合预期的约定，我们可以拒绝创建
    Pod。[图 6-5](#imagepolicywebhook-admission-controller-plugin) 展示了高级别的工作流程。
- en: '![ckss 0605](assets/ckss_0605.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![ckss 0605](assets/ckss_0605.png)'
- en: Figure 6-5\. Intercepting a Pod-specific API call and handling it with a webhook
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5. 拦截特定 Pod API 调用并使用 Webhook 处理它
- en: The [ImagePolicyWebhook](https://oreil.ly/JxmUu) admission controller plugin
    is one of the plugins we can configure for intercepting Kubernetes API calls.
    You can probably derive the plugin’s functionality from its name. It defines a
    policy for all defined container images in a Pod. To compare container images
    with the defined policy, the plugin calls off to a service external to Kubernetes
    via HTTPS, a webhook. The external service then makes the decision on how to validate
    the data. In the context of the admission controller plugin, the external service
    is also referred to as *backend*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[ImagePolicyWebhook](https://oreil.ly/JxmUu) 准入控制器插件是我们可以配置用于拦截 Kubernetes
    API 调用的插件之一。 您可以从其名称推断出插件的功能。 它为 Pod 中定义的所有容器镜像定义策略。 为了与定义的策略比较容器镜像，插件通过 HTTPS
    调用到一个服务外部于 Kubernetes 的 webhook。 外部服务然后决定如何验证数据。 在准入控制器插件的上下文中，外部服务也被称为*后端*。'
- en: Implementing the Backend Application
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施后端应用
- en: 'The backend application can be implemented with a programming language of your
    choice. There are only three requirements it must fulfill:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 后端应用可以使用您选择的编程语言实现。 它必须满足以下三个要求：
- en: It’s a web application that can handle HTTPS requests.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个可以处理 HTTPS 请求的 Web 应用程序。
- en: It can accept and parse JSON request payloads.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以接受和解析 JSON 请求有效载荷。
- en: It can send a JSON response payload.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以发送一个 JSON 响应有效载荷。
- en: Implementing the backend application is not part of the CKS exam, but you can
    find a sample Go-based implementation in the [GitHub repository](https://oreil.ly/OF4fF)
    of this book. Be aware that the code is not considered to be production-ready.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实施后端应用不是 CKS 考试的一部分，但您可以在本书的[GitHub 仓库](https://oreil.ly/OF4fF)中找到一个基于 Go 的示例实现。
    请注意，该代码不被视为生产就绪。
- en: The following commands demonstrate the runtime behavior of the application accessible
    at `https://localhost:8080/validate`. You can find an example request and response
    JSON body in the [Kubernetes documentation](https://oreil.ly/8GaQe).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令演示了应用程序在`https://localhost:8080/validate`上的运行时行为。 您可以在[Kubernetes 文档](https://oreil.ly/8GaQe)中找到示例请求和响应
    JSON 主体。
- en: 'The following `curl` command calls the validation logic for the container image
    `nginx:1.19.0`. As you can see from the JSON response, the image is denied:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `curl` 命令调用验证逻辑以验证容器镜像 `nginx:1.19.0`。 如 JSON 响应所示，镜像被拒绝：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following `curl` command calls the validation logic for the container image
    `gcr.io/nginx:1.19.0`. As you can see from the JSON response, the image is allowed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `curl` 命令调用验证逻辑以验证容器镜像 `gcr.io/nginx:1.19.0`。 如 JSON 响应所示，镜像被允许：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Configuring the ImagePolicyWebhook Admission Controller Plugin
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 ImagePolicyWebhook 准入控制器插件
- en: For the exam, you are expected to understand how to “wire” the ImagePolicyWebhook
    admission controller plugin. This section will walk you through the process. First,
    you’ll need to create a configuration file for the admission controller so it
    knows what plugins to use and how it should behave at runtime. Create the file
    `/etc/kubernetes/admission-control/image-policy-webhook-admission-config.yaml`
    and populate it with the content shown in [Example 6-9](#admission-controller-configuration-file).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考试中，您需要理解如何“连接”ImagePolicyWebhook准入控制器插件。 本节将指导您完成此过程。 首先，您需要为准入控制器创建一个配置文件，以便它知道要使用哪些插件以及运行时应如何行为。
    创建文件`/etc/kubernetes/admission-control/image-policy-webhook-admission-config.yaml`并填入[示例
    6-9](#admission-controller-configuration-file)中显示的内容。
- en: Example 6-9\. The admission controller configuration file
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9. 准入控制器配置文件
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO3-1)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_supply_chain_security_CO3-1)'
- en: Provides the configuration for the ImagePolicyWebhook plugin.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了 ImagePolicyWebhook 插件的配置。
- en: '[![2](assets/2.png)](#co_supply_chain_security_CO3-2)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_supply_chain_security_CO3-2)'
- en: Points to the configuration file used to configure the backend.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 指向用于配置后端的配置文件。
- en: '[![3](assets/3.png)](#co_supply_chain_security_CO3-3)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_supply_chain_security_CO3-3)'
- en: Denies an API request if the backend cannot be reached. The default is true
    but setting it to false is far more sensible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法访问后端，则拒绝 API 请求。 默认值为 true，但将其设置为 false 更为明智。
- en: Next, create the file referenced by the `plugins[].configuration.imagePolicy.kubeConfigFile`
    attribute. The contents of the file point to the HTTPS URL of the external service.
    It also defines the client certificate and key file, as well as the CA file on
    disk. [Example 6-10](#image-policy-configuration-file) shows the contents of the
    configuration file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建由 `plugins[].configuration.imagePolicy.kubeConfigFile` 属性引用的文件。该文件的内容指向外部服务的
    HTTPS URL。它还定义了磁盘上的客户端证书和密钥文件，以及 CA 文件。[示例 6-10](#image-policy-configuration-file)
    显示了配置文件的内容。
- en: Example 6-10\. The image policy configuration file
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 镜像策略配置文件
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO4-1)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_supply_chain_security_CO4-1)'
- en: The URL to the backend service. Must use the HTTPS protocol.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 后端服务的 URL。必须使用 HTTPS 协议。
- en: Enable the ImagePolicyWebhook admission controller plugin for the API server
    and point the admission controller to the configuration file. To achieve this,
    edit the configuration file of the API server, usually found at `/etc/kubernetes/manifests/kube-apiserver.yaml`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 API 服务器的 ImagePolicyWebhook 准入控制器插件，并将准入控制器指向配置文件。为实现此目的，请编辑 API 服务器的配置文件，通常位于
    `/etc/kubernetes/manifests/kube-apiserver.yaml`。
- en: Find the command line option `--enable-admission-plugins` and append the value
    `ImagePolicyWebhook` to the existing list of plugins, separated by a comma. Provide
    the command line option `--admission-control-config-file` if it doesn’t exist
    yet, and set the value to `/etc/kubernetes/admission-control/image-policy-webhook-admission-configuration.yaml`.
    Given that the configuration file lives in a new directory, you will have to define
    it as a Volume and mount it to the container. [Example 6-11](#api-server-configuration-file)
    shows the relevant options for the API server container.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 查找命令行选项 `--enable-admission-plugins`，并在现有插件列表中追加值 `ImagePolicyWebhook`，以逗号分隔。如果尚不存在，请提供命令行选项
    `--admission-control-config-file`，并将值设置为 `/etc/kubernetes/admission-control/image-policy-webhook-admission-configuration.yaml`。由于配置文件位于新目录中，您将需要将其定义为
    Volume 并将其挂载到容器中。[示例 6-11](#api-server-configuration-file) 显示了 API 服务器容器的相关选项。
- en: Example 6-11\. The API server configuration file
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. API 服务器配置文件
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Pod running the API server should automatically restart. This process may
    take a couple of minutes. Restart the kubelet service with the command `sudo systemctl
    restart kubelet` should the API server not come up by itself. Once fully restarted,
    you should be able to query for it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 API 服务器的 Pod 应自动重启。此过程可能需要几分钟时间。如果 API 服务器未能自行启动，请使用命令 `sudo systemctl restart
    kubelet` 重新启动 kubelet 服务。一旦完全重启，您应该能够查询它：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Any API call that requests the creation of a Pod will now be routed to the backend.
    Based on the validation result, the creation of the object will be allowed or
    denied.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何请求创建 Pod 的 API 调用将被路由到后端。根据验证结果，将允许或拒绝对象的创建。
- en: Static Analysis of Workload
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载的静态分析
- en: Throughout this book, we talk about best practices for Dockerfiles and Kubernetes
    manifests. You can inspect those files manually, find undesired configurations,
    and fix them by hand. This approach requires a lot of intricate knowledge and
    is very tedious and error-prone. It is much more convenient and efficient to analyze
    workload files in an automated fashion with proper tooling. The list of commercial
    and open source tooling for static analysis is long. In this section, we are going
    to present the functionality of two options, Haskell Dockerfile Linter and Kubesec.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们讨论了 Dockerfile 和 Kubernetes 清单的最佳实践。您可以手动检查这些文件，查找不良配置，并手动修复它们。这种方法需要大量复杂的知识，并且非常繁琐且易出错。通过适当的工具以自动化方式分析工作负载文件，会更加方便和高效。商业和开源静态分析工具的列表很长。在本节中，我们将介绍两个选项的功能，即
    Haskell Dockerfile Linter 和 Kubesec。
- en: On an enterprise level, where you have to process hundreds or even thousands
    of workload files, you’d do so with the help of a continuous delivery pipeline,
    as shown in [Figure 6-6](#continuous-delivery-kubernetes-static-analysis).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业级别上，当您需要处理数百甚至数千个工作负载文件时，您可以借助持续交付管道的帮助来完成，如 [图 6-6](#continuous-delivery-kubernetes-static-analysis)
    所示。
- en: '![ckss 0606](assets/ckss_0606.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![ckss 0606](assets/ckss_0606.png)'
- en: Figure 6-6\. An exemplary continuous delivery pipeline for Kubernetes
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. Kubernetes 的示例持续交付管道
- en: Relevant static analysis tools can be invoked as a quality gate at an early
    stage of the pipeline even before a container image is built, pushed to a registry,
    or deployed to a Kubernetes cluster. For a deep dive on the principles and practices
    of continuous delivery, see the excellent book [*Continuous Delivery*](https://oreil.ly/8CR5M)
    by Jez Humble and David Farley (Addison-Wesley Professional).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的静态分析工具可以作为管道早期阶段的质量门控调用，甚至在构建容器镜像、推送到注册表或部署到 Kubernetes 集群之前。有关持续交付原则和实践的深入了解，请参阅
    Jez Humble 和 David Farley 的优秀著作 [*Continuous Delivery*](https://oreil.ly/8CR5M)（Addison-Wesley
    Professional）。
- en: Using Hadolint for Analyzing Dockerfiles
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hadolint 分析 Dockerfile
- en: '[Haskell Dockerfile Linter](https://oreil.ly/C9bvu), also called hadolint in
    short, is a linter for Dockerfiles. The tool inspects a Dockerfile based on [best
    practices](https://oreil.ly/Fwksr) listed on the Docker documentation page. [Example 6-12](#unoptimized-dockerfile)
    shows an unoptimized Dockerfile for building a container image running a Go-based
    application.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[Haskell Dockerfile Linter](https://oreil.ly/C9bvu)，也称为 hadolint，是 Dockerfile
    的一个代码检查工具。该工具根据 Docker 文档页面上列出的 [最佳实践](https://oreil.ly/Fwksr) 检查 Dockerfile。[示例 6-12](#unoptimized-dockerfile)
    展示了用于构建运行基于 Go 的应用程序的容器镜像的未优化 Dockerfile。'
- en: Example 6-12\. An unoptimized Dockerfile
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. 一个未优化的 Dockerfile
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Haskell Dockerfile Linter supports a mode of operation that lets you point
    the `hadolint` executable to a Dockerfile on disk. You can see the command execution
    that follows, including the discovered warning messages produced by the analysis:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell Dockerfile Linter 支持一种操作模式，允许您将 `hadolint` 可执行文件指向磁盘上的 Dockerfile。您可以看到随后的命令执行，包括分析产生的发现的警告消息：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The output of the command suggests that you should assign a tag to the base
    image. The existing Dockerfile will pull the `latest` tag, which will resolve
    to the newest Go container image. This practice can result in an incompatibility
    between the Go runtime version and the application code. Defining a working directory
    for copying resources helps with keeping operating system-specific directories
    and files separate from application-specific directories and files. [Example 6-13](#optimized-dockerfile)
    fixes the warning messages found by the Haskell Dockerfile Linter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出建议您为基础镜像分配一个标签。现有的 Dockerfile 将拉取 `latest` 标签，该标签将解析为最新的 Go 容器镜像。这种做法可能导致
    Go 运行时版本与应用程序代码不兼容。定义用于复制资源的工作目录有助于将操作系统特定的目录和文件与应用程序特定的目录和文件分开。[示例 6-13](#optimized-dockerfile)
    修复了 Haskell Dockerfile Linter 发现的警告消息。
- en: Example 6-13\. An optimized Dockerfile
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. 一个优化后的 Dockerfile
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another execution against the modified Dockerfile leads to a successful exit
    code, and no additional warning messages will be rendered:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对修改后的 Dockerfile 的另一次执行将导致成功的退出代码，并且不会呈现任何额外的警告消息：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Dockerfile now follows best practices, as perceived by hadolint.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 现在遵循 hadolint 感知到的最佳实践。
- en: Using Kubesec for Analyzing Kubernetes Manifests
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kubesec 分析 Kubernetes 清单
- en: '[Kubesec](https://kubesec.io) is a tool for analyzing Kubernetes manifests.
    It can be executed as a binary, Docker container, admission controller plugin,
    and even as a plugin for `kubectl`. To demonstrate its use, we’ll set up a YAML
    manifest file `pod-initial-kubesec-test.yaml`, shown in [Example 6-14](#pod-yaml-manifest-initial-security-settings)
    as a starting point.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubesec](https://kubesec.io) 是分析 Kubernetes 清单的工具。它可以作为二进制文件、Docker 容器、准入控制器插件甚至是
    `kubectl` 插件执行。为了演示其用法，我们将设置一个 YAML 清单文件 `pod-initial-kubesec-test.yaml`，如 [示例 6-14](#pod-yaml-manifest-initial-security-settings)
    所示，作为起点。'
- en: Example 6-14\. A Pod YAML manifest using initial security settings
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14\. 使用初始安全设置的 Pod YAML 清单
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Upon inspecting the Pod configuration, you may already have some suggestions
    on what could be improved based on the content of the previous chapters. Let’s
    see what Kubesec is going to recommend.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查 Pod 配置时，您可能已经根据前几章的内容有一些改进建议。让我们看看 Kubesec 将会推荐什么。
- en: 'The simplest way to invoke Kubesec is to run the logic in a container with
    the help of Docker. The following command feeds the contents of the YAML manifest
    to the standard input stream. The result, formatted in JSON, renders a score,
    provides a human-readable message of the outcome, and advises on changes to be
    made:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Docker 容器中运行逻辑的最简单方法来调用 Kubesec。以下命令将 YAML 清单的内容传送到标准输入流中。格式化为 JSON 的结果呈现评分，并提供结果的人类可读消息，并建议进行更改：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A touched-up version of the original YAML manifest can be found in [Example 6-15](#pod-yaml-manifest-improved-security-settings).
    Here, we incorporated some of the recommended changes proposed by Kubesec.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-15](#pod-yaml-manifest-improved-security-settings)中可以找到原始YAML清单的修订版本。在这里，我们整合了Kubesec建议的一些推荐更改。'
- en: Example 6-15\. A Pod YAML manifest using improved security settings
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-15\. 使用改进的安全设置的Pod YAML清单
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Executing the same Docker command against the changed Pod YAML manifest will
    render an improved score and reduce the number of advised messages:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对改变的Pod YAML清单执行相同的Docker命令将会呈现出一个改进的分数，并减少建议消息的数量：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Scanning Images for Known Vulnerabilities
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描已知漏洞的镜像
- en: One of the top sources for logging and discovering security vulnerabilities
    is [CVE Details](https://oreil.ly/DDlVa). The page lists and ranks known vulnerabilities
    (CVEs) by score. Automated tooling can identify the software components embedded
    in a container image, compare those with the central vulnerabilities database,
    and flag issues by their severity.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 记录和发现安全漏洞的首要来源之一是[CVE详情](https://oreil.ly/DDlVa)。该页面列出并按分数排名已知的漏洞（CVE）。自动化工具可以识别嵌入容器镜像中的软件组件，将其与中央漏洞数据库进行比较，并通过其严重性标记问题。
- en: 'One of the open source tools with this capability explicitly mentioned in the
    CKS curriculum is [Trivy](https://oreil.ly/hqPHH). Trivy can run in different
    modes of operation: as a command line tool, in a container, as a GitHub Action
    configurable in a continuous integration workflow, as a plugin for the IDE VSCode,
    and as a Kubernetes operator. For an overview of the available installation options
    and procedures, see the [Trivy documentation](https://oreil.ly/qB_c8). During
    the exam, you are not expected to install the tool. It will already be preconfigured
    for you. All you need to understand is how to run it and how to interpret and
    fix the found vulnerabilities.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在CKS课程中明确提到的具备此能力的开源工具之一是[Trivy](https://oreil.ly/hqPHH)。Trivy可以以不同的操作模式运行：作为命令行工具、在容器中、作为GitHub
    Action配置在持续集成工作流中、作为IDE VSCode的插件以及作为Kubernetes操作者。关于可用安装选项和流程的概述，请参阅[Trivy文档](https://oreil.ly/qB_c8)。在考试期间，您无需安装此工具，它已经预先配置好。您只需要理解如何运行它、如何解释和修复找到的漏洞即可。
- en: 'Say you installed the command line implementation of Trivy. You can check the
    version of Trivy with the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已安装了Trivy的命令行实现。您可以使用以下命令检查Trivy的版本：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see in [Figure 6-7](#trivy-execution), Trivy indicates the timestamp
    when a copy of known vulnerabilities has been downloaded from the central database.
    Trivy can scan container images in various forms. The subcommand `image` simply
    expects you to spell out the image name and tag, in this case `python:3.4-alpine`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[图 6-7](#trivy-execution)中所见，Trivy指示了从中央数据库下载已知漏洞副本的时间戳。Trivy可以以各种形式扫描容器镜像。子命令`image`期望您简单地拼写出镜像名称和标签，在本例中为`python:3.4-alpine`。
- en: '![ckss 0607](assets/ckss_0607.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![ckss 0607](assets/ckss_0607.png)'
- en: Figure 6-7\. Reporting generated by scanning a container image with Trivy
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-7\. 使用Trivy扫描容器镜像生成的报告
- en: The most important information in the output consists of the library that contains
    a specific vulnerability, its severity, and the minimum version to use that fixes
    the issue. Any found vulnerabilities with high or critical severity should be
    considered for a fix. If you do not have any control over the container image
    yourself, you can try to upgrade to a newer version.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中最重要的信息包括包含特定漏洞的库、其严重性以及修复问题所需的最低版本。应考虑修复任何具有高或关键严重性的发现漏洞。如果您无法控制容器镜像本身，则可以尝试升级到更新版本。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Kubernetes primary objective is to run applications in containers in a scalable
    and secure fashion. In this chapter, we looked at the process, best practices,
    and tooling that help to ensure that a container image is produced that is small
    in size and that ships with as few known security vulnerabilities as possible.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的主要目标是以可伸缩和安全的方式运行应用程序容器。在本章中，我们探讨了确保生成的容器镜像尺寸小且具有尽可能少的已知安全漏洞的过程、最佳实践和工具。
- en: We reviewed some of the most efficient techniques to reduce the footprint of
    a container image to a minimum. Start by picking a small base image to start with.
    You can even go to the extreme and not provide a shell at all for additional gains
    in size reduction. If you are using Docker, you can leverage the multi-stage approach
    that lets you build the application inside of the container without bundling the
    compiler, runtime, and build tools necessary to achieve the goal.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了将容器映像占用空间减少到最小的一些最有效技术。首先选择一个小的基础映像来开始。甚至可以走极端，完全不提供 shell 以获得额外的大小减少。如果您正在使用
    Docker，则可以利用多阶段方法，在容器内构建应用程序，而无需捆绑编译器、运行时和构建工具以实现目标。
- en: When consuming the container image in a Pod, make sure to only pull the container
    image from a trusted registry. It’s advisable to set up an in-house container
    registry to serve up container images, so that reaching out to public, internet-accessible
    registries becomes obsolete, to eliminate potential security risks. You can enforce
    the usage of a list of trusted container registries with the help of OPA Gatekeeper.
    Another measure of security can be enforced by using the SHA256 hash of a container
    image to validate its expected contents.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 中消费容器映像时，请确保仅从受信任的注册表中拉取容器映像。建议设置内部容器注册表以提供容器映像，从而消除对公共、可通过互联网访问的注册表的依赖，以消除潜在的安全风险。您可以通过
    OPA Gatekeeper 帮助执行受信任容器注册表列表的使用。另一种安全措施是使用容器映像的 SHA256 哈希来验证其预期内容。
- en: The process of building and scanning a container image can be incorporated into
    a CI/CD pipeline. Third-party tools can parse and analyze the resource files of
    your deployable artifacts even before you build them. We looked at Haskell Dockerfile
    Linter for Dockerfiles and Kubesec for Kubernetes manifests. The other use case
    that needs to be covered on security aspects is consuming an existing container
    image built by an entity external to you as a developer, or your company. Before
    running a container image in a Kubernetes Pod, make sure to scan the contents
    for vulnerabilities. Trivy is one of those tools that can identify and report
    vulnerabilities in a container image to give you an idea of the security risks
    you are exposing yourself to in case you are planning to operate it in a container.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和扫描容器映像的过程可以整合到 CI/CD 流水线中。第三方工具可以在构建之前解析和分析可部署工件的资源文件。我们查看了用于 Dockerfile
    的 Haskell Dockerfile Linter 和用于 Kubernetes 清单的 Kubesec。另一个需要在安全方面涵盖的用例是作为开发人员或您公司外部实体构建的现有容器映像的消费。在运行
    Kubernetes Pod 中的容器映像之前，请确保扫描其内容以查找漏洞。Trivy 是可以识别并报告容器映像中漏洞的工具之一，以帮助您了解在计划在容器中操作时可能面临的安全风险。
- en: Exam Essentials
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考试要点
- en: Become familiar with techniques that help with reducing the container image
    footprint.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉有助于减少容器映像占用空间的技术。
- en: In this section, we described some techniques for reducing the size of a container
    image when building it. I would suggest you read the best practices mentioned
    on the Docker web page and try to apply them to sample container images. Compare
    the size of the produced container image before and after applying a technique.
    You can try to challenge yourself by reducing a container image to the smallest
    size possible while at the same time avoiding the loss of crucial functionality.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了在构建时减小容器映像大小的一些技术。我建议您阅读 Docker 网页上提到的最佳实践，并尝试将它们应用于样本容器映像。比较应用技术前后生成的容器映像的大小。您可以尝试通过避免丢失关键功能的同时将容器映像减小到最小尺寸，挑战自己。
- en: Walk through the process of governing where a container image can be resolved
    from.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 行走通过治理过程，其中容器映像可以解析。
- en: OPA Gatekeeper offers a way to define the registries users are allowed to resolve
    container images from. Set up the objects for the constraint template and constraint,
    and see if the rules apply properly for a Pod that defines a main application
    container, an init container, and an ephemeral container. To broaden your exposure,
    also look at other products in the Kubernetes spaces that provide similar functionality.
    One of those products is [Kyverno](https://kyverno.io).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: OPA Gatekeeper 提供了定义允许用户解析容器映像的注册表的方法。设置约束模板和约束对象，并查看规则是否适用于定义主应用程序容器、初始化容器和临时容器的
    Pod。为了扩展您的曝光度，还可以查看 Kubernetes 领域中提供类似功能的其他产品。其中一个产品是 [Kyverno](https://kyverno.io)。
- en: Sign a container image and verify it using the hash.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个容器镜像进行签名，并使用哈希值验证。
- en: After building a container image, make sure to also create a digest for it.
    Publish the container image, as well as the digest, to a registry. Practice how
    to use the digest in a Pod definition and verify the behavior of Kubernetes upon
    pulling the container image.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器镜像后，请确保也为其创建摘要。将容器镜像及其摘要发布到注册表。练习如何在Pod定义中使用摘要，并验证Kubernetes在拉取容器镜像时的行为。
- en: Understand how to configure the ImagePolicyWebhook admission controller plugin.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何配置ImagePolicyWebhook准入控制器插件。
- en: You are not expected to write a backend for an ImagePolicyWebhook. That’s out
    of scope for the exam and requires knowledge of a programming language. You do
    need to understand how to enable the plugin in the API server configuration, though.
    I would suggest you practice the workflow even if you don’t have a running backend
    application available.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要为ImagePolicyWebhook编写后端。这超出了考试范围，并需要掌握一门编程语言。但你确实需要了解如何在API服务器配置中启用该插件。即使没有运行的后端应用程序，我建议你练习这个工作流程。
- en: Know how to fix warnings produced by static analysis tools.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何修复静态分析工具产生的警告。
- en: The CKS curriculum doesn’t prescribe a specific tool for analyzing Dockerfiles
    and Kubernetes manifests. During the exam, you may be asked to run a specific
    command that will produce a list of error and/or warning messages. Understand
    how to interpret the messages, and how to fix them in the relevant resource files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: CKS课程不指定用于分析Dockerfile和Kubernetes清单的特定工具。在考试期间，您可能会被要求运行一个特定的命令，该命令将生成一系列错误和/或警告消息。理解如何解释这些消息，并在相关资源文件中修复它们是很重要的。
- en: Practice the use of Trivy to identify and fix security vulnerabilities.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 练习使用Trivy来识别和修复安全漏洞。
- en: The FAQ of the CKS lists the documentation page for Trivy. Therefore, it’s fair
    to assume that Trivy may come up in one of the questions. You will need to understand
    the different ways to invoke Trivy to scan a container image. The produced report
    will give a you clear indication on what needs to be fixed and the severity of
    the found vulnerability. Given that you can’t modify the container image easily,
    you will likely be asked to flag Pods that run container images with known vulnerabilities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: CKS的常见问题解答中列出了Trivy的文档页面。因此，可以合理地假设Trivy可能会在其中的一个问题中出现。您需要了解调用Trivy扫描容器镜像的不同方式。生成的报告将清楚地指示需要修复的内容及找到的漏洞的严重程度。考虑到您不能轻易修改容器镜像，您可能会被要求标记运行具有已知漏洞的容器镜像的Pod。
- en: Sample Exercises
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例练习
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的解决方案可以在[附录](app01.xhtml#appendix-a)中找到。
- en: Have a look at the following Dockerfile. Can you identify possibilities for
    reducing the footprint of the produced container image?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下以下的Dockerfile。你能找出减少生成的容器镜像占用空间的可能性吗？
- en: '[PRE35]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Apply Dockerfile best practices to optimize the container image footprint. Run
    the `docker build` command before and after making optimizations. The resulting
    size of the container image should be smaller but the application should still
    be functioning.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将Dockerfile最佳实践应用于优化容器镜像占用空间。在进行优化之前和之后运行`docker build`命令。容器镜像的最终大小应更小，但应用程序仍应正常运行。
- en: Install Kyverno in your Kubernetes cluster. You can find installation instructions
    in the [documentation](https://oreil.ly/yxlLe).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Kubernetes集群中安装Kyverno。您可以在[文档](https://oreil.ly/yxlLe)中找到安装说明。
- en: Apply the “Restrict Image Registries” policy described on the [documentation
    page](https://oreil.ly/Kdj1k). The only allowed registry should be `gcr.io`. Usage
    of any other registry should be denied.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用描述在[文档页面](https://oreil.ly/Kdj1k)上的“限制镜像注册表”策略。唯一允许的注册表应为`gcr.io`。禁止使用任何其他注册表。
- en: Create a Pod that defines the container image `gcr.io/google-containers/busybox:1.27.2`.
    Creation of the Pod should fail. Create another Pod using the container image
    `busybox:1.27.2`. Kyverno should allow the Pod to be created.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个定义了容器镜像`gcr.io/google-containers/busybox:1.27.2`的Pod。创建Pod应该失败。使用容器镜像`busybox:1.27.2`创建另一个Pod。Kyverno应该允许创建该Pod。
- en: Define a Pod using the container image `nginx:1.23.3-alpine` in the YAML manifest
    `pod-validate-image.yaml`. Retrieve the digest of the container image from Docker
    Hub. Validate the container image contents using the SHA256 hash. Create the Pod.
    Kubernetes should be able to successfully pull the container image.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 YAML 清单 `pod-validate-image.yaml` 中使用容器镜像 `nginx:1.23.3-alpine` 定义一个 Pod。从
    Docker Hub 检索容器镜像的摘要。使用 SHA256 哈希验证容器镜像内容。创建 Pod。Kubernetes 应能够成功拉取容器镜像。
- en: 'Use Kubesec to analyze the following contents of the YAML manifest file `pod.yaml`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Kubesec 分析 YAML 清单文件 `pod.yaml` 中的以下内容：
- en: '[PRE36]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inspect the suggestions generated by Kubesec. Ignore the suggestions on seccomp
    and AppArmor. Fix the root cause of all messages so that another execution of
    the tool will not report any additional suggestions.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查 Kubesec 生成的建议。忽略关于 seccomp 和 AppArmor 的建议。修复所有消息的根本原因，以确保再次执行工具时不会报告任何额外的建议。
- en: Navigate to the directory *app-a/ch06/trivy* of the checked-out GitHub repository
    [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Execute the command `kubectl
    apply -f setup.yaml`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到已检出的 GitHub 仓库 [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ) 的目录 *app-a/ch06/trivy*。执行命令
    `kubectl apply -f setup.yaml`。
- en: The command creates three different Pods in the namespace `r61`. From the command
    line, execute Trivy against the container images used by the Pods. Delete all
    Pods that have “CRITICAL” vulnerabilities. Which of the Pods are still running?
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令在命名空间 `r61` 中创建了三个不同的 Pod。从命令行执行 Trivy 对这些 Pod 使用的容器镜像进行检查。删除所有具有“CRITICAL”漏洞的
    Pod。哪些 Pod 仍在运行？
