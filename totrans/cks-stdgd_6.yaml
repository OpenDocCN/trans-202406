- en: Chapter 6\. Supply Chain Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier chapters primarily focused on securing the Kubernetes cluster and its
    components, the OS infrastructure used to run cluster nodes, and the operational
    aspects for running workload on a cluster node with existing container images.
    This chapter takes a step back and drills into the process, best practices, and
    tooling for designing, building, and optimizing container images.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you do not want to create your own container image but instead consume
    an existing one produced by a different team or company. Scanning container images
    for known vulnerabilities in a manual or automated fashion should be part of your
    vetting process before using them to run your workload. We’ll talk through some
    options relevant to the CKS exam used to identify, analyze, and mitigate security
    risks for pre-built container images.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing base image footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing the supply chain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static analysis of user workload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning images for known vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing the Base Image Footprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process for building a container image looks straightforward on the surface
    level; however, the devil is often in the details. It may not be obvious to someone
    new to the topic to refrain from building a container image that is unnecessarily
    too large in size, riddled with vulnerabilities, and not optimized for container
    layer caching. We’ll address all of those aspects in the course of this chapter
    with the help of the container engine Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Exploits Container Vulnerabilities'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first decisions you have to make when defining a Dockerfile is the
    selection of a base image. The base image provides the operating system and additional
    dependencies, and it may expose shell access.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the base images you can choose from on a public registry like Docker
    Hub are large in size and will likely contain functionality you don’t necessarily
    need to run your application inside of it. The operating system itself, as well
    as any dependencies available with the base image, can expose vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-1](#container-image-vulnerabilities-attacker), the attacker was
    able to figure out details about the container by gaining access to it. Those
    vulnerabilities can now be used as a launching pad for more advanced attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0601](assets/ckss_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. An attacker exploits container image vulnerabilities
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is recommended to use a base image with a minimal set of functionality and
    dependencies. The next couple of sections will explain the methods for creating
    a more optimized base image that’s faster to build, quicker to download from a
    container registry, and that will ultimately lead to a smaller attack surface
    simply by reducing the bloat. The next sections will touch on the most important
    techniques. You can find a more detailed list of best practices for writing Dockerfiles
    in the [Docker documentation](https://oreil.ly/43Diy).
  prefs: []
  type: TYPE_NORMAL
- en: Picking a Base Image Small in Size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some container images can have a size of a gigabyte or even more. Do you really
    need all the functionality bundled with such a container image? Unlikely. Thankfully,
    many container producers upload a wide range of variations of their container
    images for the same release. One of those variations is an `alpine` image, a small,
    lightweight, and less vulnerable Linux distribution. As you can see in the following
    output, the downloaded `alpine` container image with the tag `3.17.0` only has
    a size of 7.05MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `alpine` container image comes with an `sh` shell you can use to troubleshoot
    the process running inside of the container. You can use the following command
    to open an interactive shell in a new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While runtime troubleshooting functionality can be useful, offering a shell
    as part of a container image increases the size of it and potentially opens the
    door for attackers. Additionally, the more software there is inside of a container
    image, the more vulnerabilities it will have.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can further reduce the container image size and the attack surface by using
    a [distroless image](https://oreil.ly/J6Vra) offered by Google. The following
    command downloads the latest tag of the container image `gcr.io/distroless/static-debian11`
    and renders its details. The size of the container image is only 2.34MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A distroless container image does not ship with any shell, which you can observe
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes offers the concept of ephemeral containers for troubleshooting distroless
    containers. Those containers are meant to be disposable and can be deployed for
    troubleshooting minimal containers that would usually not allow opening a shell.
    Discussing ephemeral containers is out of scope of this book, but you can find
    more information about them in the [Kubernetes documentation](https://oreil.ly/IRjP3).
  prefs: []
  type: TYPE_NORMAL
- en: Using a Multi-Stage Approach for Building Container Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a developer, you can decide to build the application code as part of the
    instructions in a Dockerfile. This process may include compiling the code and
    building a binary that should become the entry point of the container image. Having
    all the necessarily tools and dependencies available to implement the process
    will automatically blow up the size of the container image, plus you won’t need
    those dependencies at runtime anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a [multi-stage build in Docker](https://oreil.ly/znQc3) is that
    you separate the build stage from the runtime stage. As a result, all dependencies
    needed in the build stage will be discarded after the process has been performed
    and therefore do not end up in the final container image. This approach leads
    to a much smaller container image size by removing all the unnecessary cruft.
  prefs: []
  type: TYPE_NORMAL
- en: While we won’t go into the details of crafting and fully understanding multi-stage
    Dockerfile, I want to show you the differences on a high level. We’ll start by
    showing you a Dockerfile that builds and tests a simple program using the programming
    language Go, as shown in [Example 6-1](#dockerfile-single-stage). In essence,
    we are using a [base image](https://oreil.ly/nwLtT) that includes Go 1.19.4\.
    The Go runtime provides the `go` executes, which we’ll invoke to execute the tests
    and build the binary of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1\. Building and testing a Go program using a Go base image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses a Go base image
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_supply_chain_security_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Executes the tests against the application code
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_supply_chain_security_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Builds the binary of the Go application
  prefs: []
  type: TYPE_NORMAL
- en: 'You can produce the image using the `docker build` command, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of the result container image is pretty big, 348MB, and there’s a
    good reason for it. It includes the Go runtime, even though we don’t actually
    need it anymore when starting the container. The `go build` command produced the
    binary that we can run as the container’s entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we’ll have a look at the multi-stage approach. In a multi-stage Dockerfile,
    you define at least two stages. In [Example 6-2](#dockerfile-multi-stage), we
    specify a stage aliased with `build` to run the tests and build the binary, similarly
    to what we’ve done earlier. A second stage copies the binary produced by the stage
    `build` into a dedicated directory; however, it uses the `alpine` base image to
    run it. When running the `docker build` command, the stage `build` will not be
    included in the final container image anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-2\. Building and testing a Go program as part of a multi-stage Dockerfile
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses a Go base image for building and testing the program in the stage named
    `build`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_supply_chain_security_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Executes the tests against the application code.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_supply_chain_security_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Builds the binary of the Go application.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_supply_chain_security_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses a much smaller base image for running the application in a container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_supply_chain_security_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Copies the application binary produced in the `build` stage and uses it as the
    command to run when the container is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting container image size is significantly smaller when using the
    `alpine` base image, only 12MB. You can verify the outcome by running the `docker
    build` command again and inspecting the size of the container image by listing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Not only did we reduce the size, we also reduced the attack surface by including
    fewer dependencies. You can further reduce the size of the container image by
    incorporating a distroless base image instead of the `alpine` base image.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the Number of Layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Dockerfile consists of an ordered list of instructions. Only some instructions
    create a read-only layer in the resulting container image. Those instructions
    are `FROM`, `COPY`, `RUN`, and `CMD`. All other instructions will not create a
    layer as they create temporary intermediate images. The more layers you add to
    the container image, the slower will be the build execution time and/or the bigger
    will be the size of the container image. Therefore, you need to be cautious about
    the instructions used in your Dockerfile to minimize the footprint of the container
    image.
  prefs: []
  type: TYPE_NORMAL
- en: It’s common practice to execute multiple commands in a row. You may define those
    commands using a list of `RUN` instructions on individual lines, as shown in [Example 6-3](#dockerfile-multiple-run-instructions).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-3\. A Dockerfile specifying multiple `RUN` instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each `RUN` instruction will create a layer, potentially adding to the size of
    the container image. It’s more efficient to string them together with `&&` to
    ensure that only a single layer will be produced. [Example 6-4](#dockerfile-combined-run-instructions)
    shows an example of this optimization technique.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-4\. A Dockerfile specifying multiple `RUN` instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using Container Image Optimization Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s easy to forget about the optimization practices mentioned previously.
    The open source community developed a couple of tools that can help with inspecting
    a produced container image. Their functionalities provide useful tips for pairing
    down on unnecessary layers, files, and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: DockerSlim
  prefs: []
  type: TYPE_NORMAL
- en: DockerSlim will optimize and secure your container image by analyzing your application
    and its dependencies. You can find more information in the tool’s [GitHub repository](https://oreil.ly/ZbeZl).
  prefs: []
  type: TYPE_NORMAL
- en: Dive
  prefs: []
  type: TYPE_NORMAL
- en: Dive is a tool for exploring the layers baked into a container image. It makes
    it easy to identify unnecessary layers, which you can further optimize on. The
    code and documentation for Dive are available in a [GitHub repository](https://oreil.ly/UBqqj).
  prefs: []
  type: TYPE_NORMAL
- en: This is only the short list of container image optimization tools. In [“Static
    Analysis of Workload”](#static-analysis-workload), we’ll have a look at other
    tools that focus on the static analysis of Dockerfiles and Kubernetes manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the Supply Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A supply chain automates the process of producing a container image and operating
    it in a runtime environment, in this case Kubernetes. We already touched on a
    couple of tools that can be integrated into the supply chain to support the aspect
    of container image optimization. In this section, we’ll expand on practices that
    target security aspects. Refer to the book [*Container Security*](https://learning.oreilly.com/library/view/container-security/9781492056690/)
    by Liz Rice (O’Reilly) to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Signing Container Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can sign a container image before pushing it to a container registry. Signing
    can be achieved with the `docker trust sign` command, which adds a signature to
    the container image, the so-called image digest. An image digest is derived from
    the contents of the container image and commonly represented in the form of SHA256\.
    When consuming the container image, Kubernetes can compare the image digest with
    the contents of the image to ensure that it hasn’t been tampered with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Injects Malicious Code into a Container Image'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes component that verifies the image digest is the kubelet. If you
    configured the [image pull policy](https://oreil.ly/0wSjy) to `Always`, the kubelet
    will query for the image digest from the container registry even though it may
    have downloaded and verified the container image before.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker can try to modify the contents of an existing container image, inject
    malicious code, and upload it to the container registry with the same tag, as
    shown in [Figure 6-2](#no-image-digest-validation-attacker). The malicious code
    running in the container could then send sensitive information to a third-party
    server accessible by the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0602](assets/ckss_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. An attacker injects malicious code into a container image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Image checksum validation is not automatic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image digest validation is an opt-in functionality in Kubernetes. When defining
    Pods, make sure you spell out the image digest explicitly for all container images.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Container Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, you’re able to append the SHA256 image digest to the specification
    of a container. For example, this can be achieved with the attribute `spec.containers[].image`.
    The image digest is generally available in the container registry. For example,
    [Figure 6-3](#dockerhub-alpine-image-digest) shows the image digest for the container
    image [`alpine:3.17.0` on Docker Hub](https://oreil.ly/ZAV_H). In this example,
    the image digest is `sha256:c0d488a800e4127c334ad20d61d7bc21b4097540327217dfab52262adc02380c`.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0603](assets/ckss_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. The image digest of the `alpine:3.17.0` container image on Docker
    Hub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s see the image digest in action. Instead of using the tag, [Example 6-5](#container-valid-image-digest)
    specifies the container image by appending the image digest.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-5\. A Pod using a valid container image digest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the Pod will work as expected. The image digest will be verified and
    the container transitions into the “Running” status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 6-6](#container-invalid-image-digest) shows the same Pod definition;
    however, the image digest has been changed so that it does not match with the
    contents of the container image.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-6\. A Pod using an invalid container image digest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that Kubernetes can still create the Pod object but it can’t properly
    validate the hash of the container image. This results in the status “ErrImagePull.”
    As you can see from the event log, the container image couldn’t even be pulled
    from the container registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using Public Image Registries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a Pod is created, the container runtime engine will download the declared
    container image from a container registry if it isn’t available locally yet. This
    runtime behavior can be further tweaked using the [image pull policy](https://oreil.ly/ZBMnH).
  prefs: []
  type: TYPE_NORMAL
- en: The prefix in the image name declares the domain name of the registry; e.g.,
    `gcr.io/google-containers/debian-base:v1.0.1` refers to the container image `google-containers/debian-base:v1.0.1`
    in the [Google Cloud container registry](https://oreil.ly/QFxfY), denoted by `gcr.io`.
    The container runtime will try to resolve it from `docker.io`, the [Docker Hub
    container registry](https://hub.docker.com) if you leave off the domain name in
    the container image declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Uploads a Malicious Container Image'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is convenient to resolve container images from public container registries,
    it doesn’t come without risks. Anyone with a login to those container registries
    can upload new images. Consuming container images usually doesn’t even require
    an account.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 6-4](#public-registries-attacker), an attacker can upload
    a container image containing malicious code to a public registry using stolen
    credentials. Any container referencing the container image from that registry
    will automatically run the malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0604](assets/ckss_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. An attacker uploads a malicious container image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On an enterprise level, you need to control which container registries you trust.
    It’s recommended to set up your own container registry within your company’s network,
    which you can fully control and govern. Alternatively, you can set up a private
    container registry in a cloud provider environment, not accessible by anyone else.
  prefs: []
  type: TYPE_NORMAL
- en: One of the prominent binary repository managers you can choose from is [JFrog
    Artifactory](https://oreil.ly/jdF_6). The product fully supports storing, scanning,
    and serving container images. Any consumer of container images should only be
    allowed to pull images from your whitelisted container registry. All other container
    registries should be denied.
  prefs: []
  type: TYPE_NORMAL
- en: Whitelisting Allowed Image Registries with OPA GateKeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to govern container registry usage is with OPA Gatekeeper. We discussed
    the installation process and functionality of OPA Gatekeeper in [“Understanding
    Open Policy Agent (OPA) and Gatekeeper”](ch05.xhtml#opa-gatekeeper). Here, we’ll’
    touch on the constraint template and constraint for allowing trusted container
    registries.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 6-7](#opa-whitelisted-repositories-constraint-template) shows the
    [constraint template](https://oreil.ly/hvgnr) I got directly from the OPA Gatekeeper
    library. As input properties, the constraint template defines an array of strings
    representing the prefixes of container registries. The Rego rules verify not only
    the assigned container images for the attribute `spec.containers[]` but also `spec.initContainers[]`
    and `spec.ephemeralContainers[]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-7\. An OPA Gatekeeper constraint template for enforcing container
    registries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The constraint shown in [Example 6-8](#opa-whitelisted-repositories-constraint)
    is in charge of defining which container registries we want to allow. You’d usually
    go with a domain name of a server hosted in your company’s network. Here, we are
    going to use `gcr.io/` for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-8\. An OPA Gatekeeper constraint assigning Google Cloud registry as
    trusted repository
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create both objects using the `apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constraint, we didn’t specify a namespace that the rules should apply
    to. Therefore, they’ll apply across all namespaces in the cluster. The following
    commands verify that the whitelisting rules work as expected. The following command
    tries to create a Pod using the `nginx` container image from Docker Hub. The creation
    of the Pod is denied with an appropriate error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next command creates a Pod with a container image from the Google Cloud
    container registry. The operation is permitted and the Pod object is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Whitelisting Allowed Image Registries with the ImagePolicyWebhook Admission
    Controller Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to validate the use of allowed image registries is to intercept
    a call to the API server when a Pod is about to be created. This mechanism can
    be achieved by enabling an admission controller plugin. Once configured, the logic
    of an admission controller plugin is automatically invoked when the API server
    receives the request, but after it could authenticate and authorize the caller.
    We already touched on the phases an API call has to go through in [“Processing
    a Request”](ch03.xhtml#processing-api-request).
  prefs: []
  type: TYPE_NORMAL
- en: The admission controller provides a way to approve, deny, or mutate a request
    before the request takes effect. For example, we can inspect the data sent with
    the API request to create a Pod, iterate over the assigned container images, and
    execute custom logic to validate the container image notation. If the container
    image doesn’t stick to the expected conventions, we can deny the creation of the
    Pod. [Figure 6-5](#imagepolicywebhook-admission-controller-plugin) illustrates
    the high-level workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0605](assets/ckss_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. Intercepting a Pod-specific API call and handling it with a webhook
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The [ImagePolicyWebhook](https://oreil.ly/JxmUu) admission controller plugin
    is one of the plugins we can configure for intercepting Kubernetes API calls.
    You can probably derive the plugin’s functionality from its name. It defines a
    policy for all defined container images in a Pod. To compare container images
    with the defined policy, the plugin calls off to a service external to Kubernetes
    via HTTPS, a webhook. The external service then makes the decision on how to validate
    the data. In the context of the admission controller plugin, the external service
    is also referred to as *backend*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Backend Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The backend application can be implemented with a programming language of your
    choice. There are only three requirements it must fulfill:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a web application that can handle HTTPS requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can accept and parse JSON request payloads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can send a JSON response payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing the backend application is not part of the CKS exam, but you can
    find a sample Go-based implementation in the [GitHub repository](https://oreil.ly/OF4fF)
    of this book. Be aware that the code is not considered to be production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: The following commands demonstrate the runtime behavior of the application accessible
    at `https://localhost:8080/validate`. You can find an example request and response
    JSON body in the [Kubernetes documentation](https://oreil.ly/8GaQe).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `curl` command calls the validation logic for the container image
    `nginx:1.19.0`. As you can see from the JSON response, the image is denied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `curl` command calls the validation logic for the container image
    `gcr.io/nginx:1.19.0`. As you can see from the JSON response, the image is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the ImagePolicyWebhook Admission Controller Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the exam, you are expected to understand how to “wire” the ImagePolicyWebhook
    admission controller plugin. This section will walk you through the process. First,
    you’ll need to create a configuration file for the admission controller so it
    knows what plugins to use and how it should behave at runtime. Create the file
    `/etc/kubernetes/admission-control/image-policy-webhook-admission-config.yaml`
    and populate it with the content shown in [Example 6-9](#admission-controller-configuration-file).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-9\. The admission controller configuration file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Provides the configuration for the ImagePolicyWebhook plugin.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_supply_chain_security_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Points to the configuration file used to configure the backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_supply_chain_security_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Denies an API request if the backend cannot be reached. The default is true
    but setting it to false is far more sensible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, create the file referenced by the `plugins[].configuration.imagePolicy.kubeConfigFile`
    attribute. The contents of the file point to the HTTPS URL of the external service.
    It also defines the client certificate and key file, as well as the CA file on
    disk. [Example 6-10](#image-policy-configuration-file) shows the contents of the
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-10\. The image policy configuration file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supply_chain_security_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The URL to the backend service. Must use the HTTPS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Enable the ImagePolicyWebhook admission controller plugin for the API server
    and point the admission controller to the configuration file. To achieve this,
    edit the configuration file of the API server, usually found at `/etc/kubernetes/manifests/kube-apiserver.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Find the command line option `--enable-admission-plugins` and append the value
    `ImagePolicyWebhook` to the existing list of plugins, separated by a comma. Provide
    the command line option `--admission-control-config-file` if it doesn’t exist
    yet, and set the value to `/etc/kubernetes/admission-control/image-policy-webhook-admission-configuration.yaml`.
    Given that the configuration file lives in a new directory, you will have to define
    it as a Volume and mount it to the container. [Example 6-11](#api-server-configuration-file)
    shows the relevant options for the API server container.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-11\. The API server configuration file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The Pod running the API server should automatically restart. This process may
    take a couple of minutes. Restart the kubelet service with the command `sudo systemctl
    restart kubelet` should the API server not come up by itself. Once fully restarted,
    you should be able to query for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Any API call that requests the creation of a Pod will now be routed to the backend.
    Based on the validation result, the creation of the object will be allowed or
    denied.
  prefs: []
  type: TYPE_NORMAL
- en: Static Analysis of Workload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we talk about best practices for Dockerfiles and Kubernetes
    manifests. You can inspect those files manually, find undesired configurations,
    and fix them by hand. This approach requires a lot of intricate knowledge and
    is very tedious and error-prone. It is much more convenient and efficient to analyze
    workload files in an automated fashion with proper tooling. The list of commercial
    and open source tooling for static analysis is long. In this section, we are going
    to present the functionality of two options, Haskell Dockerfile Linter and Kubesec.
  prefs: []
  type: TYPE_NORMAL
- en: On an enterprise level, where you have to process hundreds or even thousands
    of workload files, you’d do so with the help of a continuous delivery pipeline,
    as shown in [Figure 6-6](#continuous-delivery-kubernetes-static-analysis).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0606](assets/ckss_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. An exemplary continuous delivery pipeline for Kubernetes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Relevant static analysis tools can be invoked as a quality gate at an early
    stage of the pipeline even before a container image is built, pushed to a registry,
    or deployed to a Kubernetes cluster. For a deep dive on the principles and practices
    of continuous delivery, see the excellent book [*Continuous Delivery*](https://oreil.ly/8CR5M)
    by Jez Humble and David Farley (Addison-Wesley Professional).
  prefs: []
  type: TYPE_NORMAL
- en: Using Hadolint for Analyzing Dockerfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Haskell Dockerfile Linter](https://oreil.ly/C9bvu), also called hadolint in
    short, is a linter for Dockerfiles. The tool inspects a Dockerfile based on [best
    practices](https://oreil.ly/Fwksr) listed on the Docker documentation page. [Example 6-12](#unoptimized-dockerfile)
    shows an unoptimized Dockerfile for building a container image running a Go-based
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-12\. An unoptimized Dockerfile
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The Haskell Dockerfile Linter supports a mode of operation that lets you point
    the `hadolint` executable to a Dockerfile on disk. You can see the command execution
    that follows, including the discovered warning messages produced by the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The output of the command suggests that you should assign a tag to the base
    image. The existing Dockerfile will pull the `latest` tag, which will resolve
    to the newest Go container image. This practice can result in an incompatibility
    between the Go runtime version and the application code. Defining a working directory
    for copying resources helps with keeping operating system-specific directories
    and files separate from application-specific directories and files. [Example 6-13](#optimized-dockerfile)
    fixes the warning messages found by the Haskell Dockerfile Linter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-13\. An optimized Dockerfile
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another execution against the modified Dockerfile leads to a successful exit
    code, and no additional warning messages will be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The Dockerfile now follows best practices, as perceived by hadolint.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubesec for Analyzing Kubernetes Manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kubesec](https://kubesec.io) is a tool for analyzing Kubernetes manifests.
    It can be executed as a binary, Docker container, admission controller plugin,
    and even as a plugin for `kubectl`. To demonstrate its use, we’ll set up a YAML
    manifest file `pod-initial-kubesec-test.yaml`, shown in [Example 6-14](#pod-yaml-manifest-initial-security-settings)
    as a starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-14\. A Pod YAML manifest using initial security settings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Upon inspecting the Pod configuration, you may already have some suggestions
    on what could be improved based on the content of the previous chapters. Let’s
    see what Kubesec is going to recommend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to invoke Kubesec is to run the logic in a container with
    the help of Docker. The following command feeds the contents of the YAML manifest
    to the standard input stream. The result, formatted in JSON, renders a score,
    provides a human-readable message of the outcome, and advises on changes to be
    made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A touched-up version of the original YAML manifest can be found in [Example 6-15](#pod-yaml-manifest-improved-security-settings).
    Here, we incorporated some of the recommended changes proposed by Kubesec.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-15\. A Pod YAML manifest using improved security settings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the same Docker command against the changed Pod YAML manifest will
    render an improved score and reduce the number of advised messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Scanning Images for Known Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the top sources for logging and discovering security vulnerabilities
    is [CVE Details](https://oreil.ly/DDlVa). The page lists and ranks known vulnerabilities
    (CVEs) by score. Automated tooling can identify the software components embedded
    in a container image, compare those with the central vulnerabilities database,
    and flag issues by their severity.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the open source tools with this capability explicitly mentioned in the
    CKS curriculum is [Trivy](https://oreil.ly/hqPHH). Trivy can run in different
    modes of operation: as a command line tool, in a container, as a GitHub Action
    configurable in a continuous integration workflow, as a plugin for the IDE VSCode,
    and as a Kubernetes operator. For an overview of the available installation options
    and procedures, see the [Trivy documentation](https://oreil.ly/qB_c8). During
    the exam, you are not expected to install the tool. It will already be preconfigured
    for you. All you need to understand is how to run it and how to interpret and
    fix the found vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you installed the command line implementation of Trivy. You can check the
    version of Trivy with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Figure 6-7](#trivy-execution), Trivy indicates the timestamp
    when a copy of known vulnerabilities has been downloaded from the central database.
    Trivy can scan container images in various forms. The subcommand `image` simply
    expects you to spell out the image name and tag, in this case `python:3.4-alpine`.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0607](assets/ckss_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. Reporting generated by scanning a container image with Trivy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The most important information in the output consists of the library that contains
    a specific vulnerability, its severity, and the minimum version to use that fixes
    the issue. Any found vulnerabilities with high or critical severity should be
    considered for a fix. If you do not have any control over the container image
    yourself, you can try to upgrade to a newer version.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes primary objective is to run applications in containers in a scalable
    and secure fashion. In this chapter, we looked at the process, best practices,
    and tooling that help to ensure that a container image is produced that is small
    in size and that ships with as few known security vulnerabilities as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We reviewed some of the most efficient techniques to reduce the footprint of
    a container image to a minimum. Start by picking a small base image to start with.
    You can even go to the extreme and not provide a shell at all for additional gains
    in size reduction. If you are using Docker, you can leverage the multi-stage approach
    that lets you build the application inside of the container without bundling the
    compiler, runtime, and build tools necessary to achieve the goal.
  prefs: []
  type: TYPE_NORMAL
- en: When consuming the container image in a Pod, make sure to only pull the container
    image from a trusted registry. It’s advisable to set up an in-house container
    registry to serve up container images, so that reaching out to public, internet-accessible
    registries becomes obsolete, to eliminate potential security risks. You can enforce
    the usage of a list of trusted container registries with the help of OPA Gatekeeper.
    Another measure of security can be enforced by using the SHA256 hash of a container
    image to validate its expected contents.
  prefs: []
  type: TYPE_NORMAL
- en: The process of building and scanning a container image can be incorporated into
    a CI/CD pipeline. Third-party tools can parse and analyze the resource files of
    your deployable artifacts even before you build them. We looked at Haskell Dockerfile
    Linter for Dockerfiles and Kubesec for Kubernetes manifests. The other use case
    that needs to be covered on security aspects is consuming an existing container
    image built by an entity external to you as a developer, or your company. Before
    running a container image in a Kubernetes Pod, make sure to scan the contents
    for vulnerabilities. Trivy is one of those tools that can identify and report
    vulnerabilities in a container image to give you an idea of the security risks
    you are exposing yourself to in case you are planning to operate it in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Become familiar with techniques that help with reducing the container image
    footprint.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we described some techniques for reducing the size of a container
    image when building it. I would suggest you read the best practices mentioned
    on the Docker web page and try to apply them to sample container images. Compare
    the size of the produced container image before and after applying a technique.
    You can try to challenge yourself by reducing a container image to the smallest
    size possible while at the same time avoiding the loss of crucial functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Walk through the process of governing where a container image can be resolved
    from.
  prefs: []
  type: TYPE_NORMAL
- en: OPA Gatekeeper offers a way to define the registries users are allowed to resolve
    container images from. Set up the objects for the constraint template and constraint,
    and see if the rules apply properly for a Pod that defines a main application
    container, an init container, and an ephemeral container. To broaden your exposure,
    also look at other products in the Kubernetes spaces that provide similar functionality.
    One of those products is [Kyverno](https://kyverno.io).
  prefs: []
  type: TYPE_NORMAL
- en: Sign a container image and verify it using the hash.
  prefs: []
  type: TYPE_NORMAL
- en: After building a container image, make sure to also create a digest for it.
    Publish the container image, as well as the digest, to a registry. Practice how
    to use the digest in a Pod definition and verify the behavior of Kubernetes upon
    pulling the container image.
  prefs: []
  type: TYPE_NORMAL
- en: Understand how to configure the ImagePolicyWebhook admission controller plugin.
  prefs: []
  type: TYPE_NORMAL
- en: You are not expected to write a backend for an ImagePolicyWebhook. That’s out
    of scope for the exam and requires knowledge of a programming language. You do
    need to understand how to enable the plugin in the API server configuration, though.
    I would suggest you practice the workflow even if you don’t have a running backend
    application available.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to fix warnings produced by static analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: The CKS curriculum doesn’t prescribe a specific tool for analyzing Dockerfiles
    and Kubernetes manifests. During the exam, you may be asked to run a specific
    command that will produce a list of error and/or warning messages. Understand
    how to interpret the messages, and how to fix them in the relevant resource files.
  prefs: []
  type: TYPE_NORMAL
- en: Practice the use of Trivy to identify and fix security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The FAQ of the CKS lists the documentation page for Trivy. Therefore, it’s fair
    to assume that Trivy may come up in one of the questions. You will need to understand
    the different ways to invoke Trivy to scan a container image. The produced report
    will give a you clear indication on what needs to be fixed and the severity of
    the found vulnerability. Given that you can’t modify the container image easily,
    you will likely be asked to flag Pods that run container images with known vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the following Dockerfile. Can you identify possibilities for
    reducing the footprint of the produced container image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apply Dockerfile best practices to optimize the container image footprint. Run
    the `docker build` command before and after making optimizations. The resulting
    size of the container image should be smaller but the application should still
    be functioning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install Kyverno in your Kubernetes cluster. You can find installation instructions
    in the [documentation](https://oreil.ly/yxlLe).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the “Restrict Image Registries” policy described on the [documentation
    page](https://oreil.ly/Kdj1k). The only allowed registry should be `gcr.io`. Usage
    of any other registry should be denied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Pod that defines the container image `gcr.io/google-containers/busybox:1.27.2`.
    Creation of the Pod should fail. Create another Pod using the container image
    `busybox:1.27.2`. Kyverno should allow the Pod to be created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define a Pod using the container image `nginx:1.23.3-alpine` in the YAML manifest
    `pod-validate-image.yaml`. Retrieve the digest of the container image from Docker
    Hub. Validate the container image contents using the SHA256 hash. Create the Pod.
    Kubernetes should be able to successfully pull the container image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use Kubesec to analyze the following contents of the YAML manifest file `pod.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inspect the suggestions generated by Kubesec. Ignore the suggestions on seccomp
    and AppArmor. Fix the root cause of all messages so that another execution of
    the tool will not report any additional suggestions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch06/trivy* of the checked-out GitHub repository
    [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Execute the command `kubectl
    apply -f setup.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command creates three different Pods in the namespace `r61`. From the command
    line, execute Trivy against the container images used by the Pods. Delete all
    Pods that have “CRITICAL” vulnerabilities. Which of the Pods are still running?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
