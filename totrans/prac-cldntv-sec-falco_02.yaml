- en: Chapter 1\. Introducing Falco
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 介绍Falco
- en: The goal of this first chapter of the book is to explain what Falco is. Don’t
    worry, we’ll take it easy! We will first look at what Falco does, including a
    high-level view of its functionality and an introductory description of each of
    its components. We’ll explore the design principles that inspired Falco and still
    guide its development today. We’ll then discuss what you can do with Falco, what
    is outside its domain, and what you can better accomplish with other tools. Finally,
    we’ll provide some historical context to put things into perspective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第一章的目标是解释什么是Falco。别担心，我们会循序渐进！我们首先将看看Falco的功能，包括其功能的高层视图和每个组件的简介描述。我们将探讨启发Falco并至今指导其发展的设计原则。然后，我们将讨论你可以用Falco做什么，以及它所不涵盖的领域，以及你可以用其他工具更好地完成的任务。最后，我们将提供一些历史背景来全面看待这些事情。
- en: Falco in a Nutshell
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falco简介
- en: 'At the highest level, Falco is pretty straightforward: you deploy it by installing
    multiple *sensors* across a distributed infrastructure. Each sensor collects data
    (from the local machine or by talking to some API), runs a set of rules against
    it, and notifies you if something bad happens. [Figure 1-1](#falcoapostrophes_high_level_architectur)
    shows a simplified diagram of how it works.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高层面上，Falco非常直接：通过在分布式基础设施中安装多个*sensors*来部署它。每个传感器收集数据（从本地机器或通过某些API通信），对其运行一组规则，并在发生问题时通知你。[图 1-1](#falcoapostrophes_high_level_architectur)
    展示了其工作原理的简化图表。
- en: '![](Images/pcns_0101.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pcns_0101.png)'
- en: Figure 1-1\. Falco’s high-level architecture
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1 Falco的高层架构
- en: 'You can think of Falco like a network of security cameras for your infrastructure:
    you place the sensors in key locations, they observe what’s going on, and they
    ping you if they detect harmful behavior. With Falco, bad behavior is defined
    by a set of rules that the community created and maintains for you and that you
    can customize or extend for your needs. The alerts generated by your fleet of
    Falco sensors can theoretically stay in the local machine, but in practice they
    are typically exported to a centralized collector. For centralized alert collection,
    you can use a general-purpose security information and event management (SIEM)
    tool or a specialized tool like Falcosidekick. (We’ll cover alert collection extensively
    in [Chapter 12](ch12.xhtml#consuming_falco_events).)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把Falco想象成你基础设施的安全摄像头网络：你在关键位置放置传感器，它们观察发生的情况，并在检测到有害行为时通知你。对于Falco来说，不良行为由社区为你创建和维护的一组规则定义，你可以根据需要自定义或扩展。由你的Falco传感器群生成的警报理论上可以留在本地机器上，但实际上它们通常会导出到一个集中的收集器。为了集中警报收集，你可以使用通用安全信息与事件管理（SIEM）工具或类似Falcosidekick的专业工具。（我们将在[第12章](ch12.xhtml#consuming_falco_events)中详细介绍警报收集。）
- en: Now let’s dig a little deeper into the Falco architecture and explore its main
    components, starting with the sensors.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解Falco架构，探索其主要组件，从传感器开始。
- en: Sensors
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传感器
- en: '[Figure 1-2](#falco_sensor_architecture) shows how Falco sensors work.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-2](#falco_sensor_architecture) 展示了Falco传感器的工作原理。'
- en: '![](Images/pcns_0102.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pcns_0102.png)'
- en: Figure 1-2\. Falco sensor architecture
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2 Falco传感器架构
- en: 'The sensor consists of an engine that has two inputs: a data source and a set
    of rules. The sensor applies the rules to each event coming from the data source.
    When a rule matches an event, an output message is produced. Very straightforward,
    right?'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器包括一个引擎，具有两个输入：数据源和一组规则。传感器对来自数据源的每个事件应用规则。当规则匹配事件时，将生成输出消息。非常直接明了，对吧？
- en: Data Sources
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据源
- en: Each sensor is able to collect input data from a number of sources. Originally,
    Falco was designed to exclusively operate on system calls, which to date remain
    one of its most important data sources. We’ll cover system calls in detail in
    Chapters [3](ch03.xhtml#understanding_falcoapostr) and [4](ch04.xhtml#data_source),
    but for now you can think of them as what a running program uses to interface
    with its external world. Opening or closing a file, establishing or receiving
    a network connection, reading and writing data to and from the disk or the network,
    executing commands, and communicating with other processes using pipes or other
    types of interprocess communication are all examples of system call usage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个传感器能够从多个来源收集输入数据。最初，Falco被设计为专门处理系统调用，迄今仍然是其最重要的数据源之一。我们将在[第3章](ch03.xhtml#understanding_falcoapostr)和[第4章](ch04.xhtml#data_source)中详细介绍系统调用，但现在您可以将其视为运行程序用于与外部世界交互的方式。打开或关闭文件，建立或接收网络连接，从磁盘或网络读取和写入数据，执行命令，使用管道或其他类型的进程间通信与其他进程通信等都是系统调用的使用示例。
- en: 'Falco collects system calls by instrumenting the kernel of the Linux operating
    system (OS). It can do this in two different ways: deploying a kernel module (i.e.,
    a piece of executable code that can be installed in the operating system kernel
    to extend the kernel’s functionality) or using a technology called eBPF, which
    allows running of scripts that safely perform actions inside the OS. We’ll talk
    extensively about kernel modules and eBPF in [Chapter 4](ch04.xhtml#data_source).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Falco通过在Linux操作系统（OS）的内核中进行仪器化来收集系统调用。它可以通过两种不同的方式实现：部署内核模块（即可安装在操作系统内核中以扩展内核功能的可执行代码片段）或使用称为eBPF的技术，该技术允许在OS内部安全执行操作。我们将在[第4章](ch04.xhtml#data_source)中广泛讨论内核模块和eBPF。
- en: 'Tapping into this data gives Falco incredible visibility into everything that
    is happening in your infrastructure. Here are some examples of things Falco can
    detect for you:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些数据，Falco可以极大地增强对基础设施中发生的一切事情的可见性。以下是Falco可以为您检测到的一些示例：
- en: Privilege escalations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权升级
- en: Access to sensitive data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问敏感数据
- en: Ownership and mode changes
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有权和模式更改
- en: Unexpected network connections or socket mutations
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外的网络连接或套接字变化
- en: Unwanted program execution
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经授权的程序执行
- en: Data exfiltration
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据外泄
- en: Compliance violations
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合规性违规
- en: 'Falco has also been extended to tap into other data sources besides system
    calls (we’ll show you examples throughout the book). For example, Falco can monitor
    your cloud logs in real time and notify you when something bad happens in your
    cloud infrastructure. Here are some more examples of things it can detect for
    you:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Falco还可以扩展到除系统调用之外的其他数据源（我们将在整本书中为您展示示例）。例如，Falco可以实时监视您的云日志，并在云基础设施发生问题时通知您。以下是它可以为您检测到的一些更多示例：
- en: When a user logs in without multifactor authentication
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户未经多因素身份验证登录时
- en: When a cloud service configuration is modified
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当云服务配置被修改时
- en: When somebody accesses one or more sensitive files in an Amazon Web Services
    (AWS) S3 bucket
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有人访问Amazon Web Services（AWS）S3存储桶中的一个或多个敏感文件时
- en: New data sources are added to Falco frequently, so we recommend checking the
    [website](https://falco.org) and [Slack channel](https://oreil.ly/Y4bUt) to keep
    up with what’s new.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Falco经常添加新的数据源，因此我们建议查看[网站](https://falco.org)和[Slack频道](https://oreil.ly/Y4bUt)以了解最新信息。
- en: Rules
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则
- en: '*Rules* tell the Falco engine what to do with the data coming from the sources.
    They allow the user to define policies in a compact and readable format. Falco
    comes preloaded with a comprehensive set of rules that cover host, container,
    Kubernetes, and cloud security, and you can easily create your own rules to customize
    it. We’ll spend a lot of time on rules, in particular in Chapters [7](ch07.xhtml#falco_rules)
    and [13](ch13.xhtml#writing_falco_rules); by the time you’re done reading this
    book, you’ll be a total master at them. Here’s an example to whet your appetite:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*规则*告诉Falco引擎如何处理来自源的数据。它们允许用户以紧凑且易读的格式定义策略。Falco预装了一套全面的规则，涵盖主机、容器、Kubernetes和云安全，您可以轻松创建自己的规则来自定义它。我们将在[第7章](ch07.xhtml#falco_rules)和[第13章](ch13.xhtml#writing_falco_rules)中详细讨论规则；在阅读完本书后，您将成为规则的专家。以下是一个示例来激发您的兴趣：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This rule detects when a bash shell is started inside a container, which is
    normally not a good thing in an immutable container-based infrastructure. The
    core entries in a rule are the *condition*, which tells Falco what to look at,
    and the *output*, which is what Falco will tell you when the condition triggers.
    As you can see, both the condition and the output act on *fields*, one of the
    core concepts in Falco. The condition is a Boolean expression that combines checks
    of fields against values (essentially, a filter). The output is a combination
    of text and field names, whose values will be printed out in the notification.
    Its syntax is similar to that of a `print` statement in a programming language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则检测容器内启动bash shell的情况，这在不可变的基于容器的基础设施中通常不是一件好事。规则的核心条目是*条件*，告诉Falco要查看什么，以及*输出*，即条件触发时Falco将告诉您的内容。正如您所见，条件和输出都作用于*字段*，这是Falco的核心概念之一。条件是一个布尔表达式，它结合了对字段与值的检查（本质上是一个过滤器）。输出是文本和字段名称的组合，其值将在通知中打印出来。其语法类似于编程语言中的`print`语句。
- en: 'Does this remind you of networking tools like tcpdump or Wireshark? Good eye:
    they were a big inspiration for Falco.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否让你想起像tcpdump或Wireshark这样的网络工具？很有眼光：它们是Falco的重要灵感来源。
- en: Data Enrichment
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据丰富
- en: Rich data sources and a flexible rule engine help make Falco a powerful runtime
    security tool. On top of that, metadata from a disparate set of providers enriches
    its detections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 丰富的数据源和灵活的规则引擎帮助使Falco成为一个强大的运行时安全工具。此外，来自各种提供者的元数据丰富了其检测能力。
- en: When Falco tells you that something has happened—for example, that a system
    file has been modified—you typically need more information to understand the cause
    and the scope of the issue. Which process did this? Did it happen in a container?
    If so, what were the container and image names? What was the service/namespace
    where this happened? Was it in production or in dev? Was this a change made by
    root?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当Falco告诉您发生了某事，例如系统文件已被修改，通常您需要更多信息来理解问题的原因和范围。是哪个进程做的？这发生在容器中吗？如果是，容器和镜像的名称是什么？发生这种情况的服务/命名空间是什么？这是在生产环境还是开发环境中进行的更改？这是由root用户做出的改变吗？
- en: Falco’s data enrichment engine helps answer all of these questions by building
    up the environment state, including running processes and threads, the files they
    have open, the containers and Kubernetes objects they run in, etc. All of this
    state is accessible to Falco’s rules and outputs. For example, you can easily
    scope a rule so that it triggers only in production or in a specific service.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Falco的数据丰富引擎通过构建环境状态来帮助回答所有这些问题，包括运行中的进程和线程、它们打开的文件、它们所在的容器和Kubernetes对象等。所有这些状态对Falco的规则和输出都是可访问的。例如，您可以轻松地将规则范围限定为仅在生产环境或特定服务中触发。
- en: Output Channels
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出通道
- en: Every time a rule is triggered, the corresponding engine emits an output notification.
    In the simplest possible configuration, the engine writes the notification to
    standard output (which, as you can imagine, usually isn’t very useful). Fortunately,
    Falco offers sophisticated ways to route outputs and direct them to a bunch of
    places, including log collection tools, cloud storage services like S3, and communication
    tools like Slack and email. Its ecosystem includes a fantastic project called
    Falcosidekick, specifically designed to connect Falco to the world and make output
    collection effortless (see [Chapter 12](ch12.xhtml#consuming_falco_events) for
    more on this).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当触发规则时，对应的引擎会发出输出通知。在最简单的配置中，引擎将通知写入标准输出（正如你可以想象的那样，通常不是很有用）。幸运的是，Falco提供了复杂的输出路由方式，可以将输出定向到多个地方，包括日志收集工具、像S3这样的云存储服务，以及像Slack和电子邮件这样的通信工具。其生态系统包括一个名为Falcosidekick的精彩项目，专门设计用于将Falco连接到世界上，并使输出收集变得轻松（详见[第12章](ch12.xhtml#consuming_falco_events)了解更多信息）。
- en: Containers and More
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和更多
- en: Falco was designed for the modern world of cloud native applications, so it
    has excellent out-of-the-box support for containers, Kubernetes, and the cloud.
    Since this book is about cloud native security, we will mostly focus on that,
    but keep in mind that Falco is not limited to containers and Kubernetes running
    in the cloud. You can absolutely use it as a host security tool, and many of its
    preloaded rules can help you secure your fleet of Linux servers. Falco also has
    good support for network detection, allowing you to inspect the activity of connections,
    IP addresses, ports, clients, and servers and receive alerts when they show unwanted
    or unexpected/atypical behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Falco专为现代云原生应用程序设计，因此在容器、Kubernetes和云端具有出色的开箱即用支持。由于本书是关于云原生安全的，我们将主要关注这一点，但请记住，Falco并不局限于在云中运行的容器和Kubernetes。您绝对可以将其用作主机安全工具，它的许多预加载规则可以帮助您保护Linux服务器群。Falco还对网络检测有很好的支持，允许您检查连接、IP地址、端口、客户端和服务器的活动，并在它们展示不良或意外/非典型行为时收到警报。
- en: Falco’s Design Principles
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falco的设计原则
- en: Now that you understand what Falco does, let’s talk about why it is the way
    it is. When you’re developing a piece of software of non-negligible complexity,
    it’s important to focus on the right use cases and prioritize the most important
    goals. Sometimes that means accepting trade-offs. Falco is no exception. Its development
    has been guided by a core set of principles. In this section we will explore why
    they were chosen and how each of them affects Falco’s architecture and feature
    set. Understanding these principles will allow you to judge whether Falco is a
    good fit for your use cases and help you get the most out of it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了Falco的功能后，让我们谈谈它为什么会成为现在这个样子。当您开发一个非常复杂的软件时，重要的是专注于正确的使用案例并优先考虑最重要的目标。有时候这意味着要接受一些权衡。Falco也不例外。它的开发受到一组核心原则的指导。在本节中，我们将探讨为什么选择了这些原则以及它们如何影响Falco的架构和功能集。了解这些原则将帮助您判断Falco是否适合您的使用案例，并帮助您充分利用它。
- en: Specialized for Runtime
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专为运行时优化
- en: The Falco engine is designed to detect threats while your services and applications
    are running. When it detects unwanted behavior, Falco should alert you instantly
    (at most in a matter of seconds) so you’re informed (and can react!) right away,
    not after minutes or hours have passed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Falco引擎旨在在您的服务和应用程序运行时检测威胁。当它检测到不良行为时，Falco应该立即（最多几秒钟内）向您发出警报，以便您能够立即获得信息并做出反应，而不是在几分钟或几小时后才做出反应。
- en: This design principle manifests in three important architectural choices. First,
    the Falco engine is engineered as a streaming engine, able to process data quickly
    as it arrives rather than storing it and acting on it later. Second, it’s designed
    to evaluate each event independently, not to generate alerts based on a sequence
    of events; this means correlating different events, even if feasible, is not a
    primary goal and is in fact discouraged. Third, Falco evaluates rules as close
    as possible to the data source. If possible, it avoids transporting information
    before processing it and favors deploying richer engines on the endpoints.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这一设计原则体现在三个重要的架构选择中。首先，Falco引擎被设计为流式引擎，能够在数据到达时快速处理数据，而不是存储数据然后再处理。其次，它被设计为独立评估每个事件，而不是根据事件序列生成警报；这意味着即使可以，也不把相关事件作为主要目标，事实上是不鼓励的。第三，Falco尽可能在数据源附近评估规则。如果可能的话，在处理数据之前避免传输信息，并倾向于在端点部署更丰富的引擎。
- en: Suitable for Production
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适用于生产环境
- en: You should be able to deploy Falco in any environment, including production
    environments where stability and low overhead are of paramount importance. It
    should not crash your apps and should strive to slow them down as little as possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在任何环境中部署Falco，包括生产环境，稳定性和低开销至关重要。它不应该使您的应用崩溃，并且应该尽可能地减少对其性能的影响。
- en: This design principle affects the data collection architecture, particularly
    when Falco runs on endpoints that have many processes or containers. Falco’s drivers
    (the kernel module and eBPF probe) have undergone many iterations and years of
    testing to guarantee their performance and stability. Collecting data by tapping
    into the kernel of the operating system, as opposed to instrumenting the monitored
    processes/​con⁠tainers, guarantees that your applications won’t crash because
    of bugs in Falco.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这一设计原则影响数据收集架构，特别是当 Falco 运行在具有多个进程或容器的端点时。Falco 的驱动程序（内核模块和 eBPF 探针）经历了多次迭代和多年测试，以保证其性能和稳定性。通过接入操作系统内核来收集数据，而不是对被监控的进程/容器进行仪表化，确保您的应用程序不会因
    Falco 中的错误而崩溃。
- en: The Falco engine is written in C++ and employs many expedients to reduce resource
    consumption. For example, it avoids processing system calls that read or write
    disk or network data. In some ways this is a limitation, because it prevents users
    from creating rules that inspect the content of payloads, but it also ensures
    that CPU and memory consumption stay low, which is more important.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 引擎采用 C++ 编写，并采用多种手段来降低资源消耗。例如，它避免处理读取或写入磁盘或网络数据的系统调用。在某些方面，这是一种限制，因为它阻止用户创建检查有效负载内容的规则，但这也确保
    CPU 和内存消耗保持较低水平，这更为重要。
- en: Intent-Free Instrumentation
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无意图仪表化
- en: Falco is designed to observe application behavior without requiring users to
    recompile applications, install libraries, or rebuild containers with monitoring
    hooks. This is very important in modern containerized environments, where applying
    changes to every component would require an unrealistic amount of work. It also
    guarantees that Falco sees every process and container, no matter where it comes
    from, who runs it, or how long it’s been around.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 设计用于观察应用程序行为，而无需用户重新编译应用程序、安装库或重建带监控钩子的容器。在现代容器化环境中，这非常重要，因为对每个组件应用更改将需要不切实际的工作量。它还确保
    Falco 能够看到每个进程和容器，无论其来源、由谁运行或存在多长时间。
- en: Optimized to Run at the Edge
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化以在边缘运行
- en: Compared to other policy engines (for example, OPA), Falco has been explicitly
    designed with a distributed, multisensor architecture in mind. Its sensors are
    designed to be lightweight, efficient, and portable, and to operate in diverse
    environments. It can be deployed on a physical host, in a virtual machine, or
    as a container. The Falco binary is built for multiple platforms, including ARM.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他策略引擎（例如 OPA）相比，Falco 明确设计为具有分布式、多传感器架构。其传感器设计轻量、高效且可移植，并能在各种环境中运行。它可以部署在物理主机、虚拟机或容器中。Falco
    二进制文件适用于多个平台，包括 ARM。
- en: Avoids Moving and Storing a Ton of Data
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免移动和存储大量数据
- en: 'Most currently marketed threat detection products are based on sending large
    numbers of events to a centralized SIEM tool and then performing analytics on
    top of the collected data. Falco is designed around a very different principle:
    stay as close as possible to the endpoint, perform detections in place, and only
    ship alerts to a centralized collector. This approach results in a solution that
    is a bit less capable at performing complex analytics, but is simple to operate,
    much more cost-effective, and scales very well horizontally.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数当前市场上的威胁检测产品基于向集中式 SIEM 工具发送大量事件，然后在收集的数据上执行分析。Falco 围绕着一个非常不同的原则设计：尽可能靠近端点执行检测，并只向集中式收集器发送警报。这种方法导致解决方案在执行复杂分析方面略显能力不足，但操作简单、成本效益更高，并且在水平方向上具有很好的扩展性。
- en: Scalable
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展
- en: Speaking of scale, another important design goal underlying Falco is that it
    should be able to scale to support the biggest infrastructures in the world. If
    you can run it, Falco should be able to secure it. As we’ve just described, keeping
    limited state and avoiding centralized storage are important elements of this.
    Edge computing is an important element too, since distributing rule evaluation
    is the only approach to scale a tool like Falco in a truly horizontal way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到规模，Falco 的另一个重要设计目标是应该能够扩展以支持全球最大的基础设施。如果你可以运行它，Falco 应该能够保护它。正如我们刚才描述的，保持有限的状态和避免集中存储是这一目标的重要组成部分。边缘计算也是一个重要因素，因为分发规则评估是实现
    Falco 工具真正水平扩展的唯一方法。
- en: Another key part of scalability is endpoint instrumentation. Falco’s data collection
    stack doesn’t use techniques like sidecars, library linking, or process instrumentation.
    The reason is that the resource utilization of all of these techniques grows with
    the number of containers, libraries, or processes to monitor. Busy machines have
    many containers, libraries, and processes—too many for these techniques to work—but
    they have only one operating system kernel. Capturing system calls in the kernel
    means that you need only one Falco sensor per machine, no matter how big the machine
    is. This makes it possible to run Falco on big hosts with a lot of activity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性的另一个关键部分是端点仪表化。Falco的数据收集堆栈不使用诸如旁路、库链接或进程仪表化等技术。原因是所有这些技术的资源利用率随要监视的容器、库或进程数量增加而增长。繁忙的机器有许多容器、库和进程——对于这些技术来说太多了，但它们只有一个操作系统内核。在内核中捕获系统调用意味着您只需要一个Falco传感器每台机器，无论这台机器有多大活动量。这使得在具有大量活动的大型主机上运行Falco成为可能。
- en: Truthful
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实的
- en: One other benefit of using system calls as a data source? System calls never
    lie. Falco is hard to evade because the mechanism it uses to collect data is very
    difficult to disable or circumvent. If you try to evade or get around it, you
    will leave traces that Falco can capture.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统调用作为数据源的另一个好处？系统调用永远不会撒谎。Falco难以逃避，因为它用于收集数据的机制非常难以禁用或规避。如果您试图逃避或规避它，您将留下Falco可以捕获的痕迹。
- en: Robust Defaults, Richly Extensible
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 坚固的默认设置，丰富的可扩展性
- en: Another key design goal was minimizing the time it takes to extract value from
    Falco. You should be able to do this by just installing it; you shouldn’t need
    to customize it unless you have advanced requirements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键的设计目标是尽量减少从Falco中提取价值所需的时间。您只需安装它即可完成这一目标；除非您有高级需求，否则不需要进行定制。
- en: Whenever the need for customization does arise, though, Falco offers flexibility.
    For example, you can create new rules through a rich and expressive syntax, develop
    and deploy new data sources that expand the scope of detections, and integrate
    Falco with your desired notification and event collection tools.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，每当确实需要定制时，Falco提供了灵活性。例如，您可以通过丰富而表达性强的语法创建新规则，开发和部署扩展检测范围的新数据源，并将Falco集成到您想要的通知和事件收集工具中。
- en: Simple
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单
- en: 'Simplicity is the last design choice underpinning Falco, but it’s also one
    of the most important ones. The Falco rule syntax is designed to be compact, easy
    to read, and simple to learn. Whenever possible, a Falco rule condition should
    fit in a single line. Anyone, not only experts, should be able to write a new
    rule or modify an existing one. It’s OK if this reduces the expressiveness of
    the syntax: Falco is in the business of delivering an efficient security rule
    engine, not a full-fledged domain-specific language. There are better tools for
    that.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性是支持Falco的最后一个设计选择，但也是最重要的选择之一。Falco规则语法设计为紧凑、易读和易学习。在可能的情况下，Falco规则条件应该适合一行。任何人，不仅仅是专家，都应该能够编写新规则或修改现有规则。如果这降低了语法的表达能力也没关系：Falco的业务是提供高效的安全规则引擎，而不是完整的领域特定语言。对于那些，有更好的工具。
- en: Simplicity is also evident in the processes for extending Falco to alert on
    new data sources and integrating it with a new cloud service or type of container,
    which is a matter of writing a plugin in any language, including Go, C, and C++.
    Falco loads these plugins easily, and you can use them to add support for new
    data sources or new fields to use in rules.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性还体现在扩展Falco以警报新数据源并与新云服务或容器类型集成的过程中，这只需编写任何语言的插件，包括Go、C和C++。Falco可以轻松加载这些插件，您可以使用它们来支持新的数据源或新的字段以用于规则中。
- en: What You Can Do with Falco
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Falco可以做什么
- en: Falco shines at detecting threats, intrusions, and data theft at runtime and
    in real time. It works well with legacy infrastructures but excels at supporting
    containers, Kubernetes, and cloud infrastructures. It secures both workloads (processes,
    containers, services) and infrastructure (hosts, VMs, network, cloud infrastructure
    and services). It is designed to be lightweight, efficient, and scalable and to
    be used in both development and production. It can detect many classes of threats,
    but should you need more, you can customize it. It also has a thriving community
    that supports it and keeps enhancing it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 在运行时和实时检测威胁、入侵和数据盗窃方面表现突出。它在传统基础设施上运行良好，但在支持容器、Kubernetes 和云基础设施方面表现出色。它保护工作负载（进程、容器、服务）和基础设施（主机、虚拟机、网络、云基础设施和服务）。它被设计为轻量级、高效和可扩展，适用于开发和生产环境。它可以检测多类威胁，但如果您需要更多功能，可以自定义它。它还有一个支持并不断增强的活跃社区。
- en: What You Cannot Do with Falco
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Falco的局限性
- en: 'No single tool can solve all your problems. Knowing what you cannot do with
    Falco is as important as knowing where to use it. As with any tool, there are
    trade-offs. First, Falco is not a general-purpose policy language: it doesn’t
    offer the expressiveness of a full programming language and cannot perform correlation
    across different engines. Its rule engine, instead, is designed to apply relatively
    stateless rules at high frequency in many places around your infrastructure. If
    you are looking for a powerful centralized policy language, we suggest you take
    a look at [OPA](https://oreil.ly/nXYQI).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 没有单一工具能解决所有问题。了解Falco不能做什么与知道何时使用它同样重要。与任何工具一样，都有权衡。首先，Falco不是通用的策略语言：它不提供完整编程语言的表达能力，也不能在不同引擎间执行相关性。相反，其规则引擎设计为在您基础设施的多个地方高频应用相对无状态的规则。如果您寻找强大的集中式策略语言，我们建议您查看[OPA](https://oreil.ly/nXYQI)。
- en: Second, Falco is not designed to store the data it collects in a centralized
    repository so that you can perform analytics on it. Rule validation is performed
    at the endpoint, and only the alerts are sent to a centralized location. If your
    focus is advanced analytics and big data querying, we recommend that you use one
    of the many log collection tools available on the market.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Falco 并非设计用来将其收集的数据存储在集中式存储库中，以便您可以对其进行分析。规则验证在端点执行，只有警报会发送到集中位置。如果您专注于高级分析和大数据查询，我们建议您使用市场上提供的众多日志收集工具之一。
- en: Finally, for efficiency reasons, Falco does not inspect network payloads. Therefore,
    it’s not the right tool to implement layer 7 (L7) security policies. A traditional
    network-based intrusion detection system (IDS) or L7 firewall is a better choice
    for such a use case.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，出于效率考虑，Falco不会检查网络有效载荷。因此，它不适合实施第7层（L7）安全策略。传统的基于网络的入侵检测系统（IDS）或L7防火墙更适合这种用例。
- en: Background and History
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景和历史
- en: The authors of this book have been part of some of Falco’s history, and this
    final section presents our memories and perspectives. If you are interested only
    in operationalizing Falco, feel free to skip the rest of this chapter. However,
    we believe that knowing where Falco comes from can give you useful context for
    its architecture that will ultimately help you use it better. Plus, it’s a fun
    story!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的作者们是Falco历史的一部分，这一最后部分展示了我们的记忆和观点。如果您只对操作Falco感兴趣，可以跳过本章的其余部分。但是，我们认为了解Falco的起源可以为其架构提供有用的背景，最终帮助您更好地使用它。此外，这也是一个有趣的故事！
- en: 'Network Packets: BPF, libpcap, tcpdump, and Wireshark'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络数据包：BPF、libpcap、tcpdump 和Wireshark
- en: During the height of the late-1990s internet boom, computer networks were exploding
    in popularity. So was the need to observe, troubleshoot, and secure them. Unfortunately,
    many operators couldn’t afford the network visibility tools available at that
    time, which were all commercially offered and very expensive. As a consequence,
    a lot of people were fumbling around in the dark.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代末互联网高潮时期，计算机网络变得极为流行。对于观察、故障排除和保护它们的需求也同样增长。然而，许多运营商当时无法承担那时所有都是商业化且非常昂贵的网络可见性工具。因此，很多人在黑暗中摸索。
- en: 'Soon, teams around the world started working on solutions to this problem.
    Some involved extending existing operating systems to add packet capture functionality:
    in other words, making it possible to convert an off-the-shelf computer workstation
    into a device that could sit on a network and collect all the packets sent or
    received by other workstations. One such solution, Berkeley Packet Filter (BPF),
    developed by Steven McCanne and Van Jacobson at the University of California at
    Berkeley, was designed to extend the BSD operating system kernel. If you use Linux,
    you might be familiar with eBPF, a virtual machine that can be used to safely
    execute arbitrary code in the Linux kernel (the *e* stands for *extended*). eBPF
    is one of the hottest modern features of the Linux kernel. It’s evolved into an
    extremely powerful and flexible technology after many years of improvements, but
    it started as a little programmable packet capture and filtering module for BSD
    Unix.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，全球各地的团队开始致力于解决这一问题。有些解决方案涉及扩展现有操作系统，以增加数据包捕获功能：换句话说，将现成的计算机工作站转换为可以放置在网络上并收集其他工作站发送或接收的所有数据包的设备。伯克利数据包过滤器（BPF）是这样一种解决方案，由加州大学伯克利分校的Steven
    McCanne和Van Jacobson开发，旨在扩展BSD操作系统内核。如果您使用Linux，您可能熟悉eBPF，这是一个可以安全地在Linux内核中执行任意代码的虚拟机（“e”代表“扩展”）。eBPF是Linux内核中最热门的现代功能之一。经过多年的改进，它已经发展成为一种非常强大和灵活的技术，但它最初只是BSD
    Unix的一个可编程数据包捕获和过滤模块。
- en: BPF came with a library called *libpcap* that any program could use to capture
    raw network packets. Its availability triggered a proliferation of networking
    and security tools. The first tool based on *libpcap* was a command-line network
    analyzer called tcpdump, which is still part of virtually any Unix distribution.
    In 1998, however, a GUI-based open source protocol analyzer called Ethereal (renamed
    Wireshark in 2006) was launched. It became, and still is, the industry standard
    for packet analysis.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: BPF随附一个名为*libpcap*的库，任何程序都可以使用它来捕获原始网络数据包。其可用性引发了大量的网络和安全工具。基于*libpcap*的第一个工具是一个命令行网络分析器，名为tcpdump，它仍然是几乎所有Unix发行版的一部分。然而，在1998年，推出了一个基于GUI的开源协议分析器，名为Ethereal（2006年更名为Wireshark）。它成为了行业标准的数据包分析工具，至今仍然如此。
- en: 'What tcpdump, Wireshark, and many other popular networking tools have in common
    is the ability to access a data source that is rich, accurate, and trustworthy
    and can be collected in a noninvasive way: raw network packets. Keep this concept
    in mind as you continue reading!'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: tcpdump、Wireshark和许多其他流行的网络工具共同之处在于能够访问丰富、准确和可信的数据源，并且可以以非侵入式的方式进行收集：即原始网络数据包。在继续阅读时，请牢记这个概念！
- en: Snort and Packet-Based Runtime Security
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Snort与基于数据包的运行时安全
- en: Introspection tools like tcpdump and Wireshark were the natural early applications
    of the BPF packet capture stack. However, people soon started getting creative
    in their use cases for packets. For example, in 1998, Martin Roesch released an
    open source network intrusion detection tool called Snort. Snort is a rule engine
    that processes packets captured from the network. It has a large set of rules
    that can detect threats and unwanted activity by looking at packets, the protocols
    they contain, and the payloads they carry. It inspired the creation of similar
    tools such as Suricata and Zeek.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 类似tcpdump和Wireshark的内省工具是BPF数据包捕获堆栈的自然早期应用。然而，人们很快开始在数据包的用例上展开创意。例如，1998年，Martin
    Roesch发布了一个开源网络入侵检测工具，名为Snort。Snort是一个规则引擎，处理从网络捕获的数据包。它拥有一套大量的规则，可以通过检查数据包、它们包含的协议和它们携带的有效负载来检测威胁和不受欢迎的活动。它启发了类似工具如Suricata和Zeek的创建。
- en: What makes tools like Snort powerful is their ability to validate the security
    of networks and applications *while applications are running*. This is important
    because it provides real-time protection, and the focus on runtime behavior makes
    it possible to detect threats based on vulnerabilities that have not yet been
    disclosed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 像Snort这样的工具之所以强大，是因为它们能够在应用程序运行时验证网络和应用程序的安全性。这一点很重要，因为它提供了实时保护，而对运行时行为的关注使得可以基于尚未公开的漏洞检测到威胁。
- en: The Network Packets Crisis
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络数据包危机
- en: 'You’ve just seen what made network packets popular as a data source for visibility,
    security, and troubleshooting. Applications based on them spawned several successful
    industries. However, trends arose that eroded packets’ usefulness as a source
    of truth:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到了什么使网络数据包成为可见性、安全性和故障排除的数据源。基于它们的应用推动了几个成功的行业。然而，出现了趋势，侵蚀了数据包作为真相来源的有用性：
- en: Collecting packets in a comprehensive way became more and more complicated,
    especially in environments like the cloud, where access to routers and network
    infrastructure is limited.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云等环境中，收集数据包变得越来越复杂，特别是在访问路由器和网络基础设施受限的情况下。
- en: Encryption and network virtualization made it more challenging to extract valuable
    information.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密和网络虚拟化使提取有价值信息更具挑战性。
- en: The rise of containers and orchestrators like Kubernetes made infrastructures
    more elastic. At the same time, it became more complicated to reliably collect
    network data.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器和类似 Kubernetes 的编排器的兴起使基础设施更具弹性。与此同时，可靠地收集网络数据变得更加复杂。
- en: These issues started becoming clear in the early 2010s, with the popularity
    of cloud computing and containers. Once again, an exciting new ecosystem was unfolding,
    but no one quite knew how to troubleshoot and secure it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题在2010年代初期变得明显，随着云计算和容器的流行。再次出现了一个令人兴奋的新生态，但没有人确切知道如何进行故障排除和安全保护。
- en: 'System Calls as a Data Source: sysdig'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以系统调用作为数据源：sysdig
- en: 'That’s where your authors come in. We released an open source tool called *sysdig*,
    which we were inspired to build by a set of questions: What is the best way to
    provide visibility for modern cloud native applications? Can we apply workflows
    built on top of packet capture to this new world? What is the best data source?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的作者介入的地方。我们发布了一个名为 *sysdig* 的开源工具，我们受到一系列问题的启发而建立它：如何最好地为现代云原生应用程序提供可见性？我们能否将基于数据包捕获的工作流应用于这个新世界？最佳的数据源是什么？
- en: 'sysdig originally focused on collecting system calls from the kernel of the
    operating system. System calls are a rich data source—even richer than packets—because
    they don’t exclusively focus on network data: they include file I/O, command execution,
    interprocess communication, and more. They are a better data source for cloud
    native environments than packets, because they can be collected from the kernel
    for both containers and cloud instances. Plus, collecting them is easy, efficient,
    and minimally invasive.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: sysdig 最初专注于从操作系统内核收集系统调用。系统调用是丰富的数据源，甚至比数据包更丰富，因为它们不仅关注网络数据：它们包括文件I/O、命令执行、进程间通信等等。它们是云原生环境的比数据包更好的数据源，因为它们可以从内核中收集，适用于容器和云实例。此外，收集它们简单、高效且最小化侵入。
- en: 'sysdig was initially composed of three separate components:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: sysdig 最初由三个独立的组件组成。
- en: A kernel capture probe (available in two flavors, kernel module and eBPF)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核捕获探针（提供内核模块和 eBPF 两种版本）
- en: A set of libraries to facilitate the development of capture programs
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组库以便于开发捕获程序
- en: A command-line tool with decoding and filtering capabilities
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有解码和过滤功能的命令行工具
- en: 'In other words, it was porting the BPF stack to system calls. sysdig was engineered
    to support the most popular network packet workflows: trace files, easy filtering,
    scriptability, and so on. From the beginning, we also included native integrations
    with Kubernetes and other orchestrators, with the goal of making them useful in
    modern environments. sysdig immediately became very popular with the community,
    validating the technical approach.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它是将BPF堆栈移植到系统调用。sysdig 的设计旨在支持最流行的网络数据包工作流程：跟踪文件、简单过滤、可脚本化等等。从一开始，我们还包括了与
    Kubernetes 和其他编排器的本地集成，旨在使它们在现代环境中有用。sysdig 立即在社区中非常流行，验证了技术方法的有效性。
- en: Falco
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Falco
- en: 'So what would be the next logical step? You guessed it: a Snort-like tool for
    system calls! A flexible rule engine on top of the sysdig libraries, we thought,
    would be a powerful tool to detect anomalous behavior and intrusions in modern
    apps reliably and efficiently—essentially the Snort approach but applied to system
    calls and designed to work in the cloud.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 那么下一个逻辑步骤会是什么呢？你猜对了：一个类似于 Snort 的系统调用工具！我们认为，在 sysdig 库之上实现一个灵活的规则引擎，将是一种可靠和高效地检测现代应用程序异常行为和入侵的强大工具——本质上是应用于系统调用的
    Snort 方法，设计用于在云中工作。
- en: So, that’s how Falco was born. The first (rather simple) version was released
    at the end of 2016 and included most of the important components, such as the
    rule engine. Falco’s rule engine was inspired by Snort’s but designed to operate
    on a much richer and more generic dataset and was plugged into the sysdig libraries.
    It shipped with a relatively small but useful set of rules. This initial version
    of Falco was largely a single-machine tool, with no ability to be deployed in
    a distributed way. We released it as open source because we saw a broad community
    need for it and, of course, because we love open source!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Falco 就这样诞生了。第一个（相当简单的）版本于2016年底发布，包括大部分重要组件，如规则引擎。Falco 的规则引擎受到 Snort 的启发，但设计用于处理更丰富和更通用的数据集，并插入到
    sysdig 库中。它提供了一组相对较小但有用的规则。这个最初版本的 Falco 主要是单机工具，没有分布式部署的能力。我们将其作为开源发布，因为我们看到社区对它有广泛需求，并且当然也是因为我们热爱开源！
- en: Expanding into Kubernetes
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展到 Kubernetes
- en: As the tool evolved and the community embraced it, Falco’s developers expanded
    it into new domains of applicability. For example, in 2018 we added Kubernetes
    audit logs as a data source. This feature lets Falco tap into the stream of events
    produced by the audit log and detect misconfigurations and threats as they happen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随着工具的发展和社区的接受，Falco 的开发人员将其扩展到新的适用领域。例如，在2018年，我们添加了 Kubernetes 审计日志作为数据源。这一功能允许
    Falco 访问由审计日志产生的事件流，并在事件发生时检测配置错误和威胁。
- en: Creating this feature required us to improve the engine, which made Falco more
    flexible and better suited to a broader range of use cases.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这一功能需要我们改进引擎，这使得 Falco 更加灵活，更适合更广泛的用例。
- en: Joining the Cloud Native Computing Foundation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入云原生计算基金会
- en: In 2018 Sysdig contributed Falco to the Cloud Native Computing Foundation (CNCF)
    as a sandbox project. The CNCF is the home of many important projects at the foundation
    of modern cloud computing, such as Kubernetes, Prometheus, Envoy, and OPA. For
    our team, making Falco part of the CNCF was a way to evolve it into a truly community-driven
    effort, to make sure it would be flawlessly integrated with the rest of the cloud
    native stack, and to guarantee long-term support for it. In 2021 this effort was
    expanded by the contribution of the sysdig kernel module, eBPF probe, and libraries
    to the CNCF, as a subproject in the Falco organization. The full Falco stack is
    now in the hands of a neutral and caring community.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，Sysdig 将 Falco 贡献给了云原生计算基金会（CNCF）作为一个沙箱项目。CNCF 是现代云计算基础的许多重要项目的归属地，例如
    Kubernetes、Prometheus、Envoy 和 OPA。对我们团队而言，将 Falco 纳入 CNCF 是将其发展为真正社区驱动的努力的一种方式，以确保其能够与云原生栈的其余部分无缝集成，并为其提供长期支持。在2021年，通过将
    sysdig 内核模块、eBPF 探针和库贡献给 CNCF，将这一努力扩展为 Falco 组织的一个子项目。完整的 Falco 栈现在掌握在一个中立和关怀的社区手中。
- en: Plugins and the cloud
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插件和云
- en: As years passed and Falco matured, a couple of things became clear. First, its
    sophisticated engine, efficient nature, and ease of deployment make it suitable
    for much more than system call–based runtime security. Second, as software becomes
    more and more distributed and complex, runtime security is paramount to immediately
    detecting threats, both expected and unexpected. Finally, we believe that the
    world needs a consistent, standardized way to approach runtime security. In particular,
    there is great demand for a solution that can protect workloads (processes, containers,
    services, applications) and infrastructure (hosts, networks, cloud services) in
    a converged way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移和 Falco 的成熟，有几点变得很明显。首先，其复杂的引擎、高效的特性和易于部署使其适用于远不止基于系统调用的运行时安全。其次，随着软件变得越来越分布式和复杂，运行时安全变得至关重要，以立即检测到威胁，无论是预期的还是意外的。最后，我们相信世界需要一种一致和标准化的方式来处理运行时安全。特别是，对于一种可以在一个统一的方式中保护工作负载（进程、容器、服务、应用程序）和基础设施（主机、网络、云服务）的解决方案有巨大的需求。
- en: As a consequence, the next step in the evolution of Falco was adding modularity,
    flexibility, and support for many more data sources spanning different domains.
    For example, in 2021 a new plugin infrastructure was added that allows Falco to
    tap into data sources like cloud provider logs to detect misconfigurations, unauthorized
    access, data theft, and much more.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Falco 演进的下一个步骤是添加模块化、灵活性和对更多跨不同领域的数据源的支持。例如，在2021年，添加了一个新的插件基础设施，允许 Falco
    访问数据源，如云提供商日志，以检测配置错误、未经授权的访问、数据窃取等等。
- en: A long journey
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个漫长的旅程
- en: 'Falco’s story stretches across more than two decades and links many people,
    inventions, and projects that at first glance don’t appear related. In our opinion,
    this story exemplifies why open source is so cool: becoming a contributor lets
    you learn from the smart people who came before you, build on top of their innovations,
    and connect communities in creative ways.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 的故事跨越了二十多年，并连接了许多人、发明和一开始看起来并不相关的项目。在我们看来，这个故事充分展示了开源的魅力：成为贡献者让你能够向之前的聪明人学习，建立在他们创新的基础上，并以创造性的方式连接社区。
