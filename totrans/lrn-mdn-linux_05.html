<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Filesystems"><div class="chapter" id="files">
<h1><span class="label">Chapter 5. </span>Filesystems</h1>


<p><a data-type="indexterm" data-primary="filesystem" id="ix_ch05-asciidoc0"/>In this chapter, we focus on files and filesystems. The UNIX concept of
“everything is a file” lives on in Linux, and while that’s not
true 100% of the time, most resources in Linux are indeed files.
Files can be everything from the content of the letter you write to
your school to the funny GIF you download (from an obviously safe and trusted site).</p>

<p>There are other things that are also exposed as files in Linux—for example,
devices and pseudo-devices such as in <code>echo "Hello modern Linux users" &gt; /dev/pts/0</code>,
which prints “Hello modern Linux users” to the screen.
While you may not associate these resources with files, you can access them with the same
methods and tools you know from regular files. For example, the kernel exposes
certain runtime information (as discussed in <a data-type="xref" href="ch02.xhtml#kernel-process-management">“Process Management”</a>)
about a process, such as its PID or the binary used to run the process.</p>

<p>What all these things have in common is a standardized, uniform interface: opening a
file, gathering information about a file, writing to a file, and so forth.
In Linux, <a href="https://oreil.ly/9CEdn">filesystems</a>
provide this uniform interface. This interface, together with the fact that Linux
treats files as a stream of bytes, without any expectations about the structure,
enables us to build tools that work with a range of different file types.</p>

<p>In addition, the uniform interface that filesystems provide reduces your
cognitive load, making it faster for you to learn how to use Linux.</p>

<p>In this chapter, we first define some relevant terms. Then, we look at how Linux
implements the “everything is a file” abstraction. Next, we review special-purpose
filesystems the kernel uses to expose information about processes or devices.
We then move on to regular files and filesystems, something you would typically
associate with documents, data, and programs. We compare filesystem options
and discuss common operations.</p>






<section data-type="sect1" data-pdf-bookmark="Basics"><div class="sect1" id="fs-basics">
<h1>Basics</h1>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="basics" id="ix_ch05-asciidoc1"/>Before we get into the filesystem terminology, let’s first make some implicit
assumptions and expectations about filesystems more explicit:</p>

<ul>
<li>
<p>While there are exceptions, most of the widely used filesystems today
are hierarchical. That is, they provide the user with a single filesystem tree,
starting at the root (<code>/</code>).</p>
</li>
<li>
<p>In the filesystem tree, you find two different types of objects: directories and files.
Think of directories as an organizational unit, allowing you to group files.
If you’d like to apply the tree analogy, directories are the nodes in the tree,
whereas the leaves are either files or directories.</p>
</li>
<li>
<p>You can navigate a filesystem by listing the content of a directory (<code>ls</code>),
changing into that directory (<code>cd</code>), and printing the current working directory
(<code>pwd</code>).</p>
</li>
<li>
<p>Permissions are built-in: as discussed in <a data-type="xref" href="ch04.xhtml#permissions">“Permissions”</a>, one of the
attributes a filesystem captures is ownership. Consequently, ownership enforces
access to files and directories via the assigned permissions.</p>
</li>
<li>
<p>Generally, filesystems are implemented in the kernel.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While filesystems are usually, for performance reasons, implemented in the kernel
space, there’s also an option to implement them in user land. See
the <a href="https://oreil.ly/hIVgq">Filesystem in Userspace (FUSE) documentation</a>
 and the <a href="https://oreil.ly/cEZyY">libfuse project site</a>.</p>
</div>

<p>With this informal high-level explanation out of the way, we now focus on some
more crisp definitions of terms that you’ll need to understand:</p>
<dl>
<dt>Drive</dt>
<dd>
<p><a data-type="indexterm" data-primary="drive, defined" id="idm45805435795904"/>A (physical) block device such as a hard disk drive (HDD) or a
solid-state drive (SSD). In the context of virtual machines, a drive also can be
emulated—for example, <em>/dev/sda</em> (SCSI device) or <em>/dev/sdb</em> (SATA device) or
<em>/dev/hda</em> (IDE device).</p>
</dd>
<dt>Partition</dt>
<dd>
<p><a data-type="indexterm" data-primary="partition, defined" id="idm45805435792576"/>You can logically split up drives into partitions, a set of storage sectors.
For example, you may decide to create two partitions on your HDD, which then
would show up as <em>/dev/sdb1</em> and <em>/dev/sdb2</em>.</p>
</dd>
<dt>Volume</dt>
<dd>
<p><a data-type="indexterm" data-primary="volume, defined" id="idm45805435789696"/>A volume is somewhat similar to a partition, but it is more flexible, and it is
also formatted for a specific filesystem. We’ll discuss volumes in detail in <a data-type="xref" href="#lvm">“Logical Volume Manager”</a>.</p>
</dd>
<dt>Super block</dt>
<dd>
<p><a data-type="indexterm" data-primary="super block, defined" id="idm45805435786880"/>When formatted, filesystems have a special section in the beginning that
captures the metadata of the filesystem. This includes things like
filesystem type, blocks, state, and how many inodes per block.</p>
</dd>
<dt>Inodes</dt>
<dd>
<p><a data-type="indexterm" data-primary="inodes, defined" id="idm45805435784672"/>In a filesystem, inodes store metadata about files, such as size, owner, location,
date, and permissions. However, inodes do not store the filename and the actual
data. This is kept in directories, which really are just a special kind
of regular file, mapping inodes to filenames.</p>
</dd>
</dl>

<p>That was a lot of theory, so let’s see these concepts in action.
First, here’s how to see what drives, partitions, and volumes are present
in your system:</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>lsblk</code><code> </code><code>--exclude</code><code> </code><code class="m">7</code><code> </code><a class="co" id="co_filesystems_CO1-1" href="#callout_filesystems_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>NAME</code><code>                      </code><code>MAJ:MIN</code><code> </code><code>RM</code><code>   </code><code>SIZE</code><code> </code><code>RO</code><code> </code><code>TYPE</code><code> </code><code>MOUNTPOINTS</code><code>
</code><code>sda</code><code>                         </code><code class="m">8</code><code>:0</code><code>    </code><code class="m">0</code><code> </code><code class="m">223</code><code>.6G</code><code>  </code><code class="m">0</code><code> </code><code>disk</code><code>              </code><a class="co" id="co_filesystems_CO1-2" href="#callout_filesystems_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>├─sda1</code><code>                      </code><code class="m">8</code><code>:1</code><code>    </code><code class="m">0</code><code>   </code><code>512M</code><code>  </code><code class="m">0</code><code> </code><code>part</code><code> </code><code>/boot/efi</code><code>    </code><a class="co" id="co_filesystems_CO1-3" href="#callout_filesystems_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>└─sda2</code><code>                      </code><code class="m">8</code><code>:2</code><code>    </code><code class="m">0</code><code> </code><code class="m">223</code><code>.1G</code><code>  </code><code class="m">0</code><code> </code><code>part</code><code>              </code><a class="co" id="co_filesystems_CO1-4" href="#callout_filesystems_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
  </code><code>├─elementary--vg-root</code><code>   </code><code class="m">253</code><code>:0</code><code>    </code><code class="m">0</code><code> </code><code class="m">222</code><code>.1G</code><code>  </code><code class="m">0</code><code> </code><code>lvm</code><code>  </code><code>/</code><code>
  </code><code>└─elementary--vg-swap_1</code><code> </code><code class="m">253</code><code>:1</code><code>    </code><code class="m">0</code><code>   </code><code>976M</code><code>  </code><code class="m">0</code><code> </code><code>lvm</code><code>  </code><code class="o">[</code><code>SWAP</code><code class="o">]</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO1-1" href="#co_filesystems_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>List all block devices but exclude pseudo (loop) devices.</p></dd>
<dt><a class="co" id="callout_filesystems_CO1-2" href="#co_filesystems_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>We have a disk drive called <em>sda</em> with some 223 GB overall.</p></dd>
<dt><a class="co" id="callout_filesystems_CO1-3" href="#co_filesystems_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>There are two partitions here, with <em>sda1</em> being the boot partition.</p></dd>
<dt><a class="co" id="callout_filesystems_CO1-4" href="#co_filesystems_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The second partition, called <em>sda2</em>, contains two volumes (see <a data-type="xref" href="#lvm">“Logical Volume Manager”</a> for
details).</p></dd>
</dl>

<p>Now that we have an overall idea of the physical and logical setup, let’s have
a closer look at the filesystems in use:</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>findmnt</code><code> </code><code>-D</code><code> </code><code>-t</code><code> </code><code>nosquashfs</code><code> </code><a class="co" id="co_filesystems_CO2-1" href="#callout_filesystems_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>SOURCE</code><code>                          </code><code>FSTYPE</code><code>     </code><code>SIZE</code><code>  </code><code>USED</code><code>  </code><code>AVAIL</code><code> </code><code>USE%</code><code> </code><code>TARGET</code><code>
</code><code>udev</code><code>                            </code><code>devtmpfs</code><code>   </code><code class="m">3</code><code>.8G</code><code>     </code><code class="m">0</code><code>   </code><code class="m">3</code><code>.8G</code><code>   </code><code class="m">0</code><code>%</code><code> </code><code>/dev</code><code>
</code><code>tmpfs</code><code>                           </code><code>tmpfs</code><code>    </code><code class="m">778</code><code>.9M</code><code>  </code><code class="m">1</code><code>.6M</code><code> </code><code class="m">777</code><code>.3M</code><code>   </code><code class="m">0</code><code>%</code><code> </code><code>/run</code><code>
</code><code>/dev/mapper/elementary--vg-root</code><code> </code><code>ext4</code><code>     </code><code class="m">217</code><code>.6G</code><code> </code><code class="m">13</code><code>.8G</code><code> </code><code class="m">192</code><code>.7G</code><code>   </code><code class="m">6</code><code>%</code><code> </code><code>/</code><code>
</code><code>tmpfs</code><code>                           </code><code>tmpfs</code><code>      </code><code class="m">3</code><code>.8G</code><code> </code><code class="m">19</code><code>.2M</code><code>   </code><code class="m">3</code><code>.8G</code><code>   </code><code class="m">0</code><code>%</code><code> </code><code>/dev/shm</code><code>
</code><code>tmpfs</code><code>                           </code><code>tmpfs</code><code>        </code><code>5M</code><code>    </code><code>4K</code><code>     </code><code>5M</code><code>   </code><code class="m">0</code><code>%</code><code> </code><code>/run/lock</code><code>
</code><code>tmpfs</code><code>                           </code><code>tmpfs</code><code>      </code><code class="m">3</code><code>.8G</code><code>     </code><code class="m">0</code><code>   </code><code class="m">3</code><code>.8G</code><code>   </code><code class="m">0</code><code>%</code><code> </code><code>/sys/fs/cgroup</code><code>
</code><code>/dev/sda1</code><code>                       </code><code>vfat</code><code>       </code><code>511M</code><code>    </code><code>6M</code><code> </code><code class="m">504</code><code>.9M</code><code>   </code><code class="m">1</code><code>%</code><code> </code><code>/boot/efi</code><code>
</code><code>tmpfs</code><code>                           </code><code>tmpfs</code><code>    </code><code class="m">778</code><code>.9M</code><code>   </code><code>76K</code><code> </code><code class="m">778</code><code>.8M</code><code>   </code><code class="m">0</code><code>%</code><code> </code><code>/run/user/1000</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO2-1" href="#co_filesystems_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>List filesystems but exclude
<a href="https://oreil.ly/vS88y">squashfs types</a>
 (specialized read-only compressed filesystem originally developed for CDs,
 now also for snapshots).</p></dd>
</dl>

<p>We can go a step further and look at individual filesystem objects such
as directories or files:</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>stat</code><code> </code><code>myfile</code><code>
  </code><code>File:</code><code> </code><code>myfile</code><code>
  </code><code>Size:</code><code> </code><code class="m">0</code><code>               </code><code>Blocks:</code><code> </code><code class="m">0</code><code>          </code><code>IO</code><code> </code><code>Block:</code><code> </code><code class="m">4096</code><code>   </code><code>regular</code><code> </code><code>empty</code><code> </code><code>file</code><code> </code><a class="co" id="co_filesystems_CO3-1" href="#callout_filesystems_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>Device:</code><code> </code><code>fc01h/64513d</code><code>    </code><code>Inode:</code><code> </code><code class="m">555036</code><code>      </code><code>Links:</code><code> </code><code class="m">1</code><code> </code><a class="co" id="co_filesystems_CO3-2" href="#callout_filesystems_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>Access:</code><code> </code><code class="o">(</code><code class="m">0664</code><code>/-rw-rw-r--</code><code class="o">)</code><code>  </code><code>Uid:</code><code> </code><code class="o">(</code><code> </code><code class="m">1000</code><code>/</code><code>     </code><code>mh9</code><code class="o">)</code><code>   </code><code>Gid:</code><code> </code><code class="o">(</code><code> </code><code class="m">1001</code><code>/</code><code>     </code><code>mh9</code><code class="o">)</code><code>
</code><code>Access:</code><code> </code><code class="m">2021</code><code>-08-29</code><code> </code><code class="m">09</code><code>:26:36.638447261</code><code> </code><code>+0000</code><code>
</code><code>Modify:</code><code> </code><code class="m">2021</code><code>-08-29</code><code> </code><code class="m">09</code><code>:26:36.638447261</code><code> </code><code>+0000</code><code>
</code><code>Change:</code><code> </code><code class="m">2021</code><code>-08-29</code><code> </code><code class="m">09</code><code>:26:36.638447261</code><code> </code><code>+0000</code><code>
 </code><code>Birth:</code><code> </code><code class="m">2021</code><code>-08-29</code><code> </code><code class="m">09</code><code>:26:36.638447261</code><code> </code><code>+0000</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO3-1" href="#co_filesystems_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>File type information</p></dd>
<dt><a class="co" id="callout_filesystems_CO3-2" href="#co_filesystems_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Information about device and inode</p></dd>
</dl>

<p>In the previous command, if we used <code>stat .</code> (note the dot), we
would have gotten the respective directory file information, including its inode,
number of blocks used, and so forth.</p>

<p><a data-type="xref" href="#tab-fsbasics">Table 5-1</a> lists some basic filesystem commands that allow you to
explore the concepts we introduced earlier.</p>
<table id="tab-fsbasics">
<caption><span class="label">Table 5-1. </span>Selection of low-level filesystem and block device commands</caption>
<thead>
<tr>
<th>Command</th>
<th>Use case</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>lsblk</code></p></td>
<td><p>List all block devices</p></td>
</tr>
<tr>
<td><p><code>fdisk</code>, <code>parted</code></p></td>
<td><p>Manage disk partitions</p></td>
</tr>
<tr>
<td><p><code>blkid</code></p></td>
<td><p>Show block device attributes such as UUID</p></td>
</tr>
<tr>
<td><p><code>hwinfo</code></p></td>
<td><p>Show hardware information</p></td>
</tr>
<tr>
<td><p><code>file -s</code></p></td>
<td><p>Show filesystem and partition information</p></td>
</tr>
<tr>
<td><p><code>stat</code>, <code>df -i</code>, <code>ls -i</code></p></td>
<td><p>Show and list inode-related information</p></td>
</tr>
</tbody>
</table>

<p>Another term you’ll come across in the context of  filesystems is that of <em>links</em>.
Sometimes you want to refer to files with different names or provide shortcuts.
There are two types of links in Linux:</p>
<dl class="pagebreak-before">
<dt class="less_space">Hard links</dt>
<dd>
<p><a data-type="indexterm" data-primary="hard links" id="idm46298357613008"/>Reference inodes and can’t refer to directories. They also do not
  work across <span class="keep-together">filesystems.</span></p>
</dd>
<dt>Symbolic links, or <a href="https://oreil.ly/yRWYA">symlinks</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="symbolic links (symlinks)" id="idm46298357610352"/>Special files with their content being a string representing the path
  of another file.</p>
</dd>
</dl>

<p>Now let’s see links in action (some outputs shortened):</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>ln</code><code> </code><code>myfile</code><code> </code><code>somealias</code><code> </code><a class="co" id="co_filesystems_CO4-1" href="#callout_filesystems_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>$</code><code> </code><code>ln</code><code> </code><code>-s</code><code> </code><code>myfile</code><code> </code><code>somesoftalias</code><code> </code><a class="co" id="co_filesystems_CO4-2" href="#callout_filesystems_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>

</code><code>$</code><code> </code><code>ls</code><code> </code><code>-al</code><code> </code><code>*alias</code><code> </code><a class="co" id="co_filesystems_CO4-3" href="#callout_filesystems_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>-rw-rw-r--</code><code> </code><code class="m">2</code><code> </code><code>mh9</code><code> </code><code>mh9</code><code> </code><code class="m">0</code><code> </code><code>Sep</code><code>  </code><code class="m">5</code><code> </code><code class="m">12</code><code>:15</code><code> </code><code>somealias</code><code>
</code><code>lrwxrwxrwx</code><code> </code><code class="m">1</code><code> </code><code>mh9</code><code> </code><code>mh9</code><code> </code><code class="m">6</code><code> </code><code>Sep</code><code>  </code><code class="m">5</code><code> </code><code class="m">12</code><code>:45</code><code> </code><code>somesoftalias</code><code> </code><code>-&gt;</code><code> </code><code>myfile</code><code>

</code><code>$</code><code> </code><code>stat</code><code> </code><code>somealias</code><code> </code><a class="co" id="co_filesystems_CO4-4" href="#callout_filesystems_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
  </code><code>File:</code><code> </code><code>somealias</code><code>
  </code><code>Size:</code><code> </code><code class="m">0</code><code>               </code><code>Blocks:</code><code> </code><code class="m">0</code><code>          </code><code>IO</code><code> </code><code>Block:</code><code> </code><code class="m">4096</code><code>   </code><code>regular</code><code> </code><code>empty</code><code> </code><code>file</code><code>
</code><code>Device:</code><code> </code><code>fd00h/64768d</code><code>    </code><code>Inode:</code><code> </code><code class="m">6302071</code><code>     </code><code>Links:</code><code> </code><code class="m">2</code><code>
</code><code>...</code><code>
</code><code>$</code><code> </code><code>stat</code><code> </code><code>somesoftalias</code><code> </code><a class="co" id="co_filesystems_CO4-5" href="#callout_filesystems_CO4-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
  </code><code>File:</code><code> </code><code>somesoftalias</code><code> </code><code>-&gt;</code><code> </code><code>myfile</code><code>
  </code><code>Size:</code><code> </code><code class="m">6</code><code>               </code><code>Blocks:</code><code> </code><code class="m">0</code><code>          </code><code>IO</code><code> </code><code>Block:</code><code> </code><code class="m">4096</code><code>   </code><code>symbolic</code><code> </code><code>link</code><code>
</code><code>Device:</code><code> </code><code>fd00h/64768d</code><code>    </code><code>Inode:</code><code> </code><code class="m">6303540</code><code>     </code><code>Links:</code><code> </code><code class="m">1</code><code>
</code><code>...</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO4-1" href="#co_filesystems_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Create a hard link to <em>myfile</em>.</p></dd>
<dt><a class="co" id="callout_filesystems_CO4-2" href="#co_filesystems_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Create a soft link to the same file (notice the <code>-s</code> option).</p></dd>
<dt><a class="co" id="callout_filesystems_CO4-3" href="#co_filesystems_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>List the files. Notice the different file types and the rendering of the name. We could also have used <code>ls -ali *alias</code>, which would show that the inodes
were the same on the two names associated with the hard link.</p></dd>
<dt><a class="co" id="callout_filesystems_CO4-4" href="#co_filesystems_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Show the file details of the hard link.</p></dd>
<dt><a class="co" id="callout_filesystems_CO4-5" href="#co_filesystems_CO4-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Show the file details of the soft link.</p></dd>
</dl>

<p>Now that you’re familiar with filesystem terminology let’s explore how Linux
makes it possible to treat any kind of resource as a file.<a data-type="indexterm" data-startref="ix_ch05-asciidoc1" id="idm45805435259824"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The Virtual File System"><div class="sect1" id="vfs">
<h1>The Virtual File System</h1>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="VFS" id="ix_ch05-asciidoc2"/><a data-type="indexterm" data-primary="Virtual File System (VFS)" id="ix_ch05-asciidoc3"/>Linux manages to provide a file-like access to many sorts of resources
(in-memory, locally attached, or networked storage) through an abstraction called the
<a href="https://oreil.ly/3sZQ1">virtual file system
(VFS)</a>. The basic idea is to introduce a layer of 
<span class="keep-together">indirection</span>
between the clients (syscalls) and the individual filesystems implementing
operations for a concrete device or other kind of resource. This means that VFS
separates the generic operation (open, read, seek) from the actual
implementation details.</p>

<p>VFS is an abstraction layer in the kernel that provides clients a common
way to access resources, based on the file paradigm. A file, in Linux, doesn’t
have any prescribed structure; it’s just a stream of bytes. It’s up to the
client to decide what the bytes mean. As shown in <a data-type="xref" href="#fig-vfs-overview">Figure 5-1</a>,
VFS abstracts access to different kinds of filesystems:</p>
<dl>
<dt>Local filesystems, such as <code>ext3</code>, XFS, FAT, and NTFS</dt>
<dd>
<p>These filesystems use
  drivers to access local block devices such as HDDs or SSDs.</p>
</dd>
<dt>In-memory filesystems, such as <code>tmpfs</code>, that are not backed by long-term storage devices but live in main memory (RAM)</dt>
<dd>
<p>We’ll cover these and the
  previous category in <a data-type="xref" href="#regular-files">“Regular Files”</a>.</p>
</dd>
<dt>Pseudo filesystems like <code>procfs</code>, as discussed in <a data-type="xref" href="#pseudo-fs">“Pseudo Filesystems”</a></dt>
<dd>
<p>These filesystems are also in-memory in nature. They’re used for kernel
  interfacing and device abstractions.</p>
</dd>
<dt>Networked filesystems, such as NFS, Samba, Netware (nee Novell), and others</dt>
<dd>
<p>These filesystems also use a driver; however, the storage devices
  where the actual data resides is not locally attached but remote. This
  means that the driver involves network operations. For this reason, we’ll cover them in <a data-type="xref" href="ch07.xhtml#networking">Chapter 7</a>.</p>
</dd>
</dl>

<figure><div id="fig-vfs-overview" class="figure">
<img src="Images/lmlx_0501.png" alt="lmlx 0501" width="600" height="438"/>
<h6><span class="label">Figure 5-1. </span>Linux VFS overview</h6>
</div></figure>

<p>Describing the makeup of the VFS isn’t easy.
There are over 100 syscalls related to files; however, in its core, the
operations can be grouped into a handful of categories, as listed in
<a data-type="xref" href="#tab-vfsinterface">Table 5-2</a>.</p>
<table id="tab-vfsinterface">
<caption><span class="label">Table 5-2. </span>Select syscalls making up the VFS interface</caption>
<thead>
<tr>
<th>Category</th>
<th>Example syscalls</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Inodes</p></td>
<td><p><code>chmod</code>, <code>chown</code>, <code>stat</code></p></td>
</tr>
<tr>
<td><p>Files</p></td>
<td><p><code>open</code>, <code>close</code>, <code>seek</code>, <code>truncate</code>, <code>read</code>, <code>write</code></p></td>
</tr>
<tr>
<td><p>Directories</p></td>
<td><p><code>chdir</code>, <code>getcwd</code>, <code>link</code>, <code>unlink</code>, <code>rename</code>, <code>symlink</code></p></td>
</tr>
<tr>
<td><p>Filesystems</p></td>
<td><p><code>mount</code>, <code>flush</code>, <code>chroot</code></p></td>
</tr>
<tr>
<td><p>Others</p></td>
<td><p><code>mmap</code>, <code>poll</code>, <code>sync</code>, <code>flock</code></p></td>
</tr>
</tbody>
</table>

<p>Many VFS syscalls dispatch to the filesystem-specific implementation. For other syscalls,
there are VFS default implementations. Further, the Linux kernel
defines relevant VFS data structures—see
<a href="https://oreil.ly/Fkq8i"><em>include/linux/fs.h</em></a>—such as the following:</p>
<dl>
<dt><code>inode</code></dt>
<dd>
<p>The core filesystem object, capturing type, ownership, permissions, links,
  pointers to blocks containing the file data, creation and access statistics, and more</p>
</dd>
<dt><code>file</code></dt>
<dd>
<p>Representing an open file (including path, current position, and inode)</p>
</dd>
<dt><code>dentry</code> (directory entry)</dt>
<dd>
<p>Stores its parent and children</p>
</dd>
<dt><code>super_block</code></dt>
<dd>
<p>Representing a filesystem including mount information</p>
</dd>
<dt>Others</dt>
<dd>
<p>Including <code>vfsmount</code> and <code>file_system_type</code></p>
</dd>
</dl>

<p>With the VFS overview done, let’s have a closer look at the details, including
volume management, filesystem operations, and common file system layouts.</p>








<section data-type="sect2" data-pdf-bookmark="Logical Volume Manager"><div class="sect2" id="lvm">
<h2>Logical Volume Manager</h2>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="LVM" id="ix_ch05-asciidoc4"/><a data-type="indexterm" data-primary="Logical Volume Manager (LVM)" id="ix_ch05-asciidoc5"/>We previously talked about carving up drives using partitions. While doing this
is possible, partitions are hard to use, especially when resizing
(changing the amount of storage space) is necessary.</p>

<p>Logical volume manager (LVM) uses a layer of 
<span class="keep-together">indirection</span> between physical entities
(such as drives or partitions) and the file system. This yields a setup that
allows for risk-free, zero-downtime expanding and automatic storage extension
through the pooling of resources. The way LVM works is depicted in <a data-type="xref" href="#fig-lvm-overview">Figure 5-2</a>, with key concepts explained in the passage that follows.</p>

<figure><div id="fig-lvm-overview" class="figure">
<img src="Images/lmlx_0502.png" alt="lmlx 0502" width="600" height="354"/>
<h6><span class="label">Figure 5-2. </span>Linux LVM overview</h6>
</div></figure>
<dl>
<dt>Physical volumes (PV)</dt>
<dd>
<p>Can be a disk partition, an entire disk drive, and other devices.</p>
</dd>
<dt>Logical volumes (LV)</dt>
<dd>
<p>Are block devices created from VGs. These are
  conceptually comparable to partitions. You have to create a filesystem on
  an LV before you can use it. You can easily resize LVs while in use.</p>
</dd>
<dt>Volume groups (VG)</dt>
<dd>
<p>Are a go-between between a set of PVs and LVs. Think of a VG as
  pools of PVs collectively providing resources.</p>
</dd>
</dl>

<p>To <a href="https://oreil.ly/rYXVI">manage volumes with LVM</a>,
a number of tools are required; however, they are consistently named and relatively
easy to use:</p>
<dl>
<dt>PV management tools</dt>
<dd>

<ul>
<li>
<p><code>lvmdiskscan</code></p>
</li>
<li>
<p><code>pvdisplay</code></p>
</li>
<li>
<p><code>pvcreate</code></p>
</li>
<li>
<p><code>pvscan</code></p>
</li>
</ul>
</dd>
<dt>VG management tools</dt>
<dd>

<ul>
<li>
<p><code>vgs</code></p>
</li>
<li>
<p><code>vgdisplay</code></p>
</li>
<li>
<p><code>vgcreate</code></p>
</li>
<li>
<p><code>vgextend</code></p>
</li>
</ul>
</dd>
<dt>LV management tools</dt>
<dd>

<ul>
<li>
<p><code>lvs</code></p>
</li>
<li>
<p><code>lvscan</code></p>
</li>
<li>
<p><code>lvcreate</code></p>
</li>
</ul>
</dd>
</dl>

<p>Let’s see some LVM commands in action, using a concrete setup:</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>sudo</code><code> </code><code>lvscan</code><code> </code><a class="co" id="co_filesystems_CO5-1" href="#callout_filesystems_CO5-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
  </code><code>ACTIVE</code><code>            </code><code class="s1">'/dev/elementary-vg/root'</code><code> </code><code class="o">[</code><code>&lt;</code><code class="m">222</code><code>.10</code><code> </code><code>GiB</code><code class="o">]</code><code> </code><code>inherit</code><code>
  </code><code>ACTIVE</code><code>            </code><code class="s1">'/dev/elementary-vg/swap_1'</code><code> </code><code class="o">[</code><code class="m">976</code><code>.00</code><code> </code><code>MiB</code><code class="o">]</code><code> </code><code>inherit</code><code>

</code><code>$</code><code> </code><code>sudo</code><code> </code><code>vgs</code><code> </code><a class="co" id="co_filesystems_CO5-2" href="#callout_filesystems_CO5-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code>VG</code><code>            </code><code class="c1">#PV #LV #SN Attr   VSize    VFree
</code><code>  </code><code>elementary-vg</code><code>   </code><code class="m">1</code><code>   </code><code class="m">2</code><code>   </code><code class="m">0</code><code> </code><code>wz--n-</code><code> </code><code>&lt;</code><code class="m">223</code><code>.07g</code><code> </code><code class="m">16</code><code>.00m</code><code>

</code><code>$</code><code> </code><code>sudo</code><code> </code><code>pvdisplay</code><code> </code><a class="co" id="co_filesystems_CO5-3" href="#callout_filesystems_CO5-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code>---</code><code> </code><code>Physical</code><code> </code><code>volume</code><code> </code><code>---</code><code>
  </code><code>PV</code><code> </code><code>Name</code><code>               </code><code>/dev/sda2</code><code>
  </code><code>VG</code><code> </code><code>Name</code><code>               </code><code>elementary-vg</code><code>
  </code><code>PV</code><code> </code><code>Size</code><code>               </code><code>&lt;</code><code class="m">223</code><code>.07</code><code> </code><code>GiB</code><code> </code><code>/</code><code> </code><code>not</code><code> </code><code>usable</code><code> </code><code class="m">3</code><code>.00</code><code> </code><code>MiB</code><code>
  </code><code>Allocatable</code><code>           </code><code>yes</code><code>
  </code><code>PE</code><code> </code><code>Size</code><code>               </code><code class="m">4</code><code>.00</code><code> </code><code>MiB</code><code>
  </code><code>Total</code><code> </code><code>PE</code><code>              </code><code class="m">57105</code><code>
  </code><code>Free</code><code> </code><code>PE</code><code>               </code><code class="m">4</code><code>
  </code><code>Allocated</code><code> </code><code>PE</code><code>          </code><code class="m">57101</code><code>
  </code><code>PV</code><code> </code><code>UUID</code><code>               </code><code>2OrEfB-77zU-jun3-a0XC-QiJH-erDP-1ujfAM</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO5-1" href="#co_filesystems_CO5-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>List logical volumes; we have two here (<em>root</em> and <em>swap_1</em>) using
volume group <em>elementary-vg</em>.</p></dd>
<dt><a class="co" id="callout_filesystems_CO5-2" href="#co_filesystems_CO5-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Display volume groups; we have one here called <em>elementary-vg</em>.</p></dd>
<dt><a class="co" id="callout_filesystems_CO5-3" href="#co_filesystems_CO5-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Display physical volumes; we have one here (<em>/dev/sda2</em>) that’s assigned
to the volume group <em>elementary-vg</em>.</p></dd>
</dl>

<p>Whether you use a partition or an LV, two more steps, which we’ll cover next,
are necessary to use a filesystem.<a data-type="indexterm" data-startref="ix_ch05-asciidoc5" id="idm45805435078608"/><a data-type="indexterm" data-startref="ix_ch05-asciidoc4" id="idm45805435047744"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Filesystem Operations"><div class="sect2" id="fsops">
<h2>Filesystem Operations</h2>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="operations" id="ix_ch05-asciidoc6"/>In the following section, we’ll discuss how to create a filesystem, given
a partition or a logical volume (created using LVM). <a data-type="indexterm" data-primary="formatting" id="idm45805435044144"/>There are two steps
involved: creating the filesystem—in other non-Linux operating systems, this step is
sometimes called <em>formatting</em>—and then mounting it, or inserting it
into the filesystem tree.</p>










<section data-type="sect3" data-pdf-bookmark="Creating filesystems"><div class="sect3" id="fs-create">
<h3>Creating filesystems</h3>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="creating" id="idm45805435041184"/>In order to use a filesystem, the first step is to create one. This means that
you’re setting up the management pieces that make up a filesystem, taking
a partition or a volume as the input. Consult <a data-type="xref" href="#tab-fsbasics">Table 5-1</a> if you’re unsure
how to gather the necessary information about the input, and once you have
everything together, use <a href="https://oreil.ly/uqI57"><code>mkfs</code></a>
to create a filesystem.</p>

<p><code>mkfs</code> takes two primary inputs: the type of filesystem you want to create
(see one of the options we discuss in <a data-type="xref" href="#common-regular-fs">“Common Filesystems”</a>) and the device you
want to create the filesystem on (for example, a logical volume):</p>

<pre data-type="programlisting" data-code-language="shell"><code>mkfs</code><code> </code><code>-t</code><code> </code><code>ext4</code><code> </code><code class="se">\ </code><a class="co" id="co_filesystems_CO6-1" href="#callout_filesystems_CO6-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
    </code><code>/dev/some_vg/some_lv</code><code> </code><a class="co" id="co_filesystems_CO6-2" href="#callout_filesystems_CO6-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO6-1" href="#co_filesystems_CO6-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Create a filesystem of type <code>ext4</code>.</p></dd>
<dt><a class="co" id="callout_filesystems_CO6-2" href="#co_filesystems_CO6-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Create the filesystem on the logical volume <em>/dev/some_vg/some_lv</em>.</p></dd>
</dl>

<p>As you can see from the previous command, there’s not much to it to create
a filesystem, so the main work for you is to figure out what filesystem type
to use.</p>

<p>Once you have created the filesystem with <code>mkfs</code>, you can then make it
available in the filesystem tree.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Mounting filesystems"><div class="sect3" id="fs-mount">
<h3>Mounting filesystems</h3>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="mounting" id="idm45805434995632"/>Mounting a filesystem means attaching it to the filesystem tree (which starts
at <em>/</em>). Use the <a href="https://oreil.ly/c6ryR"><code>mount</code> command</a> to attach a
filesystem. <code>mount</code> takes two main inputs: the device you want to attach and the
place in the filesystem tree. In addition, you can provide other inputs, including mount options (via <code>-o</code>) such as read-only, and <a data-type="indexterm" data-primary="bind mounts" id="idm45805434992080"/>bind mounts—via <a href="https://oreil.ly/C2QuV"><code>--bind</code></a>—for mounting
directories into the filesystem tree. We’ll revisit this latter option in the context of 
<span class="keep-together">containers.</span></p>

<p>You can use <code>mount</code> on its own as well. Here’s how to list existing mounts:</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>mount</code><code> </code><code>-t</code><code> </code><code>ext4,tmpfs</code><code> </code><a class="co" id="co_filesystems_CO7-1" href="#callout_filesystems_CO7-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>tmpfs</code><code> </code><code>on</code><code> </code><code>/run</code><code> </code><code class="nb">type</code><code> </code><code>tmpfs</code><code> </code><code class="o">(</code><code>rw,nosuid,noexec,relatime,size</code><code class="o">=</code><code>797596k,mode</code><code class="o">=</code><code class="m">755</code><code class="o">)</code><code>
</code><code>/dev/mapper/elementary--vg-root</code><code> </code><code>on</code><code> </code><code>/</code><code> </code><code class="nb">type</code><code> </code><code>ext4</code><code> </code><code class="o">(</code><code>rw,relatime,errors</code><code class="o">=</code><code>remount-ro</code><code class="o">)</code><code> </code><a class="co" id="co_filesystems_CO7-2" href="#callout_filesystems_CO7-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>tmpfs</code><code> </code><code>on</code><code> </code><code>/dev/shm</code><code> </code><code class="nb">type</code><code> </code><code>tmpfs</code><code> </code><code class="o">(</code><code>rw,nosuid,nodev</code><code class="o">)</code><code>
</code><code>tmpfs</code><code> </code><code>on</code><code> </code><code>/run/lock</code><code> </code><code class="nb">type</code><code> </code><code>tmpfs</code><code> </code><code class="o">(</code><code>rw,nosuid,nodev,noexec,relatime,size</code><code class="o">=</code><code>5120k</code><code class="o">)</code><code>
</code><code>tmpfs</code><code> </code><code>on</code><code> </code><code>/sys/fs/cgroup</code><code> </code><code class="nb">type</code><code> </code><code>tmpfs</code><code> </code><code class="o">(</code><code>ro,nosuid,nodev,noexec,mode</code><code class="o">=</code><code class="m">755</code><code class="o">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO7-1" href="#co_filesystems_CO7-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>List mounts but only show certain filesystem types (<code>ext4</code> and <code>tmpfs</code>
here).</p></dd>
<dt><a class="co" id="callout_filesystems_CO7-2" href="#co_filesystems_CO7-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>An example mount: the LVM VG <em>/dev/mapper/elementary--vg-root</em> of type
<code>ext4</code> is mounted at the root.</p></dd>
</dl>

<p>You must make sure that you mount a filesystem using the type it has been
created with. For example, if you’re trying to mount an SD card using
<code>mount -t vfat /dev/sdX2 /media</code>, you have to know the SD card is formatted
using <code>vfat</code>. You can let <code>mount</code> try all filesystems until one works using
the <code>-a</code> option.</p>

<p>Further, the mounts are valid only for as long as the system is running, so in
order to make it permanent, you need to use the
<a href="https://oreil.ly/zoSE1">fstab file (<em>/etc/fstab</em>)</a>. For example,
here is mine (output slightly edited to fit):</p>

<pre data-type="programlisting" data-code-language="shell">$ cat /etc/fstab
<code class="c1"># /etc/fstab: static file system information.</code>
<code class="c1">#</code>
<code class="c1"># Use 'blkid' to print the universally unique identifier for a</code>
<code class="c1"># device; this may be used with UUID= as a more robust way to name devices</code>
<code class="c1"># that works even if disks are added and removed. See fstab(5).</code>
<code class="c1">#</code>
<code class="c1"># &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</code>
/dev/mapper/elementary--vg-root / ext4 <code class="nv">errors</code><code class="o">=</code>remount-ro <code class="m">0</code> <code class="m">1</code>
<code class="c1"># /boot/efi was on /dev/sda1 during installation</code>
<code class="nv">UUID</code><code class="o">=</code>2A11-27C0  /boot/efi vfat <code class="nv">umask</code><code class="o">=</code><code class="m">0077</code> <code class="m">0</code> <code class="m">1</code>
/dev/mapper/elementary--vg-swap_1 none swap sw <code class="m">0</code> <code class="m">0</code></pre>

<p>Now you know how to manage partitions, volumes, and filesystems.<a data-type="indexterm" data-startref="ix_ch05-asciidoc6" id="idm45805434888816"/> Next up, we
review common ways to organize filesystems.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Common Filesystem Layouts"><div class="sect2" id="common-fs-layouts">
<h2>Common Filesystem Layouts</h2>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="common layouts" id="idm45805434886496"/><a data-type="indexterm" data-primary="filesystem layout" id="idm45805434885520"/>Once you have a filesystem in place, an obvious challenge is to come up
with a way to organize its content. You may want to organize things like
where programs are stored, configuration data, system data, and user data.
We will refer to this organization of directories and their content as
the <em>filesystem layout</em>. <a data-type="indexterm" data-primary="FHS (Filesystem Hierarchy Standard)" id="idm45805434867776"/><a data-type="indexterm" data-primary="Filesystem Hierarchy Standard (FHS)" id="idm45805434867072"/>Formally, the layout is called the
<a href="https://oreil.ly/q0c4a">Filesystem Hierarchy Standard (FHS)</a>.
It defines directories, including their structure and recommended content. The
Linux Foundation maintains the FHS, and it’s a good starting point
for Linux distributions to follow.</p>

<p>The idea behind FHS is laudable. However, in practice you will find that the
filesystem layout very much depends on the Linux distribution you’re using.
Thus, I strongly recommend you use the <code>man hier</code> command to learn
about your concrete setup.</p>

<p>To provide you with a high-level idea of what you can expect when you see certain
top-level directories, I compiled a list of common ones in <a data-type="xref" href="#tab-fslayouts">Table 5-3</a>.</p>
<table id="tab-fslayouts">
<caption><span class="label">Table 5-3. </span>Common top-level directories</caption>
<thead>
<tr>
<th>Directory</th>
<th>Semantics</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><em>bin</em>, <em>sbin</em></p></td>
<td><p>System programs and commands (usually links to <em>/usr/bin</em> and <em>/usr/sbin</em>)</p></td>
</tr>
<tr>
<td><p><em>boot</em></p></td>
<td><p>Kernel images and related components</p></td>
</tr>
<tr>
<td><p><em>dev</em></p></td>
<td><p>Devices (terminals, drives, etc.)</p></td>
</tr>
<tr>
<td><p><em>etc</em></p></td>
<td><p>System configuration files</p></td>
</tr>
<tr>
<td><p><em>home</em></p></td>
<td><p>User home directories</p></td>
</tr>
<tr>
<td><p><em>lib</em></p></td>
<td><p>Shared system libraries</p></td>
</tr>
<tr>
<td><p><em>mnt</em>, <em>media</em></p></td>
<td><p>Mount points for removable media (e.g., USB sticks)</p></td>
</tr>
<tr>
<td><p><em>opt</em></p></td>
<td><p>Distro specific; can host package manager files</p></td>
</tr>
<tr>
<td><p><em>proc</em>, <em>sys</em></p></td>
<td><p>Kernel interfaces; see also <a data-type="xref" href="#pseudo-fs">“Pseudo Filesystems”</a></p></td>
</tr>
<tr>
<td><p><em>tmp</em></p></td>
<td><p>For temporary files</p></td>
</tr>
<tr>
<td><p><em>usr</em></p></td>
<td><p>User programs (usually read-only)</p></td>
</tr>
<tr>
<td><p><em>var</em></p></td>
<td><p>User programs (logs, backups, network caches, etc.)</p></td>
</tr>
</tbody>
</table>

<p>With that<a data-type="indexterm" data-startref="ix_ch05-asciidoc3" id="idm45805434804288"/><a data-type="indexterm" data-startref="ix_ch05-asciidoc2" id="idm45805434803584"/>, let’s move on to some special kinds of filesystems.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Pseudo Filesystems"><div class="sect1" id="pseudo-fs">
<h1>Pseudo Filesystems</h1>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="pseudo" id="ix_ch05-asciidoc7"/><a data-type="indexterm" data-primary="pseudo filesystems" id="ix_ch05-asciidoc8"/>Filesystems are a great way to structure and access information. By now you have
likely already internalized the Linux motto that “everything is a file.”
We looked at how Linux provides a uniform interface
via VFS in <a data-type="xref" href="#vfs">“The Virtual File System”</a>. Now, let’s take a closer look at how an interface is provided
in cases where the VFS implementor is not a block device (such as an SD card or an SSD drive).</p>

<p>Meet pseudo filesystems: they only pretend to be filesystems so
that we can interact with them in the usual manner (<code>ls</code>, <code>cd</code>, <code>cat</code>), but
really they are wrapping some kernel interface. The interface can be a range of
things, including the following:</p>

<ul>
<li>
<p>Information about a process</p>
</li>
<li>
<p>An interaction with devices such as keyboards</p>
</li>
<li>
<p>Utilities such as special devices you can use as data sources or sinks</p>
</li>
</ul>

<p>Let’s have a closer look at the three major pseudo filesystems Linux has,
starting with the oldest.</p>








<section data-type="sect2" data-pdf-bookmark="procfs"><div class="sect2" id="procfs">
<h2>procfs</h2>

<p><a data-type="indexterm" data-primary="/proc filesystem (procfs)" data-primary-sortas="proc" id="ix_ch05-asciidoc9"/><a data-type="indexterm" data-primary="filesystem" data-secondary="procfs" id="ix_ch05-asciidoc10"/><a data-type="indexterm" data-primary="procfs" id="ix_ch05-asciidoc11"/>Linux inherited the <a href="https://oreil.ly/QEdmm"><em>/proc</em></a>
filesystem (<code>procfs</code>) from UNIX. The original intention was to publish process-related
information from the kernel, to make it consumable for system commands such as
<code>ps</code> or <code>free</code>. It has very few rules around structure, allows read-write
access, and over time many things found their way into it. In general, you
find two types of information there:</p>

<ul>
<li>
<p>Per-process information in <em>/proc/PID/</em>. This is process-relevant information
that the kernel exposes via directories with the PID as the directory name.
Details concerning the information available there are listed in
<a data-type="xref" href="#tab-procfsprocess">Table 5-4</a>.</p>
</li>
<li>
<p>Other information such as mounts, networking-related information, TTY drivers, memory information,
system version, and uptime.</p>
</li>
</ul>

<p>You can glean per-process information as listed in <a data-type="xref" href="#tab-procfsprocess">Table 5-4</a> simply
by using commands like <code>cat</code>. Note that most are read-only; the write semantics
depend on the underlying resource.</p>
<table id="tab-procfsprocess">
<caption><span class="label">Table 5-4. </span>Per-process information in procfs (most notable)</caption>
<thead>
<tr>
<th>Entry</th>
<th>Type</th>
<th>Information</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>attr</code></p></td>
<td><p>Directory</p></td>
<td><p>Security attributes</p></td>
</tr>
<tr>
<td><p><code>cgroup</code></p></td>
<td><p>File</p></td>
<td><p>Control groups</p></td>
</tr>
<tr>
<td><p><code>cmdline</code></p></td>
<td><p>File</p></td>
<td><p>Command line</p></td>
</tr>
<tr>
<td><p><code>cwd</code></p></td>
<td><p>Link</p></td>
<td><p>Current working directory</p></td>
</tr>
<tr>
<td><p><code>environ</code></p></td>
<td><p>File</p></td>
<td><p>Environment variables</p></td>
</tr>
<tr>
<td><p><code>exe</code></p></td>
<td><p>Link</p></td>
<td><p>Executable of the process</p></td>
</tr>
<tr>
<td><p><code>fd</code></p></td>
<td><p>Directory</p></td>
<td><p>File descriptors</p></td>
</tr>
<tr>
<td><p><code>io</code></p></td>
<td><p>File</p></td>
<td><p>Storage I/O (bytes/char read and written)</p></td>
</tr>
<tr>
<td><p><code>limits</code></p></td>
<td><p>File</p></td>
<td><p>Resource limits</p></td>
</tr>
<tr>
<td><p><code>mem</code></p></td>
<td><p>File</p></td>
<td><p>Memory used</p></td>
</tr>
<tr>
<td><p><code>mounts</code></p></td>
<td><p>File</p></td>
<td><p>Mounts used</p></td>
</tr>
<tr>
<td><p><code>net</code></p></td>
<td><p>Directory</p></td>
<td><p>Network stats</p></td>
</tr>
<tr>
<td><p><code>stat</code></p></td>
<td><p>File</p></td>
<td><p>Process status</p></td>
</tr>
<tr>
<td><p><code>syscall</code></p></td>
<td><p>File</p></td>
<td><p>Syscall usage</p></td>
</tr>
<tr>
<td><p><code>task</code></p></td>
<td><p>Directory</p></td>
<td><p>Per-task (thread) information</p></td>
</tr>
<tr>
<td><p><code>timers</code></p></td>
<td><p>File</p></td>
<td><p>Timers information</p></td>
</tr>
</tbody>
</table>

<p>To see this in action, let’s inspect the process status.
We’re using <code>status</code> here rather than <code>stat</code>, which doesn’t come with
human-readable labels:</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>cat</code><code> </code><code>/proc/self/status</code><code> </code><code class="p">|</code><code> </code><code>head</code><code> </code><code>-10</code><code> </code><a class="co" id="co_filesystems_CO8-1" href="#callout_filesystems_CO8-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>Name:</code><code>   </code><code>cat</code><code>
</code><code>Umask:</code><code>  </code><code class="m">0002</code><code>
</code><code>State:</code><code>  </code><code>R</code><code> </code><code class="o">(</code><code>running</code><code class="o">)</code><code> </code><a class="co" id="co_filesystems_CO8-2" href="#callout_filesystems_CO8-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>Tgid:</code><code>   </code><code class="m">12011</code><code>
</code><code>Ngid:</code><code>   </code><code class="m">0</code><code>
</code><code>Pid:</code><code>    </code><code class="m">12011</code><code> </code><a class="co" id="co_filesystems_CO8-3" href="#callout_filesystems_CO8-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>PPid:</code><code>   </code><code class="m">3421</code><code> </code><a class="co" id="co_filesystems_CO8-4" href="#callout_filesystems_CO8-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>TracerPid:</code><code>      </code><code class="m">0</code><code>
</code><code>Uid:</code><code>    </code><code class="m">1000</code><code>    </code><code class="m">1000</code><code>    </code><code class="m">1000</code><code>    </code><code class="m">1000</code><code>
</code><code>Gid:</code><code>    </code><code class="m">1000</code><code>    </code><code class="m">1000</code><code>    </code><code class="m">1000</code><code>    </code><code class="m">1000</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO8-1" href="#co_filesystems_CO8-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Get the process status about the currently running command, showing only the
first 10 lines.</p></dd>
<dt><a class="co" id="callout_filesystems_CO8-2" href="#co_filesystems_CO8-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The current state (running, on-CPU).</p></dd>
<dt><a class="co" id="callout_filesystems_CO8-3" href="#co_filesystems_CO8-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The PID of the current process.</p></dd>
<dt><a class="co" id="callout_filesystems_CO8-4" href="#co_filesystems_CO8-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The process ID of the parent process of the command; in this case, it’s
the shell where I ran the <code>cat</code> command in.</p></dd>
</dl>

<p>Here is one more example of using <code>procfs</code> to glean information, this time from
the networking space:</p>

<pre data-type="programlisting" data-code-language="shell">$ cat /proc/self/net/arp
IP address       HW <code class="nb">type</code>     Flags       HW address            Mask     Device
<code class="m">192</code>.168.178.1    0x1         0x2         3c:a6:2f:8e:66:b3     *        wlp1s0
<code class="m">192</code>.168.178.37   0x1         0x2         dc:54:d7:ef:90:9e     *        wlp1s0</pre>

<p><a data-type="indexterm" data-primary="Address Resolution Protocol (ARP)" id="idm45805434629904"/><a data-type="indexterm" data-primary="ARP (Address Resolution Protocol)" id="idm45805434629296"/>As shown in the previous command, we can glean ARP information about the
current process from this special <em>/proc/self/net/arp</em>.</p>

<p><code>procfs</code> is very useful if you’re
<a href="https://oreil.ly/nJ01w">low-level debugging</a>
or developing system tooling. It is relatively messy, so you’ll need
the kernel docs or, even better, the kernel source code at hand to understand
what each file represents and how to interpret the information in it.<a data-type="indexterm" data-startref="ix_ch05-asciidoc11" id="idm45805434639168"/><a data-type="indexterm" data-startref="ix_ch05-asciidoc10" id="idm45805434638560"/><a data-type="indexterm" data-startref="ix_ch05-asciidoc9" id="idm45805434637952"/></p>

<p>Let’s move on to a more recent, more orderly way the kernel exposes information.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="sysfs"><div class="sect2" id="sysfs">
<h2>sysfs</h2>

<p><a data-type="indexterm" data-primary="/sys filesystem (sysfs)" data-primary-sortas="sys" id="idm45805434623824"/><a data-type="indexterm" data-primary="filesystem" data-secondary="sysfs" id="idm45805434622848"/><a data-type="indexterm" data-primary="sysfs" id="idm45805434621904"/>Where <code>procfs</code> is pretty Wild West, the
<a href="https://oreil.ly/EHJEJ"><em>/sys</em></a> filesystem (<code>sysfs</code>)
is a Linux-specific, structured way for the kernel to expose select information
(such as about devices) using a standardized layout.</p>

<p>Here are the directories in <code>sysfs</code>:</p>
<dl>
<dt><em>block/</em></dt>
<dd>
<p>This directory symbolic links to discovered block devices.</p>
</dd>
<dt><em>bus/</em></dt>
<dd>
<p>In this directory, you find one subdirectory for each physical bus type
  supported in the kernel.</p>
</dd>
<dt><em>class/</em></dt>
<dd>
<p>This directory contains device classes.</p>
</dd>
<dt><em>dev/</em></dt>
<dd>
<p>This directory contains two subdirectories: <em>block/</em> for block devices and
  <em>char/</em> for character devices on the system, structured with <code>major-ID:minor-ID</code>.</p>
</dd>
<dt><em>devices/</em></dt>
<dd>
<p>In this directory, the kernel provides a representation of the device tree.</p>
</dd>
<dt><em>firmware/</em></dt>
<dd>
<p>Via these directories, you can manage firmware-specific attributes.</p>
</dd>
<dt><em>fs/</em></dt>
<dd>
<p>This directory contains subdirectories for some filesystems.</p>
</dd>
<dt><em>module/</em></dt>
<dd>
<p>In these directories you find subdirectories for each module loaded in the kernel.</p>
</dd>
</dl>

<p>There are more subdirectories in <code>sysfs</code>, but some are newish and/or would
benefit from better documentation. You’ll find certain information duplicated
in <code>sysfs</code> that is also available in <code>procfs</code>, but other information (such as
memory information) is only available in <code>procfs</code>.</p>

<p>Let’s see <code>sysfs</code> in action (output edited to fit):</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>ls</code><code> </code><code>-al</code><code> </code><code>/sys/block/sda/</code><code> </code><code class="p">|</code><code> </code><code>head</code><code> </code><code>-7</code><code> </code><a class="co" id="co_filesystems_CO9-1" href="#callout_filesystems_CO9-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>total</code><code> </code><code class="m">0</code><code>
</code><code>drwxr-xr-x</code><code> </code><code class="m">11</code><code> </code><code>root</code><code> </code><code>root</code><code>    </code><code class="m">0</code><code> </code><code>Sep</code><code>  </code><code class="m">7</code><code> </code><code class="m">11</code><code>:49</code><code> </code><code>.</code><code>
</code><code>drwxr-xr-x</code><code>  </code><code class="m">3</code><code> </code><code>root</code><code> </code><code>root</code><code>    </code><code class="m">0</code><code> </code><code>Sep</code><code>  </code><code class="m">7</code><code> </code><code class="m">11</code><code>:49</code><code> </code><code>..</code><code>
</code><code>-r--r--r--</code><code>  </code><code class="m">1</code><code> </code><code>root</code><code> </code><code>root</code><code> </code><code class="m">4096</code><code> </code><code>Sep</code><code>  </code><code class="m">8</code><code> </code><code class="m">16</code><code>:22</code><code> </code><code>alignment_offset</code><code>
</code><code>lrwxrwxrwx</code><code>  </code><code class="m">1</code><code> </code><code>root</code><code> </code><code>root</code><code>    </code><code class="m">0</code><code> </code><code>Sep</code><code>  </code><code class="m">7</code><code> </code><code class="m">11</code><code>:51</code><code> </code><code>bdi</code><code> </code><code>-&gt;</code><code>  </code><code>../../../virtual/bdi/8:0</code><code> </code><a class="co" id="co_filesystems_CO9-2" href="#callout_filesystems_CO9-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>-r--r--r--</code><code>  </code><code class="m">1</code><code> </code><code>root</code><code> </code><code>root</code><code> </code><code class="m">4096</code><code> </code><code>Sep</code><code>  </code><code class="m">8</code><code> </code><code class="m">16</code><code>:22</code><code> </code><code>capability</code><code> </code><a class="co" id="co_filesystems_CO9-3" href="#callout_filesystems_CO9-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>-r--r--r--</code><code>  </code><code class="m">1</code><code> </code><code>root</code><code> </code><code>root</code><code> </code><code class="m">4096</code><code> </code><code>Sep</code><code>  </code><code class="m">7</code><code> </code><code class="m">11</code><code>:49</code><code> </code><code>dev</code><code> </code><a class="co" id="co_filesystems_CO9-4" href="#callout_filesystems_CO9-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_filesystems_CO9-1" href="#co_filesystems_CO9-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>List information about block device <code>sda</code>, showing only the first seven lines.</p></dd>
<dt><a class="co" id="callout_filesystems_CO9-2" href="#co_filesystems_CO9-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>backing_dev_info</code> link using <code>MAJOR:MINOR</code> format.</p></dd>
<dt><a class="co" id="callout_filesystems_CO9-3" href="#co_filesystems_CO9-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Captures device
<a href="https://oreil.ly/GFUid">capabilities</a>, such
as if it is removable.</p></dd>
<dt><a class="co" id="callout_filesystems_CO9-4" href="#co_filesystems_CO9-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Contains the device major and minor number (<code>8:0</code>); see also the
<a href="https://oreil.ly/DK9GT">block
device drivers reference</a> for what the numbers mean.</p></dd>
</dl>

<p>Next up in our little pseudo filesystem review are devices.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="devfs"><div class="sect2" id="devfs">
<h2>devfs</h2>

<p><a data-type="indexterm" data-primary="/dev filesystem (devfs)" data-primary-sortas="dev" id="idm45805434451520"/><a data-type="indexterm" data-primary="devfs" id="idm45805434450512"/><a data-type="indexterm" data-primary="filesystem" data-secondary="devfs" id="idm45805434449840"/>The <a href="https://oreil.ly/EkO8V"><em>/dev</em></a> filesystem
(<code>devfs</code>) hosts device special files, representing devices ranging from physical
devices to things like a random number generator or a write-only data sink.</p>

<p>The devices available and managed via <code>devfs</code> are:</p>
<dl>
<dt>Block devices</dt>
<dd>
<p>Handle data in blocks—for example, storage devices (drives)</p>
</dd>
<dt>Character devices</dt>
<dd>
<p>Handle things character by character, such as a
  terminal, a keyboard, or a mouse</p>
</dd>
<dt>Special devices</dt>
<dd>
<p>Generate data or allow you to manipulate it, including
  the famous <em>/dev/null</em> or <em>/dev/random</em></p>
</dd>
</dl>

<p>Let’s now see <code>devfs</code> in action. For example, assume you want to get a random
string. You could do something like the following:</p>

<pre data-type="programlisting" data-code-language="shell">tr -dc A-Za-z0-9 &lt; /dev/urandom <code class="p">|</code> head -c <code class="m">42</code></pre>

<p>The previous command generates a 42-character random sequence containing uppercase
and lowercase as well as numerical characters. And while <em>/dev/urandom</em>
looks like a file and can be used like one, it indeed is a special
file that, using a number of sources, generates (more or less) random
output.</p>

<p>What do you think about the following command:</p>

<pre data-type="programlisting" data-code-language="shell"><code class="nb">echo</code> <code class="s2">"something"</code> &gt; /dev/tty</pre>

<p>That’s right! The string “something” appeared on your display, and that is by
design. <em>/dev/tty</em> stands for the terminal, and with that command
we sent something (quite literally) to it.<a data-type="indexterm" data-startref="ix_ch05-asciidoc8" id="idm45805434422944"/><a data-type="indexterm" data-startref="ix_ch05-asciidoc7" id="idm45805434422336"/></p>

<p>With a good understanding of filesystems and their features,
let’s now turn our attention to filesystems that you want to use to manage
regular files such as documents and data files.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Regular Files"><div class="sect1" id="regular-files">
<h1>Regular Files</h1>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="regular files" id="ix_ch05-asciidoc12"/>In this section, we focus on regular files and
<a href="https://oreil.ly/LOuvP">filesystems</a>
for such file types. Most of the day-to-day files we’re dealing with
when working fall into this category: office documents, YAML and JSON
configuration files, images (PNG, JPEG, etc.), source code, plain text files, and so on.</p>

<p>Linux comes with a wealth of options. We’ll focus on local filesystems, both
those native for Linux as well as those in other operating systems
(such as Windows/DOS) that Linux allows you to use. First, let’s have a
look at some common filesystems.</p>








<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Common Filesystems"><div class="sect2" id="common-regular-fs">
<h2>Common Filesystems</h2>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="common" id="ix_ch05-asciidoc13"/>The term <em>common filesystem</em> doesn’t have a formal definition. It’s simply
an umbrella term for filesystems that are either the defaults used in Linux
distributions or widely used in storage devices such as removable devices
(USB sticks and SD cards) or read-only devices, like CDs and DVDs.</p>

<p>In <a data-type="xref" href="#tab-fstypesregular">Table 5-5</a> I provide a quick overview and comparison
of some common filesystems that enjoy in-kernel support. Later in this section,
we’ll review some popular filesystems in greater detail.</p>
<table id="tab-fstypesregular">
<caption><span class="label">Table 5-5. </span>Common filesystems for regular files</caption>
<thead>
<tr>
<th>Filesystem</th>
<th>Linux support since</th>
<th>File size</th>
<th>Volume size</th>
<th>Number of files</th>
<th>Filename length</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><a href="https://oreil.ly/cL9W7"><code>ext2</code></a></p></td>
<td><p>1993</p></td>
<td><p>2 TB</p></td>
<td><p>32 TB</p></td>
<td><p>10<sup>18</sup></p></td>
<td><p>255 characters</p></td>
</tr>
<tr>
<td><p><a href="https://oreil.ly/IEnxW"><code>ext3</code></a></p></td>
<td><p>2001</p></td>
<td><p>2 TB</p></td>
<td><p>32 TB</p></td>
<td><p>variable</p></td>
<td><p>255 characters</p></td>
</tr>
<tr>
<td><p><a href="https://oreil.ly/482ku"><code>ext4</code></a></p></td>
<td><p>2008</p></td>
<td><p>16 TB</p></td>
<td><p>1 EB</p></td>
<td><p>4 billion</p></td>
<td><p>255 characters</p></td>
</tr>
<tr>
<td><p><a href="https://oreil.ly/gJQex"><code>btrfs</code></a></p></td>
<td><p>2009</p></td>
<td><p>16 EB</p></td>
<td><p>16 EB</p></td>
<td><p>2<sup>18</sup></p></td>
<td><p>255 characters</p></td>
</tr>
<tr>
<td><p><a href="https://oreil.ly/5LHGl">XFS</a></p></td>
<td><p>2001</p></td>
<td><p>8 EB</p></td>
<td><p>8 EB</p></td>
<td><p>2<sup>64</sup></p></td>
<td><p>255 characters</p></td>
</tr>
<tr>
<td><p><a href="https://oreil.ly/HH1Lb">ZFS</a></p></td>
<td><p>2006</p></td>
<td><p>16 EB</p></td>
<td><p>2<sup>128</sup> Bytes</p></td>
<td><p>10<sup>14</sup> files per directory</p></td>
<td><p>255 characters</p></td>
</tr>
<tr>
<td><p>NTFS</p></td>
<td><p>1997</p></td>
<td><p>16 TB</p></td>
<td><p>256 TB</p></td>
<td><p>2<sup>32</sup></p></td>
<td><p>255 characters</p></td>
</tr>
<tr>
<td><p><code>vfat</code></p></td>
<td><p>1995</p></td>
<td><p>2 GB</p></td>
<td><p>N/A</p></td>
<td><p>2<sup>16</sup> per directory</p></td>
<td><p>255 characters</p></td>
</tr>
</tbody>
</table>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The information provided in <a data-type="xref" href="#tab-fstypesregular">Table 5-5</a> is meant to give you a
rough idea about the filesystems. Sometimes it’s hard to pinpoint the exact
time a filesystem would be officially considered part of Linux; sometimes
the numbers make sense only with the relevant context applied. For example,
there are differences between theoretical limits and implementation.</p>
</div>

<p>Now let’s take a closer look at some widely used filesystems for regular files:</p>
<dl>
<dt><a href="https://oreil.ly/Ot9DI"><code>ext4</code></a></dt>
<dd>
<p><a data-type="indexterm" data-primary="ext4 filesystem" id="idm46298356534544"/><a data-type="indexterm" data-primary="filesystem" data-secondary="ext4" id="idm46298356533840"/>A widely used filesystem,
used by default in many distributions nowadays. It’s a backward-compatible
evolution of <code>ext3</code>. Like <code>ext3</code>, it offers journaling—that is, changes
are recorded in a log so that in the worst-case scenario (think: power outage),
the recovery is fast. It’s a great general-purpose choice. See the
<a href="https://oreil.ly/9kSXn"><code>ext4</code> manual</a> for usage.</p>
</dd>
<dt><a href="https://oreil.ly/WzHIZ">XFS</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="filesystem" data-secondary="XFS" id="idm46298356529120"/><a data-type="indexterm" data-primary="XFS" id="idm46298356528144"/>A journaling filesystem that
was originally designed by Silicon Graphics (SGI) for their workstations
in the early 1990s. Offering support for large files and high-speed I/O,
it’s now used, for example, in the Red Hat distributions family.</p>
</dd>
<dt class="pagebreak-before less_space"><a href="https://oreil.ly/ApA2z">ZFS</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="filesystem" data-secondary="ZFS" id="idm46298356525104"/><a data-type="indexterm" data-primary="ZFS" id="idm46298356524128"/>Originally developed by Sun Microsystems
in 2001, ZFS combines filesystem and volume manager functionality. While now there
is the <a href="https://oreil.ly/7itzs">OpenZFS project</a>,
offering a path forward in an open source context, there are some concerns about
<a href="https://oreil.ly/mM8du">ZFS’s integration with Linux</a>.</p>
</dd>
<dt><a href="https://oreil.ly/sfUa3">FAT</a></dt>
<dd>
<p>This is really a family of
FAT filesystems for
<a data-type="indexterm" data-primary="FAT filesystems" id="idm46298356520272"/><a data-type="indexterm" data-primary="filesystem" data-secondary="FAT" id="idm46298356519568"/>Linux, with <code>vfat</code> being used most often. The main use case is
interoperability with Windows systems, as well as removable media that uses
FAT. Many of the native considerations around volumes do not apply.<a data-type="indexterm" data-startref="ix_ch05-asciidoc13" id="idm46298356518080"/></p>
</dd>
</dl>

<p>Drives are not the only place one can store data, so let’s have a look at
in-memory options.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="In-Memory Filesystems"><div class="sect2" id="in-memory-fs">
<h2>In-Memory Filesystems</h2>

<p><a data-type="indexterm" data-primary="filesystem" data-secondary="in-memory" id="idm45805434313184"/><a data-type="indexterm" data-primary="in-memory filesystems" id="idm45805434312208"/>There are a number of in-memory filesystems available; some are general
purpose and others have very specific use cases. In the following, we list
some widely used in-memory filesystems (in alphabetical order):</p>
<dl>
<dt><a href="https://oreil.ly/j30dd"><code>debugfs</code></a></dt>
<dd>
<p><a data-type="indexterm" data-primary="debugfs" id="idm45805434308640"/>A special-purpose filesystem used for debugging; usually mounted with
  <code>mount -t debugfs none /sys/kernel/debug</code>.</p>
</dd>
<dt><a href="https://oreil.ly/jZi4I"><code>loopfs</code></a></dt>
<dd>
<p><a data-type="indexterm" data-primary="loopfs" id="idm45805434305712"/>Allows mapping
  a filesystem to blocks rather than devices. See also a <a href="https://oreil.ly/kMZ7j">mail
  thread on the background</a>.</p>
</dd>
<dt><code>pipefs</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="pipefs" id="idm45805434302912"/>A special (pseudo) filesystem mounted on <code>pipe:</code> that enables pipes.</p>
</dd>
<dt><code>sockfs</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="sockfs" id="idm45805434300352"/>Another special (pseudo) filesystem that makes network sockets
  look like files, sitting between the syscalls and the
  <a href="https://oreil.ly/ANDjr">sockets</a>.</p>
</dd>
<dt><a href="https://oreil.ly/g1WsU"><code>swapfs</code></a></dt>
<dd>
<p><a data-type="indexterm" data-primary="swapfs" id="idm45805434297120"/>Used to realize swapping
  (not mountable).</p>
</dd>
<dt><a href="https://oreil.ly/ICkgj"><code>tmpfs</code></a></dt>
<dd>
<p><a data-type="indexterm" data-primary="tmpfs" id="idm45805434294544"/>A general-purpose filesystem that keeps file data in kernel caches.
  It’s fast but nonpersistent (power off means data is lost).</p>
</dd>
</dl>

<p>Let’s move on to a special category of filesystems, specifically relevant in the
context of <a data-type="xref" href="ch06.xhtml#containers">“Containers”</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Copy-on-Write Filesystems"><div class="sect2" id="cowfs">
<h2>Copy-on-Write Filesystems</h2>

<p><a data-type="indexterm" data-primary="copy on write (CoW) filesystems" id="ix_ch05-asciidoc14"/><a data-type="indexterm" data-primary="filesystem" data-secondary="CoW" id="ix_ch05-asciidoc15"/>Copy-on-write (CoW) is a nifty concept to increase I/O speed and at the same time
use less space. The way it works is depicted in <a data-type="xref" href="#fig-cow-concept">Figure 5-3</a>, with further explanation in the passage that follows.</p>

<figure><div id="fig-cow-concept" class="figure">
<img src="Images/lmlx_0503.png" alt="lmlx 0503" width="600" height="481"/>
<h6><span class="label">Figure 5-3. </span>The CoW principle in action</h6>
</div></figure>
<ol>
<li>
<p>The original file, File 1, consisting of blocks A, B, and C, is copied
to a file called File 2. Rather than copying the actual blocks, only the
metadata (pointers to the blocks) is copied. This is fast and doesn’t use
up much space since only metadata is created.</p>
</li>
<li>
<p>When File 2 is modified (let’s say something in block C is changed),
only then is block C copied: a new block called C′ is created, and
while File 2 still points to (uses) the unmodified blocks A and B,
it now uses a new block (C′) to capture new data.</p>
</li>

</ol>

<p><a data-type="indexterm" data-primary="union mounts" id="idm45805434282592"/>Before we get to implementations, we need to understand a second concept relevant
in this context:
<a href="https://oreil.ly/dh6vW">union mounts</a>. This is the idea that
you can combine (mount) multiple directories into one location so that, to the user
of the resulting directory, it appears that said directory contains the combined
content (or: union) of all the participating directories. With union mounts, you
often come across the terms <em>upper filesystem</em> and <em>lower filesystem</em>, hinting at the
layering order of the mounts. You’ll find more details in the article
<a href="https://oreil.ly/yqV9H">“Unifying Filesystems with Union Mounts”</a>.</p>

<p>With union mounts, the devil is in the details. You have to come up with rules
around what happens when a file exists in multiple places or what writing to or removing files means.</p>

<p>Let’s have a quick look at implementations of CoW in the context of Linux filesystems.
We’ll have a closer look at some of these in the context of <a data-type="xref" href="ch06.xhtml#running-apps">Chapter 6</a>,
when we discuss their use as a building block for container images.</p>
<dl>
<dt><a href="https://oreil.ly/rWKZO">Unionfs</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="filesystem" data-secondary="Unionfs" id="idm45805434275152"/><a data-type="indexterm" data-primary="Unionfs" id="idm45805434274176"/>Originally developed at Stony Brook University,
Unionfs implements a union mount for CoW filesystems. It allows you to
transparently overlay files and directories from different filesystems using
priorities at mount time. It was widely popular and used in the context of
CD-ROMs and DVDs.</p>
</dd>
<dt><a href="https://oreil.ly/5HzmC">OverlayFS</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="filesystem" data-secondary="OverlayFS" id="idm45805434271520"/><a data-type="indexterm" data-primary="OverlayFS" id="idm45805434270544"/>A union mount filesystem implementation for Linux introduced in
2009 and added to the kernel in 2014. With OverlayFS, once a file is opened,
all operations are directly handled by the underlying (lower or upper) filesystems.</p>
</dd>
<dt><a href="https://oreil.ly/kdjge">AUFS</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="advanced multilayered unification filesystem (AUFS)" id="idm45805434267952"/><a data-type="indexterm" data-primary="AUFS (advanced multilayered unification filesystem)" id="idm45805434267152"/><a data-type="indexterm" data-primary="filesystem" data-secondary="AUFS" id="idm45805434266448"/>Another attempt to implement an in-kernel union mount, AUFS (short for advanced multilayered unification
filesystem; originally AnotherUnionFS) has not been merged into
the kernel yet. It is used to default in Docker (see <a data-type="xref" href="ch06.xhtml#docker">“Docker”</a>; nowadays Docker
defaults to OverlayFS with storage driver 
<span class="keep-together"><code>overlay2</code>).</span></p>
</dd>
<dt><a href="https://oreil.ly/z1uxq"><code>btrfs</code></a></dt>
<dd>
<p><a data-type="indexterm" data-primary="btrfs (b-tree filesystem)" id="idm45805434261808"/><a data-type="indexterm" data-primary="filesystem" data-secondary="btrfs" id="idm45805434260912"/>Short for b-tree
filesystem (and pronounced <em>butterFS</em> or <em>betterFS</em>), <code>btrfs</code> is a CoW initially
designed by Oracle Corporation. Today, a number of companies contribute to
the <code>btrfs</code> development, including Facebook, Intel, SUSE, and Red Hat.</p>

<p>It comes with a number of features such as snapshots (for software-based RAID)
and automatic detection of silent data corruptions. This makes <code>btrfs</code> very
suitable for professional environments—for example, on a server<a data-type="indexterm" data-startref="ix_ch05-asciidoc15" id="idm45805434257168"/><a data-type="indexterm" data-startref="ix_ch05-asciidoc14" id="idm45805434256464"/>.<a data-type="indexterm" data-startref="ix_ch05-asciidoc12" id="idm45805434255664"/></p>
</dd>
</dl>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45805434254704">
<h1>Conclusion</h1>

<p>In this chapter, we discussed files and filesystems in Linux. Filesystems
are a great and flexible way to organize access to information in a
hierarchical manner. Linux has many technologies and projects around filesystems.
Some are open source based, but there is also a range of commercial offerings.</p>

<p>We discussed the basic building blocks, from drives to partitions and volumes.
Linux realizes the “everything is a file” abstraction using VFS, supporting
virtually any kind of filesystem, local or remote.</p>

<p>The kernel uses pseudo filesystems such as <em>/proc</em> and <em>/sys</em> to expose information
about processes or devices. You can interact with these (in-memory) filesystems
that represent kernel APIs just like with filesystems such as <code>ext4</code> (that you use
to store files).</p>

<p>We then moved on to regular files and filesystems, where we compared common local
filesystem options, as well as in-memory and CoW filesystem basics. Linux’s
filesystem support is comprehensive, allowing you to use (at least read) a
range of fil⁠e­systems, including those originating from other operating systems
such as Windows.</p>

<p>You can dive deeper into the topics covered in this chapter with the following resources:</p>
<dl>
<dt>Basics</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/8a3Zr">“UNIX File Systems: How UNIX Organizes and Accesses Files on Disk”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/aFqjg">“KHB: A Filesystems Reading List”</a></p>
</li>
</ul>
</dd>
<dt>VFS</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/pnvQ4">“Overview of the Linux Virtual File System”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/sqSHK">“Introduction to the Linux Virtual Filesystem (VFS)”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/kOfU1">“LVM” on ArchWiki</a></p>
</li>
<li>
<p><a href="https://oreil.ly/Ds7me">“LVM2 Resource Page”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/UTFpL">“How to Use GUI LVM Tools”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/osXbo">“Linux Filesystem Hierarchy”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/sFdVo">“Persistent BPF Objects”</a></p>
</li>
</ul>
</dd>
<dt>Regular files</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/Y3rAh">“Filesystem Efficiency—Comparison of EXT4, XFS, BTRFS, and ZFS” thread on reddit</a></p>
</li>
<li>
<p><a href="https://oreil.ly/ZrPci">“Linux Filesystem Performance Tests”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/DBboM">“Comparison of File Systems for an SSD” thread on Linux.org</a></p>
</li>
<li>
<p><a href="https://oreil.ly/Odkls">“Kernel Korner—Unionfs: Bringing Filesystems Together”</a></p>
</li>
<li>
<p><a href="https://oreil.ly/TLylF">“Getting Started with btrfs for Linux”</a></p>
</li>
</ul>
</dd>
</dl>

<p>Equipped with knowledge around filesystems, we’re now ready to
bring things together and focus on how to manage and launch applications.<a data-type="indexterm" data-startref="ix_ch05-asciidoc0" id="idm45805434226256"/></p>
</div></section>







</div></section></div></body></html>