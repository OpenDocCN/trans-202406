<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 14. Role-Based Access Control for Kubernetes" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapterbac_id">
<h1><span class="label">Chapter 14. </span>Role-Based Access Control for Kubernetes</h1>
<p>At this point, nearly every Kubernetes cluster you encounter has role-based access control (RBAC) enabled. <a data-primary="RBAC (role-based access control)" data-type="indexterm" id="ix_RBAC"/>So you have likely encountered RBAC before. Perhaps you initially couldn’t access your cluster until you used some magical command to add a RoleBinding to map a user to a role. Even though you may have had some exposure to RBAC, you may not have had a great deal of experience understanding RBAC in Kubernetes, including what it is for and how to use it.<a data-primary="role-based access control" data-see="RBAC" data-type="indexterm" id="idm45664074264880"/></p>
<p>Role-based access control provides a mechanism for restricting both access to and actions on Kubernetes APIs to ensure that only authorized users have access. RBAC is a critical component to both harden access to the Kubernetes cluster where you are deploying your application and (possibly more importantly) prevent unexpected accidents where one person in the wrong namespace mistakenly takes down production when they think they are destroying their test cluster.<a data-primary="access control" data-see="RBAC (role-based access control)" data-type="indexterm" id="idm45664074263104"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While RBAC can be quite useful in limiting access to the Kubernetes API, it’s important to remember that anyone who can run arbitrary code inside the Kubernetes cluster can effectively obtain root privileges on the entire cluster. <a data-primary="security" data-secondary="attacker gaining root privileges" data-type="indexterm" id="idm45664074260928"/><a data-primary="root privileges" data-type="indexterm" id="idm45664074259984"/>There are approaches that you can take to make such attacks harder and more expensive, and a correct RBAC setup is part of this defense. But if you are focused on hostile multitenant security, RBAC by itself is sufficient to protect you. <a data-primary="hypervisors" data-secondary="isolating Pods for multitenant security" data-type="indexterm" id="idm45664074258928"/>You must isolate the Pods running in your cluster to provide effective multitenant security. Generally this is done using hypervisor isolated containers or a container sandbox.</p>
</div>
<p>Before we dive into the details of RBAC in Kubernetes, it’s valuable to have a high-level understanding of RBAC as a concept, as well as authentication and authorization more generally.</p>
<p>Every request to Kubernetes is first <em>authenticated</em>. Authentication provides the identity of the caller issuing the request. <a data-primary="authentication" data-type="indexterm" id="idm45664074256352"/>It could be as simple as saying that the request is unauthenticated, or it could integrate deeply with a pluggable authentication provider (e.g., Azure Active Directory) to establish an identity within that third-party system. Interestingly enough, Kubernetes does not have a built-in identity store, focusing instead on integrating other identity sources within itself.</p>
<p>Once users have been authenticated, the authorization phase determines whether they are authorized to perform the request.<a data-primary="authorization" data-type="indexterm" id="idm45664074254992"/> Authorization is a combination of the identity of the user, the resource (effectively the HTTP path), and the verb or action the user is attempting to perform. If the particular user is authorized to perform that action on that resource, then the request is allowed to proceed. Otherwise, an HTTP 403 error is returned. Let’s dive into this process.</p>
<section data-pdf-bookmark="Role-Based Access Control" data-type="sect1"><div class="sect1" id="idm45664074254032">
<h1>Role-Based Access Control</h1>
<p>To properly manage access in Kubernetes, it’s critical to understand how identity, roles, and role bindings interact to control who can do what with which resources. At first, RBAC can seem like a challenge to understand, with a series of interconnected, abstract concepts; but once it’s understood, you can be confident in your ability to manage cluster access.</p>
<section data-pdf-bookmark="Identity in Kubernetes" data-type="sect2"><div class="sect2" id="idm45664074252032">
<h2>Identity in Kubernetes</h2>
<p>Every request to Kubernetes is associated with some identity. <a data-primary="RBAC (role-based access control)" data-secondary="identity in Kubernetes" data-type="indexterm" id="idm45664074250304"/><a data-primary="identity in Kubernetes" data-type="indexterm" id="idm45664074249232"/>Even
a request with no identity is associated with the <code>system:unauthenticated</code>
group.<a data-primary="system:unauthenticated group" data-type="indexterm" id="idm45664074247984"/> Kubernetes makes a distinction between user identities and service
account identities. <a data-primary="service accounts" data-type="indexterm" id="idm45664074246992"/>Service accounts are created and managed by Kubernetes
itself and are generally associated with components running inside the cluster.
User accounts <a data-primary="user accounts" data-type="indexterm" id="idm45664074246032"/>are all other
accounts associated with actual users of the cluster, and often include automation like
continuous delivery services that run outside the cluster.</p>
<p>Kubernetes uses a generic interface for authentication providers.<a data-primary="authentication" data-secondary="generic interface for providers" data-type="indexterm" id="idm45664074244848"/>
Each of the providers supplies a username and, optionally,
the set of groups to which the user belongs. Kubernetes supports a number of authentication providers, including:</p>
<ul>
<li>
<p>HTTP Basic Authentication (largely deprecated)</p>
</li>
<li>
<p>x509 client certificates</p>
</li>
<li>
<p>Static token files on the host</p>
</li>
<li>
<p>Cloud authentication providers, such as Azure Active Directory and AWS Identity and Access Management (IAM)<a data-primary="cloud" data-secondary="authentication providers" data-type="indexterm" id="idm45664074239424"/></p>
</li>
<li>
<p>Authentication webhooks</p>
</li>
</ul>
<p>While most managed Kubernetes <a data-primary="authentication" data-secondary="providers supported by Kubernetes" data-type="indexterm" id="idm45664074237008"/>installations configure authentication for
you, if you are deploying your own authentication, you will need to configure flags on the Kubernetes API server appropriately.</p>
<p>You should always use different identities for different applications in your
cluster. For example, you should have one identity for your production
frontends, a different identity for the production backends, and all production
identities should be distinct from development identities. You should also
have different identities for different clusters. All of these identities
should be machine identities that are not shared with users.<a data-primary="Azure Active Directory" data-type="indexterm" id="idm45664074235232"/><a data-primary="Pods" data-secondary="identity providers for" data-type="indexterm" id="idm45664074234528"/><a data-primary="service accounts" data-secondary="storing identities in" data-type="indexterm" id="idm45664074233584"/> You can either
use Kubernetes Service Accounts for achieving this, or you can use a Pod
identity provider supplied by your identity system; for example, Azure Active
Directory supplies an <a href="https://oreil.ly/YLymu">open source identity provider for Pods</a> as do other popular identity
providers.</p>
</div></section>
<section data-pdf-bookmark="Understanding Roles and Role Bindings" data-type="sect2"><div class="sect2" id="idm45664074231664">
<h2>Understanding Roles and Role Bindings</h2>
<p>Identity is just the beginning of authorization in Kubernetes.<a data-primary="RBAC (role-based access control)" data-secondary="understanding roles and role bindings" data-type="indexterm" id="idm45664074230432"/> Once Kubernetes knows the identity of the request, it needs to determine if the request
is authorized for that user. To achieve this, it uses roles and role bindings.</p>
<p>A <em>role</em> is a set of abstract capabilities.<a data-primary="roles" data-type="indexterm" id="idm45664074227984"/> For example, the <code>appdev</code> role
might represent the ability to create Pods and Services.
A <em>role binding</em> is an assignment of a role to one or more identities.<a data-primary="role bindings" data-type="indexterm" id="idm45664074226176"/>
Thus, binding the <code>appdev</code> role to the user identity <code>alice</code> indicates that Alice has the ability to create Pods and Services.</p>
</div></section>
<section data-pdf-bookmark="Roles and Role Bindings in Kubernetes" data-type="sect2"><div class="sect2" id="idm45664074224336">
<h2>Roles and Role Bindings in Kubernetes</h2>
<p>In Kubernetes, two pairs of related resources represent roles
and role bindings.<a data-primary="RBAC (role-based access control)" data-secondary="roles and role bindings in Kubernetes" data-type="indexterm" id="idm45664074222624"/><a data-primary="Role object" data-type="indexterm" id="idm45664074221568"/><a data-primary="RoleBinding object" data-type="indexterm" id="idm45664074220896"/> One pair is scoped to a namespace (Role and RoleBinding), while the other pair is scoped to the cluster (ClusterRole and ClusterRoleBinding).<a data-primary="ClusterRoleBindings" data-type="indexterm" id="idm45664074219936"/><a data-primary="ClusterRoles" data-type="indexterm" id="idm45664074219264"/></p>
<p>Let’s examine Role and RoleBinding first. Role resources
are namespaced and represent capabilities within that single namespace.
You cannot use namespaced roles <a data-primary="Role object" data-secondary="namespaces and" data-type="indexterm" id="idm45664074218208"/><a data-primary="namespaces" data-secondary="roles and" data-type="indexterm" id="idm45664074217232"/>for nonnamespaced resources (e.g.,
CustomResourceDefinitions), and binding a RoleBinding to a role only provides
authorization within the Kubernetes namespace that contains both the
Role and the RoleBinding.</p>
<p>As a concrete example, here is a simple role that gives an identity the ability to create and modify Pods and Services:</p>
<pre data-type="programlisting">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: pod-and-services
rules:
- apiGroups: [""]
  resources: ["pods", "services"]
  verbs: ["create", "delete", "get", "list", "patch", "update", "watch"]</pre>
<p>To bind this Role to the user <code>alice</code>, we need to create a RoleBinding that
looks as follows.<a data-primary="RoleBinding object" data-secondary="creating" data-type="indexterm" id="idm45664074213552"/> This role binding also binds the group <code>mydevs</code> to the
same role:</p>
<pre data-type="programlisting">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  namespace: default
  name: pods-and-services
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: alice
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: mydevs
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: pod-and-services</pre>
<p>Sometimes you need to create a role that applies to the entire
cluster, or you want to limit access to cluster-level resources. To achieve
this, you use the ClusterRole and ClusterRoleBinding resources. They
are largely identical to their namespaced peers, but are cluster-scoped.</p>
<section data-pdf-bookmark="Verbs for Kubernetes roles" data-type="sect3"><div class="sect3" id="idm45664074210000">
<h3>Verbs for Kubernetes roles</h3>
<p>Roles are defined in terms of both a resource (e.g., Pods) and<a data-primary="RBAC (role-based access control)" data-secondary="roles and role bindings in Kubernetes" data-tertiary="verbs for Kubernetes roles" data-type="indexterm" id="idm45664074208656"/> a verb
that describes an action that can be performed on that resource.<a data-primary="HTTP methods" data-type="indexterm" id="idm45664074207104"/> The
verbs correspond roughly to HTTP methods. The commonly used verbs in
Kubernetes RBAC are listed in <a data-type="xref" href="#kubernetesRBAC">Table 14-1</a>.</p>
<table id="kubernetesRBAC">
<caption><span class="label">Table 14-1. </span>Common Kubernetes RBAC verbs</caption>
<thead>
<tr>
<th>Verb</th>
<th>HTTP method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>create</code></p></td>
<td><p><code>POST</code></p></td>
<td><p>Create a new resource.</p></td>
</tr>
<tr>
<td><p><code>delete</code></p></td>
<td><p><code>DELETE</code></p></td>
<td><p>Delete an existing resource.</p></td>
</tr>
<tr>
<td><p><code>get</code></p></td>
<td><p><code>GET</code></p></td>
<td><p>Get a resource.</p></td>
</tr>
<tr>
<td><p><code>list</code></p></td>
<td><p><code>GET</code></p></td>
<td><p>List a collection of resources.</p></td>
</tr>
<tr>
<td><p><code>patch</code></p></td>
<td><p><code>PATCH</code></p></td>
<td><p>Modify an existing resource via a partial change.</p></td>
</tr>
<tr>
<td><p><code>update</code></p></td>
<td><p><code>PUT</code></p></td>
<td><p>Modify an existing resource via a complete object.</p></td>
</tr>
<tr>
<td><p><code>watch</code></p></td>
<td><p><code>GET</code></p></td>
<td><p>Watch for streaming updates to a resource.</p></td>
</tr>
<tr>
<td><p><code>proxy</code></p></td>
<td><p><code>GET</code></p></td>
<td><p>Connect to resource via a streaming WebSocket proxy.</p></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Using built-in roles" data-type="sect3"><div class="sect3" id="idm45664074180944">
<h3>Using built-in roles</h3>
<p>Designing your own roles can be complicated and time-consuming.<a data-primary="RBAC (role-based access control)" data-secondary="roles and role bindings in Kubernetes" data-tertiary="built-in roles, using" data-type="indexterm" id="idm45664074179568"/> Kubernetes has a
large number of built-in cluster roles for well-known system identities (e.g., a scheduler) that require a known set of capabilities.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get clusterroles" data-type="indexterm" id="idm45664074177984"/><a data-primary="clusters" data-secondary="built-in cluster roles" data-type="indexterm" id="idm45664074176768"/>
You can view these by running:</p>
<pre data-type="programlisting">$ <strong>kubectl get clusterroles</strong></pre>
<p>While most of these built-in roles are for system utilities, four are designed for generic end users:</p>
<ul>
<li>
<p>The <code>cluster-admin</code> role provides complete access to the entire cluster.</p>
</li>
<li>
<p>The <code>admin</code> role provides complete access to a complete namespace.</p>
</li>
<li>
<p>The <code>edit</code> role allows an end user to modify resources in a namespace.</p>
</li>
<li>
<p>The <code>view</code> role allows for read-only access to a namespace.</p>
</li>
</ul>
<p>Most clusters already have numerous ClusterRole bindings<a data-primary="ClusterRoleBindings" data-type="indexterm" id="idm45664074167712"/> set up, and
you can view these bindings with <code>kubectl get clusterrolebindings</code>.</p>
</div></section>
<section data-pdf-bookmark="Auto-reconciliation of built-in roles" data-type="sect3"><div class="sect3" id="idm45664074166176">
<h3>Auto-reconciliation of built-in roles</h3>
<p>When the Kubernetes API server starts up, it automatically installs a
number of default ClusterRoles that are defined in the code of the API
server itself.<a data-primary="RBAC (role-based access control)" data-secondary="roles and role bindings in Kubernetes" data-tertiary="auto-reconciliation of built-in roles" data-type="indexterm" id="idm45664074164880"/> This means that if you modify any built-in cluster role,
those modifications are transient. <span class="keep-together">Whenever</span> the API server is restarted (e.g., for an upgrade), your changes will be <span class="keep-together">overwritten</span>.</p>
<p>To prevent this from happening, before you make any other modifications, you need to add the
<code>rbac.authorization.kubernetes.io/autoupdate</code> annotation with a value
of <code>false</code> to the built-in ClusterRole resource.<a data-primary="ClusterRoles" data-secondary="auto-reconciliation of built-in roles" data-type="indexterm" id="idm45664074160480"/><a data-primary="rbac.authorization.kubernetes.io/autoupdate annotation" data-type="indexterm" id="idm45664074159440"/> If this annotation is set to <code>false</code>, the API server
will not overwrite the modified ClusterRole resource.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>By default, the Kubernetes API server installs a cluster role that allows
<code>system:unauthenticated</code> users access to the API server’s API discovery
endpoint. <a data-primary="system:unauthenticated group" data-type="indexterm" id="idm45664074156560"/>For any cluster exposed to a hostile environment (e.g., the
public internet) this is a bad idea, and there has been at least one serious
security vulnerability via this exposure.<a data-primary="services" data-secondary="running in hostile environment, not allowing anonymous authentication" data-type="indexterm" id="idm45664074155392"/> If you are running
a Kubernetes service on the public internet or an other hostile environment,
you should ensure that the <code>--anonymous-auth=false</code> flag is set on your
API server.</p>
</div>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Techniques for Managing RBAC" data-type="sect1"><div class="sect1" id="idm45664074153360">
<h1>Techniques for Managing RBAC</h1>
<p>Managing RBAC for a cluster can be complicated and frustrating.<a data-primary="RBAC (role-based access control)" data-secondary="management techniques" data-type="indexterm" id="idm45664074152080"/> Possibly
more concerning is that misconfigured RBAC can lead to security issues.
Fortunately, there are several tools and techniques that make managing RBAC easier.</p>
<section data-pdf-bookmark="Testing Authorization with can-i" data-type="sect2"><div class="sect2" id="idm45664074150704">
<h2>Testing Authorization with can-i</h2>
<p>The first useful tool is the <code>auth can-i</code> command for <code>kubectl</code>. <a data-primary="RBAC (role-based access control)" data-secondary="management techniques" data-tertiary="testing authorization with can-i" data-type="indexterm" id="idm45664074148000"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="auth can-i" data-type="indexterm" id="idm45664074146640"/><a data-primary="authorization" data-secondary="testing  auth can-i command" data-type="indexterm" id="idm45664074145424"/><a data-primary="can-i command, testing authorization" data-type="indexterm" id="idm45664074144464"/>This tool
is used for testing whether a specific user can perform a specific action.
You can use <code>can-i</code> to validate configuration settings as you configure your
cluster, or you can ask users to use the tool to validate their access
when filing errors or bug reports.<a data-primary="configurations" data-secondary="using can-i command to validate settings" data-type="indexterm" id="idm45664074143152"/></p>
<p>In its simplest usage, the <code>can-i</code> command takes a verb and a resource. For example, this command will indicate if the current <code>kubectl</code> user is authorized to create Pods:</p>
<pre data-type="programlisting">$ <strong>kubectl auth can-i create pods</strong></pre>
<p>You can also test subresources like logs or<a data-primary="port forwarding" data-secondary="testing authorization with can-i command" data-type="indexterm" id="idm45664074139328"/><a data-primary="subresources, testing authorization for" data-type="indexterm" id="idm45664074138256"/> port-forwarding with the
<code>--subresource</code> command-line flag:</p>
<pre data-type="programlisting">$ <strong>kubectl auth can-i get pods --subresource=logs</strong></pre>
</div></section>
<section data-pdf-bookmark="Managing RBAC in Source Control" data-type="sect2"><div class="sect2" id="idm45664074135840">
<h2>Managing RBAC in Source Control</h2>
<p>Like all resources in Kubernetes, RBAC resources are modeled using YAML.<a data-primary="RBAC (role-based access control)" data-secondary="management techniques" data-tertiary="managing RBAC in source control" data-type="indexterm" id="idm45664074134384"/><a data-primary="source control" data-secondary="managing role-based access control in" data-type="indexterm" id="idm45664074133056"/> Given this text-based representation, it makes sense to store these resources in version control, which allows for accountability, auditability, and rollback.</p>
<p>The <code>kubectl</code> command-line tool provides a <code>reconcile</code> command
that operates somewhat like <code>kubectl apply</code> and will reconcile a set of roles and role bindings with the current state of the cluster.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="reconcile" data-type="indexterm" id="idm45664074130144"/> You can run:</p>
<pre data-type="programlisting">$ <strong>kubectl auth reconcile -f some-rbac-config.yaml</strong></pre>
<p>If you want to see changes before they are made, you can add the <code>--dry-run</code> flag to the command to output, but not apply, the changes.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Advanced Topics" data-type="sect1"><div class="sect1" id="idm45664074126432">
<h1>Advanced Topics</h1>
<p>Once you orient to the basics of role-based access control, it is<a data-primary="RBAC (role-based access control)" data-secondary="advanced topics" data-type="indexterm" id="ix_RBACadv"/> relatively
easy to manage access to a Kubernetes cluster. But when managing a large
number of users or roles, there are additional advanced capabilities
you can use to manage RBAC at scale.</p>
<section data-pdf-bookmark="Aggregating ClusterRoles" data-type="sect2"><div class="sect2" id="idm45664074123376">
<h2>Aggregating ClusterRoles</h2>
<p>Sometimes you want to be able to define roles that are combinations of
other roles. <a data-primary="RBAC (role-based access control)" data-secondary="advanced topics" data-tertiary="aggregating ClusterRoles" data-type="indexterm" id="idm45664074121936"/><a data-primary="ClusterRoles" data-secondary="aggregating" data-type="indexterm" id="idm45664074120608"/>One option would be to simply clone all of the rules from one
ClusterRole into another ClusterRole, but this is complicated and
error-prone, since changes to one ClusterRole aren’t automatically
reflected in the other. Instead, Kubernetes RBAC supports the
usage of an <em>aggregation rule</em> to combine multiple roles in
a new role.<a data-primary="aggregation rule" data-type="indexterm" id="idm45664074118704"/> This new role combines all of the capabilities of
all of the aggregate roles, and any changes to any of the
constituent subroles will automatically be propogated back into the
aggregate role.</p>
<p>As with other aggregations or groupings in Kubernetes, the ClusterRoles to
be aggregated are specified using label selectors. <a data-primary="labels" data-secondary="label selectors" data-tertiary="specifying ClusterRoles to be aggregated" data-type="indexterm" id="idm45664074117120"/>In this particular case,
the <code>aggregationRule</code> field in the ClusterRole resource contains a
<code>clusterRoleSelector</code> field, which in turn is a label selector.<a data-primary="clusterRoleSelector field" data-type="indexterm" id="idm45664074114784"/> All
ClusterRole resources that match this selector are dynamically aggregated
into the <code>rules</code> array in the aggregate ClusterRole resource.</p>
<p>A best practice for managing ClusterRole resources is to create a number
of fine-grained cluster roles and then aggregate them to form
higher-level or broader cluster roles. This is how the built-in
cluster roles are defined.<a data-primary="edit role" data-type="indexterm" id="idm45664074112880"/> For example, you can see that the built-in <code>edit</code> role looks like this:</p>
<pre data-type="programlisting">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: edit
  ...
aggregationRule:
  clusterRoleSelectors:
  - matchLabels:
      rbac.authorization.k8s.io/aggregate-to-edit: "true"
...</pre>
<p>This means that the <code>edit</code> role is defined to be the aggregate of all
ClusterRole objects that have a label of
<code>rbac.authorization.k8s.io/aggregate-to-edit</code> set to <code>true</code>.</p>
</div></section>
<section data-pdf-bookmark="Using Groups for Bindings" data-type="sect2"><div class="sect2" id="idm45664074108640">
<h2>Using Groups for Bindings</h2>
<p>When managing a large number of people in different organizations with<a data-primary="RBAC (role-based access control)" data-secondary="advanced topics" data-tertiary="using groups for bindings" data-type="indexterm" id="idm45664074107008"/><a data-primary="groups" data-secondary="using for role bindings" data-type="indexterm" id="idm45664074105648"/>
similar access to the cluster, it’s generally a best practice to use groups
to manage the roles that define access, rather than
individually adding bindings to specific identities.<a data-primary="Role object" data-secondary="binding a group to" data-type="indexterm" id="idm45664074104384"/><a data-primary="ClusterRoles" data-secondary="binding a group to" data-type="indexterm" id="idm45664074103440"/> When you bind a group
to a Role or ClusterRole, anyone who is a member of that
group gains access to the resources and verbs defined by that role. Thus,
to enable any individual to gain access to the group’s role, that individual needs to be added to the group.</p>
<p>Using groups is a preferred strategy for managing access at scale  for several reasons. The first is that in any large organization,
access to the cluster is defined in terms of the team that someone is
part of, rather than their specific identity. For example, someone who is part of the frontend operations team will need access to both view
and edit the resources associated with the frontends, while they may only
need view/read access to resources associated with the backend. Granting
privileges to a group makes the association between the specific team and its
capabilities clear. When granting roles to individuals, it’s much harder
to clearly understand the appropriate (i.e., minimal) privileges
required for each team, especially when an individual may be part of
multiple teams.</p>
<p>Additional benefits of binding roles to groups instead of individuals are
simplicity and consistency. When someone joins or leaves a team, it is
straightforward to simply add or remove them to or from a group in a single
operation. If you instead have to remove a number of different role bindings
for their identity, you may either remove too few or too many bindings,
resulting in unnecessary access or preventing them from being able to do
necessary actions. Additionally, because there is only a single set of group
role bindings to maintain, you don’t have to do lots of work to ensure that
all team members have the same, consistent set of permissions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Many cloud providers support integrations onto their identity and access management platforms so that users and groups from those platforms can be used in conjunction with Kubernetes RBAC.<a data-primary="cloud" data-secondary="integration into identity and access management systems by providers" data-type="indexterm" id="idm45664074100064"/></p>
</div>
<p>Many group systems enable “just in time” (JIT) access, such that people are only temporarily added to a group in response to an<a data-primary="just in time (JIT) access" data-type="indexterm" id="idm45664074098384"/>
event (say, a page in the middle of the night) rather than having standing
access. This means that you can both audit who had access at any particular
time and ensure that, in general, even a compromised identity can’t have
access to your production infrastructure.</p>
<p>Finally, in many cases, these same groups are used to manage access to other
resources, from facilities to documents and machine logins. Thus, using the
same groups for access control to Kubernetes dramatically simplifies
management.</p>
<p>To bind a group to a ClusterRole, use a Group kind for the <code>subject</code>
in the <span class="keep-together">binding</span>:</p>
<pre data-type="programlisting">...
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: my-great-groups-name
...</pre>
<p>In Kubernetes, groups are supplied by authentication providers.<a data-primary="authentication" data-secondary="groups supplied by authentication providers in Kubernetes" data-type="indexterm" id="idm45664074093728"/> There is
no strong notion of a group within Kubernetes, only that an identity can
be part of one or more groups, and those groups can be associated with
a Role or ClusterRole via a binding.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45664074092160">
<h1>Summary</h1>
<p>When you begin with a small cluster and a small team, it is sufficient to
have every member of the team have equivalent access to the cluster.<a data-primary="RBAC (role-based access control)" data-secondary="advanced topics" data-startref="ix_RBACadv" data-type="indexterm" id="idm45664074090736"/> But as
teams grow and products become more mission critical, limiting access to
parts of the cluster is crucial. In a well-designed cluster, access is limited to the minimal set of people and capabilities needed to efficiently
manage the applications in the cluster.</p>
<p>Understanding how Kubernetes implements RBAC and how those capabilities can
be used to control access to your cluster is important for both
developers and cluster administrators. As with building out testing infrastructure, best practice is to set up RBAC earlier rather
than later. It’s far easier to start with the right foundation than to try to retrofit it later on. Hopefully, the information in this chapter has provided the necessary grounding for adding RBAC to your cluster.<a data-primary="RBAC (role-based access control)" data-startref="ix_RBAC" data-type="indexterm" id="idm45664074088720"/></p>
</div></section>
</div></section></div></body></html>