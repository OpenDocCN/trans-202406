<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Configuration Options"><div class="chapter" id="configuration_options">
<h1><span class="label">Chapter 13. </span>Configuration Options</h1>

<blockquote>
<p>Compiler options:</p>

<p>Types and modules and oh my!</p>

<p><code>tsc</code> your way.</p></blockquote>

<p>TypeScript is highly configurable and made to adapt to all common JavaScript usage patterns.
It can work for projects ranging from legacy browser code to the most modern server environments.</p>

<p>Much of TypeScript’s configurability comes from its cornucopia of over 100 configuration options that can be provided via either:</p>

<ul>
<li>
<p>Command-line (CLI) flags passed to <code>tsc</code></p>
</li>
<li>
<p>“TSConfig” TypeScript configuration files</p>
</li>
</ul>

<p>This chapter is not intended as a full reference for all TypeScript configuration options.
Instead, I’d suggest treating this chapter as a tour of the most common options you’ll find yourself using.
I’ve included just the ones that tend to be more useful and widely used for most TypeScript project setups.
See <a href="https://aka.ms/tsc">aka.ms/tsc</a> for a full reference on each of these options and more.</p>






<section data-type="sect1" data-pdf-bookmark="tsc Options"><div class="sect1" id="idm45584672347520">
<h1>tsc Options</h1>

<p>Back<a data-type="indexterm" data-primary="tsc command" data-secondary="configuration options" id="tsc-config"/><a data-type="indexterm" data-primary="configuration options" data-secondary="tsc command" id="config-tsc"/> in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch01.xhtml#from_javascript_to_typescript">Chapter 1, “From JavaScript to TypeScript”</a>, you used <code>tsc index.ts</code> to compile an <em>index.ts</em> file.
The <code>tsc</code> command can take in most of TypeScript’s configuration options as <code>--</code> flags.</p>

<p>For example, to run <code>tsc</code> on an <em>index.ts</em> file and skip emitting an <em>index.js</em> file (so, only run type checking), pass the <code>--noEmit</code> flag:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">tsc</code> <code class="nx">index</code><code class="p">.</code><code class="nx">ts</code> <code class="o">--</code><code class="nx">noEmit</code></pre>

<p>You can run <code>tsc --help</code> to get a list of commonly used CLI flags.
The full list of <code>tsc</code> configuration options from <a href="https://aka.ms/tsc">aka.ms/tsc</a> is viewable with <code>tsc --all</code>.</p>








<section data-type="sect2" data-pdf-bookmark="Pretty Mode"><div class="sect2" id="idm45584672333168">
<h2>Pretty Mode</h2>

<p>The <code>tsc</code> CLI <a data-type="indexterm" data-primary="tsc command" data-secondary="pretty mode" id="idm45584672331120"/><a data-type="indexterm" data-primary="pretty mode (tsc command)" id="idm45584672318624"/>has the ability to output in a “pretty” mode: stylized with colors and spacing to make them easier to read.
It defaults to pretty mode if it detects that the output terminal supports colorful text.</p>

<p>Here’s an example of what <code>tsc</code> looks like printing two type errors from a file 
<span class="keep-together">(<a data-type="xref" href="#tsc_pretty_errors">Figure 13-1</a>).</span></p>

<figure><div id="tsc_pretty_errors" class="figure">
<img src="Images/lets_1301.png" alt="tsc reporting two errors with blue file names, yellow line and column numbers, and red squigglies." width="600" height="224"/>
<h6><span class="label">Figure 13-1. </span><code>tsc</code> reporting two errors with blue file names, yellow line and column numbers, and red squigglies</h6>
</div></figure>

<p>If you’d prefer CLI output that is more condensed and/or doesn’t have different colors, you can explicitly provide <code>--pretty false</code> to tell TypeScript to use a more terse, uncolored format (<a data-type="xref" href="#tsc_pretty_false_errors">Figure 13-2</a>).</p>

<figure><div id="tsc_pretty_false_errors" class="figure">
<img src="Images/lets_1302.png" alt="tsc reporting two errors in plain text." width="600" height="48"/>
<h6><span class="label">Figure 13-2. </span><code>tsc</code> reporting two errors in plain text</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Watch Mode"><div class="sect2" id="idm45584672309104">
<h2>Watch Mode</h2>

<p>My <a data-type="indexterm" data-primary="tsc command" data-secondary="watch mode" id="tsc-watch"/><a data-type="indexterm" data-primary="watch mode (tsc command)" id="watch-tsc"/>favorite way to use the <code>tsc</code> CLI is with its <code>-w</code>/<code>--watch</code> mode.
Instead of exiting once completed, watch mode will keep TypeScript running indefinitely and continuously updates your terminal with a real-time list of all the errors it sees.</p>

<p>Running in watch mode on a file that contains two errors is shown in <a data-type="xref" href="#tsc_watch_errors">Figure 13-3</a>.</p>

<figure><div id="tsc_watch_errors" class="figure">
<img src="Images/lets_1303.png" alt="tsc reporting two errors in watch mode." width="600" height="224"/>
<h6><span class="label">Figure 13-3. </span><code>tsc</code> reporting two errors in watch mode</h6>
</div></figure>

<p><a data-type="xref" href="#tsc_watch_fixed">Figure 13-4</a> shows <code>tsc</code> updating console output to indicate that the file was changed in a way to fix all errors.</p>

<figure><div id="tsc_watch_fixed" class="figure">
<img src="Images/lets_1304.png" alt="tsc reporting no errors in watch mode." width="600" height="54"/>
<h6><span class="label">Figure 13-4. </span><code>tsc</code> reporting no errors in watch mode</h6>
</div></figure>

<p>Watch mode is particularly useful when you’re working on large changes such as refactors across many files.
You can use TypeScript’s type errors as a checklist of sorts to see what still needs to be <a data-type="indexterm" data-primary="tsc command" data-secondary="configuration options" data-startref="tsc-config" id="idm45584672280960"/><a data-type="indexterm" data-primary="configuration options" data-secondary="tsc command" data-startref="config-tsc" id="idm45584672279712"/><a data-type="indexterm" data-primary="tsc command" data-secondary="watch mode" data-startref="tsc-watch" id="idm45584672278496"/><a data-type="indexterm" data-primary="watch mode (tsc command)" data-startref="watch-tsc" id="idm45584672277280"/>cleaned up.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="TSConfig Files"><div class="sect1" id="idm45584672276016">
<h1>TSConfig Files</h1>

<p>Instead of<a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="purpose of" id="config-tsconfig-purpose"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="purpose of" id="tsconfig-purpose"/> always providing all file names and configuration options to <code>tsc</code>, most configuration options may be specified in a <em>tsconfig.json</em> (“TSConfig”) file in a 
<span class="keep-together">directory.</span></p>

<p>The existence of a <em>tsconfig.json</em> indicates that the directory is the root of a TypeScript project.
Running <code>tsc</code> in a directory will read in any configuration options in that <em>tsconfig.json</em> file.</p>

<p>You can also pass <code>-p</code>/<code>--project</code> to <code>tsc</code> with a path to a directory containing a <em>tsconfig.json</em> or any file to have <code>tsc</code> use that instead:</p>

<pre data-type="programlisting" data-code-language="shell">tsc -p path/to/tsconfig.json</pre>

<p>TSConfig files are generally strongly recommended to be used for TypeScript projects whenever possible.
IDEs such as VS Code will respect their configuration when giving you IntelliSense features.</p>

<p>See <a href="https://aka.ms/tsconfig.json">aka.ms/tsconfig.json</a> for the full list of configuration options available in TSConfig files.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you don’t set an option in your <em>tsconfig.json</em>, don’t worry that TypeScript’s default setting for it may change and interfere with your project’s compilation settings.
This almost never happens and if it did, it would require a major version update to TypeScript and be called out in the release <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="purpose of" data-startref="config-tsconfig-purpose" id="idm45584672232208"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="purpose of" data-startref="tsconfig-purpose" id="idm45584672230880"/>notes.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="tsc --init"><div class="sect2" id="idm45584672229376">
<h2>tsc --init</h2>

<p>The <code>tsc</code> command line <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="creating" id="idm45584672260336"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="creating" id="idm45584672259056"/><a data-type="indexterm" data-primary="tsc command" data-secondary="--init command" data-secondary-sortas="init command" id="idm45584672258112"/><a data-type="indexterm" data-primary="--init command (tsc command)" data-primary-sortas="init command" id="idm45584672256896"/>includes an <code>--init</code> command to create a new <em>tsconfig.json</em> file.
That newly created TSConfig file will contain a link to the configuration docs as well as most of the allowed TypeScript configuration options with one-line comments briefly describing their use.</p>

<p>Running this command:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --init</pre>

<p>will generate a fully commented <em>tsconfig.json</em> file:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="cm">/* Visit https://aka.ms/tsconfig.json to read more about this file */</code><code class="w"/>
<code class="w">    </code><code class="c1">// ...</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>I recommend using <code>tsc --init</code> to create your configuration file on your first few TypeScript projects.
Its default values are applicable to most projects, and its documentation comments are helpful in understanding them.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="CLI Versus Configuration"><div class="sect2" id="idm45584672191952">
<h2>CLI Versus Configuration</h2>

<p>Looking <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="CLI vs." id="idm45584672190512"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="CLI vs." id="idm45584672189232"/><a data-type="indexterm" data-primary="tsc command" data-secondary="TSConfig files vs." id="idm45584672188288"/>through the TSConfig file created by <code>tsc --init</code>, you may notice that configuration options in that file are within a <code>"compilerOptions"</code> object.
Most options available in both the CLI and in TSConfig files fall into one of two categories:</p>
<dl>
<dt>Compiler</dt>
<dd>
<p>How each included file is compiled and/or type checked by TypeScript</p>
</dd>
<dt>File</dt>
<dd>
<p>Which files will or will not have TypeScript run on them</p>
</dd>
</dl>

<p>Other settings that we’ll talk about after those two categories, such as project references, generally are only available in TSConfig files.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If a setting is provided to the <code>tsc</code> CLI, such as a one-off change for a CI or production build, it will generally override any value specified in a TSConfig file.
Because IDEs generally read from the <em>tsconfig.json</em> in a directory for TypeScript settings, it’s recommended to put most configuration options in a <em>tsconfig.json</em> file.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="File Inclusions"><div class="sect1" id="idm45584672275424">
<h1>File Inclusions</h1>

<p>By <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="file inclusions" id="config-tsconfig-include"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="file inclusions" id="tsconfig-include"/><a data-type="indexterm" data-primary="file inclusions" id="file-include"/><a data-type="indexterm" data-primary="including files" id="include-file"/>default, <code>tsc</code> will run on all nonhidden <em>.ts</em> files (those whose names do not start with a <code>.</code>) in the current directory and any child directories, ignoring hidden directories and directories named <em>node_modules</em>.
TypeScript configurations can change that list of files to run on.</p>








<section data-type="sect2" data-pdf-bookmark="include"><div class="sect2" id="idm45584672172064">
<h2>include</h2>

<p>The <a data-type="indexterm" data-primary="include property" id="idm45584672148320"/>most common way to include files is with a top-level <code>"include"</code> property in a <em>tsconfig.json</em>.
It allows an array of strings that describes what directories and/or files to include in TypeScript compilation.</p>

<p>For example, this configuration file recursively includes all TypeScript source files in a <em>src/</em> directory relative to the <em>tsconfig.json</em>:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"include"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Glob wildcards are allowed in <code>include</code> strings for more fine-grained control of files to include:</p>

<ul>
<li>
<p><code>*</code> matches zero or more characters (excluding directory separators).</p>
</li>
<li>
<p><code>?</code> matches any one character (excluding directory separators).</p>
</li>
<li>
<p><code>**/</code> matches any directory nested to any levels.</p>
</li>
</ul>

<p>This configuration file allows only <em>.d.ts</em> files nested in a <em>typings/</em> directory and <em>src/</em> files with at least two characters in their name before an extension:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"include"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>
<code class="w">    </code><code class="s2">"typings/**/*.d.ts"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s2">"src/**/*??.*"</code><code class="w"/>
<code class="w">  </code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>For most projects, a simple <code>include</code> compiler option such as <code>["src"]</code> is generally sufficient.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="exclude"><div class="sect2" id="idm45584672085456">
<h2>exclude</h2>

<p>The <code>include</code> list<a data-type="indexterm" data-primary="exclude property" id="exclude-property"/> of files for a project sometimes includes files not meant for compilation by TypeScript.
TypeScript allows a TSConfig file to omit paths from <code>include</code> by specifying them in a top-level <code>"exclude"</code> property.
Similar to <code>include</code>, it allows an array of strings that describes what directories and/or files to exclude from TypeScript compilation.</p>

<p>The following configuration includes all files in <em>src/</em> except for those within any nested <em>external/</em> directory and a <em>node_modules</em> directory:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"exclude"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"**/external"</code><code class="p">,</code><code class="w"> </code><code class="s2">"node_modules"</code><code class="p">],</code><code class="w"/>
<code class="w">  </code><code class="nt">"include"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>By default, <code>exclude</code> contains <code>["node_modules", "bower_components", "jspm_packages"]</code> to avoid running the TypeScript compiler on compiled third-party library files.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you’re writing your own <code>exclude</code> list, you typically won’t need to re-add <code>"bower_components"</code> or <code>"jspm_packages"</code>.
Most JavaScript projects that install node modules to a folder within the project only install to <code>"node_modules"</code>.</p>
</div>

<p>Keep in mind, <code>exclude</code> only acts to remove files from the starting list in <code>include</code>.
TypeScript will run on any file imported by any included <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="file inclusions" data-startref="config-tsconfig-include" id="idm45584672021344"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="file inclusions" data-startref="tsconfig-include" id="idm45584672019824"/><a data-type="indexterm" data-primary="file inclusions" data-startref="file-include" id="idm45584672018608"/><a data-type="indexterm" data-primary="including files" data-startref="include-file" id="idm45584672017664"/>file, even if the imported file is explicitly listed in <code>exclude</code>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Alternative Extensions"><div class="sect1" id="idm45584672016080">
<h1>Alternative Extensions</h1>

<p>TypeScript is by default able to read in any file whose extension is <em>.ts</em>.
However, some projects require being able to read in files with different extensions, such as JSON modules or JSX syntax for UI libraries such as React.</p>








<section data-type="sect2" data-pdf-bookmark="JSX Syntax"><div class="sect2" id="idm45584672014176">
<h2>JSX Syntax</h2>

<p>JSX syntax<a data-type="indexterm" data-primary="configuration options" data-secondary="file extensions" data-tertiary="JSX syntax" id="config-extend-jsx"/><a data-type="indexterm" data-primary="file extensions" data-secondary="JSX syntax" id="file-extend-jsx"/><a data-type="indexterm" data-primary="JSX syntax" id="jsx"/> like <code>&lt;Component /&gt;</code> is often used in UI libraries such as Preact and React.
JSX syntax is not technically JavaScript.
Like TypeScript’s type definitions, it’s an extension to JavaScript syntax that compiles down to regular JavaScript:</p>

<pre data-type="programlisting" data-code-language="jsx"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">// Equivalent to:</code><code class="w"/>
<code class="w">  </code><code class="c1">//   return React.createElement("div", null, "Hello, world!");</code><code class="w"/>
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="nx">Hello</code><code class="p">,</code><code class="w"> </code><code class="nx">world</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;;</code><code class="w"/>
<code class="p">};</code><code class="w"/></pre>

<p>In order to use JSX syntax in a file, you must do two things:</p>

<ul>
<li>
<p>Enable the <code>"jsx"</code> compiler option in your configuration options</p>
</li>
<li>
<p>Name that file with a <em>.tsx</em> extension</p>
</li>
</ul>










<section data-type="sect3" data-pdf-bookmark="jsx"><div class="sect3" id="idm45584671918688">
<h3>jsx</h3>

<p>The value <a data-type="indexterm" data-primary="jsx compiler option" id="idm45584690315872"/>used for the <code>"jsx"</code> compiler option determines how TypeScript emits JavaScript code for <em>.tsx</em> files.
Projects generally use one of these three values (<a data-type="xref" href="#jsx_compiler_option_inputs_and_outputs">Table 13-1</a>).</p>
<table id="jsx_compiler_option_inputs_and_outputs">
<caption><span class="label">Table 13-1. </span>JSX compiler option inputs and outputs</caption>
<thead>
<tr>
<th>Value</th>
<th>Input code</th>
<th>Output code</th>
<th>Output file extension</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>“preserve”</p></td>
<td><p><code>&lt;div /&gt;</code></p></td>
<td><p><code>&lt;div /&gt;</code></p></td>
<td><p>.jsx</p></td>
</tr>
<tr>
<td><p>“react”</p></td>
<td><p><code>&lt;div /&gt;</code></p></td>
<td><p><code>React.createElement("div")</code></p></td>
<td><p>.js</p></td>
</tr>
<tr>
<td><p>“react-native”</p></td>
<td><p><code>&lt;div /&gt;</code></p></td>
<td><p><code>&lt;div /&gt;</code></p></td>
<td><p>.js</p></td>
</tr>
</tbody>
</table>

<p>Values for <code>jsx</code> may be provided to the <code>tsc</code> CLI and/or in a TSConfig file.</p>

<pre data-type="programlisting" data-code-language="shell">tsc --jsx preserve</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"jsx"</code><code class="p">:</code><code class="w"> </code><code class="s2">"preserve"</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>If you’re not directly using TypeScript’s built-in transpiler, which is the case when you’re transpiling code with a separate tool such as Babel, you most likely can use any of the allowed values for <code>"jsx"</code>.
Most web apps built on modern frameworks such as Next.js or Remix handle React configuration and compiling syntax.
If you’re using one of those frameworks you probably won’t have to directly configure TypeScript’s built-in transpiler.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Generic arrow functions in .tsx files"><div class="sect3" id="idm45584671805616">
<h3>Generic arrow functions in .tsx files</h3>

<p><a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.xhtml#generics_chapter">Chapter 10, “Generics”</a> mentioned<a data-type="indexterm" data-primary="generic arrow functions in .tsx files" id="idm45584671802880"/><a data-type="indexterm" data-primary=".tsx files, generic arrow functions in" data-primary-sortas="tsx files" id="idm45584671830080"/> that the syntax for generic arrow functions conflicts with JSX syntax.
Attempting to write a type argument <code>&lt;T&gt;</code> for an arrow function in a <em>.tsx</em> file will give a syntax error for there not being a closing tag for that opening <code>T</code> element:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">identity</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code><code class="p">;</code>
<code class="c1">//               ~~~</code>
<code class="c1">// Error: JSX element 'T' has no corresponding closing tag.</code></pre>

<p class="less_space pagebreak-before">To work around this syntax ambiguity, you can add an <code>= unknown</code> constraint to the type argument.
Type arguments default to the <code>unknown</code> type so this doesn’t change code behavior at all.
It just indicates to TypeScript to read a type argument, not a <a data-type="indexterm" data-primary="configuration options" data-secondary="file extensions" data-tertiary="JSX syntax" data-startref="config-extend-jsx" id="idm45584671785712"/><a data-type="indexterm" data-primary="file extensions" data-secondary="JSX syntax" data-startref="file-extend-jsx" id="idm45584671784288"/><a data-type="indexterm" data-primary="JSX syntax" data-startref="jsx" id="idm45584671783072"/>JSX element:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">identity</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="nx">unknown</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code><code class="p">;</code> <code class="c1">// Ok</code></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="resolveJsonModule"><div class="sect2" id="idm45584671770160">
<h2>resolveJsonModule</h2>

<p>TypeScript <a data-type="indexterm" data-primary="configuration options" data-secondary="file extensions" data-tertiary="JSON files" id="config-extend-json"/><a data-type="indexterm" data-primary="file extensions" data-secondary="JSON files" id="file-extend-json"/><a data-type="indexterm" data-primary="JSON files" id="json"/><a data-type="indexterm" data-primary="resolveJsonModule compiler option" id="resolvejson"/>will allow reading in <em>.json</em> files if the <code>resolveJsonModule</code> compiler option is set to <code>true</code>.
When it is, <em>.json</em> files may be imported from as if they were <em>.ts</em> files exporting an object.
TypeScript will infer the type of that object as if it were a <code>const</code> variable.</p>

<p>For JSON files that contain an object, destructuring imports may be used.
This pair of files defines an <code>"activist"</code> string in an <em>activist.json</em> file and imports it into a <em>usesActivist.ts</em> file:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// activist.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"activist"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Mary Astell"</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// usesActivist.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">activist</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./activist.json"</code><code class="p">;</code>

<code class="c1">// Logs: "Mary Astell"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">activist</code><code class="p">);</code></pre>

<p>Default imports may be used as well if the <code>esModuleInterop</code> compiler option—covered later in this chapter—is enabled:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// useActivist.ts</code>
<code class="kr">import</code> <code class="nx">data</code> <code class="nx">from</code> <code class="s2">"./activist.json"</code><code class="p">;</code></pre>

<p>For JSON files that contain other literal types, such as arrays or numbers, you’ll have to use the <code>* as</code> import syntax.
This pair of files defines an array of strings in an <em>activists.json</em> file that is then imported into a <em>useActivists.ts</em> file:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// activists.json</code><code class="w"/>
<code class="p">[</code><code class="w"/>
<code class="w">   </code><code class="s2">"Ida B. Wells"</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="s2">"Sojourner Truth"</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="s2">"Tawakkul Karmān"</code><code class="w"/>
<code class="p">]</code><code class="w"/></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// useActivists.ts</code>
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">activists</code> <code class="nx">from</code> <code class="s2">"./activists.json"</code><code class="p">;</code>

<code class="c1">// Logs: "3 activists"</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">activists</code><code class="p">.</code><code class="nx">length</code><code class="si">}</code><code class="sb"> activists`</code><code class="p">);</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Emit"><div class="sect1" id="idm45584671738448">
<h1>Emit</h1>

<p>Although <a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" id="idm45584671544384"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" id="idm45584671543376"/><a data-type="indexterm" data-primary="emitting JavaScript" id="idm45584671542432"/><a data-type="indexterm" data-primary="output" data-see="emitting JavaScript" id="idm45584671541760"/><a data-type="indexterm" data-primary="Babel" id="idm45584671540816"/>the rise of dedicated compiler tools such as Babel has reduced TypeScript’s role in some projects to solely type checking, many other projects still rely on TypeScript for compiling TypeScript syntax to JavaScript.
It’s quite useful for projects to be able to take in a single dependency on <code>typescript</code> and use its <code>tsc</code> command to output the equivalent JavaScript.</p>








<section data-type="sect2" data-pdf-bookmark="outDir"><div class="sect2" id="idm45584671539184">
<h2>outDir</h2>

<p>By <a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="outDir compiler option" id="config-emit-outdir"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="outDir compiler option" id="javascript-emit-outdir"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="outDir compiler option" id="emit-javascript-outdir"/><a data-type="indexterm" data-primary="outDir compiler option" id="outdir"/>default, TypeScript places output files alongside their corresponding source files.
For example, running <code>tsc</code> on a directory containing 
<span class="keep-together"><em>fruits/apple.ts</em> and</span> 
<span class="keep-together"><em>vegetables/zucchini.ts</em></span> would result with output files 
<span class="keep-together"><em>fruits/apple.js</em></span> and 
<span class="keep-together"><em>vegetables/zucchini.js</em></span>:</p>

<pre data-type="programlisting" data-code-language="text">fruits/
  apple.js
  apple.ts
vegetables/
  zucchini.js
  zucchini.ts</pre>

<p>Sometimes it may be preferable to place output files in a different folder.
Many Node projects, for example, put transformed outputs in a <em>dist</em> or <em>lib</em> directory.</p>

<p>TypeScript’s <code>outDir</code> compiler option allows specifying a different root directory for outputs.
Output files are kept in the same relative directory structure as input files.</p>

<p>For example, running <code>tsc --outDir dist</code> on the previous directory would place outputs within a <em>dist/</em> folder:</p>

<pre data-type="programlisting" data-code-language="text">dist/
  fruits/
    apple.js
  vegetables/
    zucchini.js
fruits/
  apple.ts
vegetables/
  zucchini.ts</pre>

<p>TypeScript calculates the root directory to place output files into by finding the longest common subpath of all input files (excluding <em>.d.ts</em> declaration files).
That means that projects that place all input source files in a single directory will have that directory treated as the root.</p>

<p class="less_space pagebreak-before">For example, if the above example put all inputs in a <em>src/</em> directory and compiled with <code>--outDir lib</code>, <em>lib/fruits/apple.js</em> would be created instead of <em>lib/src/fruits/apple.js</em>:</p>

<pre data-type="programlisting" data-code-language="text">lib/
  fruits/
    apple.js
  vegetables/
    zucchini.js
src/
  fruits/
    apple.ts
  vegetables/
    zucchini.ts</pre>

<p>A <code>rootDir</code> compiler option does exist to explicitly specify that root directory, but it’s rarely necessary or used with values other <a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="outDir compiler option" data-startref="config-emit-outdir" id="idm45584671468592"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="outDir compiler option" data-startref="javascript-emit-outdir" id="idm45584671467376"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="outDir compiler option" data-startref="emit-javascript-outdir" id="idm45584671465952"/><a data-type="indexterm" data-primary="outDir compiler option" data-startref="outdir" id="idm45584671464736"/>than <code>.</code> or <code>src</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="target"><div class="sect2" id="idm45584671538560">
<h2>target</h2>

<p>TypeScript <a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="target compiler option" id="config-emit-target"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="target compiler option" id="javascript-emit-target"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="target compiler option" id="emit-javascript-target"/><a data-type="indexterm" data-primary="target compiler option" id="target-compile-option"/>is able to produce output JavaScript that can run in environments as old as ES3 (circa 1999!).
Most environments are able to support syntax features from much newer versions of JavaScript.</p>

<p>TypeScript includes a <code>target</code> compiler option to specify how far back in syntax support JavaScript code needs to be transpiled.
Although <code>target</code> defaults to <code>"es3"</code> for backward compatibility reasons when not specified and <code>tsc --init</code> defaults to specifying <code>"es2016"</code>, it’s generally advisable to use the newest JavaScript syntax possible per your target platform(s).
Supporting newer JavaScript features in older environments necessitates creating more JavaScript code, which causes slightly larger file sizes and slightly worse runtime performance.</p>
<div data-type="tip"><h6>Tip</h6>
<p>As of 2022, all releases within the last year of browsers serving &gt; 0.1% of worldwide users support at least all of ECMAScript 2019 and nearly all of ECMAScript 2020–2021, while the LTS-supported versions of Node.js support all of ECMAScript 2021.
There’s very little reason not to have a <code>target</code> at least as high as <code>"es2019"</code>.</p>
</div>

<p>For example, take this TypeScript source containing ES2015 <code>const</code>s and ES2020 <code>??</code> nullish coalescing:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">defaultNameAndLog</code><code class="p">(</code><code class="nx">nameMaybe</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="nx">nameMaybe</code> <code class="o">??</code> <code class="s2">"anonymous"</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"From"</code><code class="p">,</code> <code class="nx">nameMaybe</code><code class="p">,</code> <code class="s2">"to"</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>
  <code class="k">return</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>With <code>tsc --target es2020</code> or newer, both <code>const</code> and <code>??</code> are supported syntax features, so TypeScript would only need to remove the <code>: string | undefined</code> from that snippet:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">defaultNameAndLog</code><code class="p">(</code><code class="nx">nameMaybe</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="nx">nameMaybe</code> <code class="o">??</code> <code class="s2">"anonymous"</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"From"</code><code class="p">,</code> <code class="nx">nameMaybe</code><code class="p">,</code> <code class="s2">"to"</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>
  <code class="k">return</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>With <code>tsc --target es2015</code> through <code>es2019</code>, the <code>??</code> syntax sugar would be compiled down to its equivalent in older versions of JavaScript:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">defaultNameAndLog</code><code class="p">(</code><code class="nx">nameMaybe</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="nx">nameMaybe</code> <code class="o">!==</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="nx">nameMaybe</code> <code class="o">!==</code> <code class="k">void</code> <code class="mi">0</code>
      <code class="o">?</code> <code class="nx">nameMaybe</code>
      <code class="o">:</code> <code class="s2">"anonymous"</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"From"</code><code class="p">,</code> <code class="nx">nameMaybe</code><code class="p">,</code> <code class="s2">"to"</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>With <code>tsc --target es3</code> or <code>es5</code>, the <code>const</code> would additionally need to be converted to its equivalent <code>var</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">defaultNameAndLog</code><code class="p">(</code><code class="nx">nameMaybe</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">name</code> <code class="o">=</code> <code class="nx">nameMaybe</code> <code class="o">!==</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="nx">nameMaybe</code> <code class="o">!==</code> <code class="k">void</code> <code class="mi">0</code>
      <code class="o">?</code> <code class="nx">nameMaybe</code>
      <code class="o">:</code> <code class="s2">"anonymous"</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"From"</code><code class="p">,</code> <code class="nx">nameMaybe</code><code class="p">,</code> <code class="s2">"to"</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">name</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Specifying the <code>target</code> compiler option to a value that matches the oldest environment your code runs will ensure code is emitted as modern, terse syntax that can still run without syntax errors.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Emitting Declarations"><div class="sect2" id="idm45584671446752">
<h2>Emitting Declarations</h2>

<p><a data-type="xref" data-xrefstyle="chap-num-title" href="ch11.xhtml#declaration_files">Chapter 11, “Declaration Files”</a> covered<a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="declaration compiler option" id="idm45584671171808"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="declaration compiler option" id="idm45584671170560"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="declaration compiler option" id="idm45584671169376"/><a data-type="indexterm" data-primary="declaration compiler option" id="idm45584671168464"/><a data-type="indexterm" data-primary="declaration files" data-secondary="emitting" id="declare-emit"/> how <em>.d.ts</em> declaration files may be distributed in a package to indicate code types to consumers.
Most packages use TypeScript’s <code>declaration</code> compiler option to emit <em>.d.ts</em> output files from source files:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --declaration</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"declaration"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><em>.d.ts</em> output files are emitted under the same output rules as <em>.js</em> files, including respecting <code>outDir</code>.</p>

<p>For example, running <code>tsc --declaration</code> on a directory containing <em>fruits/apple.ts</em> and <em>vegetables/zucchini.ts</em> would result in output declaration files <em>fruits/apple.d.ts</em> and <em>vegetables/zucchini.d.ts</em> alongside output <em>.js</em> files:</p>

<pre data-type="programlisting" data-code-language="text">fruits/
  apple.d.ts
  apple.js
  apple.ts
vegetables/
  zucchini.d.ts
  zucchini.js
  zucchini.ts</pre>










<section data-type="sect3" data-pdf-bookmark="emitDeclarationOnly"><div class="sect3" id="idm45584671082704">
<h3>emitDeclarationOnly</h3>

<p>An 
<span class="keep-together"><code>emitDeclarationOnly</code></span> compiler option exists, as a <a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="emitDeclarationOnly compiler option" id="idm45584671076640"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="emitDeclarationOnly compiler option" id="idm45584671075552"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="emitDeclarationOnly compiler option" id="idm45584671074464"/><a data-type="indexterm" data-primary="emitDeclarationOnly compiler option" id="idm45584671073584"/>specialized addition to the <code>declaration</code> compiler option, that directs TypeScript to only emit declaration files: no <em>.js</em>/<em>.jsx</em> files at all.
This is useful for projects that use an external tool to generate output JavaScript but still want to use TypeScript to generate output definition files:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --emitDeclarationOnly</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"emitDeclarationOnly"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>If <code>emitDeclarationOnly</code> is enabled, either <code>declaration</code> or the <code>composite</code> compiler option covered later in this chapter must be enabled.</p>

<p>For example, running <code>tsc --declaration --emitDeclarationOnly</code> on a directory containing <em>fruits/apple.ts</em> and <em>vegetables/zucchini.ts</em> would result with output declaration files <em>fruits/apple.d.ts</em> and <em>vegetables/zucchini.d.ts</em> without any<a data-type="indexterm" data-primary="declaration files" data-secondary="emitting" data-startref="declare-emit" id="idm45584671008576"/> output <em>.js</em> files:</p>

<pre data-type="programlisting" data-code-language="text">fruits/
  apple.d.ts
  apple.ts
vegetables/
  zucchini.d.ts
  zucchini.ts</pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Source Maps"><div class="sect2" id="idm45584671174304">
<h2>Source Maps</h2>

<p>Source maps<a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="source maps" id="config-emit-sourcemap"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="source maps" id="javascript-emit-sourcemap"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="source maps" id="emit-javascript-sourcemap"/><a data-type="indexterm" data-primary="source maps" id="sourcemap"/> are descriptions of how the contents of output files match up to original source files.
They allow developer tools such as debuggers to display original source code when navigating through the output file.
They’re particularly useful for visual debuggers such as those used in browser developer tools and IDEs to let you see original source file contents while debugging.
TypeScript includes the ability to output source maps alongside output files.</p>










<section data-type="sect3" data-pdf-bookmark="sourceMap"><div class="sect3" id="idm45584670999584">
<h3>sourceMap</h3>

<p>TypeScript’s <code>sourceMap</code> compiler option <a data-type="indexterm" data-primary="sourceMap compiler option" id="idm45584670997616"/>enables outputting <em>.js.map</em> or <em>.jsx.map</em> 
<span class="keep-together">sourcemaps</span> alongside <em>.js</em> or <em>.jsx</em> output files.
Sourcemap files are otherwise given the same name as their corresponding output JavaScript file and placed in the same directory.</p>

<p>For example, running <code>tsc --sourceMap</code> on a directory containing <em>fruits/apple.ts</em> and <em>vegetables/zucchini.ts</em> would result with output sourcemap files <em>fruits/apple.js.map</em> and <em>vegetables/zucchini.js.map</em> alongside output <em>.js</em> files:</p>

<pre data-type="programlisting" data-code-language="text">fruits/
  apple.js
  apple.js.map
  apple.ts
vegetables/
  zucchini.js
  zucchini.js.map
  zucchini.ts</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="declarationMap"><div class="sect3" id="idm45584670935824">
<h3>declarationMap</h3>

<p>TypeScript is<a data-type="indexterm" data-primary="declarationMap compiler option" id="idm45584670952864"/><a data-type="indexterm" data-primary="declaration files" data-secondary="declarationMap compiler option" id="idm45584670952256"/> also able to generate source maps for <em>.d.ts</em> declaration files.
Its 
<span class="keep-together"><code>declarationMap</code></span> compiler option directs it to generate a <em>.d.ts.map</em> source map for each <em>.d.ts</em> that maps back to the original source file.
Declaration maps enable IDEs such as VS Code to go to the original source file when using editor features such as Go to Definition.</p>
<div data-type="tip"><h6>Tip</h6>
<p><code>declarationMap</code> is particularly useful when working with project references, covered toward the end of this chapter.</p>
</div>

<p>For example, running <code>tsc --declaration --declarationMap</code> on a directory containing <em>fruits/apple.ts</em> and <em>vegetables/zucchini.ts</em> would result in output declaration sourcemap files <em>fruits/apple.d.ts.map</em> and <em>vegetables/zucchini.d.ts.map</em> alongside <a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="source maps" data-startref="config-emit-sourcemap" id="idm45584670944928"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="source maps" data-startref="javascript-emit-sourcemap" id="idm45584670943408"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="source maps" data-startref="emit-javascript-sourcemap" id="idm45584670941952"/><a data-type="indexterm" data-primary="source maps" data-startref="sourcemap" id="idm45584670940768"/>output <em>.d.ts</em> and <em>.js</em> files:</p>

<pre data-type="programlisting" data-code-language="text">fruits/
  apple.d.ts
  apple.d.ts.map
  apple.js
  apple.ts
vegetables/
  zucchini.d.ts
  zucchini.d.ts.map
  zucchini.js
  zucchini.ts</pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="noEmit"><div class="sect2" id="idm45584670920032">
<h2>noEmit</h2>

<p>For <a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="noEmit compiler option" id="idm45584670899728"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="noEmit compiler option" id="idm45584670917216"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="noEmit compiler option" id="idm45584670916128"/><a data-type="indexterm" data-primary="noEmit compiler option" id="idm45584670915184"/>projects that completely rely on other tools to compile source files to output JavaScript, TypeScript can be told to skip emitting files altogether.
Enabling the <code>noEmit</code> compiler option directs TypeScript to act purely as a type checker.</p>

<p>Running <code>tsc --noEmit</code> on any of the previous examples would result in no new files created.
TypeScript would only report any syntax or type errors it finds.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Checking"><div class="sect1" id="idm45584670912752">
<h1>Type Checking</h1>

<p>Most of TypeScript’s configuration options control its type checker.
You can configure it to be gentle and forgiving, only emitting type-checking complaints when it’s completely certain of an error, or harsh and strict, requiring nearly all code be well typed.</p>








<section data-type="sect2" data-pdf-bookmark="lib"><div class="sect2" id="idm45584670911056">
<h2>lib</h2>

<p>To <a data-type="indexterm" data-primary="configuration options" data-secondary="for type checking" data-tertiary="lib compiler option" data-secondary-sortas="type checking" id="idm45584670909104"/><a data-type="indexterm" data-primary="type checking" data-secondary="configuration options for" data-tertiary="lib compiler option" id="idm45584670907552"/><a data-type="indexterm" data-primary="lib compiler option" id="idm45584670906368"/>start, which global APIs TypeScript assumes to be present in the runtime environment is configurable with the <code>lib</code> compiler option.
It takes in an array of strings that defaults to your <code>target</code> compiler option, as well as <code>dom</code> to indicate including browser types.</p>

<p>Most of the time, the only reason to customize <code>lib</code> would be to remove the <code>dom</code> inclusion for a project that doesn’t run in the browser:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --lib es2020</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"lib"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"es2020"</code><code class="p">]</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Alternately, for a project that uses polyfills to support newer JavaScript APIs, <code>lib</code> can include <code>dom</code> and any ECMAScript version:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --lib dom,es2021</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"lib"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"dom"</code><code class="p">,</code><code class="w"> </code><code class="s2">"es2021"</code><code class="p">]</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Be wary of modifying <code>lib</code> without providing all the right runtime polyfills.
A project with a <code>lib</code> set to <code>"es2021"</code> running on a platform that only supports up through ES2020 might have no type-checking errors but still experience runtime errors attempting to use APIs defined in ES2021 or later, such as <code>String.replaceAll</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="s2">"a b c"</code><code class="p">;</code>

<code class="nx">value</code><code class="p">.</code><code class="nx">replaceAll</code><code class="p">(</code><code class="s2">" "</code><code class="p">,</code> <code class="s2">", "</code><code class="p">);</code>
<code class="c1">// Uncaught TypeError: value.replaceAll is not a function</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Think of the <code>lib</code> compiler option as indicating what built-in language APIs are available, whereas the <code>target</code> compiler option indicates what syntax features<a data-type="indexterm" data-primary="lib compiler option" id="idm45584670744928"/><a data-type="indexterm" data-primary="configuration options" data-secondary="emitting JavaScript" data-tertiary="target compiler option" data-startref="config-emit-target" id="idm45584670744224"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="emitting" data-tertiary="target compiler option" data-startref="javascript-emit-target" id="idm45584670742736"/><a data-type="indexterm" data-primary="emitting JavaScript" data-secondary="target compiler option" data-startref="emit-javascript-target" id="idm45584670741248"/><a data-type="indexterm" data-primary="target compiler option" data-startref="target-compile-option" id="idm45584670740032"/> exist.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="skipLibCheck"><div class="sect2" id="idm45584670910432">
<h2>skipLibCheck</h2>

<p>TypeScript <a data-type="indexterm" data-primary="configuration options" data-secondary="for type checking" data-tertiary="skipLibCheck compiler option" data-secondary-sortas="type checking" id="config-typecheck-skip"/><a data-type="indexterm" data-primary="type checking" data-secondary="configuration options for" data-tertiary="skipLibCheck compiler option" id="typecheck-config-skip"/><a data-type="indexterm" data-primary="skipLibCheck compiler option" id="skiplibcheck"/>provides a <code>skipLibCheck</code> compiler option that indicates to skip type checking in declaration files not explicitly included in your source code.
This can be useful for applications that rely on many dependencies that may rely on different, conflicting definitions of shared libraries:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --skipLibCheck</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"skipLibCheck"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p><code>skipLibCheck</code> speeds up TypeScript performance by allowing it to skip some type checking.
For this reason, it is generally a good idea to enable it on most projects.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Strict Mode"><div class="sect2" id="idm45584670700720">
<h2>Strict Mode</h2>

<p>Most of <a data-type="indexterm" data-primary="configuration options" data-secondary="for type checking" data-tertiary="strict mode" data-secondary-sortas="type checking" id="config-typecheck-strict"/><a data-type="indexterm" data-primary="type checking" data-secondary="configuration options for" data-tertiary="strict mode" id="typecheck-config-strict"/><a data-type="indexterm" data-primary="strict mode (type checking)" id="strict-mode"/>TypeScript’s type-checking compiler options are grouped into what TypeScript refers to as <em>strict mode</em>.
Each strictness compiler option defaults to <code>false</code>, and when enabled, directs the type checker to turn on some additional checks.</p>

<p>I’ll cover the most commonly used strict options in alphabetical order later in this chapter.
From those options, <code>noImplicitAny</code> and <code>strictNullChecks</code> are particularly useful and impactful in enforcing type-safe code.</p>

<p>You can enable all strict mode checks by <a data-type="indexterm" data-primary="strict compiler option" id="strict-option"/>enabling the <code>strict</code> compiler option:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --strict</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>If you want to enable all strict mode checks except for certain ones, you can both enable <code>strict</code> and explicitly disable certain checks.
For example, this configuration enables all strict modes except for <code>noImplicitAny</code>:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --strict --noImplicitAny <code class="nb">false</code></pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"noImplicitAny"</code><code class="p">:</code><code class="w"> </code><code class="kc">false</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Future versions of TypeScript may introduce new strict type-checking compiler options under <code>strict</code>.
Using <code>strict</code> may therefore cause new type-checking complaints when you update TypeScript versions.
You can always opt out of specific settings in your<a data-type="indexterm" data-primary="strict compiler option" data-startref="strict-option" id="idm45584670498064"/> TSConfig.</p>
</div>










<section data-type="sect3" data-pdf-bookmark="noImplicitAny"><div class="sect3" id="idm45584670526320">
<h3>noImplicitAny</h3>

<p>If <a data-type="indexterm" data-primary="noImplicitAny compiler option" id="idm45584670524624"/><a data-type="indexterm" data-primary="any type" data-secondary="noImplicitAny compiler option" id="idm45584670523920"/>TypeScript cannot infer the type of a parameter or property, then it will fall back to assuming the <code>any</code> type.
It is generally best practice to not allow these implicit <code>any</code> types in code as the <code>any</code> type is allowed to bypass much of TypeScript’s type checking.</p>

<p>The <code>noImplicitAny</code> compiler option directs TypeScript to issue a type-checking complaint when it has to fall back to an implicit <code>any</code>.</p>

<p>For example, writing the following function parameter without a type declaration would cause a type error under <code>noImplicitAny</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">logMessage</code> <code class="o">=</code> <code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c1">//                ~~~~~~~</code>
  <code class="c1">// Error: Parameter 'message' implicitly has an 'any' type.</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Message: </code><code class="si">${</code><code class="nx">message</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">};</code></pre>

<p>Most of the time, a <code>noImplicitAny</code> complaint can be resolved either by adding a type annotation on the complaining location:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">logMessage</code> <code class="o">=</code> <code class="p">(</code><code class="nx">message</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c1">// Ok</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Message: </code><code class="si">${</code><code class="nx">message</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Or, in the case of function parameters, putting the parent function in a location that indicates the type of the function:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">type</code> <code class="nx">LogsMessage</code> <code class="o">=</code> <code class="p">(</code><code class="nx">message</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">logMessage</code>: <code class="nx">LogsMessage</code> <code class="o">=</code> <code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c1">// Ok</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Message: </code><code class="si">${</code><code class="nx">message</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">}</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p><code>noImplicitAny</code> is an excellent flag for ensuring type safety across a project.
I highly recommend striving to turn it on in projects written completely in TypeScript.
However, if a project is still transitioning from JavaScript to TypeScript, it may be easier to finish converting all files to TypeScript first.</p>
</div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="strictBindCallApply"><div class="sect3" id="idm45584670525728">
<h3>strictBindCallApply</h3>

<p>When <a data-type="indexterm" data-primary="strictBindCallApply compiler option" id="strictbindcallapply"/><a data-type="indexterm" data-primary="functions" data-secondary="strictBindCallApply compiler option" id="function-strictbindcallapply"/>TypeScript was first released, it didn’t have rich enough type system features to be able to represent the built-in <code>Function.apply</code>, <code>Function.bind</code>, or <code>Function.call</code> function utilities.
Those functions by default had to take in <code>any</code> for their list of arguments.
That’s not very type safe!</p>

<p>As an example, without <code>strictBindCallApply</code>, the following variations on <code>getLength</code> all include <code>any</code> in their types:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">getLength</code><code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">trim?</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">trim</code> <code class="o">?</code> <code class="nx">text</code><code class="p">.</code><code class="nx">trim</code><code class="p">().</code><code class="nx">length</code> : <code class="nx">text.length</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Function type: (thisArg: Function, argArray?: any) =&gt; any</code>
<code class="nx">getLength</code><code class="p">.</code><code class="nx">apply</code><code class="p">;</code>

<code class="c1">// Returned type: any</code>
<code class="nx">getLength</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kc">undefined</code><code class="p">,</code> <code class="s2">"abc123"</code><code class="p">);</code>

<code class="c1">// Returned type: any</code>
<code class="nx">getLength</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kc">undefined</code><code class="p">,</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code></pre>

<p>Now that TypeScript’s type system features are powerful enough to represent those functions’ generic rest arguments, TypeScript allows opting in to using more restrictive types for the functions.</p>

<p>Enabling <code>strictBindCallApply</code> enables much more precise types for the <code>getLength</code> variations:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">getLength</code><code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">trim?</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">trim</code> <code class="o">?</code> <code class="nx">text</code><code class="p">.</code><code class="nx">trim</code><code class="p">().</code><code class="nx">length</code> : <code class="nx">text</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Function type:</code>
<code class="c1">// (thisArg: typeof getLength, args: [text: string, trim?: boolean]) =&gt; number;</code>
<code class="nx">getLength</code><code class="p">.</code><code class="nx">apply</code><code class="p">;</code>

<code class="c1">// Returned type: (trim?: boolean) =&gt; number</code>
<code class="nx">getLength</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kc">undefined</code><code class="p">,</code> <code class="s2">"abc123"</code><code class="p">);</code>

<code class="c1">// Returned type: number</code>
<code class="nx">getLength</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kc">undefined</code><code class="p">,</code> <code class="s2">"abc123"</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code></pre>

<p>TypeScript best practice is to enable <code>strictBindCallApply</code>.
Its improved type checking for built-in function utilities helps improve type safety for projects that utilize <a data-type="indexterm" data-primary="strictBindCallApply compiler option" data-startref="strictbindcallapply" id="idm45584670211168"/><a data-type="indexterm" data-primary="functions" data-secondary="strictBindCallApply compiler option" data-startref="function-strictbindcallapply" id="idm45584670210320"/>them.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="strictFunctionTypes"><div class="sect3" id="idm45584670208944">
<h3>strictFunctionTypes</h3>

<p>The <code>strictFunctionTypes</code> compiler <a data-type="indexterm" data-primary="strictFunctionTypes compiler option" id="strictfunctiontypes"/><a data-type="indexterm" data-primary="functions" data-secondary="strictFunctionTypes compiler option" id="function-strictfunctiontypes"/>option causes function parameter types to be checked slightly more strictly.
A function type is no longer considered assignable to another function type if its parameters are subtypes of that other type’s parameters.</p>

<p>As a concrete example, the <code>checkOnNumber</code> function here takes in a function that should be able to receive a <code>number | string</code>, but is provided with a 
<span class="keep-together"><code>stringContainsA</code></span> function that expects to take in a parameter only of type <code>string</code>.
TypeScript’s default type checking would allow it—and the program would crash from trying to call <code>.match()</code> on a <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">checkOnNumber</code><code class="p">(</code><code class="nx">containsA</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">boolean</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">containsA</code><code class="p">(</code><code class="mi">1337</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">stringContainsA</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="o">!!</code><code class="nx">input</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="sr">/a/i</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">checkOnNumber</code><code class="p">(</code><code class="nx">stringContainsA</code><code class="p">);</code></pre>

<p>Under <code>strictFunctionTypes</code>, <code>checkOnNumber(stringContainsA)</code> would cause a type-checking error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Argument of type '(input: string) =&gt; boolean' is not assignable</code>
<code class="c1">// to parameter of type '(input: string | number) =&gt; boolean'.</code>
<code class="c1">//   Types of parameters 'input' and 'input' are incompatible.</code>
<code class="c1">//     Type 'string | number' is not assignable to type 'string'.</code>
<code class="c1">//       Type 'number' is not assignable to type 'string'.</code>
<code class="nx">checkOnNumber</code><code class="p">(</code><code class="nx">stringContainsA</code><code class="p">);</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In technical terms, function parameters switch from <a data-type="indexterm" data-primary="bivariant function parameters" id="idm45584670137072"/><a data-type="indexterm" data-primary="contravariant function parameters" id="idm45584670136464"/>being <em>bivariant</em> to <em>contravariant</em>.
You can read more about the difference in the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html">TypeScript 2.6 release notes</a>.</p>
</div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="strictNullChecks"><div class="sect3" id="idm45584670133920">
<h3>strictNullChecks</h3>

<p>Back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.xhtml#unions_and_literals">Chapter 3, “Unions and Literals”</a>, I<a data-type="indexterm" data-primary="strictNullChecks compiler option" id="strictnullchecks"/><a data-type="indexterm" data-primary="null type" data-secondary="strictNullChecks compiler option" id="null-strictnullchecks"/> discussed the billion-dollar mistake of languages: allowing empty types such as <code>null</code> and <code>undefined</code> to be assignable to nonempty types.
Disabling TypeScript’s <code>strictNullChecks</code> flag roughly adds <code>null | undefined</code> to every type in your code, thereby allowing any variable to receive <code>null</code> or 
<span class="keep-together"><code>undefined</code>.</span></p>

<p>This code snippet would cause a type error for assigning <code>null</code> to a <code>string</code> typed value only when <code>strictNullChecks</code> is enabled:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">value</code>: <code class="nx">string</code><code class="p">;</code>

<code class="nx">value</code> <code class="o">=</code> <code class="s2">"abc123"</code><code class="p">;</code> <code class="c1">// Always ok</code>

<code class="nx">value</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
<code class="c1">// With strictNullChecks enabled:</code>
<code class="c1">// Error: Type 'null' is not assignable to type 'string'.</code></pre>

<p>TypeScript best practice is to enable <code>strictNullChecks</code>.
Doing so helps prevent crashes and eliminates the billion-dollar mistake.</p>

<p>Refer to <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.xhtml#unions_and_literals">Chapter 3, “Unions and Literals”</a> for more details.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="strictPropertyInitialization"><div class="sect3" id="idm45584670030768">
<h3>strictPropertyInitialization</h3>

<p>Back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch08.xhtml#classes">Chapter 8, “Classes”</a>, I <a data-type="indexterm" data-primary="strictPropertyInitialization compiler option" id="idm45584670028288"/><a data-type="indexterm" data-primary="classes" data-secondary="strictPropertyInitialization compiler option" id="idm45584670027584"/>discussed strict initialization checking in classes: making sure that each property on a class is definitely assigned in the class constructor.
TypeScript’s <code>strictPropertyInitialization</code> flag causes a type error to be issued on class properties that have no initializer and are not definitely assigned in the constructor.</p>

<p>TypeScript best practice is generally to enable <code>strictPropertyInitialization</code>.
Doing so helps prevent crashes from mistakes in class initialization logic.</p>

<p>Refer to <a data-type="xref" data-xrefstyle="chap-num-title" href="ch08.xhtml#classes">Chapter 8, “Classes”</a> for more details.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="useUnknownInCatchVariables"><div class="sect3" id="idm45584669992624">
<h3>useUnknownInCatchVariables</h3>

<p>Error handling<a data-type="indexterm" data-primary="useUnknownInCatchVariables compiler option" id="useunknown"/><a data-type="indexterm" data-primary="error handling" data-secondary="useUnknownInCatchVariables compiler option" id="error-handling-useunknown"/><a data-type="indexterm" data-primary="any type" data-secondary="useUnknownInCatchVariables compiler option" id="any-type-useunknown"/><a data-type="indexterm" data-primary="unknown type" data-secondary="useUnknownInCatchVariables compiler option" id="unknown-useunknown"/> in any language is an inherently unsafe concept.
Any function can in theory throw any number of errors from edge cases such as reading properties on <code>undefined</code> or user-written <code>throw</code> statements.
In fact, there’s no guarantee a thrown error is even an instance of the <code>Error</code> class: code can always <code>throw "something-else"</code>.</p>

<p>As a result, TypeScript’s default behavior for errors is to give them type <code>any</code>, as they could be anything.
That allows flexibility in error handling at the cost of relying on the not-very-type-safe <code>any</code> by default.</p>

<p>The following snippet’s <code>error</code> is typed <code>any</code> because there’s no way for TypeScript to know what all the possible errors thrown by <code>someExternalFunction()</code> could be:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">try</code> <code class="p">{</code>
  <code class="nx">someExternalFunction</code><code class="p">();</code>
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">error</code><code class="p">;</code> <code class="c1">// Default type: any</code>
<code class="p">}</code></pre>

<p>As with most <code>any</code> uses, it would be more technically sound—at the cost of often necessitating explicit type assertions or narrowing—to treat errors as <code>unknown</code> instead.
Catch clause errors are allowed to be annotated as the <code>any</code> or <code>unknown</code> types.</p>

<p>This snippet correction adds an explicit <code>: unknown</code> to <code>error</code> to switch it to the <code>unknown</code> type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">try</code> <code class="p">{</code>
  <code class="nx">someExternalFunction</code><code class="p">();</code>
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">error</code><code class="p">;</code> <code class="c1">// Type: unknown</code>
<code class="p">}</code></pre>

<p>The strict area flag <code>useUnknownInCatchVariables</code> changes TypeScript’s default catch clause error type to <code>unknown</code>.
With <code>useUnknownInCatchVariables</code> enabled, both snippets would have type of <code>error</code> set to be <code>unknown</code>.</p>

<p>TypeScript best practice is generally to enable <code>useUnknownInCatchVariables</code>, as it’s not always safe to assume errors will be any<a data-type="indexterm" data-primary="configuration options" data-secondary="for type checking" data-tertiary="strict mode" data-secondary-sortas="type checking" data-startref="config-typecheck-strict" id="idm45584669917872"/><a data-type="indexterm" data-primary="type checking" data-secondary="configuration options for" data-tertiary="strict mode" data-startref="typecheck-config-strict" id="idm45584669916112"/><a data-type="indexterm" data-primary="strict mode (type checking)" data-startref="strict-mode" id="idm45584669914656"/><a data-type="indexterm" data-primary="useUnknownInCatchVariables compiler option" data-startref="useunknown" id="idm45584669913744"/><a data-type="indexterm" data-primary="error handling" data-secondary="useUnknownInCatchVariables compiler option" data-startref="error-handling-useunknown" id="idm45584669912768"/><a data-type="indexterm" data-primary="any type" data-secondary="useUnknownInCatchVariables compiler option" data-startref="any-type-useunknown" id="idm45584669911552"/><a data-type="indexterm" data-primary="unknown type" data-secondary="useUnknownInCatchVariables compiler option" data-startref="unknown-useunknown" id="idm45584669910304"/> particular type.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Modules"><div class="sect1" id="idm45584670700256">
<h1>Modules</h1>

<p>JavaScript’s <a data-type="indexterm" data-primary="configuration options" data-secondary="for module import/export" data-secondary-sortas="module import/export" id="idm45584669907696"/><a data-type="indexterm" data-primary="modules" data-secondary="configuration options for" id="idm45584669906448"/><a data-type="indexterm" data-primary="importing" data-secondary="via modules" data-tertiary="configuration options for" id="import-module-config"/><a data-type="indexterm" data-primary="exporting" data-secondary="via modules" data-tertiary="configuration options for" id="export-module-config"/><a data-type="indexterm" data-primary="ECMAScript" data-secondary="module import/export" id="ecmascript-module-importexport"/>various systems for exporting and importing module contents—AMD, CommonJS, ECMAScript, and so on—are one of the most convoluted module systems in any modern programming language.
JavaScript is relatively unusual in that the way files import each other’s contents is often driven by user-written frameworks such as Webpack.
TypeScript does its best to provide configuration options that represent most reasonable user-land module configurations.</p>

<p>Most new TypeScript projects are written with the standardized ECMAScript modules syntax.
To recap, here is how ECMAScript modules import a value (<code>value</code>) from another module <code>("my-example-lib")</code> and export their own value (<code>logValue</code>):</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">value</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"my-example-lib"</code><code class="p">;</code>

<code class="kr">export</code> <code class="kr">const</code> <code class="nx">logValue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code></pre>








<section data-type="sect2" data-pdf-bookmark="module"><div class="sect2" id="idm45584669860656">
<h2>module</h2>

<p>TypeScript <a data-type="indexterm" data-primary="configuration options" data-secondary="for module import/export" data-tertiary="module compiler option" data-secondary-sortas="module import/export" id="config-module-module"/><a data-type="indexterm" data-primary="modules" data-secondary="configuration options for" data-tertiary="module compiler option" id="module-config-module"/><a data-type="indexterm" data-primary="module compiler option" id="module-compile"/>provides a <code>module</code> compiler option to direct which module system transpiled code will use.
When writing source code with ECMAScript modules, TypeScript may transpile the <code>export</code> and <code>import</code> statements to a different module system based on the <code>module</code> value.</p>

<p>For example, directing that a project written in ECMAScript be output as CommonJS modules in either the command line:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --module commonjs</pre>

<p>or in a TSConfig:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"module"</code><code class="p">:</code><code class="w"> </code><code class="s2">"commonjs"</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The previous code snippet would roughly be output as:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">my_example_lib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"my-example-lib"</code><code class="p">);</code>
<code class="nx">exports</code><code class="p">.</code><code class="nx">logValue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">my_example_lib</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code></pre>

<p>If your <code>target</code> compiler option is <code>"es3"</code> or <code>"es5"</code>, <code>module</code>’s default value will be <code>"commonjs"</code>.
Otherwise, <code>module</code> will default to <code>"es2015"</code> to specify outputting ECMAScript modules.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="moduleResolution"><div class="sect2" id="idm45584669731472">
<h2>moduleResolution</h2>

<p><em>Module resolution</em> is <a data-type="indexterm" data-primary="configuration options" data-secondary="for module import/export" data-tertiary="moduleResolution compiler option" data-secondary-sortas="module import/export" id="idm45584669729616"/><a data-type="indexterm" data-primary="modules" data-secondary="configuration options for" data-tertiary="moduleResolution compiler option" id="idm45584669728128"/><a data-type="indexterm" data-primary="moduleResolution compiler option" id="idm45584669726976"/><a data-type="indexterm" data-primary="module resolution" id="idm45584669726336"/>the process by which the imported path in an import is mapped to a module.
TypeScript provides a <code>moduleResolution</code> option that you can use to specify the logic for that process.
You’ll typically want to provide it one of two logic strategies:</p>

<ul>
<li>
<p><code>node</code>: The behavior used by CommonJS resolvers such as traditional Node.js</p>
</li>
<li>
<p><code>nodenext</code>: Aligning to the behavior specified for ECMAScript modules</p>
</li>
</ul>

<p>The two strategies are similar.
Most projects could use either of them and not notice a difference. You can read more on the intricacies behind the scenes of module resolution on <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html"><em class="hyperlink">https://www.typescriptlang.org/docs/handbook/module-resolution.html</em></a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>moduleResolution</code> does not change how TypeScript emits code at all.
It’s only used to describe the runtime environment your code is meant to be run in.</p>
</div>

<p class="less_space pagebreak-before">Both the following CLI snippet and JSON file snippet would work to specify the <code>moduleResolution</code> compiler option:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --moduleResolution nodenext</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"moduleResolution"</code><code class="p">:</code><code class="w"> </code><code class="s2">"nodenext"</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="tip"><h6>Tip</h6>
<p>For backward compatibility reasons, TypeScript keeps the default <code>moduleResolution</code> value to a <code>classic</code> value that was used for projects years ago.
You almost certainly do not want the <code>classic</code> strategy in any modern project.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Interoperability with CommonJS"><div class="sect2" id="idm45584669658816">
<h2>Interoperability with CommonJS</h2>

<p>When <a data-type="indexterm" data-primary="configuration options" data-secondary="for module import/export" data-tertiary="CommonJS interoperability" data-secondary-sortas="module import/export" id="config-module-commonjs"/><a data-type="indexterm" data-primary="modules" data-secondary="configuration options for" data-tertiary="CommonJS interoperability" id="module-config-commonjs"/><a data-type="indexterm" data-primary="CommonJS interoperability" id="commonjs-interoperate"/>working with JavaScript modules, there is a difference between the “default” export of a module and its “namespace” output.
The <em>default</em> export of a module is the <code>.default</code> property on its exported object.
The <em>namespace</em> export of a module is the exported object itself.</p>

<p><a data-type="xref" href="#CommonJs_ECMAScript">Table 13-2</a> recaps the differences between default and namespace exports and imports.</p>
<table id="CommonJs_ECMAScript">
<caption><span class="label">Table 13-2. </span>CommonJS and ECMAScript module export and import forms</caption>
<thead>
<tr>
<th>Area of syntax</th>
<th>CommonJS</th>
<th>ECMAScript modules</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Default export</p></td>
<td><p><code>module.exports.default = value;</code></p></td>
<td><p><code>export default value;</code></p></td>
</tr>
<tr>
<td><p>Default import</p></td>
<td><p><code>const { default: value } = require("...");</code></p></td>
<td><p><code>import value from "...";</code></p></td>
</tr>
<tr>
<td><p>Namespace export</p></td>
<td><p><code>module.exports = value;</code></p></td>
<td><p>Not supported</p></td>
</tr>
<tr>
<td><p>Namespace import</p></td>
<td><p><code>const value = require("...");</code></p></td>
<td><p><code>import * as value from "...";</code></p></td>
</tr>
</tbody>
</table>

<p>TypeScript’s type system builds its understanding of file imports and exports in terms of <a data-type="indexterm" data-primary="ECMAScript" data-secondary="module import/export" data-startref="ecmascript-module-importexport" id="idm45584669618688"/>ECMAScript modules.
If your project depends on npm packages as most do, however, it’s likely some of those dependencies are still published as CommonJS modules.
Furthermore, although some packages that comply with ECMAScript modules rules avoid including a default export, many developers prefer the more succinct default-style imports over namespace-style imports.
TypeScript includes a few compiler options that improve interoperability between module formats.</p>










<section data-type="sect3" data-pdf-bookmark="esModuleInterop"><div class="sect3" id="idm45584669617152">
<h3>esModuleInterop</h3>

<p>The <code>esModuleInterop</code> configuration option <a data-type="indexterm" data-primary="esModuleInterop compiler option" id="esmoduleinterop"/>adds a small amount of logic to JavaScript code emitted by TypeScript when <code>module</code> is not an ECMAScript module format such as <code>"es2015"</code> or <code>"esnext"</code>.
That logic allows ECMAScript modules to import from modules even if they don’t happen to adhere to ECMAScript modules’ rules around default or namespace imports.</p>

<p>One common reason to enable <code>esModuleInterop</code> is for packages such as <code>"react"</code> that do not ship a default export.
If a module attempts to use a default-style import from the <code>"react"</code> package, TypeScript would report a type error without <code>esModuleInterop</code> enabled:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>
<code class="c1">//     ~~~~~</code>
<code class="c1">// Module '"file:///node_modules/@types/react/index"' can</code>
<code class="c1">// only be default-imported using the 'esModuleInterop' flag.</code></pre>

<p>Note that <code>esModuleInterop</code> only directly changes how emitted JavaScript code works with imports.
The following <code>allowSyntheticDefaultImports</code> configuration option is what informs the type system about import interoperability.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="allowSyntheticDefaultImports"><div class="sect3" id="idm45584669601104">
<h3>allowSyntheticDefaultImports</h3>

<p>The <code>allowSyntheticDefaultImports</code> compiler option<a data-type="indexterm" data-primary="allowSyntheticDefaultImports compiler option" id="idm45584669599216"/> informs the type system that ECMAScript modules may default import from files that are otherwise incompatible CommonJS namespace exports.</p>

<p>It defaults to <code>true</code> only if either of the following is true:</p>

<ul>
<li>
<p><code>module</code> is <code>"system"</code> (an older, rarely used module format not covered in this book).</p>
</li>
<li>
<p><code>esModuleInterop</code> is <code>true</code> and <code>module</code> is not an ECMAScript modules format such as <code>"es2015"</code> or <code>"esnext"</code>.</p>
</li>
</ul>

<p>In other words, if <code>esModuleInterop</code> is <code>true</code> but <code>module</code> is <code>"esnext"</code>, TypeScript will assume output compiled JavaScript code is not using import interoperability helpers.
It would report a type error for a default import from packages <a data-type="indexterm" data-primary="configuration options" data-secondary="for module import/export" data-tertiary="CommonJS interoperability" data-secondary-sortas="module import/export" data-startref="config-module-commonjs" id="idm45584669567392"/><a data-type="indexterm" data-primary="modules" data-secondary="configuration options for" data-tertiary="CommonJS interoperability" data-startref="module-config-commonjs" id="idm45584669565664"/><a data-type="indexterm" data-primary="CommonJS interoperability" data-startref="commonjs-interoperate" id="idm45584669564240"/>such as <code>"react"</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>
<code class="c1">// Module '"file:///node_modules/@types/react/index"' can only be</code>
<code class="c1">// default-imported using the 'allowSyntheticDefaultImports' flag`.</code></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="isolatedModules"><div class="sect2" id="idm45584669658480">
<h2>isolatedModules</h2>

<p>External transpilers<a data-type="indexterm" data-primary="configuration options" data-secondary="for module import/export" data-tertiary="isolatedModules compiler option" data-secondary-sortas="module import/export" id="idm45584669555104"/><a data-type="indexterm" data-primary="modules" data-secondary="configuration options for" data-tertiary="isolatedModules compiler option" id="idm45584669553616"/><a data-type="indexterm" data-primary="isolatedModules compiler option" id="idm45584669552464"/> such as Babel that only operate on one file at a time cannot use type system information to emit JavaScript.
As a result, TypeScript syntax features that rely on type information to emit JavaScript aren’t generally supported in those transpilers.
Enabling the <code>isolatedModules</code> compiler tells TypeScript to report an error on any instance of a syntax that is likely to cause issues in those transpilers:</p>

<ul>
<li>
<p>Const enums, covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch14.xhtml#syntax_extensions">Chapter 14, “Syntax Extensions”</a></p>
</li>
<li>
<p>Script (nonmodule) files</p>
</li>
<li>
<p>Standalone type exports, covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch14.xhtml#syntax_extensions">Chapter 14, “Syntax Extensions”</a></p>
</li>
</ul>

<p>I generally recommend enabling <code>isolatedModules</code> if your project uses a tool other than TypeScript to transpile to<a data-type="indexterm" data-primary="importing" data-secondary="via modules" data-tertiary="configuration options for" data-startref="import-module-config" id="idm45584669522112"/><a data-type="indexterm" data-primary="exporting" data-secondary="via modules" data-tertiary="configuration options for" data-startref="export-module-config" id="idm45584669520608"/> JavaScript.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="JavaScript"><div class="sect1" id="idm45584669518720">
<h1>JavaScript</h1>

<p>While <a data-type="indexterm" data-primary="configuration options" data-secondary="for JavaScript files" data-secondary-sortas="JavaScript files" id="config-javascript"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="configuration options for" id="javascript-config"/>TypeScript is lovely and I hope you want to always write code in it, you don’t have to write all your source files in TypeScript.
Although TypeScript by default ignores files with a <em>.js</em> or <em>.jsx</em> extension, using its <code>allowJs</code> and/or <code>checkJs</code> compiler options will allow it to read from, compile, and even—in a limited capacity—type check JavaScript files.</p>
<div data-type="tip"><h6>Tip</h6>
<p>A common strategy for converting an existing JavaScript project to TypeScript is to start off with only a few files initially converted to TypeScript.
More files may be added over time until there are no more JavaScript files left.
You don’t have to go all-in on TypeScript until you’re ready to!</p>
</div>








<section data-type="sect2" data-pdf-bookmark="allowJs"><div class="sect2" id="idm45584669511136">
<h2>allowJs</h2>

<p>The <code>allowJs</code> compiler<a data-type="indexterm" data-primary="configuration options" data-secondary="for JavaScript files" data-tertiary="allowJs compiler option" data-secondary-sortas="JavaScript files" id="idm45584669508800"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="configuration options for" data-tertiary="allowJs compiler option" id="idm45584669507248"/><a data-type="indexterm" data-primary="allowJs compiler option" id="idm45584669506064"/> option allows constructs declared in JavaScript files to factor into type checking TypeScript files
When combined with the <code>jsx</code> compiler option, <em>.jsx</em> files are also allowed.</p>

<p>For example, take this <em>index.ts</em> importing a <code>value</code> declared in a <em>values.js</em> file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">value</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./values"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Quote: '</code><code class="si">${</code><code class="nx">value</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code><code class="si">}</code><code class="sb">'`</code><code class="p">);</code></pre>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// values.js</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="s2">"We cannot succeed when half of us are held back."</code><code class="p">;</code></pre>

<p>Without <code>allowJs</code> enabled, the <code>import</code> statement would not have a known type.
It would be implicitly <code>any</code> by default or trigger a type error like “Could not find a declaration file for module <code>"./values"</code>.”</p>

<p><code>allowJs</code> also adds JavaScript files to the list of files compiled to the ECMAScript target and emitted as JavaScript.
Source maps and declaration files will be produced as well if the options to do so are enabled:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --allowJs</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"allowJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>With <code>allowJs</code> enabled, the imported <code>value</code> would be type <code>string</code>.
No type errors would be reported.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="checkJs"><div class="sect2" id="idm45584669510512">
<h2>checkJs</h2>

<p>TypeScript <a data-type="indexterm" data-primary="configuration options" data-secondary="for JavaScript files" data-tertiary="checkJs compiler option" data-secondary-sortas="JavaScript files" id="config-javascript-checkjs"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="configuration options for" data-tertiary="checkJs compiler option" id="javascript-config-checkjs"/><a data-type="indexterm" data-primary="checkJs compiler option" id="checkjs"/>can do more than just factor JavaScript files into type checking TypeScript files: it can type check JavaScript files too.
The <code>checkJs</code> compiler option serves two purposes:</p>

<ul>
<li>
<p>Defaulting <code>allowJs</code> to <code>true</code> if it wasn’t already</p>
</li>
<li>
<p>Enabling the type checker on <em>.js</em> and <em>.jsx</em> files</p>
</li>
</ul>

<p>Enabling <code>checkJs</code> will make TypeScript treat JavaScript files as if they were TypeScript files that don’t have any TypeScript-specific syntax.
Type mismatches, misspelled variable names, and so on will all cause type errors as they normally would in a TypeScript file:</p>

<pre data-type="programlisting" data-code-language="shell">tsc --checkJs</pre>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"checkJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>With <code>checkJs</code> enabled, this JavaScript file would cause a type-checking complaint for an incorrect variable name:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// index.js</code>
<code class="kd">let</code> <code class="nx">myQuote</code> <code class="o">=</code> <code class="s2">"Each person must live their life as a model for others."</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">quote</code><code class="p">);</code>
<code class="c1">//          ~~~~~</code>
<code class="c1">// Error: Cannot find name 'quote'. Did you mean 'myQuote'?</code></pre>

<p>Without <code>checkJs</code> enabled, TypeScript would not have reported a type error for that likely bug.</p>










<section data-type="sect3" data-pdf-bookmark="@ts-check"><div class="sect3" id="idm45584669311552">
<h3>@ts-check</h3>

<p>Alternately, <code>checkJs</code> can be <a data-type="indexterm" data-primary="@ts-check comment" id="idm45584669309648"/><a data-type="indexterm" data-primary="@ts-check comment" data-primary-sortas="ts-check comment" id="idm45584669308912"/>enabled on a file-by-file basis by including a 
<span class="keep-together"><code>// @ts-check</code></span> comment on top of the file.
Doing so enables the <code>checkJs</code> option for just that JavaScript <a data-type="indexterm" data-primary="configuration options" data-secondary="for JavaScript files" data-tertiary="checkJs compiler option" data-secondary-sortas="JavaScript files" data-startref="config-javascript-checkjs" id="idm45584669269664"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="configuration options for" data-tertiary="checkJs compiler option" data-startref="javascript-config-checkjs" id="idm45584669267904"/><a data-type="indexterm" data-primary="checkJs compiler option" data-startref="checkjs" id="idm45584669266480"/>file:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// index.js</code>
<code class="c1">// @ts-check</code>
<code class="kd">let</code> <code class="nx">myQuote</code> <code class="o">=</code> <code class="s2">"Each person must live their life as a model for others."</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">quote</code><code class="p">);</code>
<code class="c1">//          ~~~~~~~</code>
<code class="c1">// Error: Cannot find name 'quote'. Did you mean 'myQuote'?</code></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="JSDoc Support"><div class="sect2" id="idm45584669365680">
<h2>JSDoc Support</h2>

<p>Because <a data-type="indexterm" data-primary="configuration options" data-secondary="for JavaScript files" data-tertiary="JSDoc support" data-secondary-sortas="JavaScript files" id="config-javascript-jsdoc"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="configuration options for" data-tertiary="JSDoc support" id="javascript-config-jsdoc"/><a data-type="indexterm" data-primary="JSDoc" id="jsdoc-support"/><a data-type="indexterm" data-primary="documentation" data-secondary="in JavaScript" id="documentation-javascript-support"/>JavaScript doesn’t have TypeScript’s rich type syntax, the types of values declared in JavaScript files are often not as precise as those declared in TypeScript files.
For example, while TypeScript can infer the value of an object declared as a variable in a JavaScript file, there’s no native JavaScript way to declare in that file that the value adheres to any particular interface.</p>

<p>I mentioned back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch01.xhtml#from_javascript_to_typescript">Chapter 1, “From JavaScript to TypeScript”</a> that the JSDoc community standard provides some ways to describe types using comments.
When <code>allowJs</code> and/or <code>checkJs</code> are enabled, TypeScript will recognize any JSDoc definitions in code.</p>

<p>For example, this snippet declares in JSDoc that the <code>sentenceCase</code> function takes in a <code>string</code>.
TypeScript can then infer that it returns a <code>string</code>.
With <code>checkJs</code> enabled, TypeScript would know to report a type error for passing it a <code>string[]</code> later:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// index.js</code>

<code class="cm">/**</code>
<code class="cm"> * @param {string} text</code>
<code class="cm"> */</code>
<code class="kd">function</code> <code class="nx">sentenceCase</code><code class="p">(</code><code class="nx">text</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">text</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">toUpperCase</code><code class="p">()</code><code class="si">}</code><code class="sb"> </code><code class="si">${</code><code class="nx">text</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="si">}</code><code class="sb">.`</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">sentenceCase</code><code class="p">(</code><code class="s2">"hello world"</code><code class="p">);</code><code class="c1">// Ok</code>

<code class="nx">sentenceCase</code><code class="p">([</code><code class="s2">"hello"</code><code class="p">,</code> <code class="s2">"world"</code><code class="p">]);</code>
<code class="c1">//           ~~~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type 'string[]' is not</code>
<code class="c1">// assignable to parameter of type 'string'.</code></pre>

<p>TypeScript’s JSDoc support is useful for incrementally adding type checking for projects that don’t have the time or developer familiarity to convert to TypeScript.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The full list of supported JSDoc syntax is available<a data-type="indexterm" data-primary="configuration options" data-secondary="for JavaScript files" data-tertiary="JSDoc support" data-secondary-sortas="JavaScript files" data-startref="config-javascript-jsdoc" id="idm45584669170240"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="configuration options for" data-tertiary="JSDoc support" data-startref="javascript-config-jsdoc" id="idm45584669168512"/><a data-type="indexterm" data-primary="JSDoc" data-startref="jsdoc-support" id="idm45584669167056"/><a data-type="indexterm" data-primary="documentation" data-secondary="in JavaScript" data-startref="documentation-javascript-support" id="idm45584669166112"/> on <a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html"><em class="hyperlink">https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html</em></a>.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Configuration Extensions"><div class="sect1" id="idm45584669163456">
<h1>Configuration Extensions</h1>

<p>As you write more and more TypeScript projects, you may find yourself writing the same project settings repeatedly.
Although TypeScript doesn’t allow configuration files to be written in JavaScript and use <code>import</code> or <code>require</code>, it does offer a mechanism for a TSConfig file to opt into “extending,” or copying in configuration values, from another configuration file.</p>








<section data-type="sect2" data-pdf-bookmark="extends"><div class="sect2" id="idm45584669161200">
<h2>extends</h2>

<p>A <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="extends compiler option" id="config-tsconfig-extends"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="extends compiler option" id="tsconfig-extends"/><a data-type="indexterm" data-primary="extends compiler option" id="extends-option"/>TSConfig may extend from another TSConfig with the <code>extends</code> configuration option.
<code>extends</code> takes in a path to another TSConfig file and indicates that all settings from that file should be copied over.
It behaves similarly to the <code>extends</code> keyword on classes: any option declared on the derived, or child, configuration will override any option of the same name on the base, or parent, configuration.</p>

<p>For example, many repositories that have multiple TSConfigs, such as monorepos containing multiple <em>packages/*</em> directories, by convention create a <em>tsconfig.base.json</em> file for <em>tsconfig.json</em> files to extend from:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// tsconfig.base.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// packages/core/tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../../tsconfig.base.json"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"includes"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Note that <code>compilerOptions</code> are factored in recursively.
Each compiler option from a base TSConfig will copy over to a derived TSConfig unless the derived TSConfig overrides that specific option.</p>

<p>If the previous example were to add a TSConfig that adds the <code>allowJs</code> option, that new derived TSConfig would still have <code>compilerOptions.strict</code> set to <code>true</code>:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// packages/js/tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../../tsconfig.base.json"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"allowJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">},</code><code class="w"/>
<code class="w">  </code><code class="nt">"includes"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>










<section data-type="sect3" data-pdf-bookmark="Extending modules"><div class="sect3" id="idm45584668989024">
<h3>Extending modules</h3>

<p>The <code>extends</code> property<a data-type="indexterm" data-primary="modules" data-secondary="extending" id="module-extend"/> may point to either kind of JavaScript import:</p>
<dl>
<dt>Absolute</dt>
<dd>
<p>Starting with <code>@</code> or an alphabetical letter</p>
</dd>
<dt>Relative</dt>
<dd>
<p>A local file path starting with <code>.</code></p>
</dd>
</dl>

<p>When an <code>extends</code> value is an absolute path, it indicates to extend the TSConfig from an npm module.
TypeScript will use the normal Node module resolution system to find a package matching the name.
If that package’s <code>package.json</code> contains a <code>"tsconfig"</code> field containing a relative path string, the TSConfig file at that path will be used.
Otherwise, the package’s <em>tsconfig.json</em> file will be used.</p>

<p>Many organizations use npm packages to standardize TypeScript compiler options across repositories and/or within monorepos.
The following TSConfig files are what you might set up for a monorepo in a <code>@my-org</code> organization.
<code>packages/js</code> needs to specify the <code>allowJs</code> compiler option, while <code>packages/ts</code> does not change any compiler <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="extends compiler option" data-startref="config-tsconfig-extends" id="idm45584668938784"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="extends compiler option" data-startref="tsconfig-extends" id="idm45584668937264"/><a data-type="indexterm" data-primary="extends compiler option" data-startref="extends-option" id="idm45584668936048"/>options:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// packages/tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"strict"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// packages/js/tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"@my-org/tsconfig"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"allowJs"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">},</code><code class="w"/>
<code class="w">  </code><code class="nt">"includes"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// packages/ts/tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"@my-org/tsconfig"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"includes"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="s2">"src"</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Configuration Bases"><div class="sect2" id="idm45584668814960">
<h2>Configuration Bases</h2>

<p>Instead of <a data-type="indexterm" data-primary="configuration options" data-secondary="TSConfig files" data-tertiary="configuration bases" id="idm45584668806672"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="configuration bases" id="idm45584668805392"/><a data-type="indexterm" data-primary="configuration bases (TSConfig)" id="idm45584668804448"/>creating your own configuration from scratch or the <code>--init</code> suggestions, you can start with a premade “base” TSConfig file tailored to a particular runtime environment.
These premade configuration bases are available on the npm package registry under <code>@tsconfig/</code>, such as <code>@tsconfig/recommended</code> or <code>@tsconfig/node16</code>.</p>

<p>For example, to install the recommended TSConfig base for <code>deno</code>:</p>

<pre data-type="programlisting" data-code-language="shell">npm install --save-dev @tsconfig/deno
<code class="c1"># or</code>
yarn add --dev @tsconfig/deno</pre>

<p>Once a configuration base package is installed, it can be referenced like any other npm package configuration extension:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"extends"</code><code class="p">:</code><code class="w"> </code><code class="s2">"@tsconfig/deno/tsconfig.json"</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>The full list of TSConfig bases is documented on <a href="https://github.com/tsconfig/bases"><em class="hyperlink">https://github.com/tsconfig/bases</em></a>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>It is generally a good idea to know what TypeScript configuration options your file is using, even if you aren’t changing them 
<span class="keep-together">yourself.</span></p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Project References"><div class="sect1" id="idm45584668743568">
<h1>Project References</h1>

<p>Each of the<a data-type="indexterm" data-primary="configuration options" data-secondary="project references" data-tertiary="purpose of" id="idm45584668742160"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="project references" data-tertiary="purpose of" id="idm45584668740880"/><a data-type="indexterm" data-primary="project references" data-secondary="purpose of" id="idm45584668739664"/> TypeScript configuration files I’ve shown so far have assumed they manage all the source files of a project.
It can be useful in larger projects to use different configuration files for different areas of a project.
TypeScript allows defining a system of “project references” where multiple projects can be built together.
Setting up project references is a little more work than using a single TSConfig file but comes with several key benefits:</p>

<ul>
<li>
<p>You can specify different compiler options for certain areas of code.</p>
</li>
<li>
<p>TypeScript will be able to cache build outputs for individual projects, often resulting in significantly faster build times for large projects.</p>
</li>
<li>
<p>Project references enforce a “dependency tree” (only allowing certain projects to import files from certain other projects), which can help structure discrete areas of code.</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Project references are generally used in larger projects that have multiple distinct areas of code, such as monorepos and modular component systems.
You probably don’t want to use them for small projects that don’t have dozens or more files.</p>
</div>

<p>The following three sections show how to build up project settings to enable project references:</p>

<ul>
<li>
<p><code>composite</code> mode on a TSConfig enforces that it works in ways suitable for multi-TSConfig build modes.</p>
</li>
<li>
<p><code>references</code> in a TSConfig indicate which composite TSConfigs it relies on.</p>
</li>
<li>
<p>Build mode uses composite TSConfig references to orchestrate building their files.</p>
</li>
</ul>








<section data-type="sect2" data-pdf-bookmark="composite"><div class="sect2" id="idm45584668713728">
<h2>composite</h2>

<p>TypeScript <a data-type="indexterm" data-primary="configuration options" data-secondary="project references" data-tertiary="composite compiler option" id="config-projectref-composite"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="project references" data-tertiary="composite compiler option" id="tsconfig-projectref-composite"/><a data-type="indexterm" data-primary="project references" data-secondary="composite compiler option" id="projectref-composite"/><a data-type="indexterm" data-primary="composite compiler option" id="composite-option"/>allows a project to opt into the <code>composite</code> configuration option to indicate that its file system inputs and outputs obey constraints that make it easier for build tools to determine whether its build outputs are up-to-date compared to its build inputs.
When <code>composite</code> is <code>true</code>:</p>

<ul>
<li>
<p>The rootDir setting, if not already explicitly set, defaults to the directory containing the TSConfig file.</p>
</li>
<li>
<p>All implementation files must be matched by an include pattern or listed in the <code>files</code> array.</p>
</li>
<li>
<p><code>declaration</code> must be turned on.</p>
</li>
</ul>

<p>This configuration snippet matches all conditions for enabling <code>composite</code> mode in a <code>core/</code> directory:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// core/tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"declaration"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">  </code><code class="p">},</code><code class="w"/>
<code class="w">  </code><code class="nt">"composite"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>These changes help TypeScript enforce that all input files to the project create a matching <em>.d.ts</em> file.
<code>composite</code> is generally most useful in combination with the following <code>references</code> configuration option.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="references"><div class="sect2" id="idm45584668643392">
<h2>references</h2>

<p>A <a data-type="indexterm" data-primary="configuration options" data-secondary="project references" data-tertiary="references compiler option" id="idm45584668653088"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="project references" data-tertiary="references compiler option" id="idm45584668651840"/><a data-type="indexterm" data-primary="project references" data-secondary="references compiler option" id="idm45584668650656"/><a data-type="indexterm" data-primary="references compiler option" id="idm45584668649744"/>TypeScript project can indicate it relies on the outputs generated by a composite TypeScript project with a <code>references</code> setting in its TSConfig.
Importing modules from a referenced project will be seen in the type system as importing from its output <em>.d.ts</em> declaration file(s).</p>

<p>This configuration snippet sets up a <em>shell/</em> directory to reference a <em>core/</em> directory as its inputs:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// shell/tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"references"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nt">"path"</code><code class="p">:</code><code class="w"> </code><code class="s2">"../core"</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>references</code> configuration option will not be copied from base TSConfigs to derived TSConfigs via <code>extends</code>.</p>
</div>

<p><code>references</code> is generally most useful in combination with the following build mode.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Build Mode"><div class="sect2" id="idm45584668669264">
<h2>Build Mode</h2>

<p>Once <a data-type="indexterm" data-primary="configuration options" data-secondary="project references" data-tertiary="build mode" id="config-projectref-build"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="project references" data-tertiary="build mode" id="tsconfig-projectref-build"/><a data-type="indexterm" data-primary="project references" data-secondary="build mode" id="projectref-build"/><a data-type="indexterm" data-primary="build mode (tsc command)" id="buildmode"/><a data-type="indexterm" data-primary="tsc command" data-secondary="build mode" id="tsc-build"/>an area of code has been set up to use project references, it will be possible to use <code>tsc</code> in its alternate “build” mode via the <code>-b</code>/<code>--b</code> CLI flag.
Build mode enhances <code>tsc</code> into something of a project build coordinator.
It lets <code>tsc</code> rebuild only the projects that have been changed since the last build, based on when their contents and their file outputs were last generated.</p>

<p>More precisely, TypeScript’s build mode will do the following when given a TSConfig:</p>
<ol>
<li>
<p>Find that TSConfig’s referenced projects.</p>
</li>
<li>
<p>Detect if they are up-to-date.</p>
</li>
<li>
<p>Build out-of-date projects in the correct order.</p>
</li>
<li>
<p>Build the provided TSConfig if it or any of its dependencies have changed.</p>
</li>

</ol>

<p>The ability of TypeScript’s build mode to skip rebuilding up-to-date projects can significantly improve build performance.</p>










<section data-type="sect3" data-pdf-bookmark="Coordinator configurations"><div class="sect3" id="idm45584668604768">
<h3>Coordinator configurations</h3>

<p>A common handy pattern for setting up TypeScript project references in a repository is to set up a root-level <code>tsconfig.json</code> with an empty <code>files</code> array and references to all the project references in the repository.
That root TSConfig won’t direct TypeScript to build any files itself.
Instead it will act purely to tell TypeScript to build referenced projects as needed.</p>

<p>This <code>tsconfig.json</code> indicates to build the <code>packages/core</code> and <code>packages/shell</code> projects in a repository:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// tsconfig.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"files"</code><code class="p">:</code><code class="w"> </code><code class="p">[],</code><code class="w"/>
<code class="w">  </code><code class="nt">"references"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nt">"path"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./packages/core"</code><code class="w"> </code><code class="p">},</code><code class="w"/>
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nt">"path"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./packages/shell"</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>I personally like to standardize having a script in my <code>package.json</code> named <code>build</code> or <code>compile</code> that calls to <code>tsc -b</code> as a shortcut:</p>

<pre data-type="programlisting" data-code-language="json"><code class="c1">// package.json</code><code class="w"/>
<code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"scripts"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"build"</code><code class="p">:</code><code class="w"> </code><code class="s2">"tsc -b"</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Build-mode options"><div class="sect3" id="idm45584668477392">
<h3>Build-mode options</h3>

<p>Build mode supports a few build-specific CLI options:</p>

<ul>
<li>
<p><code>--clean</code>: deletes the outputs of the specified projects (may be combined with <code>--dry</code>)</p>
</li>
<li>
<p><code>--dry</code>: shows what would be done but doesn’t actually build anything</p>
</li>
<li>
<p><code>--force</code>: acts as if all projects are out of date</p>
</li>
<li>
<p><code>-w</code>/<code>--watch</code>: similar to the typical TypeScript watch mode</p>
</li>
</ul>

<p>Because build mode supports watch mode, running a command like <code>tsc -b -w</code> can be a fast way to get an up-to-date listing of all compiler errors in a large<a data-type="indexterm" data-primary="configuration options" data-secondary="project references" data-tertiary="build mode" data-startref="config-projectref-build" id="idm45584668472960"/><a data-type="indexterm" data-primary="TSConfig files" data-secondary="project references" data-tertiary="build mode" data-startref="tsconfig-projectref-build" id="idm45584668471440"/><a data-type="indexterm" data-primary="project references" data-secondary="build mode" data-startref="projectref-build" id="idm45584668469984"/><a data-type="indexterm" data-primary="build mode (tsc command)" data-startref="buildmode" id="idm45584668468768"/><a data-type="indexterm" data-primary="tsc command" data-secondary="build mode" data-startref="tsc-build" id="idm45584668467856"/> project.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584668466256">
<h1>Summary</h1>

<p>In this chapter, you went over many of the important configuration options provided by TypeScript:</p>

<ul>
<li>
<p>Using <code>tsc</code>, including its pretty and watch modes</p>
</li>
<li>
<p>Using TSConfig files, including creating one with <code>tsc --init</code></p>
</li>
<li>
<p>Changing which files will be included by the TypeScript compiler</p>
</li>
<li>
<p>Allowing JSX syntax in <em>.tsx</em> files and/or JSON syntax in <em>.json</em> files</p>
</li>
<li>
<p>Changing the directory, ECMAScript version target, declaration file, and/or source map outputs with files</p>
</li>
<li>
<p>Changing the built-in library types used in compilation</p>
</li>
<li>
<p>Strict mode and useful strict flags such as <code>noImplicitAny</code> and <code>strictNullChecks</code></p>
</li>
<li>
<p>Supporting different module systems and changing module resolution</p>
</li>
<li>
<p>Allowing including JavaScript files, and opting into type checking those files</p>
</li>
<li>
<p>Using <code>extends</code> to share configuration options between files</p>
</li>
<li>
<p>Using project references and build mode to orchestrate multi-TSConfig builds</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/configuration-options"><em class="hyperlink">https://learningtypescript.com/configuration-options</em></a>.</p>
</div>
<blockquote class="joke">
<p>What is a disciplinarian’s favorite TypeScript compiler option?</p>

<p><code>strict</code>.</p></blockquote>
</div></section>







</div></section></div></body></html>