["```\nsetTimeout(() => console.info('A'), 1)\nsetTimeout(() => console.info('B'), 2)\nconsole.info('C')\n```", "```\nfunction readFile(\n  path: string,\n  options: {encoding: string, flag?: string},\n  callback: (err: Error | null, data: string | null) => void\n): void\n```", "```\nnpm install @types/node --save-dev\n```", "```\nimport * as fs from 'fs'\n\n// Read data from an Apache server's access log\nfs.readFile(\n  '/var/log/apache2/access_log',\n  {encoding: 'utf8'},\n  (error, data) => {\n    if (error) {\n      console.error('error reading!', error)\n      return\n    }\n    console.info('success reading!', data)\n  }\n)\n\n// Concurrently, write data to the same access log\nfs.appendFile(\n  '/var/log/apache2/access_log',\n  'New access log entry',\n  error => {\n    if (error) {\n      console.error('error writing!', error)\n    }\n  })\n```", "```\nasync1((err1, res1) => {\n  if (res1) {\n    async2(res1, (err2, res2) => {\n      if (res2) {\n        async3(res2, (err3, res3) => {\n          // ...\n        })\n      }\n    })\n  }\n})\n```", "```\nfunction appendAndReadPromise(path: string, data: string): Promise<string> {\n  return appendPromise(path, data)\n    .then(() => readPromise(path))\n    .catch(error => console.error(error))\n}\n```", "```\nfunction appendAndRead(\n  path: string,\n  data: string\n  cb: (error: Error | null, result: string | null) => void\n) {\n  appendFile(path, data, error => {\n    if (error) {\n      return cb(error, null)\n    }\n    readFile(path, (error, result) => {\n      if (error) {\n        return cb(error, null)\n      }\n      cb(null, result)\n    })\n  })\n}\n```", "```\nclass Promise {\n}\n```", "```\ntype Executor = (\n  resolve: Function,\n  reject: Function\n) => void\n\nclass Promise {\n  constructor(f: Executor) {}\n}\n```", "```\nimport {readFile} from 'fs'\n\nreadFile(path, (error, result) => {\n  // ...\n})\n```", "```\nimport {readFile} from 'fs'\n\nfunction readFilePromise(path: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    readFile(path, (error, result) => {\n      if (error) {\n        reject(error)\n      } else {\n        resolve(result)\n      }\n    })\n  })\n}\n```", "```\ntype Executor`<``T``,` `E` `extends` `Error``>` = (\n  resolve: `(``result``:` `T``)` `=``>` `void`,\n  reject: `(``error``:` `E``)` `=``>` `void`\n) => void\n*`// ...`*\n\n```", "```\n// ...\nclass Promise<T, E extends Error> {\n  constructor(f: Executor<T, E>) {}\n}\n```", "```\n*`// ...`*\nclass Promise<T, E extends Error> {\n  constructor(f: Executor<T, E>) {}\n  `then``<``U``,` `F` `extends` `Error``>``(``g``:` `(``result``:` `T``)` `=``>` `Promise``<``U``,` `F``>``)``:` `Promise``<``U``,` `F``>`\n  `catch``<``U``,` `F` `extends` `Error``>``(``g``:` `(``error``:` `E``)` `=``>` `Promise``<``U``,` `F``>``)``:` `Promise``<``U``,` `F``>`\n}\n\n```", "```\nlet a: () => Promise<string, TypeError> = // ...\nlet b: (s: string) => Promise<number, never> = // ...\nlet c: () => Promise<boolean, RangeError> = // ...\n\na()\n  .then(b)\n  .catch(e => c()) // b won't error, so this is if a errors\n  .then(result => console.info('Done', result))\n  .catch(e => console.error('Error', e))\n```", "```\ntype Executor<T> = (\n  resolve: (result: T) => void,\n  reject: (error: unknown) => void\n) => void\n\nclass Promise<T> {\n  constructor(f: Executor<T>) {}\n  then<U>(g: (result: T) => Promise<U>): Promise<U> {\n    // ...\n  }\n  catch<U>(g: (error: unknown) => Promise<U>): Promise<U> {\n    // ...\n  }\n}\n```", "```\nfunction getUser() {\n  getUserID(18)\n    .then(user => getLocation(user))\n    .then(location => console.info('got location', location))\n    .catch(error => console.error(error))\n    .finally(() => console.info('done getting location'))\n}\n```", "```\n`async` function getUser() {\n  try {\n    let user = `await` getUserID(18)\n    let location = `await` getLocation(user)\n    console.info('got location', user)\n  } catch(error) {\n    console.error(error)\n  } finally {\n    console.info('done getting location')\n  }\n}\n\n```", "```\ninterface Emitter {\n\n  // Send an event\n  emit(channel: string, value: unknown): void\n\n  // Do something when an event is sent\n  on(channel: string, f: (value: unknown) => void): void\n\n}\n```", "```\nimport Redis from 'redis'\n\n// Create a new instance of a Redis client\nlet client = redis.createClient()\n\n// Listen for a few events emitted by the client\nclient.on('ready', () => console.info('Client is ready'))\nclient.on('error', e => console.error('An error occurred!', e))\nclient.on('reconnecting', params => console.info('Reconnecting...', params))\n\n```", "```\ntype RedisClient = {\n  on(event: 'ready', f: () => void): void\n  on(event: 'error', f: (e: Error) => void): void\n  on(event: 'reconnecting',\n     f: (params: {attempt: number, delay: number}) => void): void\n}\n```", "```\ntype Events = { ![1](assets/1.png)\n  ready: void\n  error: Error\n  reconnecting: {attempt: number, delay: number}\n}\n\ntype RedisClient = { ![2](assets/2.png)\n  on<E extends keyof Events>(\n    event: E,\n    f: (arg: Events[E]) => void\n  ): void\n}\n```", "```\n// ...\ntype RedisClient = {\n  on<E extends keyof Events>(\n    event: E,\n    f: (arg: Events[E]) => void\n  ): void\n  emit<E extends keyof Events>(\n    event: E,\n    arg: Events[E]\n  ): void\n}\n```", "```\n{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"es2015\"]\n  }\n}\n\n```", "```\n{\n  \"compilerOptions\": {\n    \"lib\": [\"webworker\", \"es2015\"]\n  }\n}\n\n```", "```\n// MainThread.ts\nlet worker = new Worker('WorkerScript.js')\n```", "```\n*`// MainThread.ts`*\nlet worker = new Worker('WorkerScript.js')\n\n`worker``.``postMessage``(``'some data'``)`\n\n```", "```\n// WorkerScript.ts\nonmessage = e => {\n  console.log(e.data) // Logs out 'some data'\n}\n```", "```\n// MainThread.ts\nlet worker = new Worker('WorkerScript.js')\nworker.onmessage = e => {\n  console.log(e.data) // Logs out 'Ack: \"some data\"'\n}\nworker.postMessage('some data')\n\n// WorkerScript.ts\nonmessage = e => {\n  console.log(e.data) // Logs out 'some data'\n  postMessage(Ack: \"${e.data}\")\n}\n```", "```\n// MainThread.ts\ntype Message = string\ntype ThreadID = number\ntype UserID = number\ntype Participants = UserID[]\n\ntype Commands = {\n  sendMessageToThread: [ThreadID, Message]\n  createThread: [Participants]\n  addUserToThread: [ThreadID, UserID]\n  removeUserFromThread: [ThreadID, UserID]\n}\n\ntype Events = {\n  receivedMessage: [ThreadID, UserID, Message]\n  createdThread: [ThreadID, Participants]\n  addedUserToThread: [ThreadID, UserID]\n  removedUserFromThread: [ThreadID, UserID]\n}\n```", "```\n// WorkerScript.ts type Command = ![1](assets/1.png)\n  | {type: 'sendMessageToThread', data: [ThreadID, Message]} ![2](assets/2.png)\n  | {type: 'createThread', data: [Participants]}\n  | {type: 'addUserToThread', data: [ThreadID, UserID]}\n  | {type: 'removeUserFromThread', data: [ThreadID, UserID]}\n\nonmessage = e => ![3](assets/3.png)\n  processCommandFromMainThread(e.data)\n\nfunction processCommandFromMainThread( ![4](assets/4.png)\n  command: Command\n) {\n  switch (command.type) { ![5](assets/5.png)\n    case 'sendMessageToThread':\n      let [threadID, message] = command.data\n      console.log(message)\n    // ...\n  }\n}\n```", "```\nimport EventEmitter from 'events'\n\nclass SafeEmitter<\n  Events extends Record<PropertyKey, unknown[]>  ![1](assets/1.png)\n> {\n  private emitter = new EventEmitter  ![2](assets/2.png)\n  emit<K extends keyof Events>(  ![3](assets/3.png)\n    channel: K,\n    ...data: Events[K]\n  ) {\n    return this.emitter.emit(channel, ...data)\n  }\n  on<K extends keyof Events>(  ![4](assets/4.png)\n    channel: K,\n    listener: (...data: Events[K]) => void\n  ) {\n    return this.emitter.on(channel, listener)\n  }\n}\n```", "```\n// WorkerScript.ts\ntype Commands = {\n  sendMessageToThread: [ThreadID, Message]\n  createThread: [Participants]\n  addUserToThread: [ThreadID, UserID]\n  removeUserFromThread: [ThreadID, UserID]\n}\n\ntype Events = {\n  receivedMessage: [ThreadID, UserID, Message]\n  createdThread: [ThreadID, Participants]\n  addedUserToThread: [ThreadID, UserID]\n  removedUserFromThread: [ThreadID, UserID]\n}\n\n// Listen for events coming from the main thread\nlet commandEmitter = new SafeEmitter\t<Commands>()\n\n// Emit events back to the main thread\nlet eventEmitter = new SafeEmitter\t<Events>()\n\n// Wrap incoming commands from the main thread\n// using our typesafe event emitter\nonmessage = command =>\n  commandEmitter.emit(\n    command.data.type,\n    ...command.data.data\n  )\n\n// Listen for events issued by the worker, and send them to the main thread\neventEmitter.on('receivedMessage', data =>\n  postMessage({type: 'receivedMessage', data})\n)\neventEmitter.on('createdThread', data =>\n  postMessage({type: 'createdThread', data})\n)\n// etc.\n\n// Respond to a sendMessageToThread command from the main thread\ncommandEmitter.on('sendMessageToThread', (threadID, message) =>\n  console.log(OK, I will send a message to threadID ${threadID})\n)\n\n// Send an event back to the main thread\neventEmitter.emit('createdThread', 123, [456, 789])\n\n```", "```\n// MainThread.ts\ntype Commands = {\n  sendMessageToThread: [ThreadID, Message]\n  createThread: [Participants]\n  addUserToThread: [ThreadID, UserID]\n  removeUserFromThread: [ThreadID, UserID]\n}\n\ntype Events = {\n  receivedMessage: [ThreadID, UserID, Message]\n  createdThread: [ThreadID, Participants]\n  addedUserToThread: [ThreadID, UserID]\n  removedUserFromThread: [ThreadID, UserID]\n}\n\nlet commandEmitter = new SafeEmitter\t<Commands>()\nlet eventEmitter = new SafeEmitter\t<Events>()\n\nlet worker = new Worker('WorkerScript.js')\n\n// Listen for events coming from our worker,\n// and re-emit them using our typesafe event emitter\nworker.onmessage = event =>\n  eventEmitter.emit(\n    event.data.type,\n    ...event.data.data\n  )\n\n// Listen for commands issues by this thread, and send them to our worker\ncommandEmitter.on('sendMessageToThread', data =>\n  worker.postMessage({type: 'sendMessageToThread', data})\n)\ncommandEmitter.on('createThread', data =>\n  worker.postMessage({type: 'createThread', data})\n)\n// etc.\n\n// Do something when the worker tells us a new thread was created\neventEmitter.on('createdThread', (threadID, participants) =>\n  console.log('Created a new chat thread!', threadID, participants)\n)\n\n// Send a command to our worker\ncommandEmitter.emit('createThread', [123, 456])\n\n```", "```\ntype Matrix = number[][]\n\ntype MatrixProtocol = {\n  determinant: {\n    in: [Matrix]\n    out: number\n  }\n  'dot-product': {\n    in: [Matrix, Matrix]\n    out: Matrix\n  }\n  invert: {\n    in: [Matrix]\n    out: Matrix\n  }\n}\n```", "```\ntype Protocol = { ![1](assets/1.png)\n  [command: string]: {\n    in: unknown[]\n    out: unknown\n  }\n}\n\nfunction createProtocol<P extends Protocol>(script: string) { ![2](assets/2.png)\n return <K extends keyof P>(command: K) => ![3](assets/3.png)\n   (...args: P[K]['in']) => ![4](assets/4.png)\n    new Promise<P[K]['out']>((resolve, reject) => { ![5](assets/5.png)\n      let worker = new Worker(script)\n      worker.onerror = reject\n      worker.onmessage = event => resolve(event.data.data)\n      worker.postMessage({command, args})\n    })\n}\n```", "```\nlet runWithMatrixProtocol = createProtocol<MatrixProtocol>(\n  'MatrixWorkerScript.js'\n)\nlet parallelDeterminant = runWithMatrixProtocol('determinant')\n\nparallelDeterminant([[1, 2], [3, 4]])\n  .then(determinant =>\n    console.log(determinant) // -2\n  )\n```", "```\nnpm install @types/node --save-dev\n```", "```\n// MainThread.ts import {fork} from 'child_process'\n\nlet child = fork('./ChildThread.js') ![1](assets/1.png)\n\nchild.on('message', data => ![2](assets/2.png)\n  console.info('Child process sent a message', data)\n)\n\nchild.send({type: 'syn', data: [3]}) ![3](assets/3.png)\n```", "```\n// ChildThread.ts process.on('message', data => ![1](assets/1.png)\n  console.info('Parent process sent a message', data)\n)\n\nprocess.send({type: 'ack', data: [3]}) ![2](assets/2.png)\n```", "```\n    import {readFile} from 'fs'\n\n    let readFilePromise = promisify(readFile)\n    readFilePromise('./myfile.ts')\n      .then(result => console.log('success reading file', result.toString()))\n      .catch(error => console.error('error reading file', error))\n    ```"]