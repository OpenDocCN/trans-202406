<html><head></head><body><section data-pdf-bookmark="Chapter 11. Flexible Box Layout" data-type="chapter" epub:type="chapter"><div class="chapter" id="flexbox">&#13;
<h1><span class="label">Chapter 11. </span>Flexible Box Layout</h1>&#13;
&#13;
&#13;
<p>The <a href="http://www.w3.org/TR/css-flexbox-1">CSS Flexible Box Module Level 1</a>, or <a data-primary="flexible box (flexbox) layout" data-type="indexterm" id="ix_flexbox_ch11"/>flexbox for short, makes the once difficult tasks of laying out&#13;
certain kinds of pages, widgets, applications, and galleries almost simple.&#13;
With flexbox, you often don’t need a CSS framework.&#13;
In this chapter, you’ll learn how to use just a few lines of CSS to create almost any feature your site requires.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flexbox Fundamentals" data-type="sect1"><div class="sect1" id="learning-flexbox">&#13;
<h1>Flexbox Fundamentals</h1>&#13;
&#13;
<p><em>Flexbox</em> is a simple and powerful way to lay out page components&#13;
by dictating how space is distributed, content is&#13;
aligned, and elements are visually ordered. Content can easily&#13;
be arranged vertically or horizontally, and&#13;
can be laid out along a single axis or wrapped across&#13;
multiple lines.  And much, much more.</p>&#13;
&#13;
<p>With flexbox, the appearance of content can&#13;
be independent of source order. Though visually altered, flex properties&#13;
should not impact the order of content read by screen&#13;
&#13;
<span class="keep-together">readers.</span></p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Specifications say that <a data-primary="accessibility issues" data-secondary="order of content and screen readers" data-type="indexterm" id="idm45176079780608"/>screen readers should follow source order, but as of late 2022, Firefox follows the visual order. As of this writing, a proposal calls for adding a CSS property that specifies whether to follow source or visual order, so it may soon be possible to decide for yourself.</p>&#13;
</div>&#13;
&#13;
<p>Perhaps most importantly, with flexible box module layouts, elements can be made&#13;
to behave predictably for different screen sizes and different display&#13;
devices. Flexbox works very well with responsive sites, as content can&#13;
increase and decrease in size when the space provided is increased or&#13;
decreased.</p>&#13;
&#13;
<p>Flexbox works off of a parent-and-child relationship. Flexbox layout is activated&#13;
by declaring <code>display: flex</code> or <code>display: inline-flex</code> on an element.  This <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-type="indexterm" id="ix_flexbox_item"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-type="indexterm" id="ix_flexbox_container"/>element&#13;
becomes a <em>flex container</em>, arranging its children within the&#13;
space provided and controlling their layout. The children of this flex&#13;
container become <em>flex items</em>.  Consider the following styles and markup, illustrated in <a data-type="xref" href="#display_flex">Figure 11-1</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#one</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#two</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">inline-flex</code><code class="p">;}</code>&#13;
<code class="nt">div</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">dashed</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">div</code> <code class="o">&gt;</code> <code class="o">*</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#AAA</code><code class="p">;}</code>&#13;
<code class="nt">div</code> <code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">id=</code><code class="s">"one"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p&gt;</code>flex<code class="w"> </code>item<code class="w"> </code>with<code class="nt">&lt;br&gt;</code>two<code class="w"> </code>longer<code class="w"> </code>lines<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;span&gt;</code>flex<code class="w"> </code>item<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p&gt;</code>flex<code class="w"> </code>item<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">id=</code><code class="s">"two"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;span&gt;</code>flex<code class="w"> </code>item<code class="w"> </code>with<code class="nt">&lt;br&gt;</code>two<code class="w"> </code>longer<code class="w"> </code>lines<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;span&gt;</code>flex<code class="w"> </code>item<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;p&gt;</code>flex<code class="w"> </code>item<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="display_flex">&#13;
<img alt="Adding display: flex; or display: inline-flex creates a flex container" src="assets/css5_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>The two kinds of flex containers <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/two-kinds-of-flex-containers.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Look for the Play symbol <span class="play"><img src="assets/play-icon-round.png"/></span> to know when an online example is available. All of the examples in this chapter can be found at <a class="bare" href="https://meyerweb.github.io/csstdg5figs/11-flexbox"><em class="hyperlink">https://meyerweb.github.io/csstdg5figs/11-flexbox</em></a>.</p>&#13;
</div>&#13;
&#13;
<p>Notice how each child element of the <code>&lt;div&gt;</code>s becomes a flex item, and furthermore, how they all lay out in the same way?  It doesn’t matter that some are paragraphs and others are <code>&lt;span&gt;</code>s.  They all become flex items.  (There would likely have been some differences due to the paragraphs’ browser-default margins, except those were removed.)</p>&#13;
&#13;
<p>The only real difference between the first and second flex containers is that one is set to <code>display: flex</code>, and the other to <code>display: inline-flex</code>.  In the first, the <code>&lt;div&gt;</code> becomes a block box with flex layout inside it.  In the second, the <code>&lt;div&gt;</code> becomes an inline-block box with flex inside it.</p>&#13;
&#13;
<p>The key thing to keep in mind is that once you set an element to be a flex container, like the <code>&lt;div&gt;</code>s in <a data-type="xref" href="#display_flex">Figure 11-1</a>, it&#13;
will flex only its immediate children, and not further descendants.&#13;
However, you can make those descendants flex containers as well, enabling&#13;
some really complex layouts.</p>&#13;
&#13;
<p>Within a <a data-primary="main-axis, flexbox" data-type="indexterm" id="idm45176079592960"/>flex container, items line up on the&#13;
<em>main-axis</em>. The main-axis can be either horizontal or vertical, so you&#13;
can arrange items into columns or rows. The main-axis takes on the&#13;
directionality set via the writing mode: this main-axis concept is discussed in depth in <a data-type="xref" href="#understanding-axis">“Understanding Axes”</a>.</p>&#13;
&#13;
<p>As the first <code>&lt;div&gt;</code> in <a data-type="xref" href="#display_flex">Figure 11-1</a> demonstrates,&#13;
when the flex items don’t fill up the entire&#13;
main-axis (in this case, the width) of the container, they will leave extra space.&#13;
Certain properties dictate how to handle that extra space, which we’ll explore later in the chapter.&#13;
You can group the children to the left, the right, or&#13;
centered, or you can spread them out, defining how the space is spread&#13;
out either between or around the children.</p>&#13;
&#13;
<p>Besides distributing space, you can also allow the flex items to grow to take up all the available space by&#13;
distributing that extra space among one, some, or all of the flex items.&#13;
If there isn’t enough space to contain all the flex items, you can employ flexbox properties to dictate how they should&#13;
shrink to fit within their container, or whether they’re allowed to wrap to multiple flex lines.</p>&#13;
&#13;
<p>Furthermore, the children can be&#13;
aligned with respect to their container or to each other; to the bottom,&#13;
top, or center of the container; or stretched out to fill the container.&#13;
Regardless of the difference in content length among sibling containers,&#13;
with flexbox you can make all the siblings the same size with a single&#13;
declaration.<a data-primary="" data-startref="ix_flexbox_container" data-type="indexterm" id="idm45176079588448"/><a data-primary="" data-startref="ix_flexbox_item" data-type="indexterm" id="idm45176079587472"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Simple Example" data-type="sect2"><div class="sect2" id="idm45176079586400">&#13;
<h2>A Simple Example</h2>&#13;
&#13;
<p>Let’s say we want to create a navigation bar out of a group of links.  This is exactly the sort of thing flexbox was designed to handle.  Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;nav&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/"</code><code class="nt">&gt;</code>Home<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/about"</code><code class="nt">&gt;</code>About<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/blog"</code><code class="nt">&gt;</code>Blog<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/jobs"</code><code class="nt">&gt;</code>Careers<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/contact"</code><code class="nt">&gt;</code>Contact<code class="w"> </code>Us<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/nav&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In the preceding code, with its <code>display</code> property set to <code>flex</code>, the&#13;
<code>&lt;nav&gt;</code> element is turned into a flex container, and its child links are all&#13;
flex items. These links are still hyperlinks,&#13;
but they are now also flex items, which means they are no longer inline-level&#13;
boxes: rather, they participate in their container’s flex formatting&#13;
context. Therefore, the whitespace between the <code>&lt;a&gt;</code> elements in the HTML is completely ignored in layout terms.  If you’ve ever used HTML comments to suppress the space between links, list items, or other elements, you know why this is a big deal.</p>&#13;
&#13;
<p>So let’s add some CSS to the links:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="n">border</code><code class="o">-</code><code class="nb">block</code><code class="o">-</code><code class="n">end</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#ccc</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">a</code> <code class="p">{</code>&#13;
  <code class="k">margin</code><code class="o">:</code> <code class="m">0</code> <code class="m">5px</code><code class="p">;</code>&#13;
  <code class="k">padding</code><code class="o">:</code> <code class="m">5px</code> <code class="m">15px</code><code class="p">;</code>&#13;
  <code class="k">border-radius</code><code class="o">:</code> <code class="m">3px</code> <code class="m">3px</code> <code class="m">0</code> <code class="m">0</code><code class="p">;</code>&#13;
  <code class="k">background-color</code><code class="o">:</code> <code class="m">#ddaa00</code><code class="p">;</code>&#13;
  <code class="k">text-decoration</code><code class="o">:</code> <code class="nb">none</code><code class="p">;</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="m">#ffffff</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code><code class="o">,</code> <code class="nt">a</code><code class="nd">:focus</code><code class="o">,</code> <code class="nt">a</code><code class="nd">:active</code> <code class="p">{</code>&#13;
  <code class="k">background-color</code><code class="o">:</code> <code class="m">#ffcc22</code><code class="p">;</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We now have ourselves a simple tabbed navigation&#13;
bar, as shown in <a data-type="xref" href="#simple_tabbed_navigation">Figure 11-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="simple_tabbed_navigation">&#13;
<img alt="A simple tabbed navigation (files/nav_displayflex.html)" src="assets/css5_1102.png"/>&#13;
<h6><span class="label">Figure 11-2. </span>A simple tabbed navigation <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/simple-tabbed-navigation.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>That might not seem like much right now, because there’s nothing here you couldn’t have done with old-school CSS.  Just wait: it gets better.</p>&#13;
&#13;
<p>By design, flexbox is <a data-primary="writing modes (flow direction)" data-secondary="inline layout’s horizontal bias" data-type="indexterm" id="idm45176079395712"/><a data-primary="blocks" data-secondary="writing modes" data-type="indexterm" id="idm45176079366176"/><a data-primary="writing modes (flow direction)" data-secondary="block box handling" data-type="indexterm" id="idm45176079365328"/><a data-primary="writing modes (flow direction)" data-secondary="flexbox as agnostic to" data-type="indexterm" id="idm45176079364448"/>direction-agnostic. This is different from block&#13;
or inline layouts, which are defined to be vertically and&#13;
horizontally biased, respectively. The web was originally designed for&#13;
the creation of pages on monitors, and assumed a horizontal constraint&#13;
with infinite vertical scroll. This vertically biased layout is&#13;
insufficient for modern applications that change orientation, grow, and&#13;
shrink, depending on the user agent and the direction of the viewport,&#13;
and change writing modes depending on the language.</p>&#13;
&#13;
<p>For years we joked about the challenges of vertical centering and multiple column layout. Some layouts were no laughing matter, like ensuring equal heights in sets of multiple side-by-side boxes, with buttons or “more” links fixed to the bottom of each box (<a data-type="xref" href="#power_grid_layout_flexbox">Figure 11-3</a>); or, keeping the pieces of a single button all neatly lined up (<a data-type="xref" href="#fb_button-vert-centered">Figure 11-4</a>). Flexbox makes what used to be challenging layout effects fairly simple.</p>&#13;
&#13;
<figure><div class="figure" id="power_grid_layout_flexbox">&#13;
<img alt="Power grid layout with flexbox, with buttons aligned on the bottom" src="assets/css5_1103.png"/>&#13;
<h6><span class="label">Figure 11-3. </span>Power grid layout with flexbox, with buttons aligned on the bottom <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/power-grid-layout.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="fb_button-vert-centered">&#13;
<img alt="Button with many components neatly vertically centered" src="assets/css5_1104.png"/>&#13;
<h6><span class="label">Figure 11-4. </span>Widget with several components, all vertically centered <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/widget-with-components-vertically-centered.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The classic <a href="https://en.wikipedia.org/wiki/Holy_grail_(web_design)">“Holy Grail” layout</a>, with a header, three equal-height columns of varying flexibility, and a footer, can be created in a few lines of CSS with either flexbox or grid layout, which are covered in the next chapter.&#13;
Here’s an example of HTML that might represent such a layout:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;header&gt;</code>Header<code class="nt">&lt;/header&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;main&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;nav&gt;</code>Links<code class="nt">&lt;/nav&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;aside&gt;</code>Aside<code class="w"> </code>content<code class="nt">&lt;/aside&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;article&gt;</code>Document<code class="w"> </code>content<code class="nt">&lt;/article&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/main&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;footer&gt;</code>Footer<code class="nt">&lt;/footer&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>As the chapter progresses, remember that flexbox is designed for a specific type of layout, that of&#13;
single-dimensional content distribution.  It works best at arranging information along a single dimension, or axis.&#13;
While you can create grid-like&#13;
layouts (two-dimensional alignment) with flexbox, this is not its intended purpose, and it has significant flaws for this use case.  If you find yourself pining for two-dimensional layout capabilities, see <a data-type="xref" href="ch12.html#grid-layout">Chapter 12</a>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flex Containers" data-type="sect1"><div class="sect1" id="flex-container">&#13;
<h1>Flex Containers</h1>&#13;
&#13;
<p>The first <a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-type="indexterm" id="ix_flexbox_container2"/><a data-primary="container box" data-secondary="flexbox layout" data-type="indexterm" id="ix_cont_box_flex"/>important concept to fully understand is the <em>flex container</em>,&#13;
also known as the <em>container box</em>. The element on which&#13;
<code>display: flex</code> or <code>display: inline-flex</code> is applied becomes the flex container and generates a <em>flex formatting context</em> for its child nodes.</p>&#13;
&#13;
<p>These <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-type="indexterm" id="idm45176079320736"/>children are <em>flex items</em>, whether they are&#13;
DOM nodes, text nodes, or generated-content pseudo-elements. Absolutely positioned&#13;
children of flex containers are also flex items, but each is sized and&#13;
positioned as though it is the only flex item in its flex &#13;
<span class="keep-together">container.</span></p>&#13;
&#13;
<p>We’ll first look at all the CSS properties that apply to the flex&#13;
container, including several properties impacting the layout of flex&#13;
items. We’ll then explore the equally important concept of flex items in <a data-type="xref" href="#flex-items">“Flex Items”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the flex-direction Property" data-type="sect2"><div class="sect2" id="the-flex-direction-property">&#13;
<h2>Using the flex-direction Property</h2>&#13;
&#13;
<p>If you want your <a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="flex-direction property" data-type="indexterm" id="ix_flex_cont_direct_prop"/><a data-primary="flex-direction property" data-type="indexterm" id="ix_flex_direct_prop"/>layout to go from top to bottom, left to right, right&#13;
to left, or even bottom to top, you can use <code>flex-direction</code> to control&#13;
the main-axis along which the flex items get laid out.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176079311888">&#13;
<h1>flex-direction</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>row</code> | <code>row-reverse</code> | <code>column</code> | <code>column-reverse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>row</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>flex-direction</code> property specifies how flex items are placed in the&#13;
flex container. It defines the&#13;
main-axis of a flex container, which is the primary axis along which flex items are laid out (see <a data-type="xref" href="#understanding-axis">“Understanding Axes”</a> for more details).</p>&#13;
&#13;
<p>Assume the following basic markup structure:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;li&gt;</code>1<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;li&gt;</code>2<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;li&gt;</code>3<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;li&gt;</code>4<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;li&gt;</code>5<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ol&gt;</code><code class="w"/></pre>&#13;
&#13;
<p><a data-type="xref" href="#four-values-flex-dir">Figure 11-5</a> shows how that <a data-primary="writing modes (flow direction)" data-secondary="changing for languages" data-type="indexterm" id="idm45176079241376"/>simple list would be arranged by applying each of the four values of <code>flex-direction</code>, assuming a left-to-right language.</p>&#13;
&#13;
<figure><div class="figure" id="four-values-flex-dir">&#13;
<img alt="The four values of the flex-direction property" src="assets/css5_1105.png"/>&#13;
<h6><span class="label">Figure 11-5. </span>The four values of the flex-direction property <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-four-values.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The default value, <code>row</code>, doesn’t look all that different from a bunch of inline or floated elements.  This is misleading, for reasons you’ll soon see, but notice how the other <code>flex-direction</code> values affect the arrangement of the list items.</p>&#13;
&#13;
<p>For example, you can reverse this layout of the items with <code>flex-direction: row-reverse</code>.  The flex items are laid out from top to bottom when&#13;
<code>flex-direction: column</code> is set, and from bottom to top if&#13;
<code>flex-direction: column-reverse</code> is set, as shown in <a data-type="xref" href="#four-values-flex-dir">Figure 11-5</a>.</p>&#13;
&#13;
<p>We specified left-to-right languages, because the direction of the main-axis for <code>row</code>—the direction that the flex items are laid out—is the&#13;
direction of the current writing mode.  We’ll discuss how writing modes affect flex direction and layout in a bit.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Do <em>not</em> use <code>flex-direction</code> to change the layout for&#13;
right-to-left languages. <a data-primary="dir attribute, HTML" data-type="indexterm" id="idm45176079229808"/>Rather, use the <code>dir</code> attribute in HTML, or the&#13;
<code>writing-mode</code> CSS property described in <a data-type="xref" href="ch15.html#setting_writing_modes">“Setting Writing Modes”</a>, to indicate the language direction.  To learn more about language direction and flexbox, see <a data-type="xref" href="#other-writing-directions">“Working with Other Writing Directions”</a>.</p>&#13;
</div>&#13;
&#13;
<p>The <code>column</code> value sets the flex container’s main-axis to be the same&#13;
orientation as the block axis of the current writing mode. This is the&#13;
vertical axis in horizontal writing modes like English, and the horizontal axis in vertical writing modes like traditional &#13;
<span class="keep-together">Japanese.</span></p>&#13;
&#13;
<p>Thus, when declaring a <code>column</code> direction in English (or a language with the same writing direction), the flex items are displayed in the same order as&#13;
declared in the source document, but from top to bottom instead of left&#13;
to right, so the flex items are laid out one on top of the next instead&#13;
of side by side. Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="k">flex-direction</code><code class="o">:</code> <code class="n">column</code><code class="p">;</code>&#13;
  <code class="k">border-right</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#ccc</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Thus, by simply&#13;
writing a few CSS properties, we can create a nice sidebar-style&#13;
navigation for the list of links we saw earlier as a horizontal row of tabs.&#13;
For the new layout, we change the <code>flex-direction</code> from&#13;
the default value of <code>row</code> to <code>column</code> and move the border from the bottom to the&#13;
right; <a data-type="xref" href="#changing-flex-dir">Figure 11-6</a> shows the result.</p>&#13;
&#13;
<figure><div class="figure" id="changing-flex-dir">&#13;
<img alt="Changing flex-direction can completely change the layout of your content" src="assets/css5_1106.png"/>&#13;
<h6><span class="label">Figure 11-6. </span>Changing the flex direction can completely change the layout <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-flex-direction-change-layout.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>column-reverse</code> value is similar to <code>column</code>, except the main-axis&#13;
is reversed; thus, <code>main-start</code> is placed at the <em>end</em> of the main-axis, and <code>main-end</code> is placed&#13;
at the <em>start</em> of the main-axis.  In top-to-bottom writing modes, that means the flex items are arranged going upward, as shown previously in&#13;
<a data-type="xref" href="#four-values-flex-dir">Figure 11-5</a>.  The <code>-reverse</code> values only change the appearance. The keyboard-navigation tab order remains the same as the underlying markup.</p>&#13;
&#13;
<p>What we’ve shown so far is super powerful and makes many layouts a breeze.&#13;
If we include the navigation within a full document, we can see how&#13;
simple layout can be with just a few flexbox property declarations.</p>&#13;
&#13;
<p>Let’s expand a little on our preceding HTML example, and include the&#13;
navigation as a component within a home page:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-code-language="xml" data-type="programlisting"><code class="nt">&lt;body&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;header&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;h1&gt;</code>My<code class="w"> </code>Page's<code class="w"> </code>title!<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/header&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;nav&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/"</code><code class="nt">&gt;</code>Home<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/about"</code><code class="nt">&gt;</code>About<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/blog"</code><code class="nt">&gt;</code>Blog<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/jobs"</code><code class="nt">&gt;</code>Careers<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/contact"</code><code class="nt">&gt;</code>Contact<code class="w"> </code>Us<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/nav&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;main&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;article&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="w"> </code><code class="na">src=</code><code class="s">"img1.jpg"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;p&gt;</code>This<code class="w"> </code>is<code class="w"> </code>some<code class="w"> </code>awesome<code class="w"> </code>content<code class="w"> </code>that<code class="w"> </code>is<code class="w"> </code>on<code class="w"> </code>the<code class="w"> </code>page.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;button&gt;</code>Go<code class="w"> </code>Somewhere<code class="nt">&lt;/button&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;/article&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;article&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="w"> </code><code class="na">src=</code><code class="s">"img2.jpg"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;p&gt;</code>This<code class="w"> </code>is<code class="w"> </code>more<code class="w"> </code>content<code class="w"> </code>than<code class="w"> </code>the<code class="w"> </code>previous<code class="w"> </code>box,<code class="w"> </code>but<code class="w"> </code>less<code class="w"> </code>than<code class="w"/>&#13;
<code class="w">       </code>the<code class="w"> </code>next.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;button&gt;</code>Click<code class="w"> </code>Me<code class="nt">&lt;/button&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;/article&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;article&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="w"> </code><code class="na">src=</code><code class="s">"img3.jpg"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;p&gt;</code>We<code class="w"> </code>have<code class="w"> </code>lots<code class="w"> </code>of<code class="w"> </code>content<code class="w"> </code>here<code class="w"> </code>to<code class="w"> </code>show<code class="w"> </code>that<code class="w"> </code>content<code class="w"> </code>can<code class="w"> </code>grow,<code class="w"> </code>and<code class="w"/>&#13;
<code class="w">       </code>everything<code class="w"> </code>can<code class="w"> </code>be<code class="w"> </code>the<code class="w"> </code>same<code class="w"> </code>size<code class="w"> </code>if<code class="w"> </code>you<code class="w"> </code>use<code class="w"> </code>flexbox.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">       </code><code class="nt">&lt;button&gt;</code>Do<code class="w"> </code>Something<code class="nt">&lt;/button&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;/article&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/main&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;footer&gt;</code>Copyright<code class="w"> </code><code class="ni">&amp;#169;</code><code class="w"> </code>2023<code class="nt">&lt;/footer&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/body&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>By adding a few lines of CSS, we get a nicely laid-out home&#13;
page (<a data-type="xref" href="#using_flex_direction_row_and_column">Figure 11-7</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code> <code class="p">{</code>&#13;
  <code class="k">outline</code><code class="o">:</code> <code class="m">1px</code> <code class="m">#ccc</code> <code class="nb">solid</code><code class="p">;</code>&#13;
  <code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code>&#13;
  <code class="k">padding</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">body</code><code class="o">,</code> <code class="nt">nav</code><code class="o">,</code> <code class="nt">main</code><code class="o">,</code> <code class="nt">article</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">body</code><code class="o">,</code> <code class="nt">article</code> <code class="p">{</code>&#13;
  <code class="k">flex-direction</code><code class="o">:</code> <code class="n">column</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="using_flex_direction_row_and_column">&#13;
<img alt="Home page layout using +flex-direction:+ +row+ and +column+" src="assets/css5_1107.png"/>&#13;
<h6><span class="label">Figure 11-7. </span>Home page layout using <code>flex-direction: row</code> and <code>column</code> <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/home-page-layout-row-and-column.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Yes, elements can be flex items while also being flex containers, as you can see with the navigation, main, and article elements in this case. The <code>&lt;body&gt;</code> and&#13;
<code>&lt;article&gt;</code> elements have <code>column</code> set as their flex directions, and we let <code>&lt;nav&gt;</code>&#13;
and <code>&lt;main&gt;</code> default to <code>row</code>. And all that with just two lines of CSS!</p>&#13;
&#13;
<p>To be clear, there’s more styling at work in <a data-type="xref" href="#using_flex_direction_row_and_column">Figure 11-7</a>. Borders, margins, and&#13;
padding were applied to all the elements, so you can visually differentiate the flex items for&#13;
the sake of learning (we wouldn’t put this less-than-attractive site into&#13;
production!). Otherwise, all we’ve done is simply declare the body,&#13;
navigation, main, and articles as flex containers, making the navigation&#13;
links, main, article, images, paragraphs, and buttons &#13;
<span class="keep-together">flex items.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Working with Other Writing Directions" data-type="sect2"><div class="sect2" id="other-writing-directions">&#13;
<h2>Working with Other Writing Directions</h2>&#13;
&#13;
<p>If you’re <a data-primary="writing modes (flow direction)" data-secondary="changing for languages" data-type="indexterm" id="ix_write_mode_lang"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="other writing directions" data-type="indexterm" id="ix_flex_cont_write_dir"/>creating websites in English, or another left-to-right (LTR)&#13;
language, you likely want the flex items to be laid out from left to&#13;
right, and from top to bottom. <a data-primary="left-to-right (LTR) writing mode" data-type="indexterm" id="idm45176078792640"/><a data-primary="LTR (left-to-right) writing mode" data-type="indexterm" id="idm45176078792000"/><a data-primary="right-to-left (RTL) writing mode" data-type="indexterm" id="idm45176078791360"/><a data-primary="RTL (right-to-left) writing mode" data-type="indexterm" id="idm45176078790720"/>The default value <code>row</code> will do that.&#13;
If you’re writing in Arabic, or another right-to-left (RTL) language, you likely&#13;
want the flex items to be laid out from right to left, and from top to&#13;
bottom. The default value <code>row</code> will do that, too.</p>&#13;
&#13;
<p>Using <code>flex-direction: row</code> arranges the flex items in the same direction as&#13;
the text direction, also known as the <em>writing mode</em>, whether the language is RTL&#13;
or LTR. While most websites are presented in left-to-right&#13;
languages, some sites are in right-to-left languages, and yet others are&#13;
top-to-bottom. With flexbox, when you&#13;
change the writing mode, flexbox takes care of changing the flex&#13;
direction for you.</p>&#13;
&#13;
<p>The <a data-primary="text-orientation property" data-type="indexterm" id="idm45176078787008"/><a data-primary="writing-mode property" data-type="indexterm" id="idm45176078786288"/>writing mode is set by the <code>writing-mode</code>, <code>direction</code>, and&#13;
<code>text-orientation</code> properties, or by the <code>dir</code> attribute in HTML.  (These are covered in <a data-type="xref" href="ch15.html#text_properties">Chapter 15</a>.)&#13;
When the writing mode is right to left, the&#13;
direction of the main-axis—and therefore the flex items within the flex&#13;
container—will go from right to left when the&#13;
<code>flex-direction</code> is <code>row</code>.  This is illustrated in <a data-type="xref" href="#four-vals-flex-dir">Figure 11-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="four-vals-flex-dir">&#13;
<img alt="The four values of flex-direction when direction is right to left, demonstrated here with display: inline-flex;" src="assets/css5_1108.png"/>&#13;
<h6><span class="label">Figure 11-8. </span>The four values of <code>flex-direction</code> when writing direction is right <span class="keep-together">to left <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-rtl-four-values.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></span></h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If the CSS <code>direction</code> <a data-primary="direction property" data-type="indexterm" id="idm45176078775136"/><a data-primary="dir attribute, HTML" data-type="indexterm" id="idm45176078774400"/>value is different from the <code>dir</code> attribute value&#13;
on an element, the CSS property value takes precedence over the HTML&#13;
attribute. The specifications strongly recommend using the HTML attribute rather than the CSS property.</p>&#13;
</div>&#13;
&#13;
<p>Vertically written languages include Bopomofo, Egyptian&#13;
hieroglyphs, Hiragana, Katakana, Han, Hangul, Meroitic cursive and&#13;
hieroglyphs, Mongolian, Ogham, Old Turkic, Phags Pa, Yi, and sometimes&#13;
Japanese. These languages are displayed vertically only when a vertical writing mode&#13;
is specified. If not, all of those languages are treated as horizontal.</p>&#13;
&#13;
<p class="pagebreak-before">For top-to-bottom languages,&#13;
<code>writing-mode: horizontal-tb</code> is in effect, meaning the main-axis is&#13;
rotated 90 degrees clockwise from the default left to right.  Thus,&#13;
<code>flex-direction: row</code> goes from top to bottom, and&#13;
<code>flex-direction: column</code> proceeds from right to left. <a data-type="xref" href="#writing_mode_horizontal_tb">Figure 11-9</a> shows the effects of the various <code>flex-direction</code> values on the following markup:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ol</code><code class="w"> </code><code class="na">lang=</code><code class="s">"jp"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>一<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>二<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>三<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>四<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>五<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ol&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="writing_mode_horizontal_tb">&#13;
<img alt="The four values of flex-direction when writing mode is horizontal-tb" src="assets/css5_1109.png"/>&#13;
<h6><span class="label">Figure 11-9. </span>The four values of <code>flex-direction</code> when writing mode is horizontal-tb <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-ttb-four-values.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>That’s right: the rows are vertical, and columns are horizontal.  Not only that, but the basic <code>column</code> direction is right to left, whereas <code>column-reverse</code> runs left to right.  That’s what comes of applying these values to a top-to-bottom, right-to-left language as we see here.</p>&#13;
&#13;
<p>All right, you’ve seen various ways flex direction and writing modes interact.&#13;
But so far, all the examples have shown a single row or column of flex items.  What happens when the flex items’ <em>main dimension</em> (their combined&#13;
inline sizes for <code>row</code> or combined block sizes for <code>column</code>) don’t fit within the&#13;
flex container? We can either have them overflow the container or can allow them to wrap onto additional flex lines. Also, we’ll later talk about how to allow flex items to shrink (or grow) to fit the container.<a data-primary="" data-startref="ix_flex_direct_prop" data-type="indexterm" id="idm45176078714880"/><a data-primary="" data-startref="ix_flex_cont_direct_prop" data-type="indexterm" id="idm45176078713904"/><a data-primary="" data-startref="ix_flex_cont_write_dir" data-type="indexterm" id="idm45176078712992"/><a data-primary="" data-startref="ix_write_mode_lang" data-type="indexterm" id="idm45176078712048"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wrapping Flex Lines" data-type="sect2"><div class="sect2" id="the-flex-wrap-property">&#13;
<h2>Wrapping Flex Lines</h2>&#13;
&#13;
<p>If all the <a data-primary="wrapping flex lines" data-type="indexterm" id="ix_wrap_flex_line"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="wrapping flex lines" data-type="indexterm" id="ix_flex_cont_wrap"/>flex items don’t fit into the&#13;
main-axis of the flex container, the flex items will not&#13;
wrap by default, nor will they necessarily resize.&#13;
Rather, the flex items may shrink if allowed to do so via the flex&#13;
item’s <code>flex</code> property (see <a data-type="xref" href="#growth-factors-and-the-flex-property">“Growth Factors and the flex Property”</a>); otherwise, the flex items will overflow the bounding container box.</p>&#13;
&#13;
<p>You can affect this behavior. <a data-primary="flex-wrap property" data-type="indexterm" id="ix_flex_wrap_prop"/>The <code>flex-wrap</code> property sets whether a flex container is limited&#13;
to a single line or is allowed to become multiline when&#13;
needed.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176078729936">&#13;
<h1>flex-wrap</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>nowrap</code> | <code>wrap</code> | <code>wrap-reverse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>nowrap</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>When the <code>flex-wrap</code> property is set to allow for multiple flex&#13;
lines via <code>wrap</code> or <code>wrap-reverse</code>, it determines&#13;
where additional lines of flex items appear: either before or after the original line of flex items.</p>&#13;
&#13;
<p><a data-type="xref" href="#three_values_of_flex_wrap">Figure 11-10</a> demonstrates the three values of the <code>flex-wrap</code> property when the&#13;
<code>flex-direction</code> value is <code>row</code> (and the language is LTR).&#13;
Where these examples show two&#13;
flex lines, the second line and subsequent flex lines are added along the&#13;
direction of the cross-axis (in this case, the vertical axis).</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="three_values_of_flex_wrap">&#13;
<img alt="The three values of flex-wrap property" src="assets/css5_1110.png"/>&#13;
<h6><span class="label">Figure 11-10. </span>The three values of the <code>flex-wrap</code> property in a row-oriented flow <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-three-values.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>When <code>wrap</code> is set, the cross-axis is the same as the block axis for <code>flex-direction: row</code> and <code>row-reverse</code>, and is the same as the inline axis of the language for <code>flex-direction: column</code> and <code>column-reverse</code>.</p>&#13;
&#13;
<p>The difference is that when <code>flex-wrap</code> is set to <code>wrap-reverse</code>, the cross-axis direction is reversed: subsequent flex lines are drawn above the previous line in the case of <code>row</code> and <code>row-reverse</code>, and to the left of the previous column in the case of <code>column-reverse</code> (assuming an LTR language such as English).</p>&#13;
&#13;
<p>We’ll talk more about axes in just a moment, but first, let’s talk about the shorthand property that brings flex direction and wrapping together.<a data-primary="" data-startref="ix_flex_cont_wrap" data-type="indexterm" id="idm45176078669616"/><a data-primary="" data-startref="ix_flex_wrap_prop" data-type="indexterm" id="idm45176078668640"/><a data-primary="" data-startref="ix_wrap_flex_line" data-type="indexterm" id="idm45176078667696"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Flexible Flows" data-type="sect2"><div class="sect2" id="the-flex-flow-shorthand-property">&#13;
<h2>Defining Flexible Flows</h2>&#13;
&#13;
<p>The <code>flex-flow</code> property<a data-primary="flex-flow property" data-type="indexterm" id="idm45176078664432"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="defining flexible flows" data-type="indexterm" id="idm45176078663696"/> lets you define the wrapping directions of the main- and&#13;
cross-axes, and whether the flex items can wrap to more than one line if&#13;
needed.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176078662096">&#13;
<h1>flex-flow</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>flex-direction</code></em>&gt; ‖ &lt;<em><code>flex-wrap</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>row nowrap</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>flex-flow</code> shorthand property sets the <code>flex-direction</code> and&#13;
<code>flex-wrap</code> properties to define the flex container’s wrapping and main-&#13;
and cross-axes.</p>&#13;
&#13;
<p>As long as <code>display</code> is set to <code>flex</code> or <code>inline-flex</code>, omitting&#13;
<code>flex-flow</code>, <code>flex-direction</code>, and <code>flex-wrap</code> is the same as declaring&#13;
any of the following three, all of which have the result shown in <a data-type="xref" href="#flex_flow_row">Figure 11-11</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex-flow</code><code class="o">:</code> <code class="n">row</code><code class="p">;</code>&#13;
<code class="k">flex-flow</code><code class="o">:</code> <code class="nb">nowrap</code><code class="p">;</code>&#13;
<code class="k">flex-flow</code><code class="o">:</code> <code class="n">row</code> <code class="nb">nowrap</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="flex_flow_row">&#13;
<img alt="flex-flow: row;" src="assets/css5_1111.png"/>&#13;
<h6><span class="label">Figure 11-11. </span>A row-oriented unwrapped flex flow <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-flow-unwrapped-row.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>In LTR writing modes, declaring any of the property values just listed, or omitting&#13;
the <code>flex-flow</code> property altogether, will create a flex container with a&#13;
horizontal main-axis that doesn’t wrap. <a data-type="xref" href="#flex_flow_row">Figure 11-11</a> illustrates flex items distributed along the horizontal axis, on one line,&#13;
overflowing a container that’s 500 pixels wide.</p>&#13;
&#13;
<p>If instead we want a reverse-column-oriented flow with wrapping, either of these will &#13;
<span class="keep-together">suffice:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex-flow</code><code class="o">:</code> <code class="n">column</code><code class="o">-</code><code class="n">reverse</code> <code class="n">wrap</code><code class="p">;</code>&#13;
<code class="k">flex-flow</code><code class="o">:</code> <code class="n">wrap</code> <code class="n">column</code><code class="o">-</code><code class="n">reverse</code><code class="p">;</code></pre>&#13;
&#13;
<p>In an LTR language like English, this causes the flex items to flow from bottom to top, starting at the left side, and wrap to new columns in the rightward direction.  In a vertical writing mode like Japanese, which is right-to-left when written vertically, the columns would be horizontal, flowing from right to left, and wrap top to bottom.</p>&#13;
&#13;
<p>We’ve been using terms like <em>main-axis</em> and <em>cross-axis</em> without really delving into what they mean.  It’s time to clarify all that.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Axes" data-type="sect2"><div class="sect2" id="understanding-axis">&#13;
<h2>Understanding Axes</h2>&#13;
&#13;
<p>First: <a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="axes in" data-type="indexterm" id="ix_flex_cont_axes"/>flex items are laid out along the main-axis. Flex lines are added in&#13;
the direction of the cross-axis.</p>&#13;
&#13;
<p>Up until we introduced <code>flex-wrap</code>, all the examples had a single line&#13;
of flex items. In that single line, the&#13;
flex items were laid out along the main-axis, in the <em>main direction</em>, from&#13;
main-start to main-end. When we added flex wrapping, new flex lines were added along the cross-axis, in the <em>cross direction</em>, going from cross-start to cross-end.</p>&#13;
&#13;
<p>As you can see, a lot of terms are used in that paragraph.  Here are some quick definitions:</p>&#13;
<dl>&#13;
<dt>Main-axis</dt>&#13;
<dd>&#13;
<p>The <a data-primary="main-axis, flexbox" data-type="indexterm" id="idm45176078572992"/>axis along which content flows.  In flexbox, this is the direction in which flex items are flowed.</p>&#13;
</dd>&#13;
<dt>Main-size</dt>&#13;
<dd>&#13;
<p>The <a data-primary="main-size, flexbox" data-type="indexterm" id="idm45176078570736"/>total length of the content along the main-axis.</p>&#13;
</dd>&#13;
<dt>Main-start</dt>&#13;
<dd>&#13;
<p>The <a data-primary="main-start, flexbox" data-type="indexterm" id="idm45176078568592"/>end of the main-axis from which content begins to flow.</p>&#13;
</dd>&#13;
<dt>Main-end</dt>&#13;
<dd>&#13;
<p>The <a data-primary="main-end, flexbox" data-type="indexterm" id="idm45176078566448"/>end of the main-axis toward which content flows, opposite the main-start.</p>&#13;
</dd>&#13;
<dt>Cross-axis</dt>&#13;
<dd>&#13;
<p>The <a data-primary="cross-axis, flexbox" data-type="indexterm" id="idm45176078564304"/>axis along which flex lines are “stacked.”  In flexbox, this is the direction in which new lines of flex items are placed, if flex wrapping is permitted.</p>&#13;
</dd>&#13;
<dt>Cross-size</dt>&#13;
<dd>&#13;
<p>The <a data-primary="cross-size, flexbox" data-type="indexterm" id="idm45176078543136"/>total length of the content along the cross-axis.</p>&#13;
</dd>&#13;
<dt>Cross-start</dt>&#13;
<dd>&#13;
<p>The <a data-primary="cross-start, flexbox" data-type="indexterm" id="idm45176078541248"/>edge of the cross-axis where blocks begin to be stacked.</p>&#13;
</dd>&#13;
<dt>Cross-end</dt>&#13;
<dd>&#13;
<p>The <a data-primary="cross-end, flexbox" data-type="indexterm" id="idm45176078539072"/>opposite edge of the cross-axis from the cross-start.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>While these terms may sound like logical properties such as <code>margin-inline-start</code>, they are not the same thing. Here, the physical direction of each changes depending on the value of the <code>flex-direction</code> property. In fact, the meaning of each term in the context of layout depends on the combination of the flex direction, the flex wrapping, and the writing mode.  Charting all the combinations for every writing mode would get difficult, so let’s examine what they mean for LTR languages.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It’s important to understand that direction gets reversed when writing direction&#13;
is reversed. To make explaining (and&#13;
understanding) flex layout much simpler, the rest of&#13;
the explanations and examples in this chapter are based on an LTR writing&#13;
mode, but will include how writing mode impacts the flex properties and&#13;
features &#13;
<span class="keep-together">discussed.</span></p>&#13;
</div>&#13;
&#13;
<p>When <a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="flex-direction property" data-type="indexterm" id="ix_flex_cont_direct_prop2"/><a data-primary="flex-direction property" data-type="indexterm" id="ix_flex_direct_prop2"/>thinking about <code>flex-direction</code>, we know that the flex items will start being laid out along the main-axis of the flex&#13;
container, starting from the main-start edge and proceeding toward the main-end edge.  If the <code>flex-wrap</code> property is used to allow the&#13;
container to wrap when the flex items don’t fit onto one line, the flex lines are laid out starting from the cross-start edge and proceeding toward the cross-end edge.</p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#flex_lines_on_row_and_row_reverse">Figure 11-12</a>, when we have horizontal rows of flex items, the&#13;
cross-axis is vertical. <a data-primary="left-to-right (LTR) writing mode" data-type="indexterm" id="idm45176078529760"/><a data-primary="LTR (left-to-right) writing mode" data-type="indexterm" id="idm45176078529120"/><a data-primary="right-to-left (RTL) writing mode" data-type="indexterm" id="idm45176078528480"/><a data-primary="RTL (right-to-left) writing mode" data-type="indexterm" id="idm45176078527840"/><a data-primary="flex-flow property" data-type="indexterm" id="idm45176078527200"/>In these examples, with <code>flex-flow: row wrap</code> and&#13;
<code>flex-flow: row-reverse wrap</code> set on horizontal languages, new flex&#13;
lines are added below preceding flex lines.<a data-primary="" data-startref="ix_flex_cont_axes" data-type="indexterm" id="idm45176078525568"/>  The cross-size is the opposite of main-size, being height for <code>row</code>&#13;
and <code>row-reverse</code> flex directions, and width for <code>column</code> and <code>column-reverse</code> directions, in both RTL and LTR<a data-primary="stacking of elements" data-type="indexterm" id="idm45176078522800"/> &#13;
<span class="keep-together">languages.</span></p>&#13;
&#13;
<p>By contrast, the <code>wrap-reverse</code> value inverts the direction of the cross-axis.&#13;
Normally for <code>flex-direction</code> of <code>row</code> and <code>row-reverse</code>, the&#13;
cross-axis goes from top to bottom, with the cross-start on top and&#13;
cross-end on the bottom. When <code>flex-wrap</code> is <code>wrap-reverse</code>, the&#13;
cross-start and cross-end directions are swapped, with the&#13;
cross-start on the bottom, cross-end on top, and the cross-axis&#13;
going from bottom to top. Additional flex lines get added on top of, or above, the previous line.<a data-primary="" data-startref="ix_cont_box_flex" data-type="indexterm" id="idm45176078518176"/><a data-primary="" data-startref="ix_flexbox_container2" data-type="indexterm" id="idm45176078517200"/></p>&#13;
&#13;
<figure><div class="figure" id="flex_lines_on_row_and_row_reverse">&#13;
<img alt="Flex lines on row and row-reverse when flex-wrap: wrap is set" src="assets/css5_1112.png"/>&#13;
<h6><span class="label">Figure 11-12. </span>Stacking of row-oriented flex lines</h6>&#13;
</div></figure>&#13;
&#13;
<p>If the <code>flex-direction</code> is set to <code>column</code> or <code>column-reverse</code>, by&#13;
default the cross-axis goes from left to right in LTR&#13;
languages, with new flex lines being added to the right of previous lines.<a data-primary="" data-startref="ix_flex_direct_prop2" data-type="indexterm" id="idm45176078512528"/><a data-primary="" data-startref="ix_flex_cont_direct_prop2" data-type="indexterm" id="idm45176078511552"/> As shown in <a data-type="xref" href="#flex_wrap_wrap_reverse">Figure 11-13</a>, when <code>flex-wrap</code> is set to <code>wrap-reverse</code>,&#13;
the cross-axis is inverted, with cross-start being on the right,&#13;
cross-end being on the left, the &#13;
<span class="keep-together">cross-axis</span> going from right to&#13;
left, and additional flex lines being added to the left of the&#13;
previously drawn line.</p>&#13;
&#13;
<figure><div class="figure" id="flex_wrap_wrap_reverse">&#13;
<img alt="Flex lines on columns and column-reverse when flex-wrap: wrap-reverse is set" src="assets/css5_1113.png"/>&#13;
<h6><span class="label">Figure 11-13. </span>Stacking of column-oriented flex lines</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Arrangement of Flex Items" data-type="sect1"><div class="sect1" id="arranging-items">&#13;
<h1>Arrangement of Flex Items</h1>&#13;
&#13;
<p>In our <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-type="indexterm" id="ix_flex_items_ch11"/>examples thus far, we’ve skated past the precise arrangement of the flex items within each flex line, and how that’s determined.  It might seem intuitive that a row fills in horizontally, but why should all the items huddle toward the main-start edge?  Why not have them grow to fill all available space, or distribute themselves throughout the line?</p>&#13;
&#13;
<p>For an example of what we’re talking about here, check out <a data-type="xref" href="#empty-space-dir-main-cross">Figure 11-14</a>.&#13;
Notice the extra space at the top left. In this bottom-to-top,&#13;
right-to-left flow, new flex items get placed above the&#13;
previous ones, with new wrap lines being placed to the left of each&#13;
previously filled line.</p>&#13;
&#13;
<figure><div class="figure" id="empty-space-dir-main-cross">&#13;
<img alt="No matter the value of flex flow, the empty space will be in the direction of main-end and cross-end" src="assets/css5_1114.png"/>&#13;
<h6><span class="label">Figure 11-14. </span>Empty space will be in the direction of main-end and cross-end</h6>&#13;
</div></figure>&#13;
&#13;
<p>By default, no matter the <a data-primary="flex-flow property" data-type="indexterm" id="idm45176078499136"/>values of <code>flex-flow</code>,&#13;
empty space outside the flex items in a flex container will be in the direction of main-end&#13;
and cross-end, but CSS has properties that allow us to&#13;
alter that.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flex Item Alignment" data-type="sect1"><div class="sect1" id="flex-item-alignment">&#13;
<h1>Flex Item Alignment</h1>&#13;
&#13;
<p>In our <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="alignment of" data-type="indexterm" id="ix_flex_items_align"/><a data-primary="alignment" data-secondary="flex items" data-type="indexterm" id="ix_align_flex_item"/>examples thus far, whenever the flex items do not completely fill the flex&#13;
container, the flex items are all grouped toward the main-start on&#13;
the main-axis. Flex items can be flush against&#13;
the main-end instead, centered, or even spaced out in various ways across the main-axis.</p>&#13;
&#13;
<p>The flex layout specification provides us with flex container properties&#13;
to control the distribution of space.&#13;
The <code>justify-content</code> property controls how flex items within a flex line&#13;
are distributed along the main-axis. <a data-primary="align-items property" data-type="indexterm" id="idm45176078491744"/><a data-primary="align-self property" data-type="indexterm" id="idm45176078491040"/><a data-primary="align-content property" data-type="indexterm" id="idm45176078490368"/>The <code>align-items</code> property defines the default distribution of the flex items along the cross-axis of each flex line; this global default can be individually overridden with the flex item <code>align-self</code> property. When there is more than one flex line and wrapping is enabled, the <code>align-content</code> property defines how those flex lines are distributed along the cross-axis of the flex container.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Justifying Content" data-type="sect2"><div class="sect2" id="the-justify-content-property">&#13;
<h2>Justifying Content</h2>&#13;
&#13;
<p>The <code>justify-content</code> property<a data-primary="justify-content property" data-type="indexterm" id="ix_just_cont_prop"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-tertiary="justifying content" data-type="indexterm" id="ix_flex_cont_just"/> enables us to direct the way flex items are distributed along the main-axis of the flex container within each flex line, and how to handle &#13;
<span class="keep-together">situations</span> where information might be lost.  This property is applied to the flex container, <em>not</em> the individual flex items.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176078481696">&#13;
<h1>justify-content</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>normal</code> | <code>space-between</code> | <code>space-around</code> | <code>space-evenly</code> | <code>stretch</code> | <code>unsafe</code> | <code>safe</code> ? [ <code>center</code> | <code>start</code> | <code>end</code> | <code>flex-start</code> | <code>flex-end</code> | <code>left</code> | <code>right</code> ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flexbox, grid, and multicolumn containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Note the <code>stretch</code> value is treated the same as <code>normal</code> for flexbox, but not for &#13;
<span class="keep-together">grid layout.</span></p>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <code>safe</code> and <code>unsafe</code> values, introduced with several other values in CSS Box Alignment Module Level 3, are recognized but not supported in most browsers as of early 2023. This means the value is ignored, but its presence does not render the rest of the declaration invalid.</p>&#13;
</div>&#13;
&#13;
<p><a data-type="xref" href="#justify-content-values">Figure 11-15</a> shows the effects of the various values in a writing mode like English.</p>&#13;
&#13;
<figure><div class="figure" id="justify-content-values">&#13;
<img alt="The values of the justify-content property" src="assets/css5_1115.png"/>&#13;
<h6><span class="label">Figure 11-15. </span>The values of the <code>justify-content</code> property <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-values.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p class="less_space pagebreak-before">With <code>start</code> and <code>flex-start</code>, flex&#13;
items are placed flush against main-start. With <code>end</code> and <code>flex-end</code>, flex&#13;
items are justified toward main-end. The <code>center</code> option groups the items flush&#13;
against each other, centered in the middle of the main-axis. The <code>left</code> and <code>right</code> options place items flush against the named sides of the box, regardless of the actual axis direction.</p>&#13;
&#13;
<p>The <code>space-between</code> value puts the first flex item on a&#13;
flex line flush with main-start and the last flex item in each flex&#13;
line flush with main-end, and then puts an equal amount of space&#13;
between every pair of adjacent flex items. The <code>space-evenly</code> value takes the leftover space and splits it so that every gap is the same length.  This means the spaces at the start and end edges of the main-axis will be the same size as the spaces placed between flex items.</p>&#13;
&#13;
<p>By contrast, <code>space-around</code> splits up the leftover space and then applies half of each portion to each flex item, as if there were noncollapsing margins of&#13;
equal size around each item.  Note that this means the space between any two flex items is twice that of the spaces at the main-start and main-end of the flex line.</p>&#13;
&#13;
<p>The <code>stretch</code> value has no effect as a value of <code>justify-content</code> in flexbox. As you’ll see in the next chapter, when placed on a grid container, it causes grid items to grow in size until they take up all available space in the main-axis direction.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We’ll cover <code>safe</code> and <code>unsafe</code>, which vary how the browser should handle items that overflow the container along the cross-axis, in <a data-type="xref" href="#safe-and-unsafe-alignment">“Safe and unsafe alignment”</a>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Justifying and overflow" data-type="sect3"><div class="sect3" id="justifying_and_overflow">&#13;
<h3>Justifying and overflow</h3>&#13;
&#13;
<p>If <a data-primary="overflowing flex container" data-type="indexterm" id="ix_overflow_flex_cont"/>flex items are not allowed to wrap to multiple lines and overflow their flex line, the value of <code>justify-content</code> influences the way the flex items will overflow the flex &#13;
<span class="keep-together">container.</span></p>&#13;
&#13;
<p>Setting <code>justify-content: start</code> or <code>flex-start</code> explicitly sets the default&#13;
behavior of grouping the flex items toward main-start, placing the&#13;
first flex item of each flex line flush against the main-start side.&#13;
Each subsequent flex item then gets placed flush with the preceding flex&#13;
item’s main-end side.  (Remember, the location of the main-start side depends on the flex direction and writing mode.)  If there isn’t&#13;
enough room for all the items and wrapping is not allowed, the items will overflow the main-end edge.  This is illustrated in <a data-type="xref" href="#justify_content_start">Figure 11-16</a>.</p>&#13;
&#13;
<figure><div class="figure" id="justify_content_start">&#13;
<img alt="" src="assets/css5_1116.png"/>&#13;
<h6><span class="label">Figure 11-16. </span>The effects of <code>start</code> content justification <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-start.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The mirror of this is setting <code>justify-content: end</code> or <code>flex-end</code>, which puts the last flex on a line flush against the main-end with each preceding flex item being placed flush with the subsequent item.  In this case, if the items aren’t allowed to&#13;
wrap, and if there isn’t enough room for all the items, the items will&#13;
overflow on the main-start edge, as illustrated in <a data-type="xref" href="#justify_content_end">Figure 11-17</a>.</p>&#13;
&#13;
<figure><div class="figure" id="justify_content_end">&#13;
<img alt="" src="assets/css5_1117.png"/>&#13;
<h6><span class="label">Figure 11-17. </span>The effects of <code>end</code> content justification <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-end.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Setting <code>justify-content: center</code> will pack all the items flush against each other, and center them on the center of the flex line instead&#13;
of packing them against the main-start or main-end. If there isn’t enough room for all&#13;
the items and they aren’t allowed to wrap, the items will overflow&#13;
evenly on both the main-start and &#13;
<span class="keep-together">main-end edges.</span></p>&#13;
&#13;
<p><a data-type="xref" href="#justify_content_center">Figure 11-18</a> illustrates these effects.</p>&#13;
&#13;
<figure><div class="figure" id="justify_content_center">&#13;
<img alt="" src="assets/css5_1118.png"/>&#13;
<h6><span class="label">Figure 11-18. </span>The effects of <code>center</code> content justification <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-center.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p class="less_space pagebreak-before">As the <code>left</code> and <code>right</code> values, they always start packing from the left or right edge of a row, regardless of axis directions.  Thus, <code>justify-content: left</code> will always justify row-based content to the left, whether the main-axis goes left to right or right to left.  In column-based content, <code>left</code> is treated the same as <code>start</code>, and <code>right</code> the same as <code>end</code>.  Any overflow will occur on the opposite side from where the packing started; that is, flex items will overflow on the right edge for <code>justify-content: left</code> and on the left edge for <code>right</code>.<a data-primary="" data-startref="ix_overflow_flex_cont" data-type="indexterm" id="idm45176078414320"/></p>&#13;
&#13;
<p>With those <a data-primary="spacing" data-secondary="justifying content" data-type="indexterm" id="idm45176078413184"/>relatively simple cases covered, let’s look at values that alter space between and around flex items, and compare them to their wrapped cases.  Note that if flex items are allowed to wrap onto multiple lines, the space around each flex item is based on the available space in their specific flex line only, and will not (in most cases) be consistent from one line to the next.</p>&#13;
&#13;
<p>Setting <code>justify-content: space-between</code> puts the first flex item flush&#13;
with main-start and the last flex item on the line flush with&#13;
main-end, and then puts an equal amount of space around each flex item,&#13;
until the flex line is filled (see <a data-type="xref" href="#justify_content_space-between">Figure 11-19</a>). If we have three flex&#13;
items, the same amount of space will be between the first and second items as between the second and third, but there will be no extra empty space between the main-start and main-end&#13;
edges of the container and the first and last flex items in the line.  This means if a line has only one flex item, it will be flush&#13;
with the main-start edge, not centered.  If there isn’t enough space to fit all the flex items and they aren’t allowed to wrap, the items will overflow on the main-end edge, yielding an effect visually indistinguishable from <code>justify-content: start</code>.</p>&#13;
&#13;
<figure><div class="figure" id="justify_content_space-between">&#13;
<img alt="" src="assets/css5_1119.png"/>&#13;
<h6><span class="label">Figure 11-19. </span>The effects of <code>space-between</code> content justification <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-between.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Setting <code>justify-content: space-around</code> evenly distributes the extra&#13;
space on the line around each of the flex items, as if noncollapsing margins of equal size were around each element on the&#13;
main-dimension sides (<a data-type="xref" href="#justify_content_space-around">Figure 11-20</a>). Thus, there will be twice as much space between the&#13;
first and second item as there is between main-start and the first&#13;
item, and main-end and the last item. If there isn’t enough room for all&#13;
the items and they aren’t allowed to wrap, the items will overflow&#13;
evenly on both the main-start and &#13;
<span class="keep-together">main-end</span> edges.</p>&#13;
&#13;
<figure><div class="figure" id="justify_content_space-around">&#13;
<img alt="" src="assets/css5_1120.png"/>&#13;
<h6><span class="label">Figure 11-20. </span>The effects of <code>space-around</code> content justification <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-around.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Setting <code>justify-content: space-evenly</code> means the user agent counts the items, adds one, and then splits any extra&#13;
space on the line by that many (i.e., if we have five items, the amount of space is split into six equal-size portions); see <a data-type="xref" href="#justify_content_space-evenly">Figure 11-21</a>. One portion of the space is placed before each item on the line, as if it were a noncollapsing margin, and the last portion is placed after the last item on the list. Thus, the same amount of space will appear between the first and second item as there is between main-start and the first&#13;
item, and main-end and the last item. If there isn’t enough room for all&#13;
the items and they aren’t allowed to wrap, the items will overflow&#13;
evenly on both the main-start and main-end edges.</p>&#13;
&#13;
<figure><div class="figure" id="justify_content_space-evenly">&#13;
<img alt="" src="assets/css5_1121.png"/>&#13;
<h6><span class="label">Figure 11-21. </span>The effects of <code>space-evenly</code> content justification <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-evenly.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>stretch</code> value has no effect when set as the value of <code>justify-content</code> on a flex container, and is treated the same as <code>normal</code>.  As you’ll see in the next chapter, when placed on a grid container, it causes the grid items to grow in size until they take up all available space in the main-axis direction.</p>&#13;
&#13;
<p>And finally, <code>justify-content: normal</code> is treated the same as <code>justify-content: start</code>.  This is the case for historical reasons too boring and lengthy to get into here, but what it means is that the default value of <code>justify-content</code> is essentially <code>start</code>, even if it is technically <code>normal</code>.</p>&#13;
&#13;
<p>Note in the previous few examples that when flex items are allowed to wrap onto multiple lines, the space around each flex item is based on the available space in its specific flex line only, and will not (in many cases) be consistent from one line to the next.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="justify-content example" data-type="sect3"><div class="sect3" id="justify-content-example">&#13;
<h3>justify-content example</h3>&#13;
&#13;
<p>We took advantage of the default value of <code>justify-content</code> in&#13;
<a data-type="xref" href="#simple_tabbed_navigation">Figure 11-2</a>, creating a left-aligned navigation bar. By changing the default value to&#13;
<code>justify-content: flex-end</code>, we can right-align the navigation bar in English:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="k">justify-content</code><code class="o">:</code> <code class="nb">flex-start</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that <code>justify-content</code> is applied to the flex container.  If we’d applied to the links themselves, using something like <code>nav a {justify-content: flex-start;}</code>, no alignment effect would have occurred.</p>&#13;
&#13;
<p>A major advantage of <code>justify-content</code> is that when the writing direction changes (say, for RTL writing modes), we don’t have to alter the CSS to get the tabs where they need to go.  The flex items are always grouped toward main-start when <code>flex-start</code> is applied; in English, main-start is on the left. For Hebrew, main-start is on the right.  If <code>flex-end</code> is applied and the <code>flex-direction</code> is <code>row</code>, then the tabs go to the right side in English, and the left side in Hebrew, as shown in <a data-type="xref" href="#right_and_left_aligned_navigation">Figure 11-22</a>.</p>&#13;
&#13;
<figure><div class="figure" id="right_and_left_aligned_navigation">&#13;
<img alt="Right- and left-aligned navigation in LTR and RTL languages using justify-content" src="assets/css5_1122.png"/>&#13;
<h6><span class="label">Figure 11-22. </span>Internationally robust navigation alignment <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>This may seem like the main-start and main-end are similar to inline-start and inline-end in logical properties. This will feel true when <code>flex-direction</code> is set to <code>row</code>. With <code>flex-direction:</code> <code>row-reverse</code>, however, the main-start and main-end get switched, but the inline-start and inline-end don’t, because the inline directions for the flex items remain the same even if their flex order changes.</p>&#13;
&#13;
<p>We could have centered that navigation, as shown in <a data-type="xref" href="#changing-layout-one-prop">Figure 11-23</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="k">justify-content</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="changing-layout-one-prop">&#13;
<img alt="Changing the layout with one property value pair" src="assets/css5_1123.png"/>&#13;
<h6><span class="label">Figure 11-23. </span>Changing the layout with one property value pair <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n-center.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>All the flex items we’ve shown thus far are a single line tall, and therefore are the same size in the cross dimension as their sibling flex items. Before discussing wrapping flex lines, we need to discuss aligning items of differing dimensions along the cross-axis, which is, appropriately enough, called <em>aligning</em>.<a data-primary="" data-startref="ix_flex_cont_just" data-type="indexterm" id="idm45176078307120"/><a data-primary="" data-startref="ix_just_cont_prop" data-type="indexterm" id="idm45176078306144"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Aligning Items" data-type="sect2"><div class="sect2" id="the-align-items-property">&#13;
<h2>Aligning Items</h2>&#13;
&#13;
<p>Whereas <code>justify-content</code> defines how flex items are aligned along&#13;
the flex container’s main-axis, the <code>align-items</code> property defines how&#13;
flex items are aligned along its flex line’s cross-axis.  As with <code>justify-content</code>, <code>align-items</code> is applied to flex containers, not individual flex items.<a data-primary="align-items property" data-type="indexterm" id="ix_align_item_prop"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176078300432">&#13;
<h1>align-items</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>normal</code> | <code>space-between</code> | <code>space-around</code> | <code>space-evenly</code> | <code>stretch</code> | [ <code>first</code> | <code>last</code> ]? &amp;&amp; <code>baseline</code> | [ <code>safe</code> | <code>unsafe</code> ]? <code>center</code> | <code>start</code> | <code>end</code> | <code>flex-start</code> | <code>flex-end</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Note the <code>normal</code> behaves as <code>stretch</code> for flexbox.</p>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>While <code>align-items</code> sets the alignment for all the flex items within a&#13;
container, the <a href="#the-align-self-property"><code>align-self</code> property</a>&#13;
enables overriding the alignment for individual flex items, as you’ll see in <a data-type="xref" href="#the-align-self-property">“The align-self property”</a>.</p>&#13;
</div>&#13;
&#13;
<p>In <a data-type="xref" href="#vals-align-items">Figure 11-24</a>, note how the flex items are arranged with respect to the cross-axis.  (The cross-axis is the block axis for row-flowed flex containers, and the inline axis for column-flowed flex containers.)</p>&#13;
&#13;
<figure><div class="figure" id="vals-align-items">&#13;
<img alt="The values of the align-items property when you have a single row or column of flex items" src="assets/css5_1124.png"/>&#13;
<h6><span class="label">Figure 11-24. </span>The values of the <code>align-items</code> property for both rows and columns <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/align-items-values-rows-cols.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The default value, <code>normal</code>, is treated as <code>stretch</code> in flexbox.</p>&#13;
&#13;
<p>For <code>stretch</code>, the cross-start edge of each flex item is placed against the cross-start edge of the container, and the cross-end edges are also placed against the cross-end edge of the container.  This happens regardless of the size of the content inside each flex item, so a flex item with short content (such as “One”) will still have its element box fill out the cross-axis size of the flex container.</p>&#13;
&#13;
<p>With the <code>center</code> value, by contrast, the element box is just as large as it needs to be to contain the content along the cross-axis, and no bigger.  The cross-start and -end edges of the flex items are placed the same distance away from the cross-start and -end edges of the container, thus centering the flex item’s box within the flex container along the &#13;
<span class="keep-together">cross-axis.</span></p>&#13;
&#13;
<p>For the various <code>start</code> and <code>end</code> values, the cross-start or -end edges of the flex items are all snugged up against the respective edge of the flex container.  There are so many ways to say <code>start</code> and <code>end</code>, mostly for historical reasons that are too lengthy and painful to get into here.</p>&#13;
&#13;
<p>Notice that when the items are aligned to the start or end of the cross-axis, their inline sizes are (by default) exactly as big as their content needs to be, and no wider.  It’s as if their <code>max-width</code> was set to <code>max-size</code>, so that extra content can wrap to multiple lines within the flex item, but if no wrapping is needed, the element’s inline size won’t fill out the entire flex container’s inline size.  This is a default behavior of flex items, so if you want flex elements to fill out the entire inline size of the flex container, the way block boxes fill out their containing block, use the <code>stretch</code> value instead.</p>&#13;
&#13;
<p>With <code>baseline</code>, the flex items’ first baselines are aligned with one another when they can do so, which is to say, when the <code>flex-direction</code> is <code>row</code> or <code>row-reverse</code>. Because the font size of each flex item differs, the baseline of each line in every flex item differs. The flex item&#13;
that has the greatest distance between its first baseline and its&#13;
cross-start side will be flush against the cross-start edge of the&#13;
line.  The other flex items will be placed so that their first baselines line up with the first baseline of the flex item that’s flush against the cross-start edge (and thus each other’s first baselines). When <code>align-items: last baseline;</code> is set, the inverse occurs. The flex item with the greatest distance between its last baseline and the cross-end side will be flush against the cross-end edge of the line. The other flex items will be placed with their last baseline lined up with the last baseline of the flex item that’s flush&#13;
against the cross-end edge, unless overridden by <code>align-self</code> (see <a data-type="xref" href="#the-align-self-property">“The align-self property”</a>). Since there isn’t a way to align baselines in a columnar flow, <code>baseline</code> is treated like <code>start</code> in these contexts, or <code>end</code> in the case of <code>last baseline</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flex item margins and alignment" data-type="sect3"><div class="sect3" id="idm45176078251264">&#13;
<h3>Flex item margins and alignment</h3>&#13;
&#13;
<p>Now you have a <a data-primary="margins" data-secondary="flexbox layout" data-type="indexterm" id="ix_margin_flexbox"/><a data-primary="flexible box (flexbox) layout" data-secondary="margins and" data-type="indexterm" id="ix_flex_margin"/>general idea how each value behaves, but there’s a bit more to it than that.&#13;
In the multiline <code>align-items</code> figures that follow, the following styles have been applied:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">flex-container</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="k">flex-flow</code><code class="o">:</code> <code class="n">row</code> <code class="n">wrap</code><code class="p">;</code>&#13;
  <code class="n">gap</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">flex-item</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code>&#13;
<code class="nc">.C</code><code class="o">,</code> <code class="nc">.H</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">1.5em</code><code class="p">;}</code>&#13;
<code class="nc">.D</code><code class="o">,</code> <code class="nc">.I</code> <code class="p">{</code><code class="k">margin-bottom</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
<code class="nc">.J</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">3em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>For each flex line, the cross-start and cross-end edges have been drawn in as a red dotted and blue dashed line, respectively. The C, H, D, and I boxes have added top or bottom&#13;
margins. We’ve added a <code>gap</code> (which will be discussed a bit later in the chapter) between the flex items&#13;
to make the figures more legible, which doesn’t affect the impact of the&#13;
<code>align-items</code> property in this case. The J box has its font size increased, which also increases its&#13;
line height. (This will come into play when we discuss the <code>baseline</code>&#13;
value.)</p>&#13;
&#13;
<p>The effects of these margins on both the <code>stretch</code> and <code>center</code> alignments can be seen in <a data-type="xref" href="#margins-and-align">Figure 11-25</a>.</p>&#13;
&#13;
<figure><div class="figure" id="margins-and-align">&#13;
<img alt="css5 1125" src="assets/css5_1125.png"/>&#13;
<h6><span class="label">Figure 11-25. </span>The effect of margins on cross-axis alignment</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>stretch</code> value, as its name implies, stretches all “stretchable” flex items to be as tall or wide as the tallest or widest flex item on the line.  A stretchable flex item is one that does not have a non-<code>auto</code> value set for any of the sizing properties along the cross-axis.  In <a data-type="xref" href="#margins-and-align">Figure 11-25</a>, that would be the <code>block-size</code>, <code>min-block-size</code>, <code>max-block-size</code>, <code>height</code>, <code>min-height</code>, and <code>max-height</code> properties.  If all are set to <code>auto</code>, the flex item is stretchable.  If not, it is not.</p>&#13;
&#13;
<p>Assuming a flex item is stretchable, its cross-start edge will be&#13;
flush with the flex line’s cross-start edge, and its&#13;
cross-end edge will be flush with the flex line’s cross-end edge.&#13;
The flex&#13;
item with the largest cross-size will remain its default size, and&#13;
the other flex items will grow to the size of that largest&#13;
flex item.</p>&#13;
&#13;
<p>What <a data-type="xref" href="#margins-and-align">Figure 11-25</a> shows us is that it’s the outer edge of the flex items’ <em>margins</em> that will be flush with cross-start and cross-end, not their border edges. This is demonstrated by items C, D, H, and I, which appear smaller than the other flex&#13;
items on their flex lines. They’re not, though.  It’s just that their margins, which are always fully transparent, take up some of the stretching space.<a data-primary="" data-startref="ix_align_item_prop" data-type="indexterm" id="idm45176078190400"/><a data-primary="" data-startref="ix_flex_margin" data-type="indexterm" id="idm45176078189424"/><a data-primary="" data-startref="ix_margin_flexbox" data-type="indexterm" id="idm45176078188480"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If a flex <a data-primary="overflowing flex container" data-type="indexterm" id="idm45176078141712"/>container’s cross-size is constrained, the contents may overflow&#13;
the flex container’s cross-start and/or cross-end edge. The&#13;
direction of the overflow is not determined by the <code>align-items</code>&#13;
property, but rather by the <code>align-content</code> property, discussed in <a data-type="xref" href="#the-align-content-property">“Aligning Flex Lines”</a>. The <code>align-items</code> property aligns the flex items within the flex line and does not directly impact the overflow direction of the flex items within&#13;
the <span class="keep-together">container.</span></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Baseline alignment" data-type="sect3"><div class="sect3" id="align-items-baseline">&#13;
<h3>Baseline alignment</h3>&#13;
&#13;
<p>The <code>baseline</code> values<a data-primary="baselines" data-secondary="flex item alignment" data-type="indexterm" id="ix_baseline_flex_item"/> are a little more complicated.  CSS has two possible baseline alignments, represented by <code>first baseline</code> and <code>last baseline</code>.  You can also use the value <code>baseline</code>, which is equivalent to <code>first baseline</code>.</p>&#13;
&#13;
<p>With <code>baseline</code> (and <code>first baseline</code>),&#13;
the flex items in each line are all aligned at the lowest first baseline.&#13;
For each flex line, the&#13;
flex item with the biggest distance between its&#13;
baseline and its cross-start margin edge has that margin edge placed flush against the&#13;
cross-start edge of the line, and all other flex items’ baselines are&#13;
lined up with the baseline of that flex item.</p>&#13;
&#13;
<p>To understand this, take a look at the first set of flex items in <a data-type="xref" href="#align-items_baseline">Figure 11-26</a>, the ones labeled <code>baseline</code> (and <code>first baseline</code>). For each flex line, the cross-start and -end edges are marked with solid red and blue lines, respectively. The baseline to which the items in each line are aligned is marked with a dotted line, and the element whose baseline is taken as the prime baseline has a lighter background and red text.</p>&#13;
&#13;
<figure><div class="figure" id="align-items_baseline">&#13;
<img alt="css5 1126" src="assets/css5_1126.png"/>&#13;
<h6><span class="label">Figure 11-26. </span>Baseline alignments <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/baseline-alignments.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first line (A through E), it is the C box whose first baseline is used.  This is because the C box has a top margin, so its first baseline is the farthest from the cross-start edge of the flex line.  All the other boxes (A, B, D, and E) have their first baselines aligned with the first baseline of C.</p>&#13;
&#13;
<p>In the second line (F through J), H’s first baseline is used—again, because of its top margin—and so the F, G, I, and J boxes have their first baselines aligned with H’s.  Here, we can also see how the J box has its first baseline aligned with all the others, despite its much bigger font size.</p>&#13;
&#13;
<p>Similar things happen for the flex items labeled with <code>last baseline</code>, only here, the dominating factors are bottom margins.  The D box in the first line has a bottom margin, as does the I box in the second line.  In both cases, their last baselines are the farthest away from the cross-end edge of the line, and so all the other flex items in their rows have their last baselines aligned with the last baselines of D and I.  The dotted lines show the placements of the last baselines in each flex line.</p>&#13;
&#13;
<p>In many cases, <code>first baseline</code> will look like <code>start</code> (and its equivalents, such as <code>flex-start</code>), and <code>last baseline</code> will look like <code>end</code>.  For example, had C lacked a top margin in <a data-type="xref" href="#align-items_baseline">Figure 11-26</a>, all the items in that first line would have been visibly flush against the top of the flex line, instead of pushed away from it.  Anytime flex items have different margins, borders, padding, font sizes, or line heights on their cross-start side, the <code>start</code> and <code>first baseline</code> will differ.  Similarly, any cross-end margins, borders, etc. will create a difference between the results of <code>last baseline</code> and <code>end</code>.</p>&#13;
&#13;
<p>Any of the baseline values can become <code>start</code> when the baselines of the flex items are parallel to the cross-axis.  For example, suppose we take the flex containers in <a data-type="xref" href="#align-items_baseline">Figure 11-26</a> and change them to <code>flex-direction: column</code>.  Now the cross-axis, like the baselines of the English text within, is horizontal.  Since there’s no way to create an offset from the cross-start edge of the columns that will align the text baselines, <code>baseline</code> is treated exactly as if it were <code>start</code> instead; or <code>end</code>, in the case of last baseline.<a data-primary="" data-startref="ix_baseline_flex_item" data-type="indexterm" id="idm45176078114288"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Safe and unsafe alignment" data-type="sect3"><div class="sect3" id="safe-and-unsafe-alignment">&#13;
<h3>Safe and unsafe alignment</h3>&#13;
&#13;
<p>In all the <a data-primary="safe and unsafe flex item alignment" data-type="indexterm" id="idm45176078111600"/>previous examples, we let the flex containers be whatever size they needed to be to contain the flex lines; that is, we left them at <code>block-size: auto</code> (or <code>height: auto</code>, in old-school CSS terminology).  But what happens if the block size of a flex container is constrained in some way, perhaps by the size of a grid track or an explicit block size value being given?  In these situations, the <code>safe</code> and <code>unsafe</code> keywords come into play.</p>&#13;
&#13;
<p>If <code>safe</code> alignment is specified, then anytime a flex item would overflow the flex container, the flex item is treated as though its <code>align-self</code> were set to <code>start</code>.  That would look something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">flex-container</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code>&#13;
     <code class="k">align-items</code><code class="o">:</code> <code class="n">safe</code> <code class="n">first</code> <code class="nb">baseline</code><code class="p">;}</code></pre>&#13;
&#13;
<p>On the other hand, if <code>unsafe</code> is used, the alignment of flex items is honored no matter what that means in terms of overflowing the flex container.</p>&#13;
&#13;
<p>If you’re wondering which is the default, the answer is neither.  Instead, when neither safe nor unsafe alignment has been declared, browsers should default to <code>unsafe</code> behavior <em>unless</em> this would cause flex items to overflow the scrollable area of their nearest ancestor’s scroll container, in which case they should align to the cross-axis edge farthest away from the edge they would otherwise overflow. <a data-type="xref" href="#safe_unsafe_alignment">Figure 11-27</a> shows some examples.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, only Firefox browsers fully support the <code>safe</code> and <code>unsafe</code> keywords, and they have to be written first in the value (as shown in this section) even though the formal syntax for the property does not require this placement. All other evergreen browsers recognize these keywords as valid, but they have no impact on the layout.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="safe_unsafe_alignment">&#13;
<img alt="" src="assets/css5_1127.png"/>&#13;
<h6><span class="label">Figure 11-27. </span><code>Safe</code> versus <code>unsafe</code> alignments</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The align-self property" data-type="sect3"><div class="sect3" id="the-align-self-property">&#13;
<h3>The align-self property</h3>&#13;
&#13;
<p>If you <a data-primary="align-self property" data-type="indexterm" id="idm45176078073664"/>want to change the&#13;
alignment of one or more flex items, but not all, you can include the&#13;
<code>align-self</code> property on the flex items you would like to align&#13;
differently. This property takes the same values as <code>align-items</code> and is used to override the <code>align-items</code> property&#13;
value on a per-flex-item basis.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176078071216">&#13;
<h1>align-self</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> | <code>normal</code> | <code>stretch</code> | [ <code>first</code> | <code>last</code> ]? &amp;&amp; <code>baseline</code> | [ <code>unsafe</code> | <code>safe</code> ]? [ <code>center</code> | <code>start</code> | <code>end</code> | <code>self-start</code> | <code>self-end</code> | <code>flex-start</code> | <code>flex-end</code> ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Not applicable</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>You can override the cross-axis alignment of any individual flex item with the&#13;
<code>align-self</code> property, as long as it’s represented by an element or pseudo-element.&#13;
You cannot <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="anonymous" data-type="indexterm" id="idm45176078031584"/><a data-primary="anonymous items" data-secondary="flex items" data-type="indexterm" id="idm45176078030368"/>override the alignment for anonymous flex items (non-empty&#13;
text node children of flex containers). Their <code>align-self</code> always&#13;
matches the value of <code>align-items</code> of their parent flex container.</p>&#13;
&#13;
<p>The default value of <code>align-items</code> is <code>stretch</code>, but let’s make that explicit in the following code, which will let us set different <code>align-self</code> values for the second flex item, as illustrated in <a data-type="xref" href="#align_self_fig">Figure 11-28</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.flex-container</code> <code class="p">{</code><code class="k">align-items</code><code class="o">:</code> <code class="n">stretch</code><code class="p">;}</code>&#13;
<code class="nc">.flex-container</code> <code class="nc">.two</code> <code class="p">{</code><code class="k">align-self</code><code class="o">:</code> <code class="n">var</code><code class="p">(</code><code class="o">--</code><code class="n">selfAlign</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="align_self_fig">&#13;
<img alt="css5 1128" src="assets/css5_1128.png"/>&#13;
<h6><span class="label">Figure 11-28. </span>Changing individual flex-item alignments <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/gaps-between-items.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>All these flex items have <code>align-self</code>’s default value of <code>auto</code>, meaning they inherit the alignment (in this case, <code>stretch</code>) from the container’s <code>align-items</code> <span class="keep-together">property</span>.  The exception in each example is the second flex item, which has been given the <code>align-self</code> value shown underneath.</p>&#13;
&#13;
<p>As we said, all the values of <code>align-items</code> can be used for <code>align-self</code>, including the values for first and last baseline alignment, <code>safe</code> and <code>unsafe</code> alignment, and so on.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Aligning Flex Lines" data-type="sect2"><div class="sect2" id="the-align-content-property">&#13;
<h2>Aligning Flex Lines</h2>&#13;
&#13;
<p>In nearly all the previous examples, the flex container’s cross-size was always as tall as it needed to be: no <code>block-size</code> or <code>height</code> was declared on the container, so&#13;
it defaulted to <code>height: auto</code>. Because of this, the flex container grew to fit the content.</p>&#13;
&#13;
<p>Had the cross-size of the container been set to a specific size, there may have been extra space at the cross-end, or not enough space to fit the content.  <a data-primary="align-content property" data-type="indexterm" id="ix_align_content_prop"/>In such cases, CSS allows us to control the overall placement of flex lines with the <code>align-content</code> property.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176077988208">&#13;
<h1>align-content</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>normal</code> | [ <code>first</code> | <code>last</code> ]? &amp;&amp; <code>baseline</code> | <code>space-between</code> | <code>space-around</code> | <code>space-evenly</code> | <code>stretch</code> | [ <code>unsafe</code> | <code>safe</code> ]? [ <code>center</code> | <code>start</code> | <code>end</code> | <br/><code>flex-start</code> | <code>flex-end</code> ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Multiline flex containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>align-content</code> <a data-primary="spacing" data-secondary="aligning content" data-type="indexterm" id="idm45176077950880"/>property dictates how any extra&#13;
cross-direction space in a flex container is distributed between and&#13;
around flex lines. Although the values and concepts are largely the same, <code>align-content</code> is different from the previously discussed <code>align-items</code> property, which dictates flex item positioning within each flex line.</p>&#13;
&#13;
<p>Think of <code>align-content</code> as similar to the way <code>justify-content</code> aligns&#13;
individual items along the main-axis of the flex container, but it does so for&#13;
flex lines with regard to the cross-axis of the container. This property applies to multiline flex containers, having no effect on nonwrapping&#13;
and otherwise single-line flex containers.</p>&#13;
&#13;
<p>Consider the following CSS as a base and assume the flex items have no margins:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.flex-container</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="k">flex-flow</code><code class="o">:</code> <code class="n">row</code> <code class="n">wrap</code><code class="p">;</code>&#13;
  <code class="k">align-items</code><code class="o">:</code> <code class="nb">flex-start</code><code class="p">;</code>&#13;
  <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">dashed</code><code class="p">;</code>&#13;
  <code class="k">height</code><code class="o">:</code> <code class="m">14em</code><code class="p">;</code>&#13;
  <code class="k">background-image</code><code class="o">:</code> <code class="sx">url(banded.svg)</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#distribution_of_extra_space">Figure 11-29</a> demonstrates the possible values of the <code>align-content</code>&#13;
property, as used in conjunction with that CSS.  We’ve concentrated on the primary alignment values, and left out examples of things such as safe and unsafe alignment as well as the first and last baseline alignments.</p>&#13;
&#13;
<p>With a height of 14 ems, the flex container is taller than the default combined heights of&#13;
the three flex lines.  Given the larger text of some flex items and the various bits of padding and borders, each flex container in <a data-type="xref" href="#distribution_of_extra_space">Figure 11-29</a> has approximately 3 ems of &#13;
<span class="keep-together">leftover space.</span></p>&#13;
&#13;
<figure><div class="figure" id="distribution_of_extra_space">&#13;
<img alt="The distribution of extra space for the different values of align-content" src="assets/css5_1129.png"/>&#13;
<h6><span class="label">Figure 11-29. </span>Distribution of extra space for primary values of <code>align-content</code> <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/align-content.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>With the values <code>normal</code>, <code>stretch</code>, <code>center</code>, <code>start</code>, <code>flex-start</code>, <code>end</code>, and <code>flex-end</code>, the free space is&#13;
distributed outside the flex lines, as illustrated in&#13;
<a data-type="xref" href="#distribution_of_extra_space">Figure 11-29</a>.  These act in the same ways as they do for <code>align-items</code>. <a data-primary="stretching" data-secondary="aligning content" data-type="indexterm" id="idm45176077905056"/>With&#13;
the value <code>stretch</code>, the extra space is evenly distributed to all the flex&#13;
lines, increasing their cross-size until their edges touch.  For the others, the flex lines are kept together, with the leftover space placed to one side or another.</p>&#13;
&#13;
<p>For the remaining values, the flex lines are pushed apart and the leftover space distributed in various ways.  Let’s assume the approximately 3 ems of leftover space is equal to 120 pixels.  (It’s big text, OK?)</p>&#13;
&#13;
<p>Given <code>space-between</code>, about 60 pixels of space is between each adjacent&#13;
pair of flex lines, each half of the leftover 120 pixels.&#13;
With <code>space-around</code>, the space is evenly distributed around each line: the&#13;
120 pixels are split into three pieces, since there are three flex lines.  This puts 20 pixels of noncollapsed space (half of 40 pixels) on the&#13;
cross-start and cross-end sides of each flex line, so we have 20 pixels&#13;
of extra space at the cross-start and cross-end sides of the flex&#13;
container, and 40 pixels of space between adjacent flex lines.</p>&#13;
&#13;
<p>For <code>space-evenly</code>, there are four spaces to insert: one before each flex line, and an extra space after the last flex line.  With three lines, that means four spaces, with 30 pixels for each space.  That places 30 pixels of space at the cross-start and cross-end sides of the flex container, and 30 pixels between adjacent flex lines.</p>&#13;
&#13;
<p>Continuing this example for the stretch value, you’ll note that the <code>stretch</code> value is different: with <code>stretch</code>, the lines stretch with&#13;
the extra space evenly distributed among the flex lines rather than&#13;
between them. In this case, 40 pixels are added to each of the flex lines, causing all three lines to grow in height by an equal amount—that is, the extra space is divided equally, not proportionally, with the exact same amount added to each.</p>&#13;
&#13;
<p>If there isn’t enough room for all the lines, they will overflow at&#13;
cross-start, cross-end, or both, depending on the value of the&#13;
<code>align-content</code> property.  This is shown in <a data-type="xref" href="#align_content_overflowing">Figure 11-30</a>, where the dotted box with a light-gray background represents a short flex container.  (A little bit of inline padding was added to each flex container to make it more obvious where it starts and ends.)</p>&#13;
&#13;
<figure><div class="figure" id="align_content_overflowing">&#13;
<img alt="Appearance of align-content property when lines are overflowing the container" src="assets/css5_1130.png"/>&#13;
<h6><span class="label">Figure 11-30. </span>Flex-line overflow directions for each value of <code>align-content</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>The only difference in the CSS between this and&#13;
<a data-type="xref" href="#distribution_of_extra_space">Figure 11-29</a> is the height of the flex container. Here, the flex containers have been reduced to a height of 7 ems, so as to&#13;
create flex containers not tall enough to encompass all their flex lines (which, as you may recall, total around 10 ems in height).</p>&#13;
&#13;
<p>When the flex lines <a data-primary="overflowing flex container" data-type="indexterm" id="idm45176077864448"/>overflow the flex container, the <code>align-content</code> values <code>normal</code>, <code>stretch</code>, <code>start</code>, <code>flex-start</code>, <code>baseline</code>, <code>last baseline</code>, and&#13;
<code>space-between</code> cause them to overflow on the cross-end side, whereas the values <code>center</code>, <code>space-around</code>, and <code>space-evenly</code> evenly overflow both the cross-end and cross-start&#13;
sides.  Only <code>align-content:</code> <code>end</code> and <code>flex-end</code> cause flex lines to overflow on just the cross-start side.</p>&#13;
&#13;
<p>Keep in mind that these values are not top- or bottom-centric.  If the cross-axis goes upward, <code>align-content: flex-start</code> will start aligning flex lines from the bottom and work upward from there, potentially overflowing the top (cross-end) edge.  For that matter, when the flow direction is columnar, the cross-axis will be horizontal, in which case the cross-start and -end edges will be the right or left edges of the flex container.<a data-primary="" data-startref="ix_align_content_prop" data-type="indexterm" id="idm45176077856800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the place-content Property" data-type="sect2"><div class="sect2" id="the-place-content-property">&#13;
<h2>Using the place-content Property</h2>&#13;
&#13;
<p>CSS offers a <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="shorthand property" data-type="indexterm" id="idm45176077853888"/><a data-primary="place-content property" data-type="indexterm" id="idm45176077852544"/>shorthand property that collapses <code>align-content</code>, which we just covered, and <code>justify-content</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176077850768">&#13;
<h1>place-content</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>align-content</code></em>&gt;  &lt;<em><code>justify-content</code></em>&gt;?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Block, flex, and grid containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>You can supply either one or two values.  If you supply one, <code>place-content</code> acts as if you had set both <code>align-content</code> and <code>justify-content</code> to the same value.  In other words, the following two rules are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="n">place</code><code class="o">-</code><code class="k">content</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="p">{</code><code class="n">align</code><code class="o">-</code><code class="k">content</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code> <code class="k">justify-content</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The exception to this behavior occurs if the value is baseline-related, such as <code>first baseline</code>.  In that case, the value for <code>justify-content</code> is set to <code>start</code>, making the following two rules equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="n">place</code><code class="o">-</code><code class="k">content</code><code class="o">:</code> <code class="n">last</code> <code class="nb">baseline</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="p">{</code><code class="n">align</code><code class="o">-</code><code class="k">content</code><code class="o">:</code> <code class="n">last</code> <code class="nb">baseline</code><code class="p">;</code> <code class="k">justify-content</code><code class="o">:</code> <code class="n">start</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If two values are given, the second is the value of <code>justify-content</code>.  Thus, the following two rules are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="n">place</code><code class="o">-</code><code class="k">content</code><code class="o">:</code> <code class="n">last</code> <code class="nb">baseline</code> <code class="n">end</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="p">{</code><code class="n">align</code><code class="o">-</code><code class="k">content</code><code class="o">:</code> <code class="n">last</code> <code class="nb">baseline</code><code class="p">;</code> <code class="k">justify-content</code><code class="o">:</code> <code class="n">end</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That’s pretty much all there is to <code>place-content</code>. If you’d rather align and justify content by using a single shorthand property, <code>place-content</code> does that.  Otherwise, use the individual properties separately.</p>&#13;
&#13;
<p>Two more <code>place-</code> shorthand properties are covered in <a data-type="xref" href="ch12.html#grid-layout">Chapter 12</a>.<a data-primary="" data-startref="ix_align_flex_item" data-type="indexterm" id="idm45176077691120"/><a data-primary="" data-startref="ix_flex_items_align" data-type="indexterm" id="idm45176077690144"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Opening Gaps Between Flex Items" data-type="sect1"><div class="sect1" id="the-gap-properties">&#13;
<h1>Opening Gaps Between Flex Items</h1>&#13;
&#13;
<p>Flex <a data-primary="gaps" data-secondary="opening between flex items" data-type="indexterm" id="ix_gap_flex_item"/><a data-primary="spacing" data-secondary="flex items" data-type="indexterm" id="ix_spacing_flex_item"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="opening gaps between" data-type="indexterm" id="ix_flex_item_gap"/>items are, by default, rendered with no space held open between them.  Space can appear between items thanks to values of <code>justify-content</code> or by adding margins to flex items, but these approaches are not always ideal.  For example, margins can lead to flex line wrapping when it isn’t actually needed, and even using <code>justify-content</code> values like <code>space-between</code> can result in having no space separating the items.  <a data-primary="row-gap property" data-type="indexterm" id="ix_row_gap_prop"/><a data-primary="column-gap property" data-type="indexterm" id="ix_col_gap_prop"/>It would be easier if there was a way to define what are essentially minimum gap sizes, and thanks to the gap properties, there is.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176077676928">&#13;
<h1>row-gap, column-gap</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>normal</code> | [ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex, grid, and multicolumn containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified for <code>normal</code>; otherwise, the computed length value</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes (for length values)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Each of these <a data-primary="gutter space" data-secondary="between flex items" data-type="indexterm" id="idm45176077662192"/>properties inserts space of the declared size between adjacent flex items.  This space is often referred to as a <em>gutter</em>.  For historical reasons, the default value, <code>normal</code>, equates to 0 pixels (no space) in flexbox and grid containers, and <code>1</code> em in multicolumn layout.  Otherwise, you can supply a single length or percentage value.</p>&#13;
&#13;
<p>Suppose we have a set of flex items that will wrap to multiple flex lines, and we want to open a 15-pixel gap between the flex lines.  Here’s what that CSS would look like, illustrated in <a data-type="xref" href="#row-gaps">Figure 11-31</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code> <code class="nb">flex</code><code class="o">-</code><code class="n">wrap</code><code class="o">:</code> <code class="n">wrap</code><code class="p">;</code> <code class="n">row</code><code class="o">-</code><code class="n">gap</code><code class="o">:</code> <code class="m">15px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="row-gaps">&#13;
<img alt="" src="assets/css5_1131.png"/>&#13;
<h6><span class="label">Figure 11-31. </span>Gaps between rows of flex items</h6>&#13;
</div></figure>&#13;
&#13;
<p>No <a data-primary="flexible box (flexbox) layout" data-secondary="margins and" data-type="indexterm" id="idm45176077636992"/><a data-primary="margins" data-secondary="flexbox layout" data-type="indexterm" id="idm45176077636016"/>margins are set on the flex items, to be clear. Exactly 15 pixels of space is between each flex line (row), thanks to the value of <code>row-gap</code>. In essence, <code>row-gap</code> acts as if it were called <code>block-axis-gap</code>, so if the writing mode were changed to something like <code>vertical-rl</code>, thus making the block axis horizontal, the rows would flow top to bottom, and the gaps between them would be to their right and left sides (which are their block-start and block-end sides).</p>&#13;
&#13;
<p>Note that there are gaps only between rows: there are no gaps placed between the flex items and the block-start and -end edges of the flex container.  If you want to open gaps of the same size along those container edges, you would write something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code> <code class="nb">flex</code><code class="o">-</code><code class="n">wrap</code><code class="o">:</code> <code class="n">wrap</code><code class="p">;</code> <code class="n">row</code><code class="o">-</code><code class="n">gap</code><code class="o">:</code> <code class="m">15px</code><code class="p">;</code> <code class="n">padding</code><code class="o">-</code><code class="nb">block</code><code class="o">:</code> <code class="m">15px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In a like manner, we can open spaces between the flex items along the inline axis by using <code>column-gap</code>.  We can modify the earlier example to push items apart as follows, with the result shown in <a data-type="xref" href="#column-gaps">Figure 11-32</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code> <code class="nb">flex</code><code class="o">-</code><code class="n">wrap</code><code class="o">:</code> <code class="n">wrap</code><code class="p">;</code> <code class="k">column-gap</code><code class="o">:</code> <code class="m">15px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="column-gaps">&#13;
<img alt="" src="assets/css5_1132.png"/>&#13;
<h6><span class="label">Figure 11-32. </span>Gaps between adjacent flex items along the inline axis</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here, leftover space remains at the inline-end side of the flex lines, with each line having its own amount of space.  That’s because the flex items weren’t given a <code>justify-content</code> value, so they defaulted to <code>start</code>.  This means the gaps between the flex items are all exactly 15 pixels wide.</p>&#13;
&#13;
<p>If we were to change the value of <code>justify-content</code> to <code>space-between</code>, then in any flex line with leftover space, the gaps between flex items will be increased by an equal amount, meaning they will be separated by more than 15 pixels.  If there’s a line where the inline sizes of all the flex items and all the gaps exactly equals the inline length of the flex line, 15 pixels of space will be between each flex item.</p>&#13;
&#13;
<p>This is why <code>row-gap</code> and <code>column-gap</code> are really more like minimum separation distances between flex items or flex lines.  The gaps don’t count as “leftover space,” any more than the flex items do.</p>&#13;
&#13;
<p>Gaps are inserted between the outer margin edges of adjacent flex items, so if you add margins to your flex items, the actual visible space between two flex items will be the width of the gap plus the widths of the margins.  Consider the following, which is illustrated in <a data-type="xref" href="#column-gaps-plus-margins">Figure 11-33</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.gallery</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code> <code class="nb">flex</code><code class="o">-</code><code class="n">wrap</code><code class="o">:</code> <code class="n">wrap</code><code class="p">;</code> <code class="k">column-gap</code><code class="o">:</code> <code class="m">15px</code><code class="p">;}</code>&#13;
<code class="nc">.gallery</code> <code class="nt">div</code> <code class="p">{</code><code class="n">margin</code><code class="o">-</code><code class="nb">inline</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="column-gaps-plus-margins">&#13;
<img alt="" src="assets/css5_1133.png"/>&#13;
<h6><span class="label">Figure 11-33. </span>Gaps and margins combine to open more space</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now the open spaces between flex items are all 35 pixels wide: 15 pixels from the <code>gap</code> property, plus 20 pixels (10 + 10) from the inline-side margins set on the flex items.</p>&#13;
&#13;
<p>Thus far we’ve used length values, but what about percentages?  Any percentage value used for a gap is taken to be a percentage of the container’s size along the relevant axis.  Thus, given <code>column-gap: 10%</code>, the gaps will be 10% the inline size of the flex container.  If the container is 640 pixels wide along the inline axis, the column gaps will be 64 pixels each.<a data-primary="" data-startref="ix_col_gap_prop" data-type="indexterm" id="idm45176077458016"/></p>&#13;
&#13;
<p>Working with rows can be a little more complicated.  If you define an explicit block size, percentages are just a percentage of that block size.  A <code>block-size</code> (which could also be set with <code>height</code> or <code>width</code>) of <code>25em</code> and a <code>row-gap</code> of <code>10%</code> means row gaps will be 2.5 ems wide.  This same sort of thing can also happen if the block size happens to be larger than the sum total of the rows’ block sizes.</p>&#13;
&#13;
<p>But when the <a data-primary="cyclic calculation" data-type="indexterm" id="idm45176077451248"/>block size is solely determined by the block sizes of the rows added together, any percentage value could lead to a <em>cyclic calculation</em>: each calculation changes the value being calculated, ad infinitum.  Suppose a flex container has three flex lines, each exactly 30 pixels tall.  The flex container is set so its height is <code>auto</code>, so it will “shrink-wrap” the flex lines, making it 90 pixels tall (we’re assuming no padding here, but the principles are the same regardless).  A <code>row-gap</code> of <code>10%</code> would mean 9-pixel row gaps, and inserting the 2 row gaps would add 18 pixels of height.  That would increase the container’s height to 108 pixels, which would mean the 10%-wide gaps are now 10.8 pixels, so the container height increases again, which increases the row gaps, which increases container height, which…</p>&#13;
&#13;
<p>To avoid this sort of infinite-loop scenario, the gaps are set to be zero-width whenever a cyclic calculation would happen, and everyone moves on with their lives.  In practice, this means that percentage values for row gaps are useful only in a narrow range of cases, whereas they can be more broadly useful for column gaps. <a data-type="xref" href="#percentage-based-row-gaps">Figure 11-34</a> shows examples of percentage row gaps.</p>&#13;
&#13;
<figure><div class="figure" id="percentage-based-row-gaps">&#13;
<img alt="" src="assets/css5_1134.png"/>&#13;
<h6><span class="label">Figure 11-34. </span>Percentage-based row gaps with and without explicit container heights</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can set up both <a data-primary="gap property" data-type="indexterm" id="ix_gap_prop"/>column and gap rows on a flex container by supplying the two properties individually, or you can use the shorthand property <code>gap</code>.<a data-primary="" data-startref="ix_row_gap_prop" data-type="indexterm" id="idm45176077443872"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176077442736">&#13;
<h1>gap</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>row-gap</code></em>&gt; &lt;<em><code>column-gap</code></em>&gt;?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0 0</code> for flex and grid layout; <code>0 1em</code> for multicolumn layout</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex, grid, and multicolumn containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes (for length values)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>You need to supply only one value to <code>gap</code>, in which case it will be used for both the row and column gaps.  If you supply two values, the first will always be used for row gaps, and the second for column gaps.  Thus you get the results shown in <a data-type="xref" href="#using-the-gap-shorthand">Figure 11-35</a> from the &#13;
<span class="keep-together">following</span> CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#ex01</code> <code class="p">{</code><code class="n">gap</code><code class="o">:</code> <code class="m">15px</code> <code class="m">5px</code><code class="p">;}</code>&#13;
<code class="nf">#ex02</code> <code class="p">{</code><code class="n">gap</code><code class="o">:</code> <code class="m">5px</code> <code class="m">15px</code><code class="p">;}</code>&#13;
<code class="nf">#ex03</code> <code class="p">{</code><code class="n">gap</code><code class="o">:</code> <code class="m">5px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="using-the-gap-shorthand">&#13;
<img alt="" src="assets/css5_1135.png"/>&#13;
<h6><span class="label">Figure 11-35. </span>Row and column gaps set using the <code>gap</code> shorthand property</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The  original <code>gap</code> property was defined in CSS Multiple Columns, with additional hyphenated gap properties defined in CSS Grid as <code>grid-row-gap</code>, <code>grid-column-gap</code>, and <code>grid-gap</code>, before being made more generic and available in grid, flexbox, and multicolumn contexts.  Browsers are required to treat the older properties as aliases for the newer, more generic properties; e.g., <code>grid-gap</code> is an alias for <code>gap</code>.  So if you find the older grid gap properties in legacy CSS, you can change them to the newer names, but if not, they’ll still work as if you had.<a data-primary="" data-startref="ix_flex_item_gap" data-type="indexterm" id="idm45176077392704"/><a data-primary="" data-startref="ix_gap_flex_item" data-type="indexterm" id="idm45176077391728"/><a data-primary="" data-startref="ix_spacing_flex_item" data-type="indexterm" id="idm45176077390784"/><a data-primary="" data-startref="ix_gap_prop" data-type="indexterm" id="idm45176077389840"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flex Items" data-type="sect1"><div class="sect1" id="flex-items">&#13;
<h1>Flex Items</h1>&#13;
&#13;
<p>In the <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="flex containers and" data-type="indexterm" id="ix_flex_item_cont"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex containers" data-type="indexterm" id="ix_flex_cont_item"/>previous sections, you saw how to globally lay out all the flex&#13;
items within a flex container by styling that&#13;
container. The flexible box layout specification provides several additional&#13;
properties applicable directly to flex items. With these flex-item-specific&#13;
properties, we can more precisely control the layout of individual flex&#13;
containers’ children.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Are Flex Items?" data-type="sect2"><div class="sect2" id="what-are-flex-items">&#13;
<h2>What Are Flex Items?</h2>&#13;
&#13;
<p>As you’ve <a data-primary="display property" data-secondary="flex items" data-type="indexterm" id="idm45176077382016"/>seen throughout the chapter, we create flex containers by adding <code>display: flex</code> or&#13;
<code>display: inline-flex</code> to an element that has child nodes. The children&#13;
of those flex containers are called <em>flex items</em>—whether they’re child elements,&#13;
non-empty text nodes between child elements, or generated content. In <a data-type="xref" href="#display_flex_containers_children">Figure 11-36</a>, each letter is enclosed in its own element, including the space between words, so that each letter and space becomes a flex item.</p>&#13;
&#13;
<figure><div class="figure" id="display_flex_containers_children">&#13;
<img alt="Items with display: flex; become flex containers, and their non-absolutely positioned children become flex items" src="assets/css5_1136.png"/>&#13;
<h6><span class="label">Figure 11-36. </span>The child nodes are flex items, and the parent node is a flex container <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-within-container.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>When it <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="anonymous" data-type="indexterm" id="idm45176077356032"/><a data-primary="anonymous items" data-secondary="flex items" data-type="indexterm" id="idm45176077354848"/>comes to text-node children of flex containers, if the text node&#13;
is not empty (containing content other than whitespace), it will be&#13;
wrapped in an <em>anonymous flex item</em>, behaving like its flex-item siblings.&#13;
While these anonymous flex items do inherit all the flex properties set&#13;
by the flex container, just like their DOM node siblings, they are not&#13;
directly targetable with CSS. We can’t directly set any of&#13;
the flex-item-specific properties on them.  Thus, in the following markup, the two elements (<code>&lt;strong&gt;</code> and <code>&lt;em&gt;</code>) and the text “they’re what’s for” become flex items, for a total of three flex items:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"display: flex;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;strong&gt;</code>Flex<code class="w"> </code>items:<code class="nt">&lt;/strong&gt;</code><code class="w"> </code>they’re<code class="w"> </code>what’s<code class="w"> </code>for<code class="w"> </code><code class="nt">&lt;em&gt;</code><code class="ni">&amp;lt;</code>br<code class="ni">&amp;gt;</code>fast!<code class="nt">&lt;/em&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Generated content (via <code>::before</code> and <code>::after</code>) can be styled directly; therefore, all the properties&#13;
discussed in this chapter apply equally to generated content and to element nodes.</p>&#13;
&#13;
<p>Whitespace-only<a data-primary="whitespace" data-secondary="as ignored by flex container" data-secondary-sortas="ignored by flex container" data-type="indexterm" id="idm45176077300944"/> text nodes within a flex container are ignored, as if&#13;
their <code>display</code> property were set to <code>none</code>, as the following code example shows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;nav&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"#1"</code><code class="nt">&gt;</code>Link<code class="w"> </code>1<code class="nt">&lt;/a&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"#2"</code><code class="nt">&gt;</code>Link<code class="w"> </code>2<code class="nt">&lt;/a&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"#3"</code><code class="nt">&gt;</code>Link<code class="w"> </code>3<code class="nt">&lt;/a&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"#4"</code><code class="nt">&gt;</code>Link<code class="w"> </code>4<code class="nt">&lt;/a&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"#5"</code><code class="nt">&gt;</code>Link<code class="w"> </code>5<code class="nt">&lt;/a&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/nav&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In the preceding code, with the <code>display</code> property set to <code>flex</code>, the&#13;
unordered list is the flex container, and its child list items are all&#13;
flex items. These list items, being flex items, are flex-level boxes—semantically still list items, but not list items in their presentation.&#13;
They are not block-level boxes either. Rather, they participate in their&#13;
container’s flex-formatting context. The whitespace between and around the <code>&lt;li&gt;</code> elements—the line feeds and indenting tabs and/or spaces—is completely ignored. The links are not flex items themselves, but are descendants of the flex items the list items have become.<a data-primary="" data-startref="ix_flex_cont_item" data-type="indexterm" id="idm45176077224048"/><a data-primary="" data-startref="ix_flex_item_cont" data-type="indexterm" id="idm45176077223104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flex Item Features" data-type="sect2"><div class="sect2" id="flex-item-features">&#13;
<h2>Flex Item Features</h2>&#13;
&#13;
<p>The <a data-primary="flexible box (flexbox) layout" data-secondary="margins and" data-type="indexterm" id="idm45176077220192"/><a data-primary="margins" data-secondary="flexbox layout" data-type="indexterm" id="idm45176077218832"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="features" data-type="indexterm" id="ix_flex_item_feat"/><a data-primary="vertical formatting" data-secondary="collapsing margins" data-type="indexterm" id="idm45176077216432"/><a data-primary="margins" data-secondary="collapsing" data-type="indexterm" id="idm45176077215488"/><a data-primary="clear property" data-type="indexterm" id="idm45176077214544"/><a data-primary="float property" data-type="indexterm" id="idm45176077173520"/>margins of flex items do not collapse. The <code>float</code> and <code>clear</code>&#13;
properties don’t have an effect on flex items and do not take a flex&#13;
item out of flow. In effect, <code>float</code> and <code>clear</code> are ignored when applied to flex items. (However, the <code>float</code> property can still affect box&#13;
generation by influencing the <code>display</code> property’s computed value.) Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">aside</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">img</code> <code class="p">{</code>&#13;
  <code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;aside&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="cm">&lt;!-- this is a comment --&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;h1&gt;</code>Header<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"images/foo.jpg"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"Foo Master"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>Some<code class="w"> </code>text<code class="w"/>&#13;
<code class="nt">&lt;/aside&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the <code>aside</code> is the flex container. The comment and&#13;
whitespace-only text nodes are ignored. The text node containing “Some&#13;
text” is wrapped in an anonymous flex item. The header, image, and text&#13;
node containing “Some text” are all flex items. Because the image is a flex&#13;
item, the <code>float</code> is ignored.</p>&#13;
&#13;
<p>Even though <a data-primary="blocks" data-secondary="blockification of flex items" data-type="indexterm" id="idm45176077101152"/>images and text nodes are&#13;
inline-level nodes, because they are flex items, they are blockified as long as they are not absolutely positioned:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">aside</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="k">align-items</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">aside</code> <code class="o">*</code> <code class="p">{</code>&#13;
  <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;aside&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="cm">&lt;!-- a comment --&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;h1&gt;</code>Header<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"images/foo.jpg"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"foo master"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>Some<code class="w"> </code>text<code class="w"> </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"foo.html"</code><code class="nt">&gt;</code>with<code class="w"> </code>a<code class="w"> </code>link<code class="nt">&lt;/a&gt;</code><code class="w"> </code>and<code class="w"> </code>more<code class="w"> </code>text<code class="w"/>&#13;
<code class="nt">&lt;/aside&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This markup is similar to the previous code example, except in this example we’ve added a link within the non-empty text node. In this case, we are creating five flex items illustrated in <a data-type="xref" href="#display_flex_five_items">Figure 11-37</a>. The comment and whitespace-only text nodes are ignored. The header, the image, the text node before the link, the link, and the text node after the link are all flex items.</p>&#13;
&#13;
<figure><div class="figure" id="display_flex_five_items">&#13;
<img alt="" src="assets/css5_1137.png"/>&#13;
<h6><span class="label">Figure 11-37. </span>Five flex items in an aside <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-in-aside.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The text <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="anonymous" data-type="indexterm" id="idm45176076971664"/><a data-primary="text nodes" data-secondary="in flex items" data-secondary-sortas="flex items" data-type="indexterm" id="idm45176076970480"/>nodes containing “Some text” and “and more text” are wrapped&#13;
in anonymous flex items, represented in <a data-type="xref" href="#display_flex_five_items">Figure 11-37</a> by the dashed boxes (the dashes having been added for illustrative purposes) with no background. The&#13;
header, image, and link, being actual DOM nodes, can be styled directly with CSS, as you can see with the border styling. The anonymous flex containers are not directly targetable, and so will have only whatever styles they pick up from the flex container.</p>&#13;
&#13;
<p>Additionally, <code>vertical-align</code> has no <a data-primary="vertical-align property" data-secondary="flex items" data-type="indexterm" id="idm45176076967184"/><a data-primary="vertical formatting" data-secondary="alignment setting" data-type="indexterm" id="idm45176076966176"/><a data-primary="alignment" data-secondary="vertical" data-type="indexterm" id="idm45176076962608"/>effect on a flex item, except as it affects the alignment of text within the flex item.  Setting <code>vertical-align: bottom</code> on a flex item will make all the text inside that flex item align to the bottom of their line boxes; it will not push the flex item to the bottom of its container.  (That’s what <code>align-items</code> and <code>align-self</code> are for.)<a data-primary="" data-startref="ix_flex_item_feat" data-type="indexterm" id="idm45176076960368"/><a data-primary="" data-startref="ix_flex_margin2" data-type="indexterm" id="idm45176076959520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Absolute Positioning" data-type="sect2"><div class="sect2" id="flex_absolute-positioning">&#13;
<h2>Absolute Positioning</h2>&#13;
&#13;
<p>While <code>float</code> will not actually float a flex item,&#13;
setting <code>position: absolute</code> is a different story. <a data-primary="absolute positioning" data-secondary="flex items" data-type="indexterm" id="idm45176076956224"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="absolute positioning" data-type="indexterm" id="idm45176076955216"/>The&#13;
absolutely positioned children of flex containers, just like any other&#13;
absolutely positioned element, are taken out of the flow of the&#13;
document.</p>&#13;
&#13;
<p>More to the point, they do not participate in flex layout and are not part of the document flow. However, they can be&#13;
impacted by the styles set on the flex container, just as a child&#13;
can be impacted by a parent element that isn’t a flex container. In addition to inheriting any inheritable properties, the flex container’s properties can affect the origin of the positioning.</p>&#13;
&#13;
<p>The absolutely positioned child of a flex container is affected by both&#13;
the <code>justify-content</code> value of the flex container and its own&#13;
<code>align-self</code> value, if there is one. For example, if you set&#13;
<code>align-self: center</code> on the absolutely positioned child, it will start out&#13;
centered with respect to the flex container parent’s cross-axis. From there, the element or pseudo-element can be moved by properties like <code>top</code>, <code>bottom</code>, margins, and so on.</p>&#13;
&#13;
<p>The <code>order</code> property<a data-primary="order property" data-type="indexterm" id="idm45176076950032"/> (explained in <a data-type="xref" href="#the-order-property">“The order Property”</a>) may not impact where the absolutely positioned flex&#13;
container child is drawn, but it does impact the order in which it is&#13;
drawn in relation to its siblings.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Minimum Widths" data-type="sect2"><div class="sect2" id="min-width">&#13;
<h2>Minimum Widths</h2>&#13;
&#13;
<p>In <a data-type="xref" href="#three-vals-flex-wrap">Figure 11-38</a>, you’ll note that the <a data-primary="min-width property" data-type="indexterm" id="ix_min_width_prop2"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="minimum widths" data-type="indexterm" id="ix_flex_items_min_width"/>flex line inside the container with the <code>nowrap</code> default <code>flex-wrap</code> value overflows its flex container. This is because when it comes to flex&#13;
items, the implied value of <code>min-width</code> is <code>auto</code>, rather than <code>0</code>.&#13;
Originally in the specification, if the items didn’t fit onto that&#13;
single main-axis, they would shrink. However, the specification of&#13;
<code>min-width</code> was altered as applied to flex items. (Traditionally,&#13;
the default value for &#13;
<span class="keep-together"><code>min-width</code></span> is <code>0</code>.)</p>&#13;
&#13;
<figure><div class="figure" id="three-vals-flex-wrap">&#13;
<img alt="Flex items overflowing their container when min-width defaults to auto, unless wrapping is allowed" src="assets/css5_1138.png"/>&#13;
<h6><span class="label">Figure 11-38. </span>Flex container overflow with minimum-width flex items <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-container-overflow-with-min-width.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>If you set <code>min-width</code> to a width narrower than the computed value&#13;
of <code>auto</code>—for example, if you declare <code>min-width: 0</code>—the flex items&#13;
in the <code>nowrap</code> example will shrink to be narrower than their actual content (in some cases).  If the items are allowed to wrap, they will be as narrow as possible to fit their content, but no narrower. <a data-type="xref" href="#three-vals-min-width-0">Figure 11-39</a> illustrates &#13;
<span class="keep-together">both situations.</span></p>&#13;
&#13;
<figure><div class="figure" id="three-vals-min-width-0">&#13;
<img alt="Flex items in nonwrapping containers will shrink if the min-width is explicitly set to 0, which is the default in Safari 9" src="assets/css5_1139.png"/>&#13;
<h6><span class="label">Figure 11-39. </span>Zero-minimum-width flex items in nonwrapped and wrapped &#13;
<span class="keep-together">flex containers</span> <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-zero-min-width-flex-items.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flex-Item-Specific Properties" data-type="sect1"><div class="sect1" id="flex-item-specific">&#13;
<h1>Flex-Item-Specific Properties</h1>&#13;
&#13;
<p>While <a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="individually applied properties" data-type="indexterm" id="ix_flex_items_props"/>flex items’ alignment, order, and flexibility are to some extent&#13;
controllable via properties set on their flex container, several properties can be applied to individual flex items for&#13;
more granular control.</p>&#13;
&#13;
<p>The <code>flex</code> shorthand <a data-primary="flex property" data-type="indexterm" id="ix_flex_prop"/>property, along with its component properties of&#13;
<code>flex-grow</code>, <code>flex-shrink</code>, and <code>flex-basis</code>, controls the flexibility of&#13;
the flex items.  <em>Flexibility</em> is the amount by which a flex item can grow or shrink along the main-axis.<a data-primary="" data-startref="ix_flex_items_min_width" data-type="indexterm" id="idm45176076919488"/><a data-primary="" data-startref="ix_min_width_prop2" data-type="indexterm" id="idm45176076918512"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The flex Property" data-type="sect2"><div class="sect2" id="flex">&#13;
<h2>The flex Property</h2>&#13;
&#13;
<p>The defining aspect of flex layout is the ability to make the flex items&#13;
<em>flex</em>: altering their width or height to fill the available space in&#13;
the main dimension. A flex container distributes free space to its items&#13;
proportionally to their flex grow factor, or shrinks them to prevent&#13;
overflow proportionally to their flex shrink factor.  (We’ll explore these concepts momentarily.)</p>&#13;
&#13;
<p>Declaring the <code>flex</code> shorthand property on a flex item, or defining the&#13;
individual properties that make up the shorthand, enables you to&#13;
define the grow and shrink factors. If there is excess space, you can&#13;
tell the flex items to grow to fill that space. Or not. If there isn’t&#13;
enough room to fit all the flex items within the flex container at their&#13;
defined or default sizes, you can tell the flex items to shrink&#13;
proportionally to fit into the space. Or not.</p>&#13;
&#13;
<p>This is all done with the&#13;
<code>flex</code> property, which is a shorthand property for <code>flex-grow</code>,&#13;
<code>flex-shrink</code>, and <code>flex-basis</code>. While these three subproperties can be&#13;
used separately, it is highly recommended to always use the <code>flex</code>&#13;
shorthand, for reasons we’ll soon cover.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176076911392">&#13;
<h1>flex</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>flex-grow</code></em>&gt; &lt;<em><code>flex-shrink</code></em>&gt;? ‖ &lt;<em><code>flex-basis</code></em>&gt; ] | <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0 1 auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex items (children of flex containers)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Valid for <code>flex-basis</code> value only, relative to element’s parent’s inner main-axis size</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Refer to individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>flex</code> property specifies the components of a flexible length: the <em>length</em> of the flex item being the length of the flex item along the&#13;
main-axis (see <a data-type="xref" href="#understanding-axis">“Understanding Axes”</a>). When a box&#13;
is a flex item, <code>flex</code> is consulted to determine the size of the box, instead of the main-axis size dimension property (<code>height</code> or <code>width</code>).&#13;
The <em>components</em> of the <code>flex</code> property include the flex growth factor,&#13;
flex shrink factor, and the flex basis.</p>&#13;
&#13;
<p>The <em>flex basis</em> determines<a data-primary="flex-basis property" data-type="indexterm" id="idm45176076889184"/> how the flex growth and shrink factors are&#13;
implemented. As its name suggests, the <code>flex-basis</code> component of the flex&#13;
shorthand is the basis on which the flex item determines how much it can&#13;
grow to fill available space or how much it should shrink to fit all the&#13;
flex items when there isn’t enough space. It’s the initial size of each&#13;
flex item, and can be restricted to that specific size by specifying <code>0</code>&#13;
for both the growth and shrink factors:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.flexItem</code> <code class="p">{</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code>&#13;
    <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">200px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the preceding CSS, the flex item will have a main-axis size of&#13;
exactly 200 pixels, as the flex basis is <code>200px</code>, and it is allowed to neither&#13;
grow nor shrink.  Assuming that the main-axis is horizontal, the value of <code>width</code> (<code>50%</code>) is ignored.  Similarly, a value for <code>height</code> would be ignored if the main-axis were vertical.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This override of <code>height</code> and <code>width</code> occurs outside the cascade, so you can’t even override the flex basis by adding <code>!important</code> to the <code>height</code> or <code>width</code> value of a flex item.</p>&#13;
</div>&#13;
&#13;
<p>If the target of a selector is not a flex item, applying the <code>flex</code> property to it will have no effect.</p>&#13;
&#13;
<p>It is important to understand the three components that make up the&#13;
<code>flex</code> shorthand property in order to be able to use it effectively.<a data-primary="" data-startref="ix_flex_prop" data-type="indexterm" id="idm45176076858704"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The flex-grow Property" data-type="sect2"><div class="sect2" id="flex-grow">&#13;
<h2>The flex-grow Property</h2>&#13;
&#13;
<p>The <code>flex-grow</code> property<a data-primary="flex-grow property" data-type="indexterm" id="ix_flex_grow_prop"/> defines whether a flex item is allowed to grow&#13;
when space is available, and, if so, how much it will grow proportionally relative to the&#13;
growth of other flex-item siblings.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Declaring the growth factor<a data-primary="growth factor, flex box layout" data-type="indexterm" id="idm45176076852944"/> via the <code>flex-grow</code> property is <em>strongly</em> discouraged by the authors of the specification itself.  Instead, declare the&#13;
growth factor as part of the <code>flex</code> shorthand.  We’re discussing the property here only to explore how growth works.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176076850480">&#13;
<h1>flex-grow</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex items (children of flex containers)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The value of <code>flex-grow</code> is always a number. Negative numbers are not valid. You can use non-integers if you like, just as long as they’re 0 or greater.&#13;
The value sets the <em>flex growth factor</em>, which determines how much the&#13;
flex-item will grow relative to the rest of the flex item siblings as&#13;
the flex container’s free space is distributed.</p>&#13;
&#13;
<p>If any space is available within the flex container, the space will be distributed&#13;
proportionally among the children with a nonzero positive growth factor&#13;
based on the various values of those growth factors.</p>&#13;
&#13;
<p>For example, assume a <code>750px</code>-wide horizontal flex container with three&#13;
flex items, each set to <code>width: 100px</code>. A total of 300 pixels of space is taken up by the flex items, leaving 450 pixels of “leftover” or available space (since 750 – 300 = 450).  This is the first scenario shown in <a data-type="xref" href="#variety_of_growth_factor_scenarios">Figure 11-40</a>: none of the flex items are permitted to grow.</p>&#13;
&#13;
<figure><div class="figure" id="variety_of_growth_factor_scenarios">&#13;
<img alt="With a growth factor of 0, the flex item will not grow; any positive value will allow the item to grow proportionally to the value" src="assets/css5_1140.png"/>&#13;
<h6><span class="label">Figure 11-40. </span>A variety of flex-growth scenarios <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-variety.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>In the second scenario in <a data-type="xref" href="#variety_of_growth_factor_scenarios">Figure 11-40</a>, only one of the flex items (the third) has been given a growth factor.  The declaration we gave it is <code>flex-grow: 1</code>, but it could be any positive number the browser can understand.  In this case, with two items having no growth factor and the third having a growth factor, all of the available space is given to the flex item with a growth factor.  Thus, the third flex item gets all 450 pixels of available space added to it, arriving at a final width of 550 pixels.  The <code>width: 100px</code> applied to it elsewhere in the styles is overridden.</p>&#13;
&#13;
<p>In the third and fourth scenarios, the same flex item widths result despite the differing flex growth factors.  Let’s consider the third scenario, where the growth factors are 1, 1, and 3.  The factors are all added together to get a total of 5.  Each factor is then divided by that total to get a proportion.  So here, the three values are each divided by 5, yielding 0.2, 0.2, and 0.6.</p>&#13;
&#13;
<p>Each proportion is multiplied by the available space to get the amount of growth.  Thus:</p>&#13;
<ol>&#13;
<li>&#13;
<p>450 px × 0.2 = 90 px</p>&#13;
</li>&#13;
<li>&#13;
<p>450 px × 0.2 = 90 px</p>&#13;
</li>&#13;
<li>&#13;
<p>450 px × 0.6 = 270 px</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Those are the growth portions added to each flex item’s starting width of 100 pixels.  Thus, the final widths are 190 pixels, 190 pixels, and 370 pixels, respectively.</p>&#13;
&#13;
<p>The fourth scenario has the same result, because the proportions are the same.  Imagine for a moment that we alter the growth factors to be 0.5, 1, and 1.5.  Now the math works out such that the first flex item gets one-sixth of the available space, the second gets a third, and the third gets half.  This results in the flex items’ final widths being 175, 250, and 425 pixels, respectively.  Had we declared growth factors of 0.1, 0.1, and 0.3, or 25, 25, and 75, or really any combination of numbers with a 1:1:3 correspondence, the result would have been identical.</p>&#13;
&#13;
<p>As noted in <a data-type="xref" href="#min-width">“Minimum Widths”</a>, if no width or flex basis is set, the flex basis defaults to <code>auto</code>,&#13;
meaning each flex item basis is the width of its nonwrapped content.&#13;
The <code>auto</code> value is special: <a data-primary="content keywords" data-type="indexterm" id="idm45176076803488"/>it defaults to <code>content</code> unless the item has a&#13;
width set on it, at which point the flex basis becomes that width. The&#13;
<code>auto</code> value is discussed in <a data-type="xref" href="#auto">“Automatic flex basis”</a>. Had we not set&#13;
the width in this example scenario, with our smallish font size, we&#13;
would have had more than 450 pixels of distributable space along the main-axis.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The main-axis size of a flex item is impacted by the available space, the&#13;
growth factor of all the flex items, and the flex basis of the&#13;
item. We have yet to cover <a href="#flex-basis">flex basis</a>, but that time is coming soon!</p>&#13;
</div>&#13;
&#13;
<p>Now let’s consider flex items with different <code>width</code> values as well as different growth factors. In <a data-type="xref" href="#even-dist-avail-space">Figure 11-41</a>, in the second example, we have flex items that are 100 pixels, 250 pixels, and 100 pixels wide, with growth factors of 1, 1, and 3, respectively, in a container that is 750 pixels wide. This means we have 300 pixels of extra space&#13;
to distribute among a total of five growth factors (since 750 – 450 = 300).&#13;
Each growth factor is therefore 60 pixels (300 ÷ 5).&#13;
Therefore, the first and second flex items, with a <code>flex-grow</code>&#13;
value of <code>1</code>, will each grow by 60 pixels.  The last flex item will grow by 180 pixels, since its <code>flex-grow</code> value is <code>3</code>.</p>&#13;
&#13;
<figure><div class="figure" id="even-dist-avail-space">&#13;
<img alt="The available space is evenly distributed to each growth factor; any positive value will allow the item to grow proportionally to the value." src="assets/css5_1141.png"/>&#13;
<h6><span class="label">Figure 11-41. </span>Mixed widths and growth factors <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-mixed-width-and-factors.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>To recap, the available space in the flex container, the growth factors, and final width of each flex item are as follows:</p>&#13;
<ul class="simplelist">&#13;
<li>Available space: 750 px – (100 px + 250 px + 100 px) = 300 px</li>&#13;
<li>Growth factors:  1 + 1 + 3 = 5</li>&#13;
<li>Width of each growth factor: 300 px ÷ 5 = 60 px</li>&#13;
</ul>&#13;
&#13;
<p>When flexed, the width of the flex items, based on their original width and growth factors, become</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 100 px + (1 × 60 px) = 160 px</li>&#13;
<li>item2 = 250 px + (1 × 60 px) = 310 px</li>&#13;
<li>item3 = 100 px + (3 × 60 px) = 280 px</li>&#13;
</ul>&#13;
&#13;
<p>which adds up to 750 pixels.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Growth Factors and the flex Property" data-type="sect2"><div class="sect2" id="growth-factors-and-the-flex-property">&#13;
<h2>Growth Factors and the flex Property</h2>&#13;
&#13;
<p>The <code>flex</code> property<a data-primary="growth factor, flex box layout" data-type="indexterm" id="ix_grow_factor"/> takes up to three values—the growth factor, shrink&#13;
factor, and basis. The first positive non-null numeric value, if there is&#13;
one, sets the growth factor (i.e., the <code>flex-grow</code> value).&#13;
When the growth and shrink factors are omitted in the <code>flex</code> value, the growth factor defaults to <code>1</code>.&#13;
However, if neither <code>flex</code> nor <code>flex-grow</code> is declared, the growth factor defaults to <code>0</code>.  Yes, really.</p>&#13;
&#13;
<p>Recall the second example in <a data-type="xref" href="#variety_of_growth_factor_scenarios">Figure 11-40</a>, where the flex growth factors were 0, 0, and 1.&#13;
Because we declared a value for <code>flex-grow</code> only, the <a data-primary="flex-basis property" data-secondary="growth factors and" data-type="indexterm" id="ix_flex_basis_prop"/>flex&#13;
basis was set to <code>auto</code>, as if we had declared the following:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="css" data-type="programlisting"><code class="nf">#example2</code> <code class="nt">flex-item</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nf">#example2</code> <code class="nt">flex-item</code><code class="nd">:last-child</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">1</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-primary="shrink factor, for flexbox layout" data-type="indexterm" id="idm45176076755712"/>So that means the first two flex items had no growth factor, a shrink factor, and a flex basis of <code>auto</code>.  Had we used <code>flex</code> in the examples in <a data-type="xref" href="#variety_of_growth_factor_scenarios">Figure 11-40</a> instead of ill-advisedly using <code>flex-grow</code>, the flex basis in each case&#13;
would be set to <code>0%</code>, as if this had been done:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example2</code> <code class="nt">flex-item</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">0%</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nf">#example2</code> <code class="nt">flex-item</code><code class="nd">:last-child</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">1</code> <code class="m">0%</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As the shrink factor defaults to <code>1</code> and the basis defaults to <code>0%</code>, the&#13;
following CSS is identical to the preceding snippet:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example2</code> <code class="nt">flex-item</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nf">#example2</code> <code class="nt">flex-item</code><code class="nd">:last-child</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This would have the result shown in <a data-type="xref" href="#flex_basis_is_0">Figure 11-42</a>.  Compare this to <a data-type="xref" href="#variety_of_growth_factor_scenarios">Figure 11-40</a> to see how things have changed (or not).</p>&#13;
&#13;
<p>You may notice something odd in the first two scenarios: the flex basis been set to 0, and only the last flex item in the second scenario has a positive value for flex growth. Logic would seem to dictate that the widths of the three flex items should be 0, 0, and 750 pixels, respectively. But logic would also dictate that it makes no sense to have content overflowing its flex item if the flex container has the room for all the content, even if the basis is set to <code>0</code>.</p>&#13;
&#13;
<p>The specification authors thought of this quandary. When the <code>flex</code>&#13;
property declaration explicitly sets or defaults the flex basis to <code>0%</code>&#13;
and a flex item’s growth factor is <code>0</code>, the length of the main-axis of&#13;
the nongrowing flex items will shrink to the smallest length the content&#13;
allows, or smaller. In <a data-type="xref" href="#flex_basis_is_0">Figure 11-42</a>, that minimum length is the width of the widest sequence of letters, “flex:” (including the colon).</p>&#13;
&#13;
<p>As long as a flex item has a visible overflow and no explicitly set value for&#13;
<code>min-width</code> (or <code>min-height</code> for vertical main-axes), the minimum width (or&#13;
minimum height) will be the smallest width (or height) that the flex item&#13;
needs to be to fit the content or the declared <code>width</code> (or <code>height</code>),&#13;
whichever is smaller.</p>&#13;
&#13;
<figure><div class="figure" id="flex_basis_is_0">&#13;
<img alt="Flex grow looks different when the flex basis is 0, and some items are not allowed to grow" src="assets/css5_1142.png"/>&#13;
<h6><span class="label">Figure 11-42. </span>Flex sizing when using the flex shorthand <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-sizing-when-using-shorthand.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>If all items are allowed to grow, and the flex basis for each flex item&#13;
is <code>0%</code>, <em>all</em> of the space, rather than just excess&#13;
space, is distributed proportionally based on the growth factors.&#13;
In the third example in <a data-type="xref" href="#flex_basis_is_0">Figure 11-42</a>,&#13;
two flex items have growth factors of 1, and one flex item has a growth factor of 3.  We thus have a total of five growth factors:</p>&#13;
<ul class="simplelist">&#13;
<li>(2 × 1) + (1 × 3) = 5</li>&#13;
</ul>&#13;
&#13;
<p>With five growth factors, and a total of 750 pixels, each growth factor is worth 150 <span class="keep-together">pixels:</span></p>&#13;
<ul class="simplelist">&#13;
<li>750 px ÷ 5 = 150 px</li>&#13;
</ul>&#13;
&#13;
<p>While the default flex item size is 100 pixels, the flex basis of <code>0%</code> overrides that, leaving us with two flex items at 150 pixels each and the last flex item with a width of 450 pixels:</p>&#13;
<ul class="simplelist">&#13;
<li>1 × 150 px = 150 px</li>&#13;
<li>3 × 150 px = 450 px</li>&#13;
</ul>&#13;
&#13;
<p>Similarly, in the last example of <a data-type="xref" href="#flex_basis_is_0">Figure 11-42</a>, with two flex items having&#13;
growth factors of 0.5, and one flex item having a growth factor of 1.5,&#13;
we have a total of 2.5 growth factors:</p>&#13;
<ul class="simplelist">&#13;
<li>(2 × 0.5) + (1 × 1.5) = 2.5</li>&#13;
</ul>&#13;
&#13;
<p>With a 2.5 growth factor, and a total of 750 pixels, each growth factor is&#13;
worth 300 <span class="keep-together">pixels:</span></p>&#13;
<ul class="simplelist">&#13;
<li>750 px ÷ 2.5 = 300 px</li>&#13;
</ul>&#13;
&#13;
<p>While the default flex item size is 100 pixels, the flex basis of 0%&#13;
overrides that, leaving us with two flex items at 150 pixels each and the&#13;
last flex item with a width of 450 pixels:</p>&#13;
<ul class="simplelist">&#13;
<li>0.5 × 300 px = 150 px</li>&#13;
<li>1.5 × 300 px = 450 px</li>&#13;
</ul>&#13;
&#13;
<p>Again, this is different from declaring only <code>flex-grow</code>, because that means the flex basis defaults to <code>auto</code>. In that case, only the extra space, not all the space, is distributed&#13;
proportionally.  When using <code>flex</code>, on the other hand, the flex basis is set to <code>0%</code>, so the flex items grow in proportion to the total space, not just the leftover space. <a data-type="xref" href="#flex-grow-basis-0">Figure 11-43</a> illustrates the difference.</p>&#13;
&#13;
<figure><div class="figure" id="flex-grow-basis-0">&#13;
<img alt="Flex grow looks different when the flex basis is 0, and sometimes are not allowed to grow" src="assets/css5_1143.png"/>&#13;
<h6><span class="label">Figure 11-43. </span>Flex sizing differences between using <code>flex</code> and <code>flex-grow</code> <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-differences-between-flex-and-flex-grow.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s talk about flex&#13;
shrinking factors, which are in some ways the inverse of flex growth factors, but are in other ways different.<a data-primary="" data-startref="ix_flex_grow_prop" data-type="indexterm" id="idm45176076596656"/><a data-primary="" data-startref="ix_flex_basis_prop" data-type="indexterm" id="idm45176076595744"/><a data-primary="" data-startref="ix_grow_factor" data-type="indexterm" id="idm45176076594800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="The flex-shrink Property" data-type="sect2"><div class="sect2" id="flex-shrink">&#13;
<h2>The flex-shrink Property</h2>&#13;
&#13;
<p>The &lt;<em><code>flex-shrink</code></em>&gt; portion<a data-primary="shrink factor, for flexbox layout" data-type="indexterm" id="ix_shrink_factor_flex"/><a data-primary="flex-shrink property" data-type="indexterm" id="ix_flex_shrink_prop"/> of the <code>flex</code> shorthand property specifies the <em>flex shrink</em> &#13;
<span class="keep-together"><em>factor</em>.</span>  It can also be set via the <code>flex-shrink</code> property.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Declaring the shrink factor via the <code>flex-shrink</code> property is <em>strongly</em> discouraged by the authors of the specification itself.  Instead, declare the&#13;
shrink factor as part of the <code>flex</code> shorthand.  We’re discussing the property here only to explore how shrinking works.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176076583920">&#13;
<h1>flex-shrink</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex items (children of flex containers)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The shrink factor determines how much a flex item&#13;
will shrink relative to the rest of its flex-item siblings when there&#13;
isn’t enough space for them all to fit, as defined by their content and&#13;
other CSS properties. When omitted in the shorthand <code>flex</code> property value or when both <code>flex</code>&#13;
and <code>flex-shrink</code> are omitted, the shrink factor defaults to <code>1</code>. Like the&#13;
growth factor, the value of <code>flex-shrink</code> is always a number. Negative numbers are not valid. You can use non-integer values if you like, just as long as they’re greater than 0.</p>&#13;
&#13;
<p>Basically, the shrink factor defines how&#13;
“negative available space” is distributed when there isn’t enough room for the flex items, and the flex container isn’t allowed to&#13;
otherwise grow or wrap. See <a data-type="xref" href="#flex-shrink-0">Figure 11-44</a>.</p>&#13;
&#13;
<p><a data-type="xref" href="#flex-shrink-0">Figure 11-44</a> is similar to <a data-type="xref" href="#variety_of_growth_factor_scenarios">Figure 11-40</a>, except the&#13;
flex items are set to <code>width: 300px</code> instead of 100 pixels. We still have a 750-pixel-wide flex&#13;
container. The total width of the three&#13;
items is 900 pixels, meaning the content starts out 150 pixels wider than the parent flex&#13;
container. If the items are not allowed to shrink or&#13;
wrap (see <a data-type="xref" href="#the-flex-wrap-property">“Wrapping Flex Lines”</a>), they will burst out from the&#13;
fixed-size flex container. This is demonstrated in the first example in&#13;
<a data-type="xref" href="#flex-shrink-0">Figure 11-44</a>: those items will not shrink because they have a zero shrink factor.&#13;
Instead, they overflow the flex container.</p>&#13;
&#13;
<figure><div class="figure" id="flex-shrink-0">&#13;
<img alt="A flex shrink factor of 0 will not allow flex items to shrink; any positive value will enable the item to shrink proportionally relative to sibling flex items that are allowed to shrink on the same flex line" src="assets/css5_1144.png"/>&#13;
<h6><span class="label">Figure 11-44. </span>A variety of flex shrinking scenarios <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-variety.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>In the second example in <a data-type="xref" href="#flex-shrink-0">Figure 11-44</a>, only the last flex item is set to be&#13;
able to shrink.&#13;
The last flex item is thus forced to do all the shrinking necessary to enable all the flex items to&#13;
fit within the flex container. With 900 pixels of content needing to fit&#13;
into our 750-pixel container, we have 150 pixels of negative available space. The two flex items with no shrink factor stay at 300 pixels wide. The third flex item,&#13;
with a positive value for the shrink factor, shrinks 150&#13;
pixels, to end up 150 pixels wide.  This enables the three items to fit within the&#13;
container. (In this example, the shrink factor is <code>1</code>, but had it been&#13;
<code>0.001</code> or <code>100</code> or <code>314159.65</code> or any other positive number the browser could understand, the result would be the same.)</p>&#13;
&#13;
<p>In the third example, we have positive shrink factors for all three&#13;
flex items:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example3</code> <code class="nt">flex-item</code> <code class="p">{</code>&#13;
  <code class="nb">flex</code><code class="o">-</code><code class="n">shrink</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nf">#example3</code> <code class="nt">flex-item</code><code class="nd">:last-child</code> <code class="p">{</code>&#13;
  <code class="nb">flex</code><code class="o">-</code><code class="n">shrink</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As this is the only one of the three <code>flex</code> shorthand properties we declared, this means the flex items will behave as if we had declared the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example3</code> <code class="nt">flex-item</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="nb">auto</code><code class="p">;</code> <code class="c">/* growth defaults to 0, basis to auto */</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">f</code><code class="nf">#example3</code> <code class="nt">flex-item</code><code class="nd">:last-child</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">3</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If all items are allowed to shrink, as is the case here, the shrinking&#13;
is distributed proportionally based on the shrink factors.&#13;
This means the larger a flex item’s shrink factor, as compared to the shrink factors of its sibling flex items, the more the item will shrink in comparison.</p>&#13;
&#13;
<p>With a parent&#13;
750 pixels wide, and three flex items with a width of 300 pixels, 150&#13;
“negative space” pixels need to be shaved off the flex items that are&#13;
allowed to shrink (which is all of them in this example).&#13;
With two flex items having a shrink factor of 1, and&#13;
one flex item having a shrink factor of 3, we have a total of five&#13;
shrink factors:</p>&#13;
<ul class="simplelist">&#13;
<li>(2 × 1) + (1 × 3) = 5</li>&#13;
</ul>&#13;
&#13;
<p>With five shrink factors, and a total of 150 pixels needing to be shaved off all&#13;
the flex items, each shrink factor is worth 30 pixels:</p>&#13;
<ul class="simplelist">&#13;
<li>150 px ÷ 5 = 30 px</li>&#13;
</ul>&#13;
&#13;
<p>The default flex item size is 300 pixels, leading us to have two flex items&#13;
with a width of 270 pixels each and the last flex item having a width of&#13;
210 pixels, which totals 750 pixels:</p>&#13;
<ul class="simplelist">&#13;
<li>300 px – (1 × 30 px) = 270 px</li>&#13;
<li>300 px – (3 × 30 px) = 210 px</li>&#13;
</ul>&#13;
&#13;
<p>The following CSS produces the same outcome: while the numeric representations of the shrink factors are&#13;
different, they are proportionally the same, so the flex item widths will be the same:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">flex-item</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">0</code><code class="o">.</code><code class="m">25</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">flex-item</code><code class="nd">:last-child</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">0</code><code class="o">.</code><code class="m">75</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that the flex items in these examples will shrink to 210, 210, and 270 pixels, respectively, <em>as&#13;
long as</em> the content (like media objects or nonwrappable text) within&#13;
each flex item is not wider than 210, 210, or 270 pixels, respectively.&#13;
If the flex item contains content that cannot&#13;
wrap or otherwise shrink in the main dimension, the flex item will not&#13;
shrink any further.</p>&#13;
&#13;
<p>Suppose that the first flex items contain an image 300 pixels wide.&#13;
That first flex item cannot shrink, and&#13;
other flex items can shrink; therefore, it will not shrink, as if it had&#13;
a null shrink factor.&#13;
In this case, the first item would be 300 pixels, with the 150 pixels of negative&#13;
space distributed proportionally based on the shrink factors of the&#13;
second and third flex items.</p>&#13;
&#13;
<p>That being the case, we have four unimpeded shrink factors (one from the second flex item, and three from the third) for 150 pixels of&#13;
negative space, with each shrink factor being worth 37.5 pixels. The flex&#13;
items will end up 300, 262.5, and 187.5 pixels, respectively, for a total of 750 pixels, as shown here and illustrated in <a data-type="xref" href="#flex-shrink-with-image">Figure 11-45</a>:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 300 px – (0 × 37.5 px) = 300.0 px</li>&#13;
<li>item2 = 300 px – (1 × 37.5 px) = 262.5 px</li>&#13;
<li>item3 = 300 px – (3 × 37.5 px) = 187.5 px</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="flex-shrink-with-image">&#13;
<img alt="" src="assets/css5_1145.png"/>&#13;
<h6><span class="label">Figure 11-45. </span>Shrinking being impeded by flex-item content <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-with-image.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Had the image been 296 pixels wide, that first&#13;
flex item would have been able to shrink by 4 pixels. The remaining 146 pixels of negative space&#13;
would then be distributed among the four remaining factors, yielding 36.5 pixels per factor.&#13;
The flex items would then be 296, 263.5, and 190.5 pixels wide, respectively.</p>&#13;
&#13;
<p>If all three flex items contained nonwrappable text or media 300 pixels or&#13;
wider, none of the three flex items would not shrink, appearing similar to the&#13;
first example in <a data-type="xref" href="#flex-shrink-0">Figure 11-44</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Proportional shrinkage based on width and shrink factor" data-type="sect3"><div class="sect3" id="proportional-based-on-width-and-shrink-factor">&#13;
<h3>Proportional shrinkage based on width and shrink factor</h3>&#13;
&#13;
<p>The <a data-primary="flex-shrink property" data-secondary="proportional shrinkage" data-type="indexterm" id="idm45176076411712"/>preceding code examples are fairly simple because all the flex items start with the same&#13;
width. But what if the widths are different? What if the first and last&#13;
flex items have a width of 250 pixels and the middle flex item has a width of&#13;
500 pixels, as shown in <a data-type="xref" href="#flex-items-shrink-factor">Figure 11-46</a>?</p>&#13;
&#13;
<figure><div class="figure" id="flex-items-shrink-factor">&#13;
<img alt="Flex items shrink proportionally relative to their shrink factor" src="assets/css5_1146.png"/>&#13;
<h6><span class="label">Figure 11-46. </span>Flex items shrink proportionally relative to their shrink factor <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Flex items shrink proportionally relative to both the shrink factor <em>and</em>&#13;
the flex item’s width, with the width often being the width of the flex item’s content with no wrapping. In <a data-type="xref" href="#flex-items-shrink-factor">Figure 11-46</a>, we are trying to fit 1,000 pixels into a flex container that’s 750 pixels wide. We have an excess of 250 pixels to be removed from&#13;
five shrink factors.</p>&#13;
&#13;
<p>If this were a <code>flex-grow</code> situation, we would simply&#13;
divide 250 pixels by 5, allocating 50 pixels per growth factor.&#13;
If we were to shrink that way, we would get flex items 200, 550, and 100 pixels&#13;
wide, respectively. But that’s not how shrinking actually works.</p>&#13;
&#13;
<p>Here, we have 250 pixels of negative space to proportionally distribute. To get the&#13;
shrink factor proportions, we divide the negative space by the total of the flex items’ widths (more precisely, their lengths along the main-axis) times their shrink factors:</p>&#13;
<div data-type="equation">&#13;
<math alttext="upper S h r i n k upper P e r c e n t equals StartFraction upper N e g a t i v e upper S p a c e Over left-parenthesis left-parenthesis upper W i d t h Baseline 1 times upper S h r upper F Baseline 1 right-parenthesis plus period period period plus left-parenthesis upper W i d t h upper N times upper S h r upper F upper N right-parenthesis right-parenthesis EndFraction" display="block">&#13;
  <mrow>&#13;
    <mi>S</mi>&#13;
    <mi>h</mi>&#13;
    <mi>r</mi>&#13;
    <mi>i</mi>&#13;
    <mi>n</mi>&#13;
    <mi>k</mi>&#13;
    <mi>P</mi>&#13;
    <mi>e</mi>&#13;
    <mi>r</mi>&#13;
    <mi>c</mi>&#13;
    <mi>e</mi>&#13;
    <mi>n</mi>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>N</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi></mrow> <mrow><mo>(</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mn>1</mn><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mn>1</mn><mo>)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mi>N</mi><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mi>N</mi><mo>)</mo><mo>)</mo></mrow></mfrac>&#13;
  </mrow>&#13;
</math>&#13;
</div>&#13;
&#13;
<p>Using this equation, we find the shrink percentage:</p>&#13;
<ul class="simplelist">&#13;
<li>= 250 px ÷ [(250 px × 1) + (500 px × 1) + (250 px × 3)]</li>&#13;
<li>= 250 px ÷ 1500 px</li>&#13;
<li>= 0.166666667 (16.67%)</li>&#13;
</ul>&#13;
&#13;
<p>When we reduce each flex item by 16.67% times the value of <code>flex-shrink</code>, we end up with flex items that are reduced as follows:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 250 px × (1 × 16.67%) = 41.67 px</li>&#13;
<li>item2 = 500 px × (1 × 16.67%) = 83.33 px</li>&#13;
<li>item3 = 250 px × (3 × 16.67%) = 125 px</li>&#13;
</ul>&#13;
&#13;
<p>Each reduction is then subtracted from the starting sizes of 250, 500, and 250 pixels, respectively.  Thus we have flex items that are 208.33, 416.67, and 125 pixels wide.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Differing basis values" data-type="sect3"><div class="sect3" id="differing-bases">&#13;
<h3>Differing basis values</h3>&#13;
&#13;
<p>When the <a data-primary="flex-basis property" data-secondary="shrink factor and" data-type="indexterm" id="ix_flex_basis_shrink"/><a data-primary="flex-shrink property" data-secondary="differing basis values" data-type="indexterm" id="ix_flex_shrink_prop_basis"/>shrink factor has been set to <code>0</code>, and both the width and flex basis of a flex item&#13;
are set to <code>auto</code>, the item’s content will not wrap, even when you think it should.&#13;
Conversely, any positive shrink value enables content to wrap.&#13;
Because shrinking is proportional based on the shrink factor, if all the flex items have similar shrink factors, the content should wrap over a similar number of lines.</p>&#13;
&#13;
<p>In the three examples shown in&#13;
<a data-type="xref" href="#flex_items_shrink_proportionally">Figure 11-47</a>, the flex items do not have a declared width. Therefore, the width&#13;
is based on the content, because <code>width</code> defaults to <code>auto</code>.  The flex container has been made 520 pixels wide instead of our usual 750 pixels.</p>&#13;
&#13;
<figure><div class="figure" id="flex_items_shrink_proportionally">&#13;
<img alt="css5 1147" src="assets/css5_1147.png"/>&#13;
<h6><span class="label">Figure 11-47. </span>Flex items shrink proportionally relative to their shrink factor &#13;
<span class="keep-together">and content <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor-and-content.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></span></h6>&#13;
</div></figure>&#13;
&#13;
<p>Note that in the first example, where all the items have the same <code>flex-shrink</code> value, all content wraps over four lines.&#13;
In the second example, the first flex item has a shrink factor that’s half the&#13;
value of the other flex items, so it wraps the content over (roughly) half the number of lines. This is the power of the shrink factor.</p>&#13;
&#13;
<p>In the third example, with no shrink factor, the text doesn’t wrap at all, and the flex items overflow the container by quite a bit.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, this “line-balancing” and refusal-to-wrap behavior is not consistent across browsers.  If you see different results when trying this out for yourself, that may be why.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Because the <code>flex</code> property’s shrink factor reduces the width of flex&#13;
items proportionally, the number of lines of text in the flex items will&#13;
grow or shrink as the width shrinks or grows, leading to similar height&#13;
content within sibling flex items when the shrink factors are similar.</p>&#13;
&#13;
<p>In the examples, take the contents of the flex items to be 280,&#13;
995, and 480 pixels, respectively—which are the widths of the nonwrapping flex items in the third example (as measured by the developer tools, then rounded&#13;
to make this example a little simpler). This means we have to fit&#13;
1,755 pixels of content into a 520-pixel-wide flex container by shrinking the&#13;
flex items proportionally based on their shrink factor.  We&#13;
have 1,235 pixels of negative available space to proportionally distribute.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that you can’t rely on web inspector tools to figure out shrink&#13;
factors for production. We’re going through this exercise to show how&#13;
shrink factors work. If minutia isn’t your thing, feel free to jump to&#13;
<a data-type="xref" href="#flex-basis">“The flex-basis Property”</a>.</p>&#13;
</div>&#13;
&#13;
<p>In our first example, the flex items will end up&#13;
with the same, or approximately the same, number of text lines.  This is&#13;
because flex items shrink proportionally, based on the width of their content.</p>&#13;
&#13;
<p>We didn’t declare any widths, and therefore can’t simply use an explicit element width as the basis for our calculations, as we did in the previous examples. Rather, we distribute the&#13;
1,235 pixels of negative space proportionally based on the widths of the&#13;
content—280, 995, and 480 pixels, respectively. We determine 520 is&#13;
29.63% of 1,755. To determine the width of each flex item with a shrink&#13;
factor of 1, we multiply the content width of each flex item by 29.63%:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 280 px × 29.63% =  83 px</li>&#13;
<li>item2 = 995 px × 29.63% = 295 px</li>&#13;
<li>item3 = 480 px × 29.63% = 142 px</li>&#13;
</ul>&#13;
&#13;
<p>With the default of <code>align-items: stretch</code> (see <a data-type="xref" href="#the-align-items-property">“Aligning Items”</a>),&#13;
a three-column layout will have three columns of equal height.&#13;
By using a consistent shrink factor for all flex items, you can indicate that&#13;
the actual content of these three flex items should be of approximately equal height—though,&#13;
by doing this, the widths of those columns will not necessarily be uniform.</p>&#13;
&#13;
<p class="pagebreak-after">In the second example in <a data-type="xref" href="#flex_items_shrink_proportionally">Figure 11-47</a>, the flex items don’t all have the same shrink&#13;
factor. The first flex item will, proportionally, shrink half as much as&#13;
the others.&#13;
We start with the same widths: 280, 995, and 480 pixels,&#13;
respectively, but their shrink factors are 0.5, 1.0, and 1.0.&#13;
Because we know the widths of the content, the shrink factor (<em>X</em>) can be found&#13;
mathematically:</p>&#13;
<ul class="simplelist">&#13;
<li>280 px + 995 px + 480 px = 1,615 px</li>&#13;
<li>(0.5 × 280 px) + (1 × 995 px) + (1 × 480 px) = 1,235 px</li>&#13;
<li><em>X</em> = 1,235 px ÷ 1,615 px = 0.7647</li>&#13;
</ul>&#13;
&#13;
<p>We can find the final widths now that we know the shrink factor. If the&#13;
shrink factor is 76.47%, <code>item2</code> and <code>item3</code> will shrink by that amount, whereas <code>item1</code> will shrink by 38.23% (because its <code>flex-shrink</code> value is half the others).  The amount of shrinkage in each case is rounded off to the nearest whole number:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 280 px × 0.3823 = 107 px</li>&#13;
<li>item2 = 995 px × 0.7647 = 761 px</li>&#13;
<li>item3 = 480 px × 0.7647 = 367 px</li>&#13;
</ul>&#13;
&#13;
<p>Thus, the final widths of the flex items are as follows:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 280 px – 107 px = 173 px</li>&#13;
<li>item2 = 995 px – 761 px = 234 px</li>&#13;
<li>item3 = 480 px – 367 px = 113 px</li>&#13;
</ul>&#13;
&#13;
<p>The total combined widths of these three flex items is 520 pixels.</p>&#13;
&#13;
<p>Adding in varying shrink and growth factors makes it all a little less&#13;
intuitive. That’s why you likely want to always declare the <code>flex</code>&#13;
shorthand, preferably with a width or basis set for each flex item.&#13;
If this doesn’t make sense yet, don’t worry; we’ll cover a few more&#13;
examples of shrinking as we discuss <code>flex-basis</code>.<a data-primary="" data-startref="ix_flex_shrink_prop_basis" data-type="indexterm" id="idm45176076311904"/><a data-primary="" data-startref="ix_flex_basis_shrink" data-type="indexterm" id="idm45176076310832"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Responsive flexing" data-type="sect3"><div class="sect3" id="responsive-flexing">&#13;
<h3>Responsive flexing</h3>&#13;
&#13;
<p>Allowing <a data-primary="responsive flexing" data-type="indexterm" id="ix_resp_flexing"/><a data-primary="flex-shrink property" data-secondary="responsive flexing" data-type="indexterm" id="ix_flex_shrink_prop_resp"/>flex items to shrink proportionally allows for&#13;
responsive objects and layouts that can shrink proportionally without&#13;
breaking. For example, you can create a three-column layout that smartly grows&#13;
and shrinks without media queries, as shown on a wide screen in <a data-type="xref" href="#set_diff_values">Figure 11-48</a> and narrow screen in <a data-type="xref" href="#set_diff_values-2">Figure 11-49</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">200px</code><code class="p">;</code>&#13;
  <code class="k">min-width</code><code class="o">:</code> <code class="m">150px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">article</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">2</code> <code class="m">600px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">aside</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">200px</code><code class="p">;</code>&#13;
  <code class="k">min-width</code><code class="o">:</code> <code class="m">150px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="set_diff_values">&#13;
<img alt="By setting different values for growth, shrink, basis, and min-width, you can create responsive layouts, with or without media queries" src="assets/css5_1148.png"/>&#13;
<h6><span class="label">Figure 11-48. </span>A wide flexbox layout</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="set_diff_values-2">&#13;
<img alt="css5 1149" src="assets/css5_1149.png"/>&#13;
<h6><span class="label">Figure 11-49. </span>A narrow flexbox layout <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-homepage.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>In this example, if the viewport is greater than 1,000 pixels, only the middle&#13;
column grows because only the middle column is provided with a positive growth factor. We also dictate that below the 1,000-pixel-wide mark, all the columns shrink.</p>&#13;
&#13;
<p>Let’s take it bit by bit.  The <code>&lt;nav&gt;</code> and <code>&lt;aside&gt;</code> elements have the following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">200px</code><code class="p">;</code>&#13;
<code class="k">min-width</code><code class="o">:</code> <code class="m">150px</code><code class="p">;</code></pre>&#13;
&#13;
<p>They don’t grow from their basis but can shrink at equal rates.  This means they’ll have the width of their flex basis by default.  If they do need to shrink, they’ll shrink to a minimum width of <code>150px</code> and then stop shrinking.  However, if either one has an element that’s more than 150 pixels wide, whether it’s an image or a run of text, it will stop shrinking as soon as it reaches the width of that bit of content.  Suppose a 180-pixel image dropped into the <code>&lt;aside&gt;</code> element.  It would stop shrinking as soon as it reaches 180 pixels wide.  The <code>&lt;nav&gt;</code> would keep shrinking down to 150 pixels.</p>&#13;
&#13;
<p>The <code>&lt;main&gt;</code> element, on the other hand, has these styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">2</code> <code class="m">600px</code><code class="p">;</code></pre>&#13;
&#13;
<p>Thus, the <code>&lt;main&gt;</code> element can grow if there’s space for it to do so.  Since it’s the only flex item that can grow, it gets all the growth. Given a browser window 1,300 pixels wide, the two side columns will be 200 pixels wide each, leaving 900 pixels of width for the center column.  In shrinking situations, the center column will shrink twice as fast as the other two elements.  Thus, if the browser window is 900 pixels wide, each side column will be 175 pixels wide, and the center column 550 pixels wide.</p>&#13;
&#13;
<p>Once the window reaches 800 pixels wide, the side columns will reach their <code>min-width</code> values of <code>150px</code>.  From then on, any narrowing will be taken up by the center column.</p>&#13;
&#13;
<p>Just to be clear, you are not required to use pixels in these situations. You don’t even have to use the same unit measures for various flex basis values.  The previous example could be rewritten like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">20ch</code><code class="p">;</code>&#13;
  <code class="k">min-width</code><code class="o">:</code> <code class="m">15vw</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">article</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">2</code> <code class="m">45ch</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">aside</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">20ch</code><code class="p">;</code>&#13;
  <code class="k">min-width</code><code class="o">:</code> <code class="m">10ch</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We won’t go through all the math here, but the general approach is to set flex basis values on character widths for improved readability, with some lower limits based on character widths and others on viewport width.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Flexbox can be useful for a one-dimensional page layout like the one shown in this section, with only three columns in a line.  For anything more complex, or for a more powerful set of options, use grid layout.  (See <a data-type="xref" href="ch12.html#grid-layout">Chapter 12</a>.)<a data-primary="" data-startref="ix_flex_shrink_prop" data-type="indexterm" id="idm45176076122032"/><a data-primary="" data-startref="ix_shrink_factor_flex" data-type="indexterm" id="idm45176076121056"/><a data-primary="" data-startref="ix_flex_shrink_prop_resp" data-type="indexterm" id="idm45176076120112"/><a data-primary="" data-startref="ix_resp_flexing" data-type="indexterm" id="idm45176076119200"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="The flex-basis Property" data-type="sect2"><div class="sect2" id="flex-basis">&#13;
<h2>The flex-basis Property</h2>&#13;
&#13;
<p>As you’ve already seen, a <a data-primary="flex-basis property" data-type="indexterm" id="ix_flex_basis_prop2"/>flex item’s size is impacted by its content and&#13;
box-model properties and can be reset via the three components of the&#13;
<code>flex</code> property. The &lt;<em><code>flex-basis</code></em>&gt; component of the <code>flex</code> property&#13;
defines the initial or default size of flex items, before extra or&#13;
negative space is distributed—before the flex items are allowed to&#13;
grow or shrink according to the growth and shrink factors.  It can also be set via the <code>flex-basis</code> property.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Declaring the flex basis via the <code>flex-basis</code> property is <em>strongly</em> discouraged by the authors of the specification itself.  Instead, declare the&#13;
flex basis as part of the <code>flex</code> shorthand.  We’re discussing the property here only to explore the flex basis.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176076079488">&#13;
<h1>flex-basis</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> | <code>content</code> | <code>max-content</code> | <code>min-content</code> | <code>fit-content</code> | [ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex items (children of flex containers)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Relative to flex container’s inner main-axis size</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified, with length values made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>width</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The flex <a data-primary="box-sizing property" data-type="indexterm" id="idm45176076061072"/>basis determines the size of a flex item’s element box, as set by&#13;
<code>box-sizing</code>. By default, when a block-level element is not a flex item,&#13;
the size is determined by the size of its parent, content, and box-model&#13;
properties. When no size properties are explicitly declared or&#13;
inherited, the size defaults to its individual content, border, and&#13;
padding, which is 100% of the width of its parent for block-level&#13;
elements.</p>&#13;
&#13;
<p>The flex basis can be defined using the same length value types as the&#13;
<code>width</code> and <code>height</code> properties—for example, <code>5vw</code>, <code>12%</code>, and <code>300px</code>.</p>&#13;
&#13;
<p>The universal keyword <code>initial</code> resets the flex basis to the initial value of <code>auto</code>, so you might as well declare <code>auto</code>.&#13;
In turn, <code>auto</code> evaluates to the <code>width</code> (or <code>height</code>), if declared. If the value of <code>width</code> (or <code>height</code>) is set to <code>auto</code>, the value of <code>flex-basis</code> is evaluated to &#13;
<span class="keep-together"><code>content</code>.</span>  This causes the flex item to be sized based on the content of the flex item, though the exact method for doing so is not made explicit in the specification.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The content keywords" data-type="sect3"><div class="sect3" id="content_keywords">&#13;
<h3>The content keywords</h3>&#13;
&#13;
<p>In addition to <a data-primary="flex-basis property" data-secondary="content keywords" data-type="indexterm" id="ix_flex_basis_prop_cont_key"/><a data-primary="max-content keyword" data-type="indexterm" id="idm45176076047632"/><a data-primary="min-content keyword" data-type="indexterm" id="idm45176076046928"/><a data-primary="content keywords" data-type="indexterm" id="ix_content_keys"/>lengths and percentages, <code>flex-basis</code> supports the <code>min-content</code>, <code>max-content</code>, <code>fit-content</code>, and <code>content</code> keywords.  We covered the first three in <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a>, but <code>fit-content</code> deserves a revisit here, and <code>content</code> needs to be explored.</p>&#13;
&#13;
<p>When <a data-primary="fit-content keyword" data-type="indexterm" id="idm45176076041152"/><a data-primary="flex-basis property" data-secondary="fit-content keyword" data-type="indexterm" id="idm45176076040416"/>using <code>fit-content</code> as the value for <code>flex-basis</code>, the browser will do its best to balance all the flex items in a line so that they are similar in block size.  Consider this code, which is illustrated in <a data-type="xref" href="#flex-basis-fit-sizing">Figure 11-50</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.flex-item</code> <code class="p">{</code><code class="nb">flex</code><code class="o">-</code><code class="n">basis</code><code class="o">:</code> <code class="m">25%</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nc">.flex-item.fit</code> <code class="p">{</code><code class="nb">flex</code><code class="o">-</code><code class="n">basis</code><code class="o">:</code> <code class="n">fit</code><code class="o">-</code><code class="n">content</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="flex-basis-fit-sizing">&#13;
<img alt="" src="assets/css5_1150.png"/>&#13;
<h6><span class="label">Figure 11-50. </span>Fit-content flex-basis sizing</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first flex line, the flex basis of the flex items is set to 25%, meaning each flex item starts out with 25% the width of the flex line as its sizing basis, and is flexed from there at the browser’s discretion.  In the second flex line, the flex items are set to use <code>fit-content</code> for their flex basis.  Notice that more content leads to wider flex items, and less to narrower items.</p>&#13;
&#13;
<p>Also notice that the heights (more properly, the block sizes) of the flex items are all the same, though this is not guaranteed: in certain situations, some of the flex items could be a bit taller than the others—say, by having one flex item’s content wrap to one more line than the others’.  They should all be very close to the same, though.</p>&#13;
&#13;
<p class="pagebreak-before">This is a good illustration of one of the strengths of flexbox: you can give a general direction to the layout engine and have it do the rest of the work.  Here, rather than having to figure out which widths should be assigned to which flex items in order to balance out their heights, you tell it <code>fit-content</code> and let it figure out the rest.</p>&#13;
&#13;
<p>Using the <code>content</code> keyword has results generally similar to <code>fit-content</code>, though some differences exist.  A <code>content</code> basis is the size of the flex item’s content—that is, the length of the main-axis size of the longest line of content or widest (or tallest) media object.  It’s the equivalent of declaring <code>flex-basis: auto; inline-size: auto;</code> on a flex item.</p>&#13;
&#13;
<p>The value <code>content</code> has the effects shown in <a data-type="xref" href="#content_basis_width">Figure 11-51</a>.</p>&#13;
&#13;
<figure><div class="figure" id="content_basis_width">&#13;
<img alt="css5 1151" src="assets/css5_1151.png"/>&#13;
<h6><span class="label">Figure 11-51. </span>Sizing flex items on a <code>content</code> basis <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-content-basis.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">In the first and third examples, the width of the flex item&#13;
is the size of the content; and the flex basis is that same size. In the&#13;
first example, the flex items’ width and basis are approximately 132 pixels.&#13;
The total width of the three flex items side by side is 396 pixels, with a few pixels of space between the items, all fitting&#13;
easily into the parent container.</p>&#13;
&#13;
<p>In the third example, we have set a null shrink factor (<code>0</code>): this means the&#13;
flex items cannot shrink, so they won’t shrink or wrap to fit into the&#13;
fixed-width flex container. Rather, they are the width of their&#13;
nonwrapped text. That width is also the value of the flex basis. The three flex&#13;
items’ widths, and thus their basis values, are approximately 309, 1,037 pixels, and 523 pixels, respectively. You can’t see the full width of the second flex item or the third flex item at all, but they’re in the <a href="https://meyerweb.github.io/csstdg5figs/11-flexbox">chapter files</a>.</p>&#13;
&#13;
<p>The second example contains the same content as the third example, but&#13;
the flex items are defaulting to a shrink factor of 1, so the text in this&#13;
example wraps because the flex items can shrink. Thus, while the width of&#13;
the flex item is not the width of the content, the flex basis—the&#13;
basis by which it will proportionally shrink—is the width of the&#13;
&#13;
<span class="keep-together">items’ contents.</span></p>&#13;
&#13;
<p>The <a data-primary="flex-shrink property" data-secondary="max-content keyword" data-type="indexterm" id="idm45176075998320"/><a data-primary="max-content keyword" data-type="indexterm" id="idm45176075997312"/>third example in <a data-type="xref" href="#content_basis_width">Figure 11-51</a> is also a good illustration of what would happen with the <code>max-content</code> keyword with <code>flex-shrink: 0</code>: the flex basis for each item will be the maximum size of its content.  If flex shrinking is allowed, then the browser will start with the <code>max-content</code> for the basis of each item’s flexing, and shrink them down from there.  The difference between the two is captured in the following code and illustrated in <a data-type="xref" href="#max_content_basis_width">Figure 11-52</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example1</code> <code class="p">{</code><code class="nb">flex</code><code class="o">-</code><code class="n">basis</code><code class="o">:</code> <code class="n">max</code><code class="o">-</code><code class="n">content</code><code class="p">;</code> <code class="nb">flex</code><code class="o">-</code><code class="n">shrink</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nf">#example2</code> <code class="p">{</code><code class="nb">flex</code><code class="o">-</code><code class="n">shrink</code><code class="o">:</code> <code class="m">1</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="max_content_basis_width">&#13;
<img alt="" src="assets/css5_1152.png"/>&#13;
<h6><span class="label">Figure 11-52. </span>Sizing flex items on a <code>max-content</code> basis, with and without shrinking</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">In the first example, where shrinking is not allowed, each flex item is as wide as its content can get without wrapping.  This causes the flex items to overflow the container (because <code>flex-wrap</code> is not set to <code>wrap</code>).  In the second example, where <code>flex-shrink</code> is set to <code>1</code>, the browser shrinks the flex items equally until they all fill out the flex container without overflowing it.  Note that the second of the four items is a little taller than the others, because its shrinking happens to require wrapping the content to one more line than the other items.</p>&#13;
&#13;
<p>For a <code>min-content</code> flex <a data-primary="min-content keyword" data-type="indexterm" id="idm45176075938288"/>basis, the reverse happens.  Consider the following, illustrated in <a data-type="xref" href="#min_content_basis_width">Figure 11-53</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example1</code> <code class="p">{</code><code class="nb">flex</code><code class="o">-</code><code class="n">basis</code><code class="o">:</code> <code class="n">min</code><code class="o">-</code><code class="n">content</code><code class="p">;</code> <code class="nb">flex</code><code class="o">-</code><code class="n">grow</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nf">#example2</code> <code class="p">{</code><code class="nb">flex</code><code class="o">-</code><code class="n">grow</code><code class="o">:</code> <code class="m">1</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="min_content_basis_width">&#13;
<img alt="" src="assets/css5_1153.png"/>&#13;
<h6><span class="label">Figure 11-53. </span>Sizing flex items on a <code>min-content</code> basis, with and without growing</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first example, flex items are as narrow as possible while still fitting their content.  For elements containing text, this makes them very tall, given that the block axis is vertical.  (Note that the full heights of the flex items in the first example have been clipped to keep the figure to a reasonable size.)  In the second example, the items are allowed to grow, so they start from the <code>min-content</code> size and their widths are grown equally until they all fill out the flex container without overflowing it.</p>&#13;
&#13;
<p class="pagebreak-before">In the browser used to create <a data-type="xref" href="#min_content_basis_width">Figure 11-53</a>, the widths of the flex items in the first example added up to 361.1 pixels (rounded to the nearest tenth of a pixel), with 20 pixels of space between each flex item.  This means from the left edge of the first item to the right edge of the last item is about 420.1 pixels.  To arrive at the result in the second example, given that the width of the flex container is 1,200 pixels, the difference between the container width and content width is 1,200 – 420.1 = 778.9 pixels.  This difference is divided by 4, yielding approximately 194.7 pixels, and the width of each of the four flex items is increased by that amount.<a data-primary="" data-startref="ix_content_keys" data-type="indexterm" id="idm45176075882400"/><a data-primary="" data-startref="ix_flex_basis_prop_cont_key" data-type="indexterm" id="idm45176075881456"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Automatic flex basis" data-type="sect3"><div class="sect3" id="auto">&#13;
<h3>Automatic flex basis</h3>&#13;
&#13;
<p>When <a data-primary="flex-basis property" data-secondary="automatic flex basis" data-type="indexterm" id="ix_flex_basis_prop_auto"/>set to <code>auto</code>, whether explicitly or by default,&#13;
<code>flex-basis</code> is the same as the main-axis size of&#13;
the element, had the element not been turned into a flex item. For length&#13;
values, <code>flex-basis</code> resolves to the <code>width</code> or <code>height</code> value, with&#13;
the exception that when the value of <code>width</code> or <code>height</code> is <code>auto</code>,&#13;
the flex-basis value falls back to <code class="keep-together">content</code>.</p>&#13;
&#13;
<p>When the flex basis is <code>auto</code>, and all the flex items can fit within the parent&#13;
flex container, the flex items will be their preflexed size.&#13;
If the flex items don’t fit into their parent flex container, the flex items&#13;
within that container will shrink proportionally based on their&#13;
nonflexed main-axis sizes (unless the shrink factor is 0).</p>&#13;
&#13;
<p>When there are no other properties setting the main-axis size of the flex items&#13;
(that is, there’s no <code>inline-size</code>, <code>min-inline-size</code>, <code>width</code>, or <code>min-width</code> set on these flex items), and&#13;
<code>flex-basis: auto</code> or <code>flex: 0 1 auto</code> is set, the flex items will be only as wide as they need to be for the content to fit, as seen in the&#13;
first example in <a data-type="xref" href="#when_flex_basis_set">Figure 11-54</a>. In this case, they are the width of the text&#13;
“flex-basis: auto,” which is approximately&#13;
110 pixels. The flex items are their preflexed size, as if set to&#13;
<code>display: inline-block</code>. In this example, they’re grouped at main-start because the <code>justify-content</code> property, the flex container’s <code>justify-content</code> defaults to <code>flex-start</code>.</p>&#13;
&#13;
<p>In the second example in <a data-type="xref" href="#when_flex_basis_set">Figure 11-54</a>, each flex item has a flex basis&#13;
of <code>auto</code> and an explicitly declared width. The main-axis size of the elements, had they&#13;
not been turned into flex items, would be 100, 150, and 200 pixels, respectively. And so they are here, since they fit into the flex container without any overflow along the main-axis.</p>&#13;
&#13;
<figure class="width_set_80"><div class="figure" id="when_flex_basis_set">&#13;
<img alt="css5 1154" src="assets/css5_1154.png"/>&#13;
<h6><span class="label">Figure 11-54. </span>Auto flex basis and flex item widths <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-auto-basis-and-widths.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>In the third example in <a data-type="xref" href="#when_flex_basis_set">Figure 11-54</a>, each of the flex items has a flex basis&#13;
of <code>auto</code> and a very large explicitly declared width. The main-axis size of the elements, had they&#13;
not been turned into flex items, would be 2,000, 3,000, and 4,000 pixels, respectively. Since they could not possibly fit into the flex container without overflowing along the main-axis, and their flex shrink factors have all defaulted to <code>1</code>, they shrink until they fit into the flex container.  You can do the math to find out how big they are using the process outlined in <a data-type="xref" href="#differing-bases">“Differing basis values”</a>; as a hint, the width of the third flex item should be reduced from 4,000 pixels to 240 pixels.<a data-primary="" data-startref="ix_flex_basis_prop_auto" data-type="indexterm" id="idm45176075829744"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Default values" data-type="sect3"><div class="sect3" id="default-values">&#13;
<h3>Default values</h3>&#13;
&#13;
<p>When <a data-primary="flex-basis property" data-secondary="default values" data-type="indexterm" id="idm45176075826288"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="default sizing" data-type="indexterm" id="idm45176075825280"/>neither <code>flex-basis</code> nor <code>flex</code> is set, the flex item’s main-axis size is&#13;
the preflex size of the item, as the default value is <code>auto</code>.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#when_no_flex_properties_are_set">Figure 11-55</a>: the flex basis values are defaulting to <code>auto</code>, the growth factor is defaulting to <code>0</code>, and the shrink factor of each item is defaulting to <code>1</code>.&#13;
For each flex item, the flex basis is its individual <code>width</code> value. That&#13;
means the flex basis values are being set to the values of the <code>width</code> properties:&#13;
100, 200, and 300 pixels in the first example, and 200, 400, and 200 pixels&#13;
in the second example.&#13;
As the combined widths of the flex items are 600 pixels and 800 pixels, respectively, both of which are greater than the main-axis size of the 540-pixel-wide containers, they are all shrinking proportionally to fit.</p>&#13;
&#13;
<figure><div class="figure" id="when_no_flex_properties_are_set">&#13;
<img alt="When no flex properties are set, the flex item's main-axis size will be the pre-flex size of the item" src="assets/css5_1155.png"/>&#13;
<h6><span class="label">Figure 11-55. </span>Default sizing of flex items <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-default-sizing.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first example, we are trying to fit 600 pixels in 540 pixels, so each flex item will shrink by 10% to yield flex items that are 90, 180, and 270 pixels wide. In the second example, we are trying to fit 800 pixels into 540 pixels, so they all shrink 32.5%, making the flex items’ widths 135, 270, and 135 pixels.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Length units" data-type="sect3"><div class="sect3" id="length-units">&#13;
<h3>Length units</h3>&#13;
&#13;
<p>In the <a data-primary="flex-basis property" data-secondary="length units" data-type="indexterm" id="idm45176075813056"/>previous examples, the <code>auto</code> flex basis values defaulted to the declared widths of&#13;
the various flex items. CSS provides other options; for example, we can use the same length units for our&#13;
flex-basis value as we do for <code>width</code> and <code>height</code>.</p>&#13;
&#13;
<figure><div class="figure" id="width_flex_proportion_basis">&#13;
<img alt="css5 1156" src="assets/css5_1156.png"/>&#13;
<h6><span class="label">Figure 11-56. </span>Sizing flex items with length-unit flex basis values <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-width-vs-length.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>When we have both <code>flex-basis</code> and <code>width</code> (or <code>height</code>, for vertical main-axes) values, the basis trumps the&#13;
width (or height). Let’s add basis values to the first example from&#13;
<a data-type="xref" href="#when_no_flex_properties_are_set">Figure 11-55</a>. The flex items include the&#13;
following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">flex-container</code> <code class="p">{</code>&#13;
  <code class="k">width</code><code class="o">:</code> <code class="m">540px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">item1</code> <code class="p">{</code>&#13;
  <code class="k">width</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
  <code class="nb">flex</code><code class="o">-</code><code class="n">basis</code><code class="o">:</code> <code class="m">300px</code><code class="p">;</code>  <code class="c">/* flex: 0 1 300px; */</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">item2</code> <code class="p">{</code>&#13;
  <code class="k">width</code><code class="o">:</code> <code class="m">200px</code><code class="p">;</code>&#13;
  <code class="nb">flex</code><code class="o">-</code><code class="n">basis</code><code class="o">:</code> <code class="m">200px</code><code class="p">;</code>  <code class="c">/* flex: 0 1 200px; */</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">item3</code> <code class="p">{</code>&#13;
  <code class="k">width</code><code class="o">:</code> <code class="m">300px</code><code class="p">;</code>&#13;
  <code class="nb">flex</code><code class="o">-</code><code class="n">basis</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>  <code class="c">/* flex: 0 1 100px; */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The widths are overridden by the basis values. The flex items shrink down to&#13;
270 pixels, 180 pixels, and 90 pixels, respectively.  Had the container <em>not</em> had a constrained width, the flex items would have been 300 pixels, 200 pixels, and 100 pixels, respectively.</p>&#13;
&#13;
<p>While the declared flex basis can override the main-axis size of flex items, the&#13;
size can be affected by other properties, such as <code>min-width</code>,&#13;
<code>min-height</code>, <code>max-width</code>, and <code>max-height</code>. These are not ignored.  Thus, for example, an element might have <code>flex-basis: 100px</code> and <code>min-width: 500px</code>.  The minimum width of <code>500px</code> will be respected, even though the flex basis is smaller.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Percentage units" data-type="sect3"><div class="sect3" id="length-units-percentages">&#13;
<h3>Percentage units</h3>&#13;
&#13;
<p>Percentage <a data-primary="flex-basis property" data-secondary="percentage units" data-type="indexterm" id="ix_flex_basis_prop_percent"/>values for <code>flex-basis</code> are calculated relative to the size of the main&#13;
dimension of the flex container.</p>&#13;
&#13;
<p>We’ve already seen the first example in <a data-type="xref" href="#percentage-val-flex-basis">Figure 11-57</a>; it’s included here&#13;
to recall that the width of the text “flex-basis: auto” in this case is approximately 110 pixels wide. In&#13;
this case only, declaring <code>flex-basis: auto</code> looks the same as writing <code>flex-basis: 110px</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">flex-container</code> <code class="p">{</code>&#13;
  <code class="k">width</code><code class="o">:</code> <code class="m">540px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">flex-item</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">100%</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the second example in <a data-type="xref" href="#percentage-val-flex-basis">Figure 11-57</a>, the first two flex items have a flex basis of&#13;
<code>auto</code> with a default <code>width</code> of <code>auto</code>, which is as if their flex basis were set to <code>content</code>. As we’ve noted previously, the <code>flex-basis</code> of the first two items ends up being the equivalent of 110 pixels, as the content in this case happens to be 110 pixels wide.&#13;
The last item has its <code>flex-basis</code> set to <code>100%</code>.</p>&#13;
&#13;
<figure><div class="figure" id="percentage-val-flex-basis">&#13;
<img alt="The percentage value for flex-basis is relative to the width of the flex container" src="assets/css5_1157.png"/>&#13;
<h6><span class="label">Figure 11-57. </span>Sizing flex items with percentage flex basis values <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">The percentage value is relative to the parent, which is 540 pixels.&#13;
The third flex item, with a basis of <code>100%</code>, is not&#13;
the only flex item within the nonwrapping flex container.  Thus, it will not&#13;
grow to be 100% of the width of the parent flex container <em>unless</em> its&#13;
shrink factor is set with a null shrink factor, meaning it can’t shrink, or if it contains nonwrappable content that is as wide or wider than the parent&#13;
container.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Remember: when the flex basis is a percent value, the main-axis size is&#13;
relative to the parent, which is the flex container.</p>&#13;
</div>&#13;
&#13;
<p>With our three flex basis values, if the content is indeed 110 pixels wide, and the container is 540 pixels wide (ignoring other box-model properties for simplicity’s sake), we have a total of 760 pixels to fit in a 540-pixel space. Thus we have 220 pixels of negative space to distribute proportionally. The shrink factor is as follows:</p>&#13;
<ul class="simplelist">&#13;
<li>Shrink factor = 220 px ÷ 760 px = 28.95%</li>&#13;
</ul>&#13;
&#13;
<p>Each flex item will be shrunk by 28.95%, becoming 71.05% of the width&#13;
it would have been, had it not been allowed to shrink. We can figure&#13;
the final widths:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 =  110 px × 71.05% =  78.16 px</li>&#13;
<li>item2 =  110 px × 71.05% =  78.16 px</li>&#13;
<li>item3 =  540 px × 71.05% = 383.68 px</li>&#13;
</ul>&#13;
&#13;
<p>These numbers hold true as long as the flex items can be that small—that is, as long as none of the flex items contain media or nonbreaking text wider than 78.16 pixels or 383.68 pixels. This is the widest these flex items will be as long as the content can wrap to be that width or narrower. We say “widest” because if one of the other two flex items can’t shrink to be as narrow as this value, they’ll both have to absorb some of that negative space.</p>&#13;
&#13;
<p>In the third example in <a data-type="xref" href="#percentage-val-flex-basis">Figure 11-57</a>, the <code>flex-basis: auto</code> item wraps over three lines. The CSS for this example is the equivalent of the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">flex-container</code> <code class="p">{</code>&#13;
  <code class="k">width</code><code class="o">:</code> <code class="m">540px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">item1</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">70%</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">item2</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">item3</code> <code class="p">{</code>&#13;
  <code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="m">80%</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We declare the <code>flex-basis</code> of the three flex items to be <code>70%</code>,&#13;
<code>auto</code>, and <code>80%</code>, respectively. Remembering that in our scenario <code>auto</code> is the width of the nonwrapping content, which in this case is approximately 110 pixels, and our flex container is 540 pixels, the basis values are equivalent to the following:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 70% × 540 px = 378 px</li>&#13;
<li>item2 = widthOfText(“flex-basis: auto”) ≈ 110 px</li>&#13;
<li>item3 = 80% × 540 px = 432 px</li>&#13;
</ul>&#13;
&#13;
<p>When we add the widths of these three flex items’ basis values, they have a total combined width of 920 pixels, which needs to fit into a flex container 540 pixels wide. Thus we have 380 pixels of negative space to remove proportionally among the three flex items. To figure out the ratio, we divide the available width of our flex container by the sum of the widths of the flex items that they would have if they couldn’t shrink:</p>&#13;
<ul class="simplelist">&#13;
<li>Proportional width = 540 px ÷ 920 px = 0.587</li>&#13;
</ul>&#13;
&#13;
<p>Because the shrink factors are all the same, this is fairly simple. Each&#13;
item will be 58.7% of the width it would be if it had no flex-item&#13;
siblings:</p>&#13;
<ul class="simplelist">&#13;
<li>item1 = 378 px × 58.7% = 221.8 px</li>&#13;
<li>item2 = 110 px × 58.7% =  64.6 px</li>&#13;
<li>item3 = 432 px × 58.7% = 253.6 px</li>&#13;
</ul>&#13;
&#13;
<p>What happens when the container is a different width? Say, 1,000 pixels? The&#13;
flex basis would be 700 pixels (70% × 1,000 pixels), 110 pixels, and 800 pixels (80% × 1,000 pixels),&#13;
respectively, for a total of 1,610 pixels:</p>&#13;
<ul class="simplelist">&#13;
<li>Proportional width = 1,000 px ÷ 1,610 px = 0.6211</li>&#13;
</ul>&#13;
<ul class="simplelist">&#13;
<li>item1 = 700 px × 62.11% = 434.8 px</li>&#13;
<li>item2 = 110 px × 62.11% =  68.3 px</li>&#13;
<li>item3 = 800 px × 62.11% = 496.9 px</li>&#13;
</ul>&#13;
&#13;
<p>Because with a basis of 70% and 80%, the combined basis values of the flex items will always be wider than 100%, no matter how wide we make the parent, all three items will always shrink.</p>&#13;
&#13;
<p>If the first flex item can’t shrink for some reason—whether because of unshrinkable content, or another bit of CSS setting its <code>flex-shrink</code> to <code>0</code>—it will be 70% of the width of the parent, 378 pixels in this case.&#13;
The other two flex items must shrink proportionally to fit into the remaining 30%, or&#13;
162 pixels. In this case, we expect widths to be 378 pixels, 32.875 pixels, and&#13;
129.125 pixels. As the text “basis:” is wider than that—assume 42 pixels—we get 378 pixels, 42 pixels, and 120 pixels. <a data-type="xref" href="#flex-basis-rel-main-axis-size">Figure 11-58</a> shows the result.</p>&#13;
&#13;
<figure><div class="figure" id="flex-basis-rel-main-axis-size">&#13;
<img alt="css5 1158" src="assets/css5_1158.png"/>&#13;
<h6><span class="label">Figure 11-58. </span>While the percentage value for <code>flex-basis</code> is relative to the width of the flex container, the main-axis size is impacted by its siblings <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage-main-axis.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Testing this out on your device will likely have slightly different&#13;
results, as the width of the text “flex-basis: auto” may not be the same&#13;
for you, depending on the font that gets used to render the text.  (We used Myriad Pro, with fallbacks to Helvetica and any generic sans-serif font.)<a data-primary="" data-startref="ix_flex_basis_prop_percent" data-type="indexterm" id="idm45176075562688"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Zero basis" data-type="sect3"><div class="sect3" id="zero-basis">&#13;
<h3>Zero basis</h3>&#13;
&#13;
<p>If <a data-primary="flex-basis property" data-secondary="zero basis" data-type="indexterm" id="idm45176075560176"/>neither the <code>flex-basis</code> property nor the <code>flex</code> shorthand is&#13;
included at all, the flex basis defaults to <code>auto</code>. When the <code>flex</code> property is&#13;
included, but the flex basis component of the shorthand is omitted from the&#13;
shorthand, the basis defaults to <code>0</code>. While on the surface you&#13;
might think the two values of <code>auto</code> and <code>0</code> are similar, the <code>0</code>&#13;
value is actually very different and may not be what you expect.</p>&#13;
&#13;
<p>In the case of <code>flex-basis: auto</code>, the basis is the main size of the flex items’ contents. If the basis of each of the flex items is <code>0</code>, the available space is the main-axis size of the entire flex container. In either case, the available space is distributed proportionally, based on the growth factors of each flex item.</p>&#13;
&#13;
<p>With a basis of <code>0</code>, the size of the flex container is divided up and distributed proportionally to each flex item based on its growth factors—its default original main-axis size as defined by <code>height</code>, <code>width</code>, or <code>content</code> is not taken into account, though <code>min-width</code>, <code>max-width</code>, <code>min-height</code>, and <code>max-height</code> do impact the flexed size.</p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#flex-basis-auto-vs-0">Figure 11-59</a>, when the basis is <code>auto</code>, only the extra space is divided up proportionally and added to each flex item set to grow. Again, assuming the width of the text “flex: <em>X X</em> auto” is 110 pixels, in the first example we have 210 pixels to distribute among six growth factors, or 35 pixels per growth factor. The flex items are 180, 145, and 215 pixels wide, respectively.</p>&#13;
&#13;
<figure><div class="figure" id="flex-basis-auto-vs-0">&#13;
<img alt="flex-basis auto versus 0" src="assets/css5_1159.png"/>&#13;
<h6><span class="label">Figure 11-59. </span>Flex growth in auto and zero flex basis values</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the second example, when the basis is 0, all 540 pixels of the width is distributable space. With 540 pixels of distributable space among six growth factors, each growth factor is worth 90 pixels. The flex items are 180, 90, and 270 pixels wide, respectively. While the middle flex item is 90 pixels wide, the content in this example is narrower than 110 pixels, so the flex item didn’t wrap.<a data-primary="" data-startref="ix_flex_basis_prop2" data-type="indexterm" id="idm45176075545760"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The flex Shorthand" data-type="sect2"><div class="sect2" id="flex-shorthand-property">&#13;
<h2>The flex Shorthand</h2>&#13;
&#13;
<p>Now <a data-primary="flex property" data-type="indexterm" id="ix_flex_prop2"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="shorthand property" data-type="indexterm" id="ix_flex_item_short"/>that you have a fuller understanding of the properties that make up&#13;
the <code>flex</code> shorthand, remember: <em>always use the <code>flex</code> shorthand.</em>&#13;
It accepts the usual global property values, including <code>initial</code>, <code>auto</code>, <code>none</code>; and the use of an integer, usually <code>1</code>, meaning the flex item can grow.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176075537152">&#13;
<h1>flex</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | [ &lt;<em><code>flex-grow</code></em>&gt; &lt;<em><code>flex-shrink</code></em>&gt;? ‖ &lt;<em><code>flex-basis</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0 1 auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex items</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties, with the caveat that relative lengths for <code>flex-basis</code> are converted to absolute lengths</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p class="pagebreak-before">Four of the flex values provide the most&#13;
commonly desired effects:</p>&#13;
<dl>&#13;
<dt><code>flex: initial</code></dt>&#13;
<dd>&#13;
<p>Equivalent to <code>flex: 0 1 auto</code>. This sizes flex items based on the value of <code>inline-size</code> (which is equivalent to either <code>width</code> or <code>height</code>, depending on the direction of the inline axis), and allows shrinking but not growing.</p>&#13;
</dd>&#13;
<dt><code>flex: auto</code></dt>&#13;
<dd>&#13;
<p>Equivalent to <code>flex: 1 1 auto</code>. This sizes flex items based on the value of <code>inline-size</code>, but makes them fully flexible, allowing both shrinking and growing.</p>&#13;
</dd>&#13;
<dt><code>flex: none</code></dt>&#13;
<dd>&#13;
<p>Equivalent<a data-primary="flex keyword, flex property" data-type="indexterm" id="idm45176075513952"/> to <code>flex: 0 0 auto</code>. This sizes flex items based on the value of <code>inline-size</code>, but makes them completely inflexible: they can’t shrink or grow.</p>&#13;
</dd>&#13;
<dt><code>flex: &lt;<em>number</em>&gt;</code></dt>&#13;
<dd>&#13;
<p>Equivalent to <code>flex: &lt;<em>number</em>&gt; 1 0</code>. This value sets the flex item’s growth factor to the &lt;<em><code>number</code></em>&gt; provided.  It also sets both the shrink factor and flex basis to <code>0</code>.  This means the value of <code>inline-size</code> acts as a minimum size, but the flex item will grow if there is room to do so.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Let’s consider each of these in turn.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flexing with initial" data-type="sect3"><div class="sect3" id="idm45176075507184">&#13;
<h3>Flexing with initial</h3>&#13;
&#13;
<p>The global CSS <a data-primary="initial keyword, flex property" data-type="indexterm" id="ix_initial_key_flex"/>keyword <code>initial</code> can be used on all properties to represent a property’s initial value (its specification default value). Thus, the following lines are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex</code><code class="o">:</code> <code class="nb">initial</code><code class="p">;</code>&#13;
<code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">1</code> <code class="nb">auto</code><code class="p">;</code></pre>&#13;
&#13;
<p>Declaring <code>flex: initial</code> sets a null growth factor, a shrink factor of&#13;
<code>1</code>, and the flex basis values to <code>auto</code>. In <a data-type="xref" href="#flex-shrink-flex-initial">Figure 11-60</a>, we can see the&#13;
effect of the <code>auto</code> flex basis values. In the first two examples, the basis of each flex item is <code>content</code>—with each flex item having the width of the single line of&#13;
letters that makes up the content. However, in the last two&#13;
examples, the flex basis values of all the items are equal at 50 pixels, since&#13;
<code>width: 50px</code> has been applied to all the flex items. The <code>flex: initial</code>&#13;
declaration sets the <code>flex-basis</code> to <code>auto</code>, which we previously saw is the value of the <code>width</code> (or <code>height</code>), if declared, or <code>content</code> if not declared.</p>&#13;
&#13;
<p>In the first and third of these examples, we see that when the flex&#13;
container is too small to fit all the flex items at their default&#13;
main-axis size, the flex items shrink so that all fit within the parent flex container. In these examples, the combined flex basis values of all the flex items is greater than the main-axis size of the flex container. In the first example, the width of each flex item varies based on the width of each item’s content and its ability to shrink. They all shrink proportionally based on their shrink factor, but not narrower than their widest content. In the third example, with each flex item’s flex-basis being 50 pixels (because of the value of <code>width</code>), all the items shrink equally.</p>&#13;
&#13;
<figure><div class="figure" id="flex-shrink-flex-initial">&#13;
<img alt="With containers of different main sizes, the flex items shrink but won't grow when flex: initial is set on the flex items" src="assets/css5_1160.png"/>&#13;
<h6><span class="label">Figure 11-60. </span>Flex items shrink but won’t grow when <code>flex: initial</code> is set <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-dont-grow.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Flex items, by default, are grouped at main-start, as <code>flex-start</code> is&#13;
the default value for the <code>justify-content</code> property. This is&#13;
noticeable only when the combined main-axis sizes of the flex items in a flex line are smaller than the main-axis size of the flex container, and none of the flex items are able to grow.<a data-primary="" data-startref="ix_initial_key_flex" data-type="indexterm" id="idm45176075468928"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flexing with auto" data-type="sect3"><div class="sect3" id="idm45176075467824">&#13;
<h3>Flexing with auto</h3>&#13;
&#13;
<p>The <code>flex: auto</code> option is similar to <code>flex: initial</code>, but makes the flex items&#13;
flexible in both directions: they’ll shrink if there isn’t enough room&#13;
to fit all the items within the container, and they’ll grow to take up&#13;
all the extra space within the container if there is distributable&#13;
space. The flex items absorb any free space along the main-axis.&#13;
The following two statements are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
<code class="k">flex</code><code class="o">:</code> <code class="m">1</code> <code class="m">1</code> <code class="nb">auto</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#flex-auto-grow-shrink">Figure 11-61</a> shows a variety of scenarios using <code>auto</code> flexing.</p>&#13;
&#13;
<figure><div class="figure" id="flex-auto-grow-shrink">&#13;
<img alt="With flex: auto set on the flex items, the flex items can grow and shrink " src="assets/css5_1161.png"/>&#13;
<h6><span class="label">Figure 11-61. </span>Flex items can grow and shrink when <code>flex: auto</code> is set <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-and-grow.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The first and third examples of <a data-type="xref" href="#flex-auto-grow-shrink">Figure 11-61</a> are identical to&#13;
the examples in <a data-type="xref" href="#flex-shrink-flex-initial">Figure 11-60</a>, as the shrinking and basis values are the same.&#13;
However, the second and fourth examples are different.  This is because when&#13;
<code>flex: auto</code> is set, the growth factor is <code>1</code>, and the flex items therefore can grow to incorporate all the extra available space.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Preventing flexing with none" data-type="sect3"><div class="sect3" id="idm45176075424432">&#13;
<h3>Preventing flexing with none</h3>&#13;
&#13;
<p>Any <code>flex: none</code> flex items are inflexible: they can neither&#13;
shrink nor grow.&#13;
The following two lines of CSS are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex</code><code class="o">:</code> <code class="nb">none</code><code class="p">;</code>&#13;
<code class="k">flex</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="nb">auto</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#flex-none-no-grow-shrink">Figure 11-62</a> shows the effects of <code>none</code>.</p>&#13;
&#13;
<figure><div class="figure" id="flex-none-no-grow-shrink">&#13;
<img alt="With flex: none, flex items will neither grow nor shrink" src="assets/css5_1162.png"/>&#13;
<h6><span class="label">Figure 11-62. </span>With <code>flex: none</code>, flex items will neither grow nor shrink <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-dont-grow-nor-shrink.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>As demonstrated in the first and third examples of <a data-type="xref" href="#flex-none-no-grow-shrink">Figure 11-62</a>, if there&#13;
isn’t enough space, the flex items overflow the flex container. This is&#13;
different from <code>flex: initial</code> and <code>flex: auto</code>, which both set a&#13;
positive shrink factor.</p>&#13;
&#13;
<p>The basis resolves to <code>auto</code>, meaning each flex item’s main-axis size is determined by the main-axis size of the element had it not been turned into a flex item.  The flex-basis resolves to the <code>width</code> or <code>height</code> value of the element. If that value is <code>auto</code>, the basis becomes the main-axis size of the content. In the first two examples, the basis—and the width, since there is no growing or shrinking—is the width of the content. In the third and fourth examples, the width and basis are all 50 pixels, because that’s the value of the <code>width</code> property applied to them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Numeric flexing" data-type="sect3"><div class="sect3" id="idm45176075379968">&#13;
<h3>Numeric flexing</h3>&#13;
&#13;
<p>When the value of the <code>flex</code> property is a single, positive, numeric value, that value will be used for the growth factor, while the shrink factor will default to <code>1</code> and the basis will default to <code>0</code>.&#13;
The following two CSS declarations are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">flex</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code>&#13;
<code class="k">flex</code><code class="o">:</code> <code class="m">3</code> <code class="m">1</code> <code class="m">0</code><code class="p">;</code></pre>&#13;
&#13;
<p>This makes the flex item on which it is set flexible: it can grow. The shrink&#13;
factor is actually moot: the flex basis is set to <code>0</code>, so the flex item can grow only from that basis.</p>&#13;
&#13;
<p>In the first two examples in <a data-type="xref" href="#flex-n-grow-shrink">Figure 11-63</a>, all the flex items have a flex growth factor of <code>3</code>. The flex basis is <code>0</code>, so they don’t “shrink”; they just grow equally from 0 pixels wide until the sum of their main-axis sizes to fill the container along the main-axis. With all the flex items having a basis of <code>0</code>, 100% of the main dimension is distributable space. The main-axis size of the flex items is wider in this second example because the wider flex container has more distributable space.</p>&#13;
&#13;
<figure><div class="figure" id="flex-n-grow-shrink">&#13;
<img alt="With flex: n, you're declaring the flex items growth factor while setting the flex basis to zero" src="assets/css5_1163.png"/>&#13;
<h6><span class="label">Figure 11-63. </span>Flexing using a single numeric value <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-using-single-numeric-value.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Any numeric value  that is greater than 0, even 0.1, means the flex item&#13;
can grow. If there is available space to&#13;
grow and only one flex item has a positive growth factor, that item will&#13;
take up all the available space. If multiple flex items can grow, the&#13;
available extra space will be distributed proportionally to each flex&#13;
item based on its growth factor.</p>&#13;
&#13;
<p>The last three examples of <a data-type="xref" href="#flex-n-grow-shrink">Figure 11-63</a> declare six flex items with&#13;
<code>flex: 0</code>, <code>flex: 1</code>, <code>flex: 2</code>, <code>flex: 3</code>, <code>flex: 4</code>, and <code>flex: 5</code>, respectively. These are the growth factors for the flex&#13;
items, with each having a shrink factor of <code>1</code> and a flex basis of <code>0</code>. The main-axis size of each is proportional to the specified flex growth factor. You might assume that the <code>flex: 0</code> item with the text “flex: 0” in the third example will be 0 pixels wide, as in the fourth example—but, by default, flex items won’t shrink below the length of the longest word or fixed-size element.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We added a bit of padding, margins, and borders to the figures to make the visuals more pleasing. For this reason, the leftmost flex item, with <code>flex: 0</code> declared, is visible: it has a 1-pixel border &#13;
<span class="keep-together">making</span> it visible, even though it’s 0 pixels wide.<a data-primary="" data-startref="ix_flex_items_props" data-type="indexterm" id="idm45176075329168"/><a data-primary="" data-startref="ix_flex_item_short" data-type="indexterm" id="idm45176075328192"/><a data-primary="" data-startref="ix_flex_prop2" data-type="indexterm" id="idm45176075327248"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The order Property" data-type="sect1"><div class="sect1" id="the-order-property">&#13;
<h1>The order Property</h1>&#13;
&#13;
<p>Flex <a data-primary="order property" data-type="indexterm" id="ix_order_prop"/><a data-primary="flexible box (flexbox) layout" data-secondary="flex items" data-tertiary="order of" data-type="indexterm" id="ix_flex_item_order"/>items are, by default, displayed and laid out in the same order as&#13;
they appear in the source code. The order of flex items and flex lines can be reversed with <code>flex-direction</code>, but sometimes you want a rearrangment that’s a little more complicated. The <code>order</code> property can be used to&#13;
change the ordering of individual flex items.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176075308304">&#13;
<h1>order</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>integer</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Flex items and absolutely positioned children of flex containers</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>By default, all flex items are assigned the order of <code>0</code>, with the flex&#13;
items all assigned to the same ordinal group and displayed in the same order as their source order, along the&#13;
direction of the main-axis.  (This has been the case for all the examples throughout this &#13;
<span class="keep-together">chapter.)</span></p>&#13;
&#13;
<p>To change the visual order of a flex item, set the <code>order</code> property&#13;
value to a nonzero integer. Setting the <code>order</code> property on elements&#13;
that are not children of a flex container has no effect on such elements.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Changing the <a data-primary="accessibility issues" data-secondary="order of flex items" data-type="indexterm" id="idm45176075291248"/>visual rendering order of flex items creates a disconnect between the source order of elements and their visual presentation.  This can, in the words of the Mozilla Developer Network’s article on <code>order</code>, “adversely affect users experiencing low vision navigating with the aid of assistive technology such as a screen reader.”  It could also create problems for users who navigate by keyboard and use a zoomed-in or otherwise magnified view of pages. In other words: be very careful with <code>order</code>, and use it <em>only</em> in production after much accessibility testing.</p>&#13;
</div>&#13;
&#13;
<p>The <a data-primary="ordinal group" data-type="indexterm" id="idm45176075287728"/>value of the <code>order</code> property specifies an <em>ordinal group</em> to which the flex&#13;
item belongs. Any flex items with a negative value will appear to&#13;
come before those defaulting to <code>0</code> when drawn to the page, and all the&#13;
flex items with a positive value will appear to come after those&#13;
defaulting to <code>0</code>. While visually altered, the source order remains the&#13;
same. Screen readers and tabbing order remain as defined by the source&#13;
order of the HTML.</p>&#13;
&#13;
<p>For example, if you have a group of 12 items, and you want the seventh&#13;
to come first and the sixth to be last, you would declare the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">inline-flex</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">6</code><code class="o">)</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">7</code><code class="o">)</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">-1</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this scenario, we are explicitly setting the order for the sixth and&#13;
seventh list items, while the other list items are defaulting to <code>order: 0</code>. <a data-type="xref" href="#setting-order-to-any">Figure 11-64</a> shows the result.</p>&#13;
&#13;
<figure><div class="figure" id="setting-order-to-any">&#13;
<img alt="Setting order to any value other than 0 will reorder that flex item" src="assets/css5_1164.png"/>&#13;
<h6><span class="label">Figure 11-64. </span>Reordering flex items with the <code>order</code> property <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/order01.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The seventh flex item is the first to be laid out, because of the&#13;
negative value of the <code>order</code> property, which is less&#13;
than the default <code>0</code>, and is also the lowest value of any of its sibling flex&#13;
items. The sixth flex item is the only item with a value greater than 0, and&#13;
therefore has the highest-order value out of all of its siblings. This is why it’s laid out after all the other flex items.&#13;
All the other items, all having the default&#13;
<code>order</code> of <code>0</code>, are drawn between those first and last&#13;
items, in the same order as their source order, since they are all&#13;
members of the same ordinal group (<code>0</code>).</p>&#13;
&#13;
<p>The flex container lays out its content in order-modified document&#13;
order, starting from the lowest-numbered ordinal group and going up.&#13;
When multiple flex items have the same value for the <code>order</code>&#13;
property, the items share an ordinal group. The items in each ordinal group&#13;
will appear in source order, with the group appearing in numeric order, from lowest to highest.  Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">inline-flex</code><code class="p">;</code>&#13;
  <code class="k">background-color</code><code class="o">:</code> <code class="n">rgba</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">1</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">3n-1</code><code class="o">)</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code>&#13;
  <code class="k">background-color</code><code class="o">:</code> <code class="n">rgba</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">2</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">3n</code><code class="o">+</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">-1</code><code class="p">;</code>&#13;
  <code class="k">background-color</code><code class="o">:</code> <code class="n">rgba</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">4</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>By setting the same <code>order</code> value to more than one flex item, the items&#13;
will appear by ordinal group, and by source order within each individual&#13;
ordinal group. <a data-type="xref" href="#flex-items-appear-ordinal">Figure 11-65</a> shows the result.</p>&#13;
&#13;
<figure><div class="figure" id="flex-items-appear-ordinal">&#13;
<img alt="Flex items appear in order of ordinal groups, by source order within their group" src="assets/css5_1165.png"/>&#13;
<h6><span class="label">Figure 11-65. </span>Flex items appear in order of ordinal groups, by source order within &#13;
<span class="keep-together">their group</span> <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/order02.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>Here’s what happened:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Items 2, 5, 8, and 11 were selected to share ordinal group <code>3</code>, and get a 20% opaque background.</p>&#13;
</li>&#13;
<li>&#13;
<p>Items 1, 4, 7, and 10 were selected to share ordinal group <code>-1</code>, and get a 40% opaque background.</p>&#13;
</li>&#13;
<li>&#13;
<p>Items 3, 6, 9, and 12 were not selected at all.  They default to the ordinal group <code>0</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The three ordinal groups, then, are <code>-1</code>, <code>0</code>, and <code>3</code>.  The groups are arranged in that order.  Within each group, the items are arranged by source order.</p>&#13;
&#13;
<p>This reordering is purely visual. Screen readers&#13;
<em>should</em> read the document as it appears in the source code, though they may not. As a visual&#13;
change, ordering flex items impacts the painting order of the page: the&#13;
painting order of the flex items is the order in which they appear, as&#13;
if they were reordered in the source document, even though they aren’t.</p>&#13;
&#13;
<p>Changing the layout with the <code>order</code> property has no effect on the tab&#13;
order of the page. If the numbers in <a data-type="xref" href="#flex-items-appear-ordinal">Figure 11-65</a> were links, tabbing through&#13;
the links would go through the links in the order of the source code, <em>not</em>&#13;
in the order of the layout.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tabbed Navigation Revisited" data-type="sect2"><div class="sect2" id="tabbed-navigation-revisited">&#13;
<h2>Tabbed Navigation Revisited</h2>&#13;
&#13;
<p>Adding to our tabbed navigation bar example in <a data-type="xref" href="#simple_tabbed_navigation">Figure 11-2</a>,&#13;
we can make the currently active tab appear first, as <a data-type="xref" href="#changing-order-tab">Figure 11-66</a> shows:</p>&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">display</code><code class="o">:</code><code> </code><code class="nb">flex</code><code class="p">;</code><code>&#13;
  </code><code class="k">justify-content</code><code class="o">:</code><code> </code><code class="nb">flex</code><code class="o">-</code><code class="n">end</code><code class="p">;</code><code>&#13;
  </code><code class="k">border-bottom</code><code class="o">:</code><code> </code><code class="m">1px</code><code> </code><code class="nb">solid</code><code> </code><code class="m">#ddd</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="nt">a</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">margin</code><code class="o">:</code><code> </code><code class="m">0</code><code> </code><code class="m">5px</code><code class="p">;</code><code>&#13;
  </code><code class="k">padding</code><code class="o">:</code><code> </code><code class="m">5px</code><code> </code><code class="m">15px</code><code class="p">;</code><code>&#13;
  </code><code class="k">border-radius</code><code class="o">:</code><code> </code><code class="m">3px</code><code> </code><code class="m">3px</code><code> </code><code class="m">0</code><code> </code><code class="m">0</code><code class="p">;</code><code>&#13;
  </code><code class="k">background-color</code><code class="o">:</code><code> </code><code class="m">#ddd</code><code class="p">;</code><code>&#13;
  </code><code class="k">text-decoration</code><code class="o">:</code><code> </code><code class="nb">none</code><code class="p">;</code><code>&#13;
  </code><code class="k">color</code><code class="o">:</code><code> </code><code class="nb">black</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="nt">a</code><code class="nd">:hover</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">background-color</code><code class="o">:</code><code> </code><code class="m">#bbb</code><code class="p">;</code><code>&#13;
  </code><code class="k">text-decoration</code><code class="o">:</code><code> </code><code class="nb">underline</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="nt">a</code><code class="nc">.active</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">order</code><code class="o">:</code><code> </code><code class="m">-1</code><code class="p">;</code><code>&#13;
  </code><code class="k">background-color</code><code class="o">:</code><code> </code><code class="m">#999</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="o">&lt;</code><code class="nt">nav</code><code class="o">&gt;</code><code>&#13;
  </code><code class="o">&lt;</code><code class="nt">a</code><code> </code><code class="nt">href</code><code class="o">=</code><code class="s2">"/"</code><code class="o">&gt;</code><code class="nt">Home</code><code class="o">&lt;</code><code class="o">/</code><code class="nt">a</code><code class="o">&gt;</code><code>&#13;
  </code><code class="o">&lt;</code><code class="nt">a</code><code> </code><code class="nt">href</code><code class="o">=</code><code class="s2">"/about"</code><code class="o">&gt;</code><code class="nt">About</code><code class="o">&lt;</code><code class="o">/</code><code class="nt">a</code><code class="o">&gt;</code><code>&#13;
  </code><strong><code class="o">&lt;</code><code class="nt">a</code><code> </code><code class="nt">class</code><code class="o">=</code><code class="s2">"active"</code><code class="o">&gt;</code><code class="nt">Blog</code><code class="o">&lt;</code><code class="o">/</code><code class="nt">a</code><code class="o">&gt;</code></strong><code>&#13;
  </code><code class="o">&lt;</code><code class="nt">a</code><code> </code><code class="nt">href</code><code class="o">=</code><code class="s2">"/jobs"</code><code class="o">&gt;</code><code class="nt">Careers</code><code class="o">&lt;</code><code class="o">/</code><code class="nt">a</code><code class="o">&gt;</code><code>&#13;
  </code><code class="o">&lt;</code><code class="nt">a</code><code> </code><code class="nt">href</code><code class="o">=</code><code class="s2">"/contact"</code><code class="o">&gt;</code><code class="nt">Contact</code><code> </code><code class="nt">Us</code><code class="o">&lt;</code><code class="o">/</code><code class="nt">a</code><code class="o">&gt;</code><code>&#13;
</code><code class="o">&lt;</code><code class="o">/</code><code class="nt">nav</code><code class="o">&gt;</code><code>&#13;
</code></pre>&#13;
&#13;
<figure><div class="figure" id="changing-order-tab">&#13;
<img alt="Changing the order will change the visual order, but not the tab order" src="assets/css5_1166.png"/>&#13;
<h6><span class="label">Figure 11-66. </span>Changing the order will change the visual order, but not the tab order <a class="play" href="https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-order-changes-visual-order.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></h6>&#13;
</div></figure>&#13;
&#13;
<p>The currently active tab has the <code>.active</code> class added, the <code>href</code>&#13;
attribute removed, and the <code>order</code> set to <code>-1</code>, which is less than the&#13;
default <code>0</code> of the other sibling flex items, meaning it appears first.</p>&#13;
&#13;
<p>Why did we remove the <code>href</code> attribute? As the tab is the currently&#13;
active document, there is no reason for the document to link to itself.&#13;
But, more importantly, if it was an active link instead of a placeholder&#13;
link, and the user was using the keyboard to tab through the navigation,&#13;
the order of appearance is Blog, Home, About, Careers, and&#13;
Contact Us, with the Blog appearing first; but the tab order would&#13;
have been Home, About, Blog, Careers, and Contact Us, following&#13;
the source order rather than the visual order, which can &#13;
<span class="keep-together">be confusing.</span></p>&#13;
&#13;
<p>The <code>order</code> property can be used to enable marking up the main content&#13;
area before the side columns for mobile devices and those using screen&#13;
readers and other assistive technology, while creating the appearance of&#13;
the common three-column layout: a center main content area, with site navigation&#13;
on the left and a sidebar on the right, as shown way back in <a data-type="xref" href="#set_diff_values">Figure 11-48</a>.</p>&#13;
&#13;
<p>While you can put your footer before your header in your markup, and use <code>order</code> to reorder the page, this is an inappropriate use&#13;
of the property. The <code>order</code> property should be used only for visual reordering&#13;
of content. Your underlying markup should always reflect the logical&#13;
order of your content.  Consider these two markup orders for the same content, shown here side by side to make comparing them easier:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;header&gt;&lt;/header&gt;</code><code class="w">               </code><code class="nt">&lt;header&gt;&lt;/header&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;main&gt;</code><code class="w">                          </code><code class="nt">&lt;main&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;article&gt;&lt;/article&gt;</code><code class="w">            </code><code class="nt">&lt;nav&gt;&lt;/nav&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;aside&gt;&lt;/aside&gt;</code><code class="w">                </code><code class="nt">&lt;article&gt;&lt;/article&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;nav&gt;&lt;/nav&gt;</code><code class="w">                    </code><code class="nt">&lt;aside&gt;&lt;/aside&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/main&gt;</code><code class="w">                         </code><code class="nt">&lt;/main&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;footer&gt;&lt;/footer&gt;</code><code class="w">               </code><code class="nt">&lt;footer&gt;&lt;/footer&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>We’ve been marking up websites in the order we want them to appear, as&#13;
shown on the right in the code example, which is the same code as&#13;
in our three-column layout example (<a data-type="xref" href="#set_diff_values">Figure 11-48</a>).</p>&#13;
&#13;
<p>It really would make more sense if we marked up the page as shown&#13;
on the left, with the <code>&lt;article&gt;</code> content, which is the main content,&#13;
first in the source order: this puts the article first for screen&#13;
readers, search engines, and even mobile devices, but in the middle for&#13;
our sighted users on larger screens:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">main</code> <code class="o">&gt;</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">-1</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>By using the <code>order: -1</code> declaration, we are able to make the <code>&lt;nav&gt;</code>&#13;
appear first, as it is the lone flex item in the ordinal group of <code>-1</code>.&#13;
The <code>&lt;article&gt;</code> and <code>&lt;aside&gt;</code>, with no <code>order</code> explicitly declared, default&#13;
to <code>order: 0</code>.</p>&#13;
&#13;
<p>Remember, when more than one flex item is in the same ordinal group,&#13;
the members of that group are displayed in source order in the direction&#13;
of main-start to main-end, so the <code>article</code> is displayed before the&#13;
<code>aside</code>.</p>&#13;
&#13;
<p>Some developers, when changing the order of at least one flex item, like&#13;
to give all flex items an <code>order</code> value for better markup readability.&#13;
We could have also written this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">main</code> <code class="o">&gt;</code> <code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">main</code> <code class="o">&gt;</code> <code class="nt">article</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">2</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">main</code> <code class="o">&gt;</code> <code class="nt">aside</code> <code class="p">{</code>&#13;
  <code class="k">order</code><code class="o">:</code> <code class="m">3</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In previous years, before browsers supported flex, all this could have&#13;
been done with floats: we would have set <code>float: right</code> on the <code>&lt;nav&gt;</code>.&#13;
While doable, flex layout makes this sort of layout much simpler, especially if we want&#13;
all three columns—the <code>&lt;aside&gt;</code>, <code>&lt;nav&gt;</code>, and <code>&lt;article&gt;</code>—to be of equal&#13;
heights.<a data-primary="" data-startref="ix_flex_items_ch11" data-type="indexterm" id="idm45176074700864"/><a data-primary="" data-startref="ix_flex_item_order" data-type="indexterm" id="idm45176074700064"/><a data-primary="" data-startref="ix_order_prop" data-type="indexterm" id="idm45176074699120"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45176075325392">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>With flexible box layout, you can lay out sibling elements in ways that are responsive to many layout contexts and writing modes, with a variety of options for arranging those elements and aligning them to one another.<a data-primary="" data-startref="ix_flexbox_ch11" data-type="indexterm" id="idm45176074697600"/>  It makes the task of vertically centering elements within their parent elements almost trivially easy, something that was very difficult in the years before flexbox.  It also serves as a powerfully useful bridge between normal-flow and grid layout, which is the subject of the next chapter.</p>&#13;
</div></section>&#13;
</div></section></body></html>