- en: Chapter 19\. Securing Applications in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 19 章 安全保护 Kubernetes 应用程序
- en: Providing a secure platform to run your workloads is critical for Kubernetes
    to be broadly used in production. Thankfully, Kubernetes ships with many different
    security-focused APIs that allow you to construct a secure operating environment.
    The challenge is that there are many different security APIs, and you have to
    declaratively opt-in to use them. Using these security-focused APIs can be cumbersome
    and convoluted, which makes it difficult to achieve your desired security goals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的工作负载提供一个安全平台对 Kubernetes 能够在生产环境中得到广泛应用至关重要。幸运的是，Kubernetes 集成了许多不同的安全焦点
    API，可以帮助你构建一个安全的操作环境。挑战在于有许多不同的安全 API，并且你必须声明性地选择使用它们。使用这些安全焦点 API 可能会很麻烦和复杂，这使得难以达到你期望的安全目标。
- en: 'It’s important to understand the following two concepts when securing Pods
    in Kubernetes: defense in depth and principle of least privilege. *Defense in
    depth* is a concept where you use multiple layers of security controls across
    your computing systems that include Kubernetes. The *principle of least privilege*
    means giving your workloads access only to resources that are required for them
    to operate. Both these concepts are not destinations, but constantly applied to
    the ever-changing computing system landscape.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在保护 Kubernetes 中的 Pod 时，理解以下两个概念非常重要：深度防御和最小权限原则。*深度防御* 是一个概念，它在包括 Kubernetes
    在内的计算系统上使用多层安全控制。*最小权限原则* 意味着只允许你的工作负载访问操作所需的资源。这两个概念不是终点，而是不断应用于不断变化的计算系统环境中。
- en: In this chapter, we will take a look at security-focused Kubernetes APIs that
    can be incrementally applied to help secure your workloads at the Pod level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨能够逐步应用于帮助在 Pod 级别保护你的工作负载的安全焦点 Kubernetes API。
- en: Understanding SecurityContext
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 SecurityContext
- en: 'At the core of securing Pods is SecurityContext, which is an aggregation of
    all security-focused fields that may be applied at both the Pod and container
    specification level. Here are some example security controls covered by SecurityContext:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在保护 Pod 的核心是 SecurityContext，它是可能应用在 Pod 和容器规范级别的所有安全焦点字段的汇总。以下是由 SecurityContext
    包含的一些示例安全控制：
- en: User permissions and access control (e.g., setting User ID and Group ID)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户权限和访问控制（例如，设置用户 ID 和组 ID）
- en: Read-only root filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读根文件系统
- en: Allow privilege escalation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许特权升级
- en: Seccomp, AppArmor, and SELinux profile and label assignments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Seccomp、AppArmor 和 SELinux 的配置文件和标签分配
- en: Run as privileged or unprivileged
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以特权或非特权方式运行
- en: Let’s take a look at an example Pod with a SecurityContext defined in [Example 19-1](#example1901).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在 [示例 19-1](#example1901) 中定义了 SecurityContext 的 Pod 示例。
- en: Example 19-1\. kuard-pod-securitycontext.yaml
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-1\. kuard-pod-securitycontext.yaml
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can see in this example that there is a SecurityContext at both the Pod
    and the container level. Many of the security controls can be applied at both
    of these levels. In the case that they are applied in both, the container level
    configuration takes precedence. Let’s take a look at fields we have defined in
    the Pod specification in this example and the impact they have on securing your
    workload:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个示例中看到，Pod 和容器级别都有一个 SecurityContext。许多安全控制可以同时应用在这两个级别。如果同时在这两个级别应用，容器级别的配置会优先生效。让我们看看在这个示例中我们在
    Pod 规范中定义的字段以及它们对保护你的工作负载的影响：
- en: '`runAsNonRoot`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`runAsNonRoot`'
- en: The Pod or container must run as a nonroot user. The container will fail to
    start if it is running as a root user. Running as a nonroot user is considered
    best practice as many misconfigurations and exploits happen via the container
    runtime conflating the container process running as the root user with the host
    root user. This can be set at both the PodSecurityContext and the SecurityContext.
    The kuard container image is configured to run as user “nobody” as defined in
    the [Dockerfile](https://oreil.ly/4IZI7). It’s always best practice to run your
    container as a nonroot user; however, if you are running a container downloaded
    from another source that doesn’t explicitly set the container user, you may have
    to extend the original Dockerfile to do so. This method doesn’t always work, as
    the application may have other requirements that needs to be considered.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 或容器必须作为非根用户运行。如果以根用户身份运行，容器将无法启动。作为非根用户运行被认为是最佳实践，因为许多错误配置和漏洞都是由于容器运行时将容器进程误认为与主机根用户相同而发生的。这可以在
    PodSecurityContext 和 SecurityContext 中设置。kuard 容器镜像被配置为以 [Dockerfile](https://oreil.ly/4IZI7)
    中定义的用户 "nobody" 运行。以非根用户身份运行您的容器始终是最佳实践；然而，如果您正在运行从其他来源下载的容器，而该容器未明确设置容器用户，则可能需要扩展原始
    Dockerfile 来进行设置。这种方法并不总是有效，因为应用程序可能有其他需要考虑的要求。
- en: '`runAsUser/runAsGroup`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`runAsUser/runAsGroup`'
- en: This setting overrides the user and group that the container process is run
    as. Container images may have this configured as part of the Dockerfile.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置将覆盖容器进程的用户和组。容器镜像可能已经在 Dockerfile 中配置了这一点。
- en: '`fsgroup`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsgroup`'
- en: Configures Kubernetes to change the group of all files in a volume when they
    are mounted into a Pod. An additional field, `fsGroupChangePolicy`, may be used
    to configure the exact behavior.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Kubernetes 在将卷挂载到 Pod 时更改所有文件的组。可以使用额外字段 `fsGroupChangePolicy` 来配置确切的行为。
- en: '`allowPrivilegeEscalation`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowPrivilegeEscalation`'
- en: 'Configures whether a process in a container can gain more privileges than its
    parent. This is a common vector for attack, and it’s important to explicitly set
    this to false. It’s also important to understand that this will be set to true
    if `privileged: true` is set.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '配置容器中的进程是否可以获得比其父进程更多的特权。这是一种常见的攻击向量，重要的是要显式地将其设置为 false。如果设置了 `privileged:
    true`，它将设置为 true 也很重要。'
- en: '`privileged`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`privileged`'
- en: Runs the container as privileged, which elevates the container to the same permissions
    as the host.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以特权方式运行容器，这将提升容器到与主机相同的权限。
- en: '`readOnlyRootFilesystem`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`readOnlyRootFilesystem`'
- en: Mounts the container root filesystem to read-only. This is a common attack vector
    and is best practice to enable. Any data or logs that the workloads need write
    access to can be mounted via a volume.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器根文件系统挂载为只读。这是一个常见的攻击向量，并且是一种最佳实践。工作负载需要写访问权限的任何数据或日志可以通过卷进行挂载。
- en: The fields in this example aren’t a complete list of all the security controls
    available; however, they represent a good starting point when working with SecurityContext.
    We will cover some more in context later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的字段并不是所有可用安全控制的完整列表；然而，在使用 SecurityContext 时，它们代表了一个很好的起点。我们将在本章后面的上下文中进一步介绍一些内容。
- en: 'Let’s now create the Pod by saving this example to a file called *kuard-pod-securitycontext.yaml*.
    We will demonstrate how the SecurityContext configuration is being applied to
    a running Pod. Create the Pod using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过将此示例保存到名为 *kuard-pod-securitycontext.yaml* 的文件中来创建 Pod。我们将演示如何将 SecurityContext
    配置应用于正在运行的 Pod。使用以下命令创建 Pod：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we’ll start a shell inside the kuard container and check which user ID
    and group ID the processes are running as:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在 kuard 容器内启动一个 shell 并检查进程正在以哪个用户 ID 和组 ID 运行：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that the shell that we started, `ash`, is running as user ID (uid)
    1000, group ID (gid) 3000, and is in group 2000\. We can also see that the `kuard`
    process is running as user 1000 as defined by the SecurityContext in the Pod specification.
    We also confirmed that we aren’t able to create any new files because the container
    is read-only. If you only apply the following changes to you workloads, you’re
    already off to a great start.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们启动的 shell `ash` 正在以用户 ID（uid）1000、组 ID（gid）3000 运行，并且在组 2000 中。我们还可以看到
    `kuard` 进程正如 Pod 规范中 SecurityContext 定义的那样以用户 1000 运行。我们还确认无法创建任何新文件，因为容器是只读的。如果您的工作负载仅应用以下更改，您已经迈出了良好的开端。
- en: 'We will now introduce several other security controls covered by SecurityContext,
    which enable even more fine-grained control over what access and privileges your
    workloads have. First, we will introduce the operating system level security controls
    and then how to configure them via SecurityContext. It’s important to note that
    many of these controls are host operating system dependent. This means that they
    may only apply to containers running on Linux operating systems as opposed to
    other supported Kubernetes operating systems like Windows. Here are a list of
    the core set of operating system controls that are covered by SecurityContext:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍由SecurityContext覆盖的其他几个安全控件，这些控件可以更精细地控制您的工作负载的访问和特权。首先，我们将介绍操作系统级别的安全控制，然后介绍如何通过SecurityContext进行配置。需要注意的是，许多这些控件依赖于主机操作系统。这意味着它们可能仅适用于在Linux操作系统上运行的容器，而不适用于其他支持的Kubernetes操作系统，如Windows。以下是由SecurityContext覆盖的核心操作系统控件列表：
- en: Capabilities
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Capabilities
- en: Allow either the addition or removal of groups of privilege that may be required
    for a workload to operate. For example, your workload may configure the host’s
    network configuration. Rather than configuring the Pod to be privileged, which
    is effectively host root access, you could add the specific capability to configure
    the host networking configuration (NET_ADMIN is the specific capability name).
    This follows the principal of least privilege.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 允许添加或删除可能需要的特权组。例如，您的工作负载可能配置主机的网络配置。与其配置Pod以获取特权访问，即实际上是主机根访问权限，您可以添加特定的能力来配置主机的网络配置（NET_ADMIN是特定的能力名称）。这遵循最小权限原则。
- en: AppArmor
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor
- en: 'Controls which files processes can access. AppArmor profiles can be applied
    to containers via the addition of an annotation of `container.apparmor.security.beta.kubernetes.io/<container_name>:
    <profile_ref>` to the Pod specification. Acceptable values for `<profile ref>`
    include `runtime/default`, `localhost/<path to profile>`, and `unconfined`. The
    default is `unconfined`, which explicitly sets no profile to be applied.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '控制进程可以访问哪些文件。通过将`container.apparmor.security.beta.kubernetes.io/<container_name>:
    <profile_ref>`的注释添加到Pod规范中，可以将AppArmor配置文件应用于容器。`<profile_ref>`的可接受值包括`runtime/default`、`localhost/<path
    to profile>`和`unconfined`。默认值为`unconfined`，这明确设置了不应用任何配置文件。'
- en: Seccomp
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Seccomp
- en: Seccomp (secure computing) profiles allow the creation of syscall filters. These
    filters allow specific syscalls to be allowed or blocked, which limits the surface
    area of the Linux kernel that is exposed to the processes in the Pods.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Seccomp（安全计算）配置文件允许创建系统调用过滤器。这些过滤器允许允许或阻止特定的系统调用，从而限制在Pod中的进程向Linux内核暴露的表面积。
- en: SELinux
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux
- en: Defines access controls for files and processes. SELinux operators use labels
    that are grouped together to create a security context (not to be mistaken with
    a Kubernetes SecurityContext), which is used to limit access to a process. By
    default, Kubernetes allocates a random SELinux context for each container; however,
    you may choose to set one via SecurityContext.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 定义文件和进程的访问控制。SELinux运算符使用标签将其组合，以创建一个安全上下文（不要与Kubernetes SecurityContext混淆），用于限制对进程的访问。默认情况下，Kubernetes为每个容器分配一个随机的SELinux上下文；但是，您可以选择通过SecurityContext设置一个上下文。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Both AppArmor and seccomp have the ability to set the runtime default profile
    to be used. Each container runtime ships with default AppArmor and seccomp profiles
    that have been carefully curated to reduce the attack surface area by removing
    syscalls and file access that are known to be attack vectors or aren’t commonly
    used by applications. These defaults are rarely workload impacting and offer a
    great starting point.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor和Seccomp都可以设置用于运行时默认配置文件。每个容器运行时都附带了经过精心策划的默认AppArmor和Seccomp配置文件，以减少攻击面积，通过删除已知的系统调用和文件访问攻击向量或不常用于应用程序的方式。
- en: To demonstrate how these security controls are applied to a Pod, we will use
    a tool called [amicontained](https://oreil.ly/6ubkU) (“Am I contained”) written
    by Jess Frazelle. Save the Pod specification in [Example 19-2](#example1902) to
    a file called *amicontained-pod.yaml*. The first Pod has no SecurityContext applied
    and will be used to show which security controls are applied to a Pod by default.
    Note that your output may look different because different Kubernetes distributions
    and managed services provide different defaults.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要演示这些安全控制是如何应用于 Pod 的，我们将使用一个名为 [amicontained](https://oreil.ly/6ubkU)（“Am I
    contained”）的工具，由Jess Frazelle编写。将 Pod 的规范保存在 [Example 19-2](#example1902) 中，保存为
    *amicontained-pod.yaml* 文件。第一个 Pod 没有应用安全上下文，并将用于显示默认情况下对 Pod 应用的安全控制。请注意，由于不同的
    Kubernetes 发行版和托管服务提供了不同的默认值，您的输出可能会有所不同。
- en: Example 19-2\. amicontained-pod.yaml
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-2\. amicontained-pod.yaml
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the `amicontainer` Pod:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `amicontainer` Pod：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s review the Pod logs to examine the output of the `amicontained` tool:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看 Pod 日志，以检查 `amicontained` 工具的输出：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the output above we see that the AppArmor runtime default is being applied.
    We also see the capabilities that are allowed by default along with seccomp being
    disabled. Finally, we see that a total of 21 syscalls are being blocked by default.
    Now that we have a baseline, let’s apply seccomp, AppArmor, and Capabilities security
    controls to the Pod specification. Create a file called *amicontained-pod-securitycontext.yaml*
    with the contents of [Example 19-3](#example1903).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中，我们看到正在应用 AppArmor 运行时默认配置。我们还可以看到默认情况下允许的功能以及禁用的 seccomp。最后，我们看到默认情况下阻止了
    21 个系统调用。现在我们有了一个基准，让我们将 seccomp、AppArmor 和功能安全控制应用于 Pod 规范。创建一个名为 *amicontained-pod-securitycontext.yaml*
    的文件，内容来自 [Example 19-3](#example1903)。
- en: Example 19-3\. amicontained-pod-securitycontext.yaml
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-3\. amicontained-pod-securitycontext.yaml
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, we need to delete the existing `amicontained` Pod:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要删除现有的 `amicontained` Pod：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can create the new Pod with the SecurityContext applied. We are specifically
    declaring that the runtime default AppArmor and seccomp profiles be applied. In
    addition, we have added and dropped a Capability:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个新的 Pod，并应用安全上下文。我们明确声明要应用运行时默认的 AppArmor 和 seccomp 配置文件。此外，我们还添加和删除了一个功能：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s again review the Pod logs to examine the output of the `amicontained`
    tool:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看 Pod 日志，以检查 `amicontained` 工具的输出：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: SecurityContext Challenges
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全上下文挑战
- en: As you can see, there is a lot to understand to use a SecurityContext, and it
    is not easy to apply a baseline set of security controls by directly configuring
    all fields of every Pod. The creation and management of AppArmor, seccomp, and
    SELinux profiles and contexts is not easy and is error prone. The cost of an error
    is breaking the ability for an application to perform its function. There are
    several tools out there that create a way to generate a seccomp profile from a
    running Pod, which can then be applied using SecurityContext. One such project
    is the [Security Profiles Operator](https://oreil.ly/grPCN), which makes it easy
    to generate and manage Seccomp profiles. We will now take a look at other security
    APIs that make the management of how SecurityContext is applied consistent across
    a cluster.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，要使用 SecurityContext，需要理解很多内容，并且直接配置每个 Pod 的所有字段来应用基线安全控制并不容易。创建和管理 AppArmor、seccomp
    和 SELinux 配置和上下文并非易事，且容易出错。出错的代价是破坏应用程序执行功能的能力。有几种工具可以生成运行中 Pod 的 seccomp 配置文件，并使用
    SecurityContext 应用。其中一个项目是 [Security Profiles Operator](https://oreil.ly/grPCN)，它可以轻松生成和管理
    Seccomp 配置文件。现在让我们看看其他安全 API，这些 API 可以确保在整个集群中一致地应用 SecurityContext。
- en: Pod Security
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod 安全
- en: Now that we’ve taken a look at SecurityContext as a way to manage security controls
    applied to Pods and containers, we will cover how to make sure that a set of Securi⁠ty​Context
    values are applied at scale. Kubernetes has a now-deprecated PodSecurityPolicy
    (PSP) API, which enabled both validation and mutation. *Validation* will not allow
    the creation of Kubernetes resources unless they have a specific SecurityContext
    applied. *Mutation*, on the other hand, will change Kubernetes resources and apply
    a specific SecurityContext based on criteria applied via the PSP. Given that PSP
    is deprecated and will be removed in Kubernetes v1.25, we will not cover it in
    depth but will instead cover its successor, Pod Security. One of the main differences
    between Pod Security and its predecessor is that Pod Security only performs validation
    and not mutation. If you want to learn more about mutation, we encourage you to
    take a look at [Chapter 20](ch20.xhtml#policy_and_governance_for_kubernetes_clusters).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了SecurityContext作为管理应用于Pod和容器的安全控制的方法，接下来我们将介绍如何确保一组SecurityContext值在规模应用。Kubernetes有一个现已弃用的PodSecurityPolicy（PSP）API，它可以进行验证和变异。*验证*将不允许创建Kubernetes资源，除非它们具有特定的SecurityContext。另一方面，*变异*将改变Kubernetes资源，并根据通过PSP应用的标准应用特定的SecurityContext。鉴于PSP已弃用，并将在Kubernetes
    v1.25中删除，我们不会深入讨论它，而是会介绍其继任者Pod Security。Pod Security与其前身的主要区别之一是，Pod Security仅执行验证而不执行变异。如果您想了解更多关于变异的信息，我们鼓励您查看[第20章](ch20.xhtml#policy_and_governance_for_kubernetes_clusters)。
- en: What Is Pod Security?
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是Pod安全？
- en: 'Pod Security allows you to declare different security profiles for Pods. These
    security profiles are known as Pod Security Standards and are applied at the namespace
    level. Pod Security Standards are a collection of security-sensitive fields in
    a Pod specification (including, but not limited to, SecurityContext) and their
    associated values. There are three different standards that range from restricted
    to permissive. The idea is that you can apply a general security posture to all
    Pods in a given namespace. The three Pod Security Standards are as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Pod Security允许您为Pod声明不同的安全配置文件。这些安全配置文件称为Pod安全标准，并应用于命名空间级别。Pod安全标准是Pod规范中一组安全敏感字段（包括但不限于SecurityContext）及其关联值的集合。有三种不同的标准，从受限到宽松不等。其理念是您可以将一般的安全姿态应用于给定命名空间中的所有Pod。三种Pod安全标准如下：
- en: Baseline
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基线
- en: Most common privilege escalation while enabling easier onboarding.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的权限升级，同时支持更简易的入门。
- en: Restricted
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 受限
- en: Highly restricted, covering security best practices. May cause workloads to
    break.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 高度限制，涵盖安全最佳实践。可能导致工作负载中断。
- en: Privileged
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 特权
- en: Open and unrestricted.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 开放和无限制。
- en: Warning
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Pod Security is currently a beta feature as of Kubernetes v1.23 and may be subject
    to change.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Kubernetes v1.23，Pod Security目前是一个测试功能，可能会有所更改。
- en: 'Each Pod Security Standard defines a list of fields in the Pod specification
    and their allowed values. Here are some fields that are covered by these standards:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod安全标准定义了Pod规范中一组字段及其允许的值。以下是这些标准涵盖的一些字段：
- en: '`spec.securityContext`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.securityContext`'
- en: '`spec.containers[*].securityContext`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers[*].securityContext`'
- en: '`spec.containers[*].ports`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers[*].ports`'
- en: '`spec.volumes[*].hostPath`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.volumes[*].hostPath`'
- en: You can view the complete list of fields covered by each of the Pod Security
    Standards in the [offical documentation](https://oreil.ly/xPK2p).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[官方文档](https://oreil.ly/xPK2p)中查看每个Pod安全标准涵盖的完整字段列表。
- en: 'Each standard is applied to a namespace using a given mode. There are three
    modes a policy may be applied to. They are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标准都适用于命名空间，采用给定的模式。策略可以适用于三种模式。它们如下所示：
- en: Enforce
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 执行
- en: Any Pods that violate the policy will be denied.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 任何违反策略的Pod将被拒绝。
- en: Warn
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Any Pods that violate the policy will be allowed, and a warning message will
    be displayed to the user.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 任何违反策略的Pod将被允许，并向用户显示警告消息。
- en: Audit
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 审核
- en: Any Pods that violate the policy will generate an audit message in the audit
    log.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 任何违反策略的Pod将在审计日志中生成审计消息。
- en: Applying Pod Security Standards
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用Pod安全标准
- en: 'Pod Security Standards are applied to a namespace using labels as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签将Pod安全标准应用于命名空间：
- en: 'Required: `pod-security.kubernetes.io/<MODE>: <LEVEL>`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '必需：`pod-security.kubernetes.io/<MODE>: <LEVEL>`'
- en: 'Optional: `pod-security.kubernetes.io/<MODE>-version: <VERSION>` (defaults
    to latest)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '可选：`pod-security.kubernetes.io/<MODE>-version: <VERSION>`（默认为最新）'
- en: The namespace in [Example 19-4](#example1904) illustrates how you may use multiple
    modes to enforce at one standard (baseline in this example) and audit and warn
    at another (restricted). Using multiple modes allows you to deploy a policy with
    a lower security posture and audit which workloads violate a standard with a more
    restricted policy. You can then remediate the policy violations before enforcing
    the more restricted standard. You can also pin a mode to a specific version, e.g.,
    v1.22\. This allows the policy standards to change with each Kubernetes release
    and allows you to pin a specific version. In [Example 19-4](#example1904), we
    are enforcing the baseline standard and both warning and auditing the restricted
    standard. All modes are pinned to v1.22 of the standard.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 19-4](#example1904) 中的命名空间说明了如何同时使用多种模式来强制执行一个标准（例如本示例中的基线）并在另一个标准（受限）上进行审计和警告。使用多种模式可以让您以较低的安全姿态部署策略，并审计哪些工作负载违反了更严格的策略。然后，您可以在强制执行更严格的标准之前纠正策略违规。您还可以将模式固定到特定版本，例如
    v1.22\. 这允许策略标准随每个 Kubernetes 版本的发布而变化，并允许您固定到特定版本。在 [示例 19-4](#example1904) 中，我们正在强制执行基线标准，并同时警告和审计受限标准。所有模式都固定到标准的
    v1.22 版本。
- en: Example 19-4\. baseline-ns.yaml
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-4\. baseline-ns.yaml
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Deploying a policy for the first time can be a daunting task. Thankfully, Pod
    Security has made it easy to see which existing workloads violate a Pod Security
    Standard with a single dry-run command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首次部署策略可能是一项令人生畏的任务。幸运的是，Pod 安全性通过单个 dry-run 命令使得查看现有工作负载是否违反 Pod 安全标准变得简单：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command evaluates all Pods on a Kubernetes cluster against the baseline
    Pod Security Standard and reports violations as warning messages in the output.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令评估 Kubernetes 集群中所有 Pod 是否符合基线 Pod 安全标准，并将违规项作为警告消息输出。
- en: Let’s see Pod Security in action. Create a file called *baseline-ns.yaml* with
    the content in [Example 19-5](#example1905).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Pod 安全性的实际操作。创建一个名为 *baseline-ns.yaml* 的文件，并使用 [示例 19-5](#example1905)
    中的内容。
- en: Example 19-5\. baseline-ns.yaml
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-5\. baseline-ns.yaml
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create a file called *kuard-pod.yaml* with the content in [Example 19-6](#example1906).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *kuard-pod.yaml* 的文件，并使用 [示例 19-6](#example1906) 中的内容。
- en: Example 19-6\. kuard-pod.yaml
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-6\. kuard-pod.yaml
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the Pod and review the output with the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建 Pod 并查看输出：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this output, you can see that the Pod was successfully created; however,
    it violated the restricted Pod Security Standard, and the details of the violations
    are provided in the output so that you can remediate. We can also see the message
    in the API server audit log because we configured the audit mode:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，您可以看到 Pod 已成功创建；然而，它违反了受限的 Pod 安全标准，并且输出中提供了违规的详细信息，以便您进行纠正。我们还可以看到 API
    服务器审计日志中的消息，因为我们配置了审计模式：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pod Security is a great way to manage the security posture of your workloads
    by applying policy at the namespace level and allowing Pods to be created only
    if they don’t violate the policy. It’s flexible and offers different prebuilt
    policies from permissive to restricted along with tooling to easily roll out policy
    changes without the risk of breaking workloads.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 安全性是通过在命名空间级别应用策略来管理工作负载的安全姿态的一种绝佳方式，并且只有在不违反策略的情况下才允许创建 Pod。它灵活且提供不同的预构建策略，从宽松到受限，以及工具支持，可以轻松地推出策略更改，而无需担心破坏工作负载的风险。
- en: Service Account Management
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务账户管理
- en: 'Service accounts are Kubernetes resources that provide an identity to workloads
    that run inside Pods. RBAC can be applied to service accounts to control what
    resources, via the Kubernetes API, the identity has access to. Please see [Chapter 14](ch14.xhtml#chapterbac_id)
    to learn more. If your application doesn’t require access to the Kubernetes API,
    you should disable access following the least privilege principal. By default,
    Kubernetes creates a default service account in each namespace, which is automatically
    set as the service account for all Pods. This service account contains a token
    that is automounted in each Pod and is used to access the Kubernetes API. To disable
    this behavior, you must add `automountServiceAccountToken: false` to the service
    account configuration. [Example 19-7](#example1907) demonstrates how this can
    be done for the default service account. This must be done in each namespace.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'Service accounts 是 Kubernetes 资源，为运行在 Pod 内部的工作负载提供身份。RBAC 可以应用于 service accounts，以控制通过
    Kubernetes API 身份可以访问的资源。请参阅 [第 14 章](ch14.xhtml#chapterbac_id) 了解更多信息。如果您的应用程序不需要访问
    Kubernetes API，则应按最小权限原则禁用访问。默认情况下，Kubernetes 在每个命名空间中创建一个默认的 service account，并自动将其设置为所有
    Pods 的 service account。该 service account 包含一个在每个 Pod 中自动挂载的令牌，用于访问 Kubernetes
    API。要禁用此行为，必须将 `automountServiceAccountToken: false` 添加到 service account 配置中。[示例 19-7](#example1907)
    演示了如何为默认 service account 进行此操作。这必须在每个命名空间中完成。'
- en: Example 19-7\. service-account.yaml
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-7\. service-account.yaml
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Service accounts are often overlooked when considering Pod security; however,
    they allow direct access to the Kubernetes API and, without adequate RBAC, could
    allow an attacker access to Kubernetes. It’s important to understand how to limit
    access by making a simple change to how service account tokens are handled.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑 Pod 安全性时，人们经常忽略 service accounts；然而，它们允许直接访问 Kubernetes API，并且在没有足够的 RBAC
    的情况下，可能允许攻击者访问 Kubernetes。重要的是要了解如何通过简单地更改 service account 令牌处理方式来限制访问。
- en: Role-Based Access Control
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: We would be remiss not to mention Kubernetes role-based access control (RBAC)
    in a chapter about securing Pods. Everything you need to know about RBAC can be
    found in [Chapter 14](ch14.xhtml#chapterbac_id) and can be applied to complement
    you workload’s security posture.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论保护 Pods 的章节中，我们不得不提到 Kubernetes 基于角色的访问控制（RBAC）。您可以在 [第 14 章](ch14.xhtml#chapterbac_id)
    找到有关 RBAC 的所有信息，并可以应用于补充工作负载的安全策略。
- en: RuntimeClass
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RuntimeClass
- en: Kubernetes interacts with the container runtime on the node’s operating system
    via the Container Runtime Interface (CRI). The creation and standardization of
    this interface has allowed for an ecosystem of container runtimes to exist. These
    container runtimes may offer different levels of isolation, which include stronger
    security guarantees based on how they are implemented. Projects like Kata Containers,
    Firecracker, and gVisor are based on different isolation mechanisms from nested
    virtualization to more sophisticated syscall filtering. These security and isolation
    guarantees provide a Kubernetes administrator the flexibility to allow users to
    select a container runtime based on their workload type. For example, if your
    workload needs stronger security guarantees, then you can choose to run in a Pod
    that uses a different container runtime.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过容器运行时接口（CRI）与节点操作系统上的容器运行时进行交互。该接口的创建和标准化使得容器运行时生态系统得以存在。这些容器运行时可能提供不同级别的隔离，包括基于实现方式的更强安全性保证。像
    Kata Containers、Firecracker 和 gVisor 这样的项目基于不同的隔离机制，从嵌套虚拟化到更复杂的系统调用过滤。这些安全和隔离保证为
    Kubernetes 管理员提供了灵活性，使用户可以根据其工作负载类型选择容器运行时。例如，如果您的工作负载需要更强的安全保证，则可以选择在使用不同容器运行时的
    Pod 中运行。
- en: The RuntimeClass API was introduced to allow container runtime selection. It
    allows users to select one of a supported list of container runtimes in the cluster.
    [Figure 19-1](#fig1901) depicts how RuntimeClass functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: RuntimeClass API 被引入以允许选择容器运行时。它允许用户从集群中支持的容器运行时列表中选择一个。[图 19-1](#fig1901) 展示了
    RuntimeClass 的功能。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Different RuntimeClasses must be configured by a cluster administrator and may
    required specific `nodeSelectors` or `tolerations` on your workload to be scheduled
    to the correct node.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的 RuntimeClasses 必须由集群管理员配置，并且可能需要在您的工作负载上配置特定的 `nodeSelectors` 或 `tolerations`
    才能被调度到正确的节点。
- en: '![kur3 1901](assets/kur3_1901.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![kur3 1901](assets/kur3_1901.png)'
- en: Figure 19-1\. `RuntimeClass` flow diagram
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-1\. `RuntimeClass` 流程图
- en: You can use a RuntimeClass by specifying `runtimeClassName` in the Pod specification.
    [Example 19-8](#example1912) is an example Pod that specifies a RuntimeClass.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Pod规范中指定`runtimeClassName`来使用RuntimeClass。示例 19-8是一个指定RuntimeClass的示例Pod。
- en: Example 19-8\. kuard-pod-runtimeclass.yaml
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-8\. kuard-pod-runtimeclass.yaml
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: RuntimeClass allows users to select different container runtimes that may have
    different security isolation. Using RuntimeClass can help complement the overall
    security of your workloads, especially if workloads are processing sensitive information
    or running untrusted code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: RuntimeClass允许用户选择不同的容器运行时，这些运行时可能具有不同的安全隔离。使用RuntimeClass可以帮助补充工作负载的整体安全性，特别是当工作负载处理敏感信息或运行不受信任的代码时。
- en: Network Policy
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Network Policy
- en: Kubernetes also has a Network Policy API that allows you to create both ingress
    and egress network policies for your workload. Network policies are configured
    using labels that allow you to select specific Pods and define how they can communicate
    with other Pods and endpoints. A Network Policy like Ingress doesn’t actually
    ship with an associated Kubernetes controller. This means that you can create
    Network Policy resources but if you haven’t installed a controller that acts upon
    the creation of Network Policy resources, then they will not be enforced. Network
    Policy resources are implemented by network plug-ins, such as Calico, Cilium,
    and Weave Net.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes也有一个Network Policy API，允许您为工作负载创建入口和出口网络策略。网络策略使用标签进行配置，这些标签允许您选择特定的Pod，并定义它们如何与其他Pod和端点通信。例如，Ingress这样的Network
    Policy实际上没有与之关联的Kubernetes控制器。这意味着您可以创建Network Policy资源，但如果您没有安装一个响应Network Policy资源创建的控制器，那么它们将不会被执行。Network
    Policy资源由网络插件（如Calico、Cilium和Weave Net）实现。
- en: The Network Policy resource is namespaced and is structured with the `podSelector`,
    `policyTypes`, `ingress`, and `egress` sections with the only required field being
    `pod​Se⁠lector`. If the `podSelector` field is empty, the policy matches all Pods
    in a namespace. This field may also contain a `matchLabels` section, which functions
    in the same way as a Service resource, allowing you to add a set of labels to
    match a specific set of Pods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Network Policy资源是有命名空间的，并且由`podSelector`、`policyTypes`、`ingress`和`egress`部分组成，其中唯一需要的字段是`podSelector`。如果`podSelector`字段为空，则该策略匹配命名空间中的所有Pod。此字段还可以包含一个`matchLabels`部分，其功能与Service资源相同，允许您添加一组标签以匹配特定的一组Pod。
- en: There are several idiosyncrasies when using Network Policy that you need to
    be aware of. If a Pod is matched by any Network Policy resource, then any ingress
    or egress communication must be explicitly defined, otherwise it will be blocked.
    If a Pod matches multiple Network Policy resources, then the policies are additive.
    If a Pod isn’t matched by any Network Policy, then traffic is allowed. This decision
    was intentionally made to ease onboarding of new workloads. If you do, however,
    want all traffic to be blocked by default, you can create a default deny rule
    per namespace. [Example 19-9](#example1908) shows a default deny rule that can
    be applied per namespace.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Network Policy时有几个需要注意的特殊情况。如果一个Pod匹配任何Network Policy资源，则必须显式定义任何入口或出口通信，否则将被阻止。如果一个Pod匹配多个Network
    Policy资源，则策略是叠加的。如果一个Pod没有匹配任何Network Policy，则允许流量。这个决定是有意为之，以便简化新工作负载的接入。然而，如果您确实希望默认情况下阻止所有流量，您可以为每个命名空间创建一个默认拒绝规则。示例 19-9展示了一个可以应用于每个命名空间的默认拒绝规则。
- en: Example 19-9\. networkpolicy-default-deny.yaml
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-9\. networkpolicy-default-deny.yaml
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s walk through an example set of network policies to demonstrate how you
    can use them to secure your workloads. First, create a namespace to test using
    the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一组网络策略示例来演示如何使用它们来保护您的工作负载。首先，使用以下命令创建一个测试命名空间：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create a file named *kuard-pod.yaml* with the contents of [Example 19-10](#example1909).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名为*kuard-pod.yaml*的文件，其中包含示例 19-10的内容。
- en: Example 19-10\. kuard-pod.yaml
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-10\. kuard-pod.yaml
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the `kuard` Pod in the `kuard-networkpolicy` namespace:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kuard-networkpolicy`命名空间中创建`kuard` Pod：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Expose the `kuard` Pod as a service:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将`kuard` Pod公开为服务：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can use `kubectl run` to spin up a Pod to test as our source and test
    access to the `kuard` Pod without applying any Network Policy:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`kubectl run`来启动一个Pod作为我们的源，并测试访问`kuard` Pod，而不应用任何Network Policy：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can successfully connect to the `kuard` Pod from our test-source Pod. Now
    let’s apply a default deny policy and test again. Create a file called *networkpolicy-default-deny.yaml*
    with the contents of [Example 19-11](#example1910).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以成功从我们的测试源 Pod 连接到 `kuard` Pod。现在让我们应用默认拒绝策略并再次测试。创建一个名为 *networkpolicy-default-deny.yaml*
    的文件，并包含 [示例 19-11](#example1910) 的内容。
- en: Example 19-11\. networkpolicy-default-deny.yaml
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-11\. networkpolicy-default-deny.yaml
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now apply the default deny network policy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用默认拒绝网络策略：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let’s test access to the `kuard` Pod from the test-source Pod:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试从测试源 Pod 访问 `kuard` Pod：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can no longer access the `kuard` Pod from the test-source Pod due to the
    default deny Network Policy. Create a Network Policy that allows access from the
    test-source to the `kuard` Pod. Create a file called *networkpolicy-kuard-allow-test-source.yaml*
    with the contents of [Example 19-12](#example1911).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认拒绝的网络策略，我们无法再从测试源 Pod 访问 `kuard` Pod。创建一个允许测试源访问 `kuard` Pod 的网络策略。创建一个名为
    *networkpolicy-kuard-allow-test-source.yaml* 的文件，并包含 [示例 19-12](#example1911)
    的内容。
- en: Example 19-12\. networkpolicy-kuard-allow-test-source.yaml
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-12\. networkpolicy-kuard-allow-test-source.yaml
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Apply the Network Policy:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 应用网络策略：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, verify that the test-source Pod can indeed access the `kuard` Pod:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次验证测试源 Pod 确实可以访问 `kuard` Pod：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Clean up the namespace by running the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令清理命名空间：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Applying Network Policy provides an extra layer of security for your workloads
    and continues to build on the defense in depth and principle of least privilege
    concepts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 应用网络策略为您的工作负载提供额外的安全层，并继续构建深度防御和最小特权原则的概念。
- en: Service Mesh
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格
- en: Service mesh can also be used to increase your workload’s security posture.
    Service meshes offer access policies, which allow the configuration of protocol-aware
    policies based on services. For example, your access policy might declare that
    ServiceA connects to ServiceB via HTTPS on port 443\. In addition, service meshes
    typically implement mutual TLS on all service-to-service communication, which
    means that not only is the communication encrypted but the service identities
    are also verified. If you would like to learn more about service meshes and how
    they can be used to secure your workloads, check out [Chapter 15](ch15.xhtml#service_mesh).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格还可以用于增强工作负载的安全性姿态。服务网格提供访问策略，允许基于服务配置协议感知策略。例如，您的访问策略可能声明 ServiceA 通过 HTTPS
    在 443 端口连接到 ServiceB。此外，服务网格通常在所有服务间通信上实施双向 TLS，这意味着通信不仅加密，而且还验证了服务身份。如果您想了解更多关于服务网格如何用于保护工作负载的信息，请查看
    [第 15 章](ch15.xhtml#service_mesh)。
- en: Security Benchmark Tools
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全基准工具
- en: 'There are several open source tools that allow you to run a suite of security
    benchmarks against your Kubernetes cluster to determine if your configuration
    meets a predefined set of security baselines. Once such tool is called [`kube-bench`](https://oreil.ly/TnUlm).
    `kube-bench` can be used to run the [CIS Benchmarks](https://oreil.ly/VvUe5) for
    Kubernetes. Tools like `kube-bench` running the CIS Benchmarks aren’t specifically
    focused on Pod security; however, they can certainly expose any cluster misconfigurations
    and help identify remediations. `kube-bench` can be run using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个开源工具允许您针对 Kubernetes 集群运行一系列安全基准测试，以确定您的配置是否符合预定义的安全基线。其中一种工具称为 [`kube-bench`](https://oreil.ly/TnUlm)。`kube-bench`
    可用于运行 [CIS 基准](https://oreil.ly/VvUe5)。像 `kube-bench` 运行 CIS 基准并不专门关注 Pod 安全性；然而，它确实可以暴露任何集群配置错误并帮助确定修复措施。您可以使用以下命令运行
    `kube-bench`：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can then review the benchmark output and remediations via the Pod logs:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过 Pod 日志查看基准输出和修复措施：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using tools like `kube-bench` with the CIS benchmarks can help identify whether
    your Kubernetes cluster meets a security baseline and provide remediations if
    needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 `kube-bench` 这样的工具与 CIS 基准可以帮助确定您的 Kubernetes 集群是否符合安全基线，并在需要时提供修复措施。
- en: Image Security
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像安全性
- en: Another important part of Pod security is keeping the code and application within
    the Pod secure. Securing an application’s code is a complex topic beyond the scope
    of this chapter; however, the basics for container image security include making
    sure that your container image registry is doing *static scanning* for known code
    vulnerabilities. Additionally, you should have a tool for doing *runtime scanning*
    that identifies vulnerabilities that have been discovered after an image started
    running and also looks for potentially malicious activity like intrusions. There
    are many scanning tools provided by both open source and proprietary companies.
    In addition to security scanning, focusing on minimizing the contents of your
    container image to remove unnecessary dependencies minimizes the noise from this
    scanning. Finally, image security is another great reason to invest in continuous
    delivery so that you can rapidly patch and redeploy an image when vulnerabilities
    are found.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Pod 安全的重要部分是保证 Pod 中的代码和应用程序安全。确保应用程序代码的安全是一个复杂的主题，超出了本章的范围；然而，容器镜像安全的基础包括确保你的容器镜像仓库对已知的代码漏洞进行*静态扫描*。此外，你应该有一个工具进行*运行时扫描*，以识别镜像启动后发现的漏洞，并查找潜在的恶意活动，如入侵。开源和专有公司提供了许多扫描工具。除了安全扫描外，专注于最小化容器镜像的内容，以删除不必要的依赖，可以减少扫描时的干扰。最后，镜像安全是投资于持续交付的另一个重要理由，这样当发现漏洞时，可以快速打补丁并重新部署镜像。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered many different security-focused APIs and resources
    that can be used to improve the security posture of your workloads. By practicing
    defense in depth and principle of least privilege, you can incrementally improve
    the baseline security of your Kubernetes cluster. It’s never too late to start
    practicing better security, and this chapter provides everything you need to be
    confident that you have an understanding of the security controls Kubernetes offers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多不同的面向安全的 API 和资源，可以用来提高你的工作负载的安全性姿态。通过实践深度防御和最小权限原则，你可以逐步提高 Kubernetes
    集群的基线安全性。开始实践更好的安全措施永远不会太晚，本章提供了你需要的一切，以确保你对 Kubernetes 提供的安全控制有所了解。
