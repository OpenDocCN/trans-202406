- en: Chapter 14\. Falco Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。Falco 开发
- en: 'Extending Falco is the best way to ensure that it perfectly fits your unique
    requirements. This chapter will show you three approaches to Falco development.
    We’ll begin with an overview of Falco’s codebase and a quick guide to building
    Falco from the source, which allows you to work with Falco’s code directly. This
    first approach gives you more freedom but is more difficult and perhaps less convenient
    than the other two. The second approach lets you build an application that processes
    Falco notifications in the desired way by interfacing with the gRPC API. The third
    is the standard and easiest way of extending Falco: writing your own plugin.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Falco 是确保其完全符合您独特需求的最佳方式。本章将展示三种扩展 Falco 的方法。我们将首先概述 Falco 的代码库，并快速指导如何从源代码构建
    Falco，这样您可以直接处理 Falco 的代码。这种第一种方法给予您更多自由，但可能比其他两种方法更困难，也许不太方便。第二种方法允许您通过与 gRPC
    API 交互构建处理 Falco 通知的应用程序。第三种方法是扩展 Falco 的标准且最简单的方式：编写您自己的插件。
- en: 'For the last two approaches, we will teach you by using examples. We use the
    Go programming language in these code snippets, so some familiarity with it will
    be helpful, but it’s not strictly required. This chapter also assumes that you
    have read [Part II](part02.xhtml#ii_the_architecture_of_falco) of this book. If
    you are concerned that this material may be too difficult, don’t be scared: we
    think you’ll find it understandable and interesting even if you are not a developer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后两种方法，我们将通过示例来进行讲解。在这些代码片段中，我们使用 Go 编程语言，因此对其有一些了解将会有所帮助，但不是必需的。本章还假定您已经阅读了本书的[第二部分](part02.xhtml#ii_the_architecture_of_falco)。如果您担心这些材料可能过于困难，不要害怕：我们认为即使您不是开发人员，您也会发现它易于理解且有趣。
- en: Working with the Codebase
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与代码库一起工作
- en: Falco is open source, and all its source code lives in GitHub under the Falcosecuriy
    organization. All you need to start navigating the codebase is a browser. If you
    want to store the source code locally and open it with your preferred editor,
    you will need to use Git.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Falco 是开源的，其所有源代码都存储在 GitHub 上的 Falcosecuriy 组织下。要开始浏览代码库，您只需要一个浏览器。如果您希望将源代码存储在本地并使用您喜欢的编辑器打开它，您需要使用
    Git。
- en: 'The Falcosecurity organization hosts Falco and many other related projects.
    The community is very active, so you will also find many experimental projects.
    The core of The Falco Project lives in two main repositories: *falcosecurity/falco*
    and *falcosecurity/libs*.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Falcosecurity 组织托管了 Falco 和许多其他相关项目。社区非常活跃，因此您还会找到许多实验性项目。Falco 项目的核心存放在两个主要仓库中：*falcosecurity/falco*
    和 *falcosecurity/libs*。
- en: The falcosecurity/falco Repository
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: falcosecurity/falco 仓库
- en: 'The [*falcosecurity/falco* repository](https://oreil.ly/lqnL4) contains the
    source code of the *falco* user-space program (the one you usually interact with).
    It’s the main and most important repository. The project is organized as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[*falcosecurity/falco* 仓库](https://oreil.ly/lqnL4) 包含 *falco* 用户空间程序（通常与您进行交互的程序）的源代码。这是主要且最重要的仓库。该项目组织如下：'
- en: '*/cmake*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*/cmake*'
- en: Here you can find cmake modules that the Falco build system uses to pull dependencies
    and implement specific functionalities, including cmake files to pull the *falcosecurity/libs*
    source code during the build process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到 Falco 构建系统用于拉取依赖项和实现特定功能的 cmake 模块，包括在构建过程中拉取 *falcosecurity/libs*
    源代码的 cmake 文件。
- en: '*/docker*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*/docker*'
- en: This folder is organized into various subdirectories, each containing the source
    code of a Falco container image. Some are not published because they are for development
    use only. See the [README file](https://oreil.ly/oiGQQ) for details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹分为各种子目录，每个子目录包含 Falco 容器镜像的源代码。一些并未发布，因为它们仅供开发使用。详细信息请参阅[README 文件](https://oreil.ly/oiGQQ)。
- en: '*/proposals*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*/proposals*'
- en: This folder includes design proposals made by the community and approved by
    maintainers. You may find useful information here that helps you understand how
    the Falco authors made certain architectural decisions and the rationale behind
    them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含由社区提出并由维护者批准的设计提案。您可能会在这里找到有用的信息，帮助您理解 Falco 作者在某些架构决策及其背后的理由上做出的决定。
- en: '*/rules*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*/rules*'
- en: The default rules files live here.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的规则文件存储在这里。
- en: '*/scripts*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*/scripts*'
- en: Various script files live inside this folder. For example, this is where you’ll
    find the *falco-driver-loader* script’s source code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹中包含各种脚本文件。例如，您将在此找到 *falco-driver-loader* 脚本的源代码。
- en: '*/test* and */tests*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*/test* 和 */tests*'
- en: These two folders contain regression tests and unit tests for Falco, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件夹分别包含Falco的回归测试和单元测试。
- en: '*/userspace*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*/userspace*'
- en: 'The actual C++ source code of Falco lives inside this folder. Its contents
    are organized into two subdirectories: *engine*, which contains the rule engine
    implementation, and *falco*, which contains the implementations of high-level
    features like the output channels, the gRPC server, and the CLI application.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Falco的实际C++源代码位于这个文件夹中。它的内容被组织成两个子目录：*engine*，其中包含规则引擎实现，以及*falco*，其中包含高层次功能的实现，如输出通道、gRPC服务器和CLI应用程序。
- en: Although this is the main Falco repository, not all of the project’s source
    code lives here. Most is actually in the *falcosecurity/libs* repository*,* which
    contains the implementations of Falco’s core low-level logic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是Falco主仓库，但项目的大部分源代码并不在这里。大部分实际上在*falcosecurity/libs*仓库中，它包含Falco的核心低级逻辑的实现。
- en: The falcosecurity/libs Repository
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: falcosecurity/libs仓库
- en: 'Throughout this book, we have mentioned *libscap*, *libsinsp*, and the drivers
    many times. The [*falcosecurity/libs* repository](https://oreil.ly/HSLDT) hosts
    the source code of those components. It is organized as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们多次提到了*libscap*、*libsinsp*和驱动程序。[*falcosecurity/libs*仓库](https://oreil.ly/HSLDT)托管这些组件的源代码。它的组织如下：
- en: '*/cmake/modules*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*/cmake/modules*'
- en: This folder contains cmake modules to pull external dependencies and module
    definitions for *libscap* and *libsinsp* that consumer applications (like Falco)
    can use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含用于拉取外部依赖项的cmake模块和*libscap*和*libsinsp*的模块定义，这些消费者应用程序（如Falco）可以使用。
- en: '*/driver*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*/driver*'
- en: This folder includes the source code for the kernel module and eBPF probe (mainly
    in C).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包括内核模块和eBPF探针的源代码（主要用C编写）。
- en: '*/proposals*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*/proposals*'
- en: Similar to the one in the Falco repository, this folder contains the design
    proposal documents.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与Falco仓库中的类似，此文件夹包含设计提案文档。
- en: '*/userspace*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*/userspace*'
- en: Organized into several subdirectories, here you can find the source code (in
    C and C++) of *libsinsp* and *libscap* along with other shared code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 组   这里的几个子目录中，你可以找到*libsinsp*和*libscap*的源代码（C和C++）以及其他共享代码。
- en: 'This repository contains all the low-level logic required for kernel instrumentation
    and data enrichment. The filtering grammar, plugin framework implementation, and
    many other functionalities are hosted here. The *libs* codebase is vast, but don’t
    let that frighten you: all you need to understand it is a good knowledge of C/C++.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本仓库包含用于内核仪器和数据丰富的所有低级逻辑。过滤语法、插件框架实现和许多其他功能都托管在这里。*libs*代码库庞大，但不要让它吓倒你：理解它所需的只是良好的C/C++知识。
- en: Building Falco from Source
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源构建Falco
- en: 'Compiling Falco from its source is similar to compiling any other C++ project
    that uses cmake. The build system requires a handful of dependencies: cmake, make,
    gcc, wget, and of course git. (You also need Git to get a local copy of the Falco
    repository.) You can find instructions on how to install those dependencies in
    the [documentation](https://oreil.ly/UMJI2).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从其源代码编译Falco类似于编译其他使用cmake的C++项目。构建系统需要一些依赖项：cmake、make、gcc、wget，当然，还有git（获取Falco仓库的本地副本也需要Git）。你可以在[文档](https://oreil.ly/UMJI2)中找到如何安装这些依赖项的说明。
- en: 'Once you have ensured that the required dependencies are installed on your
    system, use the following command to get a local copy of the repository:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确保系统上安装了所需的依赖项，可以使用以下命令获取本地副本：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Git will clone the repository into a newly created folder called *falco*. Enter
    that directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Git会将仓库克隆到一个名为*falco*的新创建文件夹中。进入该目录：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Prepare a directory to contain the build files, then enter it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 准备一个目录来包含构建文件，然后进入其中：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, inside the build directory, run:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在构建目录中运行：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command will likely take a substantial amount of time the first time you
    run it, as cmake downloads and builds all the dependencies. This is because we
    configured it with `-DUSE_BUNDLED_DEPS=On`; alternatively, you can set `-DUSE_BUNDLED_DEPS=Off`
    to use system dependencies, but if you do this, you will need to manually install
    all the required dependencies on your system before building Falco. You can find
    an updated list of dependencies and other useful cmake options in the documentation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此命令可能需要大量时间，因为cmake会下载并构建所有依赖项。这是因为我们使用了`-DUSE_BUNDLED_DEPS=On`进行配置；或者，你可以设置`-DUSE_BUNDLED_DEPS=Off`来使用系统依赖项，但如果这样做，你需要在构建Falco之前手动安装所有必需的依赖项到你的系统上。你可以在文档中找到更新的依赖项列表和其他有用的cmake选项。
- en: After the `make` command completes, if there were no errors, you should find
    the newly created Falco executable in *./userspace/falco/falco* (the path is relative
    to the build directory).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当`make`命令完成后，如果没有错误，你应该会在*./userspace/falco/falco*（相对于构建目录的路径）下找到新创建的Falco可执行文件。
- en: 'Now, if you also want to build the driver from the source and you already have
    the kernel headers installed in your system, run:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你也想从源代码构建驱动程序，并且你的系统已经安装了内核头文件，请运行：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command only builds the kernel module, by default. If you want to build
    the eBPF probe instead, use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令默认仅构建内核模块。如果你想构建eBPF探针，请使用：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In both cases, you will find the newly built driver under *./driver* (the path
    is relative to the build directory).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种情况下，你会在*./driver*（相对于构建目录的路径）下找到新构建的驱动程序。
- en: Extending Falco Using the gRPC API
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gRPC API扩展Falco
- en: Although you might be tempted to introduce a new feature directly into the codebase,
    there are more convenient ways. For example, if you want to extend Falco’s output
    mechanism, you can create a program that works on top of Falco and implements
    your business logic. In particular, the gRPC API allows your program to consume
    Falco notifications and receive metadata easily.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能会考虑直接向代码库引入新功能，但还有更方便的方法。例如，如果你想扩展Falco的输出机制，你可以创建一个在Falco之上运行并实现你的业务逻辑的程序。特别是，gRPC
    API允许你的程序轻松消费Falco通知并接收元数据。
- en: This section will use an example program to show you how to start developing
    with the Falco gRPC API. To follow along, you’ll need a running Falco instance
    with the gRCP server and gRPC output channel enabled (see [Chapter 8](ch08.xhtml#the_output_framework)).
    You will use gRPC via a Unix socket, so make sure you have installed and configured
    Falco accordingly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将使用一个示例程序向你展示如何开始使用Falco gRPC API进行开发。为了跟随示例，请确保你的系统上有一个运行的Falco实例，并启用了gRCP服务器和gRPC输出通道（参见[第8章](ch08.xhtml#the_output_framework)）。你将通过Unix套接字使用gRPC，因此请确保已安装并配置了Falco。
- en: 'We use the [*client-go* library](https://oreil.ly/1bSay) in the following example,
    which makes using the gRPC API straightforward:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下示例中使用[*client-go*库](https://oreil.ly/1bSay)，它使得使用gRPC API变得简单直接：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#code_id_14_1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#code_id_14_1)'
- en: We start by importing the [*client-go* library](https://oreil.ly/iQD2m).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入[*client-go*库](https://oreil.ly/iQD2m)。
- en: '[![2](Images/2.png)](#code_id_14_2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#code_id_14_2)'
- en: The `main` function sets up a connection (represented by the variable `c`) to
    Falco’s gRPC server via the Unix socket using the default path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数建立一个连接（由变量`c`表示）到Falco的gRPC服务器，通过Unix套接字使用默认路径。'
- en: '[![3](Images/3.png)](#code_id_14_3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#code_id_14_3)'
- en: The connection `c` allows it to call the `OutputsWatch` function, which subscribes
    to a stream of notifications and processes any incoming notification using a callback
    function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 连接`c`允许调用`OutputsWatch`函数，订阅通知流并使用回调函数处理任何传入的通知。
- en: '[![4](Images/4.png)](#code_id_14_4)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#code_id_14_4)'
- en: This example uses an [anonymous function](https://oreil.ly/f4htn) that prints
    the notification to standard output. In a real-world application, you would implement
    your own business logic to consume Falco notifications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用一个[匿名函数](https://oreil.ly/f4htn)，它将通知打印到标准输出。在实际应用中，你应该实现自己的业务逻辑来消费Falco通知。
- en: Using the gRPC API to implement programs that interact with Falco is convenient
    and straightforward. If, instead, you need to make Falco work with other data
    sources, the plugin system is likely what you are looking for.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gRPC API来实现与Falco交互的程序非常方便直接。如果你需要使Falco与其他数据源一起工作，插件系统可能是你需要的。
- en: Extending Falco with Plugins
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件扩展Falco
- en: Plugins are the main way to extend Falco, and we’ve mentioned them many times
    throughout the book. To recap briefly, plugins are [shared libraries](https://oreil.ly/EkUs3)
    that conform to specific APIs. In the Falco plugin framework, the primary responsibilities
    of plugins are adding new data sources by connecting Falco to external sources
    and producing events, and extracting data from events by exporting lists of fields
    and decoding event data to produce field values when Falco requires them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是扩展 Falco 的主要方式，我们在整本书中多次提到过它们。简而言之，插件是符合特定 API 的 [共享库](https://oreil.ly/EkUs3)。在
    Falco 插件框架中，插件的主要责任是通过连接 Falco 到外部源并生成事件来添加新的数据源，并通过导出字段列表并解码事件数据以在 Falco 需要时生成字段值，从事件中提取数据。
- en: Plugins contain the logic to produce and interpret data. This is powerful because
    it means that Falco is only concerned with gathering field values from plugins
    and composing them into rule conditions. In other words, Falco only knows which
    fields can be used and how to get their values; everything else is delegated to
    the plugins. Thanks to this system, you can connect Falco to any domain.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 插件包含生成和解释数据的逻辑。这很强大，因为这意味着 Falco 只关心从插件中收集字段值并将它们组合成规则条件。换句话说，Falco 只知道哪些字段可以使用以及如何获取它们的值；其他所有操作都委托给插件。由于这种系统，你可以将
    Falco 连接到任何领域。
- en: There are a few important aspects to consider when designing a plugin. First,
    a plugin with event sourcing capability implicitly defines the event payload format
    (the serialized raw event data that the plugin returns to the framework). The
    same plugin, or other plugins with field extraction capability compatible with
    that data source, will be able to access the payload later, when extracting fields.
    Second, a plugin with field extraction capability explicitly defines fields that
    are bound to a data source. Finally, rules rely on data source specifications
    to consume the events in the format they expect.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设计插件时有几个重要方面需要考虑。首先，具有事件源功能的插件隐式定义了事件负载格式（插件返回给框架的序列化原始事件数据）。具有与数据源兼容的字段提取功能的同一插件或其他插件稍后将能够访问负载，并在提取字段时使用。其次，具有字段提取功能的插件显式定义了绑定到数据源的字段。最后，规则依赖于数据源规范，以消耗其期望格式的事件。
- en: Since describing every single technical aspect of plugin development would require
    a dedicated book, in this section we’ll just offer an educational example of how
    to implement a plugin that can both generate events and extract fields. For more
    extensive coverage, refer to the [documentation](https://oreil.ly/004ur).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述插件开发的每个技术细节都需要一本专门的书，因此在本节中，我们只提供一个教育性示例，展示如何实现一个既可以生成事件又可以提取字段的插件。如需更全面的覆盖范围，请参阅[文档](https://oreil.ly/004ur)。
- en: Our example will implement a plugin that reads from the bash history file (by
    default located at *~/.bash_history*). Each time a user enters a command in the
    shell, bash stores that command line. When the shell session ends, bash appends
    the entered command lines in the history file. It’s basically a log file. Although
    it has no compelling use cases, it’s a simple way to learn how to create a plugin
    that generates events from a log file. So, let’s start having fun with a bit of
    Go code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将实现一个插件，该插件从 bash 历史文件中读取（默认位于 *~/.bash_history*）。每当用户在 shell 中输入命令时，bash
    都会将该命令行存储下来。当 shell 会话结束时，bash 会将输入的命令行追加到历史文件中。它基本上就是一个日志文件。虽然它没有令人信服的用例，但它是学习如何创建从日志文件生成事件的插件的简单方法。因此，让我们开始用一些
    Go 代码来玩乐。
- en: Preparing a Plugin in Go
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备一个 Go 中的插件
- en: 'First, create a file (we called ours *myplugin.go*) and import a bunch of Go
    packages to simplify development. You’ll also import [*tail*](https://oreil.ly/BdIXO),
    a library that emulates the [`tail` command](https://oreil.ly/OWco5) (our example
    uses it to read from the log file), and a set of packages from Falcosecurity’s
    [Plugin SDK for Go](https://oreil.ly/lnyhl) that let you implement a source plugin
    with that extractor capability. You must use the `main` package, or Go won’t allow
    you to compile it as a shared object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个文件（我们称之为 *myplugin.go*），并导入一堆 Go 包以简化开发。你还将导入[*tail*](https://oreil.ly/BdIXO)，一个模拟[`tail`命令](https://oreil.ly/OWco5)的库（我们的示例使用它从日志文件中读取），以及来自
    Falcosecurity 的 [Go 插件 SDK](https://oreil.ly/lnyhl)中的一组包，让你可以实现具有提取器功能的源插件。你必须使用
    `main` 包，否则 Go 将不允许你将其编译为共享对象：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The SDK defines a set of interfaces that help you implement a plugin by following
    a simplified, well-defined pattern. As you will see in a moment, you have to satisfy
    those interfaces by adding methods—also called [functions with receivers](https://oreil.ly/t5aAZ)
    in Go—to a couple of data structures that represent your plugin. Under the hood,
    the SDK exports those methods as the calling convention functions (or simply C
    symbols) required by the plugin framework. (See [“Falco Plugins”](ch04.xhtml#falco_plugins)
    if you need a refresher on this.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 定义了一组接口，帮助您按照简化且明确定义的模式实现插件。正如您马上将看到的，您需要通过向表示您的插件的一对数据结构添加方法（也称为 [带接收器的函数](https://oreil.ly/t5aAZ)
    在 Go 中）来满足这些接口。在幕后，SDK 导出这些方法作为插件框架所需的调用约定函数（或简单的 C 符号）。（如果您需要回顾，请参阅 [“Falco 插件”](ch04.xhtml#falco_plugins)。）
- en: Plugin State and Initialization
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插件状态和初始化
- en: The SDK requires a data structure that represents the plugin and its state.
    It can implement various composable interfaces, but all types of plugins must
    implement, at minimum, `Info` to expose general information about the plugin and
    `Init` to initialize the plugin with a given configuration string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 需要一个表示插件及其状态的数据结构。它可以实现各种可组合的接口，但所有类型的插件至少必须实现 `Info` 接口以公开有关插件的一般信息，并实现
    `Init` 接口以使用给定的配置字符串初始化插件。
- en: 'The example calls this data structure `bashPlugin`. You’ll also define another
    data structure (called `bashPluginCfg`) that represents the plugin’s configuration,
    to store options inside it. This isn’t mandatory, but it’s usually convenient:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此示例称此数据结构为 `bashPlugin`。您还将定义另一个数据结构（称为 `bashPluginCfg`），表示插件的配置，以在其中存储选项。这不是强制性的，但通常很方便：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you’ll implement the first required method that exposes general information
    about the plugin:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将实现第一个公开有关插件一般信息的必需方法：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `ID` field is required for all source plugins and must be unique across
    them to ensure interoperability. The special value `999` is reserved for development
    purposes only; if you intend to distribute your plugin, you should register it
    in the [plugins registry](https://oreil.ly/7C9n1) to get a unique ID.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有源插件都需要 `ID` 字段，并且在它们之间必须是唯一的，以确保互操作性。特殊值 `999` 仅保留用于开发目的；如果您打算分发您的插件，您应该在
    [插件注册表](https://oreil.ly/7C9n1) 中注册它以获取唯一的 ID。
- en: Another important field for interoperability is `EventSource`, where you can
    declare the name of the data source. Extractor plugins can use that value to determine
    whether they are compatible with the data source.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的互操作性字段是 `EventSource`，您可以在其中声明数据源的名称。提取器插件可以使用该值来确定它们是否与数据源兼容。
- en: 'The other required method is `Init`. Falco calls this method only once, when
    loading the plugin, and passes the configuration string (the one defined in the
    Falco configuration for the plugin). Commonly, the configuration string is JSON-formatted.
    Our example first sets a default value for a member of `b.config` (an instance
    of the data structure for the plugin configuration that we declared earlier).
    Then, if the given `config` string is not empty, the function decodes the JSON
    value into `b.config`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个必需的方法是 `Init`。Falco 仅在加载插件时调用此方法，并传递配置字符串（在 Falco 配置中为插件定义的字符串）。通常，配置字符串是
    JSON 格式的。我们的示例首先为我们之前声明的插件配置数据结构 `b.config` 的成员设置默认值。然后，如果给定的 `config` 字符串不为空，函数将
    JSON 值解码到 `b.config` 中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding Event Sourcing Capability
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加事件源功能
- en: 'Specifically for plugins with event sourcing capability, the SDK requires another
    data structure that represents a *capture session* (a stream of events). It also
    requires the following methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于具有事件源功能的插件，SDK 需要另一个表示 *捕获会话*（事件流）的数据结构。它还需要以下方法：
- en: '`Open` to start and initialize a capture session'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Open` 用于启动和初始化捕获会话'
- en: '`NextBatch` to produce events'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NextBatch` 用于生成事件'
- en: 'Falco calls `Open` immediately after initialization. That represents the beginning
    of a capture session. The method’s main responsibility is instantiating the data
    structure that holds the session state (`bashInstance` in our example). Specifically,
    here we make a `*tail.Tail` instance (that mimics the behavior of `tail -f -n
    0`) and store it in `t`. Then we create a `bashInstance` instance (to which we
    can assign `t`) and return it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Falco在初始化后立即调用`Open`。这表示捕获会话的开始。该方法的主要责任是实例化保存会话状态的数据结构（在我们的示例中为`bashInstance`）。具体来说，我们在这里创建一个`*tail.Tail`实例（模仿`tail
    -f -n 0`的行为）并将其存储在`t`中。然后我们创建一个`bashInstance`实例（可以将`t`分配给它）并返回它：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The plugin system stores the value returned by `Open` and passes it as an argument
    to the most important method for a source plugin: `NextBatch`. Unlike the other
    methods, this belongs to the session data structure (`bashInstance`) and not to
    the plugin data structure (`bashPlugin`). During the capture session, Falco repeatedly
    calls `NextBatch`, which in turn produces a batch of new events. A batch’s maximum
    size depends on the size of its underlying reusable memory buffer. However, a
    batch can have fewer events than its maximum capacity; it can contain just one
    event or even be empty. This method usually implements the core business logic
    of a source plugin, but this example just implements some simple logic: it tries
    to receive lines from the `b.t.Lines` channel and add them to the batch. If there
    are none, it will time out after a while:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 插件系统存储`Open`返回的值，并将其作为源插件的最重要方法的参数传递：`NextBatch`。与其他方法不同，此方法属于会话数据结构（`bashInstance`），而不属于插件数据结构（`bashPlugin`）。在捕获会话期间，Falco重复调用`NextBatch`，后者又生成一批新事件。批处理的最大大小取决于其底层可重用内存缓冲区的大小。然而，批处理中的事件数可以少于其最大容量；它可以仅包含一个事件，甚至是空的。该方法通常实现源插件的核心业务逻辑，但本例中仅实现了一些简单的逻辑：尝试从`b.t.Lines`通道接收行并将它们添加到批处理中。如果没有，则在一段时间后会超时：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the SDK provides an `sdk.EventWriters` interface. This automatically
    manages the reusable memory buffer for the batch and allows the implementer to
    write the raw event payload as a sequence of bytes. The function `evts.Len` returns
    the maximum number of events allowed in a batch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，SDK提供了一个`sdk.EventWriters`接口。这自动管理批处理的可重用内存缓冲区，并允许实现者将原始事件负载作为字节序列写入。函数`evts.Len`返回批处理中允许的最大事件数。
- en: The choice of the format of the event payload is up to the plugin author, because
    the Plugin API allows both the encoding (in our example, for simplicity, we store
    the whole line as plain text in the payload) and the decoding of the data (as
    we will see in a moment). This permits you to create fields that you can use in
    rules. Choosing the correct format is essential because it has implications both
    for performance and for compatibility with other plugins (other authors may want
    to implement an extractor plugin that works with your events).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事件负载格式的选择由插件作者决定，因为插件API允许数据的编码（在我们的示例中，为了简单起见，我们将整行文本作为普通文本存储在负载中）和数据的解码（稍后我们将看到）。这允许您创建可用于规则的字段。选择正确的格式至关重要，因为它不仅对性能有影响，还对与其他插件的兼容性有影响（其他作者可能希望实现与您的事件兼容的提取器插件）。
- en: So far, you have seen the minimum set of methods required to implement a source
    plugin. However, the plugin would not really be useful at this point if we did
    not add a way to export fields to use in rule conditions and output.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了实现源插件所需的最小方法集。但是，如果我们不添加一种方法来导出字段以用于规则条件和输出，此时插件实际上并不会真正有用。
- en: Adding Field Extraction Capability
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加字段提取能力
- en: 'Plugins with field extraction capability can extract values from the event
    data and export fields that Falco can use. A plugin can have only event sourcing
    capability (described in the previous section), only field extraction capability,
    or both (like our example plugin). A plugin with field extraction capability will
    work on data sources provided by other plugins, while a plugin with both capabilities
    usually works only on its own data source. However, the mechanism is the same,
    regardless of the data source. The SDK lets you define the following methods,
    which apply in both cases:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 具有字段提取能力的插件可以从事件数据中提取值并导出Falco可以使用的字段。一个插件可以只具有事件源功能（在前一节中描述），也可以只具有字段提取功能，或者两者兼有（就像我们的示例插件一样）。具有字段提取能力的插件将在其他插件提供的数据源上工作，而具有两种能力的插件通常只在自己的数据源上工作。然而，机制是相同的，无论数据源如何。SDK允许您定义以下方法，这些方法在两种情况下都适用：
- en: '`Fields` to declare which fields the plugin is able to extract'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fields` 用于声明插件能够提取哪些字段'
- en: '`Extract` to extract the value of a given field from the event data'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Extract` 从事件数据中提取给定字段的值'
- en: 'Let’s implement those methods in our example plugin. The first method, `Fields`,
    returns a slice of `sdk.FieldEntry`. Each entry contains the specification of
    a single field. The following code tells Falco that the plugin can extract a field
    called `shell.command` (this example adds just one field):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在示例插件中实现这些方法。第一个方法 `Fields` 返回一个 `sdk.FieldEntry` 切片。每个条目包含单个字段的规范。下面的代码告诉
    Falco 插件可以提取名为 `shell.command` 的字段（本例仅添加了一个字段）：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, to make the extraction work, we need to implement the `Extract` method,
    which provides the actual business logic to extract the field. The method receives
    as arguments an extraction request (which contains the identifier of the requested
    field) and a reader (to access the event payload). Implementing it is straightforward
    since this example has just one field and will simply return all the content of
    the event payload. In a real-world scenario, you would usually have more fields
    and specific logic to extract each of them:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使提取工作正常，我们需要实现 `Extract` 方法，该方法提供实际的业务逻辑来提取字段。该方法接收提取请求（包含所请求字段的标识符）和一个读取器（用于访问事件负载）作为参数。由于本例只有一个字段，实现起来非常简单，它将简单地返回事件负载的所有内容。在实际场景中，您通常会有更多字段和特定的提取逻辑：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the field extraction capability in place, our example plugin is nearly
    ready. Let’s see how to complete and use it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了字段提取功能，我们的示例插件几乎准备好了。让我们看看如何完成并使用它。
- en: Finalizing the Plugin
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成插件
- en: 'You’re almost there. Next, you’ll create an instance of the plugin and register
    its capabilities with the SDK. You can do that during the Go initialization phase
    by using the special [`init` function](https://oreil.ly/LDPaK). (Do not confuse
    this with the `Init` method!) Since our example plugin has both source and extractor
    capabilities, we have to inform the SDK of both using the provided functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经快完成了。接下来，你将创建插件的一个实例，并在 SDK 中注册其能力。您可以在 Go 初始化阶段通过使用特殊的 [`init` 函数](https://oreil.ly/LDPaK)
    来完成这一过程。（不要与 `Init` 方法混淆！）由于我们的示例插件具有源和提取器功能，因此我们必须使用提供的函数通知 SDK 两者的能力：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note the empty `main` function. As you will see in a moment, the Go building
    system requires this to build the plugin correctly, but it will never call `main`,
    so you can always leave it empty.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意空的 `main` 函数。正如您马上会看到的，Go 构建系统需要它来正确构建插件，但它永远不会调用 `main`，所以您可以始终将其保持为空。
- en: 'The last step to make your code a real Go project is to initialize the Go module
    and download the dependencies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的代码成为真正的 Go 项目的最后一步是初始化 Go 模块并下载依赖项：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These commands create the *go.mod* and *go.sum* files, respectively. The code
    for your plugin is now ready. It’s time to compile it so that you can use it with
    Falco!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令分别创建了 *go.mod* 和 *go.sum* 文件。现在，您的插件代码已经准备就绪。是时候编译它，以便您可以在 Falco 中使用它了！
- en: Building a Plugin Written in Go
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建用 Go 编写的插件
- en: A plugin is a shared library (also called a *shared object*)—specifically, a
    compiled file—that exports a set of C symbols required by the plugin framework.
    (The SDK we used in the example hides those C symbols by using high-level interfaces,
    but they are still present underneath.)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是一个共享库（也称为 *共享对象*），具体来说是一个编译文件，它导出了插件框架所需的一组 C 符号。（我们在示例中使用的 SDK 通过使用高级接口隐藏了这些
    C 符号，但它们仍然存在于底层。）
- en: 'The Go compiler has a specific command called [`cgo`](https://oreil.ly/sD0aW)
    for creating Go packages that interface with C code. It allows you to compile
    your plugin and get a shared library file (a .*so* or *.dll* file). The command
    is pretty straightforward. From the same folder where the source code lives, run:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Go 编译器有一个特定的命令称为 [`cgo`](https://oreil.ly/sD0aW)，用于创建与 C 代码接口的 Go 包。它允许您编译插件并获得一个共享库文件（一个
    *.so* 或 *.dll* 文件）。该命令非常简单。在存放源代码的同一文件夹中运行：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command creates *libmyplugin.so*, which you can use with Falco. (By convention,
    shared object files in Unix-like systems start with *lib* and have *.so* as their
    extension.) You learned about plugin configuration in [Chapter 10](ch10.xhtml#configuring_and_running),
    but the following section will give you some hints about using plugins while developing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建了 *libmyplugin.so*，您可以在 Falco 中使用它。 （按照惯例，类 Unix 系统中的共享对象文件以 *lib* 开头，并以
    *.so* 作为扩展名。）您在 [第 10 章](ch10.xhtml#configuring_and_running) 中了解了插件配置，但以下部分将为您提供一些关于开发时如何使用插件的提示。
- en: Using Plugins While Developing
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发过程中使用插件
- en: 'By default, Falco looks for installed plugins at */usr/share/falco/plugins*.
    However, you can specify an absolute path in the configuration and place your
    plugin wherever you want. (That’s convenient while developing, since you won’t
    need to install the plugin in the default path.) We suggest building the plugin
    (using the command in the previous section) in the same folder you are using to
    develop it. Then, in the same folder, create a copy of *falco.yaml*, add your
    plugin configuration accordingly, and set the `library_path` option to the absolute
    path of your plugin. For example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Falco会在*/usr/share/falco/plugins*中查找已安装的插件。但是，你可以在配置中指定绝对路径，并将插件放在任何你想放置的位置。（在开发过程中这很方便，因为你不需要将插件安装在默认路径下。）我们建议在开发插件的同时构建插件（使用上一节中的命令）。然后，在同一文件夹中，复制*falco.yaml*，根据需要添加你的插件配置，并将`library_path`选项设置为插件的绝对路径。例如：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, before using your plugin, you need a rules file that matches the data
    source provided by the plugin. (Falco would load the plugin even without the rules
    file, but you wouldn’t get any notifications.) You can create a rules file in
    the same folder—for instance, *myplugin_rules.yaml*—and add a rule like the following
    to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在使用插件之前，你需要一个与插件提供的数据源匹配的规则文件。（Falco即使没有规则文件也会加载插件，但你将不会收到任何通知。）你可以在同一文件夹中创建一个规则文件，例如*myplugin_rules.yaml*，并在其中添加如下规则：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you have prepared both your customized *falco.yaml* and *myplugin_rules.yaml,*
    the very last step is to run Falco and pass those files in the respective options:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好你定制的*falco.yaml*和*myplugin_rules.yaml*，最后一步就是运行Falco并传递这些文件给相应的选项：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Done! This way of running a plugin in Falco is very convenient during development,
    since it does not require you to install any files or mess with your local Falco
    installation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！在开发过程中以这种方式运行Falco插件非常方便，因为它不需要你安装任何文件或干扰本地的Falco安装。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you built the plugin in our example, to trigger the rule, you can run:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照我们示例中的方法构建了插件，并希望触发规则，可以运行：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Conclusion
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: There are several ways of extending Falco. Writing a plugin is generally the
    best option, especially if you want Falco to work with a new data source to enable
    new use cases. The gRPC API may help you if you need to interface with outputs.
    On rare occasions, you may need to modify the Falco core and its components directly.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以扩展Falco。编写插件通常是最佳选择，特别是如果你希望Falco能够处理新的数据源以启用新的用例。如果需要与输出进行接口化，gRPC API可能会对你有所帮助。在极少数情况下，你可能需要直接修改Falco核心及其组件。
- en: Whatever the case, you will need to read the documentation. You may sometimes
    need to study and understand advanced topics. Since Falco is open source and a
    collaborative project, you always have the opportunity to get in touch with its
    vibrant community. Sharing ideas and knowledge with others will help you find
    answers faster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，你都需要阅读文档。有时你可能需要学习和理解高级主题。由于Falco是开源的且是一个协作项目，你总是有机会与其充满活力的社区联系。与他人分享想法和知识将帮助你更快找到答案。
- en: You may also discover that other people have your exact needs and are willing
    to help you improve or extend Falco. That would be a perfect opportunity to contribute
    to the Falco project. Everyone can contribute to Falco. Not only is it a rewarding
    experience, but contributing is a great help to the project and all of its users,
    including you. Want to know how? Read the next chapter!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会发现其他人有与你完全相同的需求，并愿意帮助你改进或扩展Falco。这将是为Falco项目做贡献的绝佳机会。每个人都可以为Falco做贡献。这不仅是一种有益的经验，而且为项目和所有用户（包括你）提供了极大的帮助。想知道如何做？请阅读下一章！
