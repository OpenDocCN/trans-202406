- en: Chapter 14\. Falco Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extending Falco is the best way to ensure that it perfectly fits your unique
    requirements. This chapter will show you three approaches to Falco development.
    We’ll begin with an overview of Falco’s codebase and a quick guide to building
    Falco from the source, which allows you to work with Falco’s code directly. This
    first approach gives you more freedom but is more difficult and perhaps less convenient
    than the other two. The second approach lets you build an application that processes
    Falco notifications in the desired way by interfacing with the gRPC API. The third
    is the standard and easiest way of extending Falco: writing your own plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the last two approaches, we will teach you by using examples. We use the
    Go programming language in these code snippets, so some familiarity with it will
    be helpful, but it’s not strictly required. This chapter also assumes that you
    have read [Part II](part02.xhtml#ii_the_architecture_of_falco) of this book. If
    you are concerned that this material may be too difficult, don’t be scared: we
    think you’ll find it understandable and interesting even if you are not a developer.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Codebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Falco is open source, and all its source code lives in GitHub under the Falcosecuriy
    organization. All you need to start navigating the codebase is a browser. If you
    want to store the source code locally and open it with your preferred editor,
    you will need to use Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Falcosecurity organization hosts Falco and many other related projects.
    The community is very active, so you will also find many experimental projects.
    The core of The Falco Project lives in two main repositories: *falcosecurity/falco*
    and *falcosecurity/libs*.'
  prefs: []
  type: TYPE_NORMAL
- en: The falcosecurity/falco Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [*falcosecurity/falco* repository](https://oreil.ly/lqnL4) contains the
    source code of the *falco* user-space program (the one you usually interact with).
    It’s the main and most important repository. The project is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/cmake*'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can find cmake modules that the Falco build system uses to pull dependencies
    and implement specific functionalities, including cmake files to pull the *falcosecurity/libs*
    source code during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: '*/docker*'
  prefs: []
  type: TYPE_NORMAL
- en: This folder is organized into various subdirectories, each containing the source
    code of a Falco container image. Some are not published because they are for development
    use only. See the [README file](https://oreil.ly/oiGQQ) for details.
  prefs: []
  type: TYPE_NORMAL
- en: '*/proposals*'
  prefs: []
  type: TYPE_NORMAL
- en: This folder includes design proposals made by the community and approved by
    maintainers. You may find useful information here that helps you understand how
    the Falco authors made certain architectural decisions and the rationale behind
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '*/rules*'
  prefs: []
  type: TYPE_NORMAL
- en: The default rules files live here.
  prefs: []
  type: TYPE_NORMAL
- en: '*/scripts*'
  prefs: []
  type: TYPE_NORMAL
- en: Various script files live inside this folder. For example, this is where you’ll
    find the *falco-driver-loader* script’s source code.
  prefs: []
  type: TYPE_NORMAL
- en: '*/test* and */tests*'
  prefs: []
  type: TYPE_NORMAL
- en: These two folders contain regression tests and unit tests for Falco, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '*/userspace*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual C++ source code of Falco lives inside this folder. Its contents
    are organized into two subdirectories: *engine*, which contains the rule engine
    implementation, and *falco*, which contains the implementations of high-level
    features like the output channels, the gRPC server, and the CLI application.'
  prefs: []
  type: TYPE_NORMAL
- en: Although this is the main Falco repository, not all of the project’s source
    code lives here. Most is actually in the *falcosecurity/libs* repository*,* which
    contains the implementations of Falco’s core low-level logic.
  prefs: []
  type: TYPE_NORMAL
- en: The falcosecurity/libs Repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this book, we have mentioned *libscap*, *libsinsp*, and the drivers
    many times. The [*falcosecurity/libs* repository](https://oreil.ly/HSLDT) hosts
    the source code of those components. It is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/cmake/modules*'
  prefs: []
  type: TYPE_NORMAL
- en: This folder contains cmake modules to pull external dependencies and module
    definitions for *libscap* and *libsinsp* that consumer applications (like Falco)
    can use.
  prefs: []
  type: TYPE_NORMAL
- en: '*/driver*'
  prefs: []
  type: TYPE_NORMAL
- en: This folder includes the source code for the kernel module and eBPF probe (mainly
    in C).
  prefs: []
  type: TYPE_NORMAL
- en: '*/proposals*'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the one in the Falco repository, this folder contains the design
    proposal documents.
  prefs: []
  type: TYPE_NORMAL
- en: '*/userspace*'
  prefs: []
  type: TYPE_NORMAL
- en: Organized into several subdirectories, here you can find the source code (in
    C and C++) of *libsinsp* and *libscap* along with other shared code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This repository contains all the low-level logic required for kernel instrumentation
    and data enrichment. The filtering grammar, plugin framework implementation, and
    many other functionalities are hosted here. The *libs* codebase is vast, but don’t
    let that frighten you: all you need to understand it is a good knowledge of C/C++.'
  prefs: []
  type: TYPE_NORMAL
- en: Building Falco from Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compiling Falco from its source is similar to compiling any other C++ project
    that uses cmake. The build system requires a handful of dependencies: cmake, make,
    gcc, wget, and of course git. (You also need Git to get a local copy of the Falco
    repository.) You can find instructions on how to install those dependencies in
    the [documentation](https://oreil.ly/UMJI2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have ensured that the required dependencies are installed on your
    system, use the following command to get a local copy of the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Git will clone the repository into a newly created folder called *falco*. Enter
    that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare a directory to contain the build files, then enter it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, inside the build directory, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command will likely take a substantial amount of time the first time you
    run it, as cmake downloads and builds all the dependencies. This is because we
    configured it with `-DUSE_BUNDLED_DEPS=On`; alternatively, you can set `-DUSE_BUNDLED_DEPS=Off`
    to use system dependencies, but if you do this, you will need to manually install
    all the required dependencies on your system before building Falco. You can find
    an updated list of dependencies and other useful cmake options in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: After the `make` command completes, if there were no errors, you should find
    the newly created Falco executable in *./userspace/falco/falco* (the path is relative
    to the build directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you also want to build the driver from the source and you already have
    the kernel headers installed in your system, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command only builds the kernel module, by default. If you want to build
    the eBPF probe instead, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, you will find the newly built driver under *./driver* (the path
    is relative to the build directory).
  prefs: []
  type: TYPE_NORMAL
- en: Extending Falco Using the gRPC API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you might be tempted to introduce a new feature directly into the codebase,
    there are more convenient ways. For example, if you want to extend Falco’s output
    mechanism, you can create a program that works on top of Falco and implements
    your business logic. In particular, the gRPC API allows your program to consume
    Falco notifications and receive metadata easily.
  prefs: []
  type: TYPE_NORMAL
- en: This section will use an example program to show you how to start developing
    with the Falco gRPC API. To follow along, you’ll need a running Falco instance
    with the gRCP server and gRPC output channel enabled (see [Chapter 8](ch08.xhtml#the_output_framework)).
    You will use gRPC via a Unix socket, so make sure you have installed and configured
    Falco accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the [*client-go* library](https://oreil.ly/1bSay) in the following example,
    which makes using the gRPC API straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#code_id_14_1)'
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the [*client-go* library](https://oreil.ly/iQD2m).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#code_id_14_2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function sets up a connection (represented by the variable `c`) to
    Falco’s gRPC server via the Unix socket using the default path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#code_id_14_3)'
  prefs: []
  type: TYPE_NORMAL
- en: The connection `c` allows it to call the `OutputsWatch` function, which subscribes
    to a stream of notifications and processes any incoming notification using a callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#code_id_14_4)'
  prefs: []
  type: TYPE_NORMAL
- en: This example uses an [anonymous function](https://oreil.ly/f4htn) that prints
    the notification to standard output. In a real-world application, you would implement
    your own business logic to consume Falco notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Using the gRPC API to implement programs that interact with Falco is convenient
    and straightforward. If, instead, you need to make Falco work with other data
    sources, the plugin system is likely what you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Falco with Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are the main way to extend Falco, and we’ve mentioned them many times
    throughout the book. To recap briefly, plugins are [shared libraries](https://oreil.ly/EkUs3)
    that conform to specific APIs. In the Falco plugin framework, the primary responsibilities
    of plugins are adding new data sources by connecting Falco to external sources
    and producing events, and extracting data from events by exporting lists of fields
    and decoding event data to produce field values when Falco requires them.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins contain the logic to produce and interpret data. This is powerful because
    it means that Falco is only concerned with gathering field values from plugins
    and composing them into rule conditions. In other words, Falco only knows which
    fields can be used and how to get their values; everything else is delegated to
    the plugins. Thanks to this system, you can connect Falco to any domain.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few important aspects to consider when designing a plugin. First,
    a plugin with event sourcing capability implicitly defines the event payload format
    (the serialized raw event data that the plugin returns to the framework). The
    same plugin, or other plugins with field extraction capability compatible with
    that data source, will be able to access the payload later, when extracting fields.
    Second, a plugin with field extraction capability explicitly defines fields that
    are bound to a data source. Finally, rules rely on data source specifications
    to consume the events in the format they expect.
  prefs: []
  type: TYPE_NORMAL
- en: Since describing every single technical aspect of plugin development would require
    a dedicated book, in this section we’ll just offer an educational example of how
    to implement a plugin that can both generate events and extract fields. For more
    extensive coverage, refer to the [documentation](https://oreil.ly/004ur).
  prefs: []
  type: TYPE_NORMAL
- en: Our example will implement a plugin that reads from the bash history file (by
    default located at *~/.bash_history*). Each time a user enters a command in the
    shell, bash stores that command line. When the shell session ends, bash appends
    the entered command lines in the history file. It’s basically a log file. Although
    it has no compelling use cases, it’s a simple way to learn how to create a plugin
    that generates events from a log file. So, let’s start having fun with a bit of
    Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a Plugin in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, create a file (we called ours *myplugin.go*) and import a bunch of Go
    packages to simplify development. You’ll also import [*tail*](https://oreil.ly/BdIXO),
    a library that emulates the [`tail` command](https://oreil.ly/OWco5) (our example
    uses it to read from the log file), and a set of packages from Falcosecurity’s
    [Plugin SDK for Go](https://oreil.ly/lnyhl) that let you implement a source plugin
    with that extractor capability. You must use the `main` package, or Go won’t allow
    you to compile it as a shared object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The SDK defines a set of interfaces that help you implement a plugin by following
    a simplified, well-defined pattern. As you will see in a moment, you have to satisfy
    those interfaces by adding methods—also called [functions with receivers](https://oreil.ly/t5aAZ)
    in Go—to a couple of data structures that represent your plugin. Under the hood,
    the SDK exports those methods as the calling convention functions (or simply C
    symbols) required by the plugin framework. (See [“Falco Plugins”](ch04.xhtml#falco_plugins)
    if you need a refresher on this.)
  prefs: []
  type: TYPE_NORMAL
- en: Plugin State and Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SDK requires a data structure that represents the plugin and its state.
    It can implement various composable interfaces, but all types of plugins must
    implement, at minimum, `Info` to expose general information about the plugin and
    `Init` to initialize the plugin with a given configuration string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example calls this data structure `bashPlugin`. You’ll also define another
    data structure (called `bashPluginCfg`) that represents the plugin’s configuration,
    to store options inside it. This isn’t mandatory, but it’s usually convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’ll implement the first required method that exposes general information
    about the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `ID` field is required for all source plugins and must be unique across
    them to ensure interoperability. The special value `999` is reserved for development
    purposes only; if you intend to distribute your plugin, you should register it
    in the [plugins registry](https://oreil.ly/7C9n1) to get a unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: Another important field for interoperability is `EventSource`, where you can
    declare the name of the data source. Extractor plugins can use that value to determine
    whether they are compatible with the data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other required method is `Init`. Falco calls this method only once, when
    loading the plugin, and passes the configuration string (the one defined in the
    Falco configuration for the plugin). Commonly, the configuration string is JSON-formatted.
    Our example first sets a default value for a member of `b.config` (an instance
    of the data structure for the plugin configuration that we declared earlier).
    Then, if the given `config` string is not empty, the function decodes the JSON
    value into `b.config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adding Event Sourcing Capability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Specifically for plugins with event sourcing capability, the SDK requires another
    data structure that represents a *capture session* (a stream of events). It also
    requires the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Open` to start and initialize a capture session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NextBatch` to produce events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Falco calls `Open` immediately after initialization. That represents the beginning
    of a capture session. The method’s main responsibility is instantiating the data
    structure that holds the session state (`bashInstance` in our example). Specifically,
    here we make a `*tail.Tail` instance (that mimics the behavior of `tail -f -n
    0`) and store it in `t`. Then we create a `bashInstance` instance (to which we
    can assign `t`) and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin system stores the value returned by `Open` and passes it as an argument
    to the most important method for a source plugin: `NextBatch`. Unlike the other
    methods, this belongs to the session data structure (`bashInstance`) and not to
    the plugin data structure (`bashPlugin`). During the capture session, Falco repeatedly
    calls `NextBatch`, which in turn produces a batch of new events. A batch’s maximum
    size depends on the size of its underlying reusable memory buffer. However, a
    batch can have fewer events than its maximum capacity; it can contain just one
    event or even be empty. This method usually implements the core business logic
    of a source plugin, but this example just implements some simple logic: it tries
    to receive lines from the `b.t.Lines` channel and add them to the batch. If there
    are none, it will time out after a while:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the SDK provides an `sdk.EventWriters` interface. This automatically
    manages the reusable memory buffer for the batch and allows the implementer to
    write the raw event payload as a sequence of bytes. The function `evts.Len` returns
    the maximum number of events allowed in a batch.
  prefs: []
  type: TYPE_NORMAL
- en: The choice of the format of the event payload is up to the plugin author, because
    the Plugin API allows both the encoding (in our example, for simplicity, we store
    the whole line as plain text in the payload) and the decoding of the data (as
    we will see in a moment). This permits you to create fields that you can use in
    rules. Choosing the correct format is essential because it has implications both
    for performance and for compatibility with other plugins (other authors may want
    to implement an extractor plugin that works with your events).
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have seen the minimum set of methods required to implement a source
    plugin. However, the plugin would not really be useful at this point if we did
    not add a way to export fields to use in rule conditions and output.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Field Extraction Capability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Plugins with field extraction capability can extract values from the event
    data and export fields that Falco can use. A plugin can have only event sourcing
    capability (described in the previous section), only field extraction capability,
    or both (like our example plugin). A plugin with field extraction capability will
    work on data sources provided by other plugins, while a plugin with both capabilities
    usually works only on its own data source. However, the mechanism is the same,
    regardless of the data source. The SDK lets you define the following methods,
    which apply in both cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Fields` to declare which fields the plugin is able to extract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Extract` to extract the value of a given field from the event data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s implement those methods in our example plugin. The first method, `Fields`,
    returns a slice of `sdk.FieldEntry`. Each entry contains the specification of
    a single field. The following code tells Falco that the plugin can extract a field
    called `shell.command` (this example adds just one field):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to make the extraction work, we need to implement the `Extract` method,
    which provides the actual business logic to extract the field. The method receives
    as arguments an extraction request (which contains the identifier of the requested
    field) and a reader (to access the event payload). Implementing it is straightforward
    since this example has just one field and will simply return all the content of
    the event payload. In a real-world scenario, you would usually have more fields
    and specific logic to extract each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the field extraction capability in place, our example plugin is nearly
    ready. Let’s see how to complete and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re almost there. Next, you’ll create an instance of the plugin and register
    its capabilities with the SDK. You can do that during the Go initialization phase
    by using the special [`init` function](https://oreil.ly/LDPaK). (Do not confuse
    this with the `Init` method!) Since our example plugin has both source and extractor
    capabilities, we have to inform the SDK of both using the provided functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note the empty `main` function. As you will see in a moment, the Go building
    system requires this to build the plugin correctly, but it will never call `main`,
    so you can always leave it empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to make your code a real Go project is to initialize the Go module
    and download the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These commands create the *go.mod* and *go.sum* files, respectively. The code
    for your plugin is now ready. It’s time to compile it so that you can use it with
    Falco!
  prefs: []
  type: TYPE_NORMAL
- en: Building a Plugin Written in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A plugin is a shared library (also called a *shared object*)—specifically, a
    compiled file—that exports a set of C symbols required by the plugin framework.
    (The SDK we used in the example hides those C symbols by using high-level interfaces,
    but they are still present underneath.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go compiler has a specific command called [`cgo`](https://oreil.ly/sD0aW)
    for creating Go packages that interface with C code. It allows you to compile
    your plugin and get a shared library file (a .*so* or *.dll* file). The command
    is pretty straightforward. From the same folder where the source code lives, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command creates *libmyplugin.so*, which you can use with Falco. (By convention,
    shared object files in Unix-like systems start with *lib* and have *.so* as their
    extension.) You learned about plugin configuration in [Chapter 10](ch10.xhtml#configuring_and_running),
    but the following section will give you some hints about using plugins while developing.
  prefs: []
  type: TYPE_NORMAL
- en: Using Plugins While Developing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Falco looks for installed plugins at */usr/share/falco/plugins*.
    However, you can specify an absolute path in the configuration and place your
    plugin wherever you want. (That’s convenient while developing, since you won’t
    need to install the plugin in the default path.) We suggest building the plugin
    (using the command in the previous section) in the same folder you are using to
    develop it. Then, in the same folder, create a copy of *falco.yaml*, add your
    plugin configuration accordingly, and set the `library_path` option to the absolute
    path of your plugin. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before using your plugin, you need a rules file that matches the data
    source provided by the plugin. (Falco would load the plugin even without the rules
    file, but you wouldn’t get any notifications.) You can create a rules file in
    the same folder—for instance, *myplugin_rules.yaml*—and add a rule like the following
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have prepared both your customized *falco.yaml* and *myplugin_rules.yaml,*
    the very last step is to run Falco and pass those files in the respective options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Done! This way of running a plugin in Falco is very convenient during development,
    since it does not require you to install any files or mess with your local Falco
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you built the plugin in our example, to trigger the rule, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways of extending Falco. Writing a plugin is generally the
    best option, especially if you want Falco to work with a new data source to enable
    new use cases. The gRPC API may help you if you need to interface with outputs.
    On rare occasions, you may need to modify the Falco core and its components directly.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever the case, you will need to read the documentation. You may sometimes
    need to study and understand advanced topics. Since Falco is open source and a
    collaborative project, you always have the opportunity to get in touch with its
    vibrant community. Sharing ideas and knowledge with others will help you find
    answers faster.
  prefs: []
  type: TYPE_NORMAL
- en: You may also discover that other people have your exact needs and are willing
    to help you improve or extend Falco. That would be a perfect opportunity to contribute
    to the Falco project. Everyone can contribute to Falco. Not only is it a rewarding
    experience, but contributing is a great help to the project and all of its users,
    including you. Want to know how? Read the next chapter!
  prefs: []
  type: TYPE_NORMAL
