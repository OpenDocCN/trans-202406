["```\ndefine(\n    module_id /*optional*/,\n    [dependencies] /*optional*/,\n    definition function {} /*function for instantiating the module or object*/\n);\n```", "```\n// A module_id (myModule) is used here for demonstration purposes only\ndefine( \"myModule\",\n\n    [\"foo\", \"bar\"],\n\n    // module definition function\n    // dependencies (foo and bar) are mapped to function parameters\n    function ( foo, bar ) {\n        // return a value that defines the module export\n        // (i.e., the functionality we want to expose for consumption)\n\n        // create your module here\n        var myModule = {\n            doStuff:function () {\n                console.log( \"Yay! Stuff\" );\n            }\n        };\n\n    return myModule;\n});\n\n// An alternative version could be...\ndefine( \"myModule\",\n\n    [\"math\", \"graph\"],\n\n    function ( math, graph ) {\n\n        // Note that this is a slightly different pattern\n        // With AMD, it's possible to define modules in a few\n        // different ways due to its flexibility with\n        // certain aspects of the syntax\n        return {\n            plot: function( x, y ){\n                return graph.drawPie( math.randomGrid( x, y ) );\n            }\n        };\n});\n```", "```\n// Consider \"foo\" and \"bar\" are two external modules\n// In this example, the \"exports\" from the two modules\n// loaded are passed as function arguments to the\n// callback (foo and bar) so that they can similarly be accessed\n\nrequire([\"foo\", \"bar\"], function ( foo, bar ) {\n        // rest of your code here\n        foo.doSomething();\n});\n```", "```\ndefine(function ( require ) {\n    var isReady = false, foobar;\n\n    // note the inline require within our module definition\n    require([\"foo\", \"bar\"], function ( foo, bar ) {\n        isReady = true;\n        foobar = foo() + bar();\n    });\n\n    // we can still return a module\n    return {\n        isReady: isReady,\n        foobar: foobar\n    };\n});\n```", "```\n// With AMD, it's possible to load in assets of almost any kind\n// including text-files and HTML. This enables us to have template\n// dependencies which can be used to skin components either on\n// page-load or dynamically.\n\ndefine( [\"./templates\", \"text!./template.md\",\"css!./template.css\" ],\n\n    function( templates, template ){\n        console.log( templates );\n        // do something with our templates here\n    }\n\n});\n```", "```\nrequire([\"app/myModule\"],\n\n    function( myModule ){\n        // start the main module which in turn\n        // loads other modules\n        var module = new myModule();\n        module.doStuff();\n});\n```", "```\ncurl([\"app/myModule.js\"],\n\n    function( myModule ){\n        // start the main module which in turn\n        // loads other modules\n        var module = new myModule();\n        module.doStuff();\n\n});\n```", "```\n<pre xmlns=\"http://www.w3.org/1999/xhtml\" id=\"I_programlisting11_id234274\"\ndata-type=\"programlisting\" data-code-language=\"javascript\">\n\n// This could be compatible with jQuery's Deferred implementation,\n// futures.js (slightly different syntax) or any one of a number\n// of other implementations\n\ndefine([\"lib/Deferred\"], function( Deferred ){\n    var defer = new Deferred();\n\n    require([\"lib/templates/?index.html\",\"lib/data/?stats\"],\n        function( template, data ){\n            defer.resolve( { template: template, data:data } );\n        }\n    );\n    return defer.promise();\n});\n\n</pre>\n```", "```\n// Code in app.js. baseURl set to the lib folder\n// containing jquery, jquery.color, and lodash files.\ndefine([\"jquery\",\"jquery.color\",\"lodash\"], function( $, colorPlugin, _ ){\n    // Here we've passed in jQuery, the color plugin, and Lodash\n    // None of these will be accessible in the global scope, but we\n    // can easily reference them below.\n\n    // Pseudorandomize an array of colors, selecting the first\n    // item in the shuffled array\n    var shuffleColor = _.first( _.shuffle([\"#AAA\",\"#FFF\",\"#111\",\"#F16\"]));\n    console.log(shuffleColor);\n\n    // Animate the background color of any elements with the class\n    // \"item\" on the page using the shuffled color\n    $( \".item\" ).animate( {\"backgroundColor\": shuffleColor } );\n\n    // What we return can be used by other modules\n    return function () {};\n});\n```", "```\n// Account for the existence of more than one global\n// instance of jQuery in the document, cater for testing\n// .noConflict()\n\nvar jQuery = this.jQuery || \"jQuery\",\n$ = this.$ || \"$\",\noriginaljQuery = jQuery,\noriginal$ = $;\n\ndefine([\"jquery\"] , function ( $ ) {\n    $( \".items\" ).css( \"background\",\"green\" );\n    return function () {};\n});\n```", "```\n// package/lib is a dependency we require\nvar lib = require(\"package/lib\");\n\n// behavior for our module\nfunction foo() {\n  lib.log(\"hello world!\");\n}\n\n// export (expose) foo to other modules\nexports.foo = foo;\n```", "```\n// Import the module containing the foo function\nvar exampleModule = require(\"./example-10-9\");\n\n// Consume the 'foo' function from the imported module\nexampleModule.foo();\n```", "```\n// CommonJS module getting started\n// AMD-equivalent of CommonJS example\n// AMD module format\ndefine(function(require){\nvar lib = require( \"package/lib\" );\n\n// some behavior for our module\nfunction foo(){\n   lib.log( \"hello world!\" );\n}\n\n// export (expose) foo for other modules\nreturn {\n   foobar: foo\n};\n});\n```", "```\nvar modA = require( \"./foo\" );\nvar modB = require( \"./bar\" );\n\nexports.app = function(){\n    console.log( \"Im an application!\" );\n}\n\nexports.foo = function(){\n    return modA.helloWorld();\n}\n```", "```\nexports.name = \"bar\";\n```", "```\nrequire( \"./bar\" );\nexports.helloWorld = function(){\n    return \"Hello World!!\"\n}\n```", "```\ndefine( function ( require, exports, module ){\n\n    var shuffler = require( \"lib/shuffle\" );\n\n    exports.randomize = function( input ){\n        return shuffler.shuffle( input );\n    }\n});\n```", "```\n(function ( root, factory ) {\n    if ( typeof exports === 'object' ) {\n        // CommonJS\n        factory( exports, require('b') );\n    } else if ( typeof define === 'function' && define.amd ) {\n        // AMD. Register as an anonymous module.\n        define( ['exports', 'b'], factory);\n    } else {\n        // Browser globals\n        factory( (root.commonJsStrict = {}), root.b );\n    }\n}(this, function ( exports, b ) {\n    //use b in some fashion.\n\n    // attach properties to the exports object to define\n    // the exported module properties.\n    exports.action = function () {};\n}));\n```", "```\n<script type=\"text/javascript\" src=\"jquery.min.js\"></script>\n<script type=\"text/javascript\" src=\"pluginCore.js\"></script>\n<script type=\"text/javascript\" src=\"pluginExtension.js\"></script>\n\n<script type=\"text/javascript\">\n\n$(function(){\n\n    // Our plug-in \"core\" is exposed under a core namespace in\n    // this example, which we first cache\n    var core = $.core;\n\n    // Then use some of the built-in core functionality to\n    // highlight all divs in the page yellow\n    core.highlightAll();\n\n    // Access the plug-ins (extensions) loaded into the \"plugin\"\n    // namespace of our core module:\n\n    // Set the first div in the page to have a green background.\n    core.plugin.setGreen( \"div:first\");\n    // Here we're making use of the core's \"highlight\" method\n    // under the hood from a plug-in loaded in after it\n\n    // Set the last div to the \"errorColor\" property defined in\n    // our core module/plug-in. If we review the code further down,\n    // we can see how easy it is to consume properties and methods\n    // between the core and other plug-ins\n    core.plugin.setRed(\"div:last\");\n});\n\n</script>\n```", "```\n// Module/plug-in core\n// Note: the wrapper code we see around the module is what enables\n// us to support multiple module formats and specifications by\n// mapping the arguments defined to what a specific format expects\n// to be present. Our actual module functionality is defined lower\n// down, where a named module and exports are demonstrated.\n//\n// Note that dependencies can just as easily be declared if required\n// and should work as demonstrated earlier with the AMD module examples.\n\n(function ( name, definition ){\n  var theModule = definition(),\n      // this is considered \"safe\":\n      hasDefine = typeof define === \"function\" && define.amd,\n      hasExports = typeof module !== \"undefined\" && module.exports;\n\n  if ( hasDefine ){ // AMD Module\n    define(theModule);\n  } else if ( hasExports ) { // Node.js Module\n    module.exports = theModule;\n  } else { // Assign to common namespaces or simply the global object (window)\n    ( this.jQuery || this.ender || this.$ || this)[name] = theModule;\n  }\n})( \"core\", function () {\n    var module = this;\n    module.plugins = [];\n    module.highlightColor = \"yellow\";\n    module.errorColor = \"red\";\n\n  // define the core module here and return the public API\n\n  // This is the highlight method used by the core highlightAll()\n  // method and all of the plug-ins highlighting elements different\n  // colors\n  module.highlight = function( el,strColor ){\n    if( this.jQuery ){\n      jQuery(el).css( \"background\", strColor );\n    }\n  }\n  return {\n      highlightAll:function(){\n        module.highlight(\"div\", module.highlightColor);\n      }\n  };\n\n});\n```", "```\n// Extension to module core\n\n(function ( name, definition ) {\n    var theModule = definition(),\n        hasDefine = typeof define === \"function\",\n        hasExports = typeof module !== \"undefined\" && module.exports;\n\n    if ( hasDefine ) { // AMD Module\n        define(theModule);\n    } else if ( hasExports ) { // Node.js Module\n        module.exports = theModule;\n    } else {\n\n        // Assign to common namespaces or simply the global object (window)\n        // account for flat-file/global module extensions\n        var obj = null,\n            namespaces,\n            scope;\n\n        obj = null;\n        namespaces = name.split(\".\");\n        scope = ( this.jQuery || this.ender || this.$ || this );\n\n        for ( var i = 0; i < namespaces.length; i++ ) {\n            var packageName = namespaces[i];\n            if ( obj && i == namespaces.length - 1 ) {\n                obj[packageName] = theModule;\n            } else if ( typeof scope[packageName] === \"undefined\" ) {\n                scope[packageName] = {};\n            }\n            obj = scope[packageName];\n        }\n\n    }\n})( \"core.plugin\" , function () {\n\n    // Define our module here and return the public API.\n    // This code could be easily adapted with the core to\n    // allow for methods that overwrite and extend core functionality\n    // in order to expand the highlight method to do more if we wish.\n    return {\n        setGreen: function ( el ) {\n            highlight(el, \"green\");\n        },\n        setRed: function ( el ) {\n            highlight(el, errorColor);\n        }\n    };\n\n});\n```"]