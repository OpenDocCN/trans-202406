- en: Chapter 7\. Working with Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like most types of data, string values can be compared for equality or inequality
    or relative ordering. However, strings have additional properties to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: A string can be binary or nonbinary. Binary strings are used for raw data such
    as images, music files, or encrypted values. Nonbinary strings are used for character
    data such as text and are associated with a character set and collation (sort
    order).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A character set determines which characters are legal in a string. You can choose
    collations according to whether you need comparisons to be case sensitive or case
    insensitive, or to use the rules of a particular language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types for binary strings are `BINARY`, `VARBINARY`, and `BLOB`. Data types
    for nonbinary strings are `CHAR`, `VARCHAR`, and `TEXT`, each of which permits
    `CHARACTER` `SET` and `COLLATE` attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can convert a binary string to a nonbinary string and vice versa, or convert
    a nonbinary string from one character set or collation to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a string in its entirety or extract substrings from it. Strings
    can be combined with other strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can apply pattern-matching operations to strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full-text searching is available for efficient queries on large collections
    of text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter discusses how to use those properties, so that you can store, retrieve,
    and manipulate strings according to any requirements your applications have.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts to create the tables used in this chapter are located in the *tables*
    directory of the `recipes` distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 String Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One string property is whether it is binary or nonbinary:'
  prefs: []
  type: TYPE_NORMAL
- en: A binary string is a sequence of bytes. It can contain any type of information,
    such as images, MP3 files, or compressed or encrypted data. A binary string is
    not associated with a character set, even if you store a value such as `abc` that
    looks like ordinary text. Binary strings are compared byte by byte using numeric
    byte values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nonbinary string is a sequence of characters. It stores text that has a particular
    character set and collation. The character set defines which characters can be
    stored in the string. The collation defines the character ordering, which affects
    comparison and sorting operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see which character sets are available for nonbinary strings, use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The default character set in MySQL 8.0 is `utf8mb4` with collation of `utf8mb4_0900_ai_ci`.
    If you must store characters from several languages in a single column, consider
    using one of the Unicode character sets (such as `utf8mb4` or `utf16`) because
    they can represent characters from multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: Some character sets contain only single-byte characters, whereas others permit
    multibyte characters. Some multibyte character sets contain characters of varying
    lengths. For others, all characters have a fixed length. For example, Unicode
    data can be stored using the `utf8mb4` character set in which characters take
    from one to four bytes or the `utf16` character set in which all characters take
    two bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In MySQL, to use the full set of Unicode characters, including supplemental
    characters that lie outside the Basic Multilingual Plane (BMP), use `utf8mb4`,
    in which characters take from one to four bytes. Other Unicode character sets
    that include supplemental characters are `utf16`, `utf16le`, and `utf32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether a given string contains multibyte characters, use the
    `LENGTH()` and `CHAR_LENGTH()` functions, which return the length of a string
    in bytes and characters, respectively. If `LENGTH()` is greater than `CHAR_LENGTH()`
    for a given string, multibyte characters are present:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `utf8` Unicode character set has multibyte characters, but a given `utf8`
    string might contain only single-byte characters, as in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the `utf16` Unicode character set, all characters are encoded using two
    bytes, even if they are single-byte characters in another character set such as
    `latin1`. Thus, every `utf16` string contains multibyte characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another property of nonbinary strings is collation, which determines the sort
    order of characters in the character set. Use `SHOW` `COLLATION` to see all available
    collations; add a `LIKE` clause to see the collations for a particular character
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In contexts where no collation is specified explicitly, strings in a given character
    set use the collation with `Yes` in the `Default` column. As shown, the default
    collation for `utf8mb4` is `utf8mb4_0900_ai_ci`. (Default collations are also
    displayed by `SHOW` `CHARACTER` `SET`.)
  prefs: []
  type: TYPE_NORMAL
- en: A collation can be case sensitive (`a` and `A` are different), case insensitive
    (`a` and `A` are the same), or binary (two characters are the same or different
    based on whether their numeric values are equal). A collation name ending in `_ci`,
    `_cs`, or `_bin` is case insensitive, case sensitive, or binary, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Binary strings and binary collations both use numeric values. The difference
    is that binary string comparisons are always based on single-byte units, whereas
    a binary collation compares nonbinary strings using *character* numeric values;
    depending on the character set, some of these might be multibyte values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how collation affects sort order. Suppose
    that a table contains a `utf8mb4` string column and has the following rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By applying the `COLLATE` operator to the column, you can choose which collation
    to use for sorting and thus affect the order of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A case-insensitive collation sorts `a` and `A` together, placing them before
    `b` and `B`. However, for a given letter, it does not necessarily order one lettercase
    before another, as shown by the following result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A case-sensitive collation puts `A` and `a` before `B` and `b`, and sorts lowercase
    before uppercase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A binary collation sorts characters using their numeric values. Assuming that
    uppercase letters have numeric values less than those of lowercase letters, a
    binary collation results in the following ordering:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that because characters in different lettercases have different numeric
    values, a binary collation produces a case-sensitive ordering. However, the order
    differs from that for the case-sensitive collation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you require that comparison and sorting operations use the sorting rules
    of a particular language, choose a language-specific collation. For example, if
    you store strings using the `utf8mb4` character set, the default collation (`utf8mb4_0900_ai_ci`)
    treats `ch` and `ll` as two-character strings. To use the traditional Spanish
    ordering that treats `ch` and `ll` as single characters that follow `c` and `l`,
    respectively, specify the `utf8mb4_spanish2_ci` collation. The two collations
    produce different results, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Ideally set the collation in the column definition in case you are not using
    the default collation by following;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure to avoid possible query performance degradation during sort
    operations by using wrong collation.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Choosing a String Data Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to store string data but aren’t sure which data type is the most appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Choose the data type according to the characteristics of the information to
    be stored and how you need to use it. Consider questions such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Are the strings binary or nonbinary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does case sensitivity matter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the maximum string length?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you want to store fixed- or variable-length values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you need to retain trailing spaces?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a fixed set of permitted values?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL provides several binary and nonbinary string data types. These types come
    in pairs as shown in the following table. The maximum length is in bytes, whether
    the type is binary or nonbinary. For nonbinary types, the maximum number of *characters*
    is less for strings that contain multibyte characters as we show in the [Table 7-1](#nch-strings-strings-types-lenghts)
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Maximum Number of Characters per Data Type
  prefs: []
  type: TYPE_NORMAL
- en: '| Binary data type | Nonbinary data type | Maximum length |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BINARY` | `CHAR` | 255 |'
  prefs: []
  type: TYPE_TB
- en: '| `VARBINARY` | `VARCHAR` | 65,535 |'
  prefs: []
  type: TYPE_TB
- en: '| `TINYBLOB` | `TINYTEXT` | 255 |'
  prefs: []
  type: TYPE_TB
- en: '| `BLOB` | `TEXT` | 65,535 |'
  prefs: []
  type: TYPE_TB
- en: '| `MEDIUMBLOB` | `MEDIUMTEXT` | 16,777,215 |'
  prefs: []
  type: TYPE_TB
- en: '| `LONGBLOB` | `LONGTEXT` | 4,294,967,295 |'
  prefs: []
  type: TYPE_TB
- en: For the `BINARY` and `CHAR` data types, MySQL stores column values using a fixed
    width. For example, values stored in a `BINARY(10)` or `CHAR(10)` column always
    take 10 bytes or 10 characters, respectively. Shorter values are padded to the
    required length as necessary when stored. For `BINARY`, the pad value is `0x00`
    (the zero-valued byte, also known as ASCII NUL). `CHAR` values are padded with
    spaces for storage and trailing spaces are stripped upon retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: For `VARBINARY`, `VARCHAR`, and the `BLOB` and `TEXT` types, MySQL stores values
    using only as much storage as required, up to the maximum column length. No padding
    is added or stripped when values are stored or retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To preserve trailing pad values that are present in the original strings that
    are stored, use a data type for which no stripping occurs. For example, if you
    store character (nonbinary) strings that might end with spaces, and want to preserve
    them, use `VARCHAR` or one of the `TEXT` data types. The following statements
    illustrate the difference in trailing-space handling for `CHAR` and `VARCHAR`
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This shows that if you store a string that contains trailing spaces into a `CHAR`
    column, they’re removed when you retrieve the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A table can include a mix of binary and nonbinary string columns, and its nonbinary
    columns can use different character sets and collations. When you declare a nonbinary
    string column, use the `CHARACTER` `SET` and `COLLATE` attributes if you require
    a particular character set and collation. For example, if you need to store `utf8mb4`
    (Unicode) and `sjis` (Japanese) strings, you might define a table with two columns
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CHARACTER` `SET` and `COLLATE` clauses are each optional in a column definition:'
  prefs: []
  type: TYPE_NORMAL
- en: If you specify `CHARACTER` `SET` and omit `COLLATE`, the default collation for
    the character set is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you specify `COLLATE` and omit `CHARACTER` `SET`, the character set implied
    by the collation name (the first part of the name) is used. For example, `utf8mb4_danish_ci`
    and `sjis_japanese_ci` imply `utf8mb4` and `sjis`, respectively. This means that
    the `CHARACTER` `SET` attributes could have been omitted from the preceding `CREATE`
    `TABLE` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you omit both `CHARACTER` `SET` and `COLLATE`, the column is assigned the
    table default character set and collation. A table definition can include those
    attributes following the closing parenthesis at the end of the `CREATE` `TABLE`
    statement. If present, they apply to columns that have no explicit character set
    or collation of their own. If omitted, the table defaults are taken from the database
    defaults. You can specify the database defaults when you create the database with
    the `CREATE` `DATABASE` statement. The server defaults apply to the database if
    they are omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server default character set and collation for MySQL 8.0 are `utf8mb4` and
    `utf8mb4_0900_ai_ci`, so strings by default use the `utf8mb4` character set and
    are not case sensitive. To change this, set the `character_set_server` and `collation_server`
    system variables at server startup (see [Recipe 22.1](ch22.xhtml#nch-admin-server-config)).
  prefs: []
  type: TYPE_NORMAL
- en: MySQL also supports `ENUM` and `SET` string types, which are used for columns
    that have a fixed set of permitted values. The `CHARACTER` `SET` and `COLLATE`
    attributes apply to these data types as well.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Setting the Client Connection Character Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re executing SQL statements or producing query results that don’t use the
    default character set.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `SET` `NAMES` or an equivalent method to set your connection to the proper
    character set.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you send information back and forth between your application and the server,
    you may need to tell MySQL the appropriate character set. For example, the default
    character set is `latin1`, but that may not always be the proper character set
    to use for connections to the server. If you have Greek data, displaying it using
    `latin1` will result in gibberish on your screen. If you use Unicode strings in
    the `utf8mb4` character set, `latin1` might not be sufficient to represent all
    the characters that you might need.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with this problem, configure your connection to use the appropriate
    character set. You have several ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue a `SET` `NAMES` statement after you connect:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SET` `NAMES` permits the connection collation to be specified as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your client program supports the `--default-character-set` option, you can
    use it to specify the character set at program invocation time. *mysql* is one
    such program. Put the option in an option file so that it takes effect each time
    you connect to the server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you set the environment for your working environment using the `LANG` or
    `LC_ALL` environment variable on Unix, or the code page setting on Windows, MySQL
    client programs automatically detect which character set to use. For example,
    setting `LC_ALL` to `en_US.UTF-8` causes programs such as *mysql* to use `utf8`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some programming interfaces provide their own method of setting the character
    set. For example, MySQL Connector/J for Java clients detects the character set
    used on the server side automatically when you connect, but you can specify a
    different set explicitly using the `characterEncoding` property in the connection
    URL. The property value should be the Java-style character-set name. To select
    `utf8mb4`, you might use a connection URL like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is preferable to `SET` `NAMES` because Connector/J performs character-set
    conversion on behalf of the application, but is unaware of which character set
    applies if you use `SET` `NAMES`. Similar principles apply to programs written
    for other APIs. For PHP Data Objects (PDO), use a `charset` option in your data
    source name (DSN) string (this works in PHP 5.3.6 or later):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Connector/Python, specify a `charset` connection parameter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For Go, specify a `charset` connection parameter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Some APIs may also provide a parameter to specify the collation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Some character sets cannot be used as the connection character set: `utf16`,`utf16le`,
    `utf32`.'
  prefs: []
  type: TYPE_NORMAL
- en: You should also ensure that the character set used by your display device matches
    what you use for MySQL. Otherwise, even with MySQL handling the data properly,
    it might display as garbage. Suppose that you use the *mysql* program in a terminal
    window and that you configure MySQL to use `utf8mb4` and store `utf8mb4`-encoded
    Turkish data. If you set your terminal window to use `euc-tr` encoding, that is
    also Turkish, but its encoding for Turkish characters differs from `utf8mb4`,
    so the data will not display as you expect. (If you use autodetection, this should
    not be an issue.)
  prefs: []
  type: TYPE_NORMAL
- en: In an example Turkish characters inserted in a table will show garbled in a
    connection made with different character set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From another connection using `Latin1` client character set will result following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To verify that you’re connected with correct character set to MySQL command
    line interface issue following to show status.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 7.4 Writing String Literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to write literal strings in SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn the syntax rules that govern string values.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can write strings several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enclose the text of the string within single quotes or double quotes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the `ANSI_QUOTES` SQL mode is enabled, you cannot use double quotes for
    quoting strings: the server interprets double quote as the quoting character for
    identifiers such as table or column names, and not for strings (see [Recipe 4.6](ch04.xhtml#nch-api-api-ident-quoting)).
    If you adopt the convention of always writing quoted strings using single quotes,
    MySQL interprets them as strings and not as identifiers regardless of the `ANSI_QUOTES`
    setting.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use hexadecimal notation. Each pair of hex digits produces one byte of the
    string. `abcd` can be written using any of these formats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MySQL treats strings written using hex notation as binary strings. Not coincidentally,
    it’s common for applications to use hex strings when constructing SQL statements
    that refer to binary values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To specify a character set for interpretation of a literal string, use an introducer
    consisting of a character-set name preceded by an underscore:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An introducer tells the server how to interpret the string that follows it.
    For `_utf8mb4` `'abcd'`, the server produces a string consisting of four single-byte
    characters. For `_ucs2` `'abcd'`, the server produces a string consisting of two
    two-byte characters because `ucs2` is a double-byte character set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To ensure that a string is a binary string or that a nonbinary string has a
    specific character set or collation, use the instructions for string conversion
    given in [Recipe 7.5](#nch-strings-strings-charset-checking-changing).
  prefs: []
  type: TYPE_NORMAL
- en: 'A quoted string that includes the same quote character produces a syntax error
    if executed by an API or in the *mysql* batch mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If executed interactively by the *mysql* client, it waits for the closing quote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You have several ways to deal with this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enclose a string containing single quotes within double quotes (assuming that
    `ANSI_QUOTES` is disabled), or enclose a string containing double quotes within
    single quotes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To include a quote character within a string quoted by the same kind of quote,
    double the quote or precede it with a backslash. When MySQL reads the statement,
    it strips the extra quote or the backslash:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A backslash turns off any special meaning of the following character, including
    itself. To write a literal backslash within a string, double it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Backslash causes a temporary escape from normal string processing rules, so
    sequences such as `\'`, `\"`, and `\\` are called escape sequences. Others recognized
    by MySQL are `\b` (backspace), `\n` (newline, also called linefeed), `\r` (carriage
    return), `\t` (tab), and `\0` (ASCII NUL).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the string as a hex value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Starting from version 8.0 *mysql* client is running with option `--binary-as-hex`
    by default. If you do not disable this option you would get binary output as hex
    values. For example, for the above command you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To get human-readable output start the *mysql* client with option `--binary-as-hex=0`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you execute SQL statements from within a program, you can refer to strings
    or binary values symbolically and let your programming interface take care of
    quoting: use the placeholder mechanism provided by the language’s database-access
    API (see [Recipe 4.5](ch04.xhtml#nch-api-api-quoting)). Alternatively, load binary
    values such as images from files using the `LOAD_FILE()` function (see [MySQL
    documentation](https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_load-file)).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Checking or Changing a String’s Character Set or Collation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the character set or collation of a string, or change a string
    to some other character set or collation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To check a string’s character set or collation, use the `CHARSET()` or `COLLATION()`
    function. To change its character set, use the `CONVERT()` function. To change
    its collation, use the `COLLATE` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a table created as follows, you know that values stored in the column `c`
    have a character set of `utf8` and a collation of `utf8_danish_ci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But sometimes it’s not so clear what character set or collation applies to a
    string. Server configuration can affect literal strings and some string functions,
    and other string functions return values in a specific character set. Symptoms
    that you have the wrong character set or collation are that a collation-mismatch
    error occurs for a comparison operation, or a lettercase conversion doesn’t work
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: To determine a string’s character set or collation, use the `CHARSET()` or `COLLATION()`
    function. For example, did you know that the `USER()` function returns a Unicode
    string?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'String values that take their character set and collation from the current
    client configuration may change properties if the configuration changes. This
    is true for literal strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For a binary string, the `CHARSET()` or `COLLATION()` functions return a value
    of `binary`, which means that the string is compared and sorted based on numeric
    byte values, not character collation values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a string from one character set to another, use the `CONVERT()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the collation of a string, use the `COLLATE` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The new collation must be legal for the character set of the string. For example,
    you can use the `utf8_general_ci` collation with `utf8mb3` strings, but not with
    `latin1` strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert both the character set and collation of a string, use `CONVERT()`
    to change the character set, and apply the `COLLATE` operator to the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CONVERT()` function can also convert binary strings to nonbinary strings
    and vice versa. To produce a binary string, use `binary`; any other character-set
    name produces a nonbinary string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, produce binary strings using the `CAST` function, which is equivalent
    to `CONVERT(`*`str`* `USING` `binary)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also [Recipe 7.3](#nch-strings-strings-set-names) for more information on
    character sets.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Converting the Lettercase of a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert a string to uppercase or lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `UPPER()` or `LOWER()` function. If they don’t work, you’re probably
    trying to convert a binary string. Convert it to a nonbinary string that has a
    character set and collation and is subject to case mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UPPER()` and `LOWER()` functions convert the lettercase of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: But some strings are <q>stubborn</q> and resist lettercase conversion. To get
    human-readable output start the mysql client with option binary-as-hex=0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This problem occurs for strings that have a `BINARY` or `BLOB` data type. These
    are binary strings that have no character set or collation. Lettercase does not
    apply, and `UPPER()` and `LOWER()` do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To map a binary string to a given lettercase, convert it to a nonbinary string,
    choosing a character set that has uppercase and lowercase characters. The case-conversion
    functions then work as you expect because the collation provides case mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The example uses a table column, but the same principles apply to binary string
    literals and string expressions.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not sure whether a string expression is binary or nonbinary, use the
    `CHARSET()` function to find out; see [Recipe 7.5](#nch-strings-strings-charset-checking-changing).
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the lettercase of only part of a string, break it into pieces, convert
    the relevant piece, and put the pieces back together. Suppose that you want to
    convert only the initial character of a string to uppercase. The following expression
    accomplishes that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'But it’s ugly to write an expression like that each time you need it. For convenience,
    define a stored function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can capitalize initial characters more easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For more information about writing stored functions, see [Chapter 11](ch11.xhtml#nch-routines).
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Comparing String Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know whether strings are equal or unequal, or which appears first
    in lexical order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a comparison operator. But remember that strings have properties such as
    case sensitivity that you must take into account. A string comparison might be
    case sensitive when you don’t want it to be, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case with other data types, you can compare string values for equality,
    inequality, or relative ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, comparison and sorting properties of strings are subject to complications
    that don’t apply to other types of data. For example, sometimes you must ensure
    that a string comparison is case sensitive that would not otherwise be, or vice
    versa. This section describes how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'String comparison properties depend on whether the operands are binary or nonbinary
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: A binary string is a sequence of bytes and is compared using numeric byte values.
    Lettercase has no meaning. However, because letters in different cases have different
    byte values, comparisons of binary strings effectively are case sensitive. (That
    is, `a` and `A` are unequal.) To compare binary strings such that lettercase does
    not matter, convert them to nonbinary strings that have a case-insensitive collation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A nonbinary string is a sequence of characters and is compared in character
    units. (Depending on the character set, some characters might have multiple bytes.)
    The string has a character set that defines the legal characters and a collation
    that defines their sort order. The collation also determines whether to consider
    characters in different lettercases the same in comparisons. If the collation
    is case sensitive, and you want a case-insensitive collation (or vice versa),
    convert the strings to use a collation with the desired case-comparison properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, strings have a character set of `utf8mb4` and a collation of `utf8mb4_0900_ai_ci`
    unless you reconfigure the server (see [Recipe 22.1](ch22.xhtml#nch-admin-server-config)).
    This results in case-insensitive string comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how two binary strings that compare as unequal
    can be handled so that they are equal when compared as case-insensitive nonbinary
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, because `utf8mb4_0900_ai_ci` is the default collation for `utf8mb4`,
    you can omit the `COLLATE` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The next example shows how to compare, in case-sensitive fashion, two strings
    that are not case sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compare a binary string with a nonbinary string, the comparison treats
    both operands as binary strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, to compare two nonbinary strings as binary strings, cast them to the
    `BINARY` data type to either one when comparing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find that you’ve declared a column using a type not suited to the kind
    of comparisons for which you typically use it, use `ALTER` `TABLE` to change the
    type. Suppose that this table stores news articles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the `article` column is declared as a `BLOB`. That is a binary string
    type, so comparisons of text stored in the column are made without regard to character
    set. (In effect, they are case sensitive.) If that’s not what you want, use `ALTER`
    `TABLE` to convert the column to a nonbinary type that has a case-insensitive
    collation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 7.8 Converting Between Decimal, Octal and Hexadecimal Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert between one numeric base to another.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `CONV()` function and SQL pattern described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is difficult to operate literals as text strings in some formats such as
    `HEX`. An alternative method is to convert them to binary values. This will produce
    data type with a value of BINARY(16) that is 128 bits long. Using `BIN()`,`OCT()`,`HEX()`
    functions to convert between decimal number to binary, octal and hexadecimal is
    already possible. What if we you to do the reverse? This is where `CONV()` function
    comes handy. With the `CONV()` function from we can convert from one numeric base
    system to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax to use `CONV()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: A `number` is a value which we want to convert from one numeric base to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `from_base` is original base value of the numeric base limited to value between
    2 and 36.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `to_base` is target value of the numeric base. This value can be between 2
    and 36 or -2 and -36.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `BIN()` function we get same result. Although `BIN()` function returns
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Like wise we can convert values between each other in reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 7.9 Converting Between ASCII,BIT and Hexadecimal Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert between one string format to another.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the MySQL `CHAR()`, `ASCII()` ,`BIT_LENGTH()` functions and SQL pattern
    described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many powerful string functions to support MySQL’s string operations.
    In different use cases we may have to convert them to have different results.
    Using some of the string functions such as `ASCII()` we can convert between other
    formats like `BIT` and `HEX`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax to use `ASCII()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `ASCII()` function only returns left most character’s numeric value of the
    string. This is similar to MySQL’s `ORD()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the result is same for both strings. The function only takes
    the leftmost character of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will convert a string value to `HEX` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we have table `name` and want to get all unique `last_name` from this table
    in `HEX` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Bit operations before MySQL 8.0 handled on unsingned 64-bit integer values.
    After MySQL 8.0 bit operations extended to handle binary string arguments. This
    allowed strings that are not integers or binary strings to be converted. UUID
    (Universal Unique Identifier) specified by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)
    is a 128-bit unique value globally when complete uniqueness is required. UUIDs
    also come in handy using for security purposes since it does not reveal any information
    about data. It is represented in human readable format as `utf8mb4` with the string
    of five hexadecimal numbers. A good example is converting `UUID` value to binary
    by using `UUID_TO_BIN` function (we are running *mysql* with option `binary-as-hex`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Later we can convert this value to compare bit count using `BIT_COUNT()` function.
    This function mainly used to identify active bits in given input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `BIT_COUNT()` function is to identify active bits in given
    decimal value. For example if we were to find out active bits in number 18\. Binary
    conversion of 18 is `10010` hence active bits are only two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`BIT_COUNT()` function powered with `BIT_OR()` function can be combined to
    calculate following problem. `BIT_OR()` function returns the bitwise OR all the
    bits in an expression. Say we want to find number of Sundays in month of November.
    We will create a table called `sundays`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This example can be extended to find number of holidays in a given calendar
    year or date range.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is IPv6 and IPv4 network addresses are string values. In order
    to return binary value to represent it in numeric `INET_ATON()` function can be
    used. This function converts dotted quad IPv4 adress string represenation to numeric
    value. While use cases for this function may vary it is widely used for storing
    source and destionation of IP addresses for data as well as transactions mostly
    logging purposes. Once the IPv4 address is stored in numeric value than it can
    be indexed and processed faster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 7.10 Pattern Matching with SQL Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to perform a pattern match, not a literal comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `LIKE` operator and an SQL pattern, described in this section. Or use
    a regular-expression pattern match, described in [Recipe 7.11](#nch-strings-strings-pat-regexp).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Patterns are strings that contain special characters known as metacharacters
    because they stand for something other than themselves. MySQL provides two kinds
    of pattern matching. One is based on SQL patterns and the other on regular expressions.
    SQL patterns are more standard among different database systems, but regular expressions
    are more powerful. The two kinds of pattern match use different operators and
    different metacharacters. This section describes SQL patterns. [Recipe 7.11](#nch-strings-strings-pat-regexp)
    describes regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example here uses a table named `metal` that contains the following rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL pattern matching uses the `LIKE` and `NOT` `LIKE` operators rather than
    `=` and `<>` to perform matching against a pattern string. Patterns may contain
    two special metacharacters: `_` matches any single character, and `%` matches
    any sequence of characters, including the empty string. You can use these characters
    to create patterns that match a variety of values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings that begin with a particular substring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Strings that end with a particular substring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Strings that contain a particular substring at any position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Strings that contain a substring at a specific position (the pattern matches
    only if `at` occurs at the third position of the `name` column):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An SQL pattern matches successfully only if it matches the entire comparison
    value. Of the following two pattern matches, only the second succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To reverse the sense of a pattern match, use `NOT` `LIKE`. The following statement
    finds strings that contain no `i` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL patterns do not match `NULL` values. This is true both for `LIKE` and for
    `NOT` `LIKE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, pattern matches are equivalent to substring comparisons. For
    example, using patterns to find strings at one end or the other of a string is
    like using `LEFT()` or `RIGHT()`, as shown in the [Table 7-2](#nch-strings-strings-pat-sql-substr-comp):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2\. Patern Match versus Substring Comparison
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern match | Substring comparison |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *`str`* `LIKE ''abc%''` | `LEFT(`*`str`*`,3) = ''abc''` |'
  prefs: []
  type: TYPE_TB
- en: '| *`str`* `LIKE ''%abc''` | `RIGHT(`*`str`*`,3) = ''abc''` |'
  prefs: []
  type: TYPE_TB
- en: If you’re matching against a column that is indexed and you have a choice of
    using a pattern or an equivalent `LEFT()` exprlenghtession, you’ll likely find
    the pattern match to be faster. MySQL can use the index to narrow the search for
    a pattern that begins with a literal string. With `LEFT()`, it cannot. Also `LIKE`
    comparison with a `%` in the beginning can be slow due to optimizer checking entire
    content of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Case sensitivity of a pattern match is like that of a string comparison. That
    is, it depends on whether the operands are binary or nonbinary strings, and for
    nonbinary strings, it depends on their collation. See [Recipe 7.7](#nch-strings-strings-compare)
    for discussion of how these factors apply to comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 7.11 Pattern Matching with Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to perform a pattern match, not a literal comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `REGEXP` operator and a regular expression pattern, described in this
    section. Or use an SQL pattern, described in [Recipe 7.10](#nch-strings-strings-pat-sql).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL patterns (see [Recipe 7.10](#nch-strings-strings-pat-sql)) are likely to
    be implemented by other database systems, so they’re reasonably portable beyond
    MySQL. On the other hand, they’re somewhat limited. For example, you can easily
    write an SQL pattern `%abc%` to find strings that contain `abc`, but you cannot
    write a single SQL pattern to identify strings that contain any of the characters
    `a`, `b`, or `c`. Nor can you match string content based on character types such
    as letters or digits. For such operations, MySQL supports another type of pattern-matching
    operation based on regular expressions and the `REGEXP` operator (or `NOT` `REGEXP`
    to reverse the sense of the match). `REGEXP` matching uses the pattern elements
    shown in the [Table 7-4](#nch-strings-strings-pat-regexp-syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-4\. Popular Regular Expressions Syntax
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | What the pattern matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Beginning of string |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of string |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any single character |'
  prefs: []
  type: TYPE_TB
- en: '| `[...]` | Any character listed between the square brackets |'
  prefs: []
  type: TYPE_TB
- en: '| `[^...]` | Any character not listed between the square brackets |'
  prefs: []
  type: TYPE_TB
- en: '| *`p1`*`&#124;`*`p2`*`&#124;`*`p3`* | Alternation; matches any of the patterns
    *`p1`*, *`p2`*, or *`p3`* |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Zero or more instances of preceding element |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | One or more instances of preceding element |'
  prefs: []
  type: TYPE_TB
- en: '| `{`*`n`*`}` | *`n`* instances of preceding element |'
  prefs: []
  type: TYPE_TB
- en: '| `{`*`m`*`,`*`n`*`}` | *`m`* through *`n`* instances of preceding element
    |'
  prefs: []
  type: TYPE_TB
- en: You may already be familiar with these regular expression pattern characters;
    many of them are the same as those used by *vi*, *grep*, *sed*, and other Unix
    utilities that support regular expressions. Most of them are used also in the
    regular expressions understood by programming languages. (For discussion of pattern
    matching in programs for data validation and transformation, see [Chapter 14](ch14.xhtml#nch-format).)
  prefs: []
  type: TYPE_NORMAL
- en: '[Recipe 7.10](#nch-strings-strings-pat-sql) shows how to use SQL patterns to
    match substrings at the beginning or end of a string, or at an arbitrary or specific
    position within a string. You can do the same things with regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings that begin with a particular substring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Strings that end with a particular substring:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Strings that contain a particular substring at any position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Strings that contain a particular substring at a specific position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, regular expressions have other capabilities and can perform matches
    that SQL patterns cannot. For example, regular expressions can contain character
    classes, which match any character in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: To write a character class, use square brackets and list the characters you
    want the class to match inside the brackets. Thus, the pattern `[abc]` matches
    `a`, `b`, or `c`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes can indicate ranges of characters; use a dash between the beginning
    and end of the range. `[a-z]` matches any letter, `[0-9]` matches digits, and
    `[a-z0-9]` matches letters or digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To negate a character class (<q>match any character but these</q>), begin the
    list with a `^` character. For example, `[^0-9]` matches anything but digits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL’s regular-expression capabilities also support POSIX character classes.
    These match specific character sets, as described in the [Table 7-5](#nch-strings-strings-pat-regexp-posix):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-5\. POSIX Regular Expressions Syntax
  prefs: []
  type: TYPE_NORMAL
- en: '| POSIX class | What the class matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alnum:]` | Alphabetic and numeric characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:alpha:]` | Alphabetic characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:blank:]` | Whitespace (space or tab characters) |'
  prefs: []
  type: TYPE_TB
- en: '| `[:cntrl:]` | Control characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:digit:]` | Digits |'
  prefs: []
  type: TYPE_TB
- en: '| `[:graph:]` | Graphic (nonblank) characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:lower:]` | Lowercase alphabetic characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:print:]` | Graphic or space characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:punct:]` | Punctuation characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:space:]` | Space, tab, newline, carriage return |'
  prefs: []
  type: TYPE_TB
- en: '| `[:upper:]` | Uppercase alphabetic characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[:xdigit:]` | Hexadecimal digits (`0-9`, `a-f`, `A-F`) |'
  prefs: []
  type: TYPE_TB
- en: 'POSIX classes are intended for use within character classes, so use them within
    square brackets. The following expression matches values that contain any hexadecimal
    digit character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular expressions can specify alternations using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternation is similar to a character class in the sense that it matches
    if any of the alternatives match. But unlike a character class, the alternatives
    are not limited to single characters. They can be multiple-character strings or
    even patterns. The following alternation matches strings that begin with a vowel
    or end with `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Parentheses can be used to group alternations. For example, to match strings
    that consist entirely of digits or entirely of letters, you might try this pattern,
    using an alternation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as the query result shows, the pattern doesn’t work. That’s because
    the `^` groups with the first alternative, and the `$` groups with the second
    alternative. So the pattern actually matches strings that begin with one or more
    digits, or strings that end with one or more letters. If you group the alternatives
    within parentheses, the `^` and `$` apply to both of them, and the pattern acts
    as you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike SQL pattern matches, which are successful only if the pattern matches
    the entire comparison value, regular expressions are successful if the pattern
    matches anywhere within the value. The following two pattern matches are equivalent
    in the sense that each one succeeds only for strings that contain a `b` character,
    but the first is more efficient because the pattern is simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Regular expressions do not match `NULL` values. This is true both for `REGEXP`
    and for `NOT` `REGEXP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Because a regular expression matches a string if the pattern is found anywhere
    in the string, you must take care not to inadvertently specify a pattern that
    matches the empty string. If you do, it matches any non-`NULL` value. For example,
    the pattern `a*` matches any number of `a` characters, even none. If your goal
    is to match only strings containing nonempty sequences of `a` characters, use
    `a+` instead. The `+` requires one or more instances of the preceding pattern
    element for a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with SQL pattern matches performed using `LIKE`, regular-expression matches
    performed with `REGEXP` sometimes are equivalent to substring comparisons. As
    shown in the [Table 7-6](#nch-strings-strings-pat-regexp-substr-comp), the `^`
    and `$` metacharacters serve much the same purpose as `LEFT()` or `RIGHT()`, at
    least if you’re looking for literal strings:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-6\. Regular Expressions versus Substring Comparison Functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern match | Substring comparison |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *`str`* `REGEXP ''^abc''` | `LEFT(`*`str`*`,3) = ''abc''` |'
  prefs: []
  type: TYPE_TB
- en: '| *`str`* `REGEXP ''abc$''` | `RIGHT(`*`str`*`,3) = ''abc''` |'
  prefs: []
  type: TYPE_TB
- en: 'For nonliteral patterns, it’s typically not possible to construct an equivalent
    substring comparison. For example, to match strings that begin with any nonempty
    sequence of digits, use this pattern match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: That is something that `LEFT()` cannot do (and neither can `LIKE`, for that
    matter).
  prefs: []
  type: TYPE_NORMAL
- en: Case sensitivity of a regular-expression match is like that of a string comparison.
    That is, it depends on whether the operands are binary or nonbinary strings, and
    for nonbinary strings, it depends on their collation. See [Recipe 7.7](#nch-strings-strings-compare)
    for discussion of how these factors apply to comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prior version 8.0.4, regular expresisons worked only for single-byte character
    sets. In MySQL 8.0.4 this limitation was removed and now you can use regular expressions
    with multibyte character sets such as `utf8mb4` or `sjis`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.12 Reversing the string content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to modify a string, and find its reverse form.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use function `REVERSE()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can reverse a string or a sub-string by using `REVERSE()` function. This
    function utilizes any string value into its reverse form by character. It’s also
    often used in `SELECT` statements like many other functions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax to use `REVERSE()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Following examples are showing basic functionality of `REVERSE()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The following example shows the when the expression is `numeric` value the zero
    values is omitted by the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'While we can reverse any expression we also have some words returns exactly
    the same written in reverse known as Palindrome. For such strings function `REVERSE`
    will return string, equal to the original one. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The broader example uses table `top_names` from the *recipes* distribution,
    that stores the most common used names. Among these names we will find out the
    number of palindromatic names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Just to get a sample from this count we can have a look names start with “U”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 7.13 Searching for Substrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know whether a given string occurs within another string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `LOCATE()` or a pattern match.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `LOCATE()` function takes two arguments representing the substring that
    you’re looking for and the string in which to look for it. The return value is
    the position at which the substring occurs, or `0` if it’s not present. An optional
    third argument may be given to indicate the position within the string at which
    to start looking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine only whether the substring is present if you don’t care about
    its position, an alternative is to use `LIKE` or `REGEXP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '`LOCATE()`, `LIKE`, and `REGEXP` use the collation of their arguments to determine
    whether the search is case sensitive. [Recipe 7.5](#nch-strings-strings-charset-checking-changing)
    and [Recipe 7.7](#nch-strings-strings-compare) discuss changing the argument comparison
    properties if you want to change the search behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.14 Breaking Apart or Combining Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to extract a piece of a string or combine strings to form a larger
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To obtain a piece of a string, use a substring-extraction function. To combine
    strings, use `CONCAT()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can break apart strings by using appropriate substring-extraction functions.
    For example, `LEFT()`, `MID()`, and `RIGHT()` extract substrings from the left,
    middle, or right part of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: For `LEFT()` and `RIGHT()`, the second argument indicates how many characters
    to return from the left or right end of the string. For `MID()`, the second argument
    is the starting position of the substring you want (beginning from 1), and the
    third argument indicates how many characters to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SUBSTRING()` function takes a string and a starting position, returning
    everything to the right of the position. `MID()` acts the same way if you omit
    its third argument because `MID()` is actually a synonym for `SUBSTRING()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `SUBSTRING_INDEX(`*`str`*`,`*`c`*`,`*`n`*`)` to return everything to the
    right or left of a given character. It searches into a string *`str`* for the
    *`n`*-th occurrence of the character *`c`* and returns everything to its left.
    If *`n`* is negative, the search for *`c`* starts from the right and returns everything
    to the right of the character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: If there is no *`n`*-th occurrence of the character, `SUBSTRING_INDEX()` returns
    the entire string. `SUBSTRING_INDEX()` is case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use substrings for purposes other than display, such as to perform
    comparisons. The following statement finds metal names having a first letter that
    lies in the last half of the alphabet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'To combine rather than pull apart strings, use the `CONCAT()` function. It
    concatenates its arguments and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenation can be useful for modifying column values <q>in place.</q> For
    example, the following `UPDATE` statement adds a string to the end of each `name`
    value in the `metal` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'To undo the operation, strip the last three characters (the `CHAR_LENGTH()`
    function returns the length of a string in characters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The concept of modifying a column in place can be applied to `ENUM` or `SET`
    values as well, which usually can be treated as string values even though they
    are stored internally as numbers. For example, to concatenate a `SET` element
    to an existing `SET` column, use `CONCAT()` to add the new value to the existing
    value, preceded by a comma. But remember to account for the possibility that the
    existing value might be `NULL`. In that case, set the column value equal to the
    new element, without the leading comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 7.15 Using Full-Text Searches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to search long text columns.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `FULLTEXT` index.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pattern matches enable you to look through any number of rows, but as the amount
    of text goes up, the match operation can become quite slow. It’s also a common
    task to search for the same text in several string columns, but with pattern matching,
    that results in unwieldy queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: A useful alternative is full-text searching, which is designed for looking through
    large amounts of text and can search multiple columns simultaneously. To use this
    capability, add a `FULLTEXT` index to your table, and then use the `MATCH` operator
    to look for strings in the indexed column or columns. `FULLTEXT` indexing can
    be used with MyISAM tables or InnoDB tables for nonbinary string data types (`CHAR`,
    `VARCHAR`, or `TEXT`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Full-text searching is best illustrated with a reasonably good-sized body of
    text. If you don’t have a sample dataset, you can find several repositories of
    freely available electronic text on the Internet. For the examples here, the one
    we’ve chosen is the sample dump of the Amazon review data (2018), which is both
    available for public to download and scrape from [Amazon Review Data (2018).](https://nijianmo.github.io/amazon/index.html)
    Because of its size, this dataset is not included with the `recipes` distribution,
    but is available separately as instructions at GitHub repository. The `Amazon`
    distribution includes a file named *Appliances_5.json* that contains the product
    reviews for each category. This is subset of larger datasets. As most text-based
    data are found on the Internet, this data is only available in `JSON` data format.
    Some sample records look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: What we are interested in here is `reviewText` field which has the large body
    of text we are looking to examine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each record contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`overall` rating of the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`verified` purchase verification flag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reviewTime` date of the review'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reviewerID` - ID of the reviewer(`O` or `N`), e.g. A2SUAM1J3GNN3B'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asin` - ID of the product, e.g. 0000013714'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`style` a discretionary of the product metadata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reviewerName` name of the reviewer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reviewText` text of the review'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unixReviewTime` time of the review (unix time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To import the records into MySQL, create a table named `reviews` that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: In order to load `json` data to this table we could have used MySQL built-in
    json functions which is later covered in [Recipe 13.17](ch13.xhtml#nch-xfer-xfer-importjson).
    On some cases of large text data can include escape characters such as end of
    line `/n/n` which breaks the import functions to work. To overcome we’ll use simple
    script to load the data which is provided in GitHub repository called `load_amazon_reviews.py`.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the data we will convert the `reviewText` column as generated
    column and add `FULLTEXT` index to enable its use in full-text searching.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The table has now `FULLTEXT` index to enable its use in full-text searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the `reviews` table, load the *Appliances_5.json* file into
    it using this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that the `reviews` table contains columns both for complete `appliences_review`
    data as well as `reviews_virtual` to demonstrate the `FULLTEXT` index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a search using the `FULLTEXT` index, use `MATCH()` to name the indexed
    column and `AGAINST()` to specify what text to look for. For example, you might
    wonder, <q>How many times does the word “awesome” occur?</q> To answer that question,
    search the `reviews_virtual` column using this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: To verify `FULLTEXT` index was used
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out which products had the keyword “excellent” in `reviews` are, select
    the columns you want to see (the example here truncates the `reviews_virtual`
    column and uses `\G` so the results better fit the page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, full-text searches compute a relevance ranking and use it for sorting.
    To make sure a search result is sorted the way you want, add an explicit `ORDER`
    `BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: To see the relevance ranking, repeat the `MATCH()` … `AGAINST()` expression
    in the output column list.
  prefs: []
  type: TYPE_NORMAL
- en: To narrow the search further, include additional criteria. To provide additional
    fields in the search we’ll add the following virtual columns from `json` extract.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The following queries perform progressively more specific searches to determine
    how often each keyword occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If you expect to use search criteria frequently that include other non-`FULLTEXT`
    columns, add regular indexes to those columns so that queries perform better.
    For example, to index the vote, overall rating and verified columns, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Search strings in full-text queries can include more than one word, and you
    might suppose that adding words would make a search more specific. But in fact
    that widens it because a full-text search returns rows that contain any of the
    words. In effect, the query performs an `OR` search for any of the words. The
    following queries illustrate this; they identify successively larger numbers of
    reviews as additional search words are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: To perform a search for which each word in the search string must be present,
    see [Recipe 7.17](#nch-strings-strings-full-text-boolean).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use full-text searches that look through multiple columns simultaneously,
    name all the columns when you construct the `FULLTEXT` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'To issue a search query that uses the index, name those same columns in the
    `MATCH()` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: You need one such `FULLTEXT` index for each distinct combination of columns
    that you want to search.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For further information on `FULLTEXT` indexing see [Recipe 21.9](ch21.xhtml#nch-queryperf-queryperf-fulltext).
  prefs: []
  type: TYPE_NORMAL
- en: 7.16 Using a Full-Text Search with Short Words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your full-text searches for short words return no rows.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Change the indexing engine’s minimum word length parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a text like the `reviews`, certain words have special significance, such
    as <q>ok</q> and <q>up</q>. You might want to check fulltext index server variables
    first to make sure minimum length is satisfied by the engine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'One property of the indexing engine is that it ignores words that are <q>too
    common</q> (that is, words that occur in more than half the rows). This eliminates
    words such as <q>the</q> or <q>and</q> from the index, but that’s not what is
    going on here. You can verify that by counting the total number of rows, and by
    using SQL pattern matches to count the number of rows containing each word (see
    [Recipe 10.1](ch10.xhtml#nch-sum-sum-basic-count) regarding the use of `COUNT()`
    to produce multiple counts from the same set of values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'InnoDB full-text indexing engine doesn’t include words less than three characters
    long. The minimum word length is a configurable parameter; to change it, set the
    `ft_min_word_len` for MyISAM `innodb_ft_min_token_size` for InnoDB storage engine
    system variable. For example, to tell the indexing engine to include words as
    short as three characters, add a line to the `[mysqld]` group of the */etc/my.cnf*
    file (or whatever option file you use for server settings):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: After making this change, restart the server. Next, rebuild the `FULLTEXT` index
    to take advantage of show the new setting first set the `innodb_optimize_fulltext_only`
    parameter and run `OPTIMIZE` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'For MyISAM, additionally run *REPAIR TABLE* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: You should also use `REPAIR` `TABLE` to rebuild the indexes for all other MyISAM
    tables that have `FULLTEXT` indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, try the new index to verify that it includes shorter words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 7.17 Requiring or Prohibiting Full-Text Search Words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to require or prohibit specific words in a full-text search.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a Boolean mode search.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, full-text searches return rows that contain any of the words in the
    search string, even if some of them are missing. For example, the following statement
    finds rows that contain either of the words <q>good</q> or <q>great</q>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior is undesirable if you want only rows that contain both words.
    One way to do this is to rewrite the statement to look for each word separately
    and join the conditions with `AND`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'An easier way to require multiple words is with a Boolean mode search. To do
    this, precede each word in the search string with a `+` character and add `IN`
    `BOOLEAN` `MODE` after the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean mode searches also permit you to exclude words by preceding each one
    with a `-` character. The following queries select `reviews` rows containing the
    name <q>good</q> but not <q>great</q>, and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful special character in Boolean searches is `*`; when appended
    to a search word, it acts as a wildcard operator. The following statement finds
    rows containing not only `use`, but also words such as `user`, `useful`, and `useless`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: For the complete list of Boolean full-text operators, see the [MySQL Reference
    Manual](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html).
  prefs: []
  type: TYPE_NORMAL
- en: 7.18 Performing Full-Text Phrase Searches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to perform a full-text search for a phrase; that is, for words that
    occur adjacent to each other and in a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the full-text phrase-search capability.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find rows that contain a particular phrase, a simple full-text search doesn’t
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The query returns a result, but not the one you’re looking for. A full-text
    search computes a relevance ranking based on the presence of each word individually,
    no matter where it occurs within the `reviews_virtual` column, and the ranking
    is nonzero as long as any of the words are present. Consequently, that kind of
    statement tends to find too many rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, use full-text Boolean mode, which supports phrase searching. Enclose
    the phrase in double quotes within the search string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: A phrase match succeeds if a column contains the same words as in the phrase,
    in the order specified.
  prefs: []
  type: TYPE_NORMAL
