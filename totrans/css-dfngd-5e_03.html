<html><head></head><body><section data-pdf-bookmark="Chapter 3. Pseudo-Class and -Element Selectors" data-type="chapter" epub:type="chapter"><div class="chapter" id="pseudo_classes_and_elements">&#13;
<h1><span class="label">Chapter 3. </span>Pseudo-Class and -Element Selectors</h1>&#13;
&#13;
&#13;
<p>In the previous chapter, you saw how selectors can match a single element or a collection of elements, using fairly simple expressions that match HTML attributes in the document. Those are great if your need is just to style based on attributes, but what if you need to style part of a document based on its current state or structure? Or if you want to select all the form elements that are disabled, or those that are required for form submission to be allowed?  For those things, and a great deal more, CSS has the pseudo-class and pseudo-element selectors.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pseudo-Class Selectors" data-type="sect1"><div class="sect1" id="pseudo-class_selectors">&#13;
<h1>Pseudo-Class Selectors</h1>&#13;
&#13;
<p><em>Pseudo-class selectors</em> let you <a data-primary="pseudo-class selectors" data-type="indexterm" id="ix_pseudo_class_ch3"/>assign styles to what are, in effect, phantom classes inferred by the state of certain elements, or markup patterns within the document, or even by the state of the document itself.</p>&#13;
&#13;
<p>The term <em>phantom classes</em> might seem a little odd, but it really is the best way to think of how pseudo-classes work. For example, suppose you want to highlight every other row of a data table. You could do that by marking up every other row with something like <code>class="even"</code> and then writing CSS to highlight rows with that class—or (as you’ll soon see) you could use a pseudo-class selector to achieve the same effect, one that will act as if you’ve added all those classes to the markup even though you haven’t.</p>&#13;
&#13;
<p>One aspect of pseudo-classes needs to be made explicit here: pseudo-classes always refer to the element to which they’re attached, and to no other. Seems like a weirdly obvious thing to say, right? The reason we make it explicit is that for some pseudo-classes, it’s a common error to think they are descriptors that refer to descendant elements.</p>&#13;
&#13;
<p>To illustrate this, Eric would like to share a personal anecdote:</p>&#13;
<blockquote>&#13;
<p>When my first child was born in 2003, I announced it online, as one does. A number of people responded with congratulations and CSS jokes, chief among them the selector <code>#ericmeyer:first-child</code> (we’ll get to <code>:first-child</code> in just a bit). But that selector would select me, not my daughter, and only if I were the first child of my own parents (which, as it happens, I am). To properly select <em>my</em> first child, that selector would need to be <code>#ericmeyer &gt; :first-child</code>.</p></blockquote>&#13;
&#13;
<p>The confusion is understandable, which is why we’re addressing it here. Reminders are found throughout the following sections. Just always keep in mind that the effect of pseudo-classes is to apply a sort of phantom class to the element to which they’re attached, and you should be OK.</p>&#13;
&#13;
<p>All <a data-primary="colon (:), in pseudo-class selectors" data-type="indexterm" id="idm45176124829616"/><a data-primary=": (colon), in pseudo-class selectors" data-type="indexterm" id="idm45176124828912"/>pseudo-classes, without exception, are a word or hyphenated term preceded by a single colon (<code>:</code>), and they can appear anywhere in a selector.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Combining Pseudo-Classes" data-type="sect2"><div class="sect2" id="combining_pseudo-classes">&#13;
<h2>Combining Pseudo-Classes</h2>&#13;
&#13;
<p>Before we really get started, a word about <a data-primary="pseudo-class selectors" data-secondary="chaining pseudo-classes" data-type="indexterm" id="idm45176124825648"/><a data-primary="chaining" data-type="indexterm" id="idm45176124824672"/>chaining. CSS makes it possible to combine (<em>chain</em>) pseudo-classes together. For example, you can make unvisited links red when they’re hovered and visited links maroon when they are hovered:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The order you specify doesn’t matter; you could also write <code>a:hover:link</code> to the same effect as <code>a:link:hover</code>. It’s also possible to assign separate hover styles to unvisited and visited links that are in another language—for example, German:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link:hover:lang</code><code class="o">(</code><code class="nt">de</code><code class="o">)</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited:hover:lang</code><code class="o">(</code><code class="nt">de</code><code class="o">)</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Be careful not to combine mutually exclusive pseudo-classes. For example, a link cannot be both visited and unvisited, so <code>a:link:visited</code> doesn’t make any sense and will never match anything.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Structural Pseudo-Classes" data-type="sect2"><div class="sect2" id="structural_pseudo-classes">&#13;
<h2>Structural Pseudo-Classes</h2>&#13;
&#13;
<p>The <a data-primary="pseudo-class selectors" data-secondary="structural pseudo-classes" data-type="indexterm" id="ix_peudoclass_struct"/><a data-primary="structural pseudo-classes" data-type="indexterm" id="ix_struct_pseudoclass"/><a data-primary="document structure" data-secondary="selectors based on" data-type="indexterm" id="ix_doc_struct_ch3"/>first set of pseudo-classes we’ll explore are structural in nature; that is, they refer to the markup structure of the document. Most of them depend on patterns within the markup, such as choosing every third paragraph, but others allow you to address specific types of elements.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting the root element" data-type="sect3"><div class="sect3" id="selecting_the_root_element">&#13;
<h3>Selecting the root element</h3>&#13;
&#13;
<p>This is the <a data-primary=":root pseudo-class" data-primary-sortas="root pseudo-class" data-type="indexterm" id="idm45176124755536"/>quintessence of structural simplicity: the pseudo-class <code>:root</code> selects the root element of the document. <a data-primary="HTML" data-secondary="root element in" data-type="indexterm" id="idm45176124754016"/>In HTML, this is <em>always</em> the <code>&lt;html&gt;</code> element. <a data-primary="XML" data-secondary="root element and" data-type="indexterm" id="idm45176124752048"/>The real benefit of this selector is found when writing stylesheets for XML languages, as the root element may be different in every language—for example, in SVG it’s the <code>&lt;svg&gt;</code> element, and in our earlier PlanetML examples it was the <code>&lt;pml&gt;</code> element—or even when you have more than one possible root element within a single language (though not a single document!).</p>&#13;
&#13;
<p class="pagebreak-before">Here’s an example of styling the root element in HTML, as illustrated in <a data-type="xref" href="#styling_the_root_element">Figure 3-1</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:root</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">10px</code> <code class="nb">dotted</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">body</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">10px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="styling_the_root_element">&#13;
<img alt="css5 0301" src="assets/css5_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>Styling the root element</h6>&#13;
</div></figure>&#13;
&#13;
<p>In HTML documents, you can always select the <code>&lt;html&gt;</code> element directly, without having to use the <code>:root</code> pseudo-class. The two selectors differ in terms of specificity, which we’ll cover in <a data-type="xref" href="ch04.html#specificity_comma_inheritance">Chapter 4</a>, but otherwise they’ll have the same effect.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting empty elements" data-type="sect3"><div class="sect3" id="selecting_empty_elements">&#13;
<h3>Selecting empty elements</h3>&#13;
&#13;
<p>With the <a data-primary=":empty pseudo-class" data-primary-sortas="empty pseudo-class" data-type="indexterm" id="idm45176124699168"/><a data-primary="text nodes" data-secondary=":empty pseudo-class using" data-secondary-sortas="empty pseudo-class using" data-type="indexterm" id="idm45176124698160"/>pseudo-class <code>:empty</code>, you can select any element that has no children of any kind, <em>including</em> text nodes, which covers both text and whitespace. This can be useful in suppressing elements that a content management system (CMS) has generated without filling in any actual content. Thus, <code>p:empty {display: none;}</code> would prevent the display of any empty paragraphs.</p>&#13;
&#13;
<p>Note that in order to be matched, an element must be, from a parsing perspective, truly empty—no whitespace, visible content, or descendant elements. Of the following elements, only the first and last would be matched by <code>p:empty</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"> </code><code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="cp">&lt;!—-a comment--&gt;</code><code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The second and third paragraphs are not matched by <code>:empty</code> because they are not empty: they contain, respectively, a single space and a single newline character. Both are considered text nodes and thus prevent a state of emptiness. The last paragraph matches because comments are not considered content, not even whitespace. But put even one space or newline to either side of that comment, and <code>p:empty</code> would fail to match.</p>&#13;
&#13;
<p>You might be tempted to just style all empty elements with something like <code>*:empty {display: none;}</code>, but there’s a hidden catch: <code>:empty</code> matches HTML’s empty elements, like <code>&lt;img&gt;</code>, <code>&lt;hr&gt;</code>, <code>&lt;br&gt;</code>, and <code>&lt;input&gt;</code>. It could even match <code>&lt;textarea&gt;</code>, unless you insert some default text into the <code>&lt;textarea&gt;</code> element.</p>&#13;
&#13;
<p>Thus, in terms of matching elements, <code>img</code> and <code>img:empty</code> are effectively the same. (They are different in terms of specificity, which we’ll cover in the next chapter.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting only children" data-type="sect3"><div class="sect3" id="selecting_only_children">&#13;
<h3>Selecting only children</h3>&#13;
&#13;
<p>If you’ve ever <a data-primary=":only-child pseudo-class" data-primary-sortas="only-child pseudo-class" data-type="indexterm" id="ix_only_child_pseudo"/>wanted to select all the images that are wrapped by a hyperlink element, the <code>:only-child</code> pseudo-class is for you. It selects elements when they are the only child element of another element. So let’s say you want to add a border to any image that’s the only child of another element. You’d write the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nd">:only-child</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This would match any image that meets those criteria. Therefore, if you had a paragraph that contained an image and no other child elements, the image would be selected regardless of all the text surrounding it. If what you’re really after is images that are sole children and found inside hyperlinks, you just modify the selector like so (which is illustrated in <a data-type="xref" href="#selecting_images_that_are_only_children">Figure 3-2</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">]</code> <code class="nt">img</code><code class="nd">:only-child</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"W3C"</code><code class="nt">&gt;&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="nt">&gt;</code><code class="w"> </code>The<code class="w"> </code>W3C<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="nt">&gt;</code><code class="w"> </code><code class="nt">&lt;em&gt;</code>The<code class="w"> </code>W3C<code class="nt">&lt;/em&gt;&lt;/a&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_images_that_are_only_children">&#13;
<img alt="css5 0302" src="assets/css5_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Selecting images that are only children inside links</h6>&#13;
</div></figure>&#13;
&#13;
<p>You should remember two things about <code>:only-child</code>. The first is that you <em>always</em> apply it to the element you want to be an only child, not to the parent element, as explained earlier. That brings up the second thing to remember, which is that when you use <code>:only-child</code> in a descendant selector, you aren’t restricting the elements listed to a parent-child relationship.</p>&#13;
&#13;
<p>To go back to the hyperlinked-image example, <code>a[href] img:only-child</code> matches any image that is an only child and is descended from an <code>a</code> element, whether or not it’s a <em>child</em> of an <code>a</code> element. To match, the element image must be the only child of its direct parent and also a descendant of an <code>a</code> element with an <code>href</code> attribute, but that parent can itself be a descendant of the same <code>&lt;a&gt;</code> element. Therefore, all three of the images in the following would be matched, as shown in <a data-type="xref" href="#selecting_images_that_are_only_child">Figure 3-3</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">]</code> <code class="nt">img</code><code class="nd">:only-child</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"W3C"</code><code class="nt">&gt;&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;span&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"W3C"</code><code class="nt">&gt;&lt;/span&gt;&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;</code>A<code class="w"> </code>link<code class="w"> </code>to<code class="w"> </code><code class="nt">&lt;span&gt;</code>the<code class="w"> </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"W3C"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">   </code>web<code class="nt">&lt;/span&gt;</code><code class="w"> </code>site<code class="nt">&lt;/a&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_images_that_are_only_child">&#13;
<img alt="css5 0303" src="assets/css5_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>Selecting images that are only children inside links, redux</h6>&#13;
</div></figure>&#13;
&#13;
<p>In each case, the image is the only child element of its parent, and it is also descended from an <code>&lt;a&gt;</code> element. Thus, all three images are matched by the rule shown. If you want to restrict the rule so that it matches images that are the only children of <code>&lt;a&gt;</code> elements, you add the child combinator to yield <code>a[href] &gt; img:only-child</code>. With that change, only the first of the three images shown in <a data-type="xref" href="#selecting_images_that_are_only_child">Figure 3-3</a> would be matched.<a data-primary="" data-startref="ix_only_child_pseudo" data-type="indexterm" id="idm45176119283120"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using only-of-type selection" data-type="sect3"><div class="sect3" id="only_of_type_selection">&#13;
<h3>Using only-of-type selection</h3>&#13;
&#13;
<p>That’s all <a data-primary=":only-of-type pseudo-class" data-primary-sortas="only-of-type pseudo-class" data-type="indexterm" id="ix_only_type_pseudo"/>great, but what if you want to match images that are the only images inside hyperlinks, but other elements may be in there with them? Consider the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;b&gt;</code>•<code class="nt">&lt;/b&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"W3C"</code><code class="nt">&gt;&lt;/a&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this case, we have an <code>a</code> element that has two children: <code>&lt;b&gt;</code> and <code>&lt;img&gt;</code>. That image, no longer the only child of its parent (the hyperlink), can never be matched using <code>:only-child</code>. However, it <em>can</em> be matched using <code>:only-of-type</code>. This is illustrated in <a data-type="xref" href="#selecting_images_that_are_the_only_sibli">Figure 3-4</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">]</code> <code class="nt">img</code><code class="nd">:only-of-type</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;b&gt;</code>•<code class="nt">&lt;/b&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"W3C"</code><code class="nt">&gt;&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://w3.org/"</code><code class="nt">&gt;&lt;span&gt;&lt;b&gt;</code>•<code class="nt">&lt;/b&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"w3.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"W3C"</code><code class="nt">&gt;&lt;/span&gt;&lt;/a&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_images_that_are_the_only_sibli">&#13;
<img alt="css5 0304" src="assets/css5_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>Selecting images that are the only sibling of their type</h6>&#13;
</div></figure>&#13;
&#13;
<p>The difference is that <code>:only-of-type</code> will match any element that is the only one of its type among all its siblings, whereas <code>:only-child</code> will match only if an element has no &#13;
<span class="keep-together">siblings</span> at all.</p>&#13;
&#13;
<p>This can be very useful in cases such as selecting images within paragraphs without having to worry about the presence of hyperlinks or other inline elements:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="o">&gt;</code> <code class="nt">img</code><code class="nd">:only-of-type</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">right</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As long as there aren’t multiple images that are children of the same paragraph, the image will be floated to the right.</p>&#13;
&#13;
<p>You can also use this pseudo-class to apply extra styles to an <code>&lt;h2&gt;</code> when it’s the only one in a given section of a document, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">section</code> <code class="o">&gt;</code> <code class="nt">h2</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">1em</code> <code class="m">0</code> <code class="m">0.33em</code><code class="p">;</code> <code class="k">font-size</code><code class="o">:</code> <code class="m">1.8rem</code><code class="p">;</code> <code class="k">border-bottom</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code>&#13;
   <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">section</code> <code class="o">&gt;</code> <code class="nt">h2</code><code class="nd">:only-of-type</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">2.4rem</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Given those rules, any <code>&lt;section&gt;</code> that has only one child <code>&lt;h2&gt;</code> will have that <code>&lt;h2&gt;</code> appear larger than usual. If a <code>section</code> has two or more <code>&lt;h2&gt;</code> children, neither will be larger than the other. The presence of other children—whether they are other heading levels, tables, paragraphs, lists, and so on—will not interfere with matching.</p>&#13;
&#13;
<p>One more point to make clear is that <code>:only-of-type</code> refers to elements and nothing else.  Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.unique</code><code class="nd">:only-of-type</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"unique"</code><code class="nt">&gt;</code>This<code class="w"> </code>paragraph<code class="w"> </code>has<code class="w"> </code>a<code class="w"> </code>'unique'<code class="w"> </code>class.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code>This<code class="w"> </code>paragraph<code class="w"> </code>doesn't<code class="w"> </code>have<code class="w"> </code>a<code class="w"> </code>class<code class="w"> </code>at<code class="w"> </code>all.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this case, neither of the paragraphs will be selected.  Why not?  Because two paragraphs are descendants of the <code>&lt;div&gt;</code>, neither can be the only one of their type.</p>&#13;
&#13;
<p>The class name is irrelevant here.  We can be fooled into thinking that <em>type</em> is a generic description, because of the way we parse language.  <em>Type</em>, in the way <code>:only-of-type</code> means it, refers only to the element type, as with type selectors.  Thus, <code>p.unique:only-of-type</code> means, “Select any <code>&lt;p&gt;</code> element that is the only <code>&lt;p&gt;</code> element among its siblings if it also has a <code>class</code> of  <code>unique</code>.”  It does <em>not</em> mean, “Select any <code>&lt;p&gt;</code> element whose <code>class</code> attribute contains the word <code>unique</code> when it’s the only sibling paragraph to meet that criterion.”<a data-primary="" data-startref="ix_only_type_pseudo" data-type="indexterm" id="idm45176118949936"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting first children" data-type="sect3"><div class="sect3" id="selecting_first_children">&#13;
<h3>Selecting first children</h3>&#13;
&#13;
<p>It’s pretty <a data-primary=":first-child pseudo-class" data-primary-sortas="first-child pseudo-class" data-type="indexterm" id="ix_first_child_pseudo"/>common to want to apply special styling to the first or last child of an element. A typical example is styling a bunch of navigation links in a tab bar and wanting to put special visual touches on the first or last tab (or both). If we didn’t have structural selectors, this could be done by applying special classes to those elements. We have pseudo-classes to carry the load for us, removing the need to manually figure out which elements are the first and last.</p>&#13;
&#13;
<p>The pseudo-class <code>:first-child</code> is used to select elements that are the first children of other elements. Consider the following markup:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code>These<code class="w"> </code>are<code class="w"> </code>the<code class="w"> </code>necessary<code class="w"> </code>steps:<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Insert<code class="w"> </code>key<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Turn<code class="w"> </code>key<code class="w"> </code><code class="nt">&lt;strong&gt;</code>clockwise<code class="nt">&lt;/strong&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Push<code class="w"> </code>accelerator<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>Do<code class="w"> </code><code class="nt">&lt;em&gt;</code>not<code class="nt">&lt;/em&gt;</code><code class="w"> </code>push<code class="w"> </code>the<code class="w"> </code>brake<code class="w"> </code>at<code class="w"> </code>the<code class="w"> </code>same<code class="w"> </code>time<code class="w"> </code>as<code class="w"> </code>the<code class="w"> </code>accelerator.<code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the elements that are first children are the first <code>&lt;p&gt;</code>, the first <code>&lt;li&gt;</code>, and the <code>&lt;strong&gt;</code> and <code>&lt;em&gt;</code> elements, which are all the first children of their respective parents. Given the following two rules,</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">:first-child</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:first-child</code> <code class="p">{</code><code class="k">text-transform</code><code class="o">:</code> <code class="nb">uppercase</code><code class="p">;}</code></pre>&#13;
&#13;
<p>we get the result shown in <a data-type="xref" href="#styling_first_children">Figure 3-5</a>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_first_children">&#13;
<img alt="css5 0305" src="assets/css5_0305.png"/>&#13;
<h6><span class="label">Figure 3-5. </span>Styling first children</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first rule boldfaces any <code>&lt;p&gt;</code> element that is the first child of another element. The second rule uppercases any <code>&lt;li&gt;</code> element that is the first child of another element (which, in HTML, must be either an <code>&lt;ol&gt;</code> or <code>&lt;ul&gt;</code> element).</p>&#13;
&#13;
<p>As has been mentioned, the most common error is assuming that a selector like <code>p:first-child</code> will select the first child of a <code>&lt;p&gt;</code> element. Remember the nature of pseudo-classes, which is to attach a sort of phantom class to the anchor element, the element associated with the pseudo-class. If you were to add actual classes to the markup, it would look like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">&lt;</code><code class="n">div</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="n">p</code> <code class="n">class</code><code class="o">=</code><code class="s2">"first-child"</code><code class="o">&gt;</code><code class="n">These</code> <code class="n">are</code> <code class="n">the</code> <code class="n">necessary</code> <code class="n">steps</code><code class="o">:&lt;/</code><code class="n">p</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="n">ul</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="n">li</code> <code class="n">class</code><code class="o">=</code><code class="s2">"first-child"</code><code class="o">&gt;</code><code class="n">Insert</code> <code class="n">key</code><code class="o">&lt;/</code><code class="n">li</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="n">li</code><code class="o">&gt;</code><code class="n">Turn</code> <code class="n">key</code> <code class="o">&lt;</code><code class="n">strong</code> <code class="n">class</code><code class="o">=</code><code class="s2">"first-child"</code><code class="o">&gt;</code><code class="n">clockwise</code><code class="o">&lt;/</code><code class="n">strong</code><code class="o">&gt;&lt;/</code><code class="n">li</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="n">li</code><code class="o">&gt;</code><code class="n">Push</code> <code class="n">accelerator</code><code class="o">&lt;/</code><code class="n">li</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;/</code><code class="n">ul</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="n">p</code><code class="o">&gt;</code>&#13;
    <code class="n">Do</code> <code class="o">&lt;</code><code class="n">em</code> <code class="n">class</code><code class="o">=</code><code class="s2">"first-child"</code><code class="o">&gt;</code><code class="n">not</code><code class="o">&lt;/</code><code class="n">em</code><code class="o">&gt;</code> <code class="n">push</code> <code class="n">the</code> <code class="n">brake</code> <code class="n">at</code> <code class="n">the</code> <code class="n">same</code> <code class="n">time</code> <code class="n">as</code> <code class="n">the</code>&#13;
  <code class="n">accelerator</code><code class="o">.</code>&#13;
  <code class="o">&lt;/</code><code class="n">p</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;/</code><code class="n">div</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>Therefore, if you want to select those <code>&lt;em&gt;</code> elements that are the first child of another element, you write <code>em:first-child</code>.<a data-primary="" data-startref="ix_first_child_pseudo" data-type="indexterm" id="idm45176118774576"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting last children" data-type="sect3"><div class="sect3" id="selecting_last_children">&#13;
<h3>Selecting last children</h3>&#13;
&#13;
<p>The mirror <a data-primary=":last-child pseudo-class" data-primary-sortas="last-child pseudo-class" data-type="indexterm" id="idm45176118664096"/>image of <code>:first-child</code> is <code>:last-child</code>. If we take the previous example and just change the pseudo-classes, we get the result shown in <a data-type="xref" href="#styling_first_children-id1">Figure 3-6</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">:last-child</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:last-child</code> <code class="p">{</code><code class="k">text-transform</code><code class="o">:</code> <code class="nb">uppercase</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code>These<code class="w"> </code>are<code class="w"> </code>the<code class="w"> </code>necessary<code class="w"> </code>steps:<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Insert<code class="w"> </code>key<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Turn<code class="w"> </code>key<code class="w"> </code><code class="nt">&lt;strong&gt;</code>clockwise<code class="nt">&lt;/strong&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Push<code class="w"> </code>accelerator<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>Do<code class="w"> </code><code class="nt">&lt;em&gt;</code>not<code class="nt">&lt;/em&gt;</code><code class="w"> </code>push<code class="w"> </code>the<code class="w"> </code>brake<code class="w"> </code>at<code class="w"> </code>the<code class="w"> </code>same<code class="w"> </code>time<code class="w"> </code>as<code class="w"> </code>the<code class="w"> </code>accelerator.<code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_first_children-id1">&#13;
<img alt="css5 0306" src="assets/css5_0306.png"/>&#13;
<h6><span class="label">Figure 3-6. </span>Styling last children</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first rule boldfaces any <code>&lt;p&gt;</code> element that is the last child of another element. The second rule uppercases any <code>&lt;li&gt;</code> element that is the last child of another element. If you wanted to select the <code>&lt;em&gt;</code> element inside that last paragraph, you could use the selector <code>p:last-child em</code>, which selects any <code>&lt;em&gt;</code> element that descends from a <code>&lt;p&gt;</code> element that is itself the last child of another element.</p>&#13;
&#13;
<p>Interestingly, you can <a data-primary="pseudo-class selectors" data-secondary="chaining pseudo-classes" data-type="indexterm" id="idm45176118550176"/>combine these two pseudo-classes to create a version of <code>:only-child</code>. The following two rules will select the same elements:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">:only-child</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:first-child:last-child</code> <code class="p">{</code><code class="k">background-color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Either way, we get paragraphs with red foreground and background colors (not a good idea, to be clear).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Selecting the first and last of a type" data-type="sect3"><div class="sect3" id="selecting_first_a_type">&#13;
<h3>Selecting the first and last of a type</h3>&#13;
&#13;
<p>In a <a data-primary=":first-of-type pseudo-class" data-primary-sortas="first-of-type pseudo-class" data-type="indexterm" id="ix_first_type_pseudo"/>manner similar to selecting the first and last children of an element, you can select the first or last of a type of element within another element. This permits actions like selecting the first <code>&lt;table&gt;</code> inside a given element, regardless of whatever elements come before it:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">table</code><code class="nd">:first-of-type</code> <code class="p">{</code><code class="k">border-top</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Note that this does <em>not</em> apply to the entire document; the rule shown will not select the first table in the document and skip all the others. It will instead select the first <code>&lt;table&gt;</code> element within each element that contains one, and skip any sibling <code>&lt;table&gt;</code> elements that come after the first. Thus, given the document structure shown in <a data-type="xref" href="#selecting_first-of-type_tables">Figure 3-7</a>, the circled nodes are the ones that are selected.</p>&#13;
&#13;
<figure><div class="figure" id="selecting_first-of-type_tables">&#13;
<img alt="css5 0307" src="assets/css5_0307.png"/>&#13;
<h6><span class="label">Figure 3-7. </span>Selecting first-of-type tables</h6>&#13;
</div></figure>&#13;
&#13;
<p>Within the context of tables, a useful way to select the first data cell within a row regardless of whether a header cell comes before it in the row is as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">td</code><code class="nd">:first-of-type</code> <code class="p">{</code><code class="k">border-left</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That would select the first data cell in each of the following table rows (that is, the cells containing <code>7</code> and <code>R</code>):</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;tr&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;th</code><code class="w"> </code><code class="na">scope=</code><code class="s">"row"</code><code class="nt">&gt;</code>Count<code class="nt">&lt;/th&gt;&lt;td&gt;</code>7<code class="nt">&lt;/td&gt;&lt;td&gt;</code>6<code class="nt">&lt;/td&gt;&lt;td&gt;</code>11<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/tr&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;tr&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;td&gt;</code>R<code class="nt">&lt;/td&gt;&lt;td&gt;</code>X<code class="nt">&lt;/td&gt;&lt;td&gt;</code>-<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/tr&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Compare that to the <a data-primary=":first-child pseudo-class" data-primary-sortas="first-child pseudo-class" data-type="indexterm" id="idm45176118370240"/>effects of <code>td:first-child</code>, which would select the first <code>&lt;td&gt;</code> element in the second row, but not in the first row.</p>&#13;
&#13;
<p>The <a data-primary=":last-of-type pseudo-class" data-primary-sortas="last-of-type pseudo-class" data-type="indexterm" id="ix_last_type_pseudo"/>flip side is <code>:last-of-type</code>, which selects the last instance of a given type from among its sibling elements. In a way, it’s just like <code>:first-of-type</code>, except you start with the last element in a group of siblings and walk backward toward the first element until you reach an instance of the type. Given the document structure shown in <a data-type="xref" href="#selecting_last-of-type_tables">Figure 3-8</a>, the circled nodes are the ones selected by <code>table:last-of-type</code>.</p>&#13;
&#13;
<figure><div class="figure" id="selecting_last-of-type_tables">&#13;
<img alt="css5 0308" src="assets/css5_0308.png"/>&#13;
<h6><span class="label">Figure 3-8. </span>Selecting last-of-type tables</h6>&#13;
</div></figure>&#13;
&#13;
<p>As was <a data-primary=":only-of-type pseudo-class" data-primary-sortas="only-of-type pseudo-class" data-type="indexterm" id="idm45176118362112"/>noted with <code>:only-of-type</code>, remember that you are selecting elements of a type from among their sibling elements; thus, every set of siblings is considered separately. In other words, you are <em>not</em> selecting the first (or last) of all the elements of a type within the entire document as a single group. Each set of elements that shares a parent is its own group, and you can select the first (or last) of a type within each group.</p>&#13;
&#13;
<p>Similar to what was noted in the previous section, you can combine these two pseudo-classes to create a version of <code>:only-of-type</code>. The following two rules will select the same elements:<a data-primary="" data-startref="ix_last_type_pseudo" data-type="indexterm" id="idm45176118359152"/><a data-primary="" data-startref="ix_first_type_pseudo" data-type="indexterm" id="idm45176118333856"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">table</code><code class="nd">:only-of-type</code><code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">table</code><code class="nd">:first-of-type:last-of-type</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting every nth child" data-type="sect3"><div class="sect3" id="selecting_every_nth_child">&#13;
<h3>Selecting every nth child</h3>&#13;
&#13;
<p>If you can <a data-primary=":nth-child() pseudo-class" data-primary-sortas="nth-child() pseudo-class" data-type="indexterm" id="ix_nth_child_pseudo"/>select elements that are the first, last, or only children of other elements, how about every third child? All even children? Only the ninth child? Rather than try to define a literally infinite number of named pseudo-classes, CSS has the <code>:nth-child()</code> pseudo-class. By filling integers or even basic algebraic expressions into the parentheses, you can select any arbitrarily numbered child element you like.</p>&#13;
&#13;
<p>Let’s start with the <code>:nth-child()</code> equivalent of <code>:first-child</code>, which is <code>:nth-child(1)</code>. In the following example, the selected elements will be the first paragraph and the first list item:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">text-transform</code><code class="o">:</code> <code class="nb">uppercase</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code>These<code class="w"> </code>are<code class="w"> </code>the<code class="w"> </code>necessary<code class="w"> </code>steps:<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Insert<code class="w"> </code>key<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Turn<code class="w"> </code>key<code class="w"> </code><code class="nt">&lt;strong&gt;</code>clockwise<code class="nt">&lt;/strong&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Push<code class="w"> </code>accelerator<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>Do<code class="w"> </code><code class="nt">&lt;em&gt;</code>not<code class="nt">&lt;/em&gt;</code><code class="w"> </code>push<code class="w"> </code>the<code class="w"> </code>brake<code class="w"> </code>at<code class="w"> </code>the<code class="w"> </code>same<code class="w"> </code>time<code class="w"> </code>as<code class="w"> </code>the<code class="w"> </code>accelerator.<code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If we change the numbers from <code>1</code> to <code>2</code>, however, then no paragraphs will be selected, and the middle (or second) list item will be selected, as illustrated in <a data-type="xref" href="#styling_second_children">Figure 3-9</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">text-transform</code><code class="o">:</code> <code class="nb">uppercase</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_second_children">&#13;
<img alt="css5 0309" src="assets/css5_0309.png"/>&#13;
<h6><span class="label">Figure 3-9. </span>Styling second children</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can insert any integer you choose. If you have a use case for selecting any ordered list that is the 93rd child element of its parent, <code>ol:nth-child(93)</code> is ready to serve. This will match the 93rd child of any parent as long as that child is an ordered list. (This does not mean the 93rd ordered list among its siblings; see <a data-type="xref" href="#selecting_every_nth_of_a_type">“Selecting every nth of a type”</a> for that.)</p>&#13;
&#13;
<p>Is there a reason to use <code>:nth-child(1)</code> rather than <code>:first-child</code>?  No.  In this case, use whichever you prefer.  There is literally no difference between them.</p>&#13;
&#13;
<p>More powerfully, you can use simple algebraic expressions in the form <em><code>a</code></em><code>n</code> + <em><code>b</code></em> or <em><code>a</code></em><code>n</code> <code>-</code> <em><code>b</code></em> to define recurring instances, where <em><code>a</code></em> and <em><code>b</code></em> are integers and <code>n</code> is present as itself. Furthermore, the <code>+</code> <em><code>b</code></em> or <code>−</code> <em><code>b</code></em> part is optional and thus can be dropped if it isn’t needed.</p>&#13;
&#13;
<p>Let’s suppose we want to select every third list item in an unordered list, starting with the first. The following makes that possible, selecting the first and fourth items, as shown in <a data-type="xref" href="#styling_every_third_list_item">Figure 3-10</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="o">&gt;</code> <code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">3n</code> <code class="o">+</code> <code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">text-transform</code><code class="o">:</code> <code class="nb">uppercase</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_every_third_list_item">&#13;
<img alt="css5 0310" src="assets/css5_0310.png"/>&#13;
<h6><span class="label">Figure 3-10. </span>Styling every third list item</h6>&#13;
</div></figure>&#13;
&#13;
<p>The way this works is that <code>n</code> represents the series 0, 1, 2, 3, 4, and on into infinity. The browser then solves for <code>3n + 1</code>, yielding 1, 4, 7, 10, 13, and so on. Were we to drop the <code>+ 1</code>, thus leaving us with simply <code>3n</code>, the results would be 0, 3, 6, 9, 12, and so on. Since there is no zeroth list item—all element counting starts with 1, to the likely chagrin of array-slingers everywhere—the first list item selected by this expression would be the third list item in the list.</p>&#13;
&#13;
<p>Given that element counting starts with 1, it is a minor trick to deduce that <code>:nth-child(2n)</code> will select even-numbered children, and either <code>:nth-child(2n+1)</code> or <code>:nth-child(2n-1)</code> will select odd-numbered children. You can commit that to memory, or you can use the two special keywords that <code>:nth-child()</code> accepts: <code>even</code> and <code>odd</code>. Want to highlight every other row of a table, starting with the first? Here’s how you do it, with the results shown in <a data-type="xref" href="#styling_every_other_table_row">Figure 3-11</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">tr</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">odd</code><code class="o">)</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="styling_every_other_table_row">&#13;
<img alt="css5 0311" src="assets/css5_0311.png"/>&#13;
<h6><span class="label">Figure 3-11. </span>Styling every other table row</h6>&#13;
</div></figure>&#13;
&#13;
<p>Anything more complex than every-other-element requires an <em><code>a</code></em><code>n</code> <code>+</code> <em><code>b</code></em> expression.</p>&#13;
&#13;
<p>Note that when you want to use a negative number for <em><code>b</code></em>, you have to remove the <code>+</code> sign, or else the selector will fail entirely. Of the following two rules, only the first will do anything. The second will be dropped by the parser and the entire declaration block will &#13;
<span class="keep-together">be ignored:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">tr</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">4n</code> <code class="nt">-</code> <code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">tr</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">3n</code> <code class="o">+</code> <code class="err">−</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>  <code class="c">/* INVALID */</code></pre>&#13;
&#13;
<p>You can also use a negative value for <em><code>a</code></em> in the expression, which will effectively count backward from the term you use in <em><code>b</code></em>.  Selecting the first five list items in a list can be done like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">-n</code> <code class="o">+</code> <code class="nt">5</code><code class="o">)</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This works because negative <code>n</code> goes 0, –1, –2, –3, –4, and so on.  Add 5 to each of those, and you get 5, 4, 3, 2, 1, and so on.  Put in a negative number for a multiplier on <code>n</code>, and you can get every second, third, or whatever-number-you-want element, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">-2n</code> <code class="o">+</code> <code class="nt">10</code><code class="o">)</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That will select the 10th, 8th, 4th, and 2nd list items in a list.</p>&#13;
&#13;
<p>As you might expect, a <a data-primary=":nth-last-child() pseudo-class" data-primary-sortas="nth-last-child() pseudo-class" data-type="indexterm" id="ix_nth_lastchild_pseudo"/>corresponding pseudo-class is <code>:nth-last-child()</code>. This lets you do the same thing as <code>:nth-child()</code>, except with <code>:nth-last-child()</code> you start from the last element in a list of siblings and count backward toward the beginning. If you’re intent on highlighting every other table row <em>and</em> making sure the very last row is one of the rows in the highlighting pattern, either one of these will work for you:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">tr</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">odd</code><code class="o">)</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">tr</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">2n</code><code class="o">+</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code> <code class="c">/* equivalent */</code></pre>&#13;
&#13;
<p>If the <a data-primary="Document Object Model (DOM)" data-secondary="pseudo-class selectors and" data-type="indexterm" id="idm45176130875680"/>Document Object Model (DOM) is updated to add or remove table rows, there is no need to add or remove classes. By using structural selectors, these selectors will always match the odd rows of the updated DOM.</p>&#13;
&#13;
<p>Any element can be matched using both <code>:nth-child()</code> and <code>:nth-last-child()</code> if it fits the criteria. Consider these rules, the results of which are shown in <a data-type="xref" href="#combining_patterns_of_colon_nth-child_op">Figure 3-12</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">3n</code> <code class="o">+</code> <code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">border-left</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">4n</code> <code class="nt">-</code> <code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">border-right</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Again, using negative terms for <em><code>a</code></em> will essentially count backward, except since this pseudo-class is already counting from the end, a negative term counts forward.  That is to say, you can select the last five list items in a list like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">-n</code> <code class="o">+</code> <code class="nt">5</code><code class="o">)</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>An extension of <code>:nth-child()</code> and <code>:nth-last-child()</code> allows selecting from among elements matched by a simple or compound selector; for example, <code>:nth-child(2n + 1 of p.callout)</code>. As of early 2023, this is supported in Safari and Chrome beta releases. With it being included in Interop 2023, there are plans to have it fully supported in the near future.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="combining_patterns_of_colon_nth-child_op">&#13;
<img alt="css5 0312" src="assets/css5_0312.png"/>&#13;
<h6><span class="label">Figure 3-12. </span>Combining patterns of <code>:nth-child()</code> and <code>:nth-last-child()</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>You also can <a data-primary=":only-child pseudo-class" data-primary-sortas="only-child pseudo-class" data-type="indexterm" id="idm45176130799472"/>string these two pseudo-classes together as <code>:nth-child(1):nth-last-child(1)</code>, thus creating a more verbose restatement of <code>:only-child</code>. There’s no real reason to do so other than to create a selector with a higher specificity (discussed in <a data-type="xref" href="ch04.html#specificity_comma_inheritance">Chapter 4</a>), but the option is there.</p>&#13;
&#13;
<p>You can use CSS to determine the number of items in a list and style them accordingly:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code><code class="nd">:only-child</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">100%</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">2</code><code class="o">),</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">50%</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">3</code><code class="o">),</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="o">~</code> <code class="nt">li</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">33.33%</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">4</code><code class="o">),</code>&#13;
<code class="nt">li</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code><code class="nd">:nth-last-child</code><code class="o">(</code><code class="nt">4</code><code class="o">)</code> <code class="o">~</code> <code class="nt">li</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">25%</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In these examples, if a list item is the only list item, the width is 100%. If a list item is the first item as well as the second-from-the-last item, that means there are two items, and the width is 50%. If an item is the first item as well as the third-from-the-last item, we make it, and the two sibling list items following it, 33% wide. Similarly, if a list item is the first item as well as the fourth-from-the-last item, it means that there are exactly four items, so we make it, and its three siblings, 25% of the width.  (Note: this sort of thing is a lot easier with the <code>:has()</code> pseudo-class, covered in <a data-type="xref" href="#the_has_pseudo_class">“The :has() Pseudo-Class”</a>.)<a data-primary="" data-startref="ix_nth_child_pseudo" data-type="indexterm" id="idm45176130725520"/><a data-primary="" data-startref="ix_nth_lastchild_pseudo" data-type="indexterm" id="idm45176130724576"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting every nth of a type" data-type="sect3"><div class="sect3" id="selecting_every_nth_of_a_type">&#13;
<h3>Selecting every nth of a type</h3>&#13;
&#13;
<p>In what <a data-primary=":nth-of-type() pseudo-class" data-primary-sortas="nth-of-type() pseudo-class" data-type="indexterm" id="idm45176130722544"/><a data-primary=":nth-last-of-type() pseudo-class" data-primary-sortas="nth-last-of-type() pseudo-class" data-type="indexterm" id="idm45176130721600"/>may have become a familiar pattern, the <code>:nth-child()</code> and <code>:nth-last-child()</code> pseudo-classes have analogues in <code>:nth-of-type()</code> and <code>:nth-last-of-type()</code>. You can, for example, select every other hyperlink that’s a child of any given paragraph, starting with the second, using <code>p &gt; a:nth-of-type(even)</code>. This will ignore all other elements (<code>&lt;span&gt;</code>, <code>&lt;strong&gt;</code>, etc.) and consider only the links, as demonstrated in <a data-type="xref" href="#selecting_the_even-numbered_links">Figure 3-13</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="o">&gt;</code> <code class="nt">a</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">even</code><code class="o">)</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="selecting_the_even-numbered_links">&#13;
<img alt="css5 0313" src="assets/css5_0313.png"/>&#13;
<h6><span class="label">Figure 3-13. </span>Selecting the even-numbered links</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you want to work from the last hyperlink backward, then you’d use <code>p &gt; a:nth-last-of-type(even)</code>.</p>&#13;
&#13;
<p>As before, these pseudo-classes select elements of a type from among their sibling elements, <em>not</em> from among all the elements of a type within the entire document as a single group. Each element has its own list of siblings, and selections happen within each group.</p>&#13;
&#13;
<p>The difference between <code>:nth-of-type()</code> and <code>nth-child()</code> is that <code>:nth-of-type()</code> counts the instances of whatever you’re selecting, and does its counting within that collection of elements.  Take, for example, the following markup:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;tr&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;th</code><code class="w"> </code><code class="na">scope=</code><code class="s">"row"</code><code class="nt">&gt;</code>Count<code class="nt">&lt;/th&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>7<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>6<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>11<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>17<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>3<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>21<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/tr&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;tr&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>R<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>X<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>-<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>C<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>%<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>A<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;td&gt;</code>I<code class="nt">&lt;/td&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/tr&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If you wanted to select every table cell in a row when it’s in an even-numbered column, you would use <code>td:nth-child(even)</code>.  But if you want to select every even-numbered instance of a table cell, that would be <code>td:nth-of-type(even)</code>.  You can see the difference in <a data-type="xref" href="#nth-child_and_nth-of-type">Figure 3-14</a>, which shows the result of the following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">td</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">even</code><code class="o">)</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">td</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">even</code><code class="o">)</code> <code class="p">{</code><code class="k">text-decoration</code><code class="o">:</code> <code class="nb">underline</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="nth-child_and_nth-of-type">&#13;
<img alt="css5 0314" src="assets/css5_0314.png"/>&#13;
<h6><span class="label">Figure 3-14. </span>Selecting both <code>nth-child</code> and <code>nth-of-type</code> table cells</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first row, every other table data cell (<code>td</code>) is selected, starting with the first cell that comes after the table header cell (<code>th</code>).  In the second row, since all the cells are <code>td</code> cells, that means all the cells in that row are of the same type and thus the counting starts at the first cell.</p>&#13;
&#13;
<p>As you <a data-primary=":only-of-type pseudo-class" data-primary-sortas="only-of-type pseudo-class" data-type="indexterm" id="idm45176130476224"/>might expect, you can use <code>:nth-of-type(1):nth-last-of-type(1)</code> together to restate <code>:only-of-type</code>, only with higher specificity. (We <em>will</em> explain specificity in <a data-type="xref" href="ch04.html#specificity_comma_inheritance">Chapter 4</a>, we promise.)<a data-primary="" data-startref="ix_doc_struct_ch3" data-type="indexterm" id="idm45176130471072"/><a data-primary="" data-startref="ix_peudoclass_struct" data-type="indexterm" id="idm45176130470096"/><a data-primary="" data-startref="ix_struct_pseudoclass" data-type="indexterm" id="idm45176130469152"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Location Pseudo-Classes" data-type="sect2"><div class="sect2" id="location_pseudo-classes">&#13;
<h2>Location Pseudo-Classes</h2>&#13;
&#13;
<p>With <a data-primary="location pseudo-classes" data-type="indexterm" id="ix_loc_pseudo_class"/><a data-primary="pseudo-class selectors" data-secondary="location pseudo-classes" data-type="indexterm" id="ix_pseudo_class_loc"/>the <em>location pseudo-classes</em>, we cross into the territory of selectors that match pieces of a document based on something in addition to the structure of the document—something that cannot be precisely deduced simply by studying the document’s markup.</p>&#13;
&#13;
<p>This may sound like we’re applying styles at random, but not so. Instead, we’re applying styles based on somewhat ephemeral conditions that can’t be predicted in advance. Nevertheless, the circumstances under which the styles will appear are, in fact, well-defined.</p>&#13;
&#13;
<p>Think of it this way: during a sporting event, whenever the home team scores, the crowd will cheer. You don’t know exactly when during a game the team will score, but when it does, the crowd will cheer, just as predicted. The fact that you can’t predict the exact moment of the cheer doesn’t make it any less expected.</p>&#13;
&#13;
<p>Now consider the anchor element (<code>&lt;a&gt;</code>), which (in HTML and related languages) establishes a link from one document to another. Anchors are always anchors, but some anchors refer to pages that have already been visited, while others refer to pages that have yet to be visited. You can’t tell the difference by simply looking at the HTML markup, because in the markup, all anchors look the same.</p>&#13;
&#13;
<p>The only way to tell which links have been visited is by comparing the links in a document to the user’s browser history. So there are actually two basic types of links: visited and unvisited.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Hyperlink-specific pseudo-classes" data-type="sect3"><div class="sect3" id="hyperlink__specific_pseudo-classes">&#13;
<h3>Hyperlink-specific pseudo-classes</h3>&#13;
&#13;
<p>CSS defines a few <a data-primary="pseudo-class selectors" data-secondary="hyperlink pseudo-classes" data-type="indexterm" id="ix_pseudo_class_hyper"/><a data-primary="hyperlink-specific pseudo-classes" data-type="indexterm" id="ix_link_spec_pseudo"/>pseudo-classes that apply only to hyperlinks. In HTML, hyperlinks are any <code>&lt;a&gt;</code> elements with an <code>href</code> attribute; in XML languages, a hyperlink is any element that acts as a link to another resource. <a data-type="xref" href="#link_pseudo-classes">Table 3-1</a> describes the pseudo-classes you can apply to them.</p>&#13;
<table id="link_pseudo-classes">&#13;
<caption><span class="label">Table 3-1. </span>Link pseudo-classes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Name</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>:link</code></p></td>&#13;
<td><p>Refers <a data-primary=":link pseudo-class" data-primary-sortas="link pseudo-class" data-type="indexterm" id="ix_link_pseudo_class"/><a data-primary="links" data-secondary=":link pseudo-class" data-secondary-sortas="link pseudo-class" data-type="indexterm" id="ix_links_link_pseudo"/>to any anchor that is a hyperlink (i.e., has an <code>href</code> attribute) and points to an address that has not been visited.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code class="keep-together">:visited</code></p></td>&#13;
<td><p>Refers<a data-primary=":visited pseudo-class" data-primary-sortas="visited pseudo-class" data-type="indexterm" id="ix_visited_pseudo"/><a data-primary="links" data-secondary=":visited pseudo-class" data-secondary-sortas="visited pseudo-class" data-type="indexterm" id="ix_links_visited_pseudo"/> to any anchor that is a hyperlink to an already visited address. For security reasons, the styles that can be applied to visited links are severely limited; see <a data-type="xref" href="#visited_links_and_privacy">“Visited Links and Privacy”</a> for details.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:any-link</code></p></td>&#13;
<td><p>Refers<a data-primary=":any-link pseudo-class" data-primary-sortas="any-link pseudo-class" data-type="indexterm" id="idm45176130415408"/><a data-primary="links" data-secondary=":any-link pseudo-class" data-secondary-sortas="any-link pseudo-class" data-type="indexterm" id="idm45176130414400"/> to any element that would be matched by either <code>:link</code> or <code>:visited</code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:local-link</code></p></td>&#13;
<td><p>Refers<a data-primary="links" data-secondary=":local-link pseudo-class" data-secondary-sortas="local-link pseudo-class" data-type="indexterm" id="idm45176130410496"/><a data-primary=":local-link pseudo-class" data-primary-sortas="local-link pseudo-class" data-type="indexterm" id="idm45176130409200"/> to any link that points at the same URL as the page being styled. One example would be skip-links within a document. <em>Note: not supported as of early 2023.</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The first of the pseudo-classes in <a data-type="xref" href="#link_pseudo-classes">Table 3-1</a> may seem a bit redundant. After all, if an anchor hasn’t been visited, it must be unvisited, right? If that’s the case, all we should need is the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Although this format seems reasonable, it’s not quite enough. The first of the rules shown here applies not only to unvisited links, but also to any <code>&lt;a&gt;</code> element, even those without an <code>href</code> attribute such as this one:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">id=</code><code class="s">"section004"</code><code class="nt">&gt;</code>4.<code class="w"> </code>The<code class="w"> </code>Lives<code class="w"> </code>of<code class="w"> </code>Meerkats<code class="nt">&lt;/a&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The resulting text would be blue, because the <code>&lt;a&gt;</code> element will match the rule <code>a {color</code>: <code>blue;}</code>. Therefore, to avoid applying your link styles to placeholder links, use the <code>:link</code> and <code>:visited</code> pseudo-classes:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>    <code class="c">/* unvisited links are blue */</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>   <code class="c">/* visited links are red */</code></pre>&#13;
&#13;
<p>This is a good place to revisit attribute and class selectors and show how they can be combined with pseudo-classes. For example, let’s say you want to change the color of links that point outside your own site. In most circumstances, we can use the starts-with attribute selector. However, some CMSs set all links to be absolute URLs, in which case you could assign a class to each of these anchors. It’s easy:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"/about.html"</code><code class="nt">&gt;</code>My<code class="w"> </code>About<code class="w"> </code>page<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"https://www.site.net/"</code><code class="w"> </code><code class="na">class=</code><code class="s">"external"</code><code class="nt">&gt;</code>An<code class="w"> </code>external<code class="w"> </code>site<code class="nt">&lt;/a&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>To apply different styles to the external link, all you need is a rule like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nc">.external</code><code class="nd">:link</code><code class="o">,</code> <code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">^=</code><code class="s2">"http"</code><code class="o">]</code><code class="nd">:link</code> <code class="p">{</code> <code class="k">color</code><code class="o">:</code> <code class="nb">slateblue</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nc">.external</code><code class="nd">:visited</code><code class="o">,</code> <code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">^=</code><code class="s2">"http"</code><code class="o">]</code><code class="nd">:visited</code>  <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This rule will make the second anchor in the preceding markup slate blue by default and maroon once visited, while the first anchor will remain the default color for hyperlinks (usually blue when not visited and purple once visited). For improved usability and accessibility, visited links should be easily distinguished from unvisited links.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Styled <a data-primary="accessibility issues" data-secondary="styled visited links" data-type="indexterm" id="idm45176130214032"/>visited links enable visitors to know where they have been and what they have yet to visit. This is especially important on large websites, where it may be difficult to remember which pages have been visited, especially for those with cognitive disabilities.  Not only is highlighting visited links one of the W3C Web Content Accessibility Guidelines, but it makes searching for content faster, more efficient, and less stressful for everyone.</p>&#13;
</div>&#13;
&#13;
<p>The same general syntax is used for ID selectors as well:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nf">#footer-copyright</code><code class="nd">:link</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nf">#footer-copyright</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If you want to <a data-primary="links" data-secondary=":any-link pseudo-class" data-secondary-sortas="any-link pseudo-class" data-type="indexterm" id="idm45176130170976"/><a data-primary=":any-link pseudo-class" data-primary-sortas="any-link pseudo-class" data-type="indexterm" id="idm45176130169856"/>select all links, regardless of whether they’re visited or not, use <code>:any-link</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nf">#footer-copyright</code><code class="nd">:any-link</code> <code class="p">{</code><code class="k">text-decoration</code><code class="o">:</code> <code class="nb">underline</code><code class="p">;}</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="visited_links_and_privacy">&#13;
<h1>Visited Links and Privacy</h1>&#13;
<p>For <a data-primary="privacy issue" data-secondary="visited links and" data-type="indexterm" id="idm45176130162592"/><a data-primary="visited links and privacy" data-type="indexterm" id="idm45176130161616"/><a data-primary="Document Object Model (DOM)" data-secondary="visited links and" data-type="indexterm" id="idm45176130160976"/>well over a decade, it was possible to style visited links with any CSS properties available, just as you could unvisited links. However, in the mid-2000s several people demonstrated that visual styling and simple DOM scripting could be used to determine if a user had visited a given page.</p>&#13;
&#13;
<p>For example, given the rule <code>:visited {font-weight: bold;}</code>, a script could find all of the boldfaced links and tell the user which of those sites they’d visited—or, worse still, report those sites back to a server. A similar, nonscripted tactic uses background images to achieve the same result.</p>&#13;
&#13;
<p>While this might not seem terribly serious, it can be utterly devastating for a web user in a country that jails people for visiting certain sites—opposition parties, unsanctioned religious organizations, “immoral” or “corrupting” sites, and so on. These techniques can also be used by phishing sites to determine which online banks a user has visited. Thus, two steps were taken.</p>&#13;
&#13;
<p>The first step is that only color-related properties can be applied to visited links: <code>color</code>, <code>background-color</code>, <code>column-rule-color</code>, <code>outline-color</code>, <code>border-color</code>, and the individual-side border color properties (e.g., <code>border-top-color</code>). Attempts to apply any other property to a visited link will be ignored. Furthermore, any styles defined for <code>:link</code> will be applied to visited links as well as unvisited links, which effectively makes <code>:link</code> “style any hyperlink,” instead of “style any unvisited &#13;
<span class="keep-together">hyperlink.”</span></p>&#13;
&#13;
<p>The second step is that if a visited link has its styles queried via the DOM, the resulting value will be as if the link were not visited. Thus, if you’ve defined visited links to be purple rather than unvisited links’ blue, even though the link will appear purple onscreen, a DOM query of its color will return the blue value, not the purple one.</p>&#13;
&#13;
<p>This behavior is present throughout all browsing modes, not just “private browsing” modes. Even though we’re limited in how we can use CSS to differentiate visited links from unvisited links, it is important for usability and accessibility to use the limited styles supported by visited links to differentiate them from unvisited links.<a data-primary="" data-startref="ix_link_spec_pseudo" data-type="indexterm" id="idm45176130123136"/><a data-primary="" data-startref="ix_link_pseudo_class" data-type="indexterm" id="idm45176130122160"/><a data-primary="" data-startref="ix_links_link_pseudo" data-type="indexterm" id="idm45176130121216"/><a data-primary="" data-startref="ix_links_visited_pseudo" data-type="indexterm" id="idm45176130120272"/><a data-primary="" data-startref="ix_pseudo_class_hyper" data-type="indexterm" id="idm45176130102896"/><a data-primary="" data-startref="ix_visited_pseudo" data-type="indexterm" id="idm45176130101952"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Nonhyperlink location pseudo-classes" data-type="sect3"><div class="sect3" id="idm45176130460784">&#13;
<h3>Nonhyperlink location pseudo-classes</h3>&#13;
&#13;
<p>Hyperlinks aren’t the only <a data-primary="non-hyperlink location pseudo-classes" data-type="indexterm" id="ix_nonhyper_pseudo"/>elements that can be related to location.  CSS also provides a few pseudo-classes that relate to the targets of hyperlinks, summarized in <a data-type="xref" href="#non_link_pseudo-classes">Table 3-2</a>.</p>&#13;
<table id="non_link_pseudo-classes">&#13;
<caption><span class="label">Table 3-2. </span>Nonlink location pseudo-classes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Name</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>:target</code></p></td>&#13;
<td><p>Refers<a data-primary=":target pseudo-class" data-primary-sortas="target pseudo-class" data-type="indexterm" id="ix_target_pseudo"/> to an element whose <code>id</code> attribute value matches the fragment selector in the URL used to load the page—that is, the element specifically targeted by the URL.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:target-within</code></p></td>&#13;
<td><p>Refers<a data-primary=":target-within pseudo-class" data-primary-sortas="target-within pseudo-class" data-type="indexterm" id="idm45176124476704"/> to an element that is the target of the URL, or that contains an element that is so targeted.  <em>Note: not supported as of early 2023.</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:scope</code></p></td>&#13;
<td><p>Refers<a data-primary=":scope pseudo-class" data-primary-sortas="scope pseudo-class" data-type="indexterm" id="idm45176124473504"/> to elements that are a reference point for selector matching.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Let’s talk about target selection.  <a data-primary="fragment identifier" data-type="indexterm" id="idm45176124471552"/>When a URL includes a fragment identifier, the piece of the document at which it points is called (in CSS) the <em>target</em>. Thus, you can uniquely style any element that is the target of a URL fragment identifier with the <code>:target</code> pseudo-class.</p>&#13;
&#13;
<p>Even if you’re unfamiliar with the term <em>fragment identifier</em>, you’ve probably seen them in action. Consider this URL:</p>&#13;
&#13;
<pre data-type="programlisting">http://www.w3.org/TR/css3-selectors/#target-pseudo</pre>&#13;
&#13;
<p>The <code>target-pseudo</code> portion of the URL is the fragment identifier, which is marked by the <code>#</code> symbol. If the referenced page (<em>http://www.w3.org/TR/css3-selectors/</em>) has an element with an ID of <code>target-pseudo</code>, that element becomes the target of the fragment identifier.</p>&#13;
&#13;
<p>Thanks to <code>:target</code>, you can highlight any targeted element within a document, or you can devise different styles for various types of elements that might be targeted—say, one style for targeted headings, another for targeted tables, and so on. <a data-type="xref" href="#styling_a_fragment_identifier_target">Figure 3-15</a> shows an example of <code>:target</code> in action:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nd">:target</code> <code class="p">{</code><code class="k">border-left</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">yellow</code> <code class="sx">url(target.png)</code>&#13;
    <code class="nb">top</code> <code class="nb">right</code> <code class="nb">no-repeat</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="styling_a_fragment_identifier_target">&#13;
<img alt="css5 0315" src="assets/css5_0315.png"/>&#13;
<h6><span class="label">Figure 3-15. </span>Styling a fragment identifier target</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>:target</code> styles will not be applied in three circumstances:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The page is accessed via a URL that does not have a fragment identifier.</p>&#13;
</li>&#13;
<li>&#13;
<p>The page is accessed via a URL that has a fragment identifier, but the identifier does not match any elements within the document.</p>&#13;
</li>&#13;
<li>&#13;
<p>The page’s URL is updated in such a way that a scroll state is not created, which happens most often via JS shenanigans.  (This isn’t a CSS rule, but it is how browsers behave.)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>More interestingly, though, what happens if multiple elements within a document can be matched by the fragment identifier—for example, if the author erroneously includes three separate instances of <code>&lt;div id="target-pseudo"&gt;</code> in the same document?</p>&#13;
&#13;
<p>The short answer is that CSS doesn’t have or need rules to cover this case, because all CSS is concerned with is styling targets. Whether the browser picks just one of the three elements to be the target or designates all three as coequal targets, <code>:target</code> styles should be applied to anything that is a valid target.<a data-primary="" data-startref="ix_target_pseudo" data-type="indexterm" id="idm45176124435792"/></p>&#13;
&#13;
<p>Closely <a data-primary=":target-within pseudo-class" data-primary-sortas="target-within pseudo-class" data-type="indexterm" id="idm45176124434208"/>related to the <code>:target</code> pseudo-class is the <code>:target-within</code> pseudo-class.  The difference is that <code>:target-within</code> will match not only elements that are targets, but also elements that are the ancestors of targets.  Thus, the following CSS would match any <code>&lt;p&gt;</code> element containing a target, or that was itself a target:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">:target-within</code> <code class="p">{</code><code class="k">border-left</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">yellow</code> <code class="sx">url(target.png)</code>&#13;
    <code class="nb">top</code> <code class="nb">right</code> <code class="nb">no-repeat</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Or it would, anyway, if any browser supported it.  As of early 2023, this is not the case.</p>&#13;
&#13;
<p>Finally, we consider the <code>:scope</code> pseudo-class.  This is quite widely supported, but at present, it comes in handy only in scripting situations.  Consider the following JS and HTML, which we’ll explain after the code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">var</code> <code class="nx">output</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'output'</code><code class="p">);</code>&#13;
<code class="kd">var</code> <code class="nx">registers</code> <code class="o">=</code> <code class="nx">output</code><code class="p">.</code><code class="nx">querySelectorAll</code><code class="p">(</code><code class="s1">':scope &gt; div'</code><code class="p">);</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;section</code><code class="w"> </code><code class="na">id=</code><code class="s">"output"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;h3&gt;</code>Results<code class="nt">&lt;/h3&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;div&gt;&lt;/div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;div&gt;&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/section&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The JS portion says, in effect, “Find the element with an ID of <code>output</code>. Then, find all the <code>&lt;div&gt;</code> elements that are children of the <code>output</code> element you just found.”  (Yes, CSS selectors can be used in JS!)  The <code>:scope</code> in that bit of JS refers to the scope of the thing that had been found, thus keeping the selection confined to just that instead of the whole document.  The result is that, in the JS program’s memory, it now has a structure holding references to the two <code>&lt;div&gt;</code> elements in the HTML.</p>&#13;
&#13;
<p>If you <a data-primary=":scope pseudo-class" data-primary-sortas="scope pseudo-class" data-type="indexterm" id="idm45176124272528"/>use <code>:scope</code> in straight CSS, it will refer to the <em>scoping root</em>, which (at present) means the <code>&lt;html&gt;</code> element, assuming the document is HTML.  <a data-primary="scoping root" data-type="indexterm" id="idm45176124270144"/>Neither HTML nor CSS provides a way to set scoping roots other than the root element of the document.  So, outside of JS, <code>:scope</code> is essentially equivalent to <code>:root</code>.  That may change in the future, but for now, you should use <code>:scope</code> only in JS contexts.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="javascript_and_css">&#13;
<h1>JS and CSS</h1>&#13;
<p>CSS has <a data-primary="JavaScript, CSS influence on" data-type="indexterm" id="idm45176124238240"/>influenced the evolution of JS in a few ways, and one is the ability to use the CSS selection engine from within JS via <code>.querySelectorAll()</code>.  This method can take any CSS selector as a string, and will return a collection of all the elements within the DOM that are matched by the selector. The <code>.querySelector()</code> method also accepts any CSS selector as a string, but will return only the first element found, so it’s not always as useful.</p>&#13;
&#13;
<p>You may come across older JS methods for collecting elements, such as <code>.getElementByID()</code> and <code>.getElementsByTagName()</code>. These are from the time before <code>.querySelectorAll()</code> was added to JS, and while they may be marginally more performant than <code>.querySelectorAll()</code> in some situations, they’re mostly found in legacy codebases these days.  Both are now more simply handled with <code>.querySelectorAll()</code>. For example, the following two lines would have almost the same result:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">var</code> <code class="nx">subheads</code> <code class="o">=</code> <code class="nx">Document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s1">'h2'</code><code class="p">);</code>&#13;
<code class="kd">var</code> <code class="nx">subheads</code> <code class="o">=</code> <code class="nx">Document</code><code class="p">.</code><code class="nx">querySelectorAll</code><code class="p">(</code><code class="s1">'h2'</code><code class="p">);</code></pre>&#13;
&#13;
<p>Similarly, a <code>.getElementById('summary')</code> can be equivalently replaced with <code>.querySelectorAll('#summary')</code>.</p>&#13;
&#13;
<p>The advantage in <code>.querySelectorAll()</code> is that it can take any selector, no matter how complex, including grouped selectors.  Thus, you could get all of the level-two and &#13;
<span class="keep-together">-three</span> headings in a single call: <code>Document.querySelectorAll('h2, h3')</code>.  Or you could grab a more complex set of elements with something like <code>.querySelectorAll('h2 + p, pre + p, table + *, thead th:nth-child(even)')</code>.</p>&#13;
&#13;
<p>Note, though, that the list of elements returned by <code>.querySelectorAll()</code> is static, and therefore is not updated when the DOM is dynamically changed. If another part of the JS adds a section with an <code>&lt;h2&gt;</code> element in it, the elements previously collected with <code>.querySelectorAll('h2, h3')</code> will <em>not</em> be updated to include the newly added <code>&lt;h2&gt;</code>. You’d need to either add it yourself manually or do a new <code>.querySelectorAll()</code> call.<a data-primary="" data-startref="ix_pseudo_class_loc" data-type="indexterm" id="idm45176124186576"/><a data-primary="" data-startref="ix_nonhyper_pseudo" data-type="indexterm" id="idm45176124185568"/><a data-primary="" data-startref="ix_loc_pseudo_class" data-type="indexterm" id="idm45176124184624"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="User Action Pseudo-Classes" data-type="sect2"><div class="sect2" id="user_action_pseudo-classes">&#13;
<h2>User Action Pseudo-Classes</h2>&#13;
&#13;
<p>CSS <a data-primary="pseudo-class selectors" data-secondary="user action pseudo-classes" data-type="indexterm" id="ix_pseudo_class_dyn"/><a data-primary="user action pseudo-classes" data-type="indexterm" id="ix_ui_pseudo_class"/><a data-primary="dynamic pseudo-classes" data-type="indexterm" id="ix_dyn_pseudo_class"/>defines a few pseudo-classes that can change a document’s appearance based on actions taken by the user. These <em>dynamic pseudo-classes</em> have traditionally been used to style hyperlinks, but the possibilities are much wider. Pseudo-classes are described in <a data-type="xref" href="#user_action_pseudo-classes-id1">Table 3-3</a>.</p>&#13;
<table id="user_action_pseudo-classes-id1">&#13;
<caption><span class="label">Table 3-3. </span>User action pseudo-classes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Name</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>:hover</code></p></td>&#13;
<td><p>Refers<a data-primary=":hover pseudo-class" data-primary-sortas="hover pseudo-class" data-type="indexterm" id="idm45176124197120"/> to any element over which the mouse pointer is placed—e.g., a hyperlink over which the mouse pointer is hovering</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:active</code></p></td>&#13;
<td><p>Refers<a data-primary=":active pseudo-class" data-primary-sortas="active pseudo-class" data-type="indexterm" id="idm45176124167600"/> to any element that has been activated by user input—e.g., a hyperlink on which a user clicks during the time the mouse button is held down, or an element a user has tapped via touch screen</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:focus</code></p></td>&#13;
<td><p>Refers<a data-primary=":focus pseudo-class" data-primary-sortas="focus pseudo-class" data-type="indexterm" id="idm45176124164800"/> to any element that currently has the input focus—i.e., can accept keyboard input or otherwise be activated in some way</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:focus-within</code></p></td>&#13;
<td><p>Refers<a data-primary=":focus-within pseudo-class" data-primary-sortas="focus-within pseudo-class" data-type="indexterm" id="idm45176124162000"/> to any element that currently has the input focus—i.e., can accept keyboard input or be activated in some way—or an element containing an element that is so focused</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:focus-visible</code></p></td>&#13;
<td><p>Refers<a data-primary=":focus-visible pseudo-class" data-primary-sortas="focus-visible pseudo-class" data-type="indexterm" id="idm45176124159168"/> to any element that currently has the input focus, but only if the user agent thinks it is an element type that should have visible focus</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Elements that can become <code>:active</code> or have <code>:focus</code> include links, buttons, menu items, any element with a <code>tabindex</code> value, and all other interactive elements, including form controls and elements containing content that can be edited (by having the attribute, <code>contenteditable</code>, added to the element’s opening tag).</p>&#13;
&#13;
<p>As with <code>:link</code> and <code>:visited</code>, these pseudo-classes are most familiar in the context of hyperlinks. Many web pages have styles that look like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">navy</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:focus</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The order of the pseudo-classes is more important than it might seem at first. The usual recommendation is <code>link</code>, <code>visited</code>, <code>focus</code>, <code>hover</code>, and <code>active</code>. The next chapter explains why this particular order is important and discusses several reasons you might choose to change or even ignore the recommendation.</p>&#13;
</div>&#13;
&#13;
<p>Notice that the dynamic pseudo-classes can be applied to any element, which is good since it’s often useful to apply dynamic styles to elements that aren’t links. Consider this example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="nd">:focus</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>By using this markup, you could highlight a form element that is ready to accept keyboard input, as shown in <a data-type="xref" href="#highlighting_a_form_element_that_has_foc">Figure 3-16</a>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="highlighting_a_form_element_that_has_foc">&#13;
<img alt="css5 0316" src="assets/css5_0316.png"/>&#13;
<h6><span class="label">Figure 3-16. </span>Highlighting a form element that has focus</h6>&#13;
</div></figure>&#13;
&#13;
<p>Two <a data-primary=":focus-visible pseudo-class" data-primary-sortas="focus-visible pseudo-class" data-type="indexterm" id="idm45176124071328"/>relatively new additions to the user-action pseudo-classes are <code>:focus-within</code> and <code>:focus-visible</code>.  Let’s take the second one first.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The :focus-visible pseudo-class" data-type="sect3"><div class="sect3" id="idm45176124069296">&#13;
<h3>The :focus-visible pseudo-class</h3>&#13;
&#13;
<p>The <code>:focus-visible</code> class is very much like <code>:focus</code> in that it applies to elements that have focus, but there’s a big difference: it will match only if the element that has focus is an element that the user agent thinks should be given visible focus styles in a given situation.</p>&#13;
&#13;
<p>For example, consider HTML buttons.  When a button is clicked via a mouse, that button is given focus, the same as if we had used a keyboard interface to move the focus to it.  As authors who care about accessibility and aesthetics, we want the button to have focus when it’s focused via the keyboard or another assistive technology, but we might not like it getting focus styles when it’s clicked or tapped.</p>&#13;
&#13;
<p>We can split this difference by using CSS such as the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">button</code><code class="nd">:focus-visible</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">maroon</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will put a thick dark-red outline around the button when tabbing to it via keyboard, but the rule won’t be applied when the button is clicked with the mouse.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The :focus-within pseudo-class" data-type="sect3"><div class="sect3" id="idm45176124030944">&#13;
<h3>The :focus-within pseudo-class</h3>&#13;
&#13;
<p>Building on <a data-primary=":focus-within pseudo-class" data-primary-sortas="focus-within pseudo-class" data-type="indexterm" id="idm45176124029568"/>that, <code>:focus-within</code> applies to any element that has focus, or any element that has a descendant with focus.  Given the following CSS and HTML, we’ll get the result shown in <a data-type="xref" href="#selecting_with_focus_within">Figure 3-17</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code><code class="nd">:focus-within</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:focus-visible</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="n">currentcolor</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;nav&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"home.html"</code><code class="nt">&gt;</code>Home<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"about.html"</code><code class="nt">&gt;</code>About<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"contact.html"</code><code class="nt">&gt;</code>Contact<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/nav&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_with_focus_within">&#13;
<img alt="css5 0317" src="assets/css5_0317.png"/>&#13;
<h6><span class="label">Figure 3-17. </span>Selecting elements by using <code>:focus-within</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>The third link currently has focus, having received it by the user tabbing to that link, and is styled with a 2-pixel outline.  The <code>&lt;nav&gt;</code> element that contains it is also being given focus styling via <code>:focus-within</code>, because an element within itself (that is, an element descended from it) currently has focus.  This adds a little more visual weight to that area of the page, which can be helpful.  Be careful of overdoing it, though.  Too many focus styles can create visual overload, potentially confusing users.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>While you can style elements with <code>:focus</code> any way you like, do <em>not</em> remove all styling from focused elements.  Differentiating which element currently has focus is vital for accessibility, especially for those navigating your site or application with a keyboard.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Real-world issues with dynamic styling" data-type="sect3"><div class="sect3" id="real-world_issues_with_dynamic_styling">&#13;
<h3>Real-world issues with dynamic styling</h3>&#13;
&#13;
<p>Dynamic <a data-primary=":hover pseudo-class" data-primary-sortas="hover pseudo-class" data-type="indexterm" id="idm45176123930192"/><a data-primary=":visited pseudo-class" data-primary-sortas="visited pseudo-class" data-type="indexterm" id="idm45176123929184"/>pseudo-classes present some interesting issues and peculiarities. For example, you can set visited and unvisited links to one font size and make hovered links a larger size, as shown in <a data-type="xref" href="#changing_layout_with_dynamic_pseudo-clas">Figure 3-18</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code><code class="o">,</code> <code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">13px</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code><code class="o">,</code> <code class="nt">a</code><code class="nd">:active</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="changing_layout_with_dynamic_pseudo-clas">&#13;
<img alt="css5 0318" src="assets/css5_0318.png"/>&#13;
<h6><span class="label">Figure 3-18. </span>Changing layout with dynamic pseudo-classes</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see, the <a data-primary=":active pseudo-class" data-primary-sortas="active pseudo-class" data-type="indexterm" id="idm45176123879408"/>user agent increases the size of the anchor while the mouse pointer hovers over it—or, thanks to the <code>:active</code> setting, when a user touches it on a touch screen. Because we are changing a property that impacts line height, a user agent that supports this behavior must redraw the document while an anchor is in the hover state, which could force a reflow of all the content that follows the link.<a data-primary="" data-startref="ix_dyn_pseudo_class" data-type="indexterm" id="idm45176123877776"/><a data-primary="" data-startref="ix_pseudo_class_dyn" data-type="indexterm" id="idm45176123876752"/><a data-primary="" data-startref="ix_ui_pseudo_class" data-type="indexterm" id="idm45176123875808"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="UI-State Pseudo-Classes" data-type="sect2"><div class="sect2" id="ui_state_pseudo-classes">&#13;
<h2>UI-State Pseudo-Classes</h2>&#13;
&#13;
<p>Closely <a data-primary="UI-state pseudo-classes" data-type="indexterm" id="ix_uistate_pseudo_class"/><a data-primary="pseudo-class selectors" data-secondary="UI-state pseudo-classes" data-type="indexterm" id="ix_pseudo_class_uistate"/>related to the dynamic pseudo-classes are the <em>user-interface (UI) state pseudo-classes</em>, which are summarized in <a data-type="xref" href="#ui_state_pseudo-classes-id1">Table 3-4</a>. These pseudo-classes allow for styling based on the current state of UI elements such as checkboxes.</p>&#13;
<table id="ui_state_pseudo-classes-id1">&#13;
<caption><span class="label">Table 3-4. </span>UI-state pseudo-classes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Name</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>:enabled</code></p></td>&#13;
<td><p>Refers<a data-primary=":enabled pseudo-class" data-primary-sortas="enabled pseudo-class" data-type="indexterm" id="idm45176123864320"/> to UI elements (such as form elements) that are enabled—that is, available for input</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:disabled</code></p></td>&#13;
<td><p>Refers<a data-primary=":disabled pseudo-class" data-primary-sortas="disabled pseudo-class" data-type="indexterm" id="idm45176123861520"/> to UI elements (such as form elements) that are disabled—that is, not available for input</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:checked</code></p></td>&#13;
<td><p>Refers<a data-primary=":checked pseudo-class" data-primary-sortas="checked pseudo-class" data-type="indexterm" id="idm45176123835232"/> to radio buttons or checkboxes that have been selected, either by the user or by defaults within the document itself</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:indeterminate</code></p></td>&#13;
<td><p>Refers<a data-primary=":indeterminate pseudo-class" data-primary-sortas="indeterminate pseudo-class" data-type="indexterm" id="idm45176123832304"/> to radio buttons or checkboxes that are neither checked nor unchecked; this state can be set only via DOM scripting, and not by user input</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:default</code></p></td>&#13;
<td><p>Refers<a data-primary=":default pseudo-class" data-primary-sortas="default pseudo-class" data-type="indexterm" id="idm45176123829568"/> to the radio button, checkbox, or option that was selected by default</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:autofill</code></p></td>&#13;
<td><p>Refers<a data-primary=":autofill pseudo-class" data-primary-sortas="autofill pseudo-class" data-type="indexterm" id="idm45176123826768"/> to a user input that has been autofilled by the browser</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:placeholder-shown</code></p></td>&#13;
<td><p>Refers<a data-primary=":placeholder-shown pseudo-class" data-primary-sortas="placeholder-shown pseudo-class" data-type="indexterm" id="idm45176123823968"/> to a user input that has placeholder (not value) text prefilled</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:valid</code></p></td>&#13;
<td><p>Refers<a data-primary=":valid pseudo-class" data-primary-sortas="valid pseudo-class" data-type="indexterm" id="idm45176123821232"/> to a user input that meets all of its data validity requirements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:invalid</code></p></td>&#13;
<td><p>Refers<a data-primary=":invalid pseudo-class" data-primary-sortas="invalid pseudo-class" data-type="indexterm" id="idm45176123818432"/> to a user input that does not meet all of its data validity requirements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:in-range</code></p></td>&#13;
<td><p>Refers<a data-primary=":in-range pseudo-class" data-primary-sortas="in-range pseudo-class" data-type="indexterm" id="idm45176123815632"/> to a user input whose value is between the minimum and maximum values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:out-of-range</code></p></td>&#13;
<td><p>Refers<a data-primary=":out-of-range pseudo-class" data-primary-sortas="out-of-range pseudo-class" data-type="indexterm" id="idm45176123812832"/> to a user input whose value is below the minimum or above the maximum values allowed by the control</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:required</code></p></td>&#13;
<td><p>Refers<a data-primary=":required pseudo-class" data-primary-sortas="required pseudo-class" data-type="indexterm" id="idm45176123809936"/> to a user input that must have a value set</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:optional</code></p></td>&#13;
<td><p>Refers<a data-primary=":optional pseudo-class" data-primary-sortas="optional pseudo-class" data-type="indexterm" id="idm45176123807136"/> to a user input that does not need to have a value set</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:read-write</code></p></td>&#13;
<td><p>Refers<a data-primary=":read-write pseudo-class" data-primary-sortas="read-write pseudo-class" data-type="indexterm" id="idm45176123804336"/> to a user input that is editable by the user</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:read-only</code></p></td>&#13;
<td><p>Refers<a data-primary=":read-only pseudo-class" data-primary-sortas="read-only pseudo-class" data-type="indexterm" id="idm45176123801520"/> to a user input that is not editable by the user</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Although the state of a UI element can certainly be changed by user action—for example, a user checking or unchecking a checkbox—UI-state pseudo-classes are not classified as purely dynamic because they can also be affected by the document structure or scripting.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Enabled and disabled UI elements" data-type="sect3"><div class="sect3" id="enabled_and_disabled_ui_elements">&#13;
<h3>Enabled and disabled UI elements</h3>&#13;
&#13;
<p>Thanks to both <a data-primary=":enabled pseudo-class" data-primary-sortas="enabled pseudo-class" data-type="indexterm" id="idm45176123797600"/><a data-primary=":disabled pseudo-class" data-primary-sortas="disabled pseudo-class" data-type="indexterm" id="idm45176123796592"/><a data-primary="Document Object Model (DOM)" data-secondary="disabling UI elements" data-type="indexterm" id="idm45176123795648"/>DOM scripting and HTML, you can mark a UI element (or group of UI elements) as being disabled. A disabled element is displayed but cannot be selected, activated, or otherwise interacted with by the user. Authors can set an element to be disabled either through DOM scripting or by adding a <code>disabled</code> attribute to the element’s markup.</p>&#13;
&#13;
<p>Any element that can be disabled, but hasn’t been, is by definition enabled. You can style these two states by using the <code>:enabled</code> and <code>:disabled</code> pseudo-classes. It’s much more common to style disabled elements and leave enabled elements alone, but both have their uses, as illustrated in <a data-type="xref" href="#styling_enabled_and_disabled_ui_elements">Figure 3-19</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:enabled</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nd">:disabled</code> <code class="p">{</code><code class="k">opacity</code><code class="o">:</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_enabled_and_disabled_ui_elements">&#13;
<img alt="css5 0319" src="assets/css5_0319.png"/>&#13;
<h6><span class="label">Figure 3-19. </span>Styling enabled and disabled UI elements</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Check states" data-type="sect3"><div class="sect3" id="check_states">&#13;
<h3>Check states</h3>&#13;
&#13;
<p>In <a data-primary=":checked pseudo-class" data-primary-sortas="checked pseudo-class" data-type="indexterm" id="idm45176123777008"/>addition to being enabled or disabled, certain UI elements can be checked or unchecked—in HTML, the input types <code>checkbox</code> and <code>radio</code> fit this definition. CSS offers a <code>:checked</code> pseudo-class to handle elements in that state. In <a data-primary=":indeterminate pseudo-class" data-primary-sortas="indeterminate pseudo-class" data-type="indexterm" id="idm45176123774496"/>addition, the <code>:indeterminate</code> pseudo-class matches any checkable UI element that is neither checked nor unchecked. These states are illustrated in <a data-type="xref" href="#styling_checked_and_indeterminate_ui_ele">Figure 3-20</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:checked</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nd">:indeterminate</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_checked_and_indeterminate_ui_ele">&#13;
<img alt="css5 0320" src="assets/css5_0320.png"/>&#13;
<h6><span class="label">Figure 3-20. </span>Styling checked and indeterminate UI elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>Although checkable elements are unchecked by default, an HTML author can toggle them on by adding the <code>checked</code> attribute to an element’s markup. An author can also use DOM scripting to flip an element’s checked state to checked or unchecked, whichever they &#13;
<span class="keep-together">prefer.</span></p>&#13;
&#13;
<p>As of early 2023, the indeterminate state can be set only through DOM scripting or by the user agent itself; no markup-level method exists to set elements to an indeterminate state. The purpose of styling an indeterminate state is to visually indicate that the element needs to be checked (or unchecked) by the user. However, this is purely a visual effect: it does not affect the underlying state of the UI element, which is either checked or unchecked, depending on document markup and the effects of any DOM scripting.</p>&#13;
&#13;
<p>Although the previous examples show styled radio buttons, remember that direct styling of radio buttons and checkboxes with CSS is actually very limited. Nevertheless, that shouldn’t limit your use of the selected-option pseudo-classes. As an example, you can style the labels associated with your checkboxes and radio buttons by using a combination of <code>:checked</code> and the adjacent sibling combinator:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"checkbox"</code><code class="o">]</code><code class="nd">:checked</code> <code class="o">+</code> <code class="nt">label</code> <code class="p">{</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;</code>&#13;
  <code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">id=</code><code class="s">"chbx"</code><code class="w"> </code><code class="na">type=</code><code class="s">"checkbox"</code><code class="nt">&gt;</code><code class="w"> </code><code class="nt">&lt;label</code><code class="w"> </code><code class="na">for=</code><code class="s">"chbx"</code><code class="nt">&gt;</code>I<code class="w"> </code>am<code class="w"> </code>a<code class="w"> </code>label<code class="nt">&lt;/label&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If you need to select all checkboxes that are not checked, use the negation pseudo-class (which is covered later in the chapter) like this: <code>input[type="checkbox"]:not(:checked)</code>. Only radio buttons and checkboxes can be checked. Note that every element, and these two when not checked, are <code>:not(:checked)</code>. This approach does not fill the gap left by the absence of an <code>:unchecked</code> pseudo-class, and such a pseudo-class should match only elements that should be checkable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Default-value pseudo-classes" data-type="sect3"><div class="sect3" id="idm45176123778608">&#13;
<h3>Default-value pseudo-classes</h3>&#13;
&#13;
<p>Three <a data-primary=":default pseudo-class" data-primary-sortas="default pseudo-class" data-type="indexterm" id="idm45176123630144"/>pseudo-classes relate to default values and filler text: <code>:default</code>, <code>:placeholder-shown</code>, and <code>:autofill</code>.</p>&#13;
&#13;
<p>The <code>:default</code> pseudo-class matches the UI elements that are the default among a set of similar elements. This typically applies to context menu items, buttons, and select lists/menus. If there are several same-named radio buttons, the one that was originally selected (if any) matches <code>:default</code>, even if the UI has been updated by the user so that it no longer matches <code>:checked</code>. If a checkbox was checked on page load, <code>:default</code> matches it. Any initially selected option(s) in a <code>select</code> element will match:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"checkbox"</code><code class="o">]</code><code class="nd">:default</code> <code class="o">+</code> <code class="nt">label</code> <code class="p">{</code> <code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;</code> <code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">type=</code><code class="s">"checkbox"</code><code class="w"> </code><code class="na">id=</code><code class="s">"chbx"</code><code class="w"> </code><code class="err">checked</code><code class="w"> </code><code class="na">name=</code><code class="s">"foo"</code><code class="w"> </code><code class="na">value=</code><code class="s">"bar"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;label</code><code class="w"> </code><code class="na">for=</code><code class="s">"chbx"</code><code class="nt">&gt;</code>This<code class="w"> </code>was<code class="w"> </code>checked<code class="w"> </code>on<code class="w"> </code>page<code class="w"> </code>load<code class="nt">&lt;/label&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>:default</code> pseudo-class will also match a form’s default button, which is generally the first <code>button</code> element in DOM order that is a member of a given form.  This could be used to indicate to users which button will be activated if they just hit Enter, instead of explicitly selecting a button to activate.</p>&#13;
&#13;
<p>The <code>:placeholder-shown</code> <a data-primary=":placeholder-shown pseudo-class" data-primary-sortas="placeholder-shown pseudo-class" data-type="indexterm" id="idm45176123542192"/>pseudo-class is similar in that it will select any input that has placeholder text defined at the markup level while that placeholder text is visible. The placeholder is no longer shown when the input has a value. For example:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">input</code> <code class="na">type</code><code class="o">=</code><code class="s">"text"</code> <code class="na">id</code><code class="o">=</code><code class="s">"firstName"</code> <code class="na">placeholder</code><code class="o">=</code><code class="s">"Your first name"</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">input</code> <code class="na">type</code><code class="o">=</code><code class="s">"text"</code> <code class="na">id</code><code class="o">=</code><code class="s">"lastName"</code>  <code class="na">placeholder</code><code class="o">=</code><code class="s">"Your last name"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>By default, the value of a <code>placeholder</code> attribute will be placed into the input fields in a browser, usually in a lighter color than normal text.  If you want to style those input elements in a consistent way, you can do something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="nd">:placeholder-shown</code> <code class="p">{</code><code class="k">opacity</code><code class="o">:</code> <code class="m">0</code><code class="o">.</code><code class="m">75</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This selects the input as a whole, not the placeholder text.  (To style the placeholder text itself, see <a data-type="xref" href="#the_placeholder_text_pseudo">“The Placeholder Text Pseudo-Element”</a>.)</p>&#13;
&#13;
<p>The <code>:autofill</code> <a data-primary=":autofill pseudo-class" data-primary-sortas="autofill pseudo-class" data-type="indexterm" id="idm45176123482288"/>pseudo-class is a little bit different from the other two: it matches any element that has had its value automatically filled in or auto-completed by the browser.  This may be familiar to you if you’ve ever filled out a form by having the browser fill in stored values of your name, email, mailing address, and so on.  The input fields that are filled in usually get a distinct style, like a yellowish background.  You can add to that using <code>:autofill</code>, perhaps like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="nd">:autofill</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="nb">thick</code> <code class="nb">solid</code> <code class="nb">maroon</code><code class="p">;}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>While you can add to default browser styling of autofilled text, overriding the browser’s built-in styles for things such as background colors is difficult. This is because the browsers’ styles for autofilled fields are set to override just about anything else, largely as a way to provide users with a consistent experience of autofilled content and to protect the user.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optionality pseudo-classes" data-type="sect3"><div class="sect3" id="idm45176123631184">&#13;
<h3>Optionality pseudo-classes</h3>&#13;
&#13;
<p>The <code>:required</code> <a data-primary=":optional pseudo-class" data-primary-sortas="optional pseudo-class" data-type="indexterm" id="idm45176123411024"/><a data-primary=":required pseudo-class" data-primary-sortas="required pseudo-class" data-type="indexterm" id="idm45176123410128"/>pseudo-class matches any user-input element that is required, as denoted by the presence of the <code>required</code> attribute. The <code>:optional</code> pseudo-class matches user-input elements that do not have the <code>required</code> attribute, or whose <code>required</code> attribute has a value of <code>false</code>.</p>&#13;
&#13;
<p>A user-input element is <code>:required</code> if the user must provide a value for before submitting the form to which it belongs. All other user-input elements are matched by <code>:optional</code>. For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="nd">:required</code> <code class="p">{</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#f00</code><code class="p">;}</code>&#13;
<code class="nt">input</code><code class="nd">:optional</code> <code class="p">{</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#ccc</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">type=</code><code class="s">"email"</code><code class="w"> </code><code class="na">placeholder=</code><code class="s">"enter an email address"</code><code class="w"> </code><code class="err">required</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;input</code><code class="w"> </code><code class="na">type=</code><code class="s">"email"</code><code class="w"> </code><code class="na">placeholder=</code><code class="s">"optional email address"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;input</code><code class="w"> </code><code class="na">type=</code><code class="s">"email"</code><code class="w"> </code><code class="na">placeholder=</code><code class="s">"optional email address"</code><code class="w"> </code><code class="na">required=</code><code class="s">"false"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The first email input will match the <code>:required</code> pseudo-class because of the presence of the <code>required</code> attribute. The second input is optional and therefore will match the <code>:optional</code> pseudo-class. The same is true for the third input, which has a <code>required</code> attribute, but the value is <code>false</code>.</p>&#13;
&#13;
<p>Elements that are not user-input elements can be neither required nor optional. Including the <code>required</code> attribute on a non-user-input element won’t lead to an optionality pseudo-class match.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Validity pseudo-classes" data-type="sect3"><div class="sect3" id="idm45176123285504">&#13;
<h3>Validity pseudo-classes</h3>&#13;
&#13;
<p>The <code>:valid</code> <a data-primary=":valid pseudo-class" data-primary-sortas="valid pseudo-class" data-type="indexterm" id="idm45176123283488"/>pseudo-class refers to a user input that meets all of its data validity requirements. The <code>:invalid</code> pseudo-class, on the other hand, refers to a user input that does not meet all of its data validity requirements.</p>&#13;
&#13;
<p>The validity pseudo-classes <code>:valid</code> and <code>:invalid</code> apply only to elements having the capacity for data validity requirements: a <code>&lt;div&gt;</code> will never match either selector, but an <code>&lt;input&gt;</code> could match either, depending on the current state of the interface.</p>&#13;
&#13;
<p>In the following example, an image is dropped into the background of any email input that has focus, with one image being used when the input is invalid and another used when the input is valid, as illustrated in <a data-type="xref" href="#styling_valid_and_invalid_inputs">Figure 3-21</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"email"</code><code class="o">]</code><code class="nd">:focus</code> <code class="p">{</code>&#13;
  <code class="k">background-position</code><code class="o">:</code> <code class="m">100%</code> <code class="m">50%</code><code class="p">;</code>&#13;
  <code class="k">background-repeat</code><code class="o">:</code> <code class="nb">no-repeat</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"email"</code><code class="o">]</code><code class="nd">:focus:invalid</code> <code class="p">{</code>&#13;
  <code class="k">background-image</code><code class="o">:</code> <code class="sx">url(warning.jpg)</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"email"</code><code class="o">]</code><code class="nd">:focus:valid</code> <code class="p">{</code>&#13;
  <code class="k">background-image</code><code class="o">:</code> <code class="sx">url(checkmark.jpg)</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">type=</code><code class="s">"email"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_valid_and_invalid_inputs">&#13;
<img alt="css5 0321" src="assets/css5_0321.png"/>&#13;
<h6><span class="label">Figure 3-21. </span>Styling valid and invalid UI elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>Keep in mind that these pseudo-class states may not act as you might expect.  For example, as of late 2022, any empty email input that isn’t required matches <code>:valid</code>. Even though a null input is not a valid email address, failing to enter an email address is a valid response for an optional input.  If you try to fill in a malformed address or just some random text, that will be matched by <code>:invalid</code> because it isn’t a valid email address.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Range pseudo-classes" data-type="sect3"><div class="sect3" id="idm45176123236896">&#13;
<h3>Range pseudo-classes</h3>&#13;
&#13;
<p>The <a data-primary=":out-of-range pseudo-class" data-primary-sortas="out-of-range pseudo-class" data-type="indexterm" id="idm45176123234944"/><a data-primary="range pseudo-classes" data-type="indexterm" id="idm45176123234000"/><a data-primary=":in-range pseudo-class" data-primary-sortas="in-range pseudo-class" data-type="indexterm" id="idm45176123233328"/>range pseudo-classes include <code>:in-range</code>, which refers to a user input whose value is between the minimum and maximum values set by HTML’s <code>min</code> and <code>max</code> attributes, and <code>:out-of-range</code>, which refers to a user input whose value is below the minimum or above the maximum values allowed by the control.</p>&#13;
&#13;
<p>For example, consider a number input that accepts numbers in the range 0 to 1,000:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"number"</code><code class="o">]</code><code class="nd">:focus</code> <code class="p">{</code>&#13;
  <code class="k">background-position</code><code class="o">:</code> <code class="m">100%</code> <code class="m">50%</code><code class="p">;</code>&#13;
  <code class="k">background-repeat</code><code class="o">:</code> <code class="nb">no-repeat</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"number"</code><code class="o">]</code><code class="nd">:focus:out-of-range</code> <code class="p">{</code>&#13;
  <code class="k">background-image</code><code class="o">:</code> <code class="sx">url(warning.jpg)</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"number"</code><code class="o">]</code><code class="nd">:focus:in-range</code> <code class="p">{</code>&#13;
  <code class="k">background-image</code><code class="o">:</code> <code class="sx">url(checkmark.jpg)</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">id=</code><code class="s">"grams"</code><code class="w"> </code><code class="na">type=</code><code class="s">"number"</code><code class="w"> </code><code class="na">min=</code><code class="s">"0"</code><code class="w"> </code><code class="na">max=</code><code class="s">"1000"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, a value from 0 to 1,000, inclusive, would mean the <code>input</code> element is matched by <code>:in-range</code>.  Any value outside that range, whether input by the user or assigned via the DOM, will cause the <code>input</code> to match <code>:out-of-range</code> instead.</p>&#13;
&#13;
<p>The <code>:in-range</code> and <code>:out-of-range</code> pseudo-classes apply <em>only</em> to elements with range limitations. User inputs that don’t have range limitations, like links for inputs of type <code>tel</code>, will not be matched by either pseudo-class.</p>&#13;
&#13;
<p>HTML also has a <code>step</code> attribute. If a value is invalid because it does not match the <code>step</code> value, but is still between or equal to the <code>min</code> and <code>max</code> values, it will match <code>:invalid</code> while <em>also</em> still matching <code>:in-range</code>. A value can be in range while also being invalid.</p>&#13;
&#13;
<p>Thus, in the following scenario, the input’s value will be both red and boldfaced, because the value <code>23</code> is in range but is not evenly divisible by 10:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"number"</code><code class="o">]</code><code class="nd">:invalid</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"number"</code><code class="o">]</code><code class="nd">:in-range</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">id=</code><code class="s">"by-tens"</code><code class="w"> </code><code class="na">type=</code><code class="s">"number"</code><code class="w"> </code><code class="na">min=</code><code class="s">"0"</code><code class="w"> </code><code class="na">max=</code><code class="s">"1000"</code><code class="w"> </code><code class="na">step=</code><code class="s">"10"</code><code class="w"> </code><code class="na">value=</code><code class="s">"23"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mutability pseudo-classes" data-type="sect3"><div class="sect3" id="idm45176135667616">&#13;
<h3>Mutability pseudo-classes</h3>&#13;
&#13;
<p>The <a data-primary=":read-only pseudo-class" data-primary-sortas="read-only pseudo-class" data-type="indexterm" id="idm45176135696080"/><a data-primary=":read-write pseudo-class" data-primary-sortas="read-write pseudo-class" data-type="indexterm" id="idm45176135695104"/><a data-primary="mutability pseudo-classes" data-type="indexterm" id="idm45176135694192"/>mutability pseudo-classes include <code>:read-write</code>, which refers to a user input that is editable by the user; and <code>:read-only</code>, which matches user inputs that are not editable, including radio buttons and checkboxes. Only elements that can have their values altered by user input can match <code>:read-write</code>.</p>&#13;
&#13;
<p>For example, in HTML, a nondisabled, non-read-only <code>input</code> element is <code>:read-write</code>, as is any element with the <code>contenteditable</code> attribute. Everything else matches <code>:read-only</code>.</p>&#13;
&#13;
<p>By default, neither of the following rules would ever match, because <code>&lt;textarea&gt;</code> elements are read-write, and <code>&lt;pre&gt;</code> elements are read-only:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">textarea</code><code class="nd">:read-only</code> <code class="p">{</code><code class="k">opacity</code><code class="o">:</code> <code class="m">0</code><code class="o">.</code><code class="m">75</code><code class="p">;}</code>&#13;
<code class="nt">pre</code><code class="nd">:read-write:hover</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">dashed</code> <code class="nb">green</code><code class="p">;}</code></pre>&#13;
&#13;
<p>However, each can be made to match as follows:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;textarea</code><code class="w"> </code><code class="err">disabled</code><code class="nt">&gt;&lt;/textarea&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;pre</code><code class="w"> </code><code class="err">contenteditable</code><code class="nt">&gt;</code>Type<code class="w"> </code>your<code class="w"> </code>own<code class="w"> </code>code!<code class="nt">&lt;/pre&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Because <code>&lt;textarea&gt;</code> is given a <code>disabled</code> attribute, it becomes read-only, and so will have the first rule apply.  Similarly, the <code>&lt;pre&gt;</code> here has been made editable via the <code>contenteditable</code> attribute, so now it is a read-write element.  This will be matched by the second rule.<a data-primary="" data-startref="ix_pseudo_class_uistate" data-type="indexterm" id="idm45176135633760"/><a data-primary="" data-startref="ix_uistate_pseudo_class" data-type="indexterm" id="idm45176135632784"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The :lang() and :dir() Pseudo-Classes" data-type="sect2"><div class="sect2" id="the_colon_lang_pseudo-class">&#13;
<h2>The :lang() and :dir() Pseudo-Classes</h2>&#13;
&#13;
<p>When you want to <a data-primary=":lang() pseudo-class" data-primary-sortas="lang() pseudo-class" data-type="indexterm" id="idm45176135598800"/>select an element based on its language, you can use the <code>:lang()</code> pseudo-class. In terms of its matching patterns, this pseudo-class is similar to the <code>|=</code> attribute selector (see <a data-type="xref" href="ch02.html#selection_based_on_partial_attribute_val">“Selection Based on Partial Attribute Values”</a>). For example, to italicize elements whose content is written in French, you could write either of the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nd">:lang</code><code class="o">(</code><code class="nt">fr</code><code class="o">)</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="o">*[</code><code class="nt">lang</code><code class="o">|=</code><code class="s2">"fr"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The <a data-primary="lang attribute, HTML" data-type="indexterm" id="idm45176135572208"/>primary difference between the pseudo-class selector and the attribute selector is that language information can be derived from multiple sources, some of which are outside the element itself. For the attribute selector, the element must have the attribute present to match. The <code>:lang()</code> pseudo-class, on the other hand, matches descendants of an element with the language declaration. As <a href="https://www.w3.org/TR/selectors-3/#lang-pseudo">Selectors Level 3</a> states:</p>&#13;
<blockquote>&#13;
<p>In HTML, the language is determined by a combination of the <code>lang</code> attribute, and possibly information from the <code>meta</code> elements and the protocol (such as HTTP headers). XML uses an attribute called <code>xml:lang</code>, and there may be other document language-specific methods for determining the language.</p></blockquote>&#13;
&#13;
<p>The pseudo-class will operate on all of that information, whereas the attribute selector can work only if a <code>lang</code> attribute is present in the element’s markup. Therefore, the pseudo-class is more robust than the attribute selector and is probably a better choice in most cases where language-specific styling is needed.</p>&#13;
&#13;
<p>CSS <a data-primary=":dir() pseudo-class" data-primary-sortas="dir() pseudo-class" data-type="indexterm" id="idm45176135561632"/>also has a <code>:dir()</code> pseudo-class, which selects elements based on the HTML direction of an element.  So you could, for example, select all the elements whose direction is right to left like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nd">:dir</code><code class="o">(</code><code class="nt">rtl</code><code class="o">)</code> <code class="p">{</code><code class="k">border-right</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The <a data-primary="direction property" data-type="indexterm" id="idm45176135532816"/>thing to watch out for here is that the <code>:dir()</code> pseudo-class selects elements based on their directionality in HTML, and not the value of the <code>direction</code> property in CSS that may be applied to them.  Thus, the only two values you can really use for selection are <code>ltr</code> (left to right) and <code>rtl</code> (right to left) because those are the only direction values that HTML supports.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Logical Pseudo-Classes" data-type="sect2"><div class="sect2" id="logical_pseudo-classes">&#13;
<h2>Logical Pseudo-Classes</h2>&#13;
&#13;
<p>Beyond <a data-primary="pseudo-class selectors" data-secondary="logical pseudo-classes" data-type="indexterm" id="ix_pseudo_class_logical"/><a data-primary="logical pseudo-classes" data-type="indexterm" id="ix_log_pseudo_class"/>structure and language, some pseudo-classes are intended to bring a touch of logic and flexibility to CSS selectors.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The negation pseudo-class" data-type="sect3"><div class="sect3" id="the_negation_pseudo-class">&#13;
<h3>The negation pseudo-class</h3>&#13;
&#13;
<p>Every <a data-primary="negation pseudo-class" data-type="indexterm" id="ix_neg_pseudo"/>selector we’ve covered thus far has had one thing in common: they’re all positive selectors. They are used to identify the things that should be selected, thus excluding by implication all the things that don’t match and are thus not selected.</p>&#13;
&#13;
<p>For <a data-primary=":not() pseudo-class" data-primary-sortas="not() pseudo-class" data-type="indexterm" id="ix_not_pseudo"/>those times when you want to invert this formulation and select elements based on what they are <em>not</em>, CSS provides the negation pseudo-class, <code>:not()</code>. It’s not quite like any other selector, fittingly enough, and it does have some restrictions on its use, but let’s start with an example.</p>&#13;
&#13;
<p>Let us suppose you want to apply a style to every list item that does not have a <code>class</code> of <code>moreinfo</code>, as illustrated in <a data-type="xref" href="#styling_list_items_that_donat_have_a_cer">Figure 3-22</a>. That used to be very difficult, and in certain cases impossible, to make happen. Now we can declare the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code><code class="nd">:not</code><code class="o">(</code><code class="nc">.moreinfo</code><code class="o">)</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_list_items_that_donat_have_a_cer">&#13;
<img alt="css5 0322" src="assets/css5_0322.png"/>&#13;
<h6><span class="label">Figure 3-22. </span>Styling list items that don’t have a certain class</h6>&#13;
</div></figure>&#13;
&#13;
<p>The way <code>:not()</code> works is that you attach it to a selector, and then in the parentheses you fill in a selector or group of selectors describing what the original selector cannot match.</p>&#13;
&#13;
<p>Let’s flip around the previous example and select all elements with a class of <code>moreinfo</code> that are not list items. This is illustrated in <a data-type="xref" href="#styling_elements_with_a_certain_class_th">Figure 3-23</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.moreinfo</code><code class="nd">:not</code><code class="o">(</code><code class="nt">li</code><code class="o">)</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_elements_with_a_certain_class_th">&#13;
<img alt="css5 0323" src="assets/css5_0323.png"/>&#13;
<h6><span class="label">Figure 3-23. </span>Styling elements with a certain class that aren’t list items</h6>&#13;
</div></figure>&#13;
&#13;
<p>Translated into English, the selector would say, “Select all elements with a class whose value contains the word <code>moreinfo</code> as long as they are not <code>&lt;li&gt;</code> elements.” Similarly, the translation of <code>li:not(.moreinfo)</code> would be, “Select all <code>&lt;li&gt;</code> elements as long as they do not have a class whose value contains the word <code>moreinfo</code>.”</p>&#13;
&#13;
<p>You can also use the negation pseudo-class at any point in a more complex selector. Thus, to select all tables that are not children of a <code>&lt;section&gt;</code> element, you would write <code>*:not(section) &gt; table</code>. Similarly, to select table header cells that are not part of the table header, you’d write something like <code>table *:not(thead) &gt; tr &gt; th</code>, with a result like that shown in <a data-type="xref" href="#styling_table_cells_that_arenat_in_the_t">Figure 3-24</a>.</p>&#13;
&#13;
<figure><div class="figure" id="styling_table_cells_that_arenat_in_the_t">&#13;
<img alt="css5 0324" src="assets/css5_0324.png"/>&#13;
<h6><span class="label">Figure 3-24. </span>Styling header cells outside the table’s head area</h6>&#13;
</div></figure>&#13;
&#13;
<p>What you cannot do is nest negation pseudo-classes; thus, <code>p:not(:not(p))</code> is not valid and will be ignored. It’s also, logically, the equivalent of just writing <code>p</code>, so there’s no point anyway. Furthermore, you cannot reference pseudo-elements (which we’ll cover shortly) inside the parentheses.</p>&#13;
&#13;
<p>Technically, you can put a <a data-primary="selectors" data-secondary="universal" data-type="indexterm" id="idm45176135427536"/><a data-primary="asterisk (*)" data-secondary="universal selector" data-type="indexterm" id="idm45176135426560"/><a data-primary="* (asterisk)" data-secondary="universal selector" data-type="indexterm" id="idm45176135425616"/>universal selector into the parentheses, but there’s little point. After all, <code>p:not(*)</code> would mean “select any <code>&lt;p&gt;</code> element as long as it isn’t any element,” and there’s no such thing as an element that is not an element. Similarly, <code>p:not(p)</code> would also select nothing. It’s also possible to write things like <code>p:not(div)</code>, which will select any <code>&lt;p&gt;</code> element that is not a <code>&lt;div&gt;</code> element—in other words, all of them. Again, there is little reason to do this.</p>&#13;
&#13;
<p>On the other hand, it’s possible to chain negations together to create a sort of “and also not this” effect. For example, you might want to select all elements with a class of <code>link</code> that are neither list items nor paragraphs:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nc">.link</code><code class="nd">:not</code><code class="o">(</code><code class="nt">li</code><code class="o">)</code><code class="nd">:not</code><code class="o">(</code><code class="nt">p</code><code class="o">)</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That translates to “select all elements with a class whose value contains the word <code>link</code> as long as they are neither <code>&lt;li&gt;</code> nor <code>&lt;p&gt;</code> elements.”  This used to be the only way to exclude a group of elements, but CSS (and browsers) support selector lists in negations.  That allows us to rewrite the previous example like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nc">.link</code><code class="nd">:not</code><code class="o">(</code><code class="nt">li</code><code class="o">,</code> <code class="nt">p</code><code class="o">)</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Along with this came the ability to use more complex selectors, such as those using descendant combinators.  If you need to select all elements that are descended from a <code>&lt;form&gt;</code> element but do not immediately follow a <code>&lt;p&gt;</code> element, you could write it as &#13;
<span class="keep-together">follows:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">form</code> <code class="o">*:</code><code class="n">not</code><code class="p">(</code><code class="n">p</code> <code class="o">+</code> <code class="o">*</code><code class="p">)</code></pre>&#13;
&#13;
<p>Translated, that’s “select any element that is not the adjacent sibling <code>&lt;p&gt;</code> element, and is also the descendant of a <code>&lt;form&gt;</code> element.”  And you can put these into groups, so if you also want to exclude list items and table-header cells, it would go something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">form</code> <code class="o">*:</code><code class="n">not</code><code class="p">(</code><code class="n">p</code> <code class="o">+</code> <code class="o">*,</code> <code class="n">li</code><code class="o">,</code> <code class="n">thead</code> <code class="o">&gt;</code> <code class="n">tr</code> <code class="o">&gt;</code> <code class="n">th</code><code class="p">)</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The ability to use complex selectors in <code>:not()</code> came to browsers in only early 2021, so exercise caution when using it, especially in &#13;
<span class="keep-together">legacy settings.</span></p>&#13;
</div>&#13;
&#13;
<p>One thing to watch out for with <code>:not()</code> is that in some situations rules can combine in unexpected ways, mostly because we’re not used to thinking of selection in the negative. Consider this test case:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nd">:not</code><code class="o">(</code><code class="nc">.one</code><code class="o">)</code> <code class="nt">p</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="n">normal</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.one</code> <code class="nt">p</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"one"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"two"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;p&gt;</code>I'm<code class="w"> </code>a<code class="w"> </code>paragraph!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The paragraph will be boldfaced, not normal weight. This is because both rules match: the <code>&lt;p&gt;</code> element is descended from a <code>&lt;div&gt;</code> whose class does not contain the word <code>one</code> (<code>&lt;div class="two"&gt;</code>), but it is <em>also</em> descended from a <code>&lt;div&gt;</code> whose class contains the word <code>one</code>. Both rules match, so both apply. Since a conflict exists, the cascade (which is explained in <a data-type="xref" href="ch04.html#specificity_comma_inheritance">Chapter 4</a>) is used to resolve the conflict, and the second rule wins. The structural arrangement of the markup, with the <code>div.two</code> being “closer” to the paragraph than <code>div.one</code>, is irrelevant.<a data-primary="" data-startref="ix_neg_pseudo" data-type="indexterm" id="idm45176135166912"/><a data-primary="" data-startref="ix_not_pseudo" data-type="indexterm" id="idm45176135165904"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The :is() and :where() pseudo-classes" data-type="sect3"><div class="sect3" id="the_matches-any_pseudo-classes">&#13;
<h3>The :is() and :where() pseudo-classes</h3>&#13;
&#13;
<p>CSS has two <a data-primary=":where() pseudo-class" data-primary-sortas="where() pseudo-class" data-type="indexterm" id="ix_where_pseudo_class"/><a data-primary=":is() pseudo-class" data-primary-sortas="is() pseudo-class" data-type="indexterm" id="ix_is_pseudo_class"/>pseudo-classes that allow for group matching within a complex selector, <code>:is()</code> and <code>:where()</code>.  These are almost identical to each other, with just a minor difference that we’ll cover once you understand how they work.  Let’s start with <code>:is()</code>.</p>&#13;
&#13;
<p>Suppose you want to select all list items, whether or not they are part of an ordered or an unordered list.  The traditional way to do that is shown here:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ol</code> <code class="nt">li</code><code class="o">,</code> <code class="nt">ul</code> <code class="nt">li</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>With <code>:is()</code>, we can rewrite that like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:is</code><code class="o">(</code><code class="nt">ol</code><code class="o">,</code> <code class="nt">ul</code><code class="o">)</code> <code class="nt">li</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The matched elements will be exactly the same: all list items that are part of either ordered or unordered lists.</p>&#13;
&#13;
<p>This might seem slightly pointless: the syntax is not only slightly less clear, but also one character longer.  And it’s true that in simple situations like that, <code>:is()</code> isn’t terribly compelling.  The more complex the situation, though, the more likely <code>:is()</code> will really shine.</p>&#13;
&#13;
<p>For example, what if we want to style all list items that are at least two levels deep in nested lists, no matter what combination of ordered and unordered lists are above them?  Compare the following rules, both of which will have the effect shown in <a data-type="xref" href="#using_matches_any_to_select">Figure 3-25</a>, except one uses the traditional approach and the other uses <code>:is()</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ol</code> <code class="nt">ol</code> <code class="nt">li</code><code class="o">,</code> <code class="nt">ol</code> <code class="nt">ul</code> <code class="nt">li</code><code class="o">,</code> <code class="nt">ul</code> <code class="nt">ol</code> <code class="nt">li</code><code class="o">,</code> <code class="nt">ul</code> <code class="nt">ul</code> <code class="nt">li</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
&#13;
<code class="nd">:is</code><code class="o">(</code><code class="nt">ol</code><code class="o">,</code> <code class="nt">ul</code><code class="o">)</code> <code class="nd">:is</code><code class="o">(</code><code class="nt">ol</code><code class="o">,</code> <code class="nt">ul</code><code class="o">)</code> <code class="nt">li</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="using_matches_any_to_select">&#13;
<img alt="css5 0325" src="assets/css5_0325.png"/>&#13;
<h6><span class="label">Figure 3-25. </span>Using <code>:is()</code> to select elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now consider what the traditional approach would look like for three, four, or even more levels deep of nested lists!</p>&#13;
&#13;
<p>The <code>:is()</code> pseudo-class can be used in all sorts of situations; selecting all links inside lists that are themselves inside headers, footers, and <code>&lt;nav&gt;</code> elements could look like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:is</code><code class="o">(</code><code class="nt">header</code><code class="o">,</code><code class="nt">footer</code><code class="o">,</code><code class="nt">nav</code><code class="o">,</code><code class="nf">#header</code><code class="o">,</code><code class="nf">#footer</code><code class="o">)</code> <code class="nd">:is</code><code class="o">(</code><code class="nt">ol</code><code class="o">,</code><code class="nt">ul</code><code class="o">)</code> <code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">]</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Even better: the list of <a data-primary="forgiving selector list" data-type="indexterm" id="idm45176134988224"/>selectors inside <code>:is()</code> is what’s called a <em>forgiving selector list</em>.  By default, if any one thing in a selector is invalid, the whole rule is marked invalid.  Forgiving selector lists, on the other hand, will throw any part that’s invalid and honor the rest.</p>&#13;
&#13;
<p>So, given all that, what’s the difference between <code>:is()</code> and <code>:where()</code>?  The sole difference is that <code>:is()</code> takes the specificity of the most-specific selector in its selector list, whereas <code>:where()</code> has zero specificity.  If that last sentence didn’t make sense to you, don’t worry!  We haven’t discussed specificity yet but will in the next chapter.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><code>:is()</code> and <code>:where()</code> came to browsers in only early 2021, so exercise caution when using them, especially in legacy settings.<a data-primary="" data-startref="ix_is_pseudo_class" data-type="indexterm" id="idm45176134981712"/><a data-primary="" data-startref="ix_where_pseudo_class" data-type="indexterm" id="idm45176134980736"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting defined elements" data-type="sect3"><div class="sect3" id="selecting_defined_elements">&#13;
<h3>Selecting defined elements</h3>&#13;
&#13;
<p>As the web has advanced, it’s added more and more capabilities.  One of the more recent is the ability to add custom HTML elements to your markup in a standardized way.  This happens a lot with pattern libraries, which often define Web Components based on elements that are specific to the library.</p>&#13;
&#13;
<p>One thing such libraries do to be more efficient is hold off on defining an element until it’s needed, or it’s ready to be populated with whatever content is supposed to go into it.  Such a custom element might look like this in markup:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;mylib-combobox&gt;</code>options<code class="w"> </code>go<code class="w"> </code>here<code class="nt">&lt;/mylib-combobox&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The actual goal is to fill that combobox (a drop-down list that also allows users to enter arbitrary values) with whatever options the backend CMS provides for it, downloaded via a script that requests the latest data in order to build the list locally, and removing the placeholder text in the process.  However, what happens if the server fails to respond, leaving the custom element undefined and stuck with its placeholder text?  Without taking steps, the text “options go here” will get inserted into the page, probably with minimal styling.</p>&#13;
&#13;
<p>That’s <a data-primary=":defined pseudo-class" data-primary-sortas="defined pseudo-class" data-type="indexterm" id="idm45176134973264"/><a data-primary=":not() pseudo-class" data-primary-sortas="not() pseudo-class" data-type="indexterm" id="idm45176134972384"/>where <code>:defined</code> comes in.  You can use it to select any defined element, and combine it with <code>:not()</code> to select elements that aren’t yet defined.  Here’s a simple way to hide undefined comboboxes, as well as to apply styles to defined comboboxes:<a data-primary="" data-startref="ix_log_pseudo_class" data-type="indexterm" id="idm45176134970480"/><a data-primary="" data-startref="ix_pseudo_class_logical" data-type="indexterm" id="idm45176134941088"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">mylib-combobox</code><code class="nd">:not</code><code class="o">(</code><code class="nd">:defined</code><code class="o">)</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code>&#13;
<code class="nt">mylib-combobox</code><code class="nd">:defined</code> <code class="p">{</code><code class="k">display</code><code class="o">:</code> <code class="nb">inline-block</code><code class="p">;}</code>&#13;
<code class="nt">mylib-combobox</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="nb">inherit</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code>&#13;
   <code class="k">outline</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The :has() Pseudo-Class" data-type="sect2"><div class="sect2" id="the_has_pseudo_class">&#13;
<h2>The :has() Pseudo-Class</h2>&#13;
&#13;
<p>The <code>:has()</code> <a data-primary=":has() pseudo-class" data-primary-sortas="has() pseudo-class" data-type="indexterm" id="ix_has_pseudo_class"/>pseudo-class is a little bit tricky, because it doesn’t quite follow all the rules we’ve been working under until now—but as a result, it’s also <em>insanely</em> powerful.</p>&#13;
&#13;
<p>Imagine you want to apply special styles to any <code>&lt;div&gt;</code> element that contains an image. In other words, if a <code>&lt;div&gt;</code> element <em>has</em> an <code>&lt;img&gt;</code> element inside it, you want to apply certain styles to the <code>&lt;div&gt;</code>.  And that’s exactly what <code>:has()</code> makes possible.</p>&#13;
&#13;
<p>The previous example would be written something like this, with the result illustrated in <a data-type="xref" href="#using_has_to_select_elements">Figure 3-26</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nd">:has</code><code class="o">(</code><code class="nt">img</code><code class="o">)</code> <code class="p">{</code>&#13;
	<code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">double</code> <code class="nb">gray</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"masthead.jpg"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;p&gt;</code>No<code class="w"> </code>image<code class="w"> </code>here!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;p&gt;</code>This<code class="w"> </code>has<code class="w"> </code>text<code class="w"> </code>and<code class="w"> </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"redbox.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"an image"</code><code class="nt">&gt;</code>.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="using_has_to_select_elements">&#13;
<img alt="css5 0326" src="assets/css5_0326.png"/>&#13;
<h6><span class="label">Figure 3-26. </span>Using <code>:has()</code> to select elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>The second <code>&lt;div&gt;</code>, which does not have an <code>&lt;img&gt;</code> element as a descendant, doesn’t get the border.  If you wanted only the first <code>&lt;div&gt;</code> to get the border, because you actually wanted to style only <code>&lt;div&gt;</code> elements that have images as direct children, just modify the selector to use the child combinator, like this: <code>div:has(&gt; img)</code>.  That would prevent the third <code>&lt;div&gt;</code> from getting the border.</p>&#13;
&#13;
<p>The <code>:has()</code> pseudo-class is, in one real sense, the mythical “parent selector” CSS authors have wished for since the beginning of CSS itself.  Except it isn’t just for parent selection, because you can select based on siblings, or make the selection happen as far up the ancestry chain as you like.  And if all that didn’t quite make sense to you, hang on: we’ll explain further.</p>&#13;
&#13;
<p>We have two facts to note right off the bat:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Inside the parentheses of <code>:has()</code>, you can provide a comma-separated list of selectors, and each of those selectors can be simple, compound, or complex.</p>&#13;
</li>&#13;
<li>&#13;
<p>Those selectors are considered relative to the anchor element, the element to which <code>:has()</code> is attached.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s take those in order.  All of the following are valid <code>:has()</code> uses:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">table</code><code class="nd">:has</code><code class="o">(</code><code class="nt">tbody</code> <code class="nt">th</code><code class="o">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code>&#13;
<code class="c">/* tables whose body contains table headers */</code>&#13;
&#13;
<code class="nt">a</code><code class="nd">:any-link:has</code><code class="o">(</code><code class="nt">img</code><code class="nd">:only-child</code><code class="o">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code>&#13;
<code class="c">/* links containing only an image */</code>&#13;
&#13;
<code class="nt">header</code><code class="nd">:has</code><code class="o">(</code><code class="nt">nav</code><code class="o">,</code> <code class="nt">form</code><code class="nc">.search</code><code class="o">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code>&#13;
<code class="c">/* headers containing either nav or a form classed search */</code>&#13;
&#13;
<code class="nt">section</code><code class="nd">:has</code><code class="o">(+</code> <code class="nt">h2</code> <code class="nt">em</code><code class="o">,</code> <code class="nt">table</code> <code class="o">+</code> <code class="nt">table</code><code class="o">,</code> <code class="nt">ol</code> <code class="nt">ul</code> <code class="nt">ol</code> <code class="nt">ol</code><code class="o">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code>&#13;
<code class="c">/* sections immediately followed by an 'h2' that contains an 'em'</code>&#13;
<code class="c">   OR that contain a table immediately followed by another table</code>&#13;
<code class="c">   OR that contain an 'ol' inside an 'ol' inside a 'ul' inside an 'ol' */</code></pre>&#13;
&#13;
<p>That last example might be a bit overwhelming, so let’s break it down a bit further.  We could restate in a longer way, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">section</code><code class="nd">:has</code><code class="o">(+</code> <code class="nt">h2</code> <code class="nt">em</code><code class="o">),</code>&#13;
<code class="nt">section</code><code class="nd">:has</code><code class="o">(</code><code class="nt">table</code> <code class="o">+</code> <code class="nt">table</code><code class="o">),</code>&#13;
<code class="nt">section</code><code class="nd">:has</code><code class="o">(</code><code class="nt">ol</code> <code class="nt">ul</code> <code class="nt">ol</code> <code class="nt">ol</code><code class="o">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code></pre>&#13;
&#13;
<p>And here are two examples of the markup patterns that would be selected:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;section&gt;</code>(…section<code class="w"> </code>content…)<code class="nt">&lt;/section&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h2&gt;</code>I’m<code class="w"> </code>an<code class="w"> </code>h2<code class="w"> </code>with<code class="w"> </code>an<code class="w"> </code><code class="nt">&lt;em&gt;</code>emphasis<code class="w"> </code>element<code class="nt">&lt;/em&gt;</code><code class="w"> </code>inside,<code class="w"> </code>which<code class="w"> </code>means<code class="w"/>&#13;
<code class="w">    </code>the<code class="w"> </code>section<code class="w"> </code>right<code class="w"> </code>before<code class="w"> </code>me<code class="w"> </code>gets<code class="w"> </code>selected!<code class="nt">&lt;/h2&gt;</code><code class="w"/>&#13;
&#13;
<code class="nt">&lt;section&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h2&gt;</code>This<code class="w"> </code>h2<code class="w"> </code>doesn’t<code class="w"> </code>get<code class="w"> </code>the<code class="w"> </code>section<code class="w"> </code>selected,<code class="w"> </code>because<code class="w"> </code>it’s<code class="w"> </code>a<code class="w"> </code>child<code class="w"> </code>of<code class="w"/>&#13;
<code class="w">    </code>the<code class="w"> </code>section,<code class="w"> </code>not<code class="w"> </code>its<code class="w"> </code>immediately<code class="w"> </code>following<code class="w"> </code>sibling<code class="nt">&lt;/h2&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code>This<code class="w"> </code>paragraph<code class="w"> </code>is<code class="w"> </code>just<code class="w"> </code>here.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;aside&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h3&gt;</code>Q1<code class="w"> </code>Results<code class="nt">&lt;/h3&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;table&gt;</code>(…table<code class="w"> </code>contents…)<code class="nt">&lt;/table&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;table&gt;</code>(…table<code class="w"> </code>contents…)<code class="nt">&lt;/table&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/aside&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code>Those<code class="w"> </code>adjacent-sibling<code class="w"> </code>tables<code class="w"> </code>mean<code class="w"> </code>this<code class="w"> </code>paragraph’s<code class="w"> </code>parent<code class="w"> </code>section<code class="w"> </code>element<code class="w"/>&#13;
<code class="w">   </code>DOES<code class="w"> </code>get<code class="w"> </code>selected!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/section&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In the first example, the selection isn’t based on parentage or any other ancestry; instead, the <code>&lt;section&gt;</code> is selected because its immediate sibling (the <code>&lt;h2&gt;</code>) has an <code>&lt;em&gt;</code> element as one of its descendants.  In the second, the <code>&lt;section&gt;</code> is selected because it has a descendant <code>&lt;table&gt;</code> that’s immediately followed by another <code>&lt;table&gt;</code>, both of which happen in this case to be inside an <code>&lt;aside&gt;</code> element.  That makes this specific example one of grandparent selection, not parent selection, because the <code>&lt;section&gt;</code> is a grandparent to the tables.</p>&#13;
&#13;
<p>Right, so that’s the first point that we raised earlier.  The second is that the selectors inside the parentheses are relative to the element bearing the <code>:has()</code>.  That means, for example, that the following selector is never going to match anything:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">div</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">html</code> <code class="n">body</code> <code class="n">h1</code><code class="p">)</code></pre>&#13;
&#13;
<p>That’s because while an <code>&lt;h1&gt;</code> can certainly be a descendant of a <code>&lt;div&gt;</code>, the <code>&lt;html&gt;</code> and <code>&lt;body&gt;</code> elements cannot.  What that selector means, translated into English, is “select any <code>&lt;div&gt;</code> that has a descendant <code>&lt;html&gt;</code> which itself has a descendant <code>&lt;body&gt;</code> which has a descendant <code>&lt;h1&gt;</code>.”  The <code>&lt;html&gt;</code> element will never be a descendant of <code>&lt;div&gt;</code>, so this selector can’t match.</p>&#13;
&#13;
<p>To pick something a little more realistic, here’s a bit of markup showing lists nested inside one another, which has the document structure shown in <a data-type="xref" href="#a_fragment_of_a_doc">Figure 3-27</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"/>&#13;
<code class="w">		</code><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">		</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">		</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">		</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">		</code><code class="nt">&lt;/ol&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ol&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="a_fragment_of_a_doc">&#13;
<img alt="css5 0327" src="assets/css5_0327.png"/>&#13;
<h6><span class="label">Figure 3-27. </span>A fragment of a document’s structure</h6>&#13;
</div></figure>&#13;
&#13;
<p>To that structure, we’ll apply the following rules.  Spoiler alert: one of them will match an element, and the other will not:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code><code class="nd">:has</code><code class="o">(</code><code class="nt">li</code> <code class="nt">ol</code><code class="o">)</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">ul</code><code class="nd">:has</code><code class="o">(</code><code class="nt">ol</code> <code class="nt">ul</code> <code class="nt">ol</code><code class="o">)</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The first causes the browser to look at all the <code>&lt;ul&gt;</code> elements.  For any <code>&lt;ul&gt;</code> it finds, it looks at the structure of the elements that descend from that <code>&lt;ul&gt;</code>.  If it finds an <code>li ol</code> relationship in the elements that descend from the <code>&lt;ul&gt;</code>, then the <code>&lt;ul&gt;</code> is matched, and in this case will be given a red border.</p>&#13;
&#13;
<p>If we study the markup structure, either in the code or in <a data-type="xref" href="#a_fragment_of_a_doc">Figure 3-27</a>, we can see two <code>&lt;ul&gt;</code> elements.  The first has <code>&lt;li&gt;</code> descendants but not any <code>&lt;ol&gt;</code> descendants, so it won’t be matched.  The second <code>&lt;ul&gt;</code> also has <code>&lt;li&gt;</code> descendants, and one of them has an <code>&lt;ol&gt;</code> descendant.  It’s a match!  The <code>&lt;ul&gt;</code> will be given a red border.</p>&#13;
&#13;
<p>The second rule also causes the browser to look at all the <code>&lt;ul&gt;</code> elements.  In this case, for any <code>&lt;ul&gt;</code> it finds, the browser looks for an <code>ol ul ol</code> relationship within the descendants of the <code>&lt;ul&gt;</code>.  Elements outside the <code>&lt;ul&gt;</code> don’t count: only those within it are considered.  Of the two <code>&lt;ul&gt;</code> elements in the document, neither has an <code>&lt;ol&gt;</code> inside a <code>&lt;ul&gt;</code> that’s inside another <code>&lt;ol&gt;</code> that is itself descended from the <code>&lt;ul&gt;</code> being considered.  There’s no match, so neither of the <code>&lt;ul&gt;</code> elements will be italicized.</p>&#13;
&#13;
<p>Even more powerfully, you’re free to mix <code>:has()</code> with other pseudo-classes.  You might, for example, want to select any heading level if it has an image inside.  You can do this in two ways: the long, clumsy way or the compact way.  Both are shown here:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">h1</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">)</code><code class="o">,</code> <code class="n">h2</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">)</code><code class="o">,</code> <code class="n">h3</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">)</code><code class="o">,</code> <code class="n">h4</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">)</code><code class="o">,</code> <code class="n">h5</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">)</code><code class="o">,</code> <code class="n">h6</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">)</code>&#13;
&#13;
<code class="o">:</code><code class="n">is</code><code class="p">(</code><code class="n">h1</code><code class="o">,</code> <code class="n">h2</code><code class="o">,</code> <code class="n">h3</code><code class="o">,</code> <code class="n">h4</code><code class="o">,</code> <code class="n">h5</code><code class="o">,</code> <code class="n">h6</code><code class="p">)</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">)</code></pre>&#13;
&#13;
<p>The two selectors have the same outcome: if an element <em>is</em> one of the listed heading elements, and that element <em>has</em> among its descendant elements an <code>&lt;img&gt;</code> element, then the heading will be selected.</p>&#13;
&#13;
<p>For that matter, you could select any headings that <em>don’t</em> have images inside:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">:</code><code class="n">is</code><code class="p">(</code><code class="n">h1</code><code class="o">,</code> <code class="n">h2</code><code class="o">,</code> <code class="n">h3</code><code class="o">,</code> <code class="n">h4</code><code class="o">,</code> <code class="n">h5</code><code class="o">,</code> <code class="n">h6</code><code class="p">)</code><code class="o">:</code><code class="n">not</code><code class="p">(</code><code class="o">:</code><code class="n">has</code><code class="p">(</code><code class="n">img</code><code class="p">))</code></pre>&#13;
&#13;
<p>Here, if an element <em>is</em> one of the listed heading levels, but an <code>&lt;img&gt;</code> element is <em>not</em> one of the descendants it has, then the heading will be selected.  If we bring them together and apply them to numerous headings, we get the results shown in <a data-type="xref" href="#to_has_and_has_not">Figure 3-28</a>.</p>&#13;
&#13;
<figure><div class="figure" id="to_has_and_has_not">&#13;
<img alt="css5 0328" src="assets/css5_0328.png"/>&#13;
<h6><span class="label">Figure 3-28. </span>To has and has not</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can already see, this selector has a lot of power.  Dangers also exist: it is entirely possible to write selectors that cause major performance hits to the browser, especially in settings where scripting may be used to modify the document structure.  Consider the &#13;
<span class="keep-together">following:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nd">:has</code><code class="o">(*</code><code class="nc">.popup</code><code class="o">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code></pre>&#13;
&#13;
<p>This is saying, “Apply these styles to any <code>&lt;div&gt;</code> that has an element with a class of <code>popup</code> as a descendant.”  When the page is loaded into the browser, it has to check all the <code>&lt;div&gt;</code> elements to see if they match this selector.  That could mean a few trips up and down the document’s structural tree, but ideally it would resolve in a few milliseconds, and the page can then be displayed.</p>&#13;
&#13;
<p>But suppose we have a script that can add <code>.popup</code> to an element, or even several elements, on the page.  As soon as the class values change, the browser has to check not only whether any styles apply to <code>.popup</code> elements and their descendants, but also whether any ancestor or sibling elements are affected by this change.  Instead of looking only down the document tree, the browser now has to look up as well.  And any change triggered by this could mean changes all throughout the page’s layout, both when an element is marked as <code>.popup</code> and whenever a <code>.popup</code> element loses that class value, potentially affecting elements in entirely different parts of the document.</p>&#13;
&#13;
<p>This sort of performance hit is why there hasn’t been a “parent selector” or anything like it before.  Computers are getting fast enough, and browser engines smart enough, that this is much less of a worry than it was in the past—but it’s still something to keep in mind and test out thoroughly.<a data-primary="" data-startref="ix_has_pseudo_class" data-type="indexterm" id="idm45176129311760"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It is not possible to <a data-primary="pseudo-element selectors" data-secondary="nesting issue with :has pseudo-class" data-type="indexterm" id="idm45176129309808"/>nest pseudo-elements like <code>::first-line</code> or <code>::selection</code> in <code>has()</code>.  (We’ll discuss pseudo-elements shortly.)</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Pseudo-Classes" data-type="sect2"><div class="sect2" id="idm45176134900064">&#13;
<h2>Other Pseudo-Classes</h2>&#13;
&#13;
<p>Even more pseudo-classes are defined in the CSS Selectors specification, but they are partially supported in browsers, or in some cases not supported at all as of early 2023, or else are things we’ll cover elswhere in the book.  We’re listing them in <a data-type="xref" href="#other_pseudo-classes">Table 3-5</a> for the sake of completeness, and to point you toward pseudo-classes that might be supported between this edition of the book and the next one.  (Or could be replaced with an equivalent pseudo-class with a different name; that happens sometimes.)</p>&#13;
<table id="other_pseudo-classes">&#13;
<caption><span class="label">Table 3-5. </span>Other pseudo-classes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Name</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>:nth-col()</code></p></td>&#13;
<td><p>Refers to table cells or grid items that are in an nth column, which is found using the <em>an</em> + <em>b</em> pattern;  essentially the same as <code>:nth-child()</code>, but refers specifically to table or grid columns</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:nth-last-col()</code></p></td>&#13;
<td><p>Refers to table cells or grid items that are in an nth-last column, which is found using the <em>an</em> + <em>b</em> pattern;  essentially the same as <code>:nth-last-child()</code>, but refers specifically to table or grid columns</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:left</code></p></td>&#13;
<td><p>Refers to any lefthand page in a printed document;  see <a data-type="xref" href="ch21.html#css-at-rules">Chapter 21</a> for more</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:right</code></p></td>&#13;
<td><p>Refers to any righthand page in a printed document;  see <a data-type="xref" href="ch21.html#css-at-rules">Chapter 21</a> for more</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:fullscreen</code></p></td>&#13;
<td><p>Refers to an element that is being displayed full-screen (e.g., a video that’s in full-screen mode)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:past</code></p></td>&#13;
<td><p>Refers to an element that appeared before (in time) an element being matched by <code>:current</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:current</code></p></td>&#13;
<td><p>Refers to an element, or the ancestor of an element, that is currently being displayed in a time-based format like a video (e.g., an element containing closed-caption text)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:future</code></p></td>&#13;
<td><p>Refers to an element that will appear after (in time) an element being matched by <code>:current</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:paused</code></p></td>&#13;
<td><p>Refers to any element that can have the states “playing” or “paused” (e.g., audio, video, etc.) when it is in the “paused” state</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:playing</code></p></td>&#13;
<td><p>Refers to any element that can have the states “playing” or “paused” (e.g., audio, video, etc.) when it is in the “playing” state</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>:picture-in-picture</code></p></td>&#13;
<td><p>Refers to an element that is used as a picture-in-picture display<a data-primary="" data-startref="ix_pseudo_class_ch3" data-type="indexterm" id="idm45176129258944"/></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pseudo-Element Selectors" data-type="sect1"><div class="sect1" id="pseudo-element_selectors">&#13;
<h1>Pseudo-Element Selectors</h1>&#13;
&#13;
<p>Much as <a data-primary="pseudo-element selectors" data-type="indexterm" id="ix_pseudo_elem"/><a data-primary="selectors" data-secondary="pseudo-element" data-type="indexterm" id="ix_selector_pseudo_elem"/>pseudo-classes assign phantom classes to anchors, <em>pseudo-elements</em> insert fictional elements into a document in order to achieve certain effects.</p>&#13;
&#13;
<p>Unlike the single <a data-primary=":: (colon, double), in pseudo-element selectors" data-type="indexterm" id="idm45176129252640"/><a data-primary="colon, double (::), in pseudo-element selectors" data-type="indexterm" id="idm45176129251808"/><a data-primary="CSS2 specification" data-secondary="pseudo-elements" data-type="indexterm" id="idm45176129251104"/>colon of pseudo-classes, pseudo-elements employ a double-colon syntax, like <code>::first-line</code>. This is meant to distinguish pseudo-elements from pseudo-classes. This was not always the case—in CSS2, both selector types used a single colon—so for backward compatibility, browsers may accept some single-colon pseudo-type selectors. Don’t take this as an excuse to be sloppy, though! Use the proper number of colons at all times to future-proof your CSS; after all, there is no way to predict when browsers will stop accepting single-colon pseudo-type selectors.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Styling the First Letter" data-type="sect2"><div class="sect2" id="styling_the_first_letter">&#13;
<h2>Styling the First Letter</h2>&#13;
&#13;
<p>The <code>::first-letter</code> <a data-primary="::first-letter pseudo-element" data-primary-sortas="first-letter pseudo-element" data-type="indexterm" id="idm45176129247088"/><a data-primary="pseudo-element selectors" data-secondary="::first-letter" data-secondary-sortas="first letter" data-type="indexterm" id="idm45176129246000"/>pseudo-element styles the first letter, or a leading punctuation character and the first letter (if the text starts with punctuation), of any non-inline element. This rule causes the first letter of every paragraph to be colored red:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">::first-letter</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The <code>::first-letter</code> pseudo-element is most commonly used to create an initial-cap or drop-cap typographic effect. You could make the first letter of each <code>&lt;p&gt;</code> twice as big as the rest of the heading, though you may want to apply this styling to only the first letter of the first paragraph:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">:first-of-type::first-letter</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">200%</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#the_colon_colon_first-letter_pseudo-elem">Figure 3-29</a> illustrates the result of this rule.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="the_colon_colon_first-letter_pseudo-elem">&#13;
<img alt="css5 0329" src="assets/css5_0329.png"/>&#13;
<h6><span class="label">Figure 3-29. </span>The <code>::first-letter</code> pseudo-element in action</h6>&#13;
</div></figure>&#13;
&#13;
<p>This rule effectively causes the user agent to style a fictional, or faux, element that encloses the first letter of each <code>&lt;p&gt;</code>. It would look something like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;&lt;p-first-letter&gt;</code>T<code class="nt">&lt;/p-first-letter&gt;</code>his<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>p<code class="w"> </code>element,<code class="w"> </code>with<code class="w"> </code>a<code class="w"> </code>styled<code class="w"> </code>first<code class="w"/>&#13;
<code class="w">    </code>letter<code class="nt">&lt;/h2&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>::first-letter</code> styles are applied only to the contents of the fictional element shown in the example. This <code>&lt;p-first-letter&gt;</code> element does <em>not</em> appear in the document source, nor even in the DOM tree. Instead, its existence is constructed on the fly by the user agent and is used to apply the <code>::first-letter</code> style(s) to the appropriate bit of text. In other words, <code>&lt;p-first-letter&gt;</code> is a pseudo-element. Remember, you don’t have to add any new tags. The user agent styles the first letter for you as if you had encased it in a &#13;
<span class="keep-together">styled element.</span></p>&#13;
&#13;
<p>The first letter is defined as the first typographic letter unit of the originating element, if it is not preceded by other content, like an image. The specifications use the term letter unit because some languages have letters made up of more than one character, like <em>œ</em> in Old West Norse. Punctuation that precedes or follows the first letter unit, even if there are several such symbols, should be included in the <code>::first-letter</code> pseudo-element.  The browser does this for you.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Styling the First Line" data-type="sect2"><div class="sect2" id="styling_the_first_line">&#13;
<h2>Styling the First Line</h2>&#13;
&#13;
<p>Similarly, <code>::first-line</code> <a data-primary="pseudo-element selectors" data-secondary="::first-line" data-secondary-sortas="first line" data-type="indexterm" id="ix_pseudo_elem_first_line"/><a data-primary="::first-line pseudo-element" data-primary-sortas="first-line pseudo-element" data-type="indexterm" id="ix_first_line_pseudo"/>can be used to affect the first line of text in an element. For example, you could make the first line of each paragraph in a document large and purple:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nd">::first-line</code> <code class="p">{</code>&#13;
  <code class="k">font-size</code><code class="o">:</code> <code class="m">150%</code><code class="p">;</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In <a data-type="xref" href="#the_colon_colon_first-line_pseudo-elemen">Figure 3-30</a>, the style is applied to the first displayed line of text in each paragraph. This is true no matter how wide or narrow the display region is. If the first line contains only the first five words of the paragraph, only those five words will be big and purple. If the first line contains the first 30 words of the element, all 30 will be big and purple.</p>&#13;
&#13;
<figure><div class="figure" id="the_colon_colon_first-line_pseudo-elemen">&#13;
<img alt="css5 0330" src="assets/css5_0330.png"/>&#13;
<h6><span class="label">Figure 3-30. </span>The <code>::first-line</code> pseudo-element in action</h6>&#13;
</div></figure>&#13;
&#13;
<p>Because the text from “This” to “only” should be big and purple, the user agent employs a fictional markup that looks something like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p-first-line&gt;</code>This<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>paragraph<code class="w"> </code>of<code class="w"> </code>text<code class="w"> </code>that<code class="w"> </code>has<code class="w"> </code>only<code class="nt">&lt;/p-first-line&gt;</code><code class="w"/>&#13;
one<code class="w"> </code>stylesheet<code class="w"> </code>applied<code class="w"> </code>to<code class="w"> </code>it.<code class="w"> </code>That<code class="w"> </code>style<code class="w"> </code>causes<code class="w"> </code>the<code class="w"> </code>first<code class="w"> </code>line<code class="w"> </code>to<code class="w"/>&#13;
be<code class="w"> </code>big<code class="w"> </code>and<code class="w"> </code>purple.<code class="w"> </code>No<code class="w"> </code>other<code class="w"> </code>line<code class="w"> </code>will<code class="w"> </code>have<code class="w"> </code>those<code class="w"> </code>styles<code class="w"> </code>applied.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If the first line of text were edited to include only the first seven words of the paragraph, the fictional <code>&lt;/p-first-line&gt;</code> would move back and occur just after the word “that.” If the user were to increase or decrease the font-size rendering, or expand or contract the browser window causing the width of the text to change, thereby causing the number of words on the first line to increase or decrease, the browser automatically sets only the words in the currently displayed first line to be both big and purple.</p>&#13;
&#13;
<p>The length of the first line depends on multiple factors, including the font size, letter spacing, and width of the parent container. Depending on the markup and the length of that first line, the end of the first line could come in the middle of a nested element. If the <code>::first-line</code> breaks up a nested element, such as an <code>em</code> or a hyperlink, the properties attached to the <code>::first-line</code> will apply to only the portion of that nested element that is displayed on the first line.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Restrictions on ::first-letter and ::first-line" data-type="sect2"><div class="sect2" id="restrictions_on_colon_colon_first-letter">&#13;
<h2>Restrictions on ::first-letter and ::first-line</h2>&#13;
&#13;
<p>The <code>::first-letter</code> and <code>::first-line</code> <a data-primary="::first-letter pseudo-element" data-primary-sortas="first-letter pseudo-element" data-type="indexterm" id="idm45176129040112"/><a data-primary="pseudo-element selectors" data-secondary="::first-letter" data-secondary-sortas="first-letter" data-type="indexterm" id="idm45176129039168"/>pseudo-elements currently can be applied only to block-display elements such as headings or paragraphs, and not to inline-display elements such as hyperlinks. There are also limits on the CSS properties that may be applied to <code>::first-line</code> and <code>::first-letter</code>. <a data-type="xref" href="#properties_permitted_on_pseudo-elements">Table 3-6</a> gives an idea of these limitations. Like all pseudo-elements, neither can be included in <code>:has()</code> or <code>:not()</code>.</p>&#13;
<table id="properties_permitted_on_pseudo-elements">&#13;
<caption><span class="label">Table 3-6. </span>Properties permitted on pseudo-elements</caption>&#13;
<thead>&#13;
<tr>&#13;
<th><code>::first-letter</code></th>&#13;
<th><code>::first-line</code></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><ul>&#13;
<li>All font properties</li>&#13;
<li>All background properties</li>&#13;
<li>All text decoration properties</li>&#13;
<li>All inline typesetting properties</li>&#13;
<li>All inline layout properties</li>&#13;
<li>All border properties</li>&#13;
<li><code>box-shadow</code></li>&#13;
<li><code>color</code></li>&#13;
<li><code>opacity</code></li>&#13;
</ul></td>&#13;
&#13;
<td><ul>&#13;
<li>All font properties</li>&#13;
<li>All background properties</li>&#13;
<li>All margin properties</li>&#13;
<li>All padding properties</li>&#13;
<li>All border properties</li>&#13;
<li>All text decoration properties</li>&#13;
<li>All inline typesetting properties</li>&#13;
<li><code>color</code></li>&#13;
<li><code>opacity</code></li>&#13;
</ul></td>&#13;
</tr>&#13;
&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Placeholder Text Pseudo-Element" data-type="sect2"><div class="sect2" id="the_placeholder_text_pseudo">&#13;
<h2>The Placeholder Text Pseudo-Element</h2>&#13;
&#13;
<p>As it happens, the <a data-primary="pseudo-element selectors" data-secondary="::placeholder pseudo-element" data-secondary-sortas="placeholder pseudo-element" data-type="indexterm" id="idm45176128995344"/><a data-primary="::placeholder pseudo-element" data-primary-sortas="placeholder pseudo-element" data-type="indexterm" id="idm45176128993968"/><a data-primary="form elements" data-secondary="placeholder text" data-type="indexterm" id="idm45176128992992"/>restrictions on what styles can be applied via <code>::first-line</code> are exactly the same as the restrictions on styles applied via <code>::placeholder</code>.  This pseudo-element matches any placeholder text placed into text inputs and textareas.  You could, for example, italicize text input placeholder text and turn textarea placeholder text a dusky blue like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="nd">::placeholder</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="nt">textarea</code><code class="nd">::placeholder</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">cornflowerblue</code><code class="p">;}</code></pre>&#13;
&#13;
<p>For both <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> elements, this text is defined by the <code>placeholder</code> attribute in HTML.  The markup will look something very much like this:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">input</code> <code class="na">type</code><code class="o">=</code><code class="s">"text"</code> <code class="na">placeholder</code><code class="o">=</code><code class="s">"(XXX) XXX-XXXX"</code> <code class="na">id</code><code class="o">=</code><code class="s">"phoneno"</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">textarea</code> <code class="na">placeholder</code><code class="o">=</code><code class="s">"Tell us what you think!"</code><code class="p">&gt;&lt;/</code><code class="nt">textarea</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>If text is prefilled using the <code>value</code> attribute on <code>&lt;input&gt;</code> elements, or by placing content inside the <code>&lt;textarea&gt;</code> element, that will override the value of any <code>placeholder</code> attribute, and the resulting text won’t be selected with the <code>::placeholder</code> pseudo-element.<a data-primary="" data-startref="ix_first_line_pseudo" data-type="indexterm" id="idm45176128900048"/><a data-primary="" data-startref="ix_pseudo_elem_first_line" data-type="indexterm" id="idm45176128925824"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Form Button Pseudo-Element" data-type="sect2"><div class="sect2" id="idm45176128924912">&#13;
<h2>The Form Button Pseudo-Element</h2>&#13;
&#13;
<p>Speaking of <a data-primary="pseudo-element selectors" data-secondary="::file-selector-button pseudo-element" data-secondary-sortas="file-selector-button" data-type="indexterm" id="idm45176128923184"/><a data-primary="form elements" data-secondary="::file-selector-button pseudo-element" data-secondary-sortas="file-selector-button" data-type="indexterm" id="idm45176128921968"/>form elements, it’s also possible to directly select the file-selector button—and <em>only</em> the file-selector button—in an <code>&lt;input&gt;</code> element that has a <code>type</code> of <code>file</code>.  This gives you a way to call attention to the button a user needs to click to open the file-selection dialog, even if no other part of the input can be directly styled.</p>&#13;
&#13;
<p>If you’ve never seen a file-selection input, it usually looks like this:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">label</code> <code class="na">for</code><code class="o">=</code><code class="s">"uploadField"</code><code class="p">&gt;</code>Select file from computer<code class="p">&lt;/</code><code class="nt">label</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">input</code> <code class="na">id</code><code class="o">=</code><code class="s">"uploadField"</code> <code class="na">type</code><code class="o">=</code><code class="s">"file"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>That second line gets replaced with a control whose appearance is dependent on the combination of operating system and browser, so it tends to look at least a little different (sometimes a lot different) from one user to the next.  <a data-type="xref" href="#styling_button_file_submission">Figure 3-31</a> shows one possible rendering of the input, with the button styled by the following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="nd">::file-selector-button</code> <code class="p">{</code>&#13;
   <code class="k">border</code><code class="o">:</code> <code class="nb">thick</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code>&#13;
   <code class="k">border-radius</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="styling_button_file_submission">&#13;
<img alt="css5 0331" src="assets/css5_0331.png"/>&#13;
<h6><span class="label">Figure 3-31. </span>Styling the button in a file-submission input</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generating Content Before and After Elements" data-type="sect2"><div class="sect2" id="styling_open_parenthesis_or_creating_clo">&#13;
<h2>Generating Content Before and After Elements</h2>&#13;
&#13;
<p>Let’s say you want to <a data-primary="::before pseudo-element" data-primary-sortas="before pseudo-element" data-type="indexterm" id="idm45176128860480"/><a data-primary="generated content" data-secondary="before and after elements" data-type="indexterm" id="idm45176128859504"/>preface every <code>&lt;h2&gt;</code> element with a pair of silver square brackets as a typographical effect:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code><code class="nd">::before</code> <code class="p">{</code><code class="k">content</code><code class="o">:</code> <code class="s2">"]]"</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>CSS lets you <a data-primary="::after pseudo-element" data-primary-sortas="after pseudo-element" data-type="indexterm" id="idm45176128803184"/>insert <em>generated content</em>, and then style it directly using the pseudo-elements <code>::before</code> and <code>::after</code>. <a data-type="xref" href="#inserting_content_before_an_element">Figure 3-32</a> illustrates an example.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="inserting_content_before_an_element">&#13;
<img alt="css5 0332" src="assets/css5_0332.png"/>&#13;
<h6><span class="label">Figure 3-32. </span>Inserting content before an element</h6>&#13;
</div></figure>&#13;
&#13;
<p>The pseudo-element is used to insert the generated content and to style it. To place content at the end of an element, right before the closing tag, use the pseudo-element <code>::after</code>. You could end your documents with an appropriate finish:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code><code class="nd">::after</code> <code class="p">{</code><code class="k">content</code><code class="o">:</code> <code class="s2">"The End."</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Conversely, if you want to insert some content at the beginning of an element, right after the opening tag, use <code>::before</code>.  Just remember that in either case, you have to use the &#13;
<span class="keep-together"><code>content</code></span> property in order to insert something to style.</p>&#13;
&#13;
<p>Generated content is its own subject, and the entire topic (including more detail on <code>::before</code>, <code>::after</code>, and <code>content</code>) is covered more thoroughly in <a data-type="xref" href="ch16.html#lists-and-generated-content">Chapter 16</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Highlight Pseudo-Elements" data-type="sect2"><div class="sect2" id="highlight_pseudo_elements">&#13;
<h2>Highlight Pseudo-Elements</h2>&#13;
&#13;
<p>A relatively new <a data-primary="pseudo-element selectors" data-secondary="highlight pseudo-elements" data-type="indexterm" id="ix_pseudo_elem_highlite"/><a data-primary="highlight pseudo-elements" data-type="indexterm" id="ix_highlite_pseudo"/>concept in CSS is the ability to style pieces of content that have been highlighted, either by user selection or by the user agent itself.  These are summarized in <a data-type="xref" href="#highlight_pseudo-elements">Table 3-7</a>.</p>&#13;
<table id="highlight_pseudo-elements">&#13;
<caption><span class="label">Table 3-7. </span>Highlight pseudo-elements</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Name</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>::selection</code></p></td>&#13;
<td><p>Refers<a data-primary="::selection pseudo-element" data-primary-sortas="selection pseudo-element" data-type="indexterm" id="idm45176128729328"/> to any part of a document that has been highlighted for user operation (e.g., text that has been drag-selected with a mouse)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>::target-text</code></p></td>&#13;
<td><p>Refers<a data-primary="::target-text pseudo-element" data-primary-sortas="target-text pseudo-element" data-type="indexterm" id="idm45176128726496"/> to the text of a document that has been targeted;  this is distinct from the <code>:target</code> pseudo-class, which refers to a targeted element as a whole, not a fragment of text</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>::spelling-error</code></p></td>&#13;
<td><p>Refers<a data-primary="::spelling-error pseudo-element" data-primary-sortas="spelling-error pseudo-element" data-type="indexterm" id="idm45176128723248"/> to the part of a document that has been marked by the user agent as a misspelling</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>::grammar-error</code></p></td>&#13;
<td><p>Refers<a data-primary="::grammar-error pseudo-element" data-primary-sortas="grammar-error pseudo-element" data-type="indexterm" id="idm45176128720416"/> to the part of a document that has been marked by the user agent as a grammar error</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Of the four pseudo-elements in <a data-type="xref" href="#highlight_pseudo-elements">Table 3-7</a>, only one, <code>::selection</code>, has any appreciable support as of early 2023.  So we’ll explore it and leave the others for a future edition.</p>&#13;
&#13;
<p>When someone uses a mouse pointer to click-hold-and-drag in order to highlight some text, that’s a selection.  Most browsers have default styles set for text selection.  Authors can apply a limited set of CSS properties to such selections, overriding the browser’s default styles, by styling the <code>::selection</code> pseudo-element.  Let’s say you want selected text to be white on a navy-blue background.  The CSS would look like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">::selection</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">navy</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The primary use cases for <code>::selection</code> are specifying a color scheme for selected text that doesn’t clash with the rest of the design, or defining different selection styles for different parts of a document.  For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">::selection</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">navy</code><code class="p">;}</code>&#13;
<code class="nt">form</code><code class="nd">::selection</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Be careful in styling selection highlights: users generally expect text they select to look a certain way, usually defined by settings in their operating system.  Thus, if you get too clever with selection styling, you could confuse users.  That said, if you know that selected text can be difficult to see because your design’s colors tend to obscure it, defining more obvious highlight styles is probably a good idea.</p>&#13;
&#13;
<p>Note that selected text can cross element boundaries, and that multiple selections can occur within a given document.  Imagine that a user selects text starting from the middle of one paragraph to the middle of the next.  In effect, each paragraph will get its own selection pseudo-element nested inside, and selection styling will be handled as appropriate for the context.  Given the following CSS and HTML, you’ll get a result like that shown in <a data-type="xref" href="#selection_styling">Figure 3-33</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.p1</code><code class="nd">::selection</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nc">.p2</code><code class="nd">::selection</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"p1"</code><code class="nt">&gt;</code>This<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>paragraph<code class="w"> </code>with<code class="w"> </code>some<code class="w"> </code>text<code class="w"> </code>that<code class="w"> </code>can<code class="w"> </code>be<code class="w"> </code>selected,<code class="w"/>&#13;
<code class="w">   </code>one<code class="w"> </code>of<code class="w"> </code>two.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"p2"</code><code class="nt">&gt;</code>This<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>paragraph<code class="w"> </code>with<code class="w"> </code>some<code class="w"> </code>text<code class="w"> </code>that<code class="w"> </code>can<code class="w"> </code>be<code class="w"> </code>selected,<code class="w"/>&#13;
<code class="w">   </code>two<code class="w"> </code>of<code class="w"> </code>two.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selection_styling">&#13;
<img alt="css5 0333" src="assets/css5_0333.png"/>&#13;
<h6><span class="label">Figure 3-33. </span>Selection styling</h6>&#13;
</div></figure>&#13;
&#13;
<p>This underscores a point made earlier: <em>be careful</em> with your selection styling.  It is all too easy to make text unreadable for some users, particularly if your selection styles interact badly with the user’s default selection styles.</p>&#13;
&#13;
<p>Furthermore, for user <a data-primary="privacy issue" data-secondary="::selection pseudo-element and" data-secondary-sortas="selection pseudo-element and" data-type="indexterm" id="idm45176128533808"/>privacy reasons, you can apply only a limited number of CSS properties to selections: <code>color</code>, <code>background-color</code>, <code>text-decoration</code> and related properties, <code>text-shadow</code>, and the <code>stroke</code> properties (in SVG).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of early 2023, selections do not have their styles inherited: selecting text containing some inline elements will apply the selection styling to the text outside the inline elements, but not within the inline elements.  It is not clear if this behavior is intended, but it is consistent across major browsers.</p>&#13;
</div>&#13;
&#13;
<p>Beyond <code>::selection</code>, there will likely be increasing support for <code>::target-text</code>.  <a data-primary="::target-text pseudo-element" data-primary-sortas="target-text pseudo-element" data-type="indexterm" id="idm45176128528000"/>As of early 2023, this is supported in only Chromium browsers, which introduced a feature that needs it.  With this feature, text can be added to the end of a URL as part of the fragment identifier for highlighting, in order to draw attention to one or more parts of the page.</p>&#13;
&#13;
<p>For example, a URL might look something like: <code>https://example.org/#:~:text=for%20use%20in%20illustrative%20examples</code>.  The part at the end says to the browser, “Once you’ve loaded the page, highlight any examples of this text.”  The text is encoded for use in URLs, which is why it’s filled with <code>%20</code> strings—they represent spaces.  The result will look something like <a data-type="xref" href="#target_text_styling">Figure 3-34</a>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="target_text_styling">&#13;
<img alt="css5 0334" src="assets/css5_0334.png"/>&#13;
<h6><span class="label">Figure 3-34. </span>Targeted text styling</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you wanted to suppress this content highlighting on your own pages, you might do something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">::target-text</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">inherit</code><code class="p">;</code> <code class="k">background-color</code><code class="o">:</code> <code class="nb">inherit</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As for <code>::spelling-error</code> and <code>::grammar-error</code>, these are meant to apply highlighting of some sort to any spelling or grammar errors within a document.  <a data-primary="::grammar-error pseudo-element" data-primary-sortas="grammar-error pseudo-element" data-type="indexterm" id="idm45176128491664"/><a data-primary="::spelling-error pseudo-element" data-primary-sortas="spelling-error pseudo-element" data-type="indexterm" id="idm45176128490784"/>You can see the utility for something like Google Docs or the editing fields of CMSs like WordPress or Craft.  For most other applications, though, they seem unlikely to be very popular.  Regardless, as of this writing, there is no browser support for either, and the Working Group is still hashing out the details of how they should work.<a data-primary="" data-startref="ix_highlite_pseudo" data-type="indexterm" id="idm45176128489776"/><a data-primary="" data-startref="ix_pseudo_elem_highlite" data-type="indexterm" id="idm45176128475344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Backdrop Pseudo-Element" data-type="sect2"><div class="sect2" id="the_background_pseudo_element">&#13;
<h2>The Backdrop Pseudo-Element</h2>&#13;
&#13;
<p>Suppose you have an <a data-primary="pseudo-element selectors" data-secondary="::backdrop" data-type="indexterm" id="idm45176128473008"/><a data-primary="::backdrop pseudo-element" data-primary-sortas="backdrop pseudo-element" data-type="indexterm" id="idm45176128472032"/>element that’s being presented full-screen, like a video.  Furthermore, suppose that element doesn’t neatly fill the screen all the way to the edges, perhaps because the aspect ratio of the element doesn’t match the aspect ratio of the screen.  What should be filled in for the parts of the screen that the element doesn’t cover?  And how would you select that non-element region with CSS?</p>&#13;
&#13;
<p>Enter the <code>::backdrop</code> pseudo-element.  This represents a box that’s the exact size of the full-screen viewport, and it is always drawn beneath a full-screen element.  So you might put a dark-gray backdrop behind any full-screen video like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">video</code><code class="nd">::backdrop</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="m">#111</code><code class="p">;}</code></pre>&#13;
&#13;
<p>CSS doesn’t restrict which styles can be applied to backdrops, but since they’re essentially empty boxes placed behind a full-screen element, most of the time you’ll probably be setting background colors or images.</p>&#13;
&#13;
<p>An important thing to remember is that backdrops do <em>not</em> participate in inheritance.  They can’t inherit styles from ancestor elements, nor do they pass any of their styles on to any children.  Whatever styles you apply to the backdrop will exist in their own little &#13;
<span class="keep-together">pocket universe.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Video-Cue Pseudo-Element" data-type="sect2"><div class="sect2" id="idm45176128438816">&#13;
<h2>The Video-Cue Pseudo-Element</h2>&#13;
&#13;
<p>On the subject of <a data-primary="pseudo-element selectors" data-secondary="::video-cue" data-secondary-sortas="video-cue" data-type="indexterm" id="ix_pseudo_elem_cue"/><a data-primary="::video-cue pseudo-element" data-primary-sortas="video-cue pseudo-element" data-type="indexterm" id="ix_video_cue"/><a data-primary="::cue pseudo-element" data-primary-sortas="cue pseudo-element" data-type="indexterm" id="ix_cue_pseudo"/>videos, videos often have Web Video Text Tracks (WebVTT) data containing the text captions enabling accessibility.  These captions are known as <em>cues</em> and can be styled with the <code>::cue</code> pseudo-element.</p>&#13;
&#13;
<p>Let’s say you have a video that’s mostly dark, with a few light segments.  You might style the cues to be a lightish-gray text on a translucent dark background, as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">::cue</code> <code class="p">{</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code>&#13;
  <code class="k">background</code><code class="o">:</code> <code class="n">rgba</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This will always apply to the currently visible cue.</p>&#13;
&#13;
<p>You can also select parts of individual cues by using a selector pattern inside parentheses.  This can be used to style specific elements defined in the WebVTT data, drawn from a small list allowed by the WebVTT specification.  For example, any italicized cue text could be selected as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">::cue</code><code class="o">(</code><code class="nt">i</code><code class="o">)</code> <code class="p">{</code><code class="err">…</code><code class="p">}</code></pre>&#13;
&#13;
<p>You could use structural pseudo-classes like <code>:nth-child</code>, but these will apply only within a given cue, not across cues.  You can’t select every other cue for styling, but you can select every other element within a given cue.  Assume the following WebVTT data:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">00:00:01.500 --&gt; 00:00:02.999&#13;
&lt;v Hildy&gt;Tell me, is the lord of the universe in?&lt;/v&gt;&#13;
&#13;
00:00:03.000 --&gt; 00:00:04.299&#13;
- Yes, he's in.&#13;
- In a bad humor.</pre>&#13;
&#13;
<p>The second cue includes two lines of text.  These are treated as separate elements, in effect, even though no elements are specified.  Thus, we could make the line Hildy says (indicated with <code>&lt;v Hildy&gt;</code>, which is the WebVTT equivalent of <code>&lt;v voice="Hildy"&gt;</code>) boldface, and give alternate colors to the two lines of dialog in the second cue, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">::cue</code><code class="o">(</code><code class="nt">v</code><code class="o">[</code><code class="nt">voice</code><code class="o">=</code><code class="s2">"Hildy"</code><code class="o">])</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nd">::cue</code><code class="o">(</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">odd</code><code class="o">))</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code>&#13;
<code class="nd">::cue</code><code class="o">(</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">even</code><code class="o">))</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As of early 2023, a limited range of properties can be applied to cues:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>background</code> and its associated longhand properties (e.g., <code>background-color</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>text-decoration</code> and its associated longhand properties (e.g., <code>text-decoration-thickness</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>text-shadow</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>text-combine-upright</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>font</code> and its associated longhand properties (e.g., <code>font-weight</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>ruby-position</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>opacity</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>visibility</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>white-space</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>outline</code> and its associated longhand properties (e.g., <code>outline-width</code>)<a data-primary="" data-startref="ix_pseudo_elem" data-type="indexterm" id="idm45176128246512"/><a data-primary="" data-startref="ix_selector_pseudo_elem" data-type="indexterm" id="idm45176128245504"/><a data-primary="" data-startref="ix_cue_pseudo" data-type="indexterm" id="idm45176128244560"/><a data-primary="" data-startref="ix_pseudo_elem_cue" data-type="indexterm" id="idm45176128243616"/><a data-primary="" data-startref="ix_video_cue" data-type="indexterm" id="idm45176128242672"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shadow Pseudo-Classes and -Elements" data-type="sect1"><div class="sect1" id="shadow_pseudos">&#13;
<h1>Shadow Pseudo-Classes and -Elements</h1>&#13;
&#13;
<p>Another recent <a data-primary="Document Object Model (DOM)" data-secondary="shadow DOM" data-type="indexterm" id="ix_doc_obj_shadow_dom"/>innovation in HTML has been the introduction of the shadow DOM, which is a deep and complex subject we don’t have the space to explore here.  At a basic level, the <em>shadow DOM</em> allows developers to create encapsulated markup, style, and scripting within the regular (or <em>light</em>) DOM.  This keeps the styles and scripts of one shadow DOM from affecting any other part of the document, whether those parts are in the light or shadow DOM.</p>&#13;
&#13;
<p>We’re bringing this up here because CSS does provide ways to hook into shadow DOMs, as well as to reach up from within a shadow DOM to select the piece of the light DOM that hosts the shadow.  (This all sounds very panel-van artistic, doesn’t it?)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shadow Pseudo-Classes" data-type="sect2"><div class="sect2" id="shadow_pseudo-classes">&#13;
<h2>Shadow Pseudo-Classes</h2>&#13;
&#13;
<p>To <a data-primary="pseudo-class selectors" data-secondary="shadow pseudo-classes" data-type="indexterm" id="idm45176128235504"/><a data-primary="shadow pseudo-classes" data-type="indexterm" id="idm45176128234496"/>see what this means, let’s bring back the combobox example from earlier in the chapter.  It looks like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;mylib-combobox&gt;</code>options<code class="w"> </code>go<code class="w"> </code>here<code class="nt">&lt;/mylib-combobox&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>All the CSS (and JS) within this custom element apply <em>only</em> to the <code>&lt;mylib-combobox&gt;</code> element.  Even if the CSS within the custom element says something like <code>li {color: red;}</code>, that will apply to only <code>&lt;li&gt;</code> elements constructed within the <code>&lt;mylib-combobox&gt;</code>.  It can’t leak out to turn list items elsewhere on the page red.</p>&#13;
&#13;
<p>That’s all good, but what if you want to style the host element in a certain way from within the custom element?  The host element, more generally called the <em>shadow host</em>, is in this case <code>&lt;mylib-combobox&gt;</code>.  From within the shadow host, CSS can select the host by using the <code>:host</code> pseudo-class.  For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:host</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>That will reach up, so to speak, “pierce through the shadow boundary” (to use an evocative phrase from the specification), and select the <code>&lt;mylib-combobox&gt;</code> element, or whatever the name of the custom element containing the shadow DOM CSS is.</p>&#13;
&#13;
<p class="pagebreak-before">Now, suppose there can be different kinds of comboboxes, each with its own class.  Something like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;mylib-combobox</code><code class="w"> </code><code class="na">class=</code><code class="s">"countries"</code><code class="nt">&gt;</code>options<code class="w"> </code>go<code class="w"> </code>here<code class="nt">&lt;/mylib-combobox&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;mylib-combobox</code><code class="w"> </code><code class="na">class=</code><code class="s">"regions"</code><code class="nt">&gt;</code>options<code class="w"> </code>go<code class="w"> </code>here<code class="nt">&lt;/mylib-combobox&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;mylib-combobox</code><code class="w"> </code><code class="na">class=</code><code class="s">"cities"</code><code class="nt">&gt;</code>options<code class="w"> </code>go<code class="w"> </code>here<code class="nt">&lt;/mylib-combobox&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>You <a data-primary=":host() pseudo-class" data-primary-sortas="host() pseudo-class" data-type="indexterm" id="idm45176128118224"/>might want to style each class of combobox differently.  For that, the <code>:host()</code> pseudo-class exists:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:host</code><code class="o">(</code><code class="nc">.countries</code><code class="o">)</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nd">:host</code><code class="o">(</code><code class="nc">.regions</code><code class="o">)</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nd">:host</code><code class="o">(</code><code class="nc">.cities</code><code class="o">)</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="nb">none</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>These rules could then be included in the styles that are loaded by all comboboxes, using the presence of classes on the shadow hosts to style as appropriate.</p>&#13;
&#13;
<p>But wait!  <a data-primary=":host-context() pseudo-class" data-primary-sortas="host-context() pseudo-class" data-type="indexterm" id="idm45176128081760"/>What if, instead of latching on to classes, we want to style our shadow hosts based on where they appear in the light DOM?  In that case, <code>:host-context()</code> has you covered.  Thus, we can style our comboxes one way if they’re part of a form, and a different way if they’re part of a header navigation element:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">:host-context</code><code class="o">(</code><code class="nt">form</code><code class="o">)</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nd">:host-context</code><code class="o">(</code><code class="nt">header</code> <code class="nt">nav</code><code class="o">)</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The first of these means “if the shadow host is the descendant of a <code>&lt;form&gt;</code> element, apply these styles.”  The second means “if the shadow host is the descendant of a <code>&lt;nav&gt;</code> element that is itself descended from a <code>&lt;header&gt;</code> element, apply these styles.”  To be clear, <code>form</code> and <code>&lt;nav&gt;</code> are <em>not</em> the shadow hosts in these situations!  The selector in <code>:host-context()</code> is describing only the context in which the host needs to be placed in order to be selected.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The four<a data-primary=":slotted() pseudo-class" data-primary-sortas="slotted() pseudo-class" data-type="indexterm" id="idm45176128017840"/><a data-primary=":host-content() pseudo-class" data-primary-sortas="host-content() pseudo-class" data-type="indexterm" id="idm45176128016832"/> selectors that cross the shadow DOM/light DOM boundary—<code>:host</code>, <code>:host()</code>, and <code>:host-content()</code>, along with the <code>:slotted()</code> selector discussed next—are supported only when declared within the context of the shadow DOM. As of early 2023, <code>:host-context()</code> isn’t supported in Safari or Firefox and is at risk of being removed from the specification.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shadow Pseudo-Elements" data-type="sect2"><div class="sect2" id="shadow_pseudo-elements">&#13;
<h2>Shadow Pseudo-Elements</h2>&#13;
&#13;
<p>In <a data-primary="selectors" data-secondary="pseudo-element" data-type="indexterm" id="ix_selector_pseudo_elem2"/><a data-primary="pseudo-element selectors" data-secondary="shadow DOM pseudo-elements" data-type="indexterm" id="idm45176128010224"/><a data-primary="shadow DOM pseudo-elements" data-type="indexterm" id="idm45176128009344"/>addition to having hosts, shadow DOMs can also define <em>slots</em>.  These are elements that are meant to have other things slotted into them, much as you would place an expansion card into an expansion slot.  Let’s expand the markup of the combobox a little bit:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;mylib-combobox&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">slot=</code><code class="s">"label"</code><code class="nt">&gt;</code>Country<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="w">     </code>["shadow-tree"]<code class="w"/>&#13;
<code class="w">          </code><code class="nt">&lt;slot</code><code class="w"> </code><code class="na">name=</code><code class="s">"label"</code><code class="nt">&gt;&lt;/slot&gt;</code><code class="w"/>&#13;
<code class="w">     </code>[/"shadow<code class="w"> </code>tree"]<code class="w"/>&#13;
<code class="nt">&lt;/mylib-combobox&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Now, to be clear, the <code>shadow tree</code> isn’t actual markup.  It’s just there to represent the shadow DOM that gets constructed by whatever script builds it.  So please don’t go writing square-bracketed quoted element names into your documents; they will fail.</p>&#13;
&#13;
<p>That said, <a data-primary="::slotted() pseudo-element" data-primary-sortas="slotted() pseudo-element" data-type="indexterm" id="idm45176127964720"/>given a setup like the preceding one, <code>&lt;span&gt;</code> would be slotted into the <code>slot</code> element, because the names match.  You could try applying styles to the slot, but what if you’d rather style the thing that got plugged into the slot?  That’s represented by the <code>::slotted()</code> pseudo-element, which accepts a selector as needed.</p>&#13;
&#13;
<p>Thus, if you want to style all slotted elements one way and then add some extra style if the slotted element is a <code>&lt;span&gt;</code>, you would write something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nd">::slotted</code><code class="o">(*)</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nd">::slotted</code><code class="o">(</code><code class="nt">span</code><code class="o">)</code> <code class="p">{</code><code class="k">font-style</code><code class="o">-</code><code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>More practically, you could style all slots red, and then remove that red from any slot that’s been slotted with content, thus making the slots that failed to get any content stand out.  Something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">slot</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nd">::slotted</code><code class="o">(*)</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The shadow DOM and its use is a complex topic, and one that we have not even begun to scratch the surface of in this section.  Our only goal is to introduce the pseudo-classes and -elements that pertain to the shadow DOM, not explain the shadow DOM or illustrate best practices.<a data-primary="" data-startref="ix_doc_obj_shadow_dom" data-type="indexterm" id="idm45176127897936"/><a data-primary="" data-startref="ix_selector_pseudo_elem2" data-type="indexterm" id="idm45176127897024"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="pseudo_summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>As you saw in this chapter, pseudo-classes and pseudo-elements bring a whole lot of power and flexibility to the table.  Whether selecting hyperlinks based on their visited state, matching elements based on their placement in the document structure, or styling pieces of the shadow DOM, there’s a pseudo selector for nearly every taste.</p>&#13;
&#13;
<p>In this chapter and the preceding one, we’ve mentioned the concepts of specificity and the cascade a few times and promised to talk about them soon.  Well, soon is now. That’s exactly what we’ll do in the next chapter.</p>&#13;
</div></section>&#13;
</div></section></body></html>