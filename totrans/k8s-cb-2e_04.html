<html><head></head><body><section data-pdf-bookmark="Chapter 4. Creating and Modifying Fundamental&#xA0;Workloads" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_fundamental_workloads">&#13;
<h1><span class="label">Chapter 4. </span>Creating and Modifying Fundamental Workloads</h1>&#13;
&#13;
&#13;
<p>In this chapter, we present recipes that show you how to manage fundamental Kubernetes workload types: pods and deployments. We show how to create deployments and pods via CLI commands and from a YAML manifest and explain how to scale and update a deployment.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.1 Creating a Pod Using kubectl run" data-type="sect1"><div class="sect1" id="kubectl_run">&#13;
<h1>4.1 Creating a Pod Using kubectl run</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id36">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to quickly launch a long-running application such as a web server.<a data-primary="pods" data-secondary="creating using kubectl run" data-type="indexterm" id="id661"/><a data-primary="kubectl" data-secondary="creating a pod using kubectl run" data-type="indexterm" id="id662"/><a data-primary="run command (kubectl)" data-seealso="kubectl" data-type="indexterm" id="id663"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id180">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>kubectl run</code> command, a generator that creates a pod on the fly. For example, to create <a data-primary="NGINX" data-secondary="creating pod to run NGINX reverse proxy" data-type="indexterm" id="id664"/>a pod that runs the NGINX reverse proxy, do the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run nginx --image=nginx</strong>&#13;
&#13;
$ <strong>kubectl get pod/nginx</strong>&#13;
NAME    READY   STATUS    RESTARTS   AGE&#13;
nginx   1/1     Running   0          3m55s&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id37">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <code>kubectl run</code> command can take a number of arguments to configure additional parameters of the pods. <a data-primary="run command (kubectl)" data-secondary="arguments to configure pod parameters" data-type="indexterm" id="id665"/><a data-primary="environment variables" data-secondary="setting with kubectl run --env" data-type="indexterm" id="id666"/>For example, you can do the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Set environment variables with <code>--env</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Define container ports with <code>--port</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Define a command to run using <code>--command</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Automatically create an associated service with <code>--expose</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Test a run without actually running anything with <code>--dry-run=client</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Typical usages are as follows. To launch NGINX serving on port 2368 and create a service along with it, enter the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run nginx --image=nginx --port=2368 --expose</strong>&#13;
</pre>&#13;
&#13;
<p>To launch MySQL with the <a data-primary="MySQL" data-secondary="launching using kubectl run" data-type="indexterm" id="id667"/>root password set, enter this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run mysql --image=mysql --env=MYSQL_ROOT_PASSWORD=root</strong>&#13;
</pre>&#13;
&#13;
<p>To launch a <code>busybox</code> container and <a data-primary="busybox container, launching and executing command on" data-type="indexterm" id="id668"/>execute the command <code>sleep 3600</code> on start, enter this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run myshell --image=busybox:1.36 --command -- sh -c "sleep 3600"</strong>&#13;
</pre>&#13;
&#13;
<p>See also <code>kubectl run --help</code> for more details about the available arguments.<a data-primary="run command (kubectl)" data-secondary="--help option" data-secondary-sortas="help" data-type="indexterm" id="id669"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.2 Creating a Deployment Using kubectl create" data-type="sect1"><div class="sect1" id="id359">&#13;
<h1>4.2 Creating a Deployment Using kubectl create</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id181">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to quickly launch a long-running application such as a content &#13;
<span class="keep-together">management</span> system.<a data-primary="deployments" data-secondary="creating using kubectl create" data-type="indexterm" id="id670"/><a data-primary="kubectl" data-secondary="creating deployments with kubectl create" data-type="indexterm" id="id671"/><a data-primary="create command (kubectl)" data-secondary="create deployment" data-type="indexterm" id="id672"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id673">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>kubectl create deployment</code> to create a deployment manifest on the fly. For example, to create a deployment that runs the WordPress content management &#13;
<span class="keep-together">system,</span> do the following:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create deployment wordpress --image wordpress:6.3.1</strong>&#13;
&#13;
$ <strong>kubectl get deployments.apps/wordpress</strong>&#13;
NAME        READY   UP-TO-DATE   AVAILABLE   AGE&#13;
wordpress   1/1     1            1           90s&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id285">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <code>kubectl create deployment</code> command can take a number of arguments to configure additional parameters of the deployments. <a data-primary="create command (kubectl)" data-secondary="create deployment" data-tertiary="arguments configuring deployment parameters" data-type="indexterm" id="id674"/>For example, you can do the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Define container ports with <code>--port</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Define the number of replicas using <code>--replicas</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Test a run without actually running anything with <code>--dry-run=client</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Provide the created manifest using <code>--output yaml</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>See also <code>kubectl create deployment --help</code> for more details about the available arguments.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.3 Creating Objects from File Manifests" data-type="sect1"><div class="sect1" id="creating_objects">&#13;
<h1>4.3 Creating Objects from File Manifests</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id182">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Rather than creating an object via a generator such as <code>kubectl run</code>, you want to explicitly state <a data-primary="manifests" data-secondary="creating objects from file manifests" data-type="indexterm" id="id675"/><a data-primary="objects (Kubernetes)" data-secondary="creating from file manifests" data-type="indexterm" id="id676"/><a data-primary="kubectl" data-secondary="creating objects from file manifests using kubectl apply" data-type="indexterm" id="id677"/><a data-primary="apply command (kubectl)" data-secondary="creating objects from file manifests" data-type="indexterm" id="id678"/>its properties and then create it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id183">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>kubectl apply</code> like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f <em>&lt;manifest&gt;</em></strong>&#13;
</pre>&#13;
&#13;
<p>In <a data-type="xref" href="ch07.html#namespace">Recipe 7.3</a> you’ll see how to create a namespace using a YAML manifest. This is one of the simplest examples as the manifest is very short. <a data-primary="YAML" data-secondary="manifests written in" data-type="indexterm" id="id679"/><a data-primary="JSON" data-secondary="file manifests written in" data-type="indexterm" id="id680"/>It can be written in YAML or JSON—​for example, with a YAML manifest file <em>myns.yaml</em> like so:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myns</code><code class="w"/></pre>&#13;
&#13;
<p>You can create this object with this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f myns.yaml</strong>&#13;
</pre>&#13;
&#13;
<p>Check that the namespace <a data-primary="namespaces" data-secondary="objects created from file manifests with kubectl apply" data-type="indexterm" id="id681"/>was created with this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get namespaces</strong>&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id184">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You can point <code>kubectl apply</code> to a URL instead of a filename in your local filesystem. <a data-primary="apply command (kubectl)" data-secondary="pointing to URL or filename in local filesystem" data-type="indexterm" id="id682"/>For example, to create the frontend for the canonical Guestbook application, get the URL of the raw YAML that defines the application in a single manifest and enter this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f https://raw.githubusercontent.com/kubernetes/examples/&#13;
    master/guestbook/all-in-one/guestbook-all-in-one.yaml</strong>&#13;
</pre>&#13;
&#13;
<p>Check to see the resources that were created by this operation, for example with this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get all</strong>&#13;
</pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.4 Writing a Pod Manifest from Scratch" data-type="sect1"><div class="sect1" id="pod_manifest">&#13;
<h1>4.4 Writing a Pod Manifest from Scratch</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id185">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to write a pod manifest from scratch and apply it declaratively, as opposed to using a command like <code>kubectl run</code>, which is imperative and does not require manually editing a manifest.<a data-primary="manifests" data-secondary="writing pod manifest from scratch" data-type="indexterm" id="id683"/><a data-primary="pods" data-secondary="writing manifest from scratch" data-type="indexterm" id="id684"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id38">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>A pod is an <code>/api/v1</code> object, and like any other Kubernetes object, its manifest file contains <a data-primary="Pod object, fields in manifest file" data-type="indexterm" id="id685"/><a data-primary="apiVersion field" data-type="indexterm" id="id686"/><a data-primary="metadata" data-secondary="metadata field" data-type="indexterm" id="id687"/><a data-primary="kind field" data-type="indexterm" id="id688"/><a data-primary="spec field" data-type="indexterm" id="id689"/>the following fields:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>apiVersion</code>, which specifies the API version</p>&#13;
</li>&#13;
<li>&#13;
<p><code>kind</code>, which indicates the type of the object</p>&#13;
</li>&#13;
<li>&#13;
<p><code>metadata</code>, which provides some metadata about the object</p>&#13;
</li>&#13;
<li>&#13;
<p><code>spec</code>, which provides the object specification</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The pod manifest contains an array of containers and an optional array of volumes (see <a data-type="xref" href="ch08.html#ch_volumes_config">Chapter 8</a>). <a data-primary="containers" data-secondary="array of in pod manifests" data-type="indexterm" id="id690"/><a data-primary="volumes" data-secondary="array of in pod manifests" data-type="indexterm" id="id691"/>In its simplest form, with a single container and no volume, it looks something like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">oreilly</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">oreilly</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">Save this YAML manifest in a file called <em>oreilly.yaml</em> and then use <code>kubectl</code> to create it:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f oreilly.yaml</strong>&#13;
</pre>&#13;
&#13;
<p>Check to see the resources that were created by this operation, for example with this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get all</strong>&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id39">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The API specification of a pod is much richer than what is shown in the Solution, which is the most basic functioning pod. For example, a pod can contain multiple containers, as shown here:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">oreilly</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">oreilly</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">safari</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis:7.2.0</code><code class="w"/></pre>&#13;
&#13;
<p>A pod can also contain volume definitions to load data in the containers (see <a data-type="xref" href="ch08.html#data_exchange_local_volume">Recipe 8.1</a>), as well as probes to check the health of the containerized application (see Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.html#liveness">11.2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.html#readiness">11.3</a>).</p>&#13;
&#13;
<p>A description of the thinking behind many of the specification fields and a link to the full API object specification are detailed in the <a href="https://oreil.ly/pSCBL">documentation</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Unless for very specific reasons, never create a pod on its own. Use a <code>Deployment</code> object (see <a data-type="xref" href="#deployments">Recipe 4.5</a>) to supervise pods—​it will watch over the pods through another object called a <code>ReplicaSet</code>.<a data-primary="deployments" data-secondary="Deployment object to supervise pods" data-type="indexterm" id="id692"/><a data-primary="ReplicaSet object" data-type="indexterm" id="id693"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.5 Launching a Deployment Using a Manifest" data-type="sect1"><div class="sect1" id="deployments">&#13;
<h1>4.5 Launching a Deployment Using a Manifest</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id186">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to have full control over how a (long-running) app is launched and  &#13;
<span class="keep-together">supervised</span>.<a data-primary="manifests" data-secondary="launching a deployment with" data-type="indexterm" id="ix_manidply"/><a data-primary="deployments" data-secondary="launching using a manifest" data-type="indexterm" id="ix_dplymani"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id694">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Write a deployment manifest. For the basics, see also <a data-type="xref" href="#pod_manifest">Recipe 4.4</a>.</p>&#13;
&#13;
<p>Let’s say you have manifest file called <em>fancyapp.yaml</em> with the following contents:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fancyapp</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fancy</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fancy</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">env</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">development</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">sise</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/google-samples/hello-app:2.0</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SIMPLE_SERVICE_VERSION</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">"2.0"</code><code class="w"/></pre>&#13;
&#13;
<p>As you can see, there are a couple of things you might want to do explicitly when launching the app:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Set the number of pods (<code>replicas</code>), or identical copies, that should be launched and supervised.</p>&#13;
</li>&#13;
<li>&#13;
<p>Label it, such as with <code>env=development</code> (see also Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.html#easy_label">7.5</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.html#labels">7.6</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Set environment variables, such as <code>SIMPLE_SERVICE_VERSION</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Now let’s look at what the deployment entails:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f fancyapp.yaml</strong>&#13;
deployment.apps/fancyapp created&#13;
&#13;
$ <strong>kubectl get deployments</strong>&#13;
NAME       READY   UP-TO-DATE   AVAILABLE   AGE&#13;
fancyapp   5/5     5            5           57s&#13;
&#13;
$ <strong>kubectl get replicasets</strong>&#13;
NAME                  DESIRED   CURRENT   READY     AGE&#13;
fancyapp-1223770997   5         5         0         59s&#13;
&#13;
$ <strong>kubectl get pods -l app=fancy</strong>&#13;
NAME                                 READY   STATUS    RESTARTS      AGE&#13;
fancyapp-74c6f7cfd7-98d97            1/1     Running   0             115s&#13;
fancyapp-74c6f7cfd7-9gm2l            1/1     Running   0             115s&#13;
fancyapp-74c6f7cfd7-kggsx            1/1     Running   0             115s&#13;
fancyapp-74c6f7cfd7-xfs6v            1/1     Running   0             115s&#13;
fancyapp-74c6f7cfd7-xntk2            1/1     Running   0             115s&#13;
</pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>When you want to get rid of a deployment, and with it the replica sets and pods it supervises, execute a command like <code>kubectl delete deploy/fancyapp</code>. Do <em>not</em> try to delete individual pods, as they will be re-created by the deployment. This is something that often confuses beginners.</p>&#13;
</div>&#13;
&#13;
<p>Deployments allow you to scale the app (see <a data-type="xref" href="ch09.html#scaling-deployments">Recipe 9.1</a>) as well as roll out a new version or roll back a <code>ReplicaSet</code> to a previous version. They are, in general, good for stateless apps that require pods with identical characteristics.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id187">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>A deployment is a supervisor for pods and replica sets (RSs), giving you fine-grained control over how and when a new pod version is rolled out or rolled back to a previous state. <a data-primary="pods" data-secondary="Deployment object as supervisor" data-type="indexterm" id="id695"/><a data-primary="replica sets" data-secondary="Deployment object as supervisor" data-type="indexterm" id="id696"/>The RSs and pods that a deployment supervises are generally of no interest to you unless, for example, you need to debug a pod (see <a data-type="xref" href="ch12.html#debug_pods">Recipe 12.5</a>). <a data-type="xref" href="#deployment-revisions">Figure 4-1</a> illustrates how you can move back and forth between deployment revisions.</p>&#13;
&#13;
<figure><div class="figure" id="deployment-revisions">&#13;
<img alt="Deployment Revisions" src="assets/kcb2_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Deployment revisions</h6>&#13;
</div></figure>&#13;
&#13;
<p>To generate the manifest for a deployment, you can use the <code>kubectl create</code> command and the <code>--dry-run=client</code> option. <a data-primary="kubectl" data-secondary="generating manifest for deployment with kubectl create and --dry-run=client option" data-type="indexterm" id="id697"/><a data-primary="create command (kubectl)" data-secondary="generating manifest for deployment using --dry-run=client option" data-type="indexterm" id="id698"/>This will allow you to generate the manifest in YAML or JSON format and save the manifest for later use. For example, to create the manifest of a deployment called <code>fancy-app</code> using the container image <code>nginx</code>, issue the following command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create deployment fancyapp --image nginx:1.25.2 -o yaml \&#13;
    --dry-run=client</strong>&#13;
kind: Deployment&#13;
apiVersion: apps/v1&#13;
metadata:&#13;
  name: fancyapp&#13;
  creationTimestamp:&#13;
  labels:&#13;
    app: fancyapp&#13;
...</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id699">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/IAghn"><code>Deployment</code> documentation</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.6 Updating a Deployment" data-type="sect1"><div class="sect1" id="updating-deployments">&#13;
<h1>4.6 Updating a Deployment</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id188">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You have a deployment and want to roll out a new version of your app.<a data-primary="manifests" data-secondary="launching a deployment with" data-startref="ix_manidply" data-type="indexterm" id="id700"/><a data-primary="deployments" data-secondary="launching using a manifest" data-startref="ix_dplymani" data-type="indexterm" id="id701"/><a data-primary="deployments" data-secondary="updating" data-type="indexterm" id="ix_dplyupd"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id40">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Update your deployment and let the default update strategy, <code>RollingUpdate</code>, automatically handle the rollout.<a data-primary="RollingUpdate" data-type="indexterm" id="id702"/></p>&#13;
&#13;
<p>For example, if you create a new container image and want to update the deployment based<a data-primary="container images" data-secondary="creating new image and updating deployment" data-type="indexterm" id="id703"/><a data-primary="kubectl" data-secondary="creating new container image and updating deployment based on it" data-type="indexterm" id="id704"/> on it, you can do this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create deployment myapp --image=gcr.io/google-samples/hello-app:1.0</strong>&#13;
deployment.apps/myapp created&#13;
&#13;
$ <strong>kubectl set image deployment/myapp \&#13;
    hello-app=gcr.io/google-samples/hello-app:2.0</strong>&#13;
deployment.apps/myapp image updated&#13;
&#13;
$ <strong>kubectl rollout status deployment myapp</strong>&#13;
deployment "myapp" successfully rolled out&#13;
&#13;
$ <strong>kubectl rollout history deployment myapp</strong>&#13;
deployment.apps/myapp&#13;
REVISION        CHANGE-CAUSE&#13;
1               &lt;none&gt;&#13;
2               &lt;none&gt;&#13;
</pre>&#13;
&#13;
<p>You’ve now successfully rolled out a new revision of your deployment where only the container image used has changed. All other properties of the deployment, such as the number of replicas, stay unchanged. <a data-primary="environment variables" data-secondary="changing in a deployment" data-type="indexterm" id="id705"/>But what if you want to update other aspects of the deployment, such as changing environment variables? You can use a number of <code>kubectl</code> commands to update the deployment. <a data-primary="kubectl" data-secondary="editing a deployment with kubectl edit" data-type="indexterm" id="id706"/><a data-primary="edit command (kubectl)" data-type="indexterm" id="id707"/>For example, to add a port definition to the current deployment, you can use <code>kubectl edit</code>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl edit deploy myapp</strong>&#13;
</pre>&#13;
&#13;
<p>This command will open the current deployment in your default editor or, when set and exported, in the <a data-primary="vi editor" data-type="indexterm" id="id708"/><a data-primary="KUBE_EDITOR environment variable" data-type="indexterm" id="id709"/>editor specified by the environment variable <code>KUBE_EDITOR</code>.</p>&#13;
&#13;
<p>Say you want to add the following port definition (see <a data-type="xref" href="#deployment-edit">Figure 4-2</a> for the full file):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">9876</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>The result of the editing process (in this case, with <code>KUBE_EDITOR</code> set to <code>vi</code>) is shown in <a data-type="xref" href="#deployment-edit">Figure 4-2</a>.</p>&#13;
&#13;
<p>Once you save and exit the editor, Kubernetes kicks off a new deployment, now with the port defined.<a data-primary="kubectl" data-secondary="rollout history deployment command" data-type="indexterm" id="id710"/> Let’s verify that:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl rollout history deployment myapp</strong>&#13;
deployments "sise"&#13;
REVISION        CHANGE-CAUSE&#13;
1               &lt;none&gt;&#13;
2               &lt;none&gt;&#13;
3               &lt;none&gt;&#13;
</pre>&#13;
&#13;
<p>Indeed, we see that revision 3 has been rolled out with the changes we introduced with <code>kubectl edit</code>. However, the <code>CHANGE-CAUSE</code> column is empty. You can specify <a data-primary="change cause for revisions" data-type="indexterm" id="id711"/><a data-primary="kubectl" data-secondary="annotate command" data-type="indexterm" id="id712"/>a change cause for a revision by using a special annotation. The following is an example of setting a change cause for the most recent revision:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl annotate deployment/myapp \&#13;
    kubernetes.io/change-cause="Added port definition."</strong>&#13;
deployment.apps/myapp annotate&#13;
</pre>&#13;
&#13;
<figure><div class="figure" id="deployment-edit">&#13;
<img alt="Editing Deployment" src="assets/kcb2_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Editing a deployment</h6>&#13;
</div></figure>&#13;
&#13;
<p>As mentioned earlier, there are more <code>kubectl</code> commands that <a data-primary="kubectl" data-secondary="command to use in updating deployments" data-type="indexterm" id="id713"/><a data-primary="apply command (kubectl)" data-secondary="using to update a deployment" data-type="indexterm" id="id714"/><a data-primary="replace command (kubectl)" data-secondary="using to replace a deployment" data-type="indexterm" id="id715"/><a data-primary="patch command (kubectl)" data-secondary="updating a deployment with" data-type="indexterm" id="id716"/>you can use to update your deployment:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use <code>kubectl apply</code> to update a deployment (or create it if it doesn’t exist) from a manifest file—​for example, <code>kubectl apply -f simpleservice.yaml</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use <code>kubectl replace</code> to replace a deployment from a manifest file—​for example, <code>kubectl replace -f simpleservice.yaml</code>. Note that unlike with <code>apply</code>, to use <code>replace</code>, the deployment must already exist.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use <code>kubectl patch</code> to update a specific key—​for example:</p>&#13;
&#13;
<pre data-type="programlisting">kubectl patch deployment myapp -p '{"spec": {"template":&#13;
{"spec": {"containers":&#13;
[{"name": "sise", "image": "gcr.io/google-samples/hello-app:2.0"}]}}}}'</pre>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>What if you make a mistake or experience issues with the new version of the deployment? Luckily, Kubernetes makes it really easy to roll back to a known good state using the <code>kubectl rollout undo</code> command. <a data-primary="kubectl" data-secondary="rollout undo command" data-type="indexterm" id="id717"/><a data-primary="rollout undo command (kubectl)" data-type="indexterm" id="id718"/>For example, suppose the last edit was a mistake and you want to roll back to revision 2. You can do this with the following command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl rollout undo deployment myapp ‐‐to‐revision 2</strong>&#13;
</pre>&#13;
&#13;
<p>You can then verify that the port definition has been removed with <code>kubectl get deploy/myapp -o yaml</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The rollout of a deployment is triggered only if<a data-primary="rollout of deployments, triggering" data-type="indexterm" id="id719"/> parts of the pod template (that is, keys below <code>.spec.template</code>) are changed, such as environment variables, ports, or the container image. Changes to aspects of the deployments, such as the replica count, do not trigger a new deployment.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.7 Running a Batch Job" data-type="sect1"><div class="sect1" id="run_job">&#13;
<h1>4.7 Running a Batch Job</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id41">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to run a process that runs for a certain time to completion, such as a batch conversion, backup operation, or database schema upgrade.<a data-primary="deployments" data-secondary="updating" data-startref="ix_dplyupd" data-type="indexterm" id="id720"/><a data-primary="batch jobs, running" data-type="indexterm" id="id721"/><a data-primary="jobs" data-secondary="running a batch job" data-type="indexterm" id="id722"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id189">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a Kubernetes <a href="https://oreil.ly/1whb2"><code>Job</code></a> to launch and supervise the pod(s) that will carry out the batch process.</p>&#13;
&#13;
<p>First, define the Kubernetes manifest for <a data-primary="manifests" data-secondary="defining for batch job" data-type="indexterm" id="id723"/>the job in a file called <em>counter-batch-job.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">batch/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Job</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">counter</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">counter</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">counter</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.36</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sh"</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"for</code><code class="nv"> </code><code class="s">i</code><code class="nv"> </code><code class="s">in</code><code class="nv"> </code><code class="s">1</code><code class="nv"> </code><code class="s">2</code><code class="nv"> </code><code class="s">3</code><code class="nv"> </code><code class="s">;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">$i</code><code class="nv"> </code><code class="s">;</code><code class="nv"> </code><code class="s">done"</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Never</code><code class="w"/></pre>&#13;
&#13;
<p>Then launch the job and take <a data-primary="kubectl" data-secondary="launching batch job and watching its status" data-type="indexterm" id="id724"/>a look at its status:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f counter-batch-job.yaml</strong>&#13;
job.batch/counter created&#13;
&#13;
$ <strong>kubectl get jobs</strong>&#13;
NAME      COMPLETIONS   DURATION   AGE&#13;
counter   1/1           7s         12s&#13;
&#13;
$ <strong>kubectl describe jobs/counter</strong>&#13;
Name:             counter&#13;
Namespace:        default&#13;
Selector:         controller-uid=2d21031e-7263-4ff1-becd-48406393edd5&#13;
Labels:           controller-uid=2d21031e-7263-4ff1-becd-48406393edd5&#13;
                  job-name=counter&#13;
Annotations:      batch.kubernetes.io/job-tracking:&#13;
Parallelism:      1&#13;
Completions:      1&#13;
Completion Mode:  NonIndexed&#13;
Start Time:       Mon, 03 Apr 2023 18:19:13 +0530&#13;
Completed At:     Mon, 03 Apr 2023 18:19:20 +0530&#13;
Duration:         7s&#13;
Pods Statuses:    0 Active (0 Ready) / 1 Succeeded / 0 Failed&#13;
Pod Template:&#13;
  Labels:  controller-uid=2d21031e-7263-4ff1-becd-48406393edd5&#13;
           job-name=counter&#13;
  Containers:&#13;
   counter:&#13;
    Image:      busybox:1.36&#13;
    Port:       &lt;none&gt;&#13;
    Host Port:  &lt;none&gt;&#13;
    Command:&#13;
      sh&#13;
      -c&#13;
      for i in 1 2 3 ; do echo $i ; done&#13;
    Environment:  &lt;none&gt;&#13;
    Mounts:       &lt;none&gt;&#13;
  Volumes:        &lt;none&gt;&#13;
Events:&#13;
  Type    Reason            Age   From            Message&#13;
  ----    ------            ----  ----            -------&#13;
  Normal  SuccessfulCreate  30s   job-controller  Created pod: counter-5c8s5&#13;
  Normal  Completed         23s   job-controller  Job completed&#13;
</pre>&#13;
&#13;
<p>Finally, you want to verify that it actually <a data-primary="kubectl" data-secondary="logs command" data-type="indexterm" id="id725"/>carried out the task (counting from 1 to 3):</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl logs jobs/counter</strong>&#13;
1&#13;
2&#13;
3&#13;
</pre>&#13;
&#13;
<p>Indeed, as you can see, the <code>counter</code> job counted as expected.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id42">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>After a job has executed successfully, the pod that was created by the job will be in the <em>Completed</em> state. You can delete the job if you don’t need it anymore, which will clean up the pods it created:<a data-primary="delete command (kubectl)" data-type="indexterm" id="id726"/><a data-primary="jobs" data-secondary="running a batch job" data-tertiary="deleting finished job" data-type="indexterm" id="id727"/></p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl delete jobs/counter </strong>&#13;
</pre>&#13;
&#13;
<p>You can also temporarily suspend a <a data-primary="jobs" data-secondary="running a batch job" data-tertiary="suspending and resuming execution" data-type="indexterm" id="id728"/><a data-primary="patch command (kubectl)" data-secondary="suspending a job" data-type="indexterm" id="id729"/>job’s execution and resume it later. Suspending a job will also clean up the pods it created:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl patch jobs/counter --type=strategic --patch '{"spec":{"suspend":true}}'</strong>&#13;
</pre>&#13;
&#13;
<p>To resume the job, simply flip the <code>suspend</code> flag:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl patch jobs/counter --type=strategic \&#13;
    --patch '{"spec":{"suspend":false}}'</strong>&#13;
</pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.8 Running a Task on a Schedule Within a Pod" data-type="sect1"><div class="sect1" id="cronjob">&#13;
<h1>4.8 Running a Task on a Schedule Within a Pod</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id190">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to run a task on a specific schedule within a pod managed by Kubernetes.<a data-primary="pods" data-secondary="running a task on schedule in" data-type="indexterm" id="id730"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id43">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use Kubernetes <code>CronJob</code> objects. <a data-primary="CronJob object" data-type="indexterm" id="id731"/><a data-primary="jobs" data-secondary="CronJob, running in a pod" data-type="indexterm" id="id732"/>The <code>CronJob</code> object is a derivative of the more generic <code>Job</code> object (see <a data-type="xref" href="#run_job">Recipe 4.7</a>).</p>&#13;
&#13;
<p>You can periodically schedule a job by writing a manifest similar to the one shown here. <a data-primary="scheduling jobs" data-type="indexterm" id="id733"/>In the <code>spec</code>, you see a <code>schedule</code> section that follows the crontab format. You can also use some macros, such as <code>@hourly</code>, <code>@daily</code>, <code>@weekly</code>, <code>@monthly</code>, and <code>@yearly</code>. The <code>template</code> section describes the pod that will run and the command that will get executed (this one prints the current date and time every hour to <code>stdout</code>):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">batch/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CronJob</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hourly-date</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">schedule</code><code class="p">:</code><code class="w"> </code><code class="s">"0</code><code class="nv"> </code><code class="s">*</code><code class="nv"> </code><code class="s">*</code><code class="nv"> </code><code class="s">*</code><code class="nv"> </code><code class="s">*"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">jobTemplate</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">date</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.36</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sh"</code><code class="w"/>&#13;
<code class="w">              </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">              </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"date"</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">OnFailure</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id734">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Just like a job, a cron job can be also be suspended and resumed by flipping the <code>suspend</code> flag. For example:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl patch cronjob.batch/hourly-date --type=strategic \&#13;
    --patch '{"spec":{"suspend":true}}'</strong>&#13;
</pre>&#13;
&#13;
<p>If you don’t need the cron job anymore, delete it to clean up the pods that it created:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl delete cronjob.batch/hourly-date</strong>&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id735">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/nrxxh">Kubernetes <code>CronJob</code> documentation</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="4.9 Running Infrastructure Daemons per Node" data-type="sect1"><div class="sect1" id="daemonset">&#13;
<h1>4.9 Running Infrastructure Daemons per Node</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id44">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to launch an infrastructure daemon—​for example, a log collector or monitoring agent—​making sure that exactly one pod runs per node.<a data-primary="nodes" data-secondary="running infrastructure daemons per node" data-type="indexterm" id="ix_nodedmn"/><a data-primary="daemons (infrastructure), running per node" data-type="indexterm" id="ix_dmn"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id45">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a <code>DaemonSet</code> to launch and supervise the daemon process.<a data-primary="DaemonSet object" data-type="indexterm" id="id736"/><a data-primary="Fluentd agent, launching on nodes in cluster" data-type="indexterm" id="ix_Fluentd"/> For example, to launch a Fluentd agent on each node in your cluster, create a file named <em>fluentd-daemonset.yaml</em> with the following contents:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DaemonSet</code><code class="w"/>&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fluentd</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fluentd</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fluentd</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fluentd</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fluentd</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/google_containers/fluentd-elasticsearch:1.3</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">FLUENTD_ARGS</code><code class="w"/>&#13;
<code class="w">           </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">-qq</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">varlog</code><code class="w"/>&#13;
<code class="w">           </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/varlog</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">containers</code><code class="w"/>&#13;
<code class="w">           </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/lib/docker/containers</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">             </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/log</code><code class="w"/>&#13;
<code class="w">           </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">varlog</code><code class="w"/>&#13;
<code class="w">         </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">             </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/lib/docker/containers</code><code class="w"/>&#13;
<code class="w">           </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">containers</code><code class="w"/></pre>&#13;
&#13;
<p>Now launch the <code>DaemonSet</code>, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f fluentd-daemonset.yaml</strong>&#13;
daemonset.apps/fluentd created&#13;
&#13;
$ <strong>kubectl get ds</strong>&#13;
NAME     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE&#13;
fluentd  1         1         1       1            1           &lt;none&gt;          60s&#13;
&#13;
$ <strong>kubectl describe ds/fluentd</strong>&#13;
Name:           fluentd&#13;
Selector:       app=fluentd&#13;
Node-Selector:  &lt;none&gt;&#13;
Labels:         &lt;none&gt;&#13;
Annotations:    deprecated.daemonset.template.generation: 1&#13;
Desired Number of Nodes Scheduled: 1&#13;
Current Number of Nodes Scheduled: 1&#13;
Number of Nodes Scheduled with Up-to-date Pods: 1&#13;
Number of Nodes Scheduled with Available Pods: 1&#13;
Number of Nodes Misscheduled: 0&#13;
Pods Status:  1 Running / 0 Waiting / 0 Succeeded / 0 Failed&#13;
...&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id46">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Note that in the preceding output, because the command is executed on Minikube, you see only one pod running as there’s only one node in this setup. If you had 15 nodes in your cluster, you’d have 15 pods overall with 1 pod per node running.<a data-primary="Fluentd agent, launching on nodes in cluster" data-startref="ix_Fluentd" data-type="indexterm" id="id737"/><a data-primary="nodes" data-secondary="running infrastructure daemons per node" data-startref="ix_nodedmn" data-type="indexterm" id="id738"/><a data-primary="daemons (infrastructure), running per node" data-startref="ix_dmn" data-type="indexterm" id="id739"/> You can also restrict the daemon to certain nodes using the <code>nodeSelector</code> section in the <code>spec</code> of the <code>DaemonSet</code> manifest.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>