["```\nfunction processBar(b: Bar) { /* ... */ }\n\nfunction f() {\n  const x = expressionReturningFoo();\n  processBar(x);\n  //         ~ Argument of type 'Foo' is not assignable to\n  //           parameter of type 'Bar'\n}\n```", "```\nfunction f1() {\n  const x: any = expressionReturningFoo();  // Don't do this\n  processBar(x);\n}\n\nfunction f2() {\n  const x = expressionReturningFoo();\n  processBar(x as any);  // Prefer this\n}\n```", "```\nfunction f1() {\n  const x: any = expressionReturningFoo();\n  processBar(x);\n  return x;\n}\n\nfunction g() {\n  const foo = f1();  // Type is any\n  foo.fooMethod();  // This call is unchecked!\n}\n```", "```\nfunction f1() {\n  const x = expressionReturningFoo();\n  // @ts-ignore\n  processBar(x);\n  return x;\n}\n```", "```\nconst config: Config = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value\n // ~~~ Property ... missing in type 'Bar' but required in type 'Foo'\n  }\n};\n```", "```\nconst config: Config = {\n  a: 1,\n  b: 2,\n  c: {\n    key: value\n  }\n} as any;  // Don't do this!\n```", "```\nconst config: Config = {\n  a: 1,\n  b: 2,  // These properties are still checked\n  c: {\n    key: value as any\n  }\n};\n```", "```\nfunction getLengthBad(array: any) {  // Don't do this!\n  return array.length;\n}\n\nfunction getLength(array: any[]) {\n  return array.length;\n}\n```", "```\ngetLengthBad(/123/);  // No error, returns undefined\ngetLength(/123/);\n       // ~~~~~ Argument of type 'RegExp' is not assignable\n       //       to parameter of type 'any[]'\n```", "```\nfunction hasTwelveLetterKey(o: {[key: string]: any}) {\n  for (const key in o) {\n    if (key.length === 12) {\n      return true;\n    }\n  }\n  return false;\n}\n```", "```\nfunction hasTwelveLetterKey(o: object) {\n  for (const key in o) {\n    if (key.length === 12) {\n      console.log(key, o[key]);\n                   //  ~~~~~~ Element implicitly has an 'any' type\n                   //         because type '{}' has no index signature\n      return true;\n    }\n  }\n  return false;\n}\n```", "```\ntype Fn0 = () => any;  // any function callable with no params\ntype Fn1 = (arg: any) => any;  // With one param\ntype FnN = (...args: any[]) => any;  // With any number of params\n                                     // same as \"Function\" type\n```", "```\nconst numArgsBad = (...args: any) => args.length; // Returns any\nconst numArgsGood = (...args: any[]) => args.length;  // Returns number\n```", "```\ndeclare function cacheLast<T extends Function>(fn: T): T;\n```", "```\nfunction cacheLast<T extends Function>(fn: T): T {\n  let lastArgs: any[]|null = null;\n  let lastResult: any;\n  return function(...args: any[]) {\n      // ~~~~~~~~~~~~~~~~~~~~~~~~~~\n      //          Type '(...args: any[]) => any' is not assignable to type 'T'\n    if (!lastArgs || !shallowEqual(lastArgs, args)) {\n      lastResult = fn(...args);\n      lastArgs = args;\n    }\n    return lastResult;\n  };\n}\n```", "```\nfunction cacheLast<T extends Function>(fn: T): T {\n  let lastArgs: any[]|null = null;\n  let lastResult: any;\n  return function(...args: any[]) {\n    if (!lastArgs || !shallowEqual(lastArgs, args)) {\n      lastResult = fn(...args);\n      lastArgs = args;\n    }\n    return lastResult;\n  } as unknown as T;\n}\n```", "```\ndeclare function shallowObjectEqual<T extends object>(a: T, b: T): boolean;\n```", "```\nfunction shallowObjectEqual<T extends object>(a: T, b: T): boolean {\n  for (const [k, aVal] of Object.entries(a)) {\n    if (!(k in b) || aVal !== b[k]) {\n                           // ~~~~ Element implicitly has an 'any' type\n                           //      because type '{}' has no index signature\n      return false;\n    }\n  }\n  return Object.keys(a).length === Object.keys(b).length;\n}\n```", "```\nfunction shallowObjectEqual<T extends object>(a: T, b: T): boolean {\n  for (const [k, aVal] of Object.entries(a)) {\n    if (!(k in b) || aVal !== (b as any)[k]) {\n      return false;\n    }\n  }\n  return Object.keys(a).length === Object.keys(b).length;\n}\n```", "```\nfunction range(start, limit) {\n  const out = [];\n  for (let i = start; i < limit; i++) {\n    out.push(i);\n  }\n  return out;\n}\n```", "```\nfunction range(start: number, limit: number) {\n  const out = [];\n  for (let i = start; i < limit; i++) {\n    out.push(i);\n  }\n  return out;  // Return type inferred as number[]\n}\n```", "```\nfunction range(start: number, limit: number) {\n  const out = [];  // Type is any[]\n  for (let i = start; i < limit; i++) {\n    out.push(i);  // Type of out is any[]\n  }\n  return out;  // Type is number[]\n}\n```", "```\nconst result = [];  // Type is any[]\nresult.push('a');\nresult  // Type is string[]\nresult.push(1);\nresult  // Type is (string | number)[]\n```", "```\nlet val;  // Type is any\nif (Math.random() < 0.5) {\n  val = /hello/;\n  val  // Type is RegExp\n} else {\n  val = 12;\n  val  // Type is number\n}\nval  // Type is number | RegExp\n```", "```\nlet val = null;  // Type is any\ntry {\n  somethingDangerous();\n  val = 12;\n  val  // Type is number\n} catch (e) {\n  console.warn('alas!');\n}\nval  // Type is number | null\n```", "```\nlet val: any;  // Type is any\nif (Math.random() < 0.5) {\n  val = /hello/;\n  val  // Type is any\n} else {\n  val = 12;\n  val  // Type is any\n}\nval  // Type is any\n```", "```\nfunction range(start: number, limit: number) {\n  const out = [];\n  //    ~~~ Variable 'out' implicitly has type 'any[]' in some\n  //        locations where its type cannot be determined\n  if (start === limit) {\n    return out;\n    //     ~~~ Variable 'out' implicitly has an 'any[]' type\n  }\n  for (let i = start; i < limit; i++) {\n    out.push(i);\n  }\n  return out;\n}\n```", "```\nfunction makeSquares(start: number, limit: number) {\n  const out = [];\n     // ~~~ Variable 'out' implicitly has type 'any[]' in some locations\n  range(start, limit).forEach(i => {\n    out.push(i * i);\n  });\n  return out;\n      // ~~~ Variable 'out' implicitly has an 'any[]' type\n}\n```", "```\nfunction parseYAML(yaml: string): any {\n  // ...\n}\n```", "```\ninterface Book {\n  name: string;\n  author: string;\n}\nconst book: Book = parseYAML(`\n name: Wuthering Heights\n author: Emily Brontë\n`);\n```", "```\nconst book = parseYAML(`\n name: Jane Eyre\n author: Charlotte Brontë\n`);\nalert(book.title);  // No error, alerts \"undefined\" at runtime\nbook('read');  // No error, throws \"TypeError: book is not a\n               // function\" at runtime\n```", "```\nfunction safeParseYAML(yaml: string): unknown {\n  return parseYAML(yaml);\n}\nconst book = safeParseYAML(`\n name: The Tenant of Wildfell Hall\n author: Anne Brontë\n`);\nalert(book.title);\n   // ~~~~ Object is of type 'unknown'\nbook(\"read\");\n// ~~~~~~~~~~ Object is of type 'unknown'\n```", "```\nconst book = safeParseYAML(`\n name: Villette\n author: Charlotte Brontë\n`) as Book;\nalert(book.title);\n        // ~~~~~ Property 'title' does not exist on type 'Book'\nbook('read');\n// ~~~~~~~~~ this expression is not callable\n```", "```\ninterface Feature {\n  id?: string | number;\n  geometry: Geometry;\n  properties: unknown;\n}\n```", "```\nfunction processValue(val: unknown) {\n  if (val instanceof Date) {\n    val  // Type is Date\n  }\n}\n```", "```\nfunction isBook(val: unknown): val is Book {\n  return (\n      typeof(val) === 'object' && val !== null &&\n      'name' in val && 'author' in val\n  );\n}\nfunction processValue(val: unknown) {\n  if (isBook(val)) {\n    val;  // Type is Book\n  }\n}\n```", "```\nfunction safeParseYAML<T>(yaml: string): T {\n  return parseYAML(yaml);\n}\n```", "```\ndeclare const foo: Foo;\nlet barAny = foo as any as Bar;\nlet barUnk = foo as unknown as Bar;\n```", "```\nwindow.monkey = 'Tamarin';\ndocument.monkey = 'Howler';\n```", "```\nconst el = document.getElementById('colobus');\nel.home = 'tree';\n```", "```\n>  `RegExp``.``prototype``.``monkey` `=` `'Capuchin'`\n\"Capuchin\"\n> `/123/``.``monkey`\n\"Capuchin\"\n```", "```\ndocument.monkey = 'Tamarin';\n      // ~~~~~~ Property 'monkey' does not exist on type 'Document'\n```", "```\n(document as any).monkey = 'Tamarin';  // OK\n```", "```\n(document as any).monky = 'Tamarin';  // Also OK, misspelled\n(document as any).monkey = /Tamarin/;  // Also OK, wrong type\n```", "```\ninterface Document {\n  /** Genus or species of monkey patch */\n  monkey: string;\n}\n\ndocument.monkey = 'Tamarin';  // OK\n```", "```\nexport {};\ndeclare global {\n  interface Document {\n    /** Genus or species of monkey patch */\n    monkey: string;\n  }\n}\ndocument.monkey = 'Tamarin';  // OK\n```", "```\ninterface MonkeyDocument extends Document {\n  /** Genus or species of monkey patch */\n  monkey: string;\n}\n\n(document as MonkeyDocument).monkey = 'Macaque';\n```", "```\n$ npx type-coverage\n9985 / 10117 98.69%\n```", "```\n$ npx type-coverage --detail\npath/to/code.ts:1:10 getColumnInfo\npath/to/module.ts:7:1 pt2\n...\n```", "```\nfunction getColumnInfo(name: string): any {\n  return utils.buildColumnInfo(appState.dataSchema, name);  // Returns any\n}\n```", "```\ndeclare module 'my-module';\n```", "```\nimport {someMethod, someSymbol} from 'my-module';  // OK\n\nconst pt1 = {\n  x: 1,\n  y: 2,\n};  // type is {x: number, y: number}\nconst pt2 = someMethod(pt1, someSymbol);  // OK, pt2's type is any\n```"]