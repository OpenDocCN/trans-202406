<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Generating Summaries"><div class="chapter" id="nch-sum"><h1><span class="label">Chapter 10. </span>Generating Summaries</h1><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820369240976"><h5>A note for Early Release readers</h5><p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p></div></aside><section data-type="sect1" data-pdf-bookmark="10.0 Introduction"><div class="sect1" id="nch-sum-sum-intro"><h1>10.0 Introduction</h1><p>Database systems are not only useful for data storage and retrieval, but they can also
    summarize your data in more concise forms. Summaries are useful when you
    want the overall picture, not the details. They’re more readily understood
    than a long list of records. They enable you to answer questions such as
    <q>How many?</q> or <q>What is the total?</q> or
    <q>What is the range of values?</q> If you run a business, you may
    want to know how many customers you have in each state, or how much sales
    volume you generate each month.</p><p>The preceding examples include two common summary types: counting summaries and content summaries. The first (the
    number of customer records per state) is a counting summary. The content
    of each record is important only for purposes of placing it into the
    proper group or category for counting. Such summaries are essentially
    histograms, where you sort items into a set of bins and count the number
    of items in each bin. The second example (sales volume per month) is a
    content summary, in which sales totals are based on sales values in order
    records.</p><p>Another summary type produces neither counts nor sums, but simply a
    list of unique values. This is useful if you care
    <em>which</em> values are present rather than how many of each
    there are. To determine the states in which you have customers, you need a
    list of the distinct state names contained in the records, not a list
    consisting of the state value from every record.</p><p>The summary types available to you depend on the nature of your
    data. A counting summary can be generated from all kinds of values,
    whether they be numbers, strings, or dates. Summaries that produce sums or
    averages apply only to numeric values. You can count instances of customer
    state names to produce a demographic analysis of your customer base. And
    sometimes it makes sense to apply one summary technique to the result of
    another. For example, to determine how many states your customers live in,
    generate a list of unique customer states, then count them.</p><p>Summary operations in MySQL involve the following SQL
    constructs:</p><ul><li><p>To compute a summary value from a set of individual values, use
        one of the functions known as aggregate functions. These are so called because they operate on aggregates
        (groups) of values. Aggregate functions include <code>COUNT()</code>, which counts rows or values in a query result; <code>MIN()</code> and <code>MAX()</code>, which find smallest and largest values; and <code>SUM()</code> and <code>AVG()</code>, which produce sums and means of values. These functions can be
        used to compute a value for the entire result set, or with a <code>GROUP</code> <code>BY</code>
        clause to group rows into subsets and obtain an aggregate value
        for each one.</p></li><li><p>To obtain a list of unique values, use <code>SELECT</code> <code>DISTINCT</code> rather than <code>SELECT</code>.</p></li><li><p>To count unique values, use <code>COUNT(DISTINCT)</code>
        rather than <code>COUNT()</code>.</p></li></ul><p>The recipes in this chapter first illustrate basic summary
    techniques, and then show how to perform more complex summary operations.
    You’ll find additional examples of summary methods in later chapters,
    particularly those that cover joins and statistical operations. (See <a data-type="xref" href="ch16.xhtml#nch-multi">Chapter 16</a> and <a data-type="xref" href="ch17.xhtml#nch-stats">Chapter 17</a>.)</p><p>Summary queries sometimes involve complex expressions. For summaries
    that you execute often, keep in mind that views can make queries easier to
    use. <a data-type="xref" href="ch05.xhtml#nch-select-select-view">Recipe 5.7</a> demonstrates the basic
    technique of creating a view. <a data-type="xref" href="#nch-sum-sum-view">Recipe 10.5</a> shows
    how it applies to summary simplification, and you’ll easily see how it can
    be used in later sections of the chapter as well.</p><p>The primary tables used for examples in this chapter are the
    <code>driver_log</code> and <code>mail</code> tables. These were also used in <a data-type="xref" href="ch09.xhtml#nch-sort">Chapter 9</a>, so they should look familiar. A third table used
    throughout the chapter is <code>states</code>, which
    has rows containing a few columns of information for each of the United
    States:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM states ORDER BY name;</code></strong>
+----------------+--------+------------+----------+
| name           | abbrev | statehood  | pop      |
+----------------+--------+------------+----------+
| Alabama        | AL     | 1819-12-14 |  5039877 |
| Alaska         | AK     | 1959-01-03 |   732673 |
| Arizona        | AZ     | 1912-02-14 |  7276316 |
| Arkansas       | AR     | 1836-06-15 |  3025891 |
| California     | CA     | 1850-09-09 | 39237836 |
| Colorado       | CO     | 1876-08-01 |  5812069 |
| Connecticut    | CT     | 1788-01-09 |  3605597 |
…</pre><p>The <code>name</code> and <code>abbrev</code> columns list the full state name and the
    corresponding abbreviation. The <code>statehood</code> column indicates the day on which the
    state entered the Union. <code>pop</code> is the
    state population from the 2010 census, as reported by the US Census
    Bureau.</p><p>This chapter uses other tables occasionally as well. You can create
    them with scripts found in the <em class="filename">tables</em>
    directory of the <code>recipes</code>
    distribution. <a data-type="xref" href="ch07.xhtml#nch-strings-strings-full-text-intro">Recipe 7.15</a>
    describes the <code>reviews</code> table.</p></div></section><section data-type="sect1" data-pdf-bookmark="10.1 Summarizing with COUNT()"><div class="sect1" id="nch-sum-sum-basic-count"><h1>10.1 Summarizing with COUNT()</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369213136"><h2>Problem</h2><p>
            You want to count the number of rows in an entire table or that match particular
        conditions.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369211920"><h2>Solution</h2><p>
            Use the <code>COUNT()</code>
        function.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369210432"><h2>Discussion</h2><p>The <code>COUNT()</code>
        function calculates number of rows.
        
        For example, to display the rows in a table, use a <code>SELECT</code> <code>*</code>
        statement, but to count them instead, use <code>SELECT</code> <code>COUNT(*)</code>. Without a <code>WHERE</code> clause, the statement counts all the
        rows in the table, such as in the following statement that shows how
        many rows the <code>driver_log</code> table
        contains:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) FROM driver_log;</code></strong>
+----------+
| COUNT(*) |
+----------+
|       10 |
+----------+</pre><p>If you don’t know how many US states there are (perhaps you
        think there are 57?), this statement tells you:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) FROM states;</code></strong>
+----------+
| COUNT(*) |
+----------+
|       50 |
+----------+</pre><p><code>COUNT(*)</code> with no <code>WHERE</code> clause performs a full table scan unless storage engine optimized this function. For
        MyISAM tables, that stores exact number of rows, this is very quick. For InnoDB tables, that scans all entries in the primary key to perform <code>COUNT(*)</code>, you may want to
        avoid using this function because it can be slow for large tables. If an approximate
        row count is good enough, avoid a full scan by extracting the <code>TABLE_ROWS</code> value from the <code>INFORMATION_SCHEMA</code> database:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">TABLE_ROWS</code> <code class="k">FROM</code> <code class="n">INFORMATION_SCHEMA</code><code class="p">.</code><code class="n">TABLES</code>
<code class="k">WHERE</code> <code class="n">TABLE_SCHEMA</code> <code class="o">=</code> <code class="s1">'cookbook'</code> <code class="k">AND</code> <code class="k">TABLE_NAME</code> <code class="o">=</code> <code class="s1">'states'</code><code class="p">;</code></pre><p>To count only the number of rows that match certain conditions,
        include an appropriate <code>WHERE</code> clause
        in a <code>SELECT</code> <code>COUNT(*)</code> statement. The conditions can be
        chosen to make <code>COUNT(*)</code> useful for
        answering many kinds of questions:</p><ul><li><p>How many times did drivers travel more than 200 miles in a
            day?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) FROM driver_log WHERE miles &gt; 200;</code></strong>
+----------+
| COUNT(*) |
+----------+
|        4 |
+----------+</pre></li><li><p>How many days did Suzi drive?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) FROM driver_log WHERE name = 'Suzi';</code></strong>
+----------+
| COUNT(*) |
+----------+
|        2 |
+----------+</pre></li><li><p>How many of the United States joined the Union in the 19th
            century?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) FROM states</code></strong>
    -&gt; <strong><code>WHERE statehood BETWEEN '1800-01-01' AND '1899-12-31';</code></strong>
+----------+
| COUNT(*) |
+----------+
|       29 |
+----------+</pre></li></ul><p>The <code>COUNT()</code> function actually
        has two forms. The form we’ve been using, <code>COUNT(*)</code>, counts rows. The other form,
        <code>COUNT(</code><em><code>expr</code></em><code>)</code>, takes a column name or expression
        argument and counts the number of non-<code>NULL</code> values. The following statement shows how to produce both a row
        count for a table and a count of the number of non-<code>NULL</code> values in one of its columns:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="k">COUNT</code><code class="p">(</code><code class="o">*</code><code class="p">),</code> <code class="k">COUNT</code><code class="p">(</code><code class="n">mycol</code><code class="p">)</code> <code class="k">FROM</code> <code class="n">mytbl</code><code class="p">;</code></pre><p>The fact that <code>COUNT(</code><em><code>expr</code></em><code>)</code> doesn’t count <code>NULL</code> values is useful for producing multiple
        counts from the same set of rows. To count the number of Saturday and
        Sunday trips in the <code>driver_log</code>
        table with a single statement, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>COUNT(IF(DAYOFWEEK(trav_date)=7,1,NULL)) AS 'Saturday trips',</code></strong>
    -&gt; <strong><code>COUNT(IF(DAYOFWEEK(trav_date)=1,1,NULL)) AS 'Sunday trips'</code></strong>
    -&gt; <strong><code>FROM driver_log;</code></strong>
+----------------+--------------+
| Saturday trips | Sunday trips |
+----------------+--------------+
|              3 |            1 |
+----------------+--------------+</pre><p>Or to count weekend versus weekday trips, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>COUNT(IF(DAYOFWEEK(trav_date) IN (1,7),1,NULL)) AS 'weekend trips',</code></strong>
    -&gt; <strong><code>COUNT(IF(DAYOFWEEK(trav_date) IN (1,7),NULL,1)) AS 'weekday trips'</code></strong>
    -&gt; <strong><code>FROM driver_log;</code></strong>
+---------------+---------------+
| weekend trips | weekday trips |
+---------------+---------------+
|             4 |             6 |
+---------------+---------------+</pre><p>The <code>IF()</code> expressions
        determine, for each column value, whether it should be counted. If
        so, the expression evaluates to <code>1</code>
        and <code>COUNT()</code> counts it. If not, the
        expression evaluates to <code>NULL</code> and
        <code>COUNT()</code> ignores it. The effect is
        to count the number of values that satisfy the condition given as the
        first argument to <code>IF()</code>.</p><div data-type="tip"><h6>Tip</h6><p>
            Function <code>COUNT()</code> calculates number of elements, so you can replace <code>1</code> with any other value. The result will be the same.
          </p></div></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820369210128"><h2>See Also</h2><p>
          For the further discussion on the difference between <code>COUNT(*)</code> and <code>COUNT(expr)</code>, see <a data-type="xref" href="#nch-sum-sum-null">Recipe 10.9</a>.
        </p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.2 Summarizing with MIN() and MAX()"><div class="sect1" id="nch-sum-sum-basic-minmax"><h1>10.2 Summarizing with MIN() and MAX()</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369119648"><h2>Problem</h2><p>
            You want to find the smallest or the largest values in the dataset.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369118560"><h2>Solution</h2><p>
            Use functions <code>MIN()</code> and <code>MAX()</code> correspondingly.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369116752"><h2>Discussion</h2><p>Finding smallest or largest values in a dataset is somewhat akin to
        sorting, except that instead of producing an entire set of sorted
        values, you select only a single value at one end or the other of the
        sorted range. This operation applies to questions about smallest,
        largest, oldest, newest, most expensive, least expensive, and so
        forth. One way to find such values is to use the <code>MIN()</code> and <code>MAX()</code> functions. (Another way is to use
        <code>LIMIT</code>; see <a data-type="xref" href="ch05.xhtml#nch-select-select-limit">Recipe 5.9</a>.)</p><p>Because <code>MIN()</code> and <code>MAX()</code> determine the extreme values in a set,
        they’re useful for characterizing ranges:</p><ul><li><p>What date range is represented by the rows in the <code>mail</code> table? What are the smallest and
            largest messages sent?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>MIN(t) AS earliest, MAX(t) AS latest,</code></strong>
    -&gt; <strong><code>MIN(size) AS smallest, MAX(size) AS largest</code></strong>
    -&gt; <strong><code>FROM mail;</code></strong>
+---------------------+---------------------+----------+---------+
| earliest            | latest              | smallest | largest |
+---------------------+---------------------+----------+---------+
| 2014-05-11 10:15:08 | 2014-05-19 22:21:51 |      271 | 2394482 |
+---------------------+---------------------+----------+---------+</pre></li><li><p>What are the smallest and largest US state
            populations?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT MIN(pop) AS 'fewest people', MAX(pop) AS 'most people'</code></strong>
    -&gt; <strong><code>FROM states;</code></strong>
+---------------+-------------+
| fewest people | most people |
+---------------+-------------+
|        578803 |    39237836 |
+---------------+-------------+</pre></li><li><p>What are the first and last state names, lexically speaking?
            What is the length of the shortest and longest names?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>MIN(name) AS first,</code></strong>
    -&gt; <strong><code>MAX(name) AS last,</code></strong>
    -&gt; <strong><code>MIN(CHAR_LENGTH(name)) AS shortest,</code></strong>
    -&gt; <strong><code>MAX(CHAR_LENGTH(name)) AS longest</code></strong>
    -&gt; <strong><code>FROM states;</code></strong>
+---------+---------+----------+---------+
| first   | last    | shortest | longest |
+---------+---------+----------+---------+
| Alabama | Wyoming |        4 |      14 |
+---------+---------+----------+---------+</pre></li></ul><p>The final query illustrates that <code>MIN()</code> and <code>MAX()</code> need not be applied directly to column
        values; they’re also useful for expressions or values derived from
        column values.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.3 Summarizing with SUM() and AVG()"><div class="sect1" id="nch-sum-sum-basic-sumavg"><h1>10.3 Summarizing with SUM() and AVG()</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369075184"><h2>Problem</h2><p>
            You want to calculate total or average (mean) of a set of values.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369074096"><h2>Solution</h2><p>
            Use functions <code>SUM()</code> and <code>AVG()</code>.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369072240"><h2>Discussion</h2><p><code>SUM()</code> and <code>AVG()</code> produce the total and average (mean) of a set of values:</p><ul><li><p>What is the total amount of mail traffic in bytes and the
            average size of each message?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>SUM(size) AS 'total traffic',</code></strong>
    -&gt; <strong><code>AVG(size) AS 'average message size'</code></strong>
    -&gt; <strong><code>FROM mail;</code></strong>
+---------------+----------------------+
| total traffic | average message size |
+---------------+----------------------+
|       3798185 |          237386.5625 |
+---------------+----------------------+</pre></li><li><p>How many miles did the drivers in the <code>driver_log</code> table travel? What was the
            average number of miles traveled per day?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>SUM(miles) AS 'total miles',</code></strong>
    -&gt; <strong><code>AVG(miles) AS 'average miles/day'</code></strong>
    -&gt; <strong><code>FROM driver_log;</code></strong>
+-------------+-------------------+
| total miles | average miles/day |
+-------------+-------------------+
|        2166 |          216.6000 |
+-------------+-------------------+</pre></li><li><p>What is the total population of the United States?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT SUM(pop) FROM states;</code></strong>
+-----------+
| SUM(pop)  |
+-----------+
| 331223695 |
+-----------+</pre><p>The value represents the population reported for the 2021
            census.</p></li></ul><p><code>SUM()</code> and <code>AVG()</code> are numeric functions, so they can’t
        be used with strings or temporal values. But sometimes you can convert
        nonnumeric values to useful numeric forms. Suppose that a table
        stores <code>TIME</code> values
        that represent elapsed time:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1 FROM time_val;</code></strong>
+----------+
| t1       |
+----------+
| 15:00:00 |
| 05:01:30 |
| 12:30:20 |
+----------+</pre><p>To compute the total elapsed time, use <code>TIME_TO_SEC()</code> to
        convert the values to seconds before summing them. The resulting sum
        is also in seconds; pass it to <code>SEC_TO_TIME()</code> to convert it back to <code>TIME</code> format:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT SUM(TIME_TO_SEC(t1)) AS 'total seconds',</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(SUM(TIME_TO_SEC(t1))) AS 'total time'</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+---------------+------------+
| total seconds | total time |
+---------------+------------+
|        117110 | 32:31:50   |
+---------------+------------+</pre></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820369053792"><h2>See Also</h2><p>The <code>SUM()</code> and <code>AVG()</code> functions are especially useful in
      statistical applications. They’re explored further in <a data-type="xref" href="ch17.xhtml#nch-stats">Chapter 17</a>, along with <code>STD()</code>, a related function that calculates standard deviations.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.4 Using DISTINCT to eliminate duplicates"><div class="sect1" id="nch-sum-sum-basic-distinct"><h1>10.4 Using DISTINCT to eliminate duplicates</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369049424"><h2>Problem</h2><p>
            You want to skip duplicate values when performing calculations.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369048448"><h2>Solution</h2><p>
            Use keyword <code>DISTINCT</code>.
          </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369047040"><h2>Discussion</h2><p>A summary operation that uses no aggregate functions is
        determining the unique values or rows in a dataset. Do this with <code>DISTINCT</code> (or
        <code>DISTINCTROW</code>, a synonym). <code>DISTINCT</code> boils down a query result, and
        often is combined with <code>ORDER</code> <code>BY</code> to place values in more meaningful order.
        This query lists in lexical order the drivers named in the <code>driver_log</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DISTINCT name FROM driver_log ORDER BY name;</code></strong>
+-------+
| name  |
+-------+
| Ben   |
| Henry |
| Suzi  |
+-------+</pre><p>Without <code>DISTINCT</code>, the
        statement produces the same names, but is not nearly as easy to
        understand, even with a small dataset:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name FROM driver_log ORDER BY NAME;</code></strong>
+-------+
| name  |
+-------+
| Ben   |
| Ben   |
| Ben   |
| Henry |
| Henry |
| Henry |
| Henry |
| Henry |
| Suzi  |
| Suzi  |
+-------+</pre><p>To determine the number of different drivers, use <code>COUNT(DISTINCT)</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(DISTINCT name) FROM driver_log;</code></strong>
+----------------------+
| COUNT(DISTINCT name) |
+----------------------+
|                    3 |
+----------------------+</pre><p><code>COUNT(DISTINCT)</code> ignores
        <code>NULL</code> values. To count <code>NULL</code> as
        one of the values in the set if it’s present, use one of the following
        expressions:</p><pre data-type="programlisting" data-code-language="sql">COUNT(DISTINCT <em><code>val</code></em>) + IF(COUNT(IF(<em><code>val</code></em> IS NULL,1,NULL))=0,0,1)
COUNT(DISTINCT <em><code>val</code></em>) + IF(SUM(ISNULL(<em><code>val</code></em>))=0,0,1)
COUNT(DISTINCT <em><code>val</code></em>) + (SUM(ISNULL(<em><code>val</code></em>))&lt;&gt;0);</pre><p>
          In this example we first calculate number of distinct <code>NOT NULL</code> values, then add <code>1</code> if the sum of <code>NULL</code> values is greater than zero.
        </p><p><code>DISTINCT</code> queries often are
        useful in conjunction with aggregate functions to more fully
        characterize your data. Suppose that a <code>customer</code> table contains a <code>state</code> column indicating customer location.
        Applying <code>COUNT(*)</code> to the <code>customer</code> table indicates how many customers
        you have, using <code>DISTINCT</code> on the
        <code>state</code> column tells you the number
        of states in which you have customers, and <code>COUNT(DISTINCT)</code> on the <code>state</code> column tells you how many states your
        customer base represents.</p><p>When used with multiple columns, <code>DISTINCT</code> shows the different combinations of
        values in the columns and <code>COUNT(DISTINCT)</code> counts the number of
        combinations. The following statements show the different
        sender/recipient pairs in the <code>mail</code>
        table and the number of such pairs:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DISTINCT srcuser, dstuser FROM mail</code></strong>
    -&gt; <strong><code>ORDER BY srcuser, dstuser;</code></strong>
+---------+---------+
| srcuser | dstuser |
+---------+---------+
| barb    | barb    |
| barb    | tricia  |
| gene    | barb    |
| gene    | gene    |
| gene    | tricia  |
| phil    | barb    |
| phil    | phil    |
| phil    | tricia  |
| tricia  | gene    |
| tricia  | phil    |
+---------+---------+
mysql&gt; <strong><code>SELECT COUNT(DISTINCT srcuser, dstuser) FROM mail;</code></strong>
+----------------------------------+
| COUNT(DISTINCT srcuser, dstuser) |
+----------------------------------+
|                               10 |
+----------------------------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.5 Creating a View to Simplify Using a Summary"><div class="sect1" id="nch-sum-sum-view"><h1>10.5 Creating a View to Simplify Using a Summary</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369020208"><h2>Problem</h2><p>You want to make it easier to perform a summary.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369019200"><h2>Solution</h2><p>Create a view that does it for you.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369018256"><h2>Discussion</h2><p>If you often need a given summary, a technique that enables you to
      avoid typing the summarizing expressions repeatedly is to use a view
      (see <a data-type="xref" href="ch05.xhtml#nch-select-select-view">Recipe 5.7</a>). For example, the
      following view implements the weekend versus weekday trip summary discussed in <a data-type="xref" href="#nch-sum-sum-basic-count">Recipe 10.1</a>:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE VIEW trip_summary_view AS</code></strong>
    -&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>COUNT(IF(DAYOFWEEK(trav_date) IN (1,7),1,NULL)) AS weekend_trips,</code></strong>
    -&gt; <strong><code>COUNT(IF(DAYOFWEEK(trav_date) IN (1,7),NULL,1)) AS weekday_trips</code></strong>
    -&gt; <strong><code>FROM driver_log;</code></strong></pre><p>Selecting from this view is much easier than selecting directly
      from the underlying table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM trip_summary_view;</code></strong>
+---------------+---------------+
| weekend_trips | weekday_trips |
+---------------+---------------+
|             4 |             6 |
+---------------+---------------+</pre><p>
        While 
      </p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.6 Finding Values Associated with Minimum and Maximum Values"><div class="sect1" id="nch-sum-sum-assoc"><h1>10.6 Finding Values Associated with Minimum and Maximum Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369008800"><h2>Problem</h2><p>You want to know the values for other columns in the row that contains
      a minimum or maximum value.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369007616"><h2>Solution</h2><p>Use two statements and a user-defined variable. Or a subquery. Or
      a join. Or a CTE.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369006560"><h2>Discussion</h2><p><code>MIN()</code> and <code>MAX()</code> find an endpoint of a range of values, but you may also be
      interested in other values from the row in which the value occurs. For
      example, you can find the largest state population like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT MAX(pop) FROM states;</code></strong>
+----------+
| MAX(pop) |
+----------+
| 39237836 |
+----------+</pre><p>But that doesn’t show you which state has this population. The
      obvious attempt at getting that information looks like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT MAX(pop), name FROM states WHERE pop = MAX(pop);</code></strong>
ERROR 1111 (HY000): Invalid use of group function</pre><p>Probably everyone tries something like that sooner or later, but
      it doesn’t work. Aggregate functions such as <code>MIN()</code> and <code>MAX()</code> cannot be used in <code>WHERE</code> clauses, which
      require expressions that apply to individual rows. The intent of the
      statement is to determine which row has the maximum population value and
      display the associated state name. The problem is that although you and
      I know perfectly well what we mean by writing such a thing, it makes no
      sense at all in SQL. The statement fails because SQL uses the <code>WHERE</code> clause to determine which rows to
      select, but the value of an aggregate function is known only
      <em>after</em> selecting the rows from which the function’s
      value is determined! So, in a sense, the statement is
      self-contradictory. To solve this problem, save the maximum population
      value in a user-defined variable, then compare rows to the variable
      value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @max = (SELECT MAX(pop) FROM states);</code></strong>
mysql&gt; <strong><code>SELECT pop AS 'highest population', name FROM states WHERE pop = @max;</code></strong>
+--------------------+------------+
| highest population | name       |
+--------------------+------------+
|           39237836 | California |
+--------------------+------------+</pre><p>Alternatively, for a single-statement solution, use a subquery in the <code>WHERE</code>
      clause that returns the maximum population value:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">pop</code> <code class="k">AS</code> <code class="s1">'highest population'</code><code class="p">,</code> <code class="n">name</code> <code class="k">FROM</code> <code class="n">states</code>
<code class="k">WHERE</code> <code class="n">pop</code> <code class="o">=</code> <code class="p">(</code><code class="k">SELECT</code> <code class="k">MAX</code><code class="p">(</code><code class="n">pop</code><code class="p">)</code> <code class="k">FROM</code> <code class="n">states</code><code class="p">);</code></pre><p>This technique also works even if the minimum or maximum value
      itself isn’t actually contained in the row, but is only derived from it.
      To determine the length of the shortest review in the sample Amazon Reviews
      Data, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT MAX(CHAR_LENGTH(reviews_virtual)) FROM reviews;</code></strong>
+-----------------------------------+
| MIN(CHAR_LENGTH(reviews_virtual)) |
+-----------------------------------+
|                                 2 |
+-----------------------------------+</pre><p>If you want to know <q>Which review is that?</q> do this
      instead:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT JSON_EXTRACT(appliences_review, "$. reviewTime") as ReviewTime,</code></strong>
    -&gt; <strong><code>JSON_EXTRACT(appliences_review, "$.reviewerID") as ReviwerID, </code></strong>
    -&gt; <strong><code>JSON_EXTRACT(appliences_review, "$.asin") as ProductID </code></strong>
    -&gt; <strong><code>JSON_EXTRACT(appliences_review, "$.overall") as Rating FROM </code></strong>
    -&gt; <strong><code>reviews WHERE CHAR_LENGTH(reviews_virtual) = </code></strong>
    -&gt; <strong><code>(SELECT MIN(CHAR_LENGTH(reviews_virtual)) FROM reviews); </code></strong>
+---------------+------------------+--------------+--------+
| ReviewTime    | ReviwerID        | ProductID    | Rating |
+---------------+------------------+--------------+--------+
| "03 8, 2015"  | "A3B1B4E184FSUZ" | "B000VL060M" | 5.0    |
| "03 8, 2015"  | "A3B1B4E184FSUZ" | "B0015UGPWQ" | 5.0    |
| "03 8, 2015"  | "A3B1B4E184FSUZ" | "B000VL060M" | 5.0    |
| "03 8, 2015"  | "A3B1B4E184FSUZ" | "B0015UGPWQ" | 5.0    |
| "02 9, 2015"  | "A3B1B4E184FSUZ" | "B0042U16YI" | 5.0    |
| "07 25, 2016" | "AJPRN1TD1A0SD"  | "B00BIZDI0A" | 3.0    |
+---------------+------------------+--------------+--------+</pre><p>Yet another way to select other columns from rows containing a
      minimum or maximum value is to use a join. Select the value into another table, then join it to
      the original table to select the row that matches the value. To find the
      row for the state with the highest population, use a join like
      this:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TEMPORARY TABLE tmp SELECT MAX(pop) as maxpop FROM states;</code></strong>
mysql&gt; <strong><code>SELECT states.* FROM states INNER JOIN tmp</code></strong>
    -&gt; <strong><code>ON states.pop = tmp.maxpop;</code></strong>
+------------+--------+------------+----------+
| name       | abbrev | statehood  | pop      |
+------------+--------+------------+----------+
| California | CA     | 1850-09-09 | 39237836 |
+------------+--------+------------+----------+</pre><p>
       As of MySQL 8.0 you can use Common Table Expressions (CTE) to perform the same search.
     </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">WITH</code><code> </code><code class="n">maxpop</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">AS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="k">MAX</code><code class="p">(</code><code class="n">pop</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">maxpop</code><code> </code><code class="k">FROM</code><code> </code><code class="n">states</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">states</code><code class="p">.</code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">states</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">JOIN</code><code> </code><code class="n">maxpop</code><code> </code><code class="k">ON</code><code> </code><code class="n">states</code><code class="p">.</code><code class="n">pop</code><code> </code><code class="o">=</code><code> </code><code class="n">maxpop</code><code class="p">.</code><code class="n">maxpop</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">------------+--------+------------+----------+
</code><code class="o">|</code><code> </code><code class="n">name</code><code>       </code><code class="o">|</code><code> </code><code class="n">abbrev</code><code> </code><code class="o">|</code><code> </code><code class="n">statehood</code><code>  </code><code class="o">|</code><code> </code><code class="n">pop</code><code>      </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">------------+--------+------------+----------+
</code><code class="o">|</code><code> </code><code class="n">California</code><code> </code><code class="o">|</code><code> </code><code class="n">CA</code><code>     </code><code class="o">|</code><code> </code><code class="mi">1850</code><code class="o">-</code><code class="mi">09</code><code class="o">-</code><code class="mi">09</code><code> </code><code class="o">|</code><code> </code><code class="mi">39237836</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">------------+--------+------------+----------+
</code><code class="mi">1</code><code> </code><code class="k">row</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">.</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
       Two above code snippets use the same idea: create a temporary table to store the maximum population number and join it with the original table. But latter performs this operation in the single query, so you do not need to care about destroying the temporary table after getting the result. We discuss CTE in detail in <a data-type="xref" href="#nch-sum-sum-with">Recipe 10.18</a>.
     </p></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820369006256"><h2>See Also</h2><p><a data-type="xref" href="ch16.xhtml#nch-multi-multi-per-group">Recipe 16.7</a> extends the
      discussion here to the problem of finding rows that contain minimum or
      maximum values for multiple groups in a dataset.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.7 Controlling String Case Sensitivity for MIN() and MAX()"><div class="sect1" id="nch-sum-sum-string"><h1>10.7 Controlling String Case Sensitivity for MIN() and MAX()</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368844080"><h2>Problem</h2><p><code>MIN()</code> and <code>MAX()</code> select strings in case-sensitive fashion when you don’t want them
      to, or vice versa.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368842384"><h2>Solution</h2><p>Use different comparison characteristics of the strings.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368841440"><h2>Discussion</h2><p><a data-type="xref" href="ch07.xhtml#nch-strings-strings-properties">Recipe 7.1</a> discusses how
      string-comparison properties depend on whether the strings are binary or
      nonbinary:</p><ul><li><p>Binary strings are sequences of bytes. They are compared byte
          by byte using numeric byte values. Character set and lettercase have
          no meaning for comparisons.</p></li><li><p>Nonbinary strings are sequences of characters. They have a character set and
          collation and are compared character by character using the order
          defined by the collation.</p></li></ul><p>These properties also apply to string columns used as the argument
      to the <code>MIN()</code> or <code>MAX()</code> function because they are based on
      comparison. To alter how these functions work with a string column,
      alter the column’s comparison properties. <a data-type="xref" href="ch07.xhtml#nch-strings-strings-compare">Recipe 7.7</a> discusses how to control these
      properties, and <a data-type="xref" href="ch09.xhtml#nch-sort-sort-string">Recipe 9.4</a> shows how they
      apply to string sorts. The same principles apply to finding minimum and
      maximum string values, so I’ll just summarize here; read <a data-type="xref" href="ch09.xhtml#nch-sort-sort-string">Recipe 9.4</a> for additional details.</p><ul><li><p>To compare case-insensitive strings in case-sensitive fashion,
          order the values using a case-sensitive collation:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code>
<code class="k">MIN</code><code class="p">(</code><code class="n">str_col</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_as_cs</code><code class="p">)</code> <code class="k">AS</code> <code class="k">min</code><code class="p">,</code>
<code class="k">MAX</code><code class="p">(</code><code class="n">str_col</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_as_cs</code><code class="p">)</code> <code class="k">AS</code> <code class="k">max</code>
<code class="k">FROM</code> <code class="n">tbl</code><code class="p">;</code></pre></li><li><p>To compare case-sensitive strings in case-insensitive fashion,
          order the values using a case-insensitive collation:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code>
<code class="k">MIN</code><code class="p">(</code><code class="n">str_col</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_ai_ci</code><code class="p">)</code> <code class="k">AS</code> <code class="k">min</code><code class="p">,</code>
<code class="k">MAX</code><code class="p">(</code><code class="n">str_col</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_ai_ci</code><code class="p">)</code> <code class="k">AS</code> <code class="k">max</code>
<code class="k">FROM</code> <code class="n">tbl</code><code class="p">;</code></pre><p>Another possibility is to compare values that have all been
          converted to the same lettercase, which makes lettercase irrelevant.
          However, that also changes the retrieved values:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code>
<code class="k">MIN</code><code class="p">(</code><code class="k">UPPER</code><code class="p">(</code><code class="n">str_col</code><code class="p">))</code> <code class="k">AS</code> <code class="k">min</code><code class="p">,</code>
<code class="k">MAX</code><code class="p">(</code><code class="k">UPPER</code><code class="p">(</code><code class="n">str_col</code><code class="p">))</code> <code class="k">AS</code> <code class="k">max</code>
<code class="k">FROM</code> <code class="n">tbl</code><code class="p">;</code></pre></li><li><p>Binary strings compare using numeric byte values, so there is
          no concept of lettercase involved. However, because letters in
          different cases have different byte values, comparisons of binary
          strings effectively are case sensitive. (That is, <code>a</code> and <code>A</code>
          are unequal.) To compare binary strings using a case-insensitive
          ordering, convert them to nonbinary strings and apply an appropriate
          collation:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code>
<code class="k">MIN</code><code class="p">(</code><code class="k">CONVERT</code><code class="p">(</code><code class="n">str_col</code> <code class="k">USING</code> <code class="n">utf8mb4</code><code class="p">)</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_ai_ci</code><code class="p">)</code> <code class="k">AS</code> <code class="k">min</code><code class="p">,</code>
<code class="k">MAX</code><code class="p">(</code><code class="k">CONVERT</code><code class="p">(</code><code class="n">str_col</code> <code class="k">USING</code> <code class="n">utf8mb4</code><code class="p">)</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_ai_ci</code><code class="p">)</code> <code class="k">AS</code> <code class="k">max</code>
<code class="k">FROM</code> <code class="n">tbl</code><code class="p">;</code></pre><p>If the default collation is case insensitive (as is true for
          <code>utf8mb4</code>), you can omit the
          <code>COLLATE</code> clause.</p></li></ul></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.8 Dividing a Summary into Subgroups"><div class="sect1" id="nch-sum-sum-subgroup"><h1>10.8 Dividing a Summary into Subgroups</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368585504"><h2>Problem</h2><p>You want a summary for each subgroup of a set of rows, not an overall summary
      value.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368584512"><h2>Solution</h2><p>Use a <code>GROUP</code> <code>BY</code> clause to arrange rows into groups.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368582704"><h2>Discussion</h2><p>The summary statements shown so far calculate summary values over
      all rows in the result set. For example, the following statement
      determines the number of records in the <code>mail</code> table, and thus the total number of mail
      messages sent:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) FROM mail;</code></strong>
+----------+
| COUNT(*) |
+----------+
|       16 |
+----------+</pre><p>To arrange a set of rows into subgroups and summarize each group,
      use aggregate functions in conjunction with a <code>GROUP</code> <code>BY</code>
      clause. To determine the number of messages per sender, group the rows
      by sender name, count how many times each name occurs, and display the
      names with the counts:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser, COUNT(*) FROM mail GROUP BY srcuser;</code></strong>
+---------+----------+
| srcuser | COUNT(*) |
+---------+----------+
| barb    |        3 |
| gene    |        6 |
| phil    |        5 |
| tricia  |        2 |
+---------+----------+</pre><p>That query summarizes the same column that is used for grouping
      (<code>srcuser</code>), but that’s not always
      necessary. Suppose that you want a quick characterization of the
      <code>mail</code> table, showing for each sender
      listed in it the total amount of traffic sent (in bytes) and the average
      number of bytes per message. In this case, you still use the <code>srcuser</code> column to group the rows, but
      summarize the <code>size</code> values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser,</code></strong>
    -&gt; <strong><code>SUM(size) AS 'total bytes',</code></strong>
    -&gt; <strong><code>AVG(size) AS 'bytes per message'</code></strong>
    -&gt; <strong><code>FROM mail GROUP BY srcuser;</code></strong>
+---------+-------------+-------------------+
| srcuser | total bytes | bytes per message |
+---------+-------------+-------------------+
| barb    |      156696 |        52232.0000 |
| gene    |     1033108 |       172184.6667 |
| phil    |       18974 |         3794.8000 |
| tricia  |     2589407 |      1294703.5000 |
+---------+-------------+-------------------+</pre><p>Use as many grouping columns as necessary to achieve a grouping as
      fine-grained as you require. The earlier query that shows the number of
      messages per sender is a coarse summary. To be more specific and find
      out how many messages each sender sent from each host, use two grouping
      columns. This produces a result with nested groups (groups within groups):</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser, srchost, COUNT(srcuser) FROM mail</code></strong>
    -&gt; <strong><code>GROUP BY srcuser, srchost;</code></strong>
+---------+---------+----------------+
| srcuser | srchost | COUNT(srcuser) |
+---------+---------+----------------+
| barb    | saturn  |              2 |
| barb    | venus   |              1 |
| gene    | mars    |              2 |
| gene    | saturn  |              2 |
| gene    | venus   |              2 |
| phil    | mars    |              3 |
| phil    | venus   |              2 |
| tricia  | mars    |              1 |
| tricia  | saturn  |              1 |
+---------+---------+----------------+</pre><p>The preceding examples in this section used <code>COUNT()</code>, <code>SUM()</code>, and <code>AVG()</code> for per-group summaries. You can
      use <code>MIN()</code> or <code>MAX()</code>, too. With a <code>GROUP</code> <code>BY</code>
      clause, they return the smallest or largest value per group. The
      following query groups <code>mail</code> table
      rows by message sender, displaying for each the size of the largest
      message sent and the date of the most recent message:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser, MAX(size), MAX(t) FROM mail GROUP BY srcuser;</code></strong>
+---------+-----------+---------------------+
| srcuser | MAX(size) | MAX(t)              |
+---------+-----------+---------------------+
| barb    |     98151 | 2014-05-14 14:42:21 |
| gene    |    998532 | 2014-05-19 22:21:51 |
| phil    |     10294 | 2014-05-19 12:49:23 |
| tricia  |   2394482 | 2014-05-14 17:03:01 |
+---------+-----------+---------------------+</pre><p>You can group by multiple columns and display a maximum for each
      combination of values in those columns. This query finds the size of the
      largest message sent between each pair of sender and recipient values
      listed in the <code>mail</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser, dstuser, MAX(size) FROM mail GROUP BY srcuser, dstuser;</code></strong>
+---------+---------+-----------+
| srcuser | dstuser | MAX(size) |
+---------+---------+-----------+
| barb    | barb    |     98151 |
| barb    | tricia  |     58274 |
| gene    | barb    |      2291 |
| gene    | gene    |     23992 |
| gene    | tricia  |    998532 |
| phil    | barb    |     10294 |
| phil    | phil    |      1048 |
| phil    | tricia  |      5781 |
| tricia  | gene    |    194925 |
| tricia  | phil    |   2394482 |
+---------+---------+-----------+</pre><p>When using aggregate functions to produce per-group summary
      values, watch out for the following trap, which involves selecting
      nonsummary table columns not related to the grouping columns. Suppose
      that you want to know the longest trip per driver in the <code>driver_log</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, MAX(miles) AS 'longest trip'</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY name;</code></strong>
+-------+--------------+
| name  | longest trip |
+-------+--------------+
| Ben   |          152 |
| Henry |          300 |
| Suzi  |          502 |
+-------+--------------+</pre><p>But what if you also want to show the date on which each driver’s
      longest trip occurred? Can you just add <code>trav_date</code> to the output column list? Sorry,
      that doesn’t work:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, trav_date, MAX(miles) AS 'longest trip'</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY name;</code></strong>
+-------+------------+--------------+
| name  | trav_date  | longest trip |
+-------+------------+--------------+
| Ben   | 2014-07-30 |          152 |
| Henry | 2014-07-29 |          300 |
| Suzi  | 2014-07-29 |          502 |
+-------+------------+--------------+</pre><p>The query does produce a result, but if you compare it to the full
      table (shown here), you’ll see that although the dates for Ben and Henry
      are correct, the date for Suzi is not:</p><pre data-type="programlisting">+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      1 | Ben   | 2014-07-30 |   152 |    <code class="lineannotation">← Ben's longest trip</code>
|      2 | Suzi  | 2014-07-29 |   391 |
|      3 | Henry | 2014-07-29 |   300 |    <code class="lineannotation">← Henry's longest trip</code>
|      4 | Henry | 2014-07-27 |    96 |
|      5 | Ben   | 2014-07-29 |   131 |
|      6 | Henry | 2014-07-26 |   115 |
|      7 | Suzi  | 2014-08-02 |   502 |    <code class="lineannotation">← Suzi's longest trip</code>
|      8 | Henry | 2014-08-01 |   197 |
|      9 | Ben   | 2014-08-02 |    79 |
|     10 | Henry | 2014-07-30 |   203 |
+--------+-------+------------+-------+</pre><p>So what’s going on? Why does the summary statement produce
      incorrect results? This happens because when you include a <code>GROUP</code> <code>BY</code>
      clause in a query, the only values that you can meaningfully select are
      the grouping columns or summary values calculated from the groups. If
      you display additional table columns, they’re not tied to the grouped
      columns and the values displayed for them are indeterminate. (For the
      statement just shown, it appears that MySQL may simply be picking the
      first date for each driver, regardless of whether it matches the
      driver’s maximum mileage value.)</p><p>To make queries that pick indeterminate values illegal so that you
      won’t inadvertantly suppose that the <code>trav_date</code> values are correct, set the <code>ONLY_FULL_GROUP_BY</code>
      SQL mode:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET sql_mode = 'ONLY_FULL_GROUP_BY';</code></strong>
mysql&gt; <strong><code>SELECT name, trav_date, MAX(miles) AS 'longest trip'</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY name;</code></strong>
ERROR 1055 (42000): 'cookbook.driver_log.trav_date' isn't in GROUP BY</pre><p>
       SQL Mode <code>ONLY_FULL_GROUP_BY</code> is part of the default settings since MySQL 5.7. However, we have seen many legacy applications that disable this option. We suggest you to always have <code>ONLY_FULL_GROUP_BY</code> enabled and fix queries that return error otherwise.
     </p><p>The general solution to the problem of displaying contents of rows
      associated with minimum or maximum group values involves a join. The
      technique is described in <a data-type="xref" href="ch16.xhtml#nch-multi-multi-per-group">Recipe 16.7</a>.
      For the problem at hand, produce the required results as follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TEMPORARY TABLE t</code></strong>
    -&gt; <strong><code>SELECT name, MAX(miles) AS miles FROM driver_log GROUP BY name;</code></strong>
mysql&gt; <strong><code>SELECT d.name, d.trav_date, d.miles AS 'longest trip'</code></strong>
    -&gt; <strong><code>FROM driver_log AS d INNER JOIN t USING (name, miles) ORDER BY name;</code></strong>
+-------+------------+--------------+
| name  | trav_date  | longest trip |
+-------+------------+--------------+
| Ben   | 2014-07-30 |          152 |
| Henry | 2014-07-29 |          300 |
| Suzi  | 2014-08-02 |          502 |
+-------+------------+--------------+</pre><p>
       Or, by using CTE:
       </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="k">WITH</code><code> </code><code class="n">t</code><code> </code><code class="k">AS</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">name</code><code class="p">,</code><code> </code><code class="k">MAX</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">miles</code><code> </code><code class="k">FROM</code><code> </code><code class="n">driver_log</code><code> </code><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">name</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="k">SELECT</code><code> </code><code class="n">d</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code> </code><code class="n">d</code><code class="p">.</code><code class="n">trav_date</code><code class="p">,</code><code> </code><code class="n">d</code><code class="p">.</code><code class="n">miles</code><code> </code><code class="k">AS</code><code> </code><code class="s1">'longest trip'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="k">FROM</code><code> </code><code class="n">driver_log</code><code> </code><code class="k">AS</code><code> </code><code class="n">d</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">t</code><code> </code><code class="k">USING</code><code> </code><code class="p">(</code><code class="n">name</code><code class="p">,</code><code> </code><code class="n">miles</code><code class="p">)</code><code> </code><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">name</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">-------+------------+--------------+
</code><code class="o">|</code><code> </code><code class="n">name</code><code>  </code><code class="o">|</code><code> </code><code class="n">trav_date</code><code>  </code><code class="o">|</code><code> </code><code class="n">longest</code><code> </code><code class="n">trip</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">-------+------------+--------------+
</code><code class="o">|</code><code> </code><code class="n">Ben</code><code>   </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">30</code><code> </code><code class="o">|</code><code>          </code><code class="mi">152</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Henry</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">29</code><code> </code><code class="o">|</code><code>          </code><code class="mi">300</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Suzi</code><code>  </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">02</code><code> </code><code class="o">|</code><code>          </code><code class="mi">502</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">-------+------------+--------------+
</code><code class="mi">3</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">.</code><code class="mi">01</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
     </p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.9 Handling NULL Values with Aggregate Functions"><div class="sect1" id="nch-sum-sum-null"><h1>10.9 Handling NULL Values with Aggregate Functions</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368382800"><h2>Problem</h2><p>You’re summarizing a set of values that may include <code>NULL</code> values and you need to know how to
      interpret the results.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368381360"><h2>Solution</h2><p>Understand how aggregate functions handle <code>NULL</code> values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368380096"><h2>Discussion</h2><p>Most aggregate functions ignore <code>NULL</code> values.
      <code>COUNT()</code> is different: <code>COUNT(</code><em><code>expr</code></em><code>)</code> ignores <code>NULL</code> instances of
      <em><code>expr</code></em>, but <code>COUNT(*)</code> counts rows, regardless of
      content.</p><p>Suppose that an <code>expt</code> table
      contains experimental results for subjects who are to be given four
      tests each and that lists the test score as <code>NULL</code> for tests not yet administered:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject, test, score FROM expt ORDER BY subject, test;</code></strong>
+---------+------+-------+
| subject | test | score |
+---------+------+-------+
| Jane    | A    |    47 |
| Jane    | B    |    50 |
| Jane    | C    |  NULL |
| Jane    | D    |  NULL |
| Marvin  | A    |    52 |
| Marvin  | B    |    45 |
| Marvin  | C    |    53 |
| Marvin  | D    |  NULL |
+---------+------+-------+</pre><p>By using a <code>GROUP</code> <code>BY</code> clause to arrange the rows by subject name, the number of tests
      taken by each subject, as well as the total, average, lowest, and
      highest scores, can be calculated like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject,</code></strong>
    -&gt; <strong><code>COUNT(score) AS n,</code></strong>
    -&gt; <strong><code>SUM(score) AS total,</code></strong>
    -&gt; <strong><code>AVG(score) AS average,</code></strong>
    -&gt; <strong><code>MIN(score) AS lowest,</code></strong>
    -&gt; <strong><code>MAX(score) AS highest</code></strong>
    -&gt; <strong><code>FROM expt GROUP BY subject;</code></strong>
+---------+---+-------+---------+--------+---------+
| subject | n | total | average | lowest | highest |
+---------+---+-------+---------+--------+---------+
| Jane    | 2 |    97 | 48.5000 |     47 |      50 |
| Marvin  | 3 |   150 | 50.0000 |     45 |      53 |
+---------+---+-------+---------+--------+---------+</pre><p>You can see from the results in the column labeled <code>n</code> (number of tests) that the query counts only
      five values, even though the table contains eight. Why? Because the
      values in that column correspond to the number of non-<code>NULL</code> test scores for each subject. The other
      summary columns display results that are calculated only from the
      non-<code>NULL</code> scores as well.</p><p>It makes a lot of sense for aggregate functions to ignore <code>NULL</code> values. If they followed the usual SQL
      arithmetic rules, adding <code>NULL</code> to any
      other value would produce a <code>NULL</code>
      result. That would make aggregate functions really difficult to use: to
      avoid getting a <code>NULL</code> result, you’d
      have to filter out <code>NULL</code> values every
      time you performed a summary. By ignoring <code>NULL</code> values, aggregate functions become a lot
      more convenient.</p><p>However, be aware that even though aggregate functions may ignore
      <code>NULL</code> values, some of them can still
      produce <code>NULL</code> as a result. This
      happens if there’s nothing to summarize, which occurs if the set of
      values is empty or contains only <code>NULL</code>
      values. The following query is the same as the previous one, with one
      small difference. It selects only <code>NULL</code> test scores to illustrate what happens
      when there’s nothing for the aggregate functions to operate on:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject,</code></strong>
    -&gt; <strong><code>COUNT(score) AS n,</code></strong>
    -&gt; <strong><code>SUM(score) AS total,</code></strong>
    -&gt; <strong><code>AVG(score) AS average,</code></strong>
    -&gt; <strong><code>MIN(score) AS lowest,</code></strong>
    -&gt; <strong><code>MAX(score) AS highest</code></strong>
    -&gt; <strong><code>FROM expt WHERE score IS NULL GROUP BY subject;</code></strong>
+---------+---+-------+---------+--------+---------+
| subject | n | total | average | lowest | highest |
+---------+---+-------+---------+--------+---------+
| Jane    | 0 |  NULL |    NULL |   NULL |    NULL |
| Marvin  | 0 |  NULL |    NULL |   NULL |    NULL |
+---------+---+-------+---------+--------+---------+</pre><p>For <code>COUNT()</code>, the number of
      scores per subject is zero and is reported that way. On the other hand,
      <code>SUM()</code>, <code>AVG()</code>, <code>MIN()</code>, and <code>MAX()</code> return <code>NULL</code> when there are no values to summarize. If you don’t want an
      aggregate value of <code>NULL</code> to display as
      <code>NULL</code>, use <code>IFNULL()</code> to map it
      appropriately:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject,</code></strong>
    -&gt; <strong><code>COUNT(score) AS n,</code></strong>
    -&gt; <strong><code>IFNULL(SUM(score),0) AS total,</code></strong>
    -&gt; <strong><code>IFNULL(AVG(score),0) AS average,</code></strong>
    -&gt; <strong><code>IFNULL(MIN(score),'Unknown') AS lowest,</code></strong>
    -&gt; <strong><code>IFNULL(MAX(score),'Unknown') AS highest</code></strong>
    -&gt; <strong><code>FROM expt WHERE score IS NULL GROUP BY subject;</code></strong>
+---------+---+-------+---------+---------+---------+
| subject | n | total | average | lowest  | highest |
+---------+---+-------+---------+---------+---------+
| Jane    | 0 |     0 |  0.0000 | Unknown | Unknown |
| Marvin  | 0 |     0 |  0.0000 | Unknown | Unknown |
+---------+---+-------+---------+---------+---------+</pre><p><code>COUNT()</code> is somewhat different
      with regard to <code>NULL</code> values than the
      other aggregate functions. Like other aggregate functions, <code>COUNT(</code><em><code>expr</code></em><code>)</code> counts only non-<code>NULL</code> values, but <code>COUNT(*)</code> counts rows, no matter what they
      contain. You can see the difference between the forms of <code>COUNT()</code> like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*), COUNT(score) FROM expt;</code></strong>
+----------+--------------+
| COUNT(*) | COUNT(score) |
+----------+--------------+
|        8 |            5 |
+----------+--------------+</pre><p>This tells us that there are eight rows in the <code>expt</code> table but that only five of them have the
      <code>score</code> value filled in. The different
      forms of <code>COUNT()</code> can be very useful
      for counting missing values. Just take the difference:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) - COUNT(score) AS missing FROM expt;</code></strong>
+---------+
| missing |
+---------+
|       3 |
+---------+</pre><p>Missing and nonmissing counts can be determined for subgroups as
      well. The following query does so for each subject, providing an easy
      way to assess the extent to which the experiment has been completed:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject,</code></strong>
    -&gt; <strong><code>COUNT(*) AS total,</code></strong>
    -&gt; <strong><code>COUNT(score) AS 'nonmissing',</code></strong>
    -&gt; <strong><code>COUNT(*) - COUNT(score) AS missing</code></strong>
    -&gt; <strong><code>FROM expt GROUP BY subject;</code></strong>
+---------+-------+------------+---------+
| subject | total | nonmissing | missing |
+---------+-------+------------+---------+
| Jane    |     4 |          2 |       2 |
| Marvin  |     4 |          3 |       1 |
+---------+-------+------------+---------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.10 Selecting Only Groups with Certain Characteristics"><div class="sect1" id="nch-sum-sum-group"><h1>10.10 Selecting Only Groups with Certain Characteristics</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368308400"><h2>Problem</h2><p>You want to calculate group summaries but display results only for groups that
      match certain criteria.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368307328"><h2>Solution</h2><p>Use a <code>HAVING</code> clause.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368305936"><h2>Discussion</h2><p>You’re familiar with the use of <code>WHERE</code> to specify
      conditions that rows must satisfy to be selected by a statement. It’s
      natural, therefore, to use <code>WHERE</code> to
      write conditions that involve summary values. The only trouble is that
      it doesn’t work. To identify drivers in the <code>driver_log</code> table who drove more than three
      days, you might write the statement like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*), name FROM driver_log</code></strong>
    -&gt; <strong><code>WHERE COUNT(*) &gt; 3</code></strong>
    -&gt; <strong><code>GROUP BY name;</code></strong>
ERROR 1111 (HY000): Invalid use of group function</pre><p>The problem is that <code>WHERE</code>
      specifies the initial constraints that determine which rows to select,
      but the value of <code>COUNT()</code> can
      be determined only after the rows have been selected. The
      solution is to put the <code>COUNT()</code>
      expression in a <code>HAVING</code> clause
      instead. <code>HAVING</code> is analogous to
      <code>WHERE</code>, but it applies to group
      characteristics rather than to single rows. That is, <code>HAVING</code> operates on the
      already-selected-and-grouped set of rows, applying additional
      constraints based on aggregate function results that aren’t known during
      the initial selection process. The preceding query therefore should be
      written like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*), name FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY name</code></strong>
    -&gt; <strong><code>HAVING COUNT(*) &gt; 3;</code></strong>
+----------+-------+
| COUNT(*) | name  |
+----------+-------+
|        5 | Henry |
+----------+-------+</pre><p>When you use <code>HAVING</code>, you can
      still include a <code>WHERE</code> clause, but
      only to select rows to be summarized, not to test already calculated
      summary values.</p><p><code>HAVING</code> can refer to aliases, so the previous query can be rewritten like
      this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) AS count, name FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY name</code></strong>
    -&gt; <strong><code>HAVING count &gt; 3;</code></strong>
+-------+-------+
| count | name  |
+-------+-------+
|     5 | Henry |
+-------+-------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.11 Using Counts to Determine Whether Values Are Unique"><div class="sect1" id="nch-sum-sum-unique"><h1>10.11 Using Counts to Determine Whether Values Are Unique</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368289584"><h2>Problem</h2><p>You want to know whether values in a table are unique.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368288544"><h2>Solution</h2><p>Use <code>HAVING</code> in conjunction with
      <code>COUNT()</code>.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368286736"><h2>Discussion</h2><p><code>DISTINCT</code> eliminates duplicates
      but doesn’t show which values actually were duplicated in the
      original data. You can use <code>HAVING</code> to
      find unique values in situations to which <code>DISTINCT</code> does not apply. <code>HAVING</code> can tell you which values were unique
      or nonunique.</p><p>The following statements show the days on which only one driver
      was active, and the days on which more than one driver was active.
      They’re based on using <code>HAVING</code> and
      <code>COUNT()</code> to determine which <code>trav_date</code> values are unique or
      nonunique:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT trav_date, COUNT(trav_date) FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY trav_date HAVING COUNT(trav_date) = 1;</code></strong>
+------------+------------------+
| trav_date  | COUNT(trav_date) |
+------------+------------------+
| 2014-07-26 |                1 |
| 2014-07-27 |                1 |
| 2014-08-01 |                1 |
+------------+------------------+
mysql&gt; <strong><code>SELECT trav_date, COUNT(trav_date) FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY trav_date HAVING COUNT(trav_date) &gt; 1;</code></strong>
+------------+------------------+
| trav_date  | COUNT(trav_date) |
+------------+------------------+
| 2014-07-29 |                3 |
| 2014-07-30 |                2 |
| 2014-08-02 |                2 |
+------------+------------------+</pre><p>This technique works for combinations of values, too. For example,
      to find message sender/recipient pairs between whom only one message was
      sent, look for combinations that occur only once in the <code>mail</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser, dstuser FROM mail</code></strong>
    -&gt; <strong><code>GROUP BY srcuser, dstuser HAVING COUNT(*) = 1;</code></strong>
+---------+---------+
| srcuser | dstuser |
+---------+---------+
| barb    | barb    |
| gene    | tricia  |
| phil    | barb    |
| tricia  | gene    |
| tricia  | phil    |
+---------+---------+</pre><p>Note that this query doesn’t print the count. The previous
      examples did so, to show that the counts were being used properly, but
      you can refer to an aggregate value in a <code>HAVING</code> clause without including it in the
      output column list.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.12 Grouping by Expression Results"><div class="sect1" id="nch-sum-sum-expr"><h1>10.12 Grouping by Expression Results</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368274640"><h2>Problem</h2><p>You want to group rows into subgroups based on values calculated from an
      expression.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368273552"><h2>Solution</h2><p>In the <code>GROUP</code> <code>BY</code> clause, use an expression that categorizes values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368271648"><h2>Discussion</h2><p><code>GROUP</code> <code>BY</code>, like <code>ORDER</code> <code>BY</code>,
      can refer to expressions. This means you can use calculations as the
      basis for grouping. As with <code>ORDER</code>
      <code>BY</code>, you can write the grouping
      expression directly in the <code>GROUP</code>
      <code>BY</code> clause, or use an alias for the
      expression (if it appears in the output column list), and refer to the
      alias in the <code>GROUP</code> <code>BY</code>.</p><p>To find days of the year on which more than one state joined the
      Union, group by statehood month and day, and then use <code>HAVING</code> and <code>COUNT()</code> to find the nonunique combinations:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>MONTHNAME(statehood) AS month,</code></strong>
    -&gt; <strong><code>DAYOFMONTH(statehood) AS day,</code></strong>
    -&gt; <strong><code>COUNT(*) AS count</code></strong>
    -&gt; <strong><code>FROM states GROUP BY month, day HAVING count &gt; 1;</code></strong>
+----------+------+-------+
| month    | day  | count |
+----------+------+-------+
| February |   14 |     2 |
| June     |    1 |     2 |
| March    |    1 |     2 |
| May      |   29 |     2 |
| November |    2 |     2 |
+----------+------+-------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.13 Summarizing Noncategorical Data"><div class="sect1" id="nch-sum-sum-noncat"><h1>10.13 Summarizing Noncategorical Data</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368260112"><h2>Problem</h2><p>You want to summarize a set of values that are not naturally
      categorical.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368259168"><h2>Solution</h2><p>Use an expression to group the values into categories.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368258160"><h2>Discussion</h2><p><a data-type="xref" href="#nch-sum-sum-expr">Recipe 10.12</a> shows how to group rows by expression results. One
      important application for this is to categorize values that are not
      categorical. This is useful because <code>GROUP</code> <code>BY</code>
      works best for columns with repetitive values. For example, you might
      attempt to perform a population analysis by grouping rows in the
      <code>states</code> table using values in the
      <code>pop</code> column. That doesn’t work very
      well due to the high number of distinct values in the column. In fact,
      they’re <em>all</em> distinct:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(pop), COUNT(DISTINCT pop) FROM states;</code></strong>
+------------+---------------------+
| COUNT(pop) | COUNT(DISTINCT pop) |
+------------+---------------------+
|         50 |                  50 |
+------------+---------------------+</pre><p>In situations like this, in which values do not group nicely into
      a small number of sets, use a transformation that forces them into
      categories. Begin by determining the range of population values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT MIN(pop), MAX(pop) FROM states;</code></strong>
+----------+----------+
| MIN(pop) | MAX(pop) |
+----------+----------+
|   578803 | 39237836 |
+----------+----------+</pre><p>You can see from that result that if you divide the <code>pop</code> values by five million, they’ll group into
      eight categories—a reasonable number. (The category ranges will be 1 to
      5,000,000, 5,000,001 to 10,000,000, and so forth.) To put each
      population value in the proper category, divide by five million, and use
      the integer result:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT FLOOR(pop/5000000) AS `max population (millions)`,</code></strong>
    -&gt; <strong><code>COUNT(*) AS `number of states`</code></strong>
    -&gt; <strong><code>FROM states GROUP BY `max population (millions)`</code></strong>
    -&gt; <strong><code>ORDER BY `max population (millions)`;</code></strong>
+---------------------------+------------------+
| max population (millions) | number of states |
+---------------------------+------------------+
|                         0 |               26 |
|                         1 |               14 |
|                         2 |                6 |
|                         3 |                1 |
|                         4 |                1 |
|                         5 |                1 |
|                         7 |                1 |
+---------------------------+------------------+</pre><p>Hmm. That’s not quite right. The expression groups the population
      values into a small number of categories, but doesn’t report the
      category values properly. Let’s try multiplying the <code>FLOOR()</code> results by
      five:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT FLOOR(pop/5000000)*5 AS `max population (millions)`,</code></strong>
    -&gt; <strong><code>COUNT(*) AS `number of states`</code></strong>
    -&gt; <strong><code>FROM states GROUP BY `max population (millions)`</code></strong>
    -&gt; <strong><code>ORDER BY `max population (millions)`;</code></strong>
+---------------------------+------------------+
| max population (millions) | number of states |
+---------------------------+------------------+
|                         0 |               26 |
|                         5 |               14 |
|                        10 |                6 |
|                        15 |                1 |
|                        20 |                1 |
|                        25 |                1 |
|                        35 |                1 |
+---------------------------+------------------+</pre><p>That still isn’t correct. The maximum state population was
      35,893,799, which should go into a category for 40 million, not one for
      35 million. The problem here is that the category-generating expression
      groups values toward the lower bound of each category. To group values
      toward the upper bound instead, use the following technique. For
      categories of size <em><code>n</code></em>, place a value
      <em><code>x</code></em> into the proper category using this
      expression:</p><pre data-type="programlisting">FLOOR((<em><code>x</code></em>+(<em><code>n</code></em>-1))/<em><code>n</code></em>)</pre><p>So the final form of our query looks like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT FLOOR((pop+4999999)/5000000)*5 AS `max population (millions)`,</code></strong>
    -&gt; <strong><code>COUNT(*) AS `number of states`</code></strong>
    -&gt; <strong><code>FROM states GROUP BY `max population (millions)`</code></strong>
    -&gt; <strong><code>ORDER BY `max population (millions)`;</code></strong>
+---------------------------+------------------+
| max population (millions) | number of states |
+---------------------------+------------------+
|                         5 |               26 |
|                        10 |               14 |
|                        15 |                6 |
|                        20 |                1 |
|                        25 |                1 |
|                        30 |                1 |
|                        40 |                1 |
+---------------------------+------------------+</pre><p>The result shows clearly that the majority of US states have a
      population of five million or less.</p><p>In some instances, it may be more appropriate to categorize groups
      on a logarithmic scale. For example, treat the state population values
      that way as follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT FLOOR(LOG10(pop)) AS `log10(population)`,</code></strong>
    -&gt; <strong><code>COUNT(*) AS `number of states`</code></strong>
    -&gt; <strong><code>FROM states GROUP BY `log10(population)`;</code></strong>
+-------------------+------------------+
| log10(population) | number of states |
+-------------------+------------------+
|                 5 |                5 |
|                 6 |               35 |
|                 7 |               10 |
+-------------------+------------------+</pre><p>The query shows the number of states that have populations
      measured in hundreds of thousands, millions, and tens of millions,
      respectively.</p><p>You may have noticed that aliases in the preceding queries are
      written using backticks (identifier quoting) rather than single
      quotes (string quoting). Quoted aliases in the <code>GROUP</code>
      <code>BY</code> clause must use identifier quoting
      or the alias is treated as a constant string expression and the grouping
      produces the wrong result. Identifier quoting clarifies to MySQL that
      the alias refers to an output column. The aliases in the output column
      list could have been written using string quoting; we used backticks
      there to avoid mixing alias quoting styles within a given query.</p><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820368231408"><h5>How Repetitive Is a Set of Values?</h5><p>To assess how much repetition is present in a set of values,
        use the ratio of <code>COUNT(DISTINCT)</code> and <code>COUNT()</code>. If all values are unique, both
        counts are the same and the ratio is 1. This is the case for the
        <code>t</code> values in the <code>mail</code> table and the <code>pop</code> values in the <code>states</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(DISTINCT t) / COUNT(t) FROM mail;</code></strong>
+------------------------------+
| COUNT(DISTINCT t) / COUNT(t) |
+------------------------------+
|                       1.0000 |
+------------------------------+
mysql&gt; <strong><code>SELECT COUNT(DISTINCT pop) / COUNT(pop) FROM states;</code></strong>
+----------------------------------+
| COUNT(DISTINCT pop) / COUNT(pop) |
+----------------------------------+
|                           1.0000 |
+----------------------------------+</pre><p>For a more repetitive set of values, <code>COUNT(DISTINCT)</code> is less than <code>COUNT()</code>, and the ratio is smaller:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(DISTINCT name) / COUNT(name) FROM driver_log;</code></strong>
+------------------------------------+
| COUNT(DISTINCT name) / COUNT(name) |
+------------------------------------+
|                             0.3000 |
+------------------------------------+</pre><p>What’s the practical use for this ratio? A result close to zero
        indicates a high degree of repetition, which means the values will
        group into a small number of categories naturally. A result of 1 or
        close to it indicates many unique values, with the consequence that
        <code>GROUP</code> <code>BY</code> won’t be very efficient for grouping the
        values into categories. (That is, there will be a lot of categories,
        relative to the number of values.) This tells you that, to generate a
        summary, you’ll probably find it necessary to impose an artificial
        categorization on the values, using the techniques described in this
        recipe.</p></div></aside></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.14 Finding Smallest or Largest Summary Values"><div class="sect1" id="nch-sum-sum-minmax-sum"><h1>10.14 Finding Smallest or Largest Summary Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368220528"><h2>Problem</h2><p>You want to compute per-group summary values but display only the
      smallest or largest of them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368219472"><h2>Solution</h2><p>Add a <code>LIMIT</code> clause to the statement. Or use a user-defined variable or
      subquery to pick the appropriate summary.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368217952"><h2>Discussion</h2><p><code>MIN()</code> and <code>MAX()</code> find the values at the endpoints of a
      set of values, but to find the endpoints of a set of summary values,
      those functions won’t work. Their argument cannot be another aggregate
      function. For example, you can easily find per-driver mileage
      totals:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, SUM(miles)</code></strong>
    -&gt; <strong><code>FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY name;</code></strong>
+-------+------------+
| name  | SUM(miles) |
+-------+------------+
| Ben   |        362 |
| Henry |        911 |
| Suzi  |        893 |
+-------+------------+</pre><p>To select only the row for the driver with the most miles, the
      following doesn’t work:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, SUM(miles)</code></strong>
    -&gt; <strong><code>FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY name</code></strong>
    -&gt; <strong><code>HAVING SUM(miles) = MAX(SUM(miles));</code></strong>
ERROR 1111 (HY000): Invalid use of group function</pre><p>Instead, order the rows with the largest <code>SUM()</code> values first and use <code>LIMIT</code> to select the first row:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, SUM(miles)</code></strong>
    -&gt; <strong><code>FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY name</code></strong>
    -&gt; <strong><code>ORDER BY SUM(miles) DESC LIMIT 1;</code></strong>
+-------+------------+
| name  | SUM(miles) |
+-------+------------+
| Henry |        911 |
+-------+------------+</pre><p>However, if more than one row has the given summary value, a
      <code>LIMIT</code> <code>1</code> query won’t tell you that. For example, you
      might attempt to ascertain the most common initial letter for state
      names like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT LEFT(name,1) AS letter, COUNT(*) FROM states</code></strong>
    -&gt; <strong><code>GROUP BY letter ORDER BY COUNT(*) DESC LIMIT 1;</code></strong>
+--------+----------+
| letter | COUNT(*) |
+--------+----------+
| M      |        8 |
+--------+----------+</pre><p>But eight state names also begin with <code>N</code>. To find all most-frequent values when there
      may be more than one, use a user-defined variable or subquery to
      determine the maximum count, then select those values with a count equal
      to the maximum:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @max = (SELECT COUNT(*) FROM states</code></strong>
    -&gt; <strong><code>GROUP BY LEFT(name,1) ORDER BY COUNT(*) DESC LIMIT 1);</code></strong>
mysql&gt; <strong><code>SELECT LEFT(name,1) AS letter, COUNT(*) FROM states</code></strong>
    -&gt; <strong><code>GROUP BY letter HAVING COUNT(*) = @max;</code></strong>
+--------+----------+
| letter | COUNT(*) |
+--------+----------+
| M      |        8 |
| N      |        8 |
+--------+----------+
mysql&gt; <strong><code>SELECT LEFT(name,1) AS letter, COUNT(*) FROM states</code></strong>
    -&gt; <strong><code>GROUP BY letter HAVING COUNT(*) =</code></strong>
    -&gt;   <strong><code>(SELECT COUNT(*) FROM states</code></strong>
    -&gt;   <strong><code>GROUP BY LEFT(name,1) ORDER BY COUNT(*) DESC LIMIT 1);</code></strong>
+--------+----------+
| letter | COUNT(*) |
+--------+----------+
| M      |        8 |
| N      |        8 |
+--------+----------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.15 Producing Date-Based Summaries"><div class="sect1" id="nch-sum-sum-date"><h1>10.15 Producing Date-Based Summaries</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368195472"><h2>Problem</h2><p>You want to produce a summary based on date or time values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368194592"><h2>Solution</h2><p>Use <code>GROUP</code> <code>BY</code> to place temporal values into categories of the appropriate
      duration. Often this involves using expressions that extract the
      significant parts of dates or times.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368192672"><h2>Discussion</h2><p>To sort rows temporally, use <code>ORDER</code> <code>BY</code>
      with a temporal column. To summarize rows instead, based on
      groupings into time intervals, determine how to categorize rows into the
      proper intervals and use <code>GROUP</code>
      <code>BY</code> to group them accordingly.</p><p>For example, to determine how many drivers were on the road and how many miles were driven each day, group
      the rows in the <code>driver_log</code> table by
      date:<sup><a data-type="noteref" id="idm45820368189088-marker" href="ch10.xhtml#idm45820368189088">1</a></sup></p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT trav_date,</code></strong>
    -&gt; <strong><code>COUNT(*) AS 'number of drivers', SUM(miles) As 'miles logged'</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY trav_date;</code></strong>
+------------+-------------------+--------------+
| trav_date  | number of drivers | miles logged |
+------------+-------------------+--------------+
| 2014-07-26 |                 1 |          115 |
| 2014-07-27 |                 1 |           96 |
| 2014-07-29 |                 3 |          822 |
| 2014-07-30 |                 2 |          355 |
| 2014-08-01 |                 1 |          197 |
| 2014-08-02 |                 2 |          581 |
+------------+-------------------+--------------+</pre><p>However, this per-day summary grows lengthier as you add more rows
      to the table. Over time, the number of distinct dates will become so
      large that the summary fails to be useful, and you’d probably decide to
      increase the category size. For example, this query categorizes by
      month:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT YEAR(trav_date) AS year, MONTH(trav_date) AS month,</code></strong>
    -&gt; <strong><code>COUNT(*) AS 'number of drivers', SUM(miles) As 'miles logged'</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY year, month;</code></strong>
+------+-------+-------------------+--------------+
| year | month | number of drivers | miles logged |
+------+-------+-------------------+--------------+
| 2014 |     7 |                 7 |         1388 |
| 2014 |     8 |                 3 |          778 |
+------+-------+-------------------+--------------+</pre><p>Now the number of summary rows grows much more slowly over time.
      Eventually, you could summarize based only on year to collapse rows even
      more.</p><p>Uses for temporal categorizations are numerous:</p><ul><li><p>To produce daily summaries from <code>DATETIME</code> or <code>TIMESTAMP</code> columns that have the potential to contain many unique values,
          strip the time-of-day part to collapse all values occurring within a
          given day to the same value. Any of the following <code>GROUP</code> <code>BY</code> clauses will do this, although the last
          one is likely to be slowest:</p><pre data-type="programlisting">GROUP BY DATE(<em><code>col_name</code></em>)
GROUP BY FROM_DAYS(TO_DAYS(<em><code>col_name</code></em>))
GROUP BY YEAR(<em><code>col_name</code></em>), MONTH(<em><code>col_name</code></em>), DAYOFMONTH(<em><code>col_name</code></em>)
GROUP BY DATE_FORMAT(<em><code>col_name</code></em>,'%Y-%m-%e')</pre></li><li><p>To produce monthly or quarterly sales reports, group
          by <code>MONTH(</code><em><code>col_name</code></em><code>)</code> or <code>QUARTER(</code><em><code>col_name</code></em><code>)</code> to place dates into the correct part of
          the year.</p></li></ul></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.16 Working with Per-Group and Overall Summary Values&#10;    Simultaneously"><div class="sect1" id="nch-sum-sum-mixed"><h1>10.16 Working with Per-Group and Overall Summary Values
    Simultaneously</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368170192"><h2>Problem</h2><p>You want to produce a report that requires different levels of summary
      detail. Or you want to compare per-group summary values to an overall
      summary value.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368169168"><h2>Solution</h2><p>Use two statements that retrieve different levels of summary
      information. Or use a subquery to retrieve one summary value and refer
      to it in the outer query that refers to other summary values. For
      applications that only display multiple summary levels (rather than
      perform additional calculations on them), <code>WITH</code> <code>ROLLUP</code> might be sufficient.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368167008"><h2>Discussion</h2><p>Some reports involve multiple levels of summary information. The
      following report displays the total number of miles per driver from the
      <code>driver_log</code> table, along with each
      driver’s miles as a percentage of the total miles in the entire
      table:</p><pre data-type="programlisting">+-------+--------------+------------------------+
| name  | miles/driver | percent of total miles |
+-------+--------------+------------------------+
| Ben   |          362 |                16.7128 |
| Henry |          911 |                42.0591 |
| Suzi  |          893 |                41.2281 |
+-------+--------------+------------------------+</pre><p>The percentages represent the ratio of each driver’s miles to the
      total miles for all drivers. To perform the percentage calculation, you
      need a per-group summary to get each driver’s miles and also an overall
      summary to get the total miles. First, run a query to get the overall
      mileage total:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT @total := SUM(miles) AS 'total miles' FROM driver_log;</code></strong>
+-------------+
| total miles |
+-------------+
|        2166 |
+-------------+</pre><p>Then calculate the per-group values and use the overall total to
      compute the percentages:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name,</code></strong>
    -&gt; <strong><code>SUM(miles) AS 'miles/driver',</code></strong>
    -&gt; <strong><code>(SUM(miles)*100)/@total AS 'percent of total miles'</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY name;</code></strong>
+-------+--------------+------------------------+
| name  | miles/driver | percent of total miles |
+-------+--------------+------------------------+
| Ben   |          362 |                16.7128 |
| Henry |          911 |                42.0591 |
| Suzi  |          893 |                41.2281 |
+-------+--------------+------------------------+</pre><p>To combine the two statements into one, use a subquery that
      computes the total miles:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">name</code><code class="p">,</code>
<code class="k">SUM</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code> <code class="k">AS</code> <code class="s1">'miles/driver'</code><code class="p">,</code>
<code class="p">(</code><code class="k">SUM</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code><code class="o">*</code><code class="mi">100</code><code class="p">)</code><code class="o">/</code><code class="p">(</code><code class="k">SELECT</code> <code class="k">SUM</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code> <code class="k">FROM</code> <code class="n">driver_log</code><code class="p">)</code>
  <code class="k">AS</code> <code class="s1">'percent of total miles'</code>
<code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">GROUP</code> <code class="k">BY</code> <code class="n">name</code><code class="p">;</code></pre><p>A similar problem uses multiple summary levels to compare
      per-group summary values with the corresponding overall summary value.
      Suppose that you want to display drivers who had a lower average miles
      per day than the group average. Calculate the overall average in a
      subquery, and then compare each driver’s average to the overall average
      using a <code>HAVING</code> clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, AVG(miles) AS driver_avg FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY name</code></strong>
    -&gt; <strong><code>HAVING driver_avg &lt; (SELECT AVG(miles) FROM driver_log);</code></strong>
+-------+------------+
| name  | driver_avg |
+-------+------------+
| Ben   |   120.6667 |
| Henry |   182.2000 |
+-------+------------+</pre><p>To display different summary-level values (and not perform
      calculations involving one summary level against another), add <code>WITH</code> <code>ROLLUP</code>
      to the <code>GROUP</code> <code>BY</code> clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, SUM(miles) AS 'miles/driver'</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY name WITH ROLLUP;</code></strong>
+-------+--------------+
| name  | miles/driver |
+-------+--------------+
| Ben   |          362 |
| Henry |          911 |
| Suzi  |          893 |
| NULL  |         2166 |
+-------+--------------+
mysql&gt; <strong><code>SELECT name, AVG(miles) AS driver_avg FROM driver_log</code></strong>
    -&gt; <strong><code>GROUP BY name WITH ROLLUP;</code></strong>
+-------+------------+
| name  | driver_avg |
+-------+------------+
| Ben   |   120.6667 |
| Henry |   182.2000 |
| Suzi  |   446.5000 |
| NULL  |   216.6000 |
+-------+------------+</pre><p>In each case, the output row with <code>NULL</code> in the
      <code>name</code> column represents the overall
      sum or average calculated over all drivers.</p><p><code>WITH</code> <code>ROLLUP</code> produces multiple summary levels if you
      group by more than one column. The following statement shows the number
      of mail messages sent between each pair of users:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser, dstuser, COUNT(*)</code></strong>
    -&gt; <strong><code>FROM mail GROUP BY srcuser, dstuser;</code></strong>
+---------+---------+----------+
| srcuser | dstuser | COUNT(*) |
+---------+---------+----------+
| barb    | barb    |        1 |
| barb    | tricia  |        2 |
| gene    | barb    |        2 |
| gene    | gene    |        3 |
| gene    | tricia  |        1 |
| phil    | barb    |        1 |
| phil    | phil    |        2 |
| phil    | tricia  |        2 |
| tricia  | gene    |        1 |
| tricia  | phil    |        1 |
+---------+---------+----------+</pre><p>Adding <code>WITH</code> <code>ROLLUP</code> causes the output to include an
      intermediate count for each <code>srcuser</code>
      value (these are the lines with <code>NULL</code>
      in the <code>dstuser</code> column), plus an
      overall count at the end:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT srcuser, dstuser, COUNT(*)</code></strong>
    -&gt; <strong><code>FROM mail GROUP BY srcuser, dstuser WITH ROLLUP;</code></strong>
+---------+---------+----------+
| srcuser | dstuser | COUNT(*) |
+---------+---------+----------+
| barb    | barb    |        1 |
| barb    | tricia  |        2 |
| barb    | NULL    |        3 |
| gene    | barb    |        2 |
| gene    | gene    |        3 |
| gene    | tricia  |        1 |
| gene    | NULL    |        6 |
| phil    | barb    |        1 |
| phil    | phil    |        2 |
| phil    | tricia  |        2 |
| phil    | NULL    |        5 |
| tricia  | gene    |        1 |
| tricia  | phil    |        1 |
| tricia  | NULL    |        2 |
| NULL    | NULL    |       16 |
+---------+---------+----------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.17 Generating a Report That Includes a Summary and a List"><div class="sect1" id="nch-sum-sum-sum-list"><h1>10.17 Generating a Report That Includes a Summary <span class="keep-together">and a List</span></h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820368071744"><h2>Problem</h2><p>You want to create a report that displays a summary, together with the list of
      rows associated with each summary value.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820368070768"><h2>Solution</h2><p>Use two statements that retrieve different levels of summary
      information. Or use a programming language to do some of the work so
      that you can use a single statement.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820368069632"><h2>Discussion</h2><p>Suppose that you want to produce a report that looks like
      this:</p><pre data-type="programlisting">Name: Ben; days on road: 3; miles driven: 362
  date: 2014-07-29, trip length: 131
  date: 2014-07-30, trip length: 152
  date: 2014-08-02, trip length: 79
Name: Henry; days on road: 5; miles driven: 911
  date: 2014-07-26, trip length: 115
  date: 2014-07-27, trip length: 96
  date: 2014-07-29, trip length: 300
  date: 2014-07-30, trip length: 203
  date: 2014-08-01, trip length: 197
Name: Suzi; days on road: 2; miles driven: 893
  date: 2014-07-29, trip length: 391
  date: 2014-08-02, trip length: 502</pre><p>For each driver in the <code>driver_log</code> table, the report shows the
      following information:</p><ul><li><p>A summary line showing the driver name, the number of days on
          the road, and the number of miles driven.</p></li><li><p>A list that details dates and mileages for the individual
          trips from which the summary values are calculated.</p></li></ul><p>This scenario is a variation on the <q>different levels of
      summary information</q> problem discussed in <a data-type="xref" href="#nch-sum-sum-mixed">Recipe 10.16</a>. It may not seem like it at first because
      one of the types of information is a list rather than a summary. But
      that’s really just a <q>level zero</q> summary. This kind of
      problem appears in many other forms:</p><ul><li><p>You have a database that lists contributions to candidates in
          your political party. The party chair requests a printout that
          shows, for each candidate, the number of contributions and total
          amount contributed, as well as a list of contributor names and
          addresses.</p></li><li><p>You want to create a handout for a company presentation that
          summarizes total sales per sales region with a list under each
          region showing the sales for each state in the region.</p></li></ul><p>Such problems have multiple solutions:</p><ul><li><p>Run separate statements to get the information for each level
          of detail that you require. (A single query won’t produce per-group
          summary values and a list of each group’s individual rows.)</p></li><li><p>Fetch the rows that make up the lists and perform the summary
          calculations yourself to eliminate the summary statement.</p></li></ul><p>Let’s use each approach to produce the driver report shown at the
      beginning of this section. The following implementation (in Python)
      generates the report using one query to summarize the days and miles per
      driver, and another to fetch the individual trip rows for each
      driver:</p><pre data-type="programlisting" data-code-language="python"><code class="c1"># select total miles per driver and construct a dictionary that</code>
<code class="c1"># maps each driver name to days on the road and miles driven</code>
<code class="n">name_map</code> <code class="o">=</code> <code class="p">{}</code>
<code class="n">cursor</code> <code class="o">=</code> <code class="n">conn</code><code class="o">.</code><code class="n">cursor</code><code class="p">()</code>
<code class="n">cursor</code><code class="o">.</code><code class="n">execute</code><code class="p">(</code><code class="s1">'''</code>
<code class="s1">               SELECT name, COUNT(name), SUM(miles)</code>
<code class="s1">               FROM driver_log GROUP BY name</code>
<code class="s1">               '''</code><code class="p">)</code>
<code class="k">for</code> <code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">days</code><code class="p">,</code> <code class="n">miles</code><code class="p">)</code> <code class="ow">in</code> <code class="n">cursor</code><code class="p">:</code>
  <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">]</code> <code class="o">=</code> <code class="p">(</code><code class="n">days</code><code class="p">,</code> <code class="n">miles</code><code class="p">)</code>

<code class="c1"># select trips for each driver and print the report, displaying the</code>
<code class="c1"># summary entry for each driver prior to the list of trips</code>
<code class="n">cursor</code><code class="o">.</code><code class="n">execute</code><code class="p">(</code><code class="s1">'''</code>
<code class="s1">               SELECT name, trav_date, miles</code>
<code class="s1">               FROM driver_log ORDER BY name, trav_date</code>
<code class="s1">               '''</code><code class="p">)</code>
<code class="n">cur_name</code> <code class="o">=</code> <code class="s2">""</code>
<code class="k">for</code> <code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">trav_date</code><code class="p">,</code> <code class="n">miles</code><code class="p">)</code> <code class="ow">in</code> <code class="n">cursor</code><code class="p">:</code>
  <code class="k">if</code> <code class="n">cur_name</code> <code class="o">!=</code> <code class="n">name</code><code class="p">:</code>  <code class="c1"># new driver; print driver's summary info</code>
    <code class="k">print</code><code class="p">(</code><code class="s2">"Name: </code><code class="si">%s</code><code class="s2">; days on road: </code><code class="si">%d</code><code class="s2">; miles driven: </code><code class="si">%d</code><code class="s2">"</code> <code class="o">%</code>
          <code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">][</code><code class="mi">0</code><code class="p">],</code> <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">][</code><code class="mi">1</code><code class="p">]))</code>
    <code class="n">cur_name</code> <code class="o">=</code> <code class="n">name</code>
  <code class="k">print</code><code class="p">(</code><code class="s2">"  date: </code><code class="si">%s</code><code class="s2">, trip length: </code><code class="si">%d</code><code class="s2">"</code> <code class="o">%</code> <code class="p">(</code><code class="n">trav_date</code><code class="p">,</code> <code class="n">miles</code><code class="p">))</code>
<code class="n">cursor</code><code class="o">.</code><code class="n">close</code><code class="p">()</code></pre><p>An alternative implementation performs summary calculations within
      the program, which reduces the number of queries required. If you
      iterate through the trip list and calculate the per-driver day counts
      and mileage totals yourself, a single query suffices:</p><pre data-type="programlisting" data-code-language="python"><code class="c1"># get list of trips for the drivers</code>
<code class="n">cursor</code> <code class="o">=</code> <code class="n">conn</code><code class="o">.</code><code class="n">cursor</code><code class="p">()</code>
<code class="n">cursor</code><code class="o">.</code><code class="n">execute</code><code class="p">(</code><code class="s1">'''</code>
<code class="s1">               SELECT name, trav_date, miles FROM driver_log</code>
<code class="s1">               ORDER BY name, trav_date</code>
<code class="s1">               '''</code><code class="p">)</code>
<code class="c1"># fetch rows into data structure because we</code>
<code class="c1"># must iterate through them multiple times</code>
<code class="n">rows</code> <code class="o">=</code> <code class="n">cursor</code><code class="o">.</code><code class="n">fetchall</code><code class="p">()</code>
<code class="n">cursor</code><code class="o">.</code><code class="n">close</code><code class="p">()</code>

<code class="c1"># iterate through rows once to construct a dictionary that</code>
<code class="c1"># maps each driver name to days on the road and miles driven</code>
<code class="c1"># (the dictionary entries are lists rather than tuples because</code>
<code class="c1"># we need mutable values that can be modified in the loop)</code>
<code class="n">name_map</code> <code class="o">=</code> <code class="p">{}</code>
<code class="k">for</code> <code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">trav_date</code><code class="p">,</code> <code class="n">miles</code><code class="p">)</code> <code class="ow">in</code> <code class="n">rows</code><code class="p">:</code>
  <code class="k">if</code> <code class="n">name</code> <code class="ow">not</code> <code class="ow">in</code> <code class="n">name_map</code><code class="p">:</code> <code class="c1"># initialize entry if nonexistent</code>
    <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code>
  <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">][</code><code class="mi">0</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code>     <code class="c1"># count days</code>
  <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">][</code><code class="mi">1</code><code class="p">]</code> <code class="o">+=</code> <code class="n">miles</code> <code class="c1"># sum miles</code>

<code class="c1"># iterate through rows again to print the report, displaying the</code>
<code class="c1"># summary entry for each driver prior to the list of trips</code>
<code class="n">cur_name</code> <code class="o">=</code> <code class="s2">""</code>
<code class="k">for</code> <code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">trav_date</code><code class="p">,</code> <code class="n">miles</code><code class="p">)</code> <code class="ow">in</code> <code class="n">rows</code><code class="p">:</code>
  <code class="k">if</code> <code class="n">cur_name</code> <code class="o">!=</code> <code class="n">name</code><code class="p">:</code>  <code class="c1"># new driver; print driver's summary info</code>
    <code class="k">print</code><code class="p">(</code><code class="s2">"Name: </code><code class="si">%s</code><code class="s2">; days on road: </code><code class="si">%d</code><code class="s2">; miles driven: </code><code class="si">%d</code><code class="s2">"</code> <code class="o">%</code>
          <code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">][</code><code class="mi">0</code><code class="p">],</code> <code class="n">name_map</code><code class="p">[</code><code class="n">name</code><code class="p">][</code><code class="mi">1</code><code class="p">]))</code>
    <code class="n">cur_name</code> <code class="o">=</code> <code class="n">name</code>
  <code class="k">print</code><code class="p">(</code><code class="s2">"  date: </code><code class="si">%s</code><code class="s2">, trip length: </code><code class="si">%d</code><code class="s2">"</code> <code class="o">%</code> <code class="p">(</code><code class="n">trav_date</code><code class="p">,</code> <code class="n">miles</code><code class="p">))</code></pre><p>Should you require more levels of summary information, this type
      of problem gets more difficult. For example, you might want to precede
      the report that shows driver summaries and trip logs with a line that
      shows the total miles for all drivers:</p><pre data-type="programlisting">Total miles driven by all drivers combined: 2166

Name: Ben; days on road: 3; miles driven: 362
  date: 2014-07-29, trip length: 131
  date: 2014-07-30, trip length: 152
  date: 2014-08-02, trip length: 79
Name: Henry; days on road: 5; miles driven: 911
  date: 2014-07-26, trip length: 115
  date: 2014-07-27, trip length: 96
  date: 2014-07-29, trip length: 300
  date: 2014-07-30, trip length: 203
  date: 2014-08-01, trip length: 197
Name: Suzi; days on road: 2; miles driven: 893
  date: 2014-07-29, trip length: 391
  date: 2014-08-02, trip length: 502</pre><p>In this case, you need either another query to produce the total
      mileage, or another calculation in your program that computes the
      overall total.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="10.18 Generating Summaries from Temporary Result Sets"><div class="sect1" id="nch-sum-sum-with"><h1>10.18 Generating Summaries from Temporary Result Sets</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820367828800"><h2>Problem</h2><p>
        You want to generate summaries, but cannot achieve it without using temporary result sets.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820367753328"><h2>Solution</h2><p>
        Use Common Table Expressions (CTE) by <code>WITH</code> clause.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820367752000"><h2>Discussion</h2><p>
        We already discussed situations when a temporary table, holding result from a query, helps to create a summary. In these cases we referred the temporary table from the query, generating resulting summary. See <a data-type="xref" href="#nch-sum-sum-assoc">Recipe 10.6</a> and  <a data-type="xref" href="#nch-sum-sum-subgroup">Recipe 10.8</a> for examples.
      </p><p>
        Temporary tables are not always the best solution for such a task. They have a number of disadvantages, particularly:
        </p><ul><li><p>You need to maintain the table: delete all content when you are going to reuse it and drop once you are finished to work with it.</p></li><li><p><code>CREATE [TEMPORARY] TABLE ... SELECT</code> statement implicitly commits transaction, therefore it cannot be used when there is a possibility that the content of the original table changes after the data is inserted into the temporary table. You have to create the table first, then insert data into it and generate summary in the multiple statement transaction. For example, finding the longest trip per driver that we discussed in <a data-type="xref" href="#nch-sum-sum-subgroup">Recipe 10.8</a> may end up with the following code:
          </p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TEMPORARY</code> <code class="k">TABLE</code> <code class="n">t</code> <code class="k">LIKE</code> <code class="n">driver_log</code><code class="p">;</code>
<code class="k">START</code> <code class="n">TRANSACTION</code><code class="p">;</code>
<code class="k">INSERT</code> <code class="k">INTO</code> <code class="n">t</code> <code class="k">SELECT</code> <code class="n">name</code><code class="p">,</code> <code class="k">MAX</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code> <code class="k">AS</code> <code class="n">miles</code> <code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">GROUP</code> <code class="k">BY</code> <code class="n">name</code><code class="p">;</code>
<code class="k">SELECT</code> <code class="n">d</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">d</code><code class="p">.</code><code class="n">trav_date</code><code class="p">,</code> <code class="n">d</code><code class="p">.</code><code class="n">miles</code> <code class="k">AS</code> <code class="s1">'longest trip'</code>
<code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">AS</code> <code class="n">d</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">t</code> <code class="k">USING</code> <code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">miles</code><code class="p">)</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">name</code><code class="p">;</code>
<code class="k">COMMIT</code><code class="p">;</code>
<code class="k">DROP</code> <code class="k">TABLE</code> <code class="n">t</code><code class="p">;</code></pre><p>
          </p></li><li><p>Optimizer has less options to improve performance of the query.</p></li></ul><p>
      </p><p>
        Common Table Expressions (CTE) allow to create a named temporary result set inside the query. Syntax of CTE is
        </p><pre data-type="programlisting" data-code-language="sql">WITH <em><code>result_name</code></em> AS (SELECT ...)
SELECT ...</pre><p>
      </p><p>
        Then you can refer the named result in the following query like if it was a regular table. You can define multiple CTE and can refer the same named result multiple times when needed.
      </p><p>
        Thus, example in <a data-type="xref" href="#nch-sum-sum-sum-list">Recipe 10.17</a>, showing number of trips per driver and total mileage together with trip details could be resolved with a CTE.
        </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="k">WITH</code></strong><code> </code><a class="co" id="co_nch-sum-sum-with-with_co" href="#callout_nch-sum-sum-with-with_co"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="n">trips</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">name</code><code class="p">,</code><code> </code><code class="n">trav_date</code><code class="p">,</code><code> </code><code class="n">miles</code><code> </code><code class="k">FROM</code><code> </code><code class="n">driver_log</code><code class="p">)</code><code class="p">,</code></strong><code> </code><a class="co" id="co_nch-sum-sum-with-trips_co" href="#callout_nch-sum-sum-with-trips_co"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="n">summaries</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code>     </code><code class="k">SELECT</code><code> </code><code class="n">name</code><code class="p">,</code><code> </code><code class="k">COUNT</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">days_on_road</code><code class="p">,</code><code> </code><code class="k">SUM</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">miles_driven</code></strong><code> </code><a class="co" id="co_nch-sum-sum-with-summaries_co" href="#callout_nch-sum-sum-with-summaries_co"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code>     </code><code class="k">FROM</code><code> </code><code class="n">driver_log</code><code> </code><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">name</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="k">SELECT</code><code> </code><code class="n">trips</code><code class="p">.</code><code class="n">name</code><code class="p">,</code><code> </code><code class="n">days_on_road</code><code class="p">,</code><code> </code><code class="n">miles_driven</code><code class="p">,</code><code> </code><code class="n">trav_date</code><code class="p">,</code><code> </code><code class="n">miles</code></strong><code> </code><a class="co" id="co_nch-sum-sum-with-outer_co" href="#callout_nch-sum-sum-with-outer_co"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code> </code><code class="k">FROM</code><code> </code><code class="n">summaries</code><code> </code><code class="k">LEFT</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">trips</code><code> </code><code class="k">USING</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">-------+--------------+--------------+------------+-------+
</code><code class="o">|</code><code> </code><code class="n">name</code><code>  </code><code class="o">|</code><code> </code><code class="n">days_on_road</code><code> </code><code class="o">|</code><code> </code><code class="n">miles_driven</code><code> </code><code class="o">|</code><code> </code><code class="n">trav_date</code><code>  </code><code class="o">|</code><code> </code><code class="n">miles</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">-------+--------------+--------------+------------+-------+
</code><code class="o">|</code><code> </code><code class="n">Ben</code><code>   </code><code class="o">|</code><code>            </code><code class="mi">3</code><code> </code><code class="o">|</code><code>          </code><code class="mi">362</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">02</code><code> </code><code class="o">|</code><code>    </code><code class="mi">79</code><code> </code><code class="o">|</code><code>  </code><a class="co" id="co_nch-sum-sum-with-result_co" href="#callout_nch-sum-sum-with-result_co"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
</code><code class="o">|</code><code> </code><code class="n">Ben</code><code>   </code><code class="o">|</code><code>            </code><code class="mi">3</code><code> </code><code class="o">|</code><code>          </code><code class="mi">362</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">29</code><code> </code><code class="o">|</code><code>   </code><code class="mi">131</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Ben</code><code>   </code><code class="o">|</code><code>            </code><code class="mi">3</code><code> </code><code class="o">|</code><code>          </code><code class="mi">362</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">30</code><code> </code><code class="o">|</code><code>   </code><code class="mi">152</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Suzi</code><code>  </code><code class="o">|</code><code>            </code><code class="mi">2</code><code> </code><code class="o">|</code><code>          </code><code class="mi">893</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">02</code><code> </code><code class="o">|</code><code>   </code><code class="mi">502</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Suzi</code><code>  </code><code class="o">|</code><code>            </code><code class="mi">2</code><code> </code><code class="o">|</code><code>          </code><code class="mi">893</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">29</code><code> </code><code class="o">|</code><code>   </code><code class="mi">391</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Henry</code><code> </code><code class="o">|</code><code>            </code><code class="mi">5</code><code> </code><code class="o">|</code><code>          </code><code class="mi">911</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">30</code><code> </code><code class="o">|</code><code>   </code><code class="mi">203</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Henry</code><code> </code><code class="o">|</code><code>            </code><code class="mi">5</code><code> </code><code class="o">|</code><code>          </code><code class="mi">911</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">08</code><code class="o">-</code><code class="mi">01</code><code> </code><code class="o">|</code><code>   </code><code class="mi">197</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Henry</code><code> </code><code class="o">|</code><code>            </code><code class="mi">5</code><code> </code><code class="o">|</code><code>          </code><code class="mi">911</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">26</code><code> </code><code class="o">|</code><code>   </code><code class="mi">115</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Henry</code><code> </code><code class="o">|</code><code>            </code><code class="mi">5</code><code> </code><code class="o">|</code><code>          </code><code class="mi">911</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">27</code><code> </code><code class="o">|</code><code>    </code><code class="mi">96</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Henry</code><code> </code><code class="o">|</code><code>            </code><code class="mi">5</code><code> </code><code class="o">|</code><code>          </code><code class="mi">911</code><code> </code><code class="o">|</code><code> </code><code class="mi">2014</code><code class="o">-</code><code class="mi">07</code><code class="o">-</code><code class="mi">29</code><code> </code><code class="o">|</code><code>   </code><code class="mi">300</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">-------+--------------+--------------+------------+-------+
</code><code class="mi">10</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">.</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>

        </p><dl class="calloutlist"><dt><a class="co" id="callout_nch-sum-sum-with-with_co" href="#co_nch-sum-sum-with-with_co"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt><dd><p>Keyword <code>WITH</code> starts CTE.</p></dd><dt><a class="co" id="callout_nch-sum-sum-with-trips_co" href="#co_nch-sum-sum-with-trips_co"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt><dd><p>Assign name <code>trips</code> to the <code>SELECT</code>, retrieving travel data.</p></dd><dt><a class="co" id="callout_nch-sum-sum-with-summaries_co" href="#co_nch-sum-sum-with-summaries_co"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt><dd><p>The second named <code>SELECT</code> generates summary of the number of trips and total mileage per driver.</p></dd><dt><a class="co" id="callout_nch-sum-sum-with-outer_co" href="#co_nch-sum-sum-with-outer_co"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt><dd><p>The main query refers two named result sets and joins them using <code>LEFT JOIN</code> as if they were regular tables.</p></dd><dt><a class="co" id="callout_nch-sum-sum-with-result_co" href="#co_nch-sum-sum-with-result_co"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt><dd><p>Each resulting row contains number of trips, total amount of miles driven and details of the individual trip.</p></dd></dl><p>
      </p></div></section></div></section><div data-type="footnotes"><p data-type="footnote" id="idm45820368189088"><sup><a href="ch10.xhtml#idm45820368189088-marker">1</a></sup> The result includes an entry only for dates actually
          represented in the table. To generate a summary with an entry for
          the range of dates in the table, use a join to fill in the
          <q>missing</q> values. See <a data-type="xref" href="ch16.xhtml#nch-multi-multi-fill-hole">Recipe 16.8</a>.</p></div></div></section></div></body></html>