<html><head></head><body><section data-pdf-bookmark="Chapter 9. Other Challenges" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch09">&#13;
<h1><span class="label">Chapter 9. </span>Other Challenges</h1>&#13;
&#13;
&#13;
<p>This chapter is a short but important laundry list of common MySQL challenges and how to mitigate them.&#13;
These challenges don’t fit into other chapters because most are not directly related to performance.&#13;
But don’t underestimate them: the first two challenges, for example, can ruin a database.&#13;
More importantly, these challenges are not special cases that only happen when the stars align and The Fates conspire to ruin your day.&#13;
These are common challenges.&#13;
Take them seriously, and expect to face them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Split-Brain Is the Greatest Risk" data-type="sect1"><div class="sect1" id="split-brain">&#13;
<h1>Split-Brain Is the Greatest Risk</h1>&#13;
&#13;
<p>Split-brain <a data-primary="split-brain" data-type="indexterm" id="split-brain1"/>requires two conditions to occur at the same time, in the same replication topology:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>More than one MySQL instance is writable (<code>read_only=0</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Writes occur on more than one MySQL instance</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Neither of those should ever happen—especially not at the same time—but life is full of surprises, and you cannot avoid bugs or accidents forever.&#13;
When it happens, it’s called <em>split-brain</em>: instead of all MySQL instances having the same data, they’re figuratively split because data is no longer identical (consistent) on every instance.&#13;
Not only is inconsistent data fundamentally wrong, it can break replication or—worse—have a ripple effect that causes more data to become inconsistent, which causes the next challenge: data drift.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Split-brain does not apply to MySQL replication topologies intentionally designed to have multiple writable instances.</p>&#13;
</div>&#13;
&#13;
<p>If split-brain occurs, you must detect and stop it <em>immediately</em>.&#13;
Why?&#13;
Because a single write can affect any number of rows.&#13;
Mere seconds of split-brain can produce an avalanche of inconsistent data, resulting in <em>weeks</em> of data forensics and reconciliation.</p>&#13;
&#13;
<p>To stop split-brain, disable writes on <em>all</em> instances: <code>SET GLOBAL read_only=1</code>.&#13;
Do not leave one instance writable; that will make the problem worse.&#13;
If you cannot disable writes, then kill MySQL or the server—seriously.&#13;
<em>Data integrity is more important than data availability</em>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Data integrity is more important than data availability.</p>&#13;
</div>&#13;
&#13;
<p>Ideally, you should take the entire database offline until all inconsistent data is found and reconciled.&#13;
But realistically, if a prolonged database outage will kill the business and you’re absolutely certain that reading potentially incorrect data will not cause further damage, then you can run MySQL in read-only mode (<code>read_only=1</code>) while you fix data using <a href="https://oreil.ly/JrqIs"><code>super_read_only</code></a> mode.</p>&#13;
&#13;
<p>There are only two ways to find inconsistent rows: run <a href="https://oreil.ly/Dr10P"><code>pt-table-sync</code></a>, or check manually.&#13;
Manually entails whatever you can do to compare and verify rows given your understanding of the application, the data, and what changes were likely to have occurred during the split-brain.&#13;
<code>pt-table-sync</code> is an open source tool that can find, print, and synchronize data differences between two MySQL instances, but use it with caution because any tool that changes data is inherently risky.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><code>pt-table-sync</code> is a dangerous tool unless you wield it carefully.&#13;
Do <em>not</em> use its <code>--execute</code> option: only use <code>--print</code>, and reads its manual thoroughly.</p>&#13;
</div>&#13;
&#13;
<p>Reconciling rows is the difficult part, and you should work with a MySQL expert to ensure that it’s done correctly.&#13;
If you’re lucky, you’ll determine that one MySQL instance is authoritative—all rows have the correct data—and you can rebuild rather than reconcile: rebuild all replicas from the authoritative instance.&#13;
If you’re not lucky, then work with a MySQL expert to determine your options.<a data-primary="split-brain" data-startref="split-brain1" data-type="indexterm" id="idm45829096600080"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Drift Is Real but Invisible" data-type="sect1"><div class="sect1" id="data-drift">&#13;
<h1>Data Drift Is Real but Invisible</h1>&#13;
&#13;
<p><em>Data drift</em> refers to <a data-primary="data drift" data-type="indexterm" id="idm45829096597136"/>inconsistent data: one or more rows have different values on different MySQL instances in the same replication topology.&#13;
(<em>Drift</em> is figurative for the values drifting further apart as changes to the inconsistent data cause further inconsistencies.)&#13;
Whereas inconsistent data from a split-brain scenario is expected, inconsistent data from data drift is unexpected: you don’t know or have any reason to suspect that there is inconsistent data.&#13;
Although data drift is invisible in the sense that it does not seem to cause a problem, it is nevertheless a real problem because the application could return wrong values.</p>&#13;
&#13;
<p>Fortunately, data drift is easy to detect: run <a href="https://oreil.ly/mogUa"><code>pt-table-checksum</code></a>.&#13;
This tool is safe: it only reads and compares data.&#13;
Unfortunately, data drift is no easier to reconcile than inconsistent data due to split-brain.&#13;
But that probably won’t be an issue because data drift tends to be limited and isolated in scope—not an avalanche of inconsistent data—because it’s not caused by a serious failure like split-brain.</p>&#13;
&#13;
<p>The fascinating aspect of data drift is that, to my knowledge, no one has ever found or proven the root cause of data drift in the wild (in a real production database).&#13;
In theory, it’s caused by nondeterministic queries and statement-based replication, or writes on replicas.&#13;
In a laboratory, those two would surely cause data drift, but they never seem to be the cause in the wild.&#13;
Instead, engineers and DBAs alike are certain that nothing was done to cause or permit data drift.&#13;
And yet, it exists.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Check for data drift every few months (or once a year at the very least) by running <a href="https://oreil.ly/mogUa"><code>pt-table-checksum</code></a>.&#13;
If you find data drift once, don’t worry about it: reconcile the rows, and check again in a month.&#13;
If data keeps drifting (which is very unlikely), then you have an exotic problem worth a detailed investigation to find and fix the root cause.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t Trust ORM" data-type="sect1"><div class="sect1" id="dont-trust-orm">&#13;
<h1>Don’t Trust ORM</h1>&#13;
&#13;
<p>The purpose of object-relational mapping (ORM) <a data-primary="object-relational mapping (ORM)" data-type="indexterm" id="object-relational-mapping-ch9"/>is to aid programmers by abstracting data access into programming terms and objects.&#13;
ORM is not inherently bad or inefficient, but you should verify queries generated by an ORM  library because performance is not its purpose.&#13;
For example, since ORM treats rows as objects, an ORM library might select all columns, which is contrary to what you saw in the efficient data access checklist (<a data-type="xref" href="ch03.html#data-access-checklist">Table 3-2</a>).&#13;
Another example: some ORM libraries execute other queries (<code>SHOW WARNINGS</code>, for example) before or after the actual application query.&#13;
When striving for maximum performance, every query is important; other queries are unacceptable waste.</p>&#13;
&#13;
<p>There are high-performance applications that use ORM, but the engineers are careful not to trust ORM: they verify ORM-generated queries in the query profile and query report (see <a data-type="xref" href="ch01.html#query-profile">“Query profile”</a> and <a data-type="xref" href="ch01.html#query-report">“Query report”</a>, respectively).&#13;
If an ORM-generated query is too inefficient, read the ORM library documentation to learn how to configure it to generate a more efficient query.<a data-primary="object-relational mapping (ORM)" data-startref="object-relational-mapping-ch9" data-type="indexterm" id="idm45829096583104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Schemas Always Change" data-type="sect1"><div class="sect1" id="schemas-always-change">&#13;
<h1>Schemas Always Change</h1>&#13;
&#13;
<p>You probably already know this challenge, but in case you’re brand new to life with any relational database: schemas always change.&#13;
(More specifically, table definitions always change, but tables constitute a schema.)&#13;
The challenge is doing an <em>online schema change</em> (OSC): <a data-primary="online schema changes (OSC)" data-type="indexterm" id="idm45829096579456"/>changing a schema while it’s in use, without affecting the application.&#13;
As mentioned in previous chapters, there are three great solutions for MySQL:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/brtmM">pt-online-schema-change</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/ZKQAd"><code>gh-ost</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/GRQuf"><code>ALTER TABLE</code></a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Each solution works very differently, but all of them can alter a table definition online without affecting the application.&#13;
Read the documentation for each to decide which one works best for you.</p>&#13;
&#13;
<p>There’s another aspect to this challenge: integrating schema changes into the software development process.&#13;
You can run an OSC manually, but engineering teams don’t do that because, like other code changes, schema changes need to be a part of the development process so they are reviewed, approved, tested in staging, and so forth.&#13;
Since development processes are team-specific, your team will have to create its own solution.&#13;
But there is currently one open source solution: <a href="https://www.skeema.io">Skeema</a>.&#13;
For a thorough read on how renowned MySQL expert Shlomi Noach <a data-primary="Noach, Shlomi" data-type="indexterm" id="idm45829096571536"/>solved this challenge at GitHub, read his blog post <a href="https://oreil.ly/9cEJi">“Automating MySQL Schema Migrations with GitHub Actions and More”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="MySQL Extends Standard SQL" data-type="sect1"><div class="sect1" id="mysql-not-standard">&#13;
<h1>MySQL Extends Standard SQL</h1>&#13;
&#13;
<p>If you use only MySQL, then perhaps you can skip this challenge.<a data-primary="MySQL extensions to SQL standard" data-type="indexterm" id="idm45829096567888"/>&#13;
But if you’re coming from (or going to) another relational database, then be aware that MySQL has many extensions to standard SQL enumerated in <a href="https://oreil.ly/gLN1l">“MySQL Extensions to Standard SQL”</a> in the MySQL manual.&#13;
And MySQL does not support some standard SQL features, like full outer joins.&#13;
There are other restrictions and limitations cataloged in the aptly named excerpt <a href="https://oreil.ly/x3xro">“MySQL Restrictions and Limitations”</a>, and you will find other mentions and oddities throughout the MySQL manual.</p>&#13;
&#13;
<p>Any database with a history as long and storied as MySQL is bound to be equally eclectic.&#13;
What’s uniquely MySQL about MySQL is something that experts have come to know and trust so naturally that it’s rarely pointed out: the <a href="https://oreil.ly/IXARN">MySQL Manual</a> is comprehensive and authoritative.&#13;
Software documentation can be sparse, out of date, or nonexistent, but not the MySQL manual.&#13;
There are arcane bits of information about MySQL not in the manual, but those aside, MySQL experts rely heavily on the MySQL manual—and so should you.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Noisy Neighbors" data-type="sect1"><div class="sect1" id="noisy-neighbors">&#13;
<h1>Noisy Neighbors</h1>&#13;
&#13;
<p>On a physical <a data-primary="noisy neighbors" data-type="indexterm" id="noisy-neighbors_index1"/>server, a <em>noisy neighbor</em> is a program that degrades performance for other programs by using inordinately more system resources.&#13;
For example, if a server is running 20 separate MySQL instances, but one of them uses all the CPU and disk I/O, then it’s a noisy neighbor.&#13;
This is a common challenge because a <em>shared server</em> (or <em>multitenancy</em>) is the norm: running multiple virtualized environments on a single physical server.&#13;
(The opposite, a <em>dedicated server</em> [or <em>single-tenancy</em>], is rare and expensive, especially in the cloud.)&#13;
A noisy neighbor is a perplexing challenge because the performance impact is not your fault, but it is your problem.</p>&#13;
&#13;
<p>If your company runs its own hardware, then the problem is tractable: measure the resource usage of each program or virtual environment on the shared server where you suspect a noisy neighbor.&#13;
Noisy neighbors are easy to spot because they’re noisy.&#13;
Then move the noisy neighbor (or your database) to another, quieter server.&#13;
If that’s not possible, then buy another copy of this book for the noisy neighbor so they can learn how to optimize MySQL performance.</p>&#13;
&#13;
<p>In the cloud, you cannot see or prove the existence of a noisy neighbor.&#13;
For security, cloud providers maintain strict separation of tenants (customers like you) on shared servers.&#13;
And they are unlikely to admit the existence of a noisy neighbor because it would imply that they are not balancing the server load, which should be included in the cost.&#13;
Consequently, the standard practice is to reprovision a cloud database when you suspect a noisy neighbor.&#13;
Some companies benchmark a cloud resource before using it and only keep it if performance meets a baseline; else, the resource is destroyed, another one is provisioned, and the process repeats until—by chance—the resource is provisioned on a quiet server.<a data-primary="noisy neighbors" data-startref="noisy-neighbors_index1" data-type="indexterm" id="idm45829096555504"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Applications Do Not Fail Gracefully" data-type="sect1"><div class="sect1" id="app-fail-gracefully">&#13;
<h1>Applications Do Not Fail Gracefully</h1>&#13;
&#13;
<p>Netflix originated <em>chaos engineering</em>: <a data-primary="chaos engineering" data-type="indexterm" id="idm45829096552368"/>intentionally introducing problems and failures into a system to test its resiliency and necessitate that engineers design for failure.&#13;
This philosophy and practice is bold because it <em>truly</em> tests the mettle of an application.&#13;
Writing software that works correctly when everything around it also works correctly is an expectation so basic and obvious that it counts for nothing.&#13;
The challenge is to write software that works—in some capacity—even when everything around it is failing.&#13;
As engineers, we often think that we have accounted for failure in our software, but how do we know until something fails for real?&#13;
Plus, not all failures are binary: working or not working.&#13;
The most insidious problems are not outright failures but, rather, edge cases and outliers: the kind of problem that requires a story to explain it, not a simple failure statement like “the hard drive died.”</p>&#13;
&#13;
<p>The same is true for applications with respect to MySQL.&#13;
However, chaos engineering is not standard practice in the MySQL industry because trifling with a database is risky and few engineers are so bold.&#13;
But fortune favors the bold, so here are 12 database chaos scenarios to test the mettle of your application:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>MySQL is offline</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL is very slow to respond</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL is read-only</p>&#13;
</li>&#13;
<li>&#13;
<p>MySQL has just started (cold buffer pool)</p>&#13;
</li>&#13;
<li>&#13;
<p>Read replicas are offline or very slow</p>&#13;
</li>&#13;
<li>&#13;
<p>Failover in the same region</p>&#13;
</li>&#13;
<li>&#13;
<p>Failover to a different region</p>&#13;
</li>&#13;
<li>&#13;
<p>Database backup is running</p>&#13;
</li>&#13;
<li>&#13;
<p>DNS resolution is very slow</p>&#13;
</li>&#13;
<li>&#13;
<p>Network is slow (high latency) or saturated</p>&#13;
</li>&#13;
<li>&#13;
<p>One hard drive in a RAID array is degraded</p>&#13;
</li>&#13;
<li>&#13;
<p>Free disk space on an SSD is less than 5%</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Some of those 12 database chaos scenarios might not apply to your infrastructure, but most are standard and yield interesting results depending on the application.&#13;
If you have never engineered chaos, then I encourage you to start because chaos doesn’t wait until you’re ready.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="High Performance MySQL Is Difficult" data-type="sect1"><div class="sect1" id="idm45829096537152">&#13;
<h1>High Performance MySQL Is Difficult</h1>&#13;
&#13;
<p>If you earnestly apply all the best practices and techniques in this book, I am confident that you will achieve remarkable performance with MySQL.&#13;
But that does not mean it’ll be quick or easy.&#13;
High-performance MySQL requires practice because resources—books, blogs, videos, conferences, and so on—teach you theory, which is different than reality.&#13;
Consequently, when you begin to apply what you’ve learned from this book to your application, you might run into the following two challenges.</p>&#13;
&#13;
<p>The first challenge is that real application queries can be—and usually are—more complex than the pithy little examples strewn throughout these pages.&#13;
Add to that the additional challenge of remembering and applying so much knowledge at once: query metrics, indexes and indexing, <code>EXPLAIN</code> output, query optimizations, table definitions, and so forth.&#13;
It can be overwhelming at first, but take it one query at a time, and remember <a data-type="xref" href="ch01.html#north-star">“North Star”</a> and <a data-type="xref" href="ch02.html#think-like-mysql">“Indexing: How to Think Like MySQL”</a>.&#13;
Even experts need time to unravel and understand the full story of a query.</p>&#13;
&#13;
<p>The second challenge is that real application performance rarely depends on a single aspect of the workload.&#13;
Fixing slow queries will undoubtedly help, but it might not help enough.&#13;
The more performance you need from MySQL, the more you have to optimize the entire workload: each query, all data, and every access pattern.&#13;
Eventually you will need to apply knowledge from every chapter of this book.&#13;
(Except <a data-type="xref" href="ch10.html#ch10">Chapter 10</a> if you’re not using MySQL in the cloud.)&#13;
Start small (Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch01.html#ch01">1</a>–<a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a>), but commit to learning and applying everything in this book because you will need it.</p>&#13;
&#13;
<p>There is more to MySQL performance than I present in this book, but I assure you: the knowledge imparted in these chapters is comprehensive and effective.&#13;
Moreover, there are no secrets known only to experts that unlock amazing MySQL performance.&#13;
I know that from my own experience and also from having worked with many of the best MySQL experts in the world.&#13;
Plus, open source software is terrible at keeping secrets.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Practice: Identify the Guardrails that Prevent Split-Brain" data-type="sect1"><div class="sect1" id="idm45829096526928">&#13;
<h1>Practice: Identify the Guardrails that Prevent Split-Brain</h1>&#13;
&#13;
<p>The goal of this practice is to identify the guardrails that prevent split-brain.<a data-primary="split-brain" data-type="indexterm" id="split-brain2"/>&#13;
There are two parts: detailing the guardrails so that every engineer understands what they are, where they are (probably in tools), and how they work, and then carefully reviewing tools that manage or change MySQL instances, especially failover tools.</p>&#13;
&#13;
<p>If you do not manage MySQL, then schedule time with the engineers who manage MySQL to have them detail how they prevent split-brain during operations, especially failover.&#13;
This should be an easy request because preventing split-brain is fundamental to managing MySQL.</p>&#13;
&#13;
<p>If you use MySQL in the cloud, the details vary.&#13;
Cloud providers have undisclosed methods to prevent split-brain depending on the internal setup and management of MySQL.&#13;
For example, split-brain is theoretically not possible with a standard multi-AZ instance of Amazon RDS for MySQL because, although it’s multi-AZ, multiple instances of MySQL do not run at the same time.&#13;
(It’s a single running instance of MySQL in one availability zone [AZ].&#13;
If that instance fails, another instance is started in another AZ.)&#13;
But if you add read replicas, then you have multiple running instances of MySQL in the same replication topology, and Amazon does not make any guarantees about split-brain with respect to read replicas.&#13;
In the cloud, presume that you are responsible for the guardrails that prevent split-brain, but also know when the cloud provider does and does not prevent split-brain.</p>&#13;
&#13;
<p>If you manage MySQL on your own hardware, then I advise you to contract a MySQL expert to help you identify the guardrails that prevent split-brain.&#13;
(It shouldn’t take long, so it should be a short and affordable contract.)&#13;
There is one foundational guardrail that you must implement: configure MySQL (in its <em>my.cnf</em> file) to start in read-only mode: <code>read_only=1</code>.&#13;
Always start MySQL in read-only mode.&#13;
From this foundation, other guardrails detail how read-only mode is toggled such that it’s guaranteed to be off (MySQL is writable) on only one instance at a time.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Always start MySQL in read-only mode (<code>read_only=1</code>).</p>&#13;
</div>&#13;
&#13;
<p>Once the guardrails are understood by engineers, the second part is to carefully review tools that manage or change MySQL instances, especially failover tools, to ensure that the guardrails are implemented and working as expected.&#13;
Of course, all code should be unit tested, but preventing split-brain is so important that it warrants manual code review, too.&#13;
There are issues in code that might not surface when identifying the guardrails; for example: race conditions, retries, and error handling.&#13;
The last—error handling—is especially important: can (or should) a tool roll back changes on error?&#13;
Remember: data integrity is more important than data availability.&#13;
When toggling MySQL read-only, tools should err on the side of caution: if an operation has a nonzero chance of causing split-brain, don’t do it; leave MySQL in read-only mode, fail, and let a human figure it out.</p>&#13;
&#13;
<p>Bottom line: be 100% clear on the guardrails that prevent split-brain.<a data-primary="split-brain" data-startref="split-brain2" data-type="indexterm" id="idm45829096516704"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Practice: Check for Data Drift" data-type="sect1"><div class="sect1" id="ch10-ai-1">&#13;
<h1>Practice: Check for Data Drift</h1>&#13;
&#13;
<p>The goal of this practice is to check for data drift <a data-primary="data drift" data-type="indexterm" id="idm45829096513440"/>using <a href="https://oreil.ly/mogUa"><code>pt-table-checksum</code></a>.&#13;
You’re in luck: this tool was purposely written to be easy and automatic.&#13;
Simply download and run the tool, and it automates the rest in most cases.&#13;
If not, a quick read through its documentation will answer any questions.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Most MySQL tools need special configuration to work with MySQL in the cloud.</p>&#13;
</div>&#13;
&#13;
<p><code>pt-table-checksum</code> does only one thing: check for and report data drift.&#13;
It can run for hours or days depending on data size and access load.&#13;
By default, it’s slow to avoid interfering with production access.&#13;
Therefore, be sure to run it in a <code>screen</code> or <code>tmux</code> session.</p>&#13;
&#13;
<p>When <code>pt-table-checksum</code> finishes checking a table, it prints a one-line result for the table.&#13;
The output looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">            TS ERRORS  DIFFS  ROWS  DIFF_ROWS CHUNKS SKIPPED    TIME TABLE&#13;
10-21T08:36:55      0      0   200          0      1       0   0.005 db1.tbl1&#13;
10-21T08:37:00      0      0   603          0      7       0   0.035 db1.tbl2&#13;
10-21T08:37:10      0      2  1600          3     21       0   1.003 db2.tbl3</pre>&#13;
&#13;
<p>The last line of the output reveals a table with data drift because column <code>DIFFS</code> has a nonzero value.&#13;
If any table has data drift, rerun with the <code>--replicate-check-only</code> option to print the replicas and chunks that are different than the source.&#13;
(A <em>chunk</em> is a range of rows delineated by upper and lower boundary values for an index [usually the primary key].&#13;
<code>pt-table-checksum</code> verifies rows in chunks because checking individual rows is too slow and inefficient.)&#13;
You will need to devise a plan to isolate and reconcile inconsistent rows.&#13;
If there are very few, you might be able to isolate and reconcile them manually.&#13;
If not, then I advise you to work with a MySQL expert to ensure it’s done correctly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Practice: Chaos" data-type="sect1"><div class="sect1" id="ch10-ai-3">&#13;
<h1>Practice: Chaos</h1>&#13;
&#13;
<p>The goal of this practice is to test the mettle of your application.&#13;
Chaos engineering <a data-primary="chaos engineering" data-type="indexterm" id="idm45829096501568"/>is not for the faint of heart, so start with your staging database.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This practice will cause outages.</p>&#13;
</div>&#13;
&#13;
<p>For the following chaos, MySQL and the application should be running normally with some load, and you should have good metrics and observability into both to record and analyze how they respond.</p>&#13;
&#13;
<p>I propose the following chaos, but pick and choose based on your level of risk:</p>&#13;
<dl>&#13;
<dt>Restart MySQL</dt>&#13;
<dd>&#13;
<p>Restarting MySQL tests how the application responds when MySQL is offline, and how it responds when MySQL buffers are cold (specifically, the InnoDB buffer pool).&#13;
Cold buffers require disk I/O to read data into memory, which causes slower than usual response time.&#13;
It also teaches you three things: how long it takes MySQL to shutdown, how long it takes MySQL to start up, and how long it takes the buffers to warm up.</p>&#13;
</dd>&#13;
<dt>Enable read-only mode</dt>&#13;
<dd>&#13;
<p><code>SET GLOBAL read_only=1</code> on the source instance to enable read-only mode and test how the application responds to being able to read data but not write data.&#13;
Engineers often think that the application will continue working for reads and gracefully fail for writes, but chaos is full of surprises.&#13;
This also effectively simulates a failed failover, which should never happen (because it would mean a failure of high availability), but “should never happen” is within the purview of chaos.</p>&#13;
</dd>&#13;
<dt>Stop MySQL for 1 hour</dt>&#13;
<dd>&#13;
<p>Most applications can weather a storm for seconds or minutes—maybe even tens of minutes—but at some point, queues fill up, retires are exhausted, exponential backoffs become very long, rate limits reset, and users give up and go to a competitor.&#13;
MySQL should never be offline more than a few seconds—if properly managed—but again: chaos.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Back in 2004 when I worked in a data center, moments before I started my 2 p.m. to midnight shift, an engineer accidentally hit the emergency power off button—<em>to the data center</em>.&#13;
Calm is the only answer to chaos, so I got a cup of coffee before sitting down to help reboot the data center.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>