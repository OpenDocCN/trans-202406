- en: Chapter 3\. Beyond the Basics with Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at the most frequently used Helm commands.
    In this chapter we will explore other capabilities that the Helm tool provides.
    We will dive into commands that provide information about releases, that test
    installations, and that keep track of history. Finally, we will revisit installing
    and upgrading, this time covering advanced cases.
  prefs: []
  type: TYPE_NORMAL
- en: We will get started with some tools helpful for troubleshooting and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Templating and Dry Runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Helm installs a release, the program steps through several phases. It loads
    the chart, parses the values passed to the program, reads the chart metadata,
    and so on. Near the middle of the process, Helm compiles all of the templates
    in the chart (all in one pass), and then renders them by passing in the values
    (like we saw in the previous chapter). During this middle portion, it executes
    all of the template directives. Once the templates are rendered into YAML, Helm
    verifies the structure of the YAML by parsing it into Kubernetes objects. Finally,
    Helm serializes those objects and sends them to the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roughly, then, the process is:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the entire chart, including its dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the templates, generating YAML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the YAML into Kubernetes objects to verify the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send it to Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let’s look at one of the commands we issued in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first phase, Helm will locate the chart named `bitnami/drupal` and load
    that chart. If the chart is local, it will be read off of disk. If a URL is given,
    it will be fetched from the remote location (possibly using a plugin to assist
    in fetching the chart).
  prefs: []
  type: TYPE_NORMAL
- en: Then it will transform `--set drupalUsername=admin` into a value that can be
    injected into the templates. This value will be combined with the default values
    in the chart’s *values.yaml* file. Helm does some basic checks against the data.
    If it has trouble parsing the user input, or if the default values are corrupt,
    it will exit with an error. Otherwise, it will build a single big values object
    that the template engine can use for substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: The generated values object is created by loading all of the values of the chart
    file, overlaying any values loaded from files (that is, with the `-f` flag), and
    then overlaying any values set with the `--set` flag. In other words, `--set`
    values override settings from passed-in values files, which in turn override anything
    in the chart’s default *values.yaml* file.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, Helm will read all of the templates in the Drupal chart, and
    then execute those templates, passing the merged values into the template engine.
    Malformed templates will cause errors. But there are a variety of other situations
    that may cause failure here. For example, if a required value is missing, it is
    at this phase that an error is returned.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that, when executed, some Helm templates require information
    about Kubernetes. So during template rendering, Helm *may* contact the Kubernetes
    API server. This is an important topic that we will discuss in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the preceding step is then parsed from YAML into Kubernetes objects.
    Helm will perform some schema-level validation at this point, making sure that
    the objects are well-formed. Then they will be serialized into the final YAML
    format for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In the last phase, Helm sends the YAML data to the Kubernetes API server. This
    is the server that `kubectl` and other Kubernetes tools interact with.
  prefs: []
  type: TYPE_NORMAL
- en: The API server will run a series of checks on the submitted YAML. If Kubernetes
    accepts the YAML data, Helm will consider the deployment a success. But if Kubernetes
    rejects the YAML, Helm will exit with an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, we’ll go into detail about what happens once the objects are sent
    to Kubernetes. In particular, we’ll cover how Helm associates the process described
    earlier with an installation and revisions. But right now, we have enough information
    about workflow to understand two related Helm features: the `--dry-run` flag and
    the `helm template` command.'
  prefs: []
  type: TYPE_NORMAL
- en: The --dry-run Flag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Commands like `helm install` and `helm upgrade` provide a flag named `--dry-run`.
    When you supply this flag, it will cause Helm to step through the first four phases
    (load the chart, determine the values, render the templates, format to YAML).
    But when the fourth phase is finished, Helm will dump a trove of information to
    standard output, including all of the rendered templates. Then it will exit without
    sending the objects to Kubernetes and without creating any release records.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a version of our previous Drupal install with the `--dry-run`
    flag appended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the output, it will print some information about the release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding tells us what the name of the installation is, when it was last
    deployed (in this case, the current date and time), which namespace it would have
    been deployed into, what phase of the release it is in (`pending-install`), and
    the revision number. Since this is an install, the revision is `1`. On upgrade,
    it would be `2` or greater.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if this chart declared any hooks, they would be enumerated here. For
    more on hooks, see Chapters [6](ch06.xhtml#advanced_charts) and [7](ch07.xhtml#chart_repositories).
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it might seem that this metadata entry has a lot of unnecessary
    data. After all, what good does `LAST DEPLOYED` do if we are not actually installing?
    In fact, this chunk of information is a standard set used throughout Helm. It
    is part of the *release record*: a set of information about a release. Commands
    like `helm get` use these same fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after the informational block, all of the rendered templates are dumped
    to standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The rendered Drupal chart is thousands of lines, so the preceding just shows
    the first several lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the bottom of the dry-run output, Helm prints the user-oriented
    release notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The example is truncated for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: This dry-run feature provides Helm users a way to debug the output of a chart
    before it is sent on to Kubernetes. With all of the templates rendered, you can
    inspect exactly what would have been submitted to your cluster. And with the release
    data, you can verify that the release would have been created as you expected.
  prefs: []
  type: TYPE_NORMAL
- en: The principal purpose of the `--dry-run` flag is to give people a chance to
    inspect and debug output before sending it on to Kubernetes. But soon after it
    was introduced, Helm maintainers noticed a trend among users. People wanted to
    use `--dry-run` to use Helm as a template engine, and then use other tools (like
    `kubectl`) to send the rendered output to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'But `--dry-run` wasn’t written with this use case in mind, and that caused
    a few problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--dry-run` mixes non-YAML information with the rendered templates. This means
    the data has to be cleaned up before being sent to tools like `kubectl`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `--dry-run` on upgrade can produce different YAML output than a `--dry-run`
    on install, and this can be confusing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It contacts the Kubernetes API server for validation, which means Helm has to
    have Kubernetes credentials even if it is just used to `--dry-run` a release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It also inserts information into the template engine that is cluster-specific.
    Because of this, the output of some rendering processes may be cluster-specific.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To remedy these problems, the Helm maintainers introduced a completely separate
    command: `helm template`.'
  prefs: []
  type: TYPE_NORMAL
- en: The helm template Command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `--dry-run` is designed for debugging, `helm template` is designed to
    isolate the template rendering process of Helm from the installation or upgrade
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we looked at the five phases of a Helm install or upgrade. The `template`
    command performs the first four phases (load the chart, determine the values,
    render the templates, format to YAML). But it does this with a few additional
    caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: During `helm template`, Helm *never* contacts a remote Kubernetes server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `template` command always acts like an installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template functions and directives that would normally require contacting a Kubernetes
    server will instead only return default data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chart only has access to default Kubernetes kinds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding the last item, `helm template` makes a notable simplifying assumption.
    Kubernetes servers support built-in kinds (`Pod`, `Service`, `ConfigMap`, and
    so on) as well as custom kinds generated by custom resource definitions (CRDs).
    When running an install or upgrade, Helm fetches those kinds from the Kubernetes
    server before processing the chart.
  prefs: []
  type: TYPE_NORMAL
- en: However, `helm template` does this step differently. When Helm is compiled,
    it is compiled against a particular version of Kubernetes. The Kubernetes libraries
    contain the list of built-in kinds for that release. Helm uses that built-in list
    instead of a list it fetches from the API server. For this reason, Helm does not
    have access to any CRDs during a `helm template` run, since CRDs are installed
    on the cluster and are not included in the Kubernetes libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Running an old version of Helm against a chart that uses new kinds or versions
    can produce an error during `helm template` because Helm will not have the newest
    kinds or versions compiled into it.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of these decisions, `helm template` produces consistent output run
    after run. More importantly, it can be run in an environment that does not have
    access to a Kubernetes cluster, like a continuous integration (CI) pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is also different from `--dry-run`. Here’s an example command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is a greatly abridged version of the output, showing just the
    command and a sample of the beginning data and the end of the data. The important
    thing to note, though, is that *only* the YAML-formatted Kubernetes manifest is
    printed by default.
  prefs: []
  type: TYPE_NORMAL
- en: Because Helm does not contact a Kubernetes cluster during a `helm template`
    run, it does not do complete validation of the output. It is possible that Helm
    will not catch some errors in this case. You may choose to use the `--validate`
    flag if you want that behavior, but in this case Helm will need a valid *kubeconfig*
    file with credentials for a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The `helm template` command has a broad number of flags that mirror those in
    `helm install`. So in many cases, you can execute a `helm template` command just
    as you would a `helm install`, but then capture the YAML and use it with other
    tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Post-Render Instead of Helm Template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you want to intercept the YAML, modify it with your own tool, and
    then load it into Kubernetes. Helm provides a way to execute this external tool
    without having to resort to using `helm template`. The flag `--post-renderer`
    on the `install`, `upgrade`, `rollback`, and `template` will cause Helm to send
    the YAML data to the command, and then read the results back into Helm. This is
    a great way to work with tools like Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, `helm template` is a tool for rendering Helm charts into YAML,
    and the `--dry-run` flag is a tool for debugging installation and upgrade commands
    without loading the data into Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Learning About a Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we got a glimpse of the `helm get` command. At this
    point, we will take a deeper look into that command and others that provide us
    with information *about* Helm releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let’s revisit the five phases of a Helm installation from the previous
    section. They were:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the templates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the YAML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send it to Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first four phases are primarily concerned with a local representation of
    the data. That is, Helm is doing all of the processing on the same computer that
    the `helm` command is run on.
  prefs: []
  type: TYPE_NORMAL
- en: During the last phase, though, Helm sends that data to Kubernetes. And then
    the two communicate back and forth until the release is either accepted or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: During that fifth phase, Helm must monitor the state of the release. Moreover,
    since many individuals may be working on the same copy of that particular application
    installation, Helm needs to monitor the state in such a way that *multiple users*
    can see that information.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides this feature with *release records*.
  prefs: []
  type: TYPE_NORMAL
- en: Release Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we install a Helm chart (with `helm install`), the new installation is
    created in the namespace you specify, or the default namespace. We looked at this
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of that chapter, we also saw how `helm install` creates a special
    type of Kubernetes `Secret` that holds release information. We saw how we could
    inspect these `Secret`s with `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of particular note is that last `Secret`, `sh.helm.release.v1.mysite.v1`. Notice
    that it uses a special type (`helm.sh/release.v1`) to indicate that it is a Helm
    secret. Helm automatically generated this secret to track version 1 of our `mysite`
    installation (which is a Drupal site).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time we upgrade that `mysite` installation, a new `Secret` will be created
    to track each release. In other words, a release record tracks each *revision*
    of an *installation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have upgraded a few times, and now we are at `v3`
    of `mysite`. By default, Helm tracks up to ten revisions of each installation.
    Once an installation exceeds ten releases, Helm deletes the oldest release records
    until no more than the maximum remain.
  prefs: []
  type: TYPE_NORMAL
- en: Each release record contains enough information to re-create the Kubernetes
    objects for that revision (an important thing for `helm rollback`). It also contains
    metadata about the release.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we looked at the release using `kubectl`, we would see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_beyond_the_basics_with_helm_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The labels contain Helm metadata
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the giant Base64-encoded data has been removed along with a
    few other inessential fields. That blob contains a gzipped representation of the
    chart and release. But importantly, the `labels` section of the Kubernetes metadata
    contains information about this release.
  prefs: []
  type: TYPE_NORMAL
- en: We can see, for instance, that this data describes the release named `mysite`,
    that its current revision number is `3`, and the release is marked `deployed`.
    If we were to look at version `2`, we would see the release `status` is `superseded`,
    which means that it has been replaced by a later version.
  prefs: []
  type: TYPE_NORMAL
- en: In short, this secret is stored inside of Kubernetes so that different users
    of the same cluster have access to the same release information.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the life cycle of a release, it can pass through several different statuses.
    Here they are, approximately in the order you would likely see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pending-install`'
  prefs: []
  type: TYPE_NORMAL
- en: Before sending the manifests to Kubernetes, Helm claims the installation by
    creating a release (marked version 1) whose status is set to `pending-install`.
  prefs: []
  type: TYPE_NORMAL
- en: '`deployed`'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as Kubernetes accepts the manifest from Helm, Helm updates the release
    record, marking it as deployed.
  prefs: []
  type: TYPE_NORMAL
- en: '`pending-upgrade`'
  prefs: []
  type: TYPE_NORMAL
- en: When a Helm upgrade is begun, a new release is created for an installation (e.g.,
    `v2`), and its status is set to `pending-upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: '`superseded`'
  prefs: []
  type: TYPE_NORMAL
- en: When an upgrade is run, the last deployed release is updated, marked as `superseded`,
    and the newly upgraded release is changed from `pending-upgrade` to `deployed`.
  prefs: []
  type: TYPE_NORMAL
- en: '`pending-rollback`'
  prefs: []
  type: TYPE_NORMAL
- en: If a rollback is created, a new release (e.g., `v3`) is created, and its status
    is set to `pending-rollback` until Kubernetes accepts the release manifest. Then
    it is marked `deployed` and the last release is marked `superseded`.
  prefs: []
  type: TYPE_NORMAL
- en: '`uninstalling`'
  prefs: []
  type: TYPE_NORMAL
- en: When a `helm uninstall` is executed, the most recent release is read and then
    its status is changed to `uninstalling`.
  prefs: []
  type: TYPE_NORMAL
- en: '`uninstalled`'
  prefs: []
  type: TYPE_NORMAL
- en: If history is preserved during deletion, then when the `helm uninstall` is complete,
    the last release’s status is changed to `uninstalled`.
  prefs: []
  type: TYPE_NORMAL
- en: '`failed`'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if during *any* operation, Kubernetes rejects a manifest submitted
    by Helm, Helm will mark that release `failed`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Releases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Status messages show up in a number of Helm commands. We already saw how `pending-install`
    appears in a `--dry-run`. In this section and the next, we’ll see a few more places
    where this appears.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we used `helm list` to see the charts we had installed.
    Given our coverage of status, it is worth revisiting `helm list`. The `list` command
    is the best tool for quickly checking on the statuses of your releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we have a cluster with both the `drupal` and `wordpress` charts
    installed. Here is the output of `helm list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the result of a failure, though, we can run an upgrade command that
    we know will break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As the error message indicates, a pull policy cannot be set to `NoSuchPolicy`.
    This error came from the Kubernetes API server, which means Helm submitted the
    manifest, and Kubernetes rejected it. So our release should be in a failed state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this by running `helm ls` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting again that the `REVISION` field for our newly failed `wordpress`
    installation has been incremented from `2` to `3`. Even failed releases have revisions
    attached to them. We’ll see why this is important in [“History and Rollbacks”](#history_and_rollbacks).
  prefs: []
  type: TYPE_NORMAL
- en: Find Details of a Release with helm get
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `helm list` provides a summary view of installations, the `helm get` set
    of commands provide deeper information about a particular release.
  prefs: []
  type: TYPE_NORMAL
- en: There are five `helm get` subcommands (`hooks`, `manifests`, `notes`, `values`,
    and `all`). Each subcommand retrieves some portion of the information Helm tracks
    for a release.
  prefs: []
  type: TYPE_NORMAL
- en: Using helm get notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `helm get notes` subcommand prints the release notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This output should look familiar, as `helm install` and `helm upgrade` both
    print the release notes at the end of a successful operation. But `helm get notes`
    provides a convenient way to grab these notes on demand. That is useful in cases
    where you’ve forgotten what the URL is to your Drupal site.
  prefs: []
  type: TYPE_NORMAL
- en: Using helm get values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One useful subcommand is `values`. You can use this to see which values were
    supplied during the last release. In the previous section, we upgraded a WordPress
    installation and caused it to fail. We can see what values caused it to fail using
    `helm get values`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that revision 2 was successful, but revision 3 failed. So we can take
    a look at the earlier values to see what changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can see that one value was removed and one value was added. Features
    like this are designed to make it easier for Helm users to identify the source
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is also useful for learning about the total state of a release’s
    configuration. We can use `helm get values` to see *all* of the values currently
    set for that release. To do this, we use the `--all` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the `--all` flag is specified, Helm will get the complete computed set
    of values, sorted alphabetically. This is a great tool for seeing the exact state
    of configuration for the release.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing Default Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although `helm get values` does not have a way of showing you the default values,
    you can see those with `helm inspect values CHARTNAME`. This inspects the chart
    itself (not the release) and prints out the documented default *values.yaml* file.
    Thus, we could use `helm inspect values bitnami/wordpress` to see the default
    configuration for the WordPress chart.
  prefs: []
  type: TYPE_NORMAL
- en: Using helm get manifest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last `helm get` subcommand that we will cover is `helm get manifest`. This
    sub-command retrieves the exact YAML manifest that Helm produced using the Chart
    templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'One important detail about this command is that it does not return the *current
    state* of all of your resources. It returns *the manifest generated from the template*.
    In the preceding example, we see a `Secret` named `wordpress-mariadb`. If we query
    that `Secret` using `kubectl`, the `metadata` section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output of `kubectl` contains the record as it currently exists in Kubernetes.
    There are several fields that have been added since the template output. Some
    (like the annotations) are managed by Helm itself, and others (like `managedFields`
    and `creationTimestamp`) are managed by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, Helm provides tools designed to ease debugging. Between `helm get
    manifest` and `kubectl get`, you have tools for comparing what Kubernetes thinks
    is the current object with what the chart produced. This is particularly helpful
    when a resource that should be managed by Helm was manually edited outside of
    Helm (e.g., using `kubectl edit`).
  prefs: []
  type: TYPE_NORMAL
- en: With `helm get`, we can closely inspect an individual release. But the next
    tool we will cover provides us a view of the progression of releases. In the next
    section, we will look at `helm history` and `helm rollback`.
  prefs: []
  type: TYPE_NORMAL
- en: History and Rollbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, we have distinguished between installations and revisions.
    In this chapter, we have been working with an installation named `mysite` and
    another installation named `wordpress`. And when we ran `helm list` earlier, we
    saw that each installation had three releases. Moreover, we saw that `wordpress`
    was in a failed state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can investigate the release history of WordPress to see what happened. To
    do this, we will use `helm history`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The output of this command gives us a nice history of the `wordpress` release.
    First it was installed, and then it was upgraded and marked deployed (which means
    that it was a successful upgrade). But when it was upgraded again, that upgrade
    `failed`. The `helm history` command even gives us the error message that Kubernetes
    returned when marking the release `failed`.
  prefs: []
  type: TYPE_NORMAL
- en: From the error, we know that the release failed because we supplied an invalid
    image pull policy. So of course we could correct this by simply running another
    `helm upgrade`. But imagine a case where the cause of error was not readily available.
    Rather than leave the application in a failed state while diagnosing the problem,
    it would be nice to simply revert back to the release that worked before.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what `helm rollback` is for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command tells Helm to fetch the `wordpress` version `2` release, and resubmit
    that manifest to Kubernetes. A rollback does *not* restore to a previous snapshot
    of the cluster. Helm does not track enough information to do that. What it does
    is resubmit the previous configuration, and Kubernetes attempts to reset the resources
    to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can once again use `helm history` to see what has happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The rollback operation created a new revision (`4`). Since the rollback was
    successful (and Kubernetes accepted the alterations), the release is marked `deployed`.
    Note that revision `2` is now marked `superseded`, while the failed release `3`
    is still marked `failed`.
  prefs: []
  type: TYPE_NORMAL
- en: Because Helm has preserved the history, you can still examine the failed release
    after rolling back to a known-good configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, `helm rollback` is a great way to recover from a catastrophe.
    But if you hand-edit resources that are managed by Helm, an interesting problem
    may arise. Rollbacks can on occasion cause some unexpected behavior, especially
    if the Kubernetes resources have been hand-edited by users. Helm and Kubernetes
    will attempt to preserve those hand-edits if they do not conflict with the rollback.
    Essentially, a rollback will generate a 3-way diff between the current state of
    the resources, the failed Helm release, and the Helm release that you roll back
    to. In some cases, the generated diff may result in rolling back handmade edits,
    while in other cases those discrepancies will be merged. In the worst case, some
    handmade edits may be overwritten while other related edits are merged, leading
    to an inconsistency in configuration. This is one of the many reasons Helm core
    maintainers recommend against hand-editing resources. If all edits are made through
    Helm, then you can use Helm tools effectively and with no guesswork.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping History and Rolling Back
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw that the `helm uninstall` command has a flag
    called `--keep-history`. Normally, a deletion event will destroy all release records
    associated with that installation. But when `--keep-history` is specified, you
    can see the history of an installation even after it has been deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the last release is now marked as `uninstalled`. When history is
    preserved, you can roll back a deleted installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can see a newly deployed release `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But without the `--keep-history` flag, this will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A Deep Dive into Installs and Upgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml#Using_Helm) we took a first look at installing and
    upgrading Helm packages, and throughout this chapter we have looked at tools that
    help us work with Helm installations. To close out this chapter, we will circle
    back to installation and upgrading and look at a few advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: The --generate-name and --name-template Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the subtle dangers of the way Kubernetes works has to do with naming.
    Kubernetes assumes that names will have certain uniqueness properties. For example,
    a `Deployment` object must have a name unique within its namespace. That is, in
    the namespace `mynamespace` I cannot have two `Deployment`s named `myapp`. But
    I can have a `Deployment` and a `Pod` each named `myapp`.
  prefs: []
  type: TYPE_NORMAL
- en: This has made certain tasks a little more complicated. For example, a CI system
    that automatically deploys things must be able to ensure that the name it gives
    these things is unique within the namespace. One approach to dealing with this
    issue is for Helm to provide a tool for generating a unique name. (Another approach
    is to always overwrite a name if it already exits. See the next section for that
    approach.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm provides the `--generate-name` flag for `helm install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `--generate-name` flag, we no longer need to provide a name as the
    first argument to `helm install`. Helm generates a name based on a combination
    of the chart name and a timestamp. In the preceding output, we can see the name
    that was generated for us: `wordpress-1597689085`.'
  prefs: []
  type: TYPE_NORMAL
- en: In Helm 2, “friendly names” were generated using adjectives and animal names.
    That was removed in Helm 3 due to complaints that release names were unprofessional.
    There is currently no way to re-enable this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is an additional flag that allows you to specify a naming template.
    The `--name-template` flag allows you do to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we used the name template `foo-{{ randAlpha 9 | lower }}`.
    This uses the Helm template engine to generate a name for you. We’ll cover the
    Helm template engine in the next few chapters. But here’s what the name template
    does: The `{{` and `}}` demarcate the beginning and end of a template. Inside
    of that template, we are calling the `randAlpha` function, asking for a `9`-character
    random string from the `a-z, A-Z` range of characters. Then we are “piping” the
    results through a second function (`lower`) that lowercases everything.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the output of the earlier example, the result of `{{ randAlpha 9
    | lower }}` was `yejpiyjmp`. So the result of the entire name template was `foo-yejpiyjmp`.
  prefs: []
  type: TYPE_NORMAL
- en: The --create-namespace Flag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another consideration with naming in Kubernetes has to do with namespaces. Earlier,
    we saw that no two objects of the same kind *within the same namespace* can have
    the same name. But Kubernetes also has a concept of global names. CRDs and namespaces
    each have global names.
  prefs: []
  type: TYPE_NORMAL
- en: A namespace, therefore, must be unique cluster-wide.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever Helm encounters globally unique names, it adopts a defensive posture.
    In later chapters, we’ll see how charts handle globally unique names. But here,
    it is worth pointing out that Helm 3 assumes by default that if you attempt to
    deploy a chart into a namespace, that namespace was already created.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on a fresh cluster this will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It fails because `mynamespace` has not already been created and *Helm won’t
    automatically create a namespace*. It won’t create one because namespaces are
    global, and the safe assumption is that when a namespace is created, it probably
    needs access controls (like RBACs) and other things assigned to it before it can
    be safely used in production. In short, it views silently creating a namespace
    as an opportunity for unintentionally creating a security hole.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Helm does let you override this consideration by explicitly stating
    that you want to create a namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By adding `--create-namespace`, we have indicated to Helm that we *acknowledge*
    that there may not be a namespace with that name already, and we just want one
    to be created. Be sure, of course, that if you use this flag on a production instance,
    you have other mechanisms for enforcing security on this new namespace.
  prefs: []
  type: TYPE_NORMAL
- en: There is not an analogous `--delete-namespace` on `helm uninstall`. And the
    reason for this falls out of Helm’s defensiveness regarding global objects. Once
    a namespace is created, any number of objects may be put in the namespace, not
    all of them managed by Helm. And when a namespace is deleted, all of the objects
    inside of that namespace are also deleted. So Helm does not automatically delete
    namespaces that were created with `--create-namespace`. To delete a namespace,
    use `kubectl delete namespace` (after making sure, of course, that no important
    objects exist in that namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Using helm upgrade --install
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some systems, like CI pipelines, are employed to automatically install or upgrade
    a chart each time a significant event occurs. For example, many organizations
    have pipelines that trigger whenever new code is uploaded to a version control
    system (VCS) like Git. GitHub, a popular Git hosting service, even provides tools
    to automatically deploy whenever a code change is merged.
  prefs: []
  type: TYPE_NORMAL
- en: Systems like this often run rudimentary scripts on a stateless platform that
    does not have the means to query Kubernetes. Users of such systems requested a
    Helm feature that would allow “install or upgrade” support in a single command.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this behavior, Helm maintainers added the `--install` flag to
    the `helm upgrade` command. The `helm upgrade --install` command will install
    a release if it does not exist already, or will upgrade a release if a release
    by that name is found. Underneath the hood, it works by querying Kubernetes for
    a release with the given name. If that release does not exist, it switches out
    of the upgrade logic and into the install logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can run an install and an upgrade in sequence using exactly
    the same command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the first line of output, the first run of the command caused
    an install, while the second caused an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: This command does introduce some danger, though. Helm has no way of establishing
    whether the name of the installation you provide to `helm upgrade --install` belongs
    to the release you intend to upgrade or just *happens* to be the named the same
    thing as the thing you want to install. Careless use of this command could result
    in overwriting one installation with another. This is why it is not the default
    behavior for Helm.
  prefs: []
  type: TYPE_NORMAL
- en: The --wait and --atomic Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another pair of significant flags for `helm install` and `helm upgrade` modify
    the success criteria for Helm operations. These are the `--wait` and `--atomic`
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: The `--wait` flag modifies the behavior of the Helm client in a couple of ways.
    First, when Helm runs an installation, it remains active for a set window of time
    (modifiable with the `--timeout` flag) during which it watches Kubernetes. It
    polls the Kubernetes API server for information about all pod-running objects
    that were created by the chart. For example, `DaemonSet`s, `Deployment`s, and
    `StatefulSet`s all create pods. So Helm with `--wait` will track such objects,
    waiting until the pods they create are marked as `Running` by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In a normal install or upgrade, Helm marks a release as successful as soon as
    the Kubernetes API server accepts the manifests. This is similar to package managers
    that consider a package successfully installed as soon as the package contents
    are written to the correct storage locations.
  prefs: []
  type: TYPE_NORMAL
- en: But with `--wait`, the success criteria for an installation is modified. A chart
    is not considered successfully installed unless (1) the Kubernetes API server
    accepts the manifest and (2) all of the pods created by the chart reach the `Running`
    state before Helm’s timeout expires.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, installs with `--wait` can fail for a wide variety of reasons, including
    network latency, a slow scheduler, busy nodes, slow image pulls, and outright
    failure of a container to start.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is seen as a desirable outcome, and operators use `helm install
    --wait` to ensure that not only did the chart successfully install but that the
    resulting application correctly started. However, it does introduce some complicating
    factors when troubleshooting. Transient outages may result in Helm failures that
    are resolved by Kubernetes later. For example, a delayed image pull might result
    in a Helm release marked as failed, even though a few minutes later the image
    pull can complete and the application can be started.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, though, `helm install --wait` is a good tool for making sure
    that the release is brought all the way to running. But when used in automated
    systems (like CI), it may cause spurious failures. One recommendation for using
    `--wait` in CI is to use a long `--timeout` (five or ten minutes) to ensure that
    Kubernetes has time to resolve any transient failures.
  prefs: []
  type: TYPE_NORMAL
- en: A second strategy is to use the `--atomic` flag instead of the `--wait` flag.
    This flag causes the same behavior as `--wait` unless the release fails. Then,
    instead of marking the release as `failed` and exiting, it performs an automatic
    rollback to the last successful release. In automated systems, the `--atomic`
    flag is more resistent to outages, since it is less likely to have a failure as
    its end result. (Keep in mind, though, that there is no assurance that a rollback
    will be successful.)
  prefs: []
  type: TYPE_NORMAL
- en: Just as `--wait` can mark a release as a failure for transitive reasons that
    may be resolved by Kubernetes itself, `--atomic` may trigger an unnecessary rollback
    for the same reasons. Thus, it is recommended to use longer `--timeout` durations
    for `--atomic`, especially when used with CI systems.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading with --force and --cleanup-on-fail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last two flags we will look at modify the way that Helm handles the nuances
    of upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: The `--force` flag modifies the behavior of Helm when it upgrades a resource
    that manages pods (like `Pod`, `Deployment`, and `StatefulSet`). Normally, when
    Kubernetes receives a request to modify such objects, it determines whether it
    needs to restart the pods that this resource manages. For example, a `Deployment`
    may run five replicas of a pod. But if Kubernetes receives an update to the `Deployment`
    object, it will only restart those pods if certain fields are modified.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, though, Helm users want to make sure that the pods are restarted.
    That’s where the `--force` flag comes in. Instead of modifying the `Deployment`
    (or similar object), it will delete and re-create it. This forces Kubernetes to
    delete the old pods and create new ones. By design, using `--force` will cause
    downtime. While it is often only seconds of downtime, it is downtime nonetheless.
    It is recommended to only use `--force` when the situation clearly calls for it,
    not as a default option. For example, the core maintainers do not recommend using
    `--force` in CI pipelines that deploy to production.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to modify the behavior of an upgrade is to use the `--cleanup-on-fail`
    flag. Similarly to `--force`, this flag instructs Helm to do additional work.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the case where you install a chart that creates one Kubernetes `Secret`.
    A new version of the chart is created, and it creates a second `Secret`. But partway
    through the installation, Helm encounters an error and marks the release a failure.
    It is possible for the second `Secret` to be left hanging. This situation is more
    likely to arise if `--wait` or `--atomic` are used, since those may fail after
    Kubernetes has accepted the manifests and created the resources.
  prefs: []
  type: TYPE_NORMAL
- en: The `--cleanup-on-fail` flag will attempt to fix this situation. On failure,
    it will request deletion on every object that was *newly created* during the upgrade.
    Using it may make it a little harder to debug (especially if the failure was a
    result of the newly created object), but it is useful if you do not want to risk
    having unused objects hanging around after a failure.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Helm command-line tool provides many useful commands. While the basic commands
    were introduced in the previous chapter, this chapter has focused on some of the
    other useful commands in Helm. Near the end, we also revisited the installation
    and upgrade commands, getting a taste of some of the more sophisticated features
    for working with those.
  prefs: []
  type: TYPE_NORMAL
- en: However, not all of the commands were discussed here. In coming chapters, we’ll
    take a look at commands for creating and packaging charts, commands for signing
    and verifying packages, and more commands for working with repositories.
  prefs: []
  type: TYPE_NORMAL
