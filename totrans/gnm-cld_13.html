<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Interactive Analysis in Jupyter Notebook"><div class="chapter" id="interactive_analysis_in_jupyter_noteboo">
<h1><span class="label">Chapter 12. </span>Interactive Analysis in Jupyter Notebook</h1>

<p>With this chapter, we round out <a contenteditable="false" data-primary="Jupyter Notebook" data-type="indexterm" id="ix_JupN"/>the experience of working in the cloud. We started out in <a data-type="xref" href="ch04.xhtml#first_steps_in_the_cloud">Chapter 4</a> running individual commands in a shell, and built up proficiency with GATK tools in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a> through <a data-type="xref" href="ch07.xhtml#gatk_best_practices_for_somatic_variant">Chapter 7</a>. Then, in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>, you learned about scripted workflows and discovered progressively better ways to run them in subsequent chapters.</p>

<p>Yet we’re now coming back to the inescapable fact that not everything in genomics can (or should) be done as a scripted workflow.<a contenteditable="false" data-primary="interactive analysis in Jupyter Notebook" data-see="Jupyter Notebook" data-type="indexterm" id="idm45625614211752"/> Sometimes, you just want to interact directly with the data, maybe generate a couple of plots and determine what your next step should be based on what the plots look like. You might be in an early exploratory phase of your project, stuck midway through with some failed samples to troubleshoot, or moving on to digging into the genetics of a group of people. In any case, you need to be able to try out ideas quickly, keep track of what each attempt produces, and share your work with others.</p>

<p>In this chapter, we show you how to use Jupyter Notebook in Terra to achieve these objectives. We kick it off with a brief introduction to Jupyter, in case you’re not already familiar with the concept and tooling. We spend a bit more time on describing how Jupyter works in Terra, focusing on the capabilities and behaviors that are more specific to Terra and the cloud environment. Then, in the hands-on portion of this chapter, we guide you through an example notebook that demonstrates three types of interactive analyses, with direct connections to topics and exercises covered in earlier chapters.</p>

<section class="pagebreak-before less_space" data-type="sect1" data-pdf-bookmark="Introduction to Jupyter in Terra"><div class="sect1" id="introduction_to_jupyter_notebooks_in_te">
<h1>Introduction to Jupyter in Terra</h1>

<p>If you’re reading this book in its intended order, we introduced you to Terra in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>, primarily so that you could experience working with its built-in Cromwell server to run workflows efficiently at scale.<a contenteditable="false" data-primary="Terra platform" data-secondary="Jupyter Notebooks in" data-type="indexterm" id="idm45625614205144"/> You learned to clone a workspace, read a workflow configuration, and launch the workflow on part or all of a preset dataset. However, Terra is not only built for running workflows, but also includes tooling for performing interactive analysis, including a Jupyter service. In this chapter, we’re going to show you how to use Jupyter in Terra to interact with data and perform analysis in real time. You’ll still work within the same workspace, but this time you’ll be going to the Notebooks tab instead of the Workflows tab.</p>

<p>In the first part of this introduction, we aim to provide enough context and fundamentals so that if you’ve never heard of Jupyter before, you’ll be able to complete the exercises that follow. If you’re already familiar with Jupyter, feel free to skip this part. In the second part, we talk specifically about how Jupyter works in Terra, focusing mostly on what is different compared to typical local installations. We strongly recommend that you read it even if you’re familiar with Jupyter, in general because it will help you to better understand key points of the exercises.</p>

<section data-type="sect2" data-pdf-bookmark="Jupyter Notebooks in General"><div class="sect2" id="jupyter_notebooks_in_general">
<h2>Jupyter Notebooks in General</h2>

<p>In a nutshell, <em>Jupyter</em><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="introduction to" data-type="indexterm" id="ix_JupNintro"/> is an application that creates a special kind of document that combines static content (like text and images) with executable code and even interactive elements. For example, the tutorial notebook that you’ll work with in this chapter has sections of plain text that explain briefly what’s going on as well as <em>code cells</em> that include fully functional tool commands (which you can execute to actually run GATK on real data). It includes an integrated IGV module that allows you to view the results of the commands.<a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="module in Jupyter Notebook" data-type="indexterm" id="idm45625614196664"/> To run the contents of a code cell, you simply click the cell<a contenteditable="false" data-primary="code cells, running in Jupyter Notebook" data-type="indexterm" id="idm45625614195128"/> and then press Shift+Enter on your keyboard, or, on the menu bar, click the Run icon. <a contenteditable="false" data-primary="I/O (input/output)" data-secondary="output from command run in Jupyter Notebook" data-type="indexterm" id="idm45625614193800"/>As the command runs, the <a contenteditable="false" data-primary="doc text, code cell, and execution output in Jupyter Notebook" data-type="indexterm" id="idm45625614192328"/>output log of the command appears directly below the code cell, as shown in <a data-type="xref" href="#a_screenshot_of_doc_textcomma_code_cell">Figure 12-1</a>. When you send to collaborators a copy of a notebook with code cells that have been run, they can view your results embedded within the <span class="keep-together">document</span>.</p>

<figure class="width-75 no-frame"><div id="a_screenshot_of_doc_textcomma_code_cell" class="figure"><img alt="A screenshot of doc text, code cell, and execution output in a Jupyter Notebook." src="Images/gitc_1201.png" width="872" height="440"/>
<h6><span class="label">Figure 12-1. </span>Doc text, code cell, and execution output in a Jupyter notebook.</h6>
</div></figure>

<p>The basic<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="introduction to" data-tertiary="advantages of Jupyter Notebook" data-type="indexterm" id="idm45625614186440"/> idea is to combine analysis methods and findings in a single place, in a form that anyone can easily distribute. In a way, this is a logical evolution of the traditional scientific paper, but much better because it dramatically shortens the path between reading how an analysis was done and actually being able to reproduce it. It’s difficult to overstate how powerful this concept is and what a dramatic impact it can have on the reusability and reproducibility of findings in the computational sciences.</p>

<p>So what kind of code can you run in such an interactive notebook? The original concept had been developed under the name <a href="https://ipython.org">IPython</a> to run Python code specifically. <a contenteditable="false" data-primary="Python" data-secondary="Jupyter Notebook and" data-type="indexterm" id="idm45625614182664"/><a contenteditable="false" data-primary="IPython" data-type="indexterm" id="idm45625614181288"/>The Jupyter project came out of IPython with the goal of extending the concept to other languages, starting with Julia, Python, and R, which are reflected in the name Jupyter (hence, the <em>py</em> spelling of Jupyter, as opposed to Jupiter, the Roman god of thunder).<a contenteditable="false" data-primary="kernels (Jupyter Notebook)" data-type="indexterm" id="idm45625614179432"/> There are now Jupyter <em>kernels</em> for <a href="https://oreil.ly/Pf8Or">other popular languages</a>, such as <a contenteditable="false" data-primary="Ruby, Jupyter kernels for" data-type="indexterm" id="idm45625614176936"/>Ruby, for example. In this chapter’s exercises, we work with a Python kernel that supports <a contenteditable="false" data-primary="R language" data-secondary="support by Python kernel for Jupyter" data-type="indexterm" id="idm45625614175544"/>including R code, as well as running pretty much anything you could run in a shell environment, thanks to a neat set of features called <em>Python magic methods</em>. In our opinion, it’s like having the best of both worlds, but for many worlds.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In general computing, the <em>kernel</em> is the program at the core of an operating system. In the Jupyter context, the kernel is the program that interprets code cells, passes those instructions to the actual operating system of the machine that the notebook is running on, and retrieves results to display them in the notebook.</p>
</div>

<p>Jupyter notebooks are backed by a server application that has fairly simple requirements and can be run on almost any kind of computing infrastructure, including your laptop.<a contenteditable="false" data-primary="server application for Jupyter Notebook" data-type="indexterm" id="idm45625614170920"/> In addition, a Jupyter notebook enables researchers to encapsulate the information necessary to re-create the software environment used by the analysis that it describes, making it a great vector for distributing reproducible code.<a contenteditable="false" data-primary="reproducible code from Jupyter Notebook" data-type="indexterm" id="idm45625614169416"/> It’s also an increasingly popular teaching tool, for reasons that will hopefully become evident as you work through the exercises in this chapter.</p>

<p>The growing popularity of Jupyter has spawned a rich ecosystem of add-on tools and services.<a contenteditable="false" data-primary="add-on tools and services for Jupyter Notebook" data-type="indexterm" id="idm45625614167256"/> For example,<a contenteditable="false" data-primary="Google Cloud Platform (GCP)" data-secondary="Colaboratory service for Jupyter Notebook" data-type="indexterm" id="idm45625614165928"/> GCP operates a service called <a href="https://oreil.ly/3Tr2r">Colaboratory</a> that offers<a contenteditable="false" data-primary="Colaboratory service for Jupyter Notebook (GCP)" data-type="indexterm" id="idm45625614163704"/> free access to cloud-based notebooks, with tutorial materials that are heavily geared toward machine learning applications. The Google Cloud AI Platform, meanwhile, <a contenteditable="false" data-primary="Google Cloud AI Platform, service for Jupyter Notebook" data-type="indexterm" id="idm45625614162232"/>offers a paid service that offers preconfigured VMs for running notebooks integrated with other Google Cloud services.<a contenteditable="false" data-primary="virtual machines (VMs)" data-secondary="preconfigured, for running Jupyter Notebook" data-type="indexterm" id="idm45625614160840"/> Another example is <a href="https://mybinder.org">Binder</a>, an open source community-driven project that can take any Jupyter notebook in a GitHub repository and open it in an interactive environment.<a contenteditable="false" data-primary="Binder project" data-type="indexterm" id="idm45625614158600"/> These free services usually have limitations on the amount of computing power associated with the environments they provide, but they can be extremely convenient nonetheless for sharing working code, tutorials, and so on.</p>

<p>That being said, it’s practically impossible for a single tool to satisfy the full spectrum of needs and preferences of people in computational sciences, and we recognize that Jupyter notebooks do have some shortcomings that limit their appeal to certain audiences.<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="introduction to" data-tertiary="limitations of Jupyter Notebook" data-type="indexterm" id="idm45625614156424"/> For example, people with advanced programming experience typically criticize the lack of development features that are standard on most modern programming tools, like <a contenteditable="false" data-primary="RStudio" data-type="indexterm" id="idm45625614154440"/>syntax highlighting and code introspection. In addition, data scientists who are used to exploratory analysis interfaces like <a href="https://oreil.ly/1M5Jh">RStudio</a> tend to find the primary Jupyter interface too basic and lacking in assistive features.<a contenteditable="false" data-primary="JupyterLab project" data-type="indexterm" id="idm45625614152232"/> The <a href="https://oreil.ly/RCfhB">JupyterLab</a> project aims to remedy that limitation by providing a richer interface that is closer in concept to RStudio. Given the surge in economic investment in data sciences that we’ve seen in recent years, we expect that the tooling options will only improve over time, and we look forward to seeing what the next generation of interfaces will look like.</p>

<p>In the meantime, we choose to use Jupyter for its accessibility to newcomers and its as-yet unparalleled support of<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="introduction to" data-startref="ix_JupNintro" data-type="indexterm" id="idm45625614149528"/> portability and reproducibility.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="How Jupyter Notebooks Work in Terra"><div class="sect2" id="how_jupyter_notebooks_work_in_terra">
<h2>How Jupyter Notebooks Work in Terra</h2>

<p>Before we get into<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-type="indexterm" id="ix_JupNTer"/> the details, you should know <a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-type="indexterm" id="ix_TerraJN"/>that Terra uses a standard Jupyter server implementation, so the interface and <a contenteditable="false" data-primary="server implementation for Jupyter in Terra" data-type="indexterm" id="idm45625614142280"/>core capabilities that you will be working with are all basically the same as those you would see in any other setting. As a result, you can take advantage of the wealth of documentation and tutorials available on the internet for learning how to use the various menu options, widgets, and so on that we’re not going to cover in detail here.</p>

<p>The one thing that is truly different about how Jupyter notebooks work in Terra compared to typical local installations is the way the computing environment is set up. Let’s go over that now given that it will have important consequences for you on <span class="keep-together">several</span> fronts; for example, the amount of flexibility you have to customize the environment, and the way you will access data and then save your analysis results.</p>

<section data-type="sect3" data-pdf-bookmark="Overview"><div class="sect3" id="overview">
<h3>Overview</h3>

<p>In Terra, notebook <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-tertiary="overview" data-type="indexterm" id="ix_JupNTerovr"/>documents live <a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-tertiary="overview" data-type="indexterm" id="ix_TerraJNovr"/>in your workspace’s storage bucket. When you open a notebook for the <a contenteditable="false" data-primary="virtual machines (VMs)" data-secondary="for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614132696"/>first time, Terra requests a VM in GCP, spins up a container<a contenteditable="false" data-primary="containers" data-secondary="for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614131096"/> with a Jupyter server on it, and loads your notebook within that container environment, as illustrated in <a data-type="xref" href="#an_overview_of_the_jupyter_notebooks_se">Figure 12-2</a>.</p>

<figure><div id="an_overview_of_the_jupyter_notebooks_se" class="figure"><img alt="An overview of the Jupyter service in Terra." src="Images/gitc_1202.png" width="1338" height="590"/>
<h6><span class="label">Figure 12-2. </span>An overview of the Jupyter service in Terra.</h6>
</div></figure>

<p>From that point on, any code that you run in the notebook will be executed in the container on that VM. You can even run commands that install software packages or load libraries on the VM to customize the environment on the fly. Conceptually, it’s similar to working with the VM you set up through the GCP console in <a data-type="xref" href="ch04.xhtml#first_steps_in_the_cloud">Chapter 4</a> and subsequently used in every chapter up through <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>, except it is originally created by Terra, and it provides you with the Jupyter interface instead of the bare shell terminal.</p>

<p>It is possible to pull up a terminal interface to the notebook, which allows you to perform actions like listing files and installing packages without having to put these actions into code cells. However, we recommend using this capability sparingly, largely because it runs counter to the underlying purpose of Jupyter, which is to capture every meaningful action taken during an analysis. Listing directory contents might not be meaningful in that context, but installing a package or importing data, on the other hand, can play an essential role. Omitting such actions from the notebook record could create missing links that break the reproducibility of the work.</p>

<p>The cost model is the same, as well; GCP will charge you for the amount of time that the VM is in a<a contenteditable="false" data-primary="costs" data-secondary="GCP charges for running Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614122072"/> running state, even if it’s not actively doing anything. The good news is that Terra has an automatic feature to detect inactivity; more on that in a minute.<a contenteditable="false" data-primary="virtual machines (VMs)" data-secondary="for Jupyter Notebook in Terra" data-tertiary="costs of" data-type="indexterm" id="idm45625614120296"/> The base rate depends on the VM configuration you choose to use; by default, Terra provides a basic configuration that accommodates common performance needs, but you can dial it up or down based on your specific needs. We get back to that shortly.</p>

<p>The overall computing environment constituted by the VM plus the container and all the software <a contenteditable="false" data-primary="notebook runtime" data-type="indexterm" id="idm45625614117656"/>it contains is called the <em>notebook runtime</em>. It is strictly personal to you; no one else can access it even if you share your workspace with them. We talk about sharing and collaboration in the last section of this introduction, when you’ll have a better sense of<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-startref="ix_JupNTerovr" data-tertiary="overview" data-type="indexterm" id="idm45625614115768"/> how it all works.<a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-startref="ix_TerraJNovr" data-tertiary="overview" data-type="indexterm" id="idm45625614113720"/></p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Accessing data"><div class="sect3" id="accessing_data">
<h3>Accessing data</h3>

<p>Your notebook runtime comes <a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-tertiary="accessing data" data-type="indexterm" id="idm45625614109576"/>equipped with local storage space.<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-tertiary="accessing data" data-type="indexterm" id="idm45625614107832"/> Cloud subtleties<a contenteditable="false" data-primary="notebook runtime" data-secondary="local storage space in" data-type="indexterm" id="idm45625614106056"/> notwithstanding, it’s basically like a hard drive with a filesystem on it. You can interact <a contenteditable="false" data-primary="filesystem, interacting with, Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614104408"/>with the filesystem through code cells in the notebook, via the Jupyter built-in graphical file explorer, or through the aforementioned terminal interface, which supports classic commands like <code>ls</code> and <code>cd</code>. This allows you to run commands in the notebook using regular file paths as you would on a regular local system, such as your laptop. In addition, there are a few ways to run commands on data without first copying it to the local filesystem. We’re not going to go through the laundry list of options for accessing data from a notebook, because that would be boring. Instead, here’s a list of those we use most commonly:</p>

<ul>
	<li>
	<p>Upload files from your desktop to your notebook’s local storage through the notebook’s graphical file explorer.</p>
	</li>
	<li>
	<p>Copy data from a GCS bucket to your notebook’s local storage using <code>gsutil cp</code>.</p>
	</li>
	<li>
	<p>Run tools that support streaming (like GATK4) directly on files in GCS.</p>
	</li>
	<li>
	<p>Import tabular data from tables on the DATA tab of the workspace by using a programmatic interface (API).<a contenteditable="false" data-primary="tabular data, importing into Jupyter Notebook on Terra" data-type="indexterm" id="idm45625614096952"/></p>
	</li>
	<li>
	<p>Import tabular data from Google’s BigQuery datastore service.</p>
	</li>
</ul>

<p>We show you how to use the second and third options in practice in the next section, and we will provide pointers to additional resources for learning the fourth and fifth on the book’s companion blog.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Saving, stopping, and restarting"><div class="sect3" id="savingcomma_stoppingcomma_and_restartin">
<h3>Saving, stopping, and restarting</h3>

<p>While you work in the notebook, the system will regularly save changes back to the original notebook document in your workspace bucket.<a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-tertiary="saving, stopping, and restarting" data-type="indexterm" id="idm45625614092328"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-tertiary="saving, stopping, and restarting" data-type="indexterm" id="idm45625614090600"/> However, aside from the notebook itself, Terra does not automatically save any files from the notebook’s local storage back to the workspace. For reasons that we discuss shortly, you can’t depend on the notebook runtime for permanent storage, so you must take action to save a copy of any output files you care about, preferably to the workspace storage bucket.<a contenteditable="false" data-primary="saving data in Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614088424"/> We show you an easy way to do this in <a data-type="xref" href="#setting_up_a_sandbox_and_practice_savin">“Setting Up a Sandbox and Saving Output Files to the <span class="keep-together">Workspace Bucket</span>”</a>.</p>

<p>When you’re done <a contenteditable="false" data-primary="stopping Jupyter Notebooks running in Terra" data-type="indexterm" id="idm45625614085752"/>working and close the notebook, Terra instructs GCP to stop the notebook runtime but save its state, which includes<a contenteditable="false" data-primary="notebook runtime" data-secondary="stopping and saving its state" data-type="indexterm" id="idm45625614084264"/> the state of the Jupyter container, with any modifications that you might have made by installing packages, for example, and any files present on its local storage partition. That way, you can <a contenteditable="false" data-primary="restarting Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614082488"/>resume working at any time with minimal effort: when you reopen the notebook, Terra restarts the VM and restores the notebook runtime to its saved state. The restart process can take up to two minutes on the GCP side, but while you wait, Terra gives you a read-only view of the notebook contents based on the document’s latest saved state. Finally, as mentioned in the previous paragraph, Terra is able to detect when you are no longer actively working in your notebook (based on how long the VM has been idle) and will automatically save the notebook and stop the VM to limit your costs.<a contenteditable="false" data-primary="virtual machines (VMs)" data-secondary="for Jupyter Notebook in Terra" data-tertiary="automatic stopping of idle VMs" data-type="indexterm" id="idm45625614080632"/></p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Customizing your notebook’s computing environment"><div class="sect3" id="customizing_your_notebookapostrophes_co">
<h3>Customizing your notebook’s computing environment</h3>

<p>You <a contenteditable="false" data-primary="notebook runtime" data-secondary="customizing" data-type="indexterm" id="idm45625614076792"/>might want to customize your notebook runtime in two main ways: modify the VM resource allocations (how many CPUs, how much memory, etc.) and/or modify which software is preinstalled in the container.<a contenteditable="false" data-primary="computing environment, customizing for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614075032"/><a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-tertiary="customizing notebook's computing environment" data-type="indexterm" id="idm45625614073880"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-tertiary="customizing notebook's computing environment" data-type="indexterm" id="idm45625614072120"/></p>

<p>As noted earlier in passing, you can readily modify the VM resources allocated to your notebook runtime; for example, if you need more CPUs or memory than is included in the default configuration, you can adjust the notebook runtime configuration accordingly.<a contenteditable="false" data-primary="virtual machines (VMs)" data-secondary="for Jupyter Notebook in Terra" data-tertiary="customizing" data-type="indexterm" id="idm45625614069752"/> You can even request a Spark cluster instead of a single VM if you’re planning to use tools that are Spark enabled. <a contenteditable="false" data-primary="Spark framework" data-secondary="requesting Spark cluster for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614067832"/>Conveniently, Terra includes a notebook runtime configuration panel that is much simpler than the equivalent GCP interface, which you might remember from <a data-type="xref" href="ch04.xhtml#first_steps_in_the_cloud">Chapter 4</a>. But what’s really cool is that you can do it at any time, even if you’ve already started working in the notebook. You’ll just pull up the configuration panel, specify what you want, and let the system regenerate your notebook runtime with the new specifications. As a result, you don’t need to try too hard to guess up front the kind of resources you’re going to need to do your work. You can start working with minimal settings and then dial them up if you run into limitations.</p>

<p>However—and this is a big caveat—the new runtime <em>will be a blank slate</em> because the regeneration process <a contenteditable="false" data-primary="notebook runtime" data-secondary="becoming blank slate after customization and regeneration" data-type="indexterm" id="idm45625614063784"/>provisions a new VM with a fresh install of the original container image and an empty storage partition. If the work you’re doing in your notebook includes mostly short-running commands that don’t amount to much computation cost, this isn’t a big problem: the Jupyter menu includes an option to rerun all code cells (or all up to a certain point) so that you can simply regenerate the previous state. However, if some of your work involves massive computations that would not be trivial to rerun, you might need a better strategy. For example, you could explicitly save the outputs generated so far to the workspace bucket and then set your notebook to take those saved outputs as inputs for the next section of the work.</p>

<p>The second customization point, modifying the software in the container when the notebook runtime is being generated, is a little more complicated but worth taking a few minutes to discuss.<a contenteditable="false" data-primary="containers" data-secondary="for Jupyter Notebook in Terra" data-tertiary="modifying software in container while notebook runtime is generated" data-type="indexterm" id="idm45625614060872"/> First, why would you want to do that? Suppose that your analysis is going to require software packages that are not part of the default notebook runtime configuration. You could start the notebook with some installation steps, but that can turn into a maintenance headache if you have multiple notebooks that require the same configuration commands. It would be much easier to move some of those software installation steps out of the notebooks and into the environment configuration proper. You can do exactly that in Terra in two ways: you can specify a setup script that Terra will run in the container when it is creating or regenerating the notebook runtime, or you can supply a custom container image to the runtime service. Or you can, in fact, combine both: specify a custom container and a startup script to modify its setup. <a data-type="xref" href="#options_for_customizing_the_software_in">Figure 12-3</a> illustrates the difference between these options.</p>

<figure><div id="options_for_customizing_the_software_in" class="figure"><img alt="Options for customizing the software installed in the notebook runtime." src="Images/gitc_1203.png" width="1440" height="545"/>
<h6><span class="label">Figure 12-3. </span>Options for customizing the software installed in the notebook runtime.</h6>
</div></figure>

<p>In the upcoming exercises, we show you how to use the <a contenteditable="false" data-primary="startup script, using to customize software in notebook runtime" data-type="indexterm" id="idm45625614054616"/>startup script option because it’s a good compromise of power and ease of use: it’s not difficult to make your own, and you can readily distribute the script for others who are also using the same kernel in Terra. The custom container image option is technically more powerful and more portable, but it’s a bit more complicated. If you’re interested in learning how that works, check out the <a href="https://oreil.ly/R-Grd">Terra documentation on custom containers</a>.</p>

<p>Now that you know how much power you have to customize your notebook runtime, we need to address a crucial question that we’ve been careful to avoid bringing up until now: how many notebook runtimes do you get to work with? Do you use the same runtime for everything, one per workspace, one per notebook, or can you create new runtimes willy-nilly like you can spin up VMs in the GCP console? To be frank, the answer is likely to evolve over time as the platform matures further and the product development team collects more data regarding what researchers actually want (so feel free to give them your opinion!).</p>

<p>As of this writing, the Terra Notebooks service provides you with a single notebook runtime for all workspaces within a particular billing project. To be clear, this means that if you open or create another notebook in any workspace attached to the same billing project as your first notebook, the new notebook will open in the same runtime environment. This can be very convenient if you have a lot of overlap between the data, resources, and software that you plan to use in both notebooks. However, it can be a source of major complications if you are working on different projects with very different configuration needs. In that case, you might want to consider developing notebooks with incompatible requirements under different billing projects, because that will give you a completely separate notebook runtime for each one.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Sharing and collaboration"><div class="sect3" id="sharing_and_collaboration">
<h3>Sharing and collaboration</h3>

<p>With that, you’ve reached the last section of this introduction, and now it’s time to talk about how to play nice with others.<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-tertiary="sharing and collaboration" data-type="indexterm" id="idm45625614047992"/><a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-tertiary="sharing and collaboration" data-type="indexterm" id="idm45625614046280"/><a contenteditable="false" data-primary="sharing and collaboration, Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614044600"/><a contenteditable="false" data-primary="collaboration and sharing, Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614043400"/> As we noted earlier, the notebook runtime is personal to you: only you have access to that machine, container, and Jupyter server. If you share your workspace with a collaborator who then opens up the same notebook, it will open in their own runtime environment. As a result, any work they do in the notebook will not affect the state of your runtime environment. However, the system will automatically save any changes they make to the shared document in the workspace, so it’s important to set expectations clearly with your collaborators about whether it’s OK for them to modify the notebook or whether they should work in a separate copy.</p>

<p>In addition, be aware that Terra will <em>lock</em> the notebook document in the workspace whenever someone is actively working with it, to avoid having multiple people making conflicting changes at the same time. When this happens, your collaborator can open the notebook in the read-only preview mode, or they can open it in a special <em>playground mode</em> that allows them to make changes and run code in their own runtime environment but does not save any changes to the original file, as illustrated in <a data-type="xref" href="#options_for_sharing_and_collaboration_a">Figure 12-4</a>. This falls a bit short of the ideal collaborative experience that you could envision based on Google Docs, for example, but it provides a reasonable compromise given the constraints at play.</p>

<figure><div id="options_for_sharing_and_collaboration_a" class="figure"><img alt="Options for sharing and collaboration around notebooks in Terra." src="Images/gitc_1204.png" width="1238" height="426"/>
<h6><span class="label">Figure 12-4. </span>Notebooks in shared workspaces are protected from overwriting when two people open them concurrently.</h6>
</div></figure>

<p>If you’re having a difficult time envisioning how this all works in practice, don’t worry! First, that’s totally OK; if anything is unclear, it’s our fault, not yours. Second, good news: you’ve reached the end of the wall of theory, and now it’s time to work through practical <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="how they work in Terra" data-startref="ix_JupNTer" data-type="indexterm" id="idm45625614035848"/>exercises in a real-life notebook.<a contenteditable="false" data-primary="Terra platform" data-secondary="how Jupyter Notebooks work in" data-startref="ix_TerraJN" data-type="indexterm" id="idm45625614034072"/></p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Getting Started with Jupyter in Terra"><div class="sect1" id="getting_started_with_jupyter_notebooks">
<h1>Getting Started with Jupyter in Terra</h1>

<p>We’re going to work with a prewritten notebook, so<a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-type="indexterm" id="ix_TerraJNstrt"/> you’ll mostly<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-type="indexterm" id="ix_JupNstrt"/> just need to run cells, though whenever possible we tried to include hints for additional things that you can try in order to reinforce the learning.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625614026472"/> In <a data-type="xref" href="ch13.xhtml#assembling_your_own_workspace_in_terra">Chapter 13</a>, we talk about creating your own notebooks from scratch or importing existing notebooks from external sources.</p>

<p>To get started, go back to the workspace that you created by cloning the original book workspace in <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>. If you don’t have the URL on hand, you should be able to find it in <a href="https://oreil.ly/bKWll">Your Workspaces</a>; or if you deleted it, you can clone the original again by following the relevant instructions at the beginning of <a data-type="xref" href="ch11.xhtml#running_many_workflows_conveniently_in">Chapter 11</a>. After you’ve found your workspace, open it and go to the Notebooks tab. There, you’ll see two notebooks listed, as shown in <a data-type="xref" href="#the_notebooks_tab_showing_two_copies_of">Figure 12-5</a>. Those are actually two copies of the same notebook: one that has never been run, and the other where we ran everything so that you can see the expected output.</p>

<figure class="no-frame"><div id="the_notebooks_tab_showing_two_copies_of" class="figure"><img alt="The NOTEBOOKS tab showing two copies of the notebook: one already executed and another without any previous results." src="Images/gitc_1205.png" width="1440" height="360"/>
<h6><span class="label">Figure 12-5. </span>The Notebooks tab showing two copies of the notebook: one already executed and another without any previous results.</h6>
</div></figure>

<p>We recommend that you open the second only in preview mode to preserve its contents as a reference in case you encounter anything surprising in the other one, which you will use to run through the upcoming exercise.</p>

<p>However, before you open anything, we’re going to walk you through customizing your runtime configuration. If you already started opening one of the notebooks, don’t panic; you’ll still be able to reconfigure the notebook runtime. We just want to save you a little bit of time given that it takes a few minutes to get a new runtime up and running, and we know that we’re going to want more than what the default configuration has to offer.</p>

<section data-type="sect2" data-pdf-bookmark="Inspecting and Customizing the Notebook Runtime Configuration"><div class="sect2" id="inspecting_and_customizing_the_notebook">
<h2>Inspecting and Customizing the Notebook Runtime Configuration</h2>

<p>As noted earlier, the <a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-tertiary="inspecting and customizing notebook runtime configuration" data-type="indexterm" id="ix_TerraJNstrtNR"/>runtime environment<a contenteditable="false" data-primary="notebook runtime" data-secondary="inspecting and customizing configuration in Terra" data-type="indexterm" id="ix_ntrncst"/> that Terra creates <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-tertiary="inspecting and customizing notebook runtime configuration" data-type="indexterm" id="ix_JupNstrtNR"/>for you by default is set up with basic resource allocations and a set of standard software packages. You can view this configuration at any time without having to open a notebook, as long as you’re in a workspace under the appropriate billing project.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="Notebook Runtime status widget" data-type="indexterm" id="idm45625614006552"/> To do so, look for the Notebook Runtime status widget, which, as of this writing, is displayed in the upper-right corner of almost all workspace pages, as demonstrated in <a data-type="xref" href="#the_notebook_runtime_status_widgetdot">Figure 12-6</a>.</p>

<figure class="width-50 no-frame"><div id="the_notebook_runtime_status_widgetdot" class="figure"><img alt="The Notebook Runtime status widget." src="Images/gitc_1206.png" width="1132" height="236"/>
<h6><span class="label">Figure 12-6. </span>The Notebook Runtime status widget.</h6>
</div></figure>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>We have heard rumblings from the Terra product development team that the display of the Notebook Runtime status widget might change in the near future, in which case you’ll need to poke around to find it, or if that fails, consult the documentation in the book’s repository on <a href="https://oreil.ly/genomics-repo">GitHub</a>.</p>
</div>

<p>Click the gear icon on the right to bring up the <a contenteditable="false" data-primary="runtime configuration page (Terra)" data-type="indexterm" id="idm45625613999144"/>runtime configuration page.<a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="runtime configuration page" data-type="indexterm" id="idm45625613997896"/> If you haven’t made any customizations to <a contenteditable="false" data-primary="notebook runtime" data-secondary="inspecting and customizing configuration in Terra" data-tertiary="inspecting runtime configuration" data-type="indexterm" id="idm45625613996264"/>the runtime under your current billing project, the form should display all default settings, as depicted in <a data-type="xref" href="#the_default_notebook_runtime_configurat">Figure 12-7</a>.</p>

<figure class="width-75 no-frame"><div id="the_default_notebook_runtime_configurat" class="figure"><img alt="The default Notebook Runtime configuration settings." src="Images/gitc_1207.png" width="1314" height="1110"/>
<h6><span class="label">Figure 12-7. </span>The default Notebook Runtime configuration settings.</h6>
</div></figure>

<p>You can see a small list of default environments <a contenteditable="false" data-primary="environment, runtime, choosing in Terra" data-type="indexterm" id="idm45625613990360"/>to choose from, identified by the packages that are considered most important. For full details on what is installed on each, select the environment you’re interested in and click “What’s installed on this environment?” to bring up the detailed view. As shown in <a data-type="xref" href="#detailed_view_of_the_packages_installed">Figure 12-8</a>, this detailed view is further broken into categories such as Python, R, and Tools.<a contenteditable="false" data-primary="Python" data-secondary="in runtime environment for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625613987816"/> Selecting either <a contenteditable="false" data-primary="R language" data-secondary="in runtime environment for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625613986248"/>Python or R brings up the full list of packages of the corresponding language that are included in the runtime environment.<a contenteditable="false" data-primary="command-line tools" data-secondary="in runtime environment for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625613984536"/> Selecting Tools will bring up the list of command-line executable tools also included in the runtime environment.</p>

<p>In fact, if you <a contenteditable="false" data-primary="packages installed in default notebook runtime environment" data-type="indexterm" id="idm45625613982584"/>select Tools, you’ll see that this default set actually includes GATK, which is a nice touch for those of us in the genomics field, considering Terra has a much wider audience than just genomics. <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="in runtime environment for Jupyter Notebook in Terra" data-type="indexterm" id="idm45625613981064"/>That being said, for the purposes of this book, we are using a different version than the one included in the default configuration as of this writing, so we need to customize this. In addition, we’re going to want to use a Python library that (spoiler alert) makes it possible to embed an IGV browser window within the notebook (which is so cool). <a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-type="indexterm" id="idm45625613979192"/>We could install both from within the notebook itself, but as noted in the introduction, we prefer to use a startup script that will install them in the Jupyter container during the notebook runtime creation process. We provide a closer look at the script in question in the accompanying sidebar in case you’re curious, but feel free to skip it if it’s not your cup of tea or if you’re eager to get started with the notebook itself.</p>

<figure class="width-75 no-frame"><div id="detailed_view_of_the_packages_installed" class="figure"><img alt="Detailed view of the packages installed on the default runtime environment." src="Images/gitc_1208.png" width="1320" height="730"/>
<h6><span class="label">Figure 12-8. </span>Detailed view of the packages installed on the default runtime environment.</h6>
</div></figure>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="a_closer_look_at_the_startup_script_tha">
<h5>A Closer Look at the Startup Script that Installs GATK and IGV on the Notebook Runtime</h5>

<p>This startup script was <a contenteditable="false" data-primary="notebook runtime" data-secondary="inspecting and customizing configuration in Terra" data-tertiary="startup script installing GATK and IGV on" data-type="indexterm" id="idm45625613972888"/>originally provided by the GATK team for its workshops, which use <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="installing on notebook runtime, startup script for" data-type="indexterm" id="idm45625613970952"/>Terra as a teaching <a contenteditable="false" data-primary="startup script, using to customize software in notebook runtime" data-secondary="startup script installing GATK and IGV" data-type="indexterm" id="idm45625613969272"/>platform. You can find it with a collection of other startup scripts <a href="https://oreil.ly/rUPmm">here</a>, and we’ve also included a copy in the book repository on GitHub. Let’s walk through it briefly to highlight the key parts.</p>

<p>This line declares that it’s a Bash script:</p>

<pre data-type="programlisting">
#!/bin/bash</pre>

<p>The next block of lines is much more interesting because it contains the installation commands for the IGV library. <a contenteditable="false" data-primary="Python" data-secondary="IGV library installed on notebook runtime" data-type="indexterm" id="idm45625613964856"/><a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="installing on notebook runtime, startup script for" data-type="indexterm" id="idm45625613963384"/>First the script installs the <code>igv-jupyter</code> Python<a contenteditable="false" data-primary="pip3 package management tool" data-type="indexterm" id="idm45625613961464"/> package by using the Python package management tool, <code>pip</code> (specifically its Python 3 <span class="keep-together">version</span>, <code>pip3</code>). Then, it enables Jupyter Notebook extensions that are necessary for the IGV browser to be properly interactive in the context of the notebook:</p>

<pre data-type="programlisting">
pip3 install igv-jupyter

jupyter serverextension enable --py igv --sys-prefix
jupyter nbextension install --py igv --sys-prefix
jupyter nbextension enable --py igv --sys-prefix</pre>

<p>This next block contains accessory packages that are useful but not particularly interesting, so we won’t go into the details:</p>

<pre data-type="programlisting">
pip3 install rpy2==3.0.4
pip3 install singledispatch
pip3 install tzlocal

echo
"install.packages(c(\"optparse\",\"data.table\"),repos=\"
http://cran.us.r-project.org\")" | R --no-save</pre>

<p>And, finally, this longer block contains the commands to install the GATK components that we want. First it deletes any preinstalled GATK package, retrieves the zipped archive for the specific release of GATK that we want from GitHub, and then unzips it and sets up a symbolic link to make it callable from the notebook. That takes care of the main GATK package. There’s also a secondary package of Python code, which the script installs with <code>pip</code>:</p>

<pre data-type="programlisting">
set -e

GATK_VERSION=4.1.3.0
GATK_ZIP_PATH=/tmp/gatk-$GATK_VERSION.zip

# remove pre-existing GATK version
rm -rf /bin/gatk

# download the gatk zip if it doesn't already exist

if ! [ -f $GATK_ZIP_PATH ]; then
  # curl and follow redirects and output to a temp file
  curl -L -o $GATK_ZIP_PATH
https://github.com/broadinstitute/gatk/releases/download/$G
ATK_VERSION/gatk-$GATK_VERSION.zip
fi

# unzip with forced overwrite (if necessary) to /bin
unzip -o $GATK_ZIP_PATH -d /etc/

# make a symlink to gatk right inside bin so it’s available from the existing 
# PATH
ln -s /etc/gatk-$GATK_VERSION/gatk /bin/gatk

pip3 install /etc/gatk-$GATK_VERSION/gatkPythonPackageArchive.zip

export PATH=$PATH:/home/jupyter-user/.local/bin</pre>

<p>If you’re familiar with installation scripts written in Bash, you can see that there is nothing specific to Terra about this particular script. <a contenteditable="false" data-primary="Bash shell" data-secondary="installation scripts written in" data-type="indexterm" id="idm45625613952872"/>You could provide it to anyone who wants to set up the same environment as your notebook runtime outside of Terra. That contributes to making the “outsourcing” of custom environment setup instructions to a startup script (as opposed to keeping them within the notebook itself) a really solid option for portability and reproducibility.</p>
</div></aside>

<p>So where should we specify the startup script? You might be tempted to look in the environments menu on the notebook runtime customization page, maybe even select the Custom Environment option, and you would be so close to being right, conceptually—but in practice, you’d be wrong. <a contenteditable="false" data-primary="containers" data-secondary="specifying custom Docker image for notebook runtime" data-type="indexterm" id="idm45625613950440"/>That is where you would go to specify a custom Docker image to substitute for the built-in one. Instead, you need to look a little farther down at the Compute Power section (shown earlier in <a data-type="xref" href="#the_default_notebook_runtime_configurat">Figure 12-7</a>), which allows you to modify the VM resource allocations. This section includes a menu that allows you to choose from three preset configurations, designated as providing Moderate, Increased, or High computer power, or provide your own under the label <span class="keep-together">Custom</span>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>To be frank, we wouldn’t be surprised if this part of the interface also evolved a bit in the near future because it’s not super logical to find a software customization option grouped with hardware allocations. Not to mention the names of the preset configurations, which are about as helpful as Starbucks cup sizes: once you get used to them, they kind of make sense, but the first time you set foot in a Starbucks, you’re just happy that the prices tell you which one is bigger.</p>
</div>

<p>Feel free to select each preset and look at how their respective resource allocations differ. When you’re ready to move on, select the Custom option to bring up an editable configuration window. You should see a new field named “Startup script” appear that wasn’t available earlier (<a data-type="xref" href="#the_compute_power_section_allows_you_to">Figure 12-9</a>). You can finally input the path to the startup script there, in the text box labeled URI (for <a href="https://oreil.ly/Ltao0">uniform resource identifier</a>, a close cousin of <a href="https://oreil.ly/jUtVr">URL</a>, the uniform resource locator). We included a copy of the script in the book bucket, so you can use this path:</p>

<pre data-type="programlisting">
gs://genomics-in-the-cloud/v1/scripts/install_GATK_4130_with_igv.sh</pre>

<p>The rest of the resource allocations will be fine with <a contenteditable="false" data-primary="Compute Power section, Notebook Runtime configuration page" data-type="indexterm" id="idm45625613940440"/>the default (Moderate) values of 4 CPUs, 15 GB of memory (RAM), and 50 GB of disk (storage space). <a data-type="xref" href="#the_compute_power_section_allows_you_to">Figure 12-9</a> demonstrates what this looks like.</p>

<p>As a reminder, this startup script installs GATK version 4.1.3.0 in the runtime environment, as well as an IGV integration module that will make it possible to view genomic data using IGV from within the notebook itself.</p>

<figure class="width-75 no-frame"><div id="the_compute_power_section_allows_you_to" class="figure"><img alt="The COMPUTE POWER section allows you to specify a startup script if you choose the Custom profile." src="Images/gitc_1209.png" width="1282" height="678"/>
<h6><span class="label">Figure 12-9. </span>The Compute Power section allows you to specify a startup script if you choose the Custom profile.</h6>
</div></figure>

<p>Click the Create button when you are done (labeled Replace if you had already created a runtime earlier), and Terra begins to create a new runtime environment with your settings. You can go grab yourself a cup of something nice or continue on to the next set of instructions, as you prefer. You will probably need to wait a few minutes in either case while Terra communicates with GCP to provision your shiny new runtime environment.<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-startref="ix_JupNstrtNR" data-tertiary="inspecting and customizing notebook runtime configuration" data-type="indexterm" id="idm45625613934168"/><a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-startref="ix_TerraJNstrtNR" data-tertiary="inspecting and customizing notebook runtime configuration" data-type="indexterm" id="idm45625613932184"/><a contenteditable="false" data-primary="notebook runtime" data-secondary="inspecting and customizing configuration in Terra" data-startref="ix_ntrncst" data-type="indexterm" id="idm45625613930120"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Opening Notebook in Edit Mode and Checking the Kernel"><div class="sect2" id="opening_notebook_in_edit_mode_and_check">
<h2>Opening Notebook in Edit Mode and Checking the Kernel</h2>

<p>You don’t <a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-tertiary="opening notebook in Edit mode and checking kernel" data-type="indexterm" id="idm45625613926504"/>need to wait for the runtime <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-tertiary="opening notebook in Edit mode and checking kernel" data-type="indexterm" id="idm45625613924600"/>to be ready in order to take a peek at the notebook, so go ahead and open the never-been-run copy of the tutorial notebook. Whether your runtime is ready or not, <a contenteditable="false" data-primary="Edit mode, opening notebook in" data-type="indexterm" id="idm45625613922568"/>Terra will initially open the notebook in preview mode, in which the notebook is read-only. As <a data-type="xref" href="#menu_on_the_notebook_preview_page_displ">Figure 12-10</a> illustrates, a menu at the top of the preview panel offers you the two options for opening the notebook in an interactive mode: Edit, to work with<a contenteditable="false" data-primary="Playground Mode, opening notebook in" data-type="indexterm" id="idm45625613920056"/> the notebook<a contenteditable="false" data-primary="Preview mode, Jupyter Notebook in Terra" data-type="indexterm" id="idm45625613918840"/> normally; or Playground Mode, to experiment without saving anything, as we briefly discussed in the <span class="keep-together">introduction</span>.</p>

<figure class="width-75 no-frame"><div id="menu_on_the_notebook_preview_page_displ" class="figure"><img alt="Menu on the notebook preview page displaying the main options: Preview, Edit, and Playground Mode." src="Images/gitc_1210.png" width="1439" height="124"/>
<h6><span class="label">Figure 12-10. </span>Menu on the notebook preview page displaying the main options: Preview, Edit, and Playground Mode.</h6>
</div></figure>

<p>Click Edit and wait for the runtime to be ready. You’ll recognize when the transition to Edit mode happens by the appearance of the standard Jupyter menu bar, shown in <a data-type="xref" href="#the_standard_jupyter_notebooks_menu_bar">Figure 12-11</a>. A more subtle but also important sign is the little white box toward the right of the menu bar showing the label Edit Mode. If you had opened the notebook in Playground Mode by mistake, the Jupyter menu bar would also be displayed, but instead of the white Edit Mode label, you’d see an orange “Playground Mode (Edits not saved)” label.</p>

<figure class="no-frame"><div id="the_standard_jupyter_notebooks_menu_bar" class="figure"><img alt="The standard Jupyter menu bar." src="Images/gitc_1211.png" width="1440" height="134"/>
<h6><span class="label">Figure 12-11. </span>The standard Jupyter menu bar.</h6>
</div></figure>

<p>Further to the <a contenteditable="false" data-primary="menu bar, standard, for Jupyter Notebook" data-type="indexterm" id="idm45625613909864"/>right in that area of the menu bar is the Python 3 label that identifies the active kernel as well as the Python logo. <a contenteditable="false" data-primary="Python" data-secondary="Python 3 kernel in Jupyter Notebook" data-type="indexterm" id="idm45625613908408"/><a contenteditable="false" data-primary="kernels (Jupyter Notebook)" data-secondary="inspecting the kernel" data-type="indexterm" id="idm45625613906984"/>You might remember that the <em>kernel</em> of the notebook is the computational engine that interprets the code in the notebook and initiates execution of each cell that you run. For this particular notebook, we decided to use a Python 3 kernel so we can execute terminal commands (including to programs like <code>gsutil</code> and GATK) using Python magic methods—which is an actual technical term, we swear. You’ll see it in action shortly: it is truly magical.<a contenteditable="false" data-primary="magic methods (Python)" data-type="indexterm" id="idm45625613904184"/><a contenteditable="false" data-primary="terminal commands, execution in Jupyter Notebook, using Python magic methods" data-type="indexterm" id="idm45625613903080"/></p>

<p>In case you’re wondering, yes you can switch the kernel while the notebook is running using the Kernel menu, but we really don’t recommend doing that. It might sound useful in principle—for example, to run code in a different language in a subset of cells—but in practice it’s dangerous and can mess you up if you’re not careful. <a contenteditable="false" data-primary="R language" data-secondary="using both R and Python in same notebook" data-type="indexterm" id="idm45625613901400"/>If you need to use both Python and R code within the same notebook, you’re much better off using the Python 3 kernel and magic methods commands as we demonstrate in this notebook.</p>

<p>And with that, it’s time to run some actual code cells!</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Running the Hello World Cells"><div class="sect2" id="running_the_hello_world_cells">
<h2>Running the Hello World Cells</h2>

<p>Let’s run through a few simple examples so you can get a feel for what it’s like to work in a Jupyter notebook if you’ve never done so before. <a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-tertiary="running Hello World cells" data-type="indexterm" id="ix_TerraJNstrtHW"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-tertiary="running Hello World cells" data-type="indexterm" id="ix_JupNstrtHW"/>We’re going to run three types of commands to demonstrate the syntax for running Python code as well as R code and a command-line tool from the Python context.</p>

<section data-type="sect3" data-pdf-bookmark="Python Hello World"><div class="sect3" id="python_hello_world">
<h3>Python Hello World</h3>

<p>This is the<a contenteditable="false" data-primary="Python" data-secondary="running Python Hello World cell for Jupyter Notebook in Terra" data-type="indexterm" id="ix_PytHW"/> classic Hello World in Python, using the <code>print()</code> function and giving it the string <code>Hello World</code>. As you may recall from the Hello World we did in WDL in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>, this is the equivalent of the <code>echo "Hello World"</code> command that we used at the time. To run the cell, click anywhere in the gray area to select the cell and then press Shift+Enter on your keyboard, or, at the top of the page, on the toolbar, use the Run menu to run the cell:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]</code>  <code class="k">print</code><code class="p">(</code><code class="s2">"Hello World!"</code><code class="p">)</code></pre>

<pre data-type="programlisting">
Out [1] Hello World!</pre>

<p>You can use a variable for the greeting if you want to give yourself some flexibility. Double-click the cell to edit it and modify the code, as follows, and then run it again:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]</code>  <code class="n">greeting</code> <code class="o">=</code> <code class="s2">"Hello World!"</code>
        <code class="k">print</code><code class="p">(</code><code class="n">greeting</code><code class="p">)</code></pre>
        
<pre data-type="programlisting">
Out [2] Hello World!</pre>

<p>Incidentally, this shows you that when you have a cell containing multiple lines, running it executes all the code in the cell. Sometimes, it makes sense to group multiple commands in a single cell because you’re always going to want to run them all. However, you could also choose to divide them into separate cells. Try doing that now. You can add a new cell to the notebook either by clicking the “+” icon on the toolbar at the top of the page or by going to the Insert menu. The former automatically creates the new cell below the one that is currently active, whereas the Insert menu gives you an explicit choice to add it either above or below the active cell.</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]</code>  <code class="n">greeting</code> <code class="o">=</code> <code class="s2">"Hello World!"</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]</code>  <code class="k">print</code><code class="p">(</code><code class="n">greeting</code><code class="p">)</code></pre>

<pre data-type="programlisting">
Out [4] Hello World!</pre>

<p>This allows you to decouple the assignment of the variable and the execution of the task itself. In this simple example, it doesn’t make much difference, but when you are performing more complex operations, the choice of which commands to group versus which to break apart becomes more important.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625613733992">
<h5>Order and State in Jupyter</h5>

<p>Even though the commands are organized linearly on the page to accommodate our puny human brains, you can go back and run code cells in any order you want. That’s why the Jupyter server adds a number in the little brackets in the left margin; it gives you an indication of when the cells were last run relative to each other.</p>

<p>This system is not perfect—for example, running the same code cell again makes the previous number disappear, so if you go back and forth multiple times, you could lose track of what was run when. This is one of the shortcomings of Jupyter that is most often criticized by experienced programmers, because it can lead to risky situations in which the underlying state of the notebook is not clear; for instance, which variables are live and what their values are. If you get into a situation like that, the safest course of action might be to reset the notebook state by restarting the kernel and clearing all outputs, which you can do from the Kernel menu on the Jupyter <span class="keep-together">toolbar</span>.</p>
</div></aside>

<p>Now that you have the basic mechanics down, let’s have a look at how we can run some R code within this Python notebook.<a contenteditable="false" data-primary="Python" data-secondary="running Python Hello World cell for Jupyter Notebook in Terra" data-startref="ix_PytHW" data-type="indexterm" id="idm45625613775880"/></p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="R Hello World using Python magic methods"><div class="sect3" id="r_hello_world_using_python_magic_method">
<h3>R Hello World using Python magic methods</h3>

<p>This one requires a tiny bit of setup before we can dive into the Hello World exercise itself.<a contenteditable="false" data-primary="R language" data-secondary="running Hello World cell using Python magic methods in Jupyter Notebook" data-type="indexterm" id="idm45625613772360"/><a contenteditable="false" data-primary="magic methods (Python)" data-secondary="running R Hello World in Jupyter Notebook with" data-type="indexterm" id="idm45625613771016"/> Remember the startup script we used to customize the notebook runtime? One of the steps in that script <a contenteditable="false" data-primary="rpy2 package" data-type="indexterm" id="idm45625613764392"/>installs the <code>rpy2</code> package, which handles the interpretation of R code within the Python notebook, into the runtime environment. It’s one of the magic methods features we mentioned earlier in the chapter. To activate it, you first need to import the <code>rpy</code> package and activate the corresponding notebook extension:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]</code>  <code class="kn">import</code> <code class="nn">rpy2</code>
        <code class="o">%</code><code class="n">load_ext</code> <code class="n">rpy2</code><code class="o">.</code><code class="n">ipython</code>
</pre>

<p>This can take a few seconds, during which time the server displays an asterisk (<code>*</code>) in the brackets to the left of the cell to indicate that it’s working on it. After the package is loaded, you have two ways to invoke the magic methods: use <code>%R</code> for a single line of code or <code>%%R</code> for an entire cell.</p>

<p>Here’s the same basic Hello World as we ran earlier but in R this time, using the single-line magic methods invocation:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">6</code><code class="p">]</code>  %<code class="n">R</code> <code class="nf">print </code><code class="p">(</code><code class="s">"Hello World!"</code><code class="p">)</code></pre>

<pre data-type="programlisting">
Out [6] [1] "Hello World"</pre>

<p>Yes, that’s the same code as we ran in the Python example, because R also has a <code>print()</code> function. You can recognize that it’s the R version because the output shows up as an array with the greeting as a single string element, whereas the Python version just returned the text of the greeting as a string by itself.</p>

<p>That being said, modifying it to use a variable assignment makes it a little more obvious that it’s R code as opposed to Python. This time, use <code>%%R</code> to apply the magic methods to the whole cell:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">7</code><code class="p">]</code>  <code class="o">%%</code><code class="n">R</code>
        <code class="n">greeting</code> <code class="o">&lt;-</code> <code class="s">"Hello World!"</code>
        <code class="nf">print</code><code class="p">(</code><code class="n">greeting</code><code class="p">)</code></pre>

<pre data-type="programlisting">
Out [7] [1] "Hello World"</pre>

<p>There you go: you’re running R code in a Python notebook. This is going to be really handy when we get to the “serious” exercises, because we need to use Python in order to embed an IGV browser (coming up real soon!), but we also want to use an existing R script later for plotting. Now we have access to the best of both worlds. Just remember that when you start using this in your own notebooks, you’ll need to include the cell that imports <code>rpy2</code> and activates the extension.</p>

<p>This brings us to the third type of command that we’re going to want to run in our notebook: command-line tools like <code>ls</code>, <code>gsutil</code>, and GATK.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Command-line tool Hello World using Python magic methods"><div class="sect3" id="command_line_tool_hello_world_using_pyt">
<h3>Command-line tool Hello World using Python magic methods</h3>

<p>For this one, there’s nothing <a contenteditable="false" data-primary="command-line tools" data-secondary="Hello World in Jupyter Notebook, running using Python magic methods" data-type="indexterm" id="idm45625613610136"/>to load; the <a contenteditable="false" data-primary="magic methods (Python)" data-secondary="running command-line tool Hello World in Jupyter Notebook" data-type="indexterm" id="idm45625613608664"/>Hello World case works out of the box. We’ll use the classic <code>echo</code> command that we used in our WDL Hello World example. Simply prepend an exclamation mark to the command and then run the cell:</p>

<pre data-type="programlisting">
In [8]  ! echo "Hello World!"
 

Out [8] Hello World!</pre>

<p>You can use<a contenteditable="false" data-primary="shell commands" data-type="indexterm" id="idm45625613605496"/> all the classic shell commands in this way; for example, if you want to list the contents of the working directory, type <code><strong>! ls</strong></code> in a cell and run it. Similarly, you can run any command-line tool installed in the notebook runtime environment in this way. All preset environments available in Terra include the <code>gsutil</code> package, so you can use those tools in any Terra notebook. <a contenteditable="false" data-primary="gsutil" data-secondary="included in notebook runtime environments in Terra" data-type="indexterm" id="idm45625613602936"/>We walk you through specific examples of that in the next section. Later, we also run commands to run GATK, which our startup script installed, using the same basic syntax.</p>

<p>We’ve been focusing on code cells so far, but keep in mind all of the descriptive text cells are also editable, of course. Feel free to double-click a few and see how their appearance changes to show that they are in editing mode. Try making some edits and then, when you’re done, “run” the cell (just as you would run a code cell) to exit the text-editing mode.<a contenteditable="false" data-primary="Markdown (markup language)" data-type="indexterm" id="idm45625613600472"/> The descriptive text cells use a simple formatting markup language called <em>Markdown</em>, so you can set header levels, make bullet-point lists, and so on. For more on working with Markdown, see this helpful <a href="https://oreil.ly/07KtL">page</a> in the Jupyter project documentation. When you create new cells in your notebook, the system makes them code cells by default, but you <a contenteditable="false" data-primary="Cell menu (Jupyter Notebook)" data-type="indexterm" id="idm45625613597864"/>can switch them to Markdown via the Cell menu, by choosing Cell Type &gt; Markdown.</p>

<p>Now that you have a firm grip on the fundamentals, it’s time to do some work that is more specific to the cloud environment and the genomics subject matter that <span class="keep-together">interests</span> us.<a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-startref="x_TerraJNstrtHW" data-tertiary="running Hello World cells" data-type="indexterm" id="idm45625613595384"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with variant discovery" data-startref="ix_JupNstrtHW" data-tertiary="running Hello World cells" data-type="indexterm" id="idm45625613593432"/></p>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Using gsutil to Interact with Google Cloud Storage Buckets"><div class="sect2" id="using_gsutil_to_interact_with_google_cl">
<h2>Using gsutil to Interact with Google Cloud Storage Buckets</h2>

<p>Most of the<a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-tertiary="using gsutil to interact with GCS storage buckets" data-type="indexterm" id="idm45625613571256"/> time, the <a contenteditable="false" data-primary="gsutil" data-secondary="using from Jupyter Notebook to interact with GCS storage buckets" data-type="indexterm" id="idm45625613569416"/>data we want to work with<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-tertiary="using gsutil to interact with GCS storage buckets" data-type="indexterm" id="idm45625613567912"/> in the notebook resides in GCS buckets, so the first thing you need to learn is how to access that data.<a contenteditable="false" data-primary="storage buckets" data-secondary="GCS, interacting with from Jupyter Notebook using gsutil" data-type="indexterm" id="idm45625613566008"/><a contenteditable="false" data-primary="Google Cloud Storage (GCS)" data-secondary="using gsutil from Jupyter Notebook to interact with storage buckets" data-type="indexterm" id="idm45625613564584"/> Here’s some good news: you can use <code>gsutil</code> commands to do all the same things we’ve previously shown you in <a data-type="xref" href="ch04.xhtml#first_steps_in_the_cloud">Chapter 4</a> and beyond. For example, use <code>gsutil ls</code> to list the contents of the book bucket:<sup><a data-type="noteref" id="idm45625613561112-marker" href="ch12.xhtml#idm45625613561112">1</a></sup></p>

<pre data-type="programlisting">
In [9]  ! gsutil ls gs://genomics-in-the-cloud/
</pre>

<p>Similarly, you can use <code>gsutil cp</code> to <em>localize</em> files; that is, copy them from a bucket to the notebook’s local storage space. For example, use the following command to copy a file from the book bucket to the <em>sandbox</em> directory in the notebook runtime:</p>

<pre data-type="programlisting">
In [10]  ! gsutil cp gs://genomics-in-the-cloud/hello.txt .
</pre>

<p>Then, you can run <code>cat</code> to read the contents of the localized file. <a contenteditable="false" data-primary="cat utility" data-type="indexterm" id="idm45625613555336"/>You could write this in Python instead because this is a Python notebook, but it’s hard to beat the brevity of <code>cat</code>!</p>

<pre data-type="programlisting">
In [11]  ! cat hello.txt
</pre>

<p>As you can see, these are essentially<a contenteditable="false" data-primary="! (exclamation mark) preceding commands in Jupyter Notebook" data-type="indexterm" id="idm45625613552376"/> the same commands we used in <a data-type="xref" href="ch04.xhtml#first_steps_in_the_cloud">Chapter 4</a>, except that we added the <code>!</code> in front to signal the Python interpreter to execute that line as a terminal command instead of reading it as Python code.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Setting Up a Variable Pointing to the Germline Data in the Book Bucket"><div class="sect2" id="setting_up_a_variable_pointing_to_the_g">
<h2>Setting Up a Variable Pointing to the Germline Data in the <span class="keep-together">Book Bucket</span></h2>

<p>The next few exercises are going to make use of the germline data that we provide in the book’s data bundle. <a contenteditable="false" data-primary="variables" data-secondary="creating to store path to data in Jupyter Notebook book bucket" data-type="indexterm" id="idm45625613546632"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-tertiary="setting up variable pointing to germline data in book bucket" data-type="indexterm" id="idm45625613545208"/><a contenteditable="false" data-primary="storage data, setting up variable pointing to in book bucket from Jupyter Notebook" data-type="indexterm" id="idm45625613543496"/><a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-tertiary="setting up variable pointing to germline data in book bucket" data-type="indexterm" id="idm45625613542424"/>Because the path to the example data is rather long, let’s set up a variable to store it in the notebook in a more concise form, much as we did with an environmental variable back in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]</code>  <code class="n">GERM_DATA</code> <code class="o">=</code> <code class="s2">"gs://genomics-in-the-cloud/v1/data/germline"</code>
</pre>

<p>This is a Python <a contenteditable="false" data-primary="Python" data-secondary="variable storing path to germline data in book bucket" data-type="indexterm" id="idm45625613534424"/>variable, so when you use it in a shell command, you’ll need to wrap it up in curly braces.<a contenteditable="false" data-primary="{} (curly braces)" data-secondary="enclosing Python variable in Jupyter Notebook" data-type="indexterm" id="idm45625613532408"/> For example, a command using <code>gsutil</code> to list the contents of that directory would look like this:</p>

<pre data-type="programlisting">
In [13]  ! gsutil ls {GERM_DATA}
</pre>

<p>Take a moment to think about how we’re using curly braces around this variable instead of calling it as <code>$GERM_DATA</code>, which you might have expected based on the Bash environment variables that we’ve been using quite a bit so far. The key point to remember here is that we set up the bucket shortcut as a Python variable, not a shell environment variable. It is possible to use shell environment variables in the notebook, but that’s a topic for another time.</p>

<p>You can also compose paths based on this variable in order to list subdirectories; for example, to get a list of the BAM files, or perform operations on specific files. For each of the following commands, try to infer what its function is, then run it in the notebook and evaluate the result against your expectation.</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]</code>  <code class="err">!</code> <code class="n">gsutil</code> <code class="n">ls</code> <code class="p">{</code><code class="n">GERM_DATA</code><code class="p">}</code><code class="o">/</code><code class="n">bams</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]</code>  <code class="err">!</code> <code class="n">gsutil</code> <code class="n">cp</code> <code class="p">{</code><code class="n">GERM_DATA</code><code class="p">}</code><code class="o">/</code><code class="n">bams</code><code class="o">/</code><code class="n">mother</code><code class="o">.</code><code class="n">ba</code><code class="o">*</code> <code class="o">.</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]</code>  <code class="err">!</code> <code class="n">ls</code> <code class="o">.</code>
</pre>

<p>Later in this chapter, we also show you how to use this same <code>GERM_DATA</code> variable in the context of some Python code.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Setting Up a Sandbox and Saving Output Files to the Workspace Bucket"><div class="sect2" id="setting_up_a_sandbox_and_practice_savin">
<h2>Setting Up a Sandbox and Saving Output Files to the <span class="keep-together">Workspace Bucket</span></h2>

<p>When you run commands in the notebook that produce output files, by default those files<a contenteditable="false" data-primary="sandbox directory" data-secondary="setting up in Jupyter Notebook and saving output files to workspace bucket" data-type="indexterm" id="idm45625613455864"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-tertiary="setting up sandbox and saving output files to workspace bucket" data-type="indexterm" id="idm45625613454520"/> will be saved on the notebook’s local storage space.<a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-tertiary="setting up sandbox and saving output files to workspace bucket" data-type="indexterm" id="idm45625613452744"/><a contenteditable="false" data-primary="workspaces (Terra)" data-secondary="saving Jupyter Notebook output files to workspace bucket" data-type="indexterm" id="idm45625613451032"/><a contenteditable="false" data-primary="storage buckets" data-secondary="saving Jupyter Notebook output files to workspace bucket" data-type="indexterm" id="idm45625613449688"/> However, the local storage associated with your notebook is temporary, so you’ll need to copy any outputs that you care about to a GCS bucket. You can use any bucket to which you have write access for that purpose, but we recommend using the workspace’s dedicated bucket.</p>

<p>To streamline the process of saving outputs to the bucket, we like to do two things: create a sandbox to house the output files that we’re going to produce, and set up a variable pointing to the workspace bucket.</p>

<p>Let’s begin with the <em>sandbox</em> directory; go ahead and create a new directory, and then move some files there for demonstration purposes. Once again, we include the commands here but don’t detail their purpose or results. We do provide additional detail in the notebook. Try to infer the function of each command before you look at its full description and run it in the notebook:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]</code>  <code class="err">!</code> <code class="n">mkdir</code> <code class="o">-</code><code class="n">p</code> <code class="n">sandbox</code><code class="o">/</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]</code>  <code class="err">!</code> <code class="n">mv</code> <code class="n">mother</code><code class="o">.</code><code class="n">ba</code><code class="o">*</code> <code class="n">sandbox</code><code class="o">/</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]</code>  <code class="err">!</code> <code class="n">ls</code> <code class="n">sandbox</code>
</pre>

<p>When you have your sandbox ready, let’s tackle the workspace bucket. The workspace bucket name is a long machine-generated sequence of letters and numbers, which is annoying to work with. Fortunately, we can import it programmatically (rather than looking it up manually in the workspace dashboard) because Terra makes it available to the notebook as a system variable. And to make it even easier, we’re going to create a Python variable from that system variable as follows:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]</code>  <code class="kn">import</code> <code class="nn">os</code>
         <code class="n">WS_BUCKET</code> <code class="o">=</code> <code class="n">os</code><code class="o">.</code><code class="n">environ</code><code class="p">[</code><code class="s1">'WORKSPACE_BUCKET'</code><code class="p">]</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]</code>  <code class="k">print</code><code class="p">(</code><code class="n">WS_BUCKET</code><code class="p">)</code></pre>

<pre data-type="programlisting">
Out [21] ’gs://fc-46207b9c-d593-4e7a-9057-7aca3bb5c9a7’</pre>

<p>Here, we use Python commands to set variables at the Python level.<a contenteditable="false" data-primary="variables" data-secondary="using Python commands to set variables" data-type="indexterm" id="idm45625613338408"/> The <code>import os</code> command allows <a contenteditable="false" data-primary="import os command" data-type="indexterm" id="idm45625613336584"/>us to interact with the operating system from within Python code, and the <code>os.environ['WORKSPACE_BUCKET']</code> call uses that to access the value<a contenteditable="false" data-primary="os.environ command" data-type="indexterm" id="idm45625613334904"/> of the environment variable <code>'WORKSPACE_BUCKET'</code>, which was originally set for you by the Terra Notebooks service.</p>

<p>From here on, you’ll be able to refer to the workspace bucket as <code>WS_BUCKET</code>. For example, you can use <code>gsutil ls</code> to list its contents:</p>

<pre data-type="programlisting">
In [22]  ! gsutil ls -r {WS_BUCKET}
</pre>

<p>Notice that we wrapped the <code>WS_BUCKET</code> variable in curly braces, just as we did for the germline data variable in the previous section.<a contenteditable="false" data-primary="{WS_BUCKET} variable" data-primary-sortas="WS_BUCKET" data-type="indexterm" id="idm45625613330408"/></p>

<p>After that’s set up, you can simply run the same <code>gsutil cp</code> command on the <em>sandbox</em> directory whenever you want to save your outputs to the workspace bucket:</p>

<pre data-type="programlisting">
In [23]  ! gsutil -m cp -r sandbox {WS_BUCKET}

In [24]  ! gsutil ls {WS_BUCKET}/sandbox
</pre>

<p>This copies the entire <em>sandbox</em> directory from the notebook’s local storage to the workspace bucket. Keep in mind that this approach might not scale very well if you’re producing many large files; in that case, you might want to consider dividing and managing your sandbox in separate subdirectories. It is admittedly not ideal that you must synchronize files manually to the bucket; we look forward to seeing improvements to the experience of using these tools as the technology develops further. At least the notebook file itself is saved automatically, as we discussed earlier.<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="getting started with in Terra" data-startref="ix_JupNstrt" data-type="indexterm" id="idm45625613325512"/><a contenteditable="false" data-primary="Terra platform" data-secondary="getting started with Jupyter Notebook in" data-startref="ix_TerraJNstrt" data-type="indexterm" id="idm45625613323800"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Visualizing Genomic Data in an Embedded IGV Window"><div class="sect1" id="visualizing_genomic_data_in_an_embedded">
<h1>Visualizing Genomic Data in an Embedded IGV Window</h1>

<p>Now that our notebook <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing genomic data in embedded IGV window" data-type="indexterm" id="ix_JupNvisIGV"/>is all set up and <a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-type="indexterm" id="ix_IGVJuN"/>ready to roll, <a data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook"> </a>let’s use it to try out a cool trick: visualizing genomic data with IGV within the context of the notebook. In previous chapters, we had you work with the desktop version of IGV, which you had set up to pull data from GCS. This time, we’re going to do something a little different: we’re going to use a special IGV package called <em>IGV.js</em> that allows us to embed an IGV browser in the notebook. <a contenteditable="false" data-primary="IGV.js package" data-type="indexterm" id="idm45625613314792"/>This is especially convenient when you want to include the data visualization within a tutorial for students, or within a report to communicate results to collaborators, in such a way that they don’t need to resort to using a separate program.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <em>IGV.js</em> package has limitations that we describe further in just a moment. In a nutshell, it’s very cool when it works, so we do think it’s worth showing you how to use it in a Jupyter notebook, but it doesn’t always work seamlessly. If you experience any difficulties while using it, we recommend that you fall back to using Desktop IGV, as previously described.</p>
</div>

<p>In this exercise, we’re going to load two BAM files: the WGS mother <a contenteditable="false" data-primary="whole genome sequencing" data-secondary="BAM file loaded into Jupyter Notebook with IGV embedded" data-type="indexterm" id="idm45625613288616"/>sample, which has been our go-to test file for most of the book, and an exome sample from the same person for comparison. You might recall that in <a data-type="xref" href="ch02.xhtml#genomics_in_a_nutshell_a_primer_for_new">Chapter 2</a> (a lifetime ago), we touched on the differences between several library design strategies, including WGS and exome sequencing. <a contenteditable="false" data-primary="exome sequencing" data-secondary="BAM file loaded into Jupyter Notebook with IGV embedded" data-type="indexterm" id="idm45625613285880"/>In particular, we discussed how their coverage profiles have very different shapes: the WGS tends to look like a distant mountain range, whereas the exome sample looks more like a series of volcanic islands scattered in the ocean. This is an opportunity for you to see that for yourself, essentially replicating <a data-type="xref" href="ch02.xhtml#visual_appearance_of_whole_genome_seque">Figure 2-18</a> in an interactive form, while trying out the <em>IGV.js</em> integration.</p>

<section data-type="sect2" data-pdf-bookmark="Setting Up the Embedded IGV Browser"><div class="sect2" id="setting_up_the_embedded_igv_browser">
<h2>Setting Up the Embedded IGV Browser</h2>

<p>The good news is that there’s not much you need to do here. <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing genomic data in embedded IGV window" data-tertiary="setting up embedded IGV browser" data-type="indexterm" id="idm45625613280568"/><a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-tertiary="setting up IGV browser" data-type="indexterm" id="idm45625613278776"/>Remember the startup script that you ran as part of the runtime environment customization? That included instructions to install all the prerequisite software to run <em>IGV.js</em>, which the system executed when it created your customized runtime environment. As a result, we just need to do a <a contenteditable="false" data-primary="igv Python package" data-type="indexterm" id="idm45625613276344"/>one-time import to activate the <code>igv</code> Python package. After that, it’s just a matter of creating an IGV browser wherever you want one to appear, as shown in the code cell that follows. <a contenteditable="false" data-primary="Python" data-secondary="code setting up embedded IGV browser in Jupyter Notebook" data-type="indexterm" id="idm45625613274536"/>This is all Python code that follows the guidelines documented by the IGV team in the <a href="https://oreil.ly/JgOtt">IGV-Jupyter repository</a> on GitHub:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]</code>  <code class="kn">import</code> <code class="nn">igv</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]</code>  <code class="n">IGV_Explore</code> <code class="o">=</code> <code class="n">igv</code><code class="o">.</code><code class="n">Browser</code><code class="p">(</code>
             <code class="p">{</code><code class="s2">"genome"</code><code class="p">:</code> <code class="s2">"hg19"</code><code class="p">,</code>
             <code class="s2">"locus"</code><code class="p">:</code> <code class="s2">"chr20:10,025,584-10,036,143"</code>
             <code class="p">}</code>
         <code class="p">)</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]</code>  <code class="n">IGV_Explore</code><code class="o">.</code><code class="n">show</code><code class="p">()</code>
</pre>

<p>The name we give the browser (here, <code>IGV_Explore</code>) is completely arbitrary. You could provide other parameters to initialize the browser, but the only one that is absolutely required is the genome reference; everything else is optional. That being said, we usually specify some coordinates (or the name of a gene of interest) for the browser to zoom in on straight away.</p>

<p>When you run the cell, you should see an embedded IGV browser that includes the reference genome and a RefSeq gene track, but no actual data tracks, as shown in <a data-type="xref" href="#a_newly_created_igv_browserdot">Figure 12-12</a>.</p>

<figure class="no-frame"><div id="a_newly_created_igv_browserdot" class="figure"><img alt="A newly created IGV browser." src="Images/gitc_1212.png" width="1441" height="315"/>
<h6><span class="label">Figure 12-12. </span>A newly created IGV browser.</h6>
</div></figure>

<p>Next, let’s add the two sample BAM files that we want to compare.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Adding Data to the IGV Browser"><div class="sect2" id="adding_data_to_the_igv_browser">
<h2>Adding Data to the IGV Browser</h2>

<p>For each track that <a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-tertiary="adding data to IGV browser" data-type="indexterm" id="idm45625613230760"/>we want to load, we <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing genomic data in embedded IGV window" data-tertiary="adding data to IGV browser" data-type="indexterm" id="idm45625613228856"/>need to provide this same set of metadata: a name for the track, the path to where the file lives in GCS, the format, and the path to the corresponding index file.<a contenteditable="false" data-primary="load_track function (Python)" data-type="indexterm" id="idm45625613226824"/> We provide this information to IGV using the <code>load_track()</code> function:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">28</code><code class="p">]</code>  <code class="n">IGV_Explore</code><code class="o">.</code><code class="n">load_track</code><code class="p">(</code>
             <code class="p">{</code>
                 <code class="s2">"name"</code><code class="p">:</code> <code class="s2">"Mother WGS"</code><code class="p">,</code>
                 <code class="s2">"url"</code><code class="p">:</code> <code class="n">GERM_DATA</code> <code class="o">+</code> <code class="s2">"/bams/mother.bam"</code><code class="p">,</code>
                 <code class="s2">"indexURL"</code><code class="p">:</code> <code class="n">GERM_DATA</code> <code class="o">+</code> <code class="s2">"/bams/mother.bai"</code><code class="p">,</code>
                 <code class="s2">"format"</code><code class="p">:</code> <code class="s2">"bam"</code>
             <code class="p">})</code>


<code class="n">In</code> <code class="p">[</code><code class="mi">29</code><code class="p">]</code>  <code class="n">IGV_Explore</code><code class="o">.</code><code class="n">load_track</code><code class="p">(</code>
             <code class="p">{</code>
                 <code class="s2">"name"</code><code class="p">:</code> <code class="s2">"Mother Exome"</code><code class="p">,</code>
                 <code class="s2">"url"</code><code class="p">:</code> <code class="n">GERM_DATA</code> <code class="o">+</code> <code class="s2">"/bams/motherNEX.bam"</code><code class="p">,</code>
                 <code class="s2">"indexURL"</code><code class="p">:</code> <code class="n">GERM_DATA</code> <code class="o">+</code> <code class="s2">"/bams/motherNEX.bai"</code><code class="p">,</code>
                 <code class="s2">"format"</code><code class="p">:</code> <code class="s2">"bam"</code>
             <code class="p">})</code>
</pre>

<p>Because this is all Python code, we can use the Python variable that we set up for the germline data simply by <a contenteditable="false" data-primary="GERM_DATA Python variable" data-type="indexterm" id="idm45625613221976"/>referring to its name, <code>GERM_DATA</code>.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Take a moment to note the Python syntax, which explicitly uses a <code>+</code> operator to <a contenteditable="false" data-primary="+ (plus sign) concatenation operator in Python" data-type="indexterm" id="idm45625613129304"/>concatenate the<a contenteditable="false" data-primary="concatenating strings, Python versus gsutil" data-type="indexterm" id="idm45625613128008"/> variable and the subdirectory strings in order to compose the full address pointing to where the data files reside. <a contenteditable="false" data-primary="gsutil" data-secondary="string concatenation in" data-type="indexterm" id="idm45625613126584"/>This is in contrast to the shell syntax that we used earlier in the <code>gsutil</code> command, <code>"{GERM_DATA}/bams"</code>, which is a more implicit instruction. If you’re not very familiar with Python, know that this exemplifies one of the cardinal rules of Python programming: explicit is better than implicit.</p>
</div>

<p>After you’ve run both cells and each of them returns <code>OK</code> as a result, scroll up to the browser, where you should see spinning symbols that indicate the data is loading. <a contenteditable="false" data-primary="whole genome sequencing" data-secondary="visualization of data loaded into embedded IGV browser in Jupyter Notebook" data-type="indexterm" id="idm45625613123048"/>When the spinners go away and the data displays, you should have two data tracks in your<a contenteditable="false" data-primary="exome sequencing" data-secondary="visualization of data loaded into embedded IGV browser in Jupyter Notebook" data-type="indexterm" id="idm45625613121464"/> IGV browser: the WGS and exome versions of the mother sample, respectively, as shown in <a data-type="xref" href="#the_igv_browser_showing_the_two_sequenc">Figure 12-13</a>.</p>

<figure class="no-frame"><div id="the_igv_browser_showing_the_two_sequenc" class="figure"><img alt="The IGV browser showing the two sequence data tracks." src="Images/gitc_1213.png" width="1439" height="1213"/>
<h6><span class="label">Figure 12-13. </span>The IGV browser showing the two sequence data tracks.</h6>
</div></figure>

<p>Try zooming in and out, and drag the sequence left and right to pan the view and get a sense of how the data is distributed in these two samples. You’ll observe the classic “mountain range versus volcanic islands” difference in coverage profile, which you can use from here onward to identify the library design type of any sequencing sample on sight.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It is<a contenteditable="false" data-primary="BAMs (Binary Alignment Maps)" data-secondary="loading BAM files into embedded IGV browser in Jupyter Notebook without specifying index file" data-type="indexterm" id="idm45625613114664"/> technically possible to load VCF and BAM files in the<a contenteditable="false" data-primary="indexes" data-secondary="loading VCF and BAM files into embedded IGV browser in Jupyter Notebook without specifying index file" data-type="indexterm" id="idm45625613113016"/> embedded IGV browser <a contenteditable="false" data-primary="VCF (Variant Call Format) files" data-secondary="loading into embedded IGV browser in Jupyter Notebook without specifying index file" data-type="indexterm" id="idm45625613111432"/>without specifying an index file. To do so, omit the <code>"indexURL"</code> line and replace it with <code>"indexed": False</code>. Be aware, however, that doing so will cause IGV to take much longer to load the data. It can take a couple of minutes for the data to load, and you might see a pop-up window stating that the page is unresponsive. If so, dismiss the alert and give it another minute. If it takes much longer than that, you might need to fall back to using the desktop version of IGV.</p>
</div>

<p>We hope you’ll agree this is a neat way to include a view of the genomic data within an analysis log or report, even though it suffers from a few limitations. One limitation is the lag that you might experience when you originally load the data; another is the fact that not all display customization options are available compared to the desktop version of IGV. Authentication can be a major stumbling block if you don’t have proper guidance: if you want to access data in private buckets (which includes your workspace bucket!), you need to jump through additional hoops that involve access credentials. You might recall that in <a data-type="xref" href="ch04.xhtml#first_steps_in_the_cloud">Chapter 4</a> you had to enable a Google login option in the desktop version of IGV in order to view files from a private bucket. Here, we’re going to do something similar, except instead of a point-and-click process, it will consist of a few lines of code.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Setting Up an Access Token to View Private Data"><div class="sect2" id="setting_up_an_access_token_to_view_priv">
<h2>Setting Up an Access Token to View Private Data</h2>

<p>In the previous example, we were reading data from completely public buckets, so we didn’t need to do any authentication.<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing genomic data in embedded IGV window" data-tertiary="setting up access token to view private data" data-type="indexterm" id="idm45625613104392"/><a contenteditable="false" data-primary="authentication" data-secondary="viewing private data in embedded IGV browser in Jupyter Notebook" data-type="indexterm" id="idm45625613102616"/><a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-tertiary="setting up access token to view private data" data-type="indexterm" id="idm45625613101272"/> However, you’ll eventually want to view files in private buckets. <a contenteditable="false" data-primary="access token to view private data in Jupyter Notebook" data-type="indexterm" id="idm45625613099432"/>To do that, you need to set up an access token that IGV can use to access data in your private bucket.<a contenteditable="false" data-primary="gcloud (Google Cloud SDK)" data-secondary="auth command" data-type="indexterm" id="idm45625613098056"/></p>

<p>First, let’s use <code>gcloud auth</code> to generate an access token and save it to a file:</p>

<pre data-type="programlisting">
In [30]  ! gcloud auth print-access-token &gt; token.txt
</pre>

<p>As long as this file is saved only to your notebook’s local storage, it is secure because your runtime environment is strictly personal to you and cannot be accessed by others, even if you share your workspace or your notebook with them. But don’t save this file to your workspace bucket! Saving it to the bucket would make it visible to anyone with whom you share the workspace.</p>

<p>Next, read the contents of the token file into a Python variable. <a contenteditable="false" data-primary="variables" data-secondary="Python variable, reading token file contents into" data-type="indexterm" id="idm45625613093816"/>Because the token consists of a single line of text, we can use the <code>readline()</code> function, which reads the first<a contenteditable="false" data-primary="readline function (Python)" data-type="indexterm" id="idm45625613091800"/> line of a file into a string:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">31</code><code class="p">]</code>  <code class="n">token_file</code> <code class="o">=</code> <code class="nb">open</code><code class="p">(</code><code class="s2">"token.txt"</code><code class="p">,</code><code class="s2">"r"</code><code class="p">)</code> 
         <code class="n">token</code> <code class="o">=</code> <code class="n">token_file</code><code class="o">.</code><code class="n">readline</code><code class="p">()</code>
</pre>

<p>At this point, you have the <code>token</code> variable stored and ready to use with IGV whenever you want to load a file that resides in a private bucket.</p>

<p>For example, recall that in the previous section, we had you copy the <em>mother.bam</em> file and its index to your workspace bucket. Even though you own that bucket, the IGV process that is running in your notebook doesn’t “know” that you’re allowed to access it.<a contenteditable="false" data-primary="load_track function (Python)" data-type="indexterm" id="idm45625613035384"/> You must instruct it explicitly by providing the token that you just set up when you make the call to <code>load_track()</code> function, as follows:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">32</code><code class="p">]</code>  <code class="n">IGV_Explore</code><code class="o">.</code><code class="n">load_track</code><code class="p">(</code>
             <code class="p">{</code>
                <code class="s2">"name"</code><code class="p">:</code> <code class="s2">"Workspace bucket copy of Mother WGS"</code><code class="p">,</code>
                <code class="s2">"url"</code><code class="p">:</code> <code class="n">WS_BUCKET</code> <code class="o">+</code> <code class="s2">"/sandbox/mother.bam"</code><code class="p">,</code>
                <code class="s2">"indexURL"</code><code class="p">:</code> <code class="n">WS_BUCKET</code> <code class="o">+</code> <code class="s2">"/sandbox/mother.bai"</code><code class="p">,</code>
                <code class="s2">"format"</code><code class="p">:</code> <code class="s2">"bam"</code><code class="p">,</code>
                <code class="s2">"oauthToken"</code><code class="p">:</code> <code class="n">token</code>
             <code class="p">})</code>
</pre>

<p>As you can see, we copied the same code we used earlier to load BAM files, except this time we provided the path to the files in the workspace bucket and added the token that we generated earlier. If you’re curious to see what would happen if you didn’t provide the token, feel free to try it out by deleting that line (as well as the comma that ends the previous line). Note that it is also possible to access data that resides in private buckets managed outside of Terra. As we’ll see in <a data-type="xref" href="ch13.xhtml#assembling_your_own_workspace_in_terra">Chapter 13</a>, this requires giving access to the bucket to your proxy group service account.</p>

<p>If you were to have multiple private files to load in the IGV browser, you would include the token in each track definition. The <a href="https://oreil.ly/RWDqg">IGV documentation</a> states that it is possible to set a global IGV configuration variable, <code>igv.setGoogleOauth​Token​(accessToken)</code>, that would apply to all tracks, but as of this writing, that did not work within our notebook.<a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-startref="ix_IGVJuN" data-type="indexterm" id="idm45625612970056"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing genomic data in embedded IGV window" data-startref="ix_JupNvisIGV" data-type="indexterm" id="idm45625612968408"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Running GATK Commands to Learn, Test, or Troubleshoot"><div class="sect1" id="running_gatk_commands_to_learncomma_tes">
<h1>Running GATK Commands to Learn, Test, or Troubleshoot</h1>

<p>It’s all well and good that we can visualize the<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-type="indexterm" id="ix_JupNGATK"/> sequencing <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-type="indexterm" id="ix_GATKJN"/>data from within a notebook, but we were already able to achieve the equivalent result with the desktop version of IGV. What’s really cool about the notebook concept is that we can run analysis commands and then visualize the output, all within the same environment.</p>

<p>What kind of analyses can you run, you ask? Well, just about anything you want. As you saw when we had you run <code>gsutil</code> commands, you’re not constrained to running only Python code in a Python notebook. You can run pretty much anything that you can install and run in the shell environment.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Here we’re relying<a contenteditable="false" data-primary="startup script, using to customize software in notebook runtime" data-secondary="startup script installing GATK and IGV" data-type="indexterm" id="idm45625612959032"/> on the startup script that you used to initialize your notebook runtime environment at the start of this chapter’s exercises. That script includes instructions to download the GATK package and make it available for command-line invocation, which were executed when the environment was created for you, so you don’t need to do any of it yourself.</p>
</div>

<p>In this section, we show you how to run GATK commands and visualize the results in IGV, both from within the notebook. We find that this provides a much more integrated and seamless experience than the “split-screen” approach we took in earlier chapters in which we were running GATK commands in a VM and then visualizing results in the desktop version of IGV. We put you through all that because we’re sadists, and also because it gave you the opportunity to build up foundational skills. Through that process, you gained a measure of familiarity with the underlying components of cloud computing that should help you conceptualize what’s happening behind the scenes when you run a workflow or work in a notebook. And perhaps having gone through that will enhance your appreciation of the notebook-based approach, if only for purposes like teaching, testing, and troubleshooting.</p>

<p>To that end, we’re going to revisit exercises that you previously worked through in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a> so you can focus your attention on <em>how</em> you are doing the work rather than what the analysis means.</p>

<section data-type="sect2" data-pdf-bookmark="Running a Basic GATK Command: HaplotypeCaller"><div class="sect2" id="running_a_basic_gatk_command_haplotypec">
<h2>Running a Basic GATK Command: HaplotypeCaller</h2>

<p>Let’s begin by running the <code>HaplotypeCaller</code> tool on <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-tertiary="running HaplotypeCaller" data-type="indexterm" id="ix_GATKJNHC"/>the same sample we’ve been using throughout the book. <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-tertiary="running HaplotypeCaller" data-type="indexterm" id="ix_JupNGATKHC"/><a contenteditable="false" data-primary="HaplotypeCaller" data-secondary="running in Jupyter Notebook" data-type="indexterm" id="ix_HCJN"/>You should recognize this command, which we copied almost verbatim from <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>:</p>

<pre data-type="programlisting">
In [33]  ! gatk HaplotypeCaller \
             -R {GERM_DATA}/ref/ref.fasta \
             -I {GERM_DATA}/bams/mother.bam \
             -O sandbox/mother_variants.200k.vcf.gz \
             -L 20:10,000,000-10,200,000
</pre>

<p>What are the differences in this command compared to how we ran it in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>? By now you should <a contenteditable="false" data-primary="! (exclamation mark) preceding commands in Jupyter Notebook" data-type="indexterm" id="idm45625612941896"/>recognize the <code>!</code> that precedes the GATK command as the signal to bypass the Python interpreter and run it as a shell command. The reference to the file path variable is also a little different since we’re using curly braces instead of <code>$</code>, as noted earlier. We’re also writing the output VCF file in the compressed <em>gzip</em> form, which is a requirement for IGV in the next step.</p>

<p>Another difference is a bit hidden by our use of a Python variable to store the common part of the input file paths, <em>gs://genomics-in-the-cloud/v1/data/germline</em>. This <a contenteditable="false" data-primary="variables" data-secondary="Python variable storing input paths for data loaded into Jupyter Notebook" data-type="indexterm" id="idm45625612909672"/>time, we’re using the paths to the files in GCS instead of pointing to a local copy. We can do that because, as we’ve noted several times by now, GATK tools are capable of streaming most types of file inputs directly from GCS. In practice this behavior kicks in whenever the GATK command-line parser identifies that an eligible input file path starts with <em>gs://</em>. This is great because it allows us to avoid localizing the relevant files to the notebook’s local storage. Incidentally, this also works for writing output files directly to GCS, though we don’t demonstrate it here.</p>

<p>In <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a> through <a data-type="xref" href="ch07.xhtml#gatk_best_practices_for_somatic_variant">Chapter 7</a>, we had you localize the full data bundle and run all GATK commands with local file inputs. We could have had you run most of the commands with the bucket paths instead and relied on GATK’s data streaming capabilities; it would have worked just fine on your VM. However, we felt that introducing those aspects so early would overcomplicate what might well be your first experience with the cloud. We chose instead to have you work with localized files in the hope that the ensuing experience would provide enough familiarity to make you feel more comfortable. We bring this up now in case you choose to go back to working in a VM environment, so that you know that you can still take advantage of the streaming feature. And, as you might remember from the discussion on optimizations in <a data-type="xref" href="ch10.xhtml#running_single_workflows_at_scale_with">Chapter 10</a>, this also works in the context of WDL workflows.</p>

<p>When you run the command, you should see the log output being written to the notebook below the cell. This is a really nice touch in terms of keeping all the information about the analysis together in a single place—it’s one of the key benefits of the Jupyter concept. On the downside, if you’re running a tool that’s particularly verbose (as GATK can occasionally be), you can end up with pages and pages of a log in the middle of your notebook. That’s where it really helps to use clear section headers in Markdown cells to demarcate the different parts of your analysis, especially in combination with the notebook widget that automatically creates a table of contents and sidebar navigation menu.</p>

<p>After the <code>HaplotypeCaller</code>’s run is complete, let’s list the sandbox contents to confirm that the command worked and that the VCF of variant calls was created as expected:</p>

<pre data-type="programlisting">
In [34]  ! ls sandbox/
</pre>

<p>Yep, there <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-startref="x_GATKJNHC" data-tertiary="running HaplotypeCaller" data-type="indexterm" id="idm45625612899576"/>it is, along <a contenteditable="false" data-primary="HaplotypeCaller" data-secondary="running in Jupyter Notebook" data-startref="ix_HCJN" data-type="indexterm" id="idm45625612897512"/>with its <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-startref="ix_JupNGATKHC" data-tertiary="running HaplotypeCaller" data-type="indexterm" id="idm45625612895688"/>index file. Let’s look at it in IGV.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Loading the Data (BAM and VCF) into IGV"><div class="sect2" id="loading_the_data_left_parenthesisbam_an">
<h2>Loading the Data (BAM and VCF) into IGV</h2>

<p>Suppose that we want to open the output VCF with IGV in our notebook, mainly to do a visual check<a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-tertiary="loading BAM and VCF data into" data-type="indexterm" id="ix_IGVJNld"/> and compare <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-tertiary="loading data files (BAM and VCF) into embedded IGV" data-type="indexterm" id="ix_JupNGATKld"/>it to <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-tertiary="loading data files (BAM and VCF) into embedded IGV" data-type="indexterm" id="ix_GATKJNld"/>the BAM file. We could use the IGV browser that we created earlier to look at the different BAM files, but because this is a separate exercise with a different purpose—and we’re too lazy to scroll up a bunch of pages—we’re going to create a new one.</p>

<p>The first bit of code is essentially the same as what we used earlier except that we’re using a different name for the browser object:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">35</code><code class="p">]</code>  <code class="n">IGV_InspectCalls</code> <code class="o">=</code> <code class="n">igv</code><code class="o">.</code><code class="n">Browser</code><code class="p">(</code>
             <code class="p">{</code><code class="s2">"genome"</code><code class="p">:</code> <code class="s2">"hg19"</code><code class="p">,</code>
             <code class="s2">"locus"</code><code class="p">:</code> <code class="s2">"chr20:10,002,294-10,002,623"</code>
             <code class="p">}</code>
          <code class="p">)</code>

          <code class="n">IGV_InspectCalls</code><code class="o">.</code><code class="n">show</code><code class="p">()</code>
</pre>

<p>This creates a new browser below the cell, zoomed in on intervals of interest but without any data. So, let’s load the variant data from the VCF file that we produced with the <code>HaplotypeCaller</code> command, which resides in the <em>sandbox</em> directory on the notebook’s local storage space:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">36</code><code class="p">]</code>  <code class="n">IGV_InspectCalls</code><code class="o">.</code><code class="n">load_track</code><code class="p">(</code>
             <code class="p">{</code>
                <code class="s2">"name"</code><code class="p">:</code> <code class="s2">"Mother variants"</code><code class="p">,</code>
                <code class="s2">"url"</code><code class="p">:</code> <code class="s2">"files/sandbox/mother_variants.200k.vcf.gz"</code><code class="p">,</code>
                <code class="s2">"indexURL"</code><code class="p">:</code> <code class="s2">"files/sandbox/mother_variants.200k.vcf.gz.tbi"</code><code class="p">,</code>
                <code class="s2">"format"</code><code class="p">:</code> <code class="s2">"vcf"</code>
             <code class="p">})</code>
</pre>

<p>This is the same code that we used earlier to load BAM files, except this time we changed the track <code>format</code> property to <code>vcf</code> instead of <code>bam</code>, and the file paths (<code>url</code> and <code>indexURL</code>) are pointing to local files instead of pointing to locations in GCS.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Pay attention to those<a contenteditable="false" data-primary="file paths for genomic data loaded into IGV embedded in Jupyter Notebook" data-type="indexterm" id="idm45625612805240"/> file paths: you should notice that they’re not exactly the file paths you would expect based on the directory structure of the notebook’s local storage space. Do you see it? The <code>files/</code> part does not refer to a real directory! It’s a prefix that we add for IGV’s benefit, as instructed in the <a href="https://oreil.ly/JgOtt">IGV-Jupyter project <span class="keep-together">documentation</span></a>.</p>
</div>

<p>Alternatively, you could run the <code>gsutil cp</code> command to copy the sandbox to the workspace bucket and then use the paths to the workspace bucket copy to load the VCF track. However, if you do that, don’t forget to include the access token as explained in the previous section.</p>

<p>Finally, let’s load the BAM file and its index from the original germline data bundle. These files are located in a public bucket and therefore do not require specifying the access token (but if you do include it, nothing bad will happen):</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">37</code><code class="p">]</code>  <code class="n">IGV_InspectCalls</code><code class="o">.</code><code class="n">load_track</code><code class="p">(</code>
             <code class="p">{</code>
                <code class="s2">"name"</code><code class="p">:</code> <code class="s2">"Mother WGS"</code><code class="p">,</code>
                <code class="s2">"url"</code><code class="p">:</code> <code class="n">GERM_DATA</code> <code class="o">+</code> <code class="s2">"/bams/mother.bam"</code><code class="p">,</code>
                <code class="s2">"indexURL"</code><code class="p">:</code> <code class="n">GERM_DATA</code> <code class="o">+</code> <code class="s2">"/bams/mother.bai"</code><code class="p">,</code>
                <code class="s2">"format"</code><code class="p">:</code> <code class="s2">"bam"</code>
             <code class="p">})</code>
</pre>

<p>The resulting view, shown in <a data-type="xref" href="#igvdotjs_rendering_of_the_sequencing_da">Figure 12-14</a>, should look essentially the same as what you produced in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>, with a few differences in appearance between the desktop version and the <em>IGV.js</em> version of the visual rendering.</p>

<figure class="no-frame"><div id="igvdotjs_rendering_of_the_sequencing_da" class="figure"><img alt="IGV.js rendering of the sequencing data (&quot;Mother WGS&quot; track) and output variants produced by HaplotypeCaller (&quot;Mother variants&quot; track)." src="Images/gitc_1214.png" width="1439" height="847"/>
<h6><span class="label">Figure 12-14. </span>IGV.js rendering of the sequencing data (“Mother WGS” track) and output variants produced by HaplotypeCaller (“Mother variants” track).</h6>
</div></figure>

<p>You can click elements of data (e.g., reads or variants) in the viewer to bring up additional details, just as we did in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>. The visual display is a little different, but it’s basically the same functionality, except that you can’t switch it to show details “on hover.”</p>

<p>One difference that’s not obvious here is that the embedded IGV window organizes tracks a little differently compared to the way the desktop version of IGV does it. In the desktop version, variant tracks are automatically displayed above sequence data tracks, regardless of the order in which they are loaded. You could load a BAM file first and then a VCF file, yet the variant track will always be on top. In contrast, the embedded IGV window displays tracks in whatever order they are added. So, if you load the BAM file first, that’s what will be on top, even if you load a VCF file <span class="keep-together">afterward.</span></p>

<p>Hopefully this gives you a good sense of how you can use the embedded IGV within a notebook. Let’s work through one more exercise from the original <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a> curriculum to practice using this tooling and cover a few more minor options.<a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-startref="ix_GATKJNld" data-tertiary="loading data files (BAM and VCF) into embedded IGV" data-type="indexterm" id="idm45625612725976"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-startref="ix_JupNGATKld" data-tertiary="loading data files (BAM and VCF) into embedded IGV" data-type="indexterm" id="idm45625612724024"/><a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-startref="ix_IGVJNld" data-tertiary="loading BAM and VCF data into" data-type="indexterm" id="idm45625612722040"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Troubleshooting a Questionable Variant Call in the Embedded IGV Browser"><div class="sect2" id="troubleshooting_a_questionable_variant">
<h2>Troubleshooting a Questionable Variant Call in the Embedded <span class="keep-together">IGV Browser</span></h2>

<p>You might<a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-tertiary="troubleshooting questionable GATK variant call in" data-type="indexterm" id="ix_IGVJNtrbl"/> recall that in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a> we took a closer<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-tertiary="troubleshooting variant call in embedded IGV browser" data-type="indexterm" id="ix_JupNGATKtrbl"/> look at the homozygous<a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-tertiary="troubleshooting variant call in embedded IGV browser" data-type="indexterm" id="ix_GATKJNtrbl"/> variant insertion of three T bases that appears in the variant track in this region. At first glance, we were skeptical of <code>HaplotypeCaller</code>’s decision because the call didn’t seem to be supported by the sequencing data. Do you remember the first thing we did to investigate? That’s right, we turned on the display of soft clips, those bits of sequence data tagged as “unusable” by the mapper that are normally hidden by default. Let’s do that now in the IGV window in the notebook.</p>

<p>As you can see in <a data-type="xref" href="#menu_of_display_options_for_the_quotmot">Figure 12-15</a>, you can bring up track-viewing options by clicking on the gear icon to the right of the track of interest. Do that now for the Mother WGS sequence data track and select “Show soft clips;” then, in the upper-right corner of the menu, click the X to close it.</p>

<figure class="width-30 no-frame"><div id="menu_of_display_options_for_the_quotmot" class="figure"><img alt="Menu of display options for the &quot;Mother WGS&quot; sequence data track." src="Images/gitc_1215.png" width="430" height="866"/>
<h6><span class="label">Figure 12-15. </span>Menu of display options for the Mother WGS sequence data track.</h6>
</div></figure>

<p>You should see the entire area light up in the bright glare of multitudes of <span class="keep-together">mismatches</span>, as shown in <a data-type="xref" href="#display_of_soft_clipsdot">Figure 12-16</a>.</p>

<figure class="no-frame"><div id="display_of_soft_clipsdot" class="figure"><img alt="Display of soft-clips." src="Images/gitc_1216.png" width="1442" height="848"/>
<h6><span class="label">Figure 12-16. </span>Display of soft clips.</h6>
</div></figure>

<p>You know what to do now, right? Questionable indel call, tons of soft clips…Yes, it’s time to generate a bamout to see what <code>HaplotypeCaller</code> was thinking when it made that call:</p>

<pre data-type="programlisting">
In [38]  ! gatk HaplotypeCaller \
             -R {GERM_DATA}/ref/ref.fasta \
             -I {GERM_DATA}/bams/mother.bam \
             -O sandbox/motherHCdebug.vcf.gz \
             -bamout sandbox/motherHCdebug.bam \
             -L 20:10,002,000-10,003,000
</pre>

<p>That should run very quickly and produce the key output we’re interested in, which is the BAM file that shows how <code>HaplotypeCaller</code> has realigned the read data, as explained in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>. Let’s add that file to our IGV browser:</p>

<pre data-code-language="python" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="mi">39</code><code class="p">]</code>  <code class="n">IGV_InspectCalls</code><code class="o">.</code><code class="n">load_track</code><code class="p">(</code>
             <code class="p">{</code>
                <code class="s2">"name"</code><code class="p">:</code> <code class="s2">"Mother HC bamout"</code><code class="p">,</code>
                <code class="s2">"url"</code><code class="p">:</code> <code class="s2">"files/sandbox/motherHCdebug.bam"</code><code class="p">,</code>
                <code class="s2">"indexURL"</code><code class="p">:</code> <code class="s2">"files/sandbox/motherHCdebug.bai"</code><code class="p">,</code>
                <code class="s2">"height"</code><code class="p">:</code> <code class="mi">500</code><code class="p">,</code>
                <code class="s2">"format"</code><code class="p">:</code> <code class="s2">"bam"</code>
             <code class="p">})</code>
</pre>

<p>Again, this should produce a view that is equivalent, though not identical, to the one we encountered in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>. As previously, we can conclude that <code>HaplotypeCaller</code>’s call of an indel was reasonable, given the realigned data.</p>

<p>Incidentally, you might notice that in this one we specified the height of the track with <code>"height": 500</code>. This can be useful when we’re trying to showcase a specific view of the data in a way that minimizes scrolling, for example. Feel free to experiment with setting the height of different tracks.</p>

<p>What do you think of this approach to running and examining GATK commands? We could continue mirroring all of the material that we covered in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a> through <a data-type="xref" href="ch07.xhtml#gatk_best_practices_for_somatic_variant">Chapter 7</a> in this way, and in fact, there are several such GATK tutorial notebooks in public Terra workspaces, which the GATK team uses in its popular series of international workshops. We encourage you to check those out for further study.</p>

<p>However, for the purposes of this book, and this chapter in particular, we want to focus on covering the most useful aspects of Jupyter notebooks in relation to the types of interactions you would typically have with genomic data. We have a few more that we’re excited to show you, so we need to move on.</p>

<p>The next logical step is to plot variant data. There are many aspects of variant data that you might want to explore visually, but we can’t cover them all—in fact, we can really cover only one. So, let’s tackle the topic of visualizing how variant context <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-startref="ix_GATKJNtrbl" data-tertiary="troubleshooting variant call in embedded IGV browser" data-type="indexterm" id="idm45625612635720"/>annotation values are<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-startref="ix_JupNGATKtrbl" data-tertiary="troubleshooting variant call in embedded IGV browser" data-type="indexterm" id="idm45625612633592"/> distributed, which <a contenteditable="false" data-primary="IGV (Integrated Genome Viewer)" data-secondary="embedded window in Jupyter Notebook" data-startref="ix_IGVJNtrbl" data-tertiary="troubleshooting questionable GATK variant call in" data-type="indexterm" id="idm45625612631448"/>can be helpful for understanding variant <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="running commands in Jupyter Notebook" data-startref="ix_GATKJN" data-type="indexterm" id="idm45625612629304"/>filtering<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="running GATK commands to learn, test, or troubleshoot" data-startref="ix_JupNGATK" data-type="indexterm" id="idm45625612627496"/> methods, as we discussed in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Visualizing Variant Context Annotation Data"><div class="sect1" id="visualizing_variant_context_annotation">
<h1>Visualizing Variant Context Annotation Data</h1>

<p>You might<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-type="indexterm" id="ix_JupNvisVCA"/> recall that in <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a> we described <a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-type="indexterm" id="ix_VCAJN"/>using an annotation (<code>callsets</code>) derived from the GiaB truth set in order to understand how<a contenteditable="false" data-primary="Genome in a Bottle (GiaB) truth set" data-type="indexterm" id="idm45625612617816"/> the distributions of variant context annotations can inform us about the quality of our variant calls. We used a visual approach to making that assessment, which involved plotting variant context annotation values in a couple of ways (density plots and scatter plots). If that doesn’t ring a bell or if you’re feeling fuzzy on the details, please take a few minutes to read through that section again to refresh your memory. At the time, we focused on the concepts and outlined the procedure only in general terms, so here we’re going to take the opportunity to show you how to apply key steps to reproduce the plots shown in <a data-type="xref" href="ch05.xhtml#aright_parenthesis_density_plot_of_qual">Figure 5-8</a> through <a data-type="xref" href="ch05.xhtml#a_scatter_plot_with_marginal_densities">Figure 5-11</a>.</p>

<section data-type="sect2" data-pdf-bookmark="Exporting Annotations of Interest with VariantsToTable"><div class="sect2" id="exporting_annotations_of_interest_with">
<h2>Exporting Annotations of Interest with VariantsToTable</h2>

<p>We start<a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-tertiary="exporting annotations of interest with VariantsToTable tool" data-type="indexterm" id="ix_VCAJNexp"/> with the VCF of<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-tertiary="exporting annotations from GATK with VariantsToTable" data-type="indexterm" id="ix_JupNvisVCAexp"/> SNPs<a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="exporting variant context annotations to Jupyter Notebook with VariantsToTable" data-type="indexterm" id="ix_GATKexpVCA"/> called from the Mother WGS sample that we’ve previously annotated with information for the GiaB truth set. For a tutorial showing how to perform the full procedure, including subsetting and annotation steps, see this <a href="https://oreil.ly/WGncb">GATK tutorial workspace</a>.</p>

<p>The VCF file format is rather painful to work with directly, so for this exercise, we’re going to make life easier on ourselves and export the information we care about from the VCF file into a tab-delimited table, to make it easier to parse in R. To that end, we run the GATK tool <code>VariantsToTable</code> on the annotated input VCF file, providing it with the list of annotations we’re interested in. We use the <code>-F</code> argument for INFO (site-level) annotations and <code>-GF</code> for FORMAT (sample-level) annotations, where the <em>F</em> stands for field, and <em>GF</em> for genotype field, respectively:</p>

<pre data-type="programlisting">
In [40]  ! gatk VariantsToTable \
		 	-V {GERM_DATA}/vcfs/motherSNP.giab.vcf.gz \
		 	-F CHROM -F POS -F QUAL \
		 	-F BaseQRankSum -F MQRankSum -F ReadPosRankSum \
		 	-F DP -F FS -F MQ -F QD -F SOR \
		 	-F giab.callsets \
		 	-GF GQ \
		 	-O sandbox/motherSNP.giab.txt
</pre>

<p>The <code>VariantsToTable</code> command should run very quickly to produce the output file, <em>motherSNP.giab.txt</em>. This is a plain-text file, so we can view a snippet of it using <code>cat</code>:</p>

<pre data-type="programlisting">
In [41]  ! cat sandbox/motherSNP.giab.txt | head -n300
</pre>

<p>As you can see, the tool produced a table in which each line represents a variant record from the VCF, and each column represents an annotation that we specified in the export command. Wherever a requested annotation was not present (for example, homozygous sites do not have <code>RankSum</code> annotations, because that annotation can be calculated only for heterozygous sites), the value was replaced by <code>NA</code>. With this plain-text table in hand, we can easily load the full set of variant calls and their annotation values into an R DataFrame.</p>

<p>To load the table contents into an R DataFrame, we call the <code>readr</code> library and use its <code>read_delim</code> function to load the <em>motherSNP.giab.txt</em> table into the <code>motherSNP.giab</code> DataFrame object. Notice that the R command is preceded by the <code>%%R</code> symbol, which as we learned earlier instructs the notebook kernel that all of the code in this cell should be interpreted in R:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">42</code><code class="p">]</code>  <code class="o">%%</code><code class="n">R</code>
         <code class="nf">library</code><code class="p">(</code><code class="n">readr</code><code class="p">)</code>
         <code class="n">motherSNP.giab</code> <code class="o">&lt;-</code> <code class="nf">read_delim</code><code class="p">(</code><code class="s">"sandbox/motherSNP.giab.txt"</code><code class="p">,</code><code class="s">"\t"</code><code class="p">,</code> 
                       <code class="n">escape_double</code> <code class="o">=</code> <code class="kc">FALSE</code><code class="p">,</code> 
                       <code class="n">col_types</code> <code class="o">=</code> <code class="nf">cols</code><code class="p">(</code><code class="n">giab.callsets</code> <code class="o">=</code> <code class="nf">col_character</code><code class="p">()),</code> 
                       <code class="n">trim_ws</code> <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
</pre>

<p>When the DataFrame is ready, you can manipulate it using your favorite R functions. And, as it happens, we have some handy plotting functions all lined up for you.<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-startref="ix_JupNvisVCAexp" data-tertiary="exporting annotations from GATK with VariantsToTable" data-type="indexterm" id="idm45625612499192"/><a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="exporting variant context annotations to Jupyter Notebook with VariantsToTable" data-startref="ix_GATKexpVCA" data-type="indexterm" id="idm45625612529720"/><a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-startref="ix_VCAJNexp" data-tertiary="exporting annotations of interest with VariantsToTable tool" data-type="indexterm" id="idm45625612528040"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Loading R Script to Make Plotting Functions Available"><div class="sect2" id="loading_r_script_to_make_plotting_funct">
<h2>Loading R Script to Make Plotting Functions Available</h2>

<p>We’re going to take advantage of an <a contenteditable="false" data-primary="R language" data-secondary="loading R script into Jupyter Notebook to make plotting functions available" data-type="indexterm" id="idm45625612524152"/>existing R script provided by the GATK support team. <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-tertiary="loading R script with plotting functions" data-type="indexterm" id="idm45625612522680"/><a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-tertiary="loading R script with plotting functions" data-type="indexterm" id="idm45625612520904"/><a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="R script with plotting functions" data-type="indexterm" id="idm45625612519192"/>The script, which is available in the book repository and in the bucket, defines three <a contenteditable="false" data-primary="plotting functions using R library ggplot2" data-type="indexterm" id="idm45625612517656"/>plotting <a contenteditable="false" data-primary="ggplot2 R library" data-type="indexterm" id="idm45625612516392"/>functions that utilize a fantastic R library called <code>ggplot2</code> to visualize the distribution of variant annotation values.</p>

<p>To make these functions available in the notebook, we could simply copy the contents of the R script into a code cell and run it. However, because this is a script that we might want to run in multiple notebooks, and we don’t want to have to maintain separate copies, let’s use a smarter way to import the code. You’re going to copy the R script to the notebook’s local storage, and then<a contenteditable="false" data-primary="source function (R)" data-type="indexterm" id="idm45625612514008"/> use the <code>source()</code> function in R to load the R script code into the notebook:</p>

<pre data-type="programlisting">
In [43]  ! gsutil cp gs://genomics-in-the-cloud/v1/scripts/plotting.R .</pre>

<pre data-type="programlisting" data-code-language="r">
         %<code class="n">R</code> <code class="nf">source</code><code class="p">(</code><code class="s">"plotting.R"</code><code class="p">)</code> 
</pre>

<p>This outputs about a page’s worth of log, which we’re not showing here. The log output is displayed on a red background, which is a tad alarming, but don’t worry about it unless the next steps fail. If you do encounter issues, check whether your output is different from what is shown in the prerun copy of the notebook (which also contains solutions to the do-it-yourself exercises). If everything works as it should, you’ll now have a few new R packages installed and loaded, and the plotting functions will be available.</p>

<p>Let’s try that out, shall we? First up, the density plot.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Making Density Plots for QUAL by Using makeDensityPlot"><div class="sect2" id="making_density_plots_for_qual_by_using">
<h2>Making Density Plots for QUAL by Using makeDensityPlot</h2>

<p>The <code>makeDensityPlot</code> function<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-tertiary="making density plots for QUAL with makeDensityPlot" data-type="indexterm" id="ix_JupNvisVCADP"/> takes a <a contenteditable="false" data-primary="makeDensityPlot function" data-type="indexterm" id="idm45625612500968"/>DataFrame <a contenteditable="false" data-primary="density plots" data-secondary="creating for QUAL annotations" data-type="indexterm" id="ix_DPQUAL"/>and an <a contenteditable="false" data-primary="QUAL annotations" data-secondary="density plots for, creating in Jupyter Notebook" data-type="indexterm" id="ix_QUAdp"/>annotation of interest to generate a density plot, which is basically a smoothed version of the histogram, representing the distribution of values for that annotation. Here’s how we can use it to reproduce Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.xhtml#aright_parenthesis_density_plot_of_qual">5-8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.xhtml#density_plot_of_qual_aright_parenthesis">5-9</a>. In each of the following cells, the first line creates the plot and then the second line calling its name displays it:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">44</code><code class="p">]</code>  <code class="o">%%</code><code class="n">R</code>
         <code class="n">QUAL_density</code> <code class="o">=</code> <code class="nf">makeDensityPlot</code><code class="p">(</code><code class="n">motherSNP.giab</code><code class="p">,</code> <code class="s">"QUAL"</code><code class="p">)</code>
         <code class="n">QUAL_density</code>
</pre>

<p>The QUAL distribution shown in <a data-type="xref" href="#qual_distributiondot">Figure 12-17</a> has a very long tail on the right, so let’s zoom in by restricting the x-axis to a reasonable maximum value by using the optional <code>xmax</code> argument, with the result presented in <a data-type="xref" href="#qual_density_plotdot">Figure 12-18</a>:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">45</code><code class="p">]</code>  <code class="o">%%</code><code class="n">R</code>
         <code class="n">QUAL_density_zoom</code> <code class="o">=</code> <code class="nf">makeDensityPlot</code><code class="p">(</code><code class="n">motherSNP.giab</code><code class="p">,</code> <code class="s">"QUAL"</code><code class="p">,</code> <code class="n">xmax</code><code class="o">=</code><code class="m">10000</code><code class="p">)</code>
         <code class="n">QUAL_density_zoom</code>
</pre>

<figure><div id="qual_distributiondot" class="figure"><img alt="QUAL distribution." src="Images/gitc_1217.png" width="480" height="480"/>
<h6><span class="label">Figure 12-17. </span>QUAL distribution.</h6>
</div></figure>

<figure><div id="qual_density_plotdot" class="figure"><img alt="QUAL density plot." src="Images/gitc_1218.png" width="480" height="480"/>
<h6><span class="label">Figure 12-18. </span>QUAL density plot.</h6>
</div></figure>

<p>We can also specify an annotation to use for organizing the data into subsets and have the function generate a separate density curve for each subset of data. Here, we use the <code>giab.callsets</code> annotation, which refers to the number of callsets in the GiaB truth set called the same variant. The higher the number, the more we can trust the variant call:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">46</code><code class="p">]</code>  <code class="o">%%</code><code class="n">R</code>
         <code class="n">QUAL_density_split</code> <code class="o">=</code> <code class="nf">makeDensityPlot</code><code class="p">(</code><code class="n">motherSNP.giab</code><code class="p">,</code> <code class="s">"QUAL"</code><code class="p">,</code> <code class="n">xmax</code><code class="o">=</code><code class="m">10000</code><code class="p">,</code>
         <code class="n">split</code><code class="o">=</code><code class="s">"giab.callsets"</code><code class="p">)</code>
         <code class="n">QUAL_density_split</code>
</pre>

<p><a data-type="xref" href="#qual_density_plots_by_callsets_from_gia">Figure 12-19</a> shows the result.</p>

<figure><div id="qual_density_plots_by_callsets_from_gia" class="figure"><img alt="QUAL density plots by callsets from GiaB." src="Images/gitc_1219.png" width="480" height="480"/>
<h6><span class="label">Figure 12-19. </span>QUAL density plots by callsets from GiaB.</h6>
</div></figure>

<p>After you have that working, try generating the same kind of plots for other annotations. As an example, we used similar commands to generate <a data-type="xref" href="ch05.xhtml#density_plot_of_qd_aright_parenthesis_a">Figure 5-10</a> for the <code>QualByDepth</code> (QD) annotation.</p>

<p>Now let’s try <a contenteditable="false" data-primary="QUAL annotations" data-secondary="density plots for, creating in Jupyter Notebook" data-startref="ix_QUAdp" data-type="indexterm" id="idm45625612321720"/>making scatter plots. <a contenteditable="false" data-primary="density plots" data-secondary="creating for QUAL annotations" data-startref="ix_DPQUAL" data-type="indexterm" id="idm45625612319816"/>Everyone <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-startref="ix_JupNvisVCADP" data-tertiary="making density plots for QUAL with makeDensityPlot" data-type="indexterm" id="idm45625612318040"/>loves a good scatter plot, right?</p>
</div></section>

<section class="pagebreak-before" data-type="sect2" data-pdf-bookmark="Making a Scatter Plot of QUAL Versus DP"><div class="sect2" id="making_a_scatter_plot_of_qual_versus_dp">
<h2 class="less_space">Making a Scatter Plot of QUAL Versus DP</h2>

<p>The <code>makeScatterPlot</code> function <a contenteditable="false" data-primary="makeScatterPlot function" data-type="indexterm" id="idm45625612312936"/>takes <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-tertiary="making scatter plot of QUAL vs. DP" data-type="indexterm" id="ix_JupNvisVCAscp"/>a DataFrame <a contenteditable="false" data-primary="scatter plots" data-secondary="making scatter plot of QUAL vs. DP annotations in Jupyter Notebook" data-type="indexterm" id="ix_scatplQDP"/><a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-tertiary="making scatter plot of QUAL versus DP" data-type="indexterm" id="ix_VCAJNscpl"/>and<a contenteditable="false" data-primary="DP (depth of coverage) annotations" data-secondary="making scatter plot of QUAL versus DP" data-type="indexterm" id="ix_DPvQUAL"/> two <a contenteditable="false" data-primary="QUAL annotations" data-secondary="making scatter plot of QUAL versus DP in Jupyter Notebook" data-type="indexterm" id="ix_QUALvDP"/>annotations of interest to generate a 2D scatter plot of the two annotations in which each data point is an individual variant call. Here’s how we can use it to reproduce <a data-type="xref" href="ch05.xhtml#aright_parenthesis_density_plot_of_qual">Figure 5-8</a> from <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>, with <a data-type="xref" href="#scatter_plot_qual_versus_dpdot">Figure 12-20</a> displaying the result:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">47</code><code class="p">]</code>  <code class="o">%%</code><code class="n">R</code>
         <code class="n">QUAL_DP_scatterplot</code> <code class="o">=</code> <code class="nf">makeScatterPlot</code><code class="p">(</code><code class="n">motherSNP.giab</code><code class="p">,</code> <code class="s">"QUAL"</code><code class="p">,</code> <code class="s">"DP"</code><code class="p">)</code>
         <code class="n">QUAL_DP_scatterplot</code>
</pre>

<figure><div id="scatter_plot_qual_versus_dpdot" class="figure"><img alt="Scatter plot QUAL versus DP." src="Images/gitc_1220.png" width="480" height="480"/>
<h6><span class="label">Figure 12-20. </span>Scatter plot QUAL versus DP.</h6>
</div></figure>

<p>This function accepts the same <code>xmax</code> argument as <code>makeDensityPlot</code> for limiting the range of values on the x-axis, and a new <code>ymax</code> argument to limit values on the y-axis. Feel free to experiment with these arguments to zoom in on subsets of data.</p>

<p>You can also use the same <code>split</code> argument for splitting the data into subsets, with the effect of coloring the points based on the subset they belong to. Try doing that now based on what you learned in the previous exercise and then try applying the same principles to plot other annotations.</p>

<p>Finally, in our last plotting exercise, we’re going to combine both the scatter and the density plotting.<a contenteditable="false" data-primary="scatter plots" data-secondary="making scatter plot of QUAL vs. DP annotations in Jupyter Notebook" data-startref="ix_scatplQDP" data-type="indexterm" id="idm45625612258872"/><a contenteditable="false" data-primary="DP (depth of coverage) annotations" data-secondary="making scatter plot of QUAL vs. DP" data-startref="ix_DPvQUAL" data-type="indexterm" id="idm45625612253896"/><a contenteditable="false" data-primary="QUAL annotations" data-secondary="making scatter plot of QUAL vs. DP in Jupyter Notebook" data-startref="ix_QUALvDP" data-type="indexterm" id="idm45625612252168"/><a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-startref="ix_JupNvisVCAscp" data-tertiary="making scatter plot of QUAL vs. DP" data-type="indexterm" id="idm45625612250488"/><a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-startref="ix_VCAJNscpl" data-tertiary="making scatter plot of QUAL vs. DP" data-type="indexterm" id="idm45625612248520"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Making a Scatter Plot Flanked by Marginal Density Plots"><div class="sect2" id="making_a_scatter_plot_flanked_by_margin">
<h2>Making a Scatter Plot Flanked by Marginal Density Plots</h2>

<p>The <code>makeScatterPlotWithMarginalDensity</code> function<a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-tertiary="making scatter plot flanked by marginal density plots" data-type="indexterm" id="ix_JupNvisVCAscplMDA"/> takes <a contenteditable="false" data-primary="scatter plots" data-secondary="making scatter plot flanked by marginal density plots in Jupyter Notebook" data-type="indexterm" id="ix_scatplMDP"/>a DataFrame and two annotations, combining the other two<a contenteditable="false" data-primary="density plots" data-secondary="making scatter plot flanked by marginal density plots" data-type="indexterm" id="ix_deplMDP"/> functions <a contenteditable="false" data-primary="marginal density plots" data-startref="ix_MDPl" data-type="indexterm" id="idm45625612212472"/>to <a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-tertiary="making scatter plot flanked by marginal density plots" data-type="indexterm" id="ix_VCAJNscplMDP"/>generate a scatter plot flanked horizontally and vertically by the annotations’ respective density plots. Here’s how we can use it to reproduce <a data-type="xref" href="ch05.xhtml#a_scatter_plot_with_marginal_densities">Figure 5-11</a> from <a data-type="xref" href="ch05.xhtml#first_steps_with_gatk">Chapter 5</a>, with the result shown in <a data-type="xref" href="#a_scatter_plot_along_with_density_plots">Figure 12-21</a>:</p>

<pre data-code-language="r" data-type="programlisting">
<code class="n">In</code> <code class="p">[</code><code class="m">48</code><code class="p">]</code>  <code class="o">%%</code><code class="n">R</code>
         <code class="n">QUAL_DP_comboplot</code> <code class="o">=</code> <code class="nf">makeScatterPlotWithMarginalDensity</code><code class="p">(</code><code class="n">motherSNP.giab</code><code class="p">,</code>
         <code class="s">"QUAL"</code><code class="p">,</code>
         <code class="s">"DP"</code><code class="p">,</code> <code class="n">split</code><code class="o">=</code><code class="s">"giab.callsets"</code><code class="p">,</code> <code class="n">xmax</code><code class="o">=</code><code class="m">10000</code><code class="p">,</code> <code class="n">ymax</code><code class="o">=</code><code class="m">100</code><code class="p">,</code> <code class="n">ptSize</code><code class="o">=</code><code class="m">0.5</code><code class="p">,</code> 
         <code class="n">ptAlpha</code><code class="o">=</code><code class="m">0.05</code><code class="p">)</code>
         <code class="n">QUAL_DP_comboplot</code>
</pre>

<figure><div id="a_scatter_plot_along_with_density_plots" class="figure"><img alt="A scatter plot along with density plots." src="Images/gitc_1221.png" width="480" height="480"/>
<h6><span class="label">Figure 12-21. </span>A scatter plot along with density plots.</h6>
</div></figure>

<p>As previously, we specify <code>giab.callsets</code> as the variable to use for splitting the variant data points into groups according to how much we trust them. We also set optional parameters (<code>xmax</code> and <code>ymax</code>) to limit the axes to display a subset of values, and we tweak the display of the data to optimize readability (<code>ptSize</code> and <code>ptAlpha</code>).</p>

<p>Go ahead and try applying this to other pairs of annotations. Note that some annotations can have negative values, so be aware that the plotting functions also accept <code>xmin</code> and <code>ymin</code> arguments to limit the range of negative values to display.</p>

<p>To be clear, there are a lot of other ways to manipulate and plot variant data from within a notebook. In fact, this particular method would not scale well for larger datasets, because it involves reading a potentially very large table directly into memory. We chose it for this tutorial because it has the advantage of being approachable for newcomers, and our primary goal was to give you a sense of the possibilities and familiarize you with the basic mechanics involved. However, for full-scale work, you’ll probably want to use more robust methods. We recommend<a contenteditable="false" data-primary="Hail toolkit" data-type="indexterm" id="idm45625612150312"/> checking out <a href="https://hail.is">Hail</a>, a Python-based, genetics-focused toolkit that is extraordinarily scalable and includes a suite of variant quality control functions, among other capabilities. Like some of the more recent GATK tools, Hail is capable of using Spark to parallelize analysis, and <a contenteditable="false" data-primary="genome-wide analysis studies (GWAS)" data-type="indexterm" id="idm45625612148088"/>has been used to perform genome-wide analysis studies (GWAS) on massive datasets like the <a href="https://oreil.ly/mes1R">UK Biobank</a>. The Terra <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-startref="ix_JupNvisVCAscplMDA" data-tertiary="making scatter plot flanked by marginal density plots" data-type="indexterm" id="idm45625612146088"/>Library<a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-startref="ix_VCAJNscplMDP" data-tertiary="making scatter plot flanked by marginal density plots" data-type="indexterm" id="idm45625612143880"/> has a<a contenteditable="false" data-primary="scatter plots" data-secondary="making scatter plot flanked by marginal density plots in Jupyter Notebook" data-startref="ix_scatplMDP" data-type="indexterm" id="idm45625612141736"/> few <a contenteditable="false" data-primary="marginal density plots" data-startref="ix_MDPl" data-type="indexterm" id="idm45625612139960"/>workspaces <a contenteditable="false" data-primary="density plots" data-secondary="making scatter plot flanked by marginal density plots" data-startref="ix_deplMDP" data-type="indexterm" id="idm45625612138424"/>that feature Hail, including a <a href="https://oreil.ly/-h7Zj">set of tutorial notebooks</a> and a <a href="https://oreil.ly/Q-LJD">complete GWAS example</a>.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Wrap-Up and Next Steps"><div class="sect1" id="wrap_up_and_next_steps-id00009">
<h1>Wrap-Up and Next Steps</h1>

<p>In this chapter, you<a contenteditable="false" data-primary="variant context annotations" data-secondary="visualizing data in Jupyter Notebook" data-startref="ix_VCAJN" data-type="indexterm" id="idm45625612133976"/> learned <a contenteditable="false" data-primary="Jupyter Notebook" data-secondary="visualizing variant context annotation data" data-startref="ix_JupNvisVCA" data-type="indexterm" id="idm45625612132136"/>how to use Jupyter in Terra to interact with your data. You began by learning the basic mechanics of using notebooks on the cloud, setting up your computing environment, opening an example notebook, and running code cells. With those foundations in place, you worked through three types of interactive analysis: visualizing genomic data in an embedded IGV browser, running and troubleshooting GATK commands, and plotting variant context annotation data in R.</p>

<p>This was by no means an exhaustive catalog of what you can do in this environment; if anything, we barely scratched the surface of what is possible. However, you now have enough grounding in the technology and tooling to start adapting your own analyses to work within the Terra framework. In <a data-type="xref" href="ch13.xhtml#assembling_your_own_workspace_in_terra">Chapter 13</a>, we show you how to assemble your own workspaces from component elements: data, tools, and code from various origins.<a contenteditable="false" data-primary="interactive analysis in Jupyter Notebook" data-startref="ix_intan" data-type="indexterm" id="idm45625612103096"/><a contenteditable="false" data-primary="Jupyter Notebook" data-startref="ix_JupN" data-type="indexterm" id="idm45625612101784"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45625613561112"><sup><a href="ch12.xhtml#idm45625613561112-marker">1</a></sup> From this point on, we don’t show the output of the cells. You can check your outputs against the copy of the notebook included in the Terra workspace. We also provide an html version of the pre-run notebook in the book’s <a href="https://oreil.ly/genomics-repo">Github repository</a>.</p></div></div></section></div>



  </body></html>