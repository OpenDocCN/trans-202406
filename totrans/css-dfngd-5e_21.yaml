- en: Chapter 21\. CSS At-Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For 20 chapters now, we’ve explored the properties, values, and selectors that
    can be combined to create CSS rules. These are what we might call *normal rules*
    or *regular rules*, and they’re powerful, but sometimes more is needed. Sometimes
    there needs to be a way to encapsulate certain styles in conditional blocks, such
    that styles can be applied at certain page widths or only if a given CSS feature
    is recognized by the browser processing the stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: These are almost invariably enclosed in *at-rules*, so called because they start
    with an at (`@`) symbol. You’ve seen some of these in previous chapters, such
    as `@font-face` and `@counter-style`, but there are still more that aren’t so
    tightly bound to specifics of styling. This chapter explores the three powerful
    at-rules `@media`, `@container`, and `@supports`.
  prefs: []
  type: TYPE_NORMAL
- en: Media Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the mechanisms defined in HTML and CSS called *media queries*, you
    can restrict any set of styles (including entire stylesheets) to a specific medium,
    such as screen or print, and to a specific set of media conditions. These mechanisms
    allow you to define a combination of media types and conditions such as display
    size or color depth, to pick two examples. We’ll cover the basic form before exploring
    the more complex forms.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Media Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For HTML-based stylesheets, you can impose medium restrictions through the
    `media` attribute. This works the same for both the `<link>` and `<style>` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `media` attribute can accept a single medium value or a comma-separated
    list of values. Thus, to link in a stylesheet that should be used in only the
    `screen` and `print` media, you would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In a stylesheet itself, you can also impose medium restrictions on `@import`
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that if you don’t add medium information to a stylesheet, it will
    be applied in *all* media. Therefore, if you want one set of styles to apply only
    onscreen, and another to apply only in print, you need to add medium information
    to both stylesheets. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you were to remove the `media` attribute from the first `<link>` element
    in this example, the rules found in the stylesheet *article-screen.css* would
    be applied in *all* media.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS also defines syntax for `@media` blocks. This allows you to define styles
    for multiple media within the same stylesheet. Consider this basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that in all media, the `<body>` element is given a white background
    and a black foreground by the first rule. This happens because its stylesheet,
    the one defined by the `style` attribute, has no `media` attribute and thus defaults
    to `all`. Next, a block of rules is provided for the `screen` medium alone, followed
    by another block of rules that applies only in the `print` medium.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The indentation shown in these blocks is solely for purposes of clarity. You
    don’t have to indent the rules found inside an `@media` block, but you’re welcome
    to do so if it makes your CSS easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: The `@media` blocks can be any size, containing any number of rules. When authors
    have control over a single stylesheet, such as in a shared hosting environment
    or a CMS that restricts what users can edit, `@media` blocks may be the only way
    to define medium-specific styles. This is also the case when CSS is used to style
    a document using an XML language that does not contain a `media` attribute or
    its equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the three most widely recognized media types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`all`'
  prefs: []
  type: TYPE_NORMAL
- en: Use in all presentational media.
  prefs: []
  type: TYPE_NORMAL
- en: '`print`'
  prefs: []
  type: TYPE_NORMAL
- en: Use when printing the document for sighted users, and also when displaying a
    print preview of the document.
  prefs: []
  type: TYPE_NORMAL
- en: '`screen`'
  prefs: []
  type: TYPE_NORMAL
- en: Use when presenting the document in a screen medium like a desktop computer
    monitor or a handheld device. All web browsers running on such systems are screen-medium
    user agents.
  prefs: []
  type: TYPE_NORMAL
- en: It’s entirely possible that new media types will be added over time, so remember
    that this limited list may not always be so limited. It’s fairly easy to imagine
    `augmented-reality` as a media type, for example, since text in AR displays would
    likely need to be of higher contrast in order to stand out against the background
    reality.
  prefs: []
  type: TYPE_NORMAL
- en: HTML4 defined a list of media types that CSS originally recognized, but most
    have been deprecated and should be avoided. These are `aural`, `braille`, `embossed`,
    `handheld`, `projection`, `speech`, `tty`, and `tv`. If you have old stylesheets
    that use these media types, they should almost certainly be converted to one of
    the three recognized media types, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of 2022, a couple of browsers still support `projection`, which allows a
    document to be presented as a slideshow. Several mobile-device browsers also support
    the `handheld` type, but not in consistent ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible in some circumstances to combine media types into comma-separated
    lists, though the rationale for doing so isn’t terribly compelling, given the
    small number of media types currently available. For example, styles could be
    restricted to only screen and print media in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Complex Media Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you saw how multiple media types could be chained
    together with a comma. We might call that a *compound media query*, because it
    allows us to address multiple media at once. There is a great deal more to media
    queries, though: it’s possible to apply styles based not just media types, but
    also features of those media, such as display size or color depth.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a great deal of power, and it’s not enough to rely on commas to make
    it all happen. Thus, CSS includes the logical operator `and` to pair media types
    with features of those media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this plays out in practice. Here are two essentially equivalent
    ways of applying an external stylesheet when rendering the document on a color
    printer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Anywhere a media type can be given, a media query can be constructed. This
    means that, following on the examples of the previous section, it is possible
    to list more than one query in a comma-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If even one of the media queries evaluates to `true`, the associated stylesheet
    is applied. Thus, given the previous `@import`, *print-color.css* will be applied
    if rendering to a color printer *or* to a color screen environment. If printing
    on a black-and-white printer, both queries will evaluate to `false` and *print-color.css*
    will not be applied to the document. The same holds true in a grayscale screen
    environment, any speech media environment, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each media descriptor is composed of a media type and one or more listed media
    features, with each media feature descriptor enclosed in parentheses. If no media
    type is provided, it is assumed to be `all`, which makes the following two examples
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally speaking, a media feature descriptor is formatted like a property-value
    pair in CSS, only enclosed by parentheses. A few differences exist, most notably
    that some features can be specified without an accompanying value. For example,
    any color-based medium will be matched using `(color)`, whereas any color medium
    using a 16-bit color depth is matched using `(color: 16)`. In effect, the use
    of a descriptor without a value is a true/false test for that descriptor: `(color)`
    means “is this medium in color?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple feature descriptors can be linked with the `and` logical keyword.
    In fact, there are two logical keywords in media queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '`and`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Links together two or more media features in such a way that all of them must
    be true for the query to be true. For example, `(color) and (orientation: landscape)
    and (min-device-width: 800px)` means that all three conditions must be satisfied:
    if the media environment has color, is in landscape orientation, *and* the device’s
    display is at least 800 pixels wide, then the stylesheet is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '`not`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Negates the entire query so that if all of the conditions are true, the stylesheet
    is not applied. For example, `not (color) and (orientation: landscape) and (min-device-width:
    800px)` means that if the three conditions are satisfied, the statement is negated.
    Thus, if the media environment has color, is in landscape orientation, and the
    device’s display is at least 800 pixels wide, then the stylesheet is *not* used.
    In all other cases, it will be used.'
  prefs: []
  type: TYPE_NORMAL
- en: CSS has no `or` logical keyword, as its role is served by the comma, as shown
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `not` keyword can be used only at the beginning of a media query.
    It is not presently legal to write something like `(color) and not (min-device-width:
    800px)`. In such cases, the entire query block will be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example of how all this plays out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 21-1](#mediaqueries-logical-operators) shows the result, but bear in
    mind that, even though you may be reading this on printed paper, the actual image
    was generated with a screen-medium browser (Firefox Nightly, as it happens) displaying
    an HTML document with the previous CSS applied to it. So everything you see in
    [Figure 21-1](#mediaqueries-logical-operators) was operating under a `screen`
    medium.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2101](assets/css5_2101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-1\. Logical operators in media queries
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first line is italicized because the screen on which the file was displayed
    had a resolution equal to or greater than 72 dots per inch. Its resolution was
    not, however, `32767dpi` or higher, so the second media block is skipped and thus
    the second line stays un-italicized. The third line is italicized because, being
    a screen display, it was `not print`. The last line is italicized because it was
    either not print or not monochrome—in this case, not monochrome.
  prefs: []
  type: TYPE_NORMAL
- en: Another keyword, `only`, was designed to create deliberate backward incompatibility.
    Yes, really.
  prefs: []
  type: TYPE_NORMAL
- en: '`only`'
  prefs: []
  type: TYPE_NORMAL
- en: Used to hide a stylesheet from browsers old enough that they understand media
    queries but not media types. (This is almost never a problem in modern usage,
    but the capability was created and so we document it here.) In browsers that *do*
    understand media types, the `only` keyword is ignored and the stylesheet is applied.
    In browsers that do not understand media types, the `only` keyword creates an
    apparent media type of `only all`, which is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: Special Value Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two value types were introduced by media queries. These types are used in conjunction
    with specific media features, which are explained later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <*`ratio`*>
  prefs: []
  type: TYPE_NORMAL
- en: Two numbers separated by a forward slash (`/`), defined in [Chapter 5](ch05.html#values_and_units).
  prefs: []
  type: TYPE_NORMAL
- en: <*`resolution`*>
  prefs: []
  type: TYPE_NORMAL
- en: A resolution value is a positive <*`integer`*> followed by either of the unit
    identifiers `dpi` or `dpcm`. In CSS terms, a *dot* is any display unit, the most
    familiar of which is the pixel. As usual, whitespace is not permitted between
    the <*`integer`*> and the identifier. Therefore, a display that has exactly 150
    pixels (dots) per inch is matched with `150dpi`.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Media Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far you’ve seen several media features in the examples, but not a complete
    list of the possible features and their values. Let’s fix that now!
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that none of the following values can be negative, and that media features
    are always enclosed in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `any-hover`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `hover`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks for any available input mechanism that can hover over elements (i.e.,
    trigger a `:hover` state). The `none` value means there are no such mechanisms,
    or no mechanisms that can do so conveniently. Compare with the `hover` media feature,
    which restricts checking to the primary input mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `any-pointer`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `coarse` | `fine`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks for an input mechanism that creates an onscreen pointer. The `none` values
    indicates no such devices, `coarse` indicates at least one device with limited
    accuracy (e.g., a finger), and `fine` indicates at least one device with high
    accuracy (e.g., a mouse). Compare with `pointer`, which restricts checking to
    the primary input mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `color-gamut`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `srgb` | `p3` | `rec2020`'
  prefs: []
  type: TYPE_NORMAL
- en: Tests the range of colors supported by both the browser and the output device.
    As of late 2022, the majority of displays support the `srgb` and `p3` gamuts.
    The `p3` value refers to the Display P3 color space, which is a superset of sRGB.
    The `rec2020` value refers to the gamut specified by the ITU-R Recommendation
    BT.2020 Color Space, which is a superset of P3\. The `color-gamut` media feature
    is not supported by Firefox as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `display-mode`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `fullscreen` | `standalone` | `minimal-ui` | `browser`'
  prefs: []
  type: TYPE_NORMAL
- en: Tests the display mode of the top-level browsing context and any child browsing
    contexts. This corresponds to the Web Application Manifest specification’s `display`
    member, and is commonly used to check if a progressive web application visitor
    is browsing a website or on an installed application, but applies whether or not
    a manifest has been defined. See [“Forced Colors, Contrast, and Display Mode”](#forced_colors_contrast_and_display_mode)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `dynamic-range`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `standard` | `high`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the browsing context supports a high dynamic range for visual
    output. The `high` value means the media environment supports high peak brightness,
    a high contrast ratio, and a 24-bit color depth or higher. There are no precisely
    defined values for high peak brightness or color contrast, so this is left to
    browsers to decide. Any device that matches `high` will also match `standard`.
    The `dynamic-range` media feature achieved widespread browser support in early
    2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `forced-colors`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `active`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the browser is in *forced-color* mode, which forces browser-default
    values for a set of CSS properties such as `color` and `background-color`, and
    specific values for a handful of others, and may also trigger a `prefers-color-scheme`
    value. See [“Forced Colors, Contrast, and Display Mode”](#forced_colors_contrast_and_display_mode)
    for details. The `forced-colors` media feature is not supported by WebKit as of
    late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `grid`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `0` | `1`'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to the presence (or absence) of a grid-based output device, such as a
    TTY terminal. This does *not* refer to CSS Grid. A grid-based device will return
    `1`; otherwise, `0` is returned. This media feature can be used in place of the
    old `tty` media descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `hover`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `hover`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the user’s *primary* input mechanism can hover over elements.
    The `none` value means the primary mechanism cannot hover, or cannot do so conveniently;
    an example of the latter is a mobile device that pretends to hover when an inconvenient
    tap-and-hold action is performed. The `hover` value means hovering is convenient,
    such as with a mouse. Compare to `any-hover`, which checks whether any mechanism
    permits hovering, not just the primary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `inverted-colors`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `inverted`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether colors are being inverted by the underlying operating system.
    The `none` value means colors are being displayed normally; `inverted` means that
    all pixels in the display area are being inverted. The `inverted-colors` media
    feature is supported only in WebKit as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `orientation`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `portrait` | `landscape`'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to the orientation of the user agent’s display area, where `portrait`
    is returned if the media feature `height` is equal to or greater than the media
    feature `width`. Otherwise, the result is `landscape`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `overflow-block`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `scroll` | `optional-paged` | `paged`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks how the output device handles content that overflows along the block
    axis. The `none` value means the overflowed content cannot be accessed; `scroll`
    means the content can be accessed by scrolling to it in some way; `optional-paged`
    means the user can scroll to the content, but page breaks can be manually triggered
    using properties like `break-inside`; `paged` means overflowing content can be
    accessed only by “paging” to see the content, as in an ebook. The `overflow-block`
    media feature is supported only in Firefox as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `overflow-inline`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `scroll`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks to see how the output device handles content that overflows along the
    inline axis. The `none` value means the overflowed content cannot be accessed;
    `scroll` means the content can be accessed by scrolling to it in some way. The
    `overflow-inline` media feature is supported only in Firefox as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `pointer`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `coarse` | `fine`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the *primary* input mechanism creates an onscreen pointer. The
    `none` value means the primary input device generates no pointer, `coarse` means
    it does but with limited accuracy, and `fine` means it does with high accuracy
    (e.g., a mouse). Compare to `any-pointer`, which checks whether any mechanism
    creates a pointer, not just the primary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `prefers-color-scheme`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `light` | `dark`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checks which color scheme the user has selected at the browser or operating
    system level (i.e., Light mode or Dark mode). Thus, the author can define specific
    color values for, say, `prefers-color-scheme: dark`. Safari adds a `no-preference`
    value, but this has not been standardized or adopted by other browsers as of late
    2022.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `prefers-contrast`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `no-preference` | `less` | `more` | `custom`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the user has set a preference for high-contrast output, at either
    the browser or operating system level (e.g., Windows High Contrast mode). See
    [“Forced Colors, Contrast, and Display Mode”](#forced_colors_contrast_and_display_mode)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `prefers-reduced-motion`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `no-preference` | `reduce`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checks whether the user has set a preference regarding motion, at either the
    browser or operating system level. The `reduce` value means the user has indicated
    they wish motion to be reduced or eliminated, possibly because of vestibular disorders
    that create discomfort when viewing motion onscreen. Transitions and animations
    should most often be put into a `prefers-reduced-motion: reduce` block for accessibility
    reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `scan`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `progressive` | `interlace`'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to the scanning process used in an output device. The `interlace` value
    is the type generally used in CRT and some plasma displays. As of late 2022, all
    known implementations match the `progressive` value, making this media feature
    somewhat useless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `scripting`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `initial-only` | `enabled`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether a scripting language such as JavaScript is available. The `initial-only`
    value means scripting can be performed only at page load, but not thereafter.
    The `scripting` media feature is not supported by any browser as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `update`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `none` | `slow` | `fast`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the content’s appearance can be changed after page load. The
    `none` value means no updates are possible, such as in print media. The `slow`
    value means changes are possible but cannot be animated smoothly because of device
    or browser constraints. The `fast` value means smooth animations are possible.
    The `update` media feature is supported only by Firefox as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media feature: `video-dynamic-range`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: `standard` | `high`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the browsing context supports a high dynamic range for visual
    output on videos. This is useful because some devices render video separately
    from other graphics, and so may support a different dynamic range for video than
    for other content. The `high` value means the media environment supports high
    peak brightness, a high contrast ratio, and a 24-bit color depth or higher. There
    are no precisely defined values for high peak brightness or color contrast, so
    this is left to browsers to decide. Any device that matches `high` will also match
    `standard`. The `video-dynamic-range` media feature achieved widespread browser
    support in early 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Forced Colors, Contrast, and Display Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Three of the previously defined media features relate to user preference in
    their display, and allow you to detect those preferences so you may style accordingly.
    Two are closely intertwined, so we’ll start with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a user has gone to the effort of defining a specific set of colors to be
    used in the display of their content, such as with Windows High Contrast mode,
    then `forced-colors: active` will be matched, as will `prefers-contrast: custom`.
    You can use one or both of these queries to apply specific styles under such conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `forced-colors: active` returns true, the following CSS properties will
    be forced to use the browser (or operating system) default values, overriding
    any values you may have declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background-color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`border-color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column-rule-color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outline-color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-decoration-color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-emphasis-color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-webkit-tap-highlight-color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the SVG `fill` and `stroke` attributes will be ignored and set to their
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the following property-value combinations are enforced over whatever
    the author has declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '`box-shadow: none`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-shadow: none`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`background-image: none` for values that are not URL-based (e.g., gradients)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color-scheme: light dark`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scrollbar-color: auto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that, to pick one example, any element whose hover or focus styles
    depend on changing the color of a border will fail to have an effect. Thus, you
    could provide a change of font weight and border style (not color) instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of the sorts of changes you should make to accommodate forced-color
    situations, providing greater usability through small changes. You *should not*
    use this query to set up an entire separate design for users who have forced certain
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted previously, if a user has set things up such that `forced-colors:
    active` is triggered, `prefers-contrast: custom` will also be triggered. The meanings
    of this media feature’s values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`no-preference`'
  prefs: []
  type: TYPE_NORMAL
- en: The browser and/or operating system are not aware of a user preference with
    regards to color contrast.
  prefs: []
  type: TYPE_NORMAL
- en: '`less`'
  prefs: []
  type: TYPE_NORMAL
- en: The user has requested interfaces with less contrast than usual. Examples of
    this could be users with a propensity for migraine headaches or dyslexia, as some
    (not all) dyslexics find high-contrast text difficult to parse.
  prefs: []
  type: TYPE_NORMAL
- en: '`more`'
  prefs: []
  type: TYPE_NORMAL
- en: The user has requested interfaces with more contrast than usual.
  prefs: []
  type: TYPE_NORMAL
- en: '`custom`'
  prefs: []
  type: TYPE_NORMAL
- en: The user has defined a specific set of colors that are not matched by either
    `more` or `less`, such as the Windows High Contrast mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to query for any value by not supplying a value, which is especially
    useful in this scenario. You might cater to both low- and high-contrast users
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `display-mode` media feature is entirely different from the previous two
    features. The `display-mode` media feature lets authors determine the kind of
    display environment being used and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s define what the various values mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fullscreen`'
  prefs: []
  type: TYPE_NORMAL
- en: The application takes up the entire available display area and does not show
    any application chrome (e.g., address bar, back button, status bar, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: '`standalone`'
  prefs: []
  type: TYPE_NORMAL
- en: The application appears like a native standalone application. This removes application
    chrome such as address bar, but will make operating-system-derived navigation
    elements like back buttons available.
  prefs: []
  type: TYPE_NORMAL
- en: '`minimal-ui`'
  prefs: []
  type: TYPE_NORMAL
- en: The application appears similar to a native standalone application, but provides
    a way to access application chrome for things like address bars, the application’s
    navigation controls, and so on. System-specific interface controls for things
    like “share” or “print” may also be included.
  prefs: []
  type: TYPE_NORMAL
- en: '`browser`'
  prefs: []
  type: TYPE_NORMAL
- en: The application appears as normal, showing the entire application chrome including
    things like the complete address bar with forward/back/home buttons, scrollbar
    gutters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These various states can be triggered either by the user putting the browser
    into a given mode (e.g., the user hitting F11 on Windows to enter full-screen
    mode), or by a Web Application Manifest’s `display` member. The values are exactly
    the same in all respects; in fact, the Web Application Manifest specification
    just points to the values defined in the CSS Media Queries Level 5 specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, you can do things like define different layouts for different display
    modes. Here’s a brief example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This can be especially useful if you intend to have your design used in multiple
    contexts, such as in web browsers, as web apps, on kiosks, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Ranged Media Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we turn our attention to the media features that allow ranges, and have
    `min-` and `-max` variants in addition to accepting values like lengths or ratios.
    They also have a more compact way of formatting value comparisons, which are discussed
    in an upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `width`, `min-width`, `max-width`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The width of the viewport of the user agent. In a screen-media web browser,
    this is the width of the viewport *plus* any scrollbars. In paged media, this
    is the width of the page box, which is the area of the page in which content is
    rendered. Thus, `(min-width: 100rem)` applies when the viewport is greater than
    or equal to 100 rem wide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `height`, `min-height`, `max-height`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The height of the viewport of the user agent. In a screen-media web browser,
    this is the height of the viewport plus any scrollbars. In paged media, this is
    the height of the page box. Thus, `(height: 60rem)` applies when the viewport’s
    height is precisely 60 rems tall.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `aspect-ratio`, `min-aspect-ratio`, `max-aspect-ratio`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`ratio`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ratio that results from comparing the `width` media feature to the `height`
    media feature (see the definition of <*`ratio`*> in [“Special Value Types”](#special-value-types)).
    Thus, `(min-aspect-ratio: 2/1)` applies to any viewport whose width-to-height
    ratio is at least 2:1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `color`, `min-color`, `max-color`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`integer`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of color-display capability in the output device, with an *optional*
    number value representing the number of bits used in each color component. Thus,
    `(color)` applies to any device with any color depth at all, whereas `(min-color:
    4)` means there must be at least 4 bits used per color component. Any device that
    does not support color will return `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `color-index`, `min-color-index`, `max-color-index`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`integer`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The total number of colors available in the output device’s color lookup table.
    Any device that does not use a color lookup table will return `0`. Thus, `(min-color-index:
    256)` applies to any device with a minimum of 256 colors available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `monochrome`, `min-monochrome`, `max-monochrome`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`integer`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of a monochrome display, with an *optional* number of bits per
    pixel in the output device’s frame buffer. Any device that is not monochrome will
    return `0`. Thus, `(monochrome)` applies to any monochrome output device, whereas
    `(min-monochrome: 2)` means any monochrome output device with a minimum of 2 bits
    per pixel in the frame buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `resolution`, `min-resolution`, `max-resolution`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`resolution`*>'
  prefs: []
  type: TYPE_NORMAL
- en: The resolution of the output device in terms of pixel density, measured in either
    dots per inch (dpi) or dots per centimeter (dpcm); see the definition of <*`resolution`*>
    in the next section for details. If an output device has pixels that are not square,
    the least dense axis is used; for example, if a device is 100 dpcm along one axis
    and 120 dpcm along the other, `100` is the value returned. Additionally, in such
    nonsquare cases, a bare `resolution` feature query—that is, one without a value—can
    never match (though `min-resolution` and `max-resolution` can). Note that resolution
    values must be not only nonnegative, but also nonzero.
  prefs: []
  type: TYPE_NORMAL
- en: 'With ranged media feature values, it’s common to want to restrict rules to
    a specific range with a maximum and minimum. For example, you might want to apply
    a certain margin between two display widths, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Media Queries Level 4 defines a much more compact way to say the same thing,
    using standard mathematical expressions like equals, greater than, less than,
    and so on. Thus, the previous example could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In other words, “width is greater than 20 em and less than 45 em.” If you want
    to have the rules in that media block apply at exactly 20 and 45 em of width,
    the `<` symbols would be written as `<=` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax can be used to limit in only one direction, so to speak, as this
    example illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Any media feature that accepts a range as a value (see the preceding section)
    can use this syntax format. This effectively does away with the need for `min-`
    and `max-` prefixes on the feature name, as well as for complex `and` constructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also do multiple ranged queries by chaining them with the `and` combinator,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will add an inline margin to the `<body>` element only when the width of
    the display area is between 20 and 45 em, and the output resolution is below 600
    dots per inch.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of early 2023, the Chrome and Firefox browser families support the compact
    range syntax, and Safari has it in its nightly builds. We hope this is supported
    everywhere soon after (or even before!) this edition is published.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated Media Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following media features have been deprecated, so browser support for them
    could disappear at any time. We include them here since you may come across them
    in legacy CSS, and will need to know what they were intended to do so you can
    replace them with something more up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `device-width`, `min-device-width`, `max-device-width`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Best replaced by: `width`, `min-width`, `max-width`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The width of the complete rendering area of the output device. In screen media,
    this is the width of the screen (i.e., a handheld device screen’s or desktop monitor’s
    horizontal measurement). In paged media, this is the width of the page itself.
    Thus, `(max-device-width: 1200px)` applies when the device’s output area is less
    than or equal to 1,200 pixels wide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `device-height`, `min-device-height`, `max-device-height`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Best replaced by: `height`, `min-height`, `max-height`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The height of the complete rendering area of the output device. In screen media,
    this is the height of the screen (i.e., a handheld device screen’s or desktop
    monitor’s vertical measurement). In paged media, this is the height of the page
    itself. Thus, `(max-device-height: 400px)` applies when the device’s output area
    is less than or equal to 400 pixels tall.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media features: `device-aspect-ratio`, `min-device-aspect-ratio`, `max-device-aspect-ratio`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Best replaced by: `aspect-ratio`, `min-aspect-ratio`, `max-aspect-ratio`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Values: <*`ratio`*>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ratio that results from comparing the `device-width` media feature to the
    `device-height` media feature (see the definition of <*`ratio`*> in [“Special
    Value Types”](#special-value-types)). Thus, `(device-aspect-ratio: 16/9)` applies
    to any output device whose display area width-to-height ratio is *exactly* 16:9.'
  prefs: []
  type: TYPE_NORMAL
- en: Responsive Styling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Media queries are the foundation on which the practice of *responsive web design*
    is built. By applying different sets of rules depending on the display environment,
    it’s possible to marry “mobile-friendly” and “desktop-friendly” styles into a
    single stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: We put these terms in quotes because, as you may have seen in your own life,
    the lines between what’s mobile and what’s desktop are blurred. A laptop with
    a touch-sensitive screen that folds all the way back can act as both a tablet
    and a laptop, for example. CSS doesn’t (yet) have a way of detecting whether a
    hinge is open past a certain point, nor whether the device is held in hand or
    sitting on a flat surface. Instead, inferences are drawn from aspects of the media
    environment, like display size or display orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A fairly common pattern in responsive design is to define *breakpoints* for
    each `@media` block. This often takes the form of certain pixel widths, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This makes certain assumptions about what a device can display and how it will
    report that, however. For example, the iPhone 6 Plus had a resolution of 1,242
    × 2,208, which it downsampled to 1,080 × 1,920\. Even at the downsampled resolution,
    that’s enough pixels across to qualify for big-screen styles in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! The iPhone 6 Plus also maintained an internal coordinate system of
    points that measured 414 × 736\. If it decided to use those as its definition
    of pixels, which would be entirely valid, then it would get only the small-screen
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: The point here isn’t to single out the iPhone 6 Plus as uniquely bad, which
    it wasn’t, but to illustrate the uncertainties of relying on pixel-based media
    queries. Browser makers have gone to some effort to make their browsers behave
    with some semblance of sanity, but never quite as much as we’d like, and you never
    know when a new device’s assumptions will clash with your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other methods are available, though they come with their own uncertainties.
    Instead of pixels, you might try em-based measures, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This ties the breakpoints to text display size rather than pixels, which is
    more robust. This isn’t perfect either, though: it relies on a sensible approach
    to determining the em width of, say, a smartphone. It also directly relies on
    the actual font family and size used by the device, which varies from one device
    to another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another seemingly simple query set with potentially surprising results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This feels like a good way to tell whether a smartphone is in use: after all,
    most of them are taller than they are wide, and most people don’t turn them sideways
    to read. The wrinkle is that the `orientation` feature refers to the `height`
    and `width`; that is, `orientation` is `portrait` if `height` is equal to or larger
    than `width`. Not `device-height` and `device-width`, but `height` and `width`,
    which refer to the display area of the user agent.'
  prefs: []
  type: TYPE_NORMAL
- en: That means a desktop browser window whose display area (the part inside the
    browser chrome) is taller than it is wide, or even perfectly square, will get
    the portrait styles. So if you assume “portrait equals smartphone,” some of your
    desktop users could get a surprise.
  prefs: []
  type: TYPE_NORMAL
- en: The basic point here is that responsive styling is powerful, and as with any
    powerful tool, its use requires a fair amount of thought and care. Carefully considering
    the implications of each combination of feature queries is the minimum requirement
    for successful responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Paged Media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In CSS terms, a *paged medium* is any medium that handles a document’s presentation
    as a series of discrete “pages.” This is different from the screen, which is a
    *continuous medium*: documents are presented as a single, scrollable “page.” An
    analog example of a continuous medium is a papyrus scroll. Printed material, such
    as books, magazines, and laser printouts, are all paged media. So too are slideshows,
    which show a series of slides one at a time. Each slide is a “page” in CSS terms.'
  prefs: []
  type: TYPE_NORMAL
- en: Print Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even in the paperless future, the most commonly encountered paged medium is
    a printout of a document—a web page, a word-processing document, a spreadsheet,
    or something else that has been committed to the thin wafers of a dead tree. You
    can do several things to make printouts of your documents more pleasing for the
    user, from adjusting page breaking to creating styles meant specifically for print.
  prefs: []
  type: TYPE_NORMAL
- en: Note that print styles would also be applied to the document display in a print
    preview mode. Thus, it’s possible in some circumstances to see print styles on
    a monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Differences Between Screen and Print
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beyond the obvious physical differences, stylistic differences also exist between
    screen and print design. The most basic involves font choices. Most designers
    will tell you that sans-serif fonts are best suited for screen design, but serif
    fonts are more readable in print. Thus, you might set up a print stylesheet that
    uses Times instead of Verdana for the text in your document.
  prefs: []
  type: TYPE_NORMAL
- en: Another major difference involves font sizing. If you’ve spent any time at all
    doing web design, you’ve probably heard again and again (and again) that points
    are a horrible choice for font sizing on the web. This is basically true, especially
    if you want your text to be consistently sized between browsers and operating
    systems. However, print design is not web design any more than web design is print
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Using points, or even centimeters or picas, is perfectly OK in print design
    because printing devices know the physical size of their output area. If a printer
    has been loaded with 8.5 × 11 inch paper, that printer knows it has a printing
    area that will fit within the edges of a piece of paper. It also knows how many
    dots there are in an inch, since it knows the dpi it’s capable of generating.
    This means that it can cope with physical-world length units like points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many a print stylesheet has started with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It’s so traditional, it just might bring a tear of joy to the eye of a graphic
    artist reading over your shoulder. But make sure they understand that points are
    acceptable only because of the nature of the print medium—they’re still not good
    for web design.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the lack of backgrounds in most printouts might bring a tear
    of frustration to that designer’s eye. To save users ink, most web browsers are
    preconfigured not to print background colors and images. If the user wants to
    see those backgrounds in the printout, they have to change an option in the preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS can’t do anything to force the printing of backgrounds. However, you can
    use a print stylesheet to make backgrounds unnecessary. For example, you might
    include this rule in your print stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will do its utmost to ensure that all of your elements print out as black
    text and remove any backgrounds you might have assigned in an all-medium stylesheet.
    It also makes sure that if you have a web design that puts yellow text on a dark
    gray background, a user with a color printer won’t get yellow text on a white
    piece of paper.
  prefs: []
  type: TYPE_NORMAL
- en: One other difference between paged media and continuous media is that multicolumn
    layouts are even harder to use in paged media. Suppose you have an article with
    text formatted as two columns. In a printout, the left side of each page will
    contain the first column, and the right side the second. This would force the
    user to read the left side of every page, then go back to the beginning of the
    printout and read the right side of every page. This is annoying enough on the
    web, but on paper it’s much worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution is to use CSS for laying out your two columns (by using flexbox,
    perhaps) and then write a print stylesheet that restores the content to a single
    column. Thus, you might write something like this for the screen stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in your print stylesheet, you would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, in user agents that support it, you might define actual multicolumn
    layout for both screen and print, and trust the user agents to do the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: We could spend an entire chapter on the details of print design, but that really
    isn’t the purpose of this book. Let’s start exploring the details of paged-media
    CSS and leave the design discussions for another book.
  prefs: []
  type: TYPE_NORMAL
- en: Page Size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In much the same way as it defines the element box, CSS defines a *page box*
    that describes the components of a page. A page box is composed of two main regions:'
  prefs: []
  type: TYPE_NORMAL
- en: Page area
  prefs: []
  type: TYPE_NORMAL
- en: The portion of the page in which the content is laid out. This is roughly analogous
    to the content area of a normal element box, to the extent that the edges of the
    page area act as the initial containing block for layout within a page.
  prefs: []
  type: TYPE_NORMAL
- en: Margin area
  prefs: []
  type: TYPE_NORMAL
- en: The area that surrounds the page area.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 21-2](#pagesize-page-box) shows the page box model.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2102](assets/css5_2102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-2\. The page box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `@page` block is the method by which settings are made, and the `size`
    property is used to define the actual dimensions of the page box. Here’s a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`@page` is a block like `@media` is a block, and it can contain any set of
    styles. One of them, `size`, makes sense only in the context of an `@page` block.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, only Chromium-based browsers support `size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This descriptor defines the size of the page area. The value `landscape` is
    meant to cause the layout to be rotated 90 degrees, whereas `portrait` is the
    normal orientation for Western-language printing. Thus, you could cause a document
    to be printed sideways by declaring the following, with the result shown in [Figure 21-3](#pagesize-landscape):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2103](assets/css5_2103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-3\. Landscape page sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to `landscape` and `portrait`, predefined page-size keywords are
    available. These are summarized in [Table 21-1](#page-size-keywords).
  prefs: []
  type: TYPE_NORMAL
- en: Table 21-1\. Page-size keywords
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `A5` | International Standards Organization (ISO) A5 size, 148 mm wide x
    210 mm tall (5.83 in x 8.27 in) |'
  prefs: []
  type: TYPE_TB
- en: '| `A4` | ISO A2 size, 210 mm x 297 mm (8.27 in x 11.69 in) |'
  prefs: []
  type: TYPE_TB
- en: '| `A3` | ISO A3 size, 297 mm x 420 mm (11.69 in x 16.54 in) |'
  prefs: []
  type: TYPE_TB
- en: '| `B5` | ISO B5 size, 176 mm x 250 mm (6.93 in x 9.84 in) |'
  prefs: []
  type: TYPE_TB
- en: '| `B4` | ISO B4 size, 250 mm x 353 mm (9.84 in x 13.9 in) |'
  prefs: []
  type: TYPE_TB
- en: '| `JIS-B5` | ISO Japanese Industrial Standards (JIS) B5 size, 182 mm x 257
    mm (7.17 in x 10.12 in) |'
  prefs: []
  type: TYPE_TB
- en: '| `JIS-B4` | ISO JIS B4 size, 257 mm x 364 mm (10.12 in x 14.33 in) |'
  prefs: []
  type: TYPE_TB
- en: '| `letter` | North American letter size, 8.5 in x 11 in (215.9 mm x 279.4 mm)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `legal` | North American legal size, 8.5 in x 14 in (215.9 mm x 355.6 mm)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ledger` | North American ledger size, 11 in x 17 in (279.4 mm x 431.8 mm)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Any one of the keywords can be used to declare a page size. The following defines
    a page to be JIS B5 size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These keywords can be combined with the `landscape` and `portrait` keywords;
    thus, to define landscape-oriented North American legal pages, the following is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides using keywords, it’s also possible to define page sizes using length
    units. The width is given first, and then the height. Therefore, the following
    defines a page area 8 inches wide by 10 inches tall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The defined area is usually centered within the physical page, with equal amounts
    of whitespace on each side. If the defined `size` is larger than the printable
    area of the page, the user agent has to decide what to do to resolve the situation.
    There is no defined behavior here, so it’s really dealer’s choice.
  prefs: []
  type: TYPE_NORMAL
- en: Page Margins and Padding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Related to `size`, CSS includes the ability to style the margin area of the
    page box. If you want to make sure that only a small bit at the center of every
    8.5 × 11 inch page is used to print, you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This would leave a printing area 1 inch wide by 3.5 inches tall.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use the length units `em` and `ex` to describe either the
    margin area or the page area, at least in theory. The size used is taken from
    the page context’s font, which is to say, the base font size used for the content
    displayed on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Named Page Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSS enables you to create different page types using named `@page` rules. Let’s
    say you have a document on astronomy that is several pages long, and in the middle
    of it, a fairly wide table contains a list of the physical characteristics of
    all the moons of Saturn. You want to print out the text in portrait mode, but
    the table needs to be landscape. Here’s how you’d start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you just need to apply these page types as needed. The table of Saturn’s
    moons has an `id` of `moon-data`, so you write the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This causes the table to be printed in landscape orientation, but the rest of
    the document to be in portrait orientation. The `page` propery is what makes this
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from looking at the value definition, the whole reason `page`
    exists is to let you assign named page types to various elements in your document.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use more generic page types through special pseudo-classes. The `:first`
    page pseudo-class lets you apply special styles to the first page in the document.
    For example, you might want to give the first page a larger top margin than other
    pages. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will yield a 3 cm margin on all pages, with the exception of a 6 cm top
    margin on the first page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to styling the first page, you can also style left and right pages,
    emulating the pages to the left and right of a book’s spine. You can style these
    differently using `:left` and `:right`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These rules will have the effect of putting larger margins between the content
    of the left and right pages, on the sides where the spine of a book would be.
    This is a common practice when pages are to be bound together into a book of some
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of early 2023 the Firefox family doesn’t support `:first`, `:left`, or `:right`.
  prefs: []
  type: TYPE_NORMAL
- en: Page Breaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a paged medium, it’s a good idea to exert some influence over the way page
    breaks are placed. You can affect page breaking by using the properties `page-break-before`
    and `page-break-after`, both of which accept the same set of values.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `auto` means that a page break is not forced to come before
    or after an element. This is the same as any normal printout. The `always` value
    causes a page break to be placed before (or after) the styled element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say the page title is an `<h1>` element, and the section titles
    are all `<h2>` elements. We might want a page break right before the beginning
    of each section of a document and after the document title. This would result
    in the following rules, illustrated in [Figure 21-4](#pagebreaking-breaks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2104](assets/css5_2104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-4\. Inserting page breaks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we want the document title to be centered in its page, we’d add rules to
    that effect. Since we don’t, we just get a straightforward rendering of each page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values `left` and `right` operate in the same manner as always, except
    they further define the type of page on which printing can resume. Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will force every `<h2>` element to be preceded by enough page breaks that
    the `<h2>` will be printed at the top of a left page—that is, a page surface that
    would appear to the left of a spine if the output were bound. In double-sided
    printing, this would mean printing on the back of a piece of paper.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s assume that, in printing, the element just before an `<h2>` is printed
    on a right page. The previous rule would cause a single page break to be inserted
    before the `<h2>`, thus pushing it to the next page. If the next `<h2>` is preceded
    by an element on a left page, however, the `<h2>` would be preceded by two page
    breaks, thus placing it at the top of the next left page. The right page between
    the two would be intentionally left blank. The value `right` has the same basic
    effect, except it forces an element to be printed at the top of a right page preceded
    by either one or two page breaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The companion to `always` is `avoid`, which directs the user agent to do its
    best to avoid placing a page break either before or after an element. To extend
    the previous example, suppose you have subsections whose titles are `<h3>` elements.
    You want to keep these titles together with the text that follows them, so you
    want to avoid a page break following an `<h3>` whenever possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, though, that the value is called `avoid`, not `never`. There is no way
    to absolutely guarantee that a page break will never be inserted before or after
    a given element. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose further that an `<h4>` is placed between two images, and its height
    calculates to be half an inch. Each image will have to be printed on a separate
    page, but the `<h4>` can go only two places: at the bottom of the page holding
    the first element, or on the page after it. If it’s placed after the first image,
    it has to be followed by a page break, since there’s no room for the second image
    to follow it.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the `<h4>` is placed on a new page following the first
    image, there won’t be room on that same page for the second image. So, again,
    a page break will occur after the `<h4>`. And, in either case, at least one image,
    if not both, will be preceded by a page break. There’s only so much the user agent
    can do, given a situation like this one.
  prefs: []
  type: TYPE_NORMAL
- en: Situations such as these are rare, but they can happen—for example, in a document
    containing nothing but tables preceded by headings. The tables could print in
    such a way that they force a heading element to be followed by a page break, even
    though the author requested such break placement be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: The same sorts of issues can arise with the other page-break property, `page-break-inside`.
    Its possible values are more limited than those of its cousins.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `page-break-inside`, you pretty much have one option other than the default:
    you can request that a user agent try to avoid placing page breaks within an element.
    If you have a series of `aside` divisions, and you don’t want them broken across
    two pages, then you could declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is a suggestion more than an actual rule. If an aside turns out
    to be longer than a page, the user agent can’t help but place a page break inside
    the element.
  prefs: []
  type: TYPE_NORMAL
- en: Orphans and Widows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two properties common to both traditional print typography and desktop
    publishing that provide influence over page breaking: `widows` and `orphans`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties have similar aims but approach them from different angles.
    The value of `widows` defines the minimum number of line boxes found in an element
    that can be placed at the top of a page without forcing a page break to come before
    the element. The `orphans` property has the reverse effect: it gives the minimum
    number of line boxes that can appear at the bottom of a page without forcing a
    page break before the element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take `widows` as an example. Suppose you declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This means that any paragraph can have no fewer than four line boxes appear
    at the top of a page. If the layout of the document would lead to fewer line boxes,
    the entire paragraph is placed at the top of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the situation shown in [Figure 21-5](#widows-counting). Cover up the
    top part of the figure with your hand so that only the second page is visible.
    Notice that there are two line boxes there, from the end of a paragraph that started
    on the previous page. Given the default `widows` value of `2`, this is an acceptable
    rendering. However, if the value were `3` or higher, the entire paragraph would
    appear at the top of the second page as a single block. This would require that
    a page break be inserted before the paragraph in question.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2105](assets/css5_2105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-5\. Counting the widows and orphans
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Refer back to [Figure 21-5](#widows-counting), and this time cover up the second
    page with your hand. Notice the four line boxes at the bottom of the page, at
    the beginning of the last paragraph. This is fine as long as the value of `orphans`
    is `4` or less. If it were `5` or higher, the paragraph would again be preceded
    by a page break and be laid out as a single block at the top of the second page.
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential pitfall is that both `orphans` and `widows` must be satisfied.
    If you declare the following, most paragraphs would be without an interior page
    break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It would take a pretty lengthy paragraph to allow an interior page break, given
    those values. If the intent is to prevent interior breaking, that intent would
    be better expressed as the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both `widows` and `orphans` have long been supported in most browsers, except
    for the Firefox family, which still does not seem to support them as of early
    2023.
  prefs: []
  type: TYPE_NORMAL
- en: Page-Breaking Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because CSS allows for some odd page-breaking styles, it defines a set of behaviors
    regarding allowed page breaks and “best” page breaks. These behaviors serve to
    guide user agents in how they should handle page breaking in various circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Page breaks are permitted in only two generic places. The first of these is
    between two block-level boxes. If a page break falls between two block boxes,
    the `margin-bottom` value of the element before the page break is reset to `0`,
    as is the `margin-top` of the element following the page break. However, two rules
    affect whether a page break can fall between two element boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value of `page-break-after` for the first element—or the value of `page-break-before`
    for the second element—is `always`, `left`, or `right`, a page break will be placed
    between the elements. This is true regardless of the value for the other element,
    even if it’s `avoid`. (This is a *forced* page break.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of the first element’s `page-break-after` value is `auto`, and
    the same is true for the second element’s `page-break-before` value, and they
    do not share an ancestor element whose `page-break-inside` value is not `avoid`,
    then a page break may be placed between them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 21-6](#pagebreaking-potential) illustrates all the possible page-break
    placements between elements in a hypothetical document. Forced page breaks are
    represented as a filled square, whereas potential (unforced) page breaks are shown
    as an open square.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, page breaks are allowed between two line boxes inside a block-level
    box. This, too, is governed by a pair of rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A page break may appear between two line boxes only if the number of line boxes
    between the start of the element and the line box before the page break would
    be less than the value of `orphans` for the element. Similarly, a page break can
    be placed only where the number of line boxes between the line box after the page
    break and the end of the element is less than the value of `widows`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A page break can be placed between line boxes if the value of `page-break-inside`
    for the element is not `avoid`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![css5 2106](assets/css5_2106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-6\. Potential page-break placement between block boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In both cases, the second of the two rules controlling page-break placement
    is ignored if no page-break placement can satisfy all the rules. Thus, if an element
    has been given `page-break-inside: avoid` but the element is longer than a full
    page, a page break will be permitted inside the element, between two line boxes.
    In other words, the second rule regarding page-break placement between line boxes
    is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: If ignoring the second rule in each pair of rules still does not yield good
    page-break placement, other rules can also be ignored. In such a situation, the
    user agent is likely to ignore all page-break property values and proceed as if
    they were all `auto`, although this approach is not defined (or required) by the
    CSS specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the previously explored rules, CSS defines a set of best page-breaking
    behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: Break as few times as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make all pages that don’t end with a forced break appear to have about the same
    height.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid breaking inside a block that has a border.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid breaking inside a table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid breaking inside a floated element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These recommendations aren’t required of user agents, but they offer logical
    guidance that should lead to ideal page-breaking behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very common desire in paged media is the ability to have a *running head*.
    This is an element that appears on every page, such as the document’s title or
    the author’s name. This is possible in CSS by using a fixed-position element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will place any `<div>` with an `id` of `runhead` at the top-right corner
    of every page box when the document is outputted to a paged medium. The same rule
    would place the element in the top-right corner of the viewport in a continuous
    medium, such as a web browser. Any element positioned in this way will appear
    on every page. It is not possible to copy an element to become a repeated element.
    Thus, given the following, the `<h1>` element will appear as a running head on
    every page, including the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The drawback is that the `<h1>` element, being positioned on the first page,
    cannot be printed as anything except the running head.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, we will be able to add content directly into the margins of a printed
    page with the `@page`’s margin at-rules. The following would place “table of contents”
    in the top middle of a printed page containing an element with `page: toc` set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Elements Outside the Page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All this talk of positioning elements in a paged medium leads to an interesting
    question: what happens if an element is positioned outside the page box? You don’t
    even need positioning to create such a situation. Think about a `<pre>` element
    that contains a line with 411 characters. This is likely to be wider than any
    standard piece of paper, and so the element will be wider than the page box. What
    will happen then?'
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, CSS doesn’t say exactly what user agents should do, so it’s
    up to each one to come up with a solution. For a very wide `<pre>` element, the
    user agent might clip the element to the page box and throw away the rest of the
    content. It could also generate extra pages to display the leftover part of the
    element.
  prefs: []
  type: TYPE_NORMAL
- en: CSS has a few general recommendations for handling content outside the page
    box, and two that are really important. First, content should be allowed to protrude
    slightly from a page box in order to allow bleeding. This implies that no extra
    page would be generated for the portions of such content that exceed the page
    box but do not extend all the way off the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, user agents are cautioned not to generate large numbers of empty pages
    for the sole purpose of honoring positioning information. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that the page boxes are 10 inches high, the user agent would have to
    precede an `<h1>` with 150 page breaks (and thus 150 blank pages) just to honor
    that rule. Instead, a user agent might choose to skip the blank pages and output
    only the last one, which actually contains the `<h1>` element.
  prefs: []
  type: TYPE_NORMAL
- en: The other two recommendations in the specification state that user agents should
    not position elements in strange places just to avoid rendering them, and that
    content placed outside a page box can be rendered in any of a number of ways.
    (Some of the commentary in CSS is useful and intriguing, but some seems to exist
    solely to cheerily state the obvious.)
  prefs: []
  type: TYPE_NORMAL
- en: Container Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As media queries are to media contexts, so container queries are to containment
    contexts. Rather than saying you want to change the layout of a piece of your
    design because of changes in the display size, you can have those changes come
    from changes in their parent element’s size.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might have a page header containing a logo, some navbar links,
    and a search box. By default, the search box is narrow, so as not to take up too
    much space. Once it gains focus, though, it gets wider. In this situation, you
    might want to change the layout and sizing of the logo and links, thus giving
    way to the search box without disappearing entirely or being overlaid. Here’s
    how you could set that up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let’s explore the new properties that container queries introduce, and then
    dig into the query block syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Container queries gained widespread browser support in mid- to late 2022, so
    be careful when using them if you have users with browsers older than that. That
    said, container queries are supported in all evergreen browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Container Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of ways to define the type of container, while also setting
    the kinds of containment (see `contain` in [Chapter 20](ch20.html#filters-compositing))
    that are enabled for the container. It’s all managed through the `container-type`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the default value, `normal`, a container can be queried on specific
    property-value combinations. Suppose you want to apply certain styles if a container
    has a specific side padding value. That would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside a `style()` function, any property and value combination can be used,
    including those involving custom properties, and will match as long as that precise
    combination is in effect. You could, for example, change the color of heading
    text based on the value of a text-sizing custom property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also query specific sizing values, such as `(width: 30em)`, but that
    queries only the value of the CSS property, not the rendered size of the container.
    If you want to perform range-based sizing queries, you’ll have to use one of the
    other values of `container-type`: `size` or `inline-size`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you declare `container-type: size`, you’re able to query on both the inline
    and block axes. Thus you could, for example, set up a query that relates to both
    sizes of the container like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you care about only the inline size, using `inline-size` instead might make
    more sense, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What’s the real difference, besides one of them allowing for block-axis queries?
    Both values set layout and style containment (see the `contain` property in [Chapter 20](ch20.html#filters-compositing)),
    but `size` sets size containment, whereas `inline-size` sets inline-size containment.
    This makes some sense, given their respective names. If you’re always going to
    do only inline querying, use `inline-size` so as to keep the block direction uncontained.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we’ve been setting a container name without having
    really talked about it, so let’s talk about it now.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Container Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To refer to a container, that container needs a name, and that’s what `container-name`
    provides. It even lets you assign multiple names to the same element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretty much anytime you set a container, you should set a container name—or
    names. Both of the following rules are legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, you probably shouldn’t be mixing camelCase, dash-separated, and underscore_separated
    naming conventions, but otherwise, everything’s fine. The `<header>` elements
    will be given the container name `pageHeader`, while `<footer>` elements will
    be given all three container names listed. This allows you to apply different
    container queries for different things, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can turn this around and assign the same container name to a bunch of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Using Container Shorthand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s bring these two properties together into a single shorthand, `container`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to define the container name and type in one handy declaration,
    this is the property for you. As an example, the following two rules are precisely
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `container` value, the name must always be present and must always come
    first. If a container type is defined, it must come second and follow a forward
    slash (`/`). If no container type is given, the initial value of `normal` is used.
    Thus, the following rules are precisely equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `container-name`, you can include a space-separated list of names,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So those are the ways to set container names and types. You’ve seen that the
    `@container` block is used to invoke these, and now it’s time to discuss exactly
    how that works.
  prefs: []
  type: TYPE_NORMAL
- en: Using Container At-Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax of container query blocks will seem familiar if you read the earlier
    sections on media queries, because the syntax is nearly the same. The only real
    difference is that container queries use an optional container name and the `style()`
    function. Here’s the basic syntax format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to include a container name, but if you do, it must go first.
    (We’ll talk about what happens if you don’t in just a bit.) There must, however,
    be a condition of some sort—some sort of query. It wouldn’t be a container query
    without one, after all.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with media queries, you can use the `and`, `not`, and `or` modifiers to
    set up your queries. Suppose you want to match a container that does *not* have
    a dashed border. That goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Or perhaps you want to apply some rules when a container named `fullWidth`
    is in a certain size range but also doesn’t have a dashed border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can list only one container name; there is no way to combine
    them in a single query block, whether with commas or logical combinators like
    `and`. As with all query blocks, though, you can nest container queries, such
    as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This will be matched, and the styles applied, to elements when they have a `fullWidth`
    container with an inline size above 30 em and a not-dashed border style, and also
    a `headerNav` container with an inline size above 30 em. And the same element
    could be both containers!
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the question of how, exactly, an element knows which containers
    are being queried. Let’s extend an earlier example a bit and fill in the actual
    CSS rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'How does a given `<nav>` element on the page know when it’s matched by a container
    query? By looking up its ancestor tree to see if there are any containers above
    it in the tree. If there are, and they match the name that appears in the container
    block surrounding it, and the specified query matches the container type, then
    the query is made. If it returns true, the styles in the container block are applied.
    Let’s see that in action. Here’s a document skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To that markup, we’ll apply the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the markup, we have three `<nav>` elements, and in the CSS we have three
    container blocks. Let’s consider the blocks one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first container query block says to all `<nav>` elements, “If you have
    a container with a name of `fullWidth`, and that container’s inline size is less
    than 30 em, then you get these styles.” The header and footer `<nav>` elements
    do have containers named `fullWidth`: the `<header>` and `<footer>` elements both
    have that name. Their container types are also `size`, so checking the inline
    size is valid. So they check the inline sizes of their respective containers to
    see if the styles will be applied.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this happens per container. The header might be 40 em wide and the
    footer only 25 em wide because of other layout styles (a grid template, for example).
    In that case, the change of flex direction will be applied to the footer’s `<nav>`,
    but not the header’s `<nav>`. As for the `<nav>` inside the `<main>` element,
    it doesn’t have any containers labeled `fullWidth`, so it gets skipped over regardless
    of the condition query.
  prefs: []
  type: TYPE_NORMAL
- en: The second container query block says to all `<nav>` elements, “If you have
    a container named `headerNav`, and that container’s block size is greater than
    25 vh, you get these styles.” The only container on the page with a container
    name of `headerNav` is the `<header class="page">`, so its `<nav>` checks the
    block size of the container, and applies the styles if the container’s block size
    is above 25 vh. The other two `<nav>` elements skip this entirely, because none
    of their containers are named `headerNav`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third container query block is more vague. It says to all `<nav>` elements,
    “If you have a container and its background is blue, then you get these styles.”
    Note that there’s no container name, so the header `<nav>` checks its nearest-ancestor
    container, which is `header.page`, to see if it’s set to `background-color: blue`.
    Let’s assume it isn’t, so these styles aren’t applied.'
  prefs: []
  type: TYPE_NORMAL
- en: The same thing happens for the `<nav>` inside the `<main>` and the footer, as
    well any `<a>` elements inside them. We already established that its background
    color isn’t blue in the previous paragraph, so if `<main>` or the footer have
    their background color set to `blue`, then their respective `<nav>` elements and
    their links will get those styles; otherwise, they won’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that a container query matters only if an element matches the selectors
    inside the query block. Imagine someone writing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Only an element that matches that long and very specific selector can check
    its containers to see if any of them are in `portrait` orientation, and even an
    element that matches the selector won’t get the styles if it doesn’t have any
    containers. Otherwise, the query is kind of moot. This speaks to the necessity
    of making sure your selectors will match before you worry about querying any containers,
    and then making sure your matched elements have containers to query.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Container Query Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can check seven features in a container query, most of which you’ve seen
    previously, but a couple of which we haven’t touched on. They’re summarized here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: `block-size`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the block size of the query container’s content box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: `inline-size`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the inline size of the query container’s content box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: `width`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the physical width of the query container’s content box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: `height`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: <*`length`*>'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the physical height of the query container’s content box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: `aspect-ratio`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: <*`ratio`*>'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the ratio of the physical width as compared to the physical height of
    the query container’s content box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature: `orientation`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value: `portrait` | `landscape`'
  prefs: []
  type: TYPE_NORMAL
- en: Queries the physical width and height of the query container’s content box.
    The container is considered to be `landscape` if its width is greater than its
    height; otherwise, the container is considered to be `portrait`.
  prefs: []
  type: TYPE_NORMAL
- en: These do not have `min-` and `max-` prefixed variants. Instead, the math-style
    range notation we covered previously is used.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Container Length Units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to querying containers, you can also style elements with length
    values based on their containers’ sizes, very much like the viewport-relative
    length units discussed in [Chapter 5](ch05.html#values_and_units). These are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cqb`'
  prefs: []
  type: TYPE_NORMAL
- en: 1% of the container’s block size
  prefs: []
  type: TYPE_NORMAL
- en: '`cqi`'
  prefs: []
  type: TYPE_NORMAL
- en: 1% of the container’s inline size
  prefs: []
  type: TYPE_NORMAL
- en: '`cqh`'
  prefs: []
  type: TYPE_NORMAL
- en: 1% of the container’s physical height
  prefs: []
  type: TYPE_NORMAL
- en: '`cqw`'
  prefs: []
  type: TYPE_NORMAL
- en: 1% of the container’s physical width
  prefs: []
  type: TYPE_NORMAL
- en: '`cqmin`'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to `cqb` or `cqi`, whichever is *smaller*
  prefs: []
  type: TYPE_NORMAL
- en: '`cqmax`'
  prefs: []
  type: TYPE_NORMAL
- en: Equivalent to `cqb` or `cqi`, whichever is *larger*
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus you could set up an element such that at smaller container sizes, its
    children are the full width of the container, but at larger sizes they’re some
    fraction of the container’s width. This could be done with grid tracks, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, if the container is above 45 em in width, a `<ul>` that is a child of
    `div.card` will be turned into a grid container, with columns that are sized based
    on the container’s width. This is illustrated in [Figure 21-7](#container-query-units).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2107](assets/css5_2107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 21-7\. Using container query units
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The advantage here is mostly in applications like web components, for which
    it may be desirable to size elements based on the size of the container, even
    though the container may appear in a wide variety of sizing conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Feature Queries (@supports)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS has the ability to apply rules when certain CSS property-value combinations
    are supported by the user agent. These are known as *feature queries*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to apply color to an element only if `color` is a supported property.
    (Which it certainly should be!) That would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This says, in effect, “If you recognize and can do something with the property-value
    combination `color: black`, apply these styles. Otherwise, skip these styles.”
    In user agents that don’t understand `@supports`, the entire block is skipped
    over.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature queries are a perfect way to progressively enhance your styles. For
    example, suppose you want to add some grid layout to your existing float-and-inline-block
    layout. You can keep the old layout scheme and then later in the stylesheet include
    a block like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This block of styles will be applied in browsers that understand grid display,
    overriding the old styles that governed page layout, and then applying the styles
    needed to make things work in a grid-based future. Browsers too old to understand
    grid layout are too old to understand `@supports`, so they’ll skip the whole block
    entirely, as if it had never been there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature queries can be embedded inside each other, and indeed can be embedded
    inside media blocks, as well as vice versa. You could write screen and print styles
    based on flexible-box layout, and wrap those media blocks in an `@supports (display:
    flex)` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, you could add `@supports()` blocks inside various responsive-design
    media query blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The way you organize these blocks is really up to you. The same holds true for
    container queries, which can be nested inside feature queries, or vice versa.
    In fact, you can nest the various kinds of queries inside each other, or themselves,
    in any combination that makes sense for your situation (and to you).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with media queries, feature queries also permit logical operators. Suppose
    we want to apply styles only if a user agent supports both grid layout *and* CSS
    shapes. Here’s how that might go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This is essentially equivalent to writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there’s more than “and” operations available. CSS Shapes (covered
    in detail in [Chapter 20](ch20.html#filters-compositing)) are a good example of
    why “or” is useful, because for a long time WebKit supported CSS shapes only via
    vendor-prefixed properties. So if you want to use shapes, you can use a feature
    query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You’d still have to make sure to use both prefixed and unprefixed versions of
    the shape properties, but this would let you add support for those properties
    backward in the WebKit release line while supporting other browsers that also
    support shapes via nonprefixed properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this is handy because at times you might want to apply different properties
    than those you’re testing. So, to go back to grid layout for a second, you might
    want to change the margins and so forth on your layout elements when a grid is
    in use. Here’s a simplified version of that approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to use negation as well. For example, you could apply the following
    styles when grid layout is *not* supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine your logical operators into a single query, but parentheses
    are required to keep the logic straight. Suppose we want a set of styles to be
    applied when color is supported, and when one of either grid or flexible box layout
    is supported. That’s written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that there’s another set of parentheses around the “or” part of the
    logic, enclosing the grid and flex tests. Those extra parentheses are required.
    Without them, the entire expression will fail, and the styles inside the block
    will be skipped. In other words, *don’t* do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you might wonder why both a property and value are required in feature
    query tests. After all, if you’re using shapes, all you need to test for is `shape-outside`,
    right? It’s because a browser can easily support a property without supporting
    all its values. Grid layout is a perfect example. Suppose you try to test for
    grid support like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Well, even Internet Explorer 4 supported `display`. Any browser that understands
    `@supports` will certainly understand `display` and many of its values—but maybe
    not `grid`. That’s why property and value are always tested in feature queries.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that these are *feature* queries, not *correctness* queries. A browser
    can understand the feature you’re testing for, but implement it with bugs, or
    parse it correctly without actually supporting the intended behavior. In other
    words, you’re not getting an assurance from the browser that it supports something
    correctly. All a positive feature-query result means is that the browser understands
    what you’ve said.
  prefs: []
  type: TYPE_NORMAL
- en: Other At-Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variety of other at-rules were covered in other parts of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@counter-style` (see [Chapter 16](ch16.html#lists-and-generated-content))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@font-face` (see [Chapter 14](ch14.html#fonts))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@font-feature-values` (see [Chapter 14](ch14.html#fonts))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@import` (see [Chapter 1](ch01.html#css_fundamentals))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@layer` (see [Chapter 4](ch04.html#specificity_comma_inheritance))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two more were not covered elsewhere, so we’ll cover them here.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Character Set for a Stylesheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@charset` at-rule is a way to set a specific character set for a stylesheet.
    For example, you may have received a stylesheet in the UTF-16 character encoding.
    That would be marked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In a departure from the rest of CSS, the syntax here is very exacting. There
    must be exactly one space (which must be the space defined by Unicode code point
    U+0020) between the `@charset` and the quoted value, the value must be quoted,
    and it can be quoted using only double quotes. In addition, you cannot have space
    of any kind before the `@charset`; it must be the first thing on the line.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if you need to include `@charset`, it must be the very first thing
    in the stylesheet, before any other at-rule or regular rule. If you list more
    than one `@charset`, the first will be used, and the rest ignored.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, the only acceptable values are character encodings defined in the
    [Internet Assigned Numbers Authority (IANA) Registry](https://www.iana.org/assignments/character-sets/character-sets.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Use of `@charset` is vanishingly rare, so unless explicitly declaring the encoding
    of a specific stylesheet is absolutely required to make things work, don’t worry
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Namespace for Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `@namespace` at-rule allows you to use XML namespaces in your stylesheets.
    The value of `@namespace` is the URL of a document defining the namespace, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the previous CSS, `<a>` elements in XHTML would be navy on yellow, and
    `<a>` elements in SVG would be red on yellow. This is why selectors without namespaces
    work across all markup languages: no namespace means no restriction.'
  prefs: []
  type: TYPE_NORMAL
- en: Any `@namespace` at-rules must come after any `@charset` or `@import` at-rules,
    but before any other stylesheet content, whether other at-rules or normal rules.
    The `@namespace` at-rule is rarely used outside of test pages, but if you need
    to use it, the capability is there.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the flexibility of at-rules, it is possible to provide a wide range
    of design experiences from within a single set of styles. Whether reorganizing
    a page to account for varying display sizes, reworking the color scheme to support
    grayscale printing, or restyling content based on elements that contain them,
    you have the ability to do a great deal to make your work the best it can be.
  prefs: []
  type: TYPE_NORMAL
