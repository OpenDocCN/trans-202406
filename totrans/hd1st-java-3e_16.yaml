- en: 'Chapter 14\. A Very Graphic Story: Getting Gui'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0461-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Face it, you need to make GUIs**. If you’re building applications that other
    people are going to use, you *need* a graphical interface. If you’re building
    programs for yourself, you *want* a graphical interface. Even if you believe that
    the rest of your natural life will be spent writing server-side code, where the
    client user interface is a web page, sooner or later you’ll need to write tools,
    and you’ll want a graphical interface. Sure, command-line apps are retro, but
    not in a good way. They’re weak, inflexible, and unfriendly. We’ll spend two chapters
    working on GUIs and learn key Java language features along the way including **Event
    Handling** and **Inner Classes** and **lambdas**. In this chapter, we’ll put a
    button on the screen, and make it do something when you click it. We’ll paint
    on the screen, we’ll display a JPEG image, and we’ll even do some (crude) animation.'
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0462-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**She’s asked a couple of really good questions.** In a few pages we’ll address
    these questions with an extra-special “No Dumb Questions.”'
  prefs: []
  type: TYPE_NORMAL
- en: A JFrame is the object that represents a window on the screen. It’s where you
    put all the interface things like buttons, check boxes, text fields, and so on.
    It can have an honest-to-goodness menu bar with menu items. And it has all the
    little windowing icons for whatever platform you’re on, for minimizing, maximizing,
    and closing the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JFrame looks different depending on the platform you’re on. This is a JFrame
    on an old Mac OS X:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0462-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Put widgets in the window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have a JFrame, you can put things (“widgets”) in it by adding them
    to the JFrame. There are a ton of Swing components you can add; look for them
    in the javax.swing package. The most common include JButton, JRadioButton, JCheckBox,
    JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable. Most are
    really simple to use, but some (like JTable) can be a bit more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making a GUI is easy:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Make a frame (a JFrame)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '`**JFrame frame = new JFrame();**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Make a widget (button, text field, etc.)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '`**JButton button = new JButton("click me");**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Add the widget to the frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**frame.getContentPane().add(button);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You don’t add things to the frame directly. Think of the frame as the trim around
    the window, and you add things to the window pane.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/4.png) Display it (give it a size and make it visible)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your first GUI: a button on a frame'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0463-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Let’s see what happens when we run it:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`%java SimpleGui1`'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0463-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Whoa! That’s a Really Big Button.**'
  prefs: []
  type: TYPE_NORMAL
- en: The button fills all the available space in the frame. Later we’ll learn to
    control where (and how big) the button is on the frame.
  prefs: []
  type: TYPE_NORMAL
- en: But nothing happens when I click it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s not exactly true. When you press the button, it shows that “pressed”
    or “pushed in” look (which changes depending on the platform look and feel, but
    it always does *something* to show when it’s being pressed).
  prefs: []
  type: TYPE_NORMAL
- en: The real question is, “How do I get the button to do something specific when
    the user clicks it?”
  prefs: []
  type: TYPE_NORMAL
- en: '**We need two things:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) A ***method*** to be called when the user clicks (the
    thing you want to happen as a result of the button click).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) A way to ***know*** when to trigger that method. In
    other words, a way to know when the user clicks the button!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a user event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you want the text on the button to change from *click me* to *I’ve
    been clicked* when the user presses the button. First we can write a method that
    changes the text of the button (a quick look through the API will show you the
    method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But *now* what? How will we *know* when this method should run? ***How will
    we know when the button is clicked?***
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the process of getting and handling a user event is called *event-handling*.
    There are many different event types in Java, although most involve GUI user actions.
    If the user clicks a button, that’s an event. An event that says “The user wants
    the action of this button to happen.” If it’s a “Slow the Tempo” button, the user
    wants the slow-the-music-tempo action to occur. If it’s a Send button on a chat
    client, the user wants the send-my-message action to happen. So the most straightforward
    event is when the user clicked the button, indicating they want an action to occur.
  prefs: []
  type: TYPE_NORMAL
- en: With buttons, you usually don’t care about any intermediate events like button-is-being-pressed
    and button-is-being-released. What you want to say to the button is, “I don’t
    care how the user plays with the button, how long they hold the mouse over it,
    how many times they change their mind and roll off before letting go, etc. ***Just
    tell me when the user means business!*** In other words, don’t call me unless
    the user clicks in a way that indicates he wants the darn button to do what it
    says it’ll do!”
  prefs: []
  type: TYPE_NORMAL
- en: '**First, the button needs to know that we care.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0465-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Second, the button needs a way to call us back when a button-clicked event
    occurs.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you care about the button’s events, **implement an interface** that says,
    “I’m **listening** for your events.”**'
  prefs: []
  type: TYPE_NORMAL
- en: A **listener interface** is the bridge between the **listener** (you) and **event
    source** (the button).
  prefs: []
  type: TYPE_NORMAL
- en: The Swing GUI components are event sources. In Java terms, an event source is
    an object that can turn user actions (click a mouse, type a key, close a window)
    into events. And like virtually everything else in Java, an event is represented
    as an object. An object of some event class. If you scan through the java.awt.event
    package in the API, you’ll see a bunch of event classes (easy to spot—they all
    have ***Event*** in the name). You’ll find MouseEvent, KeyEvent, WindowEvent,
    ActionEvent, and several others.
  prefs: []
  type: TYPE_NORMAL
- en: An event ***source*** (like a button) creates an ***event object*** when the
    user does something that matters (like *click* the button). Most of the code you
    write (and all the code in this book) will *receive* events rather than *create*
    events. In other words, you’ll spend most of your time as an event *listener*
    rather than an event *source*.
  prefs: []
  type: TYPE_NORMAL
- en: Every event type has a matching listener interface. If you want MouseEvents,
    implement the MouseListener interface. Want WindowEvents? Implement WindowListener.
    You get the idea. And remember your interface rules—to implement an interface
    you *declare* that you implement it (class Dog implements Pet), which means you
    must *write implementation methods* for every method in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Some interfaces have more than one method because the event itself comes in
    different flavors. If you implement MouseListener, for example, you can get events
    for mousePressed, mouseReleased, mouseMoved, etc. Each of those mouse events has
    a separate method in the interface, even though they all take a MouseEvent. If
    you implement MouseListener, the mousePressed() method is called when the user
    (you guessed it) presses the mouse. And when the user lets go, the mouseReleased()
    method is called. So for mouse events, there’s only one event *object*, MouseEvent,
    but several different event *methods*, representing the different *types* of mouse
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**When you implement a listener interface, you give the button a way to call
    you back. The interface is where the call-back method is declared.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0466-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**How the listener and source communicate:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0467-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The Listener**'
  prefs: []
  type: TYPE_NORMAL
- en: If your class wants to know about a button’s ActionEvents, you implement the
    ActionListener interface. The button needs to know you’re interested, so you register
    with the button by calling its addActionListener(this) and passing an ActionListener
    reference to it. In our first example, *you* are the ActionListener so you pass
    *this*, but it’s more common to create a specific class to do listen to events.
    The button needs a way to call you back when the event happens, so it calls the
    method in the listener interface. As an ActionListener, you *must* implement the
    interface’s sole method, actionPerformed(). The compiler guarantees it.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Event Source**'
  prefs: []
  type: TYPE_NORMAL
- en: A button is a source of ActionEvents, so it has to know which objects are interested
    listeners. The button has an addActionListener() method to give interested objects
    (listeners) a way to *tell* the button they’re interested.
  prefs: []
  type: TYPE_NORMAL
- en: When the button’s addActionListener() runs (because a potential listener invoked
    it), the button takes the parameter (a reference to the listener object) and stores
    it in a list. When the user clicks the button, the button “fires” the event by
    calling the actionPerformed() method on each listener in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting a button’s ActionEvent**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Implement the ActionListener interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Register with the button (tell it you want to listen
    for events)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![images](Images/3.png) Define the event-handling method (implement the actionPerformed()
    method from the ActionListener interface)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![image](Images/f0468-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Listeners, Sources, and Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most of your stellar Java career, *you* will not be the *source* of events.
  prefs: []
  type: TYPE_NORMAL
- en: (No matter how much you fancy yourself the center of your social universe.)
  prefs: []
  type: TYPE_NORMAL
- en: Get used to it. ***Your job is to be a good listener.***
  prefs: []
  type: TYPE_NORMAL
- en: (Which, if you do it sincerely, *can* improve your social life.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0469-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to graphics...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a little about how events work (we’ll learn more later), let’s
    get back to putting stuff on the screen. We’ll spend a few minutes playing with
    some fun ways to get graphic, before returning to event handling.
  prefs: []
  type: TYPE_NORMAL
- en: '**Three ways to put things on your GUI:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) **Put widgets on a frame**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add buttons, menus, radio buttons, etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**frame.getContentPane().add(myButton);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The javax.swing package has more than a dozen widget types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0471-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2.png) **Draw 2D graphics on a widget**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a graphics object to paint shapes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**graphics.fillOval(70,70,100,100);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can paint a lot more than boxes and circles; the Java2D API is full of fun,
    sophisticated graphics methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0471-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3.png) **Put a JPEG on a widget**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can put your own images on a widget.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**graphics.drawImage(myPic,10,10,this);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0471-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Make your own drawing widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to put your own graphics on the screen, your best bet is to make
    your own paintable widget. You plop that widget on the frame, just like a button
    or any other widget, but when it shows up, it will have your images on it. You
    can even make those images move, in an animation, or make the colors on the screen
    change every time you click a button.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: '**Make a subclass of JPanel and override one method, paintComponent().**'
  prefs: []
  type: TYPE_NORMAL
- en: All of your graphics code goes inside the paintComponent() method. Think of
    the paintComponent() method as the method called by the system to say, “Hey widget,
    time to paint yourself.” If you want to draw a circle, the paintComponent() method
    will have code for drawing a circle. When the frame holding your drawing panel
    is displayed, paintComponent() is called and your circle appears. If the user
    iconifies/minimizes the window, the JVM knows the frame needs “repair” when it
    gets de-iconified, so it calls paintComponent() again. Anytime the JVM thinks
    the display needs refreshing, your paintComponent() method will be called.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing, ***you never call this method yourself!*** The argument to this
    method (a Graphics object) is the actual drawing canvas that gets slapped onto
    the *real* display. You can’t get this by yourself; it must be handed to you by
    the system. You’ll see later, however, that you *can* ask the system to refresh
    the display (repaint()), which ultimately leads to paintComponent() being called.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0472-01.png)![image](Images/f0472-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Fun things to do in paintComponent()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at a few more things you can do in paintComponent(). The most fun,
    though, is when you start experimenting yourself. Try playing with the numbers,
    and check the API for class Graphics (later we’ll see that there’s even *more*
    you can do besides what’s in the Graphics class).
  prefs: []
  type: TYPE_NORMAL
- en: '**Display a JPEG**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0473-01.png)![image](Images/f0473-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Paint a randomly colored circle on a black background**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0473-03.png)![image](Images/f0473-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Behind every good Graphics reference is a Graphics2D object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The argument to paintComponent() is declared as type Graphics (java.awt.Graphics).
  prefs: []
  type: TYPE_NORMAL
- en: '**`public void paintComponent(Graphics g) { }`**'
  prefs: []
  type: TYPE_NORMAL
- en: So the parameter “g” IS-A Graphics object. This means it *could* be a *subclass*
    of Graphics (because of polymorphism). And in fact, it *is*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The object referenced by the “g” parameter is actually an instance of the***
    Graphics2D ***class.***'
  prefs: []
  type: TYPE_NORMAL
- en: Why do you care? Because there are things you can do with a Graphics2D reference
    that you can’t do with a Graphics reference. A Graphics2D object can do more than
    a Graphics object, and it really is a Graphics2D object lurking behind the Graphics
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember your polymorphism. The compiler decides which methods you can call
    based on the reference type, not the object type. If you have a Dog object referenced
    by an Animal reference variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**Animal a = new Dog();**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You CANNOT say:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**a.bark();**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though you know it’s really a Dog back there. The compiler looks at “a,”
    sees that it’s of type Animal, and finds that there’s no remote control button
    for bark() in the Animal class. But you can still get the object back to the Dog
    it really *is* by saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So the bottom line with the Graphics object is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you need to use a method from the Graphics2D class, you can’t *use* the
    paintComponent parameter (“g”) straight from the method. But you can *cast* it
    with a new Graphics2D variable:**'
  prefs: []
  type: TYPE_NORMAL
- en: '`**Graphics2D g2d = (Graphics2D) g;**`'
  prefs: []
  type: TYPE_NORMAL
- en: Because life’s too short to paint the circle a solid color when there’s a gradient
    blend waiting for you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0475-01.png)![image](Images/f0475-02.png)![image](Images/f0475-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Bullet Points**'
  prefs: []
  type: TYPE_NORMAL
- en: We can get an event. We can paint graphics. But can we paint graphics *when*
    we get an event?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s hook up an event to a change in our drawing panel. We’ll make the circle
    change colors each time you click the button. Here’s how the program flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1-circle.png) The frame is built with the two widgets (your
    drawing panel and a button). A listener is created and registered with the button.
    Then the frame is displayed, and it just waits for the user to click.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2-circle.png) The user clicks the button, and the button creates
    an event object and calls the listener’s event handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3-circle.png) The event handler calls repaint() on the frame.
    The system calls paintComponent() on the drawing panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/4-circle.png) Voilà! A new color is painted because paintComponent()
    runs again, filling the circle with a random color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![image](Images/f0478-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'GUI layouts: putting more than one widget on a frame'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cover GUI layouts in the *next* chapter, but we’ll do a quickie lesson here
    to get you going. By default, a frame has five regions you can add to. You can
    add only *one* thing to each region of a frame, but don’t panic! That one thing
    might be a panel that holds three other things including a panel that holds two
    more things and...you get the idea. In fact, we were “cheating” when we added
    a button to the frame using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0478-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The circle changes color each time you click the button.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0479-01.png)![image](Images/f0479-02.png)![image](Images/f0479-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s try it with TWO buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The south button will act as it does now, simply calling repaint on the frame.
    The second button (which we’ll stick in the east region) will change the text
    on a label. (A label is just text on the screen.)
  prefs: []
  type: TYPE_NORMAL
- en: So now we need FOUR widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0480-01.png)'
  prefs: []
  type: TYPE_IMG
- en: And we need to get TWO events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uh-oh.
  prefs: []
  type: TYPE_NORMAL
- en: Is that even possible? How do you get *two* events when you have only *one*
    actionPerformed() method?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0480-02.png)'
  prefs: []
  type: TYPE_IMG
- en: How do you get action events for two different buttons when each button needs
    to do something different?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0483-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Inner class to the rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You *can* have one class nested inside another. It’s easy. Just make sure that
    the definition for the inner class is *inside* the curly braces of the outer class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple inner class:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0484-01.png)'
  prefs: []
  type: TYPE_IMG
- en: An inner class gets a special pass to use the outer class’s stuff. *Even the
    private stuff.* And the inner class can use those private variables and methods
    of the outer class as if the variables and members were defined in the inner class.
    That’s what’s so handy about inner classes—they have most of the benefits of a
    normal class, but with special access rights.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner class using an outer class variable**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0484-02.png)'
  prefs: []
  type: TYPE_IMG
- en: An inner class instance must be tied to an outer class instance*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, when we talk about an inner *class* accessing something in the outer
    class, we’re really talking about an *instance* of the inner class accessing something
    in an *instance* of the outer class. But *which* instance?
  prefs: []
  type: TYPE_NORMAL
- en: Can *any* arbitrary instance of the inner class access the methods and variables
    of *any* instance of the outer class? **No!**
  prefs: []
  type: TYPE_NORMAL
- en: '*An **inner** object must be tied to a specific **outer** object on the heap.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![images](Images/1.png) Make an instance of the outer class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0485-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2.png) Make an instance of the inner class, by using the instance
    of the outer class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0485-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3.png) The outer and inner objects are now intimately linked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0485-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '* There’s an exception to this, for a very special case—an inner class defined
    within a static method. But we’re not going there, and you might go your entire
    Java life without ever encountering one of these.'
  prefs: []
  type: TYPE_NORMAL
- en: How to make an instance of an inner class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you instantiate an inner class from code *within* an outer class, the instance
    of the outer class is the one that the inner object will “bond” with. For example,
    if code within a method instantiates the inner class, the inner object will bond
    to the instance whose method is running.
  prefs: []
  type: TYPE_NORMAL
- en: Code in an outer class can instantiate one of its own inner classes, in exactly
    the same way it instantiates any other class...**`new MyInner()`**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0486-01.png)![image](Images/f0486-02.png)![image](Images/f0486-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Now we can get the two-button code working**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0487-01.png)![image](Images/f0487-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Java Exposed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0488-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**This week’s interview: Instance of an Inner Class**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** What makes inner classes important?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Where do I start? We give you a chance to implement the same
    interface more than once in a class. Remember, you can’t implement a method more
    than once in a normal Java class. But using *inner* classes, each inner class
    can implement the *same* interface, so you can have all these *different* implementations
    of the very same interface methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Why would you ever* want to implement the same method twice?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Let’s revisit GUI event handlers. Think about it...if you
    want* three *buttons to each have a different event behavior, then use* three
    inner classes, all implementing ActionListener—which means each class gets to
    implement its own actionPerformed method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** So are event handlers the only reason to use inner classes?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Oh, gosh no. Event handlers are just an obvious example.
    Anytime you need a separate class but still want that class to behave as if it
    were part of* another *class, an inner class is the best—and sometimes* only—way
    to do it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *I’m still confused here. If you want the inner class to* behave
    *like it belongs to the outer class, why have a separate class in the first place?
    Why wouldn’t the inner class code just be* in the outer class in the first place?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *I just* gave *you one scenario, where you need more than
    one implementation of an interface. But even when you’re not using interfaces,
    you might need two different* classes *because those classes represent two different*
    things. It’s good OO.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Whoa. Hold on here. I thought a big part of OO design is about
    reuse and maintenance. You know, the idea that if you have two separate classes,
    they can each be modified and used independently, as opposed to stuffing it all
    into one class yada yada yada. But with an* inner *class, you’re still just working
    with one* real class in the end, right? The enclosing class is the only one that’s
    reusable and separate from everybody else. Inner classes aren’t exactly reusable.
    In fact, I’ve heard them called “Reuseless—useless over and over again.”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes, it’s true that the inner class is not *as* reusable,
    in fact sometimes not reusable at all, because it’s intimately tied to the instance
    variables and methods of the outer class. But it—'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** —which only proves my point! If they’re not reusable, why bother
    with a separate class? I mean, other than the interface issue, which sounds like
    a workaround to me.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** As I was saying, you need to think about IS-A and polymorphism.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** OK. And I’m thinking about them because...'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Because the outer and inner classes might need to pass*
    different *IS-A tests! Let’s start with the polymorphic GUI listener example.
    What’s the declared argument type for the button’s listener registration method?
    In other words, if you go to the API and check, what kind of* thing (class or
    interface type) do you have to pass to the addActionListener() method?'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** You have to pass a listener. Something that implements a particular
    listener interface, in this case ActionListener. Yeah, we know all this. What’s
    your point?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *My point is that polymorphically, you have a method that
    takes only one particular* type*. Something that passes the IS-A test for ActionListener.
    But—and here’s the big thing—what if your class needs to be an IS-A of something
    that’s a* class type rather than an interface?'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Wouldn’t you have your class just* extend the class you need
    to be a part of? Isn’t that the whole point of how subclassing works? If B is
    a subclass of A, then anywhere an A is expected a B can be used. The whole pass-a-Dog-where-an-Animal-is-the-declared-type
    thing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes! Bingo! So now what happens if you need to pass the IS-A
    test for two different classes? Classes that aren’t in the same inheritance hierarchy?'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Oh, well you just...hmmm. I think I’m getting it. You can always*
    implement *more than one interface, but you can* extend *only* one *class. You
    can be only one kind of IS-A when it comes to* class types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Well done! Yes, you can’t be both a Dog and a Button. But
    if you’re a Dog that needs to sometimes be a Button (in order to pass yourself
    to methods that take a Button), the Dog class (which extends Animal so it can’t
    extend Button) can have an* inner class that acts on the Dog’s behalf as a Button,
    by extending Button, and thus wherever a Button is required, the Dog can pass
    his inner Button instead of himself. In other words, instead of saying x.takeButton(this),
    the Dog object calls x.takeButton(new MyInnerButton()).'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Can I get a clear example?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Remember the drawing panel we used, where we made our own
    subclass of JPanel? Right now, that class is a separate, non-inner, class. And
    that’s fine, because the class doesn’t need special access to the instance variables
    of the main GUI. But what if it did? What if we’re doing an animation on that
    panel, and it’s getting its coordinates from the main application (say, based
    on something the user does elsewhere in the GUI). In that case, if we make the
    drawing panel an inner class, the drawing panel class gets to be a subclass of
    JPanel, while the outer class is still free to be a subclass of something else.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Yes, I see! And the drawing panel isn’t reusable enough to be
    a separate class anyway, since what it’s actually painting is specific to this
    one GUI application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes! You’ve got it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Good. Then we can move on to the nature of the* relationship
    between you and the outer instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** What is it with you people? Not enough sordid gossip in a
    serious topic like polymorphism?'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Hey, you have no idea how much the public is willing to pay
    for some good old tabloid dirt. So, someone creates you, and you become instantly
    bonded to the outer object, is that right?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes, that’s right.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** What about the outer object? Can it be associated with any other
    inner objects?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *So now we have it. This is what you* really *wanted. Yes,
    yes. My so-called* “mate” can have as many inner objects as it wants.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Is that like, serial monogamy? Or can it have them all at the
    same time?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** All at the same time. There. Satisfied?'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Well, it does make sense. And let’s not forget, it was* you
    extolling the virtues of “multiple implementations of the same interface.” So
    it makes sense that if the outer class has three buttons, it would need three
    different inner classes (and thus three different inner class objects) to handle
    the events.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner objects:** You got it!'
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** One more question. I’ve heard that when lambdas came along,
    you were almost put out of a job?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner objects:** Ouch, that really hurts! Okay, full disclosure, there are
    many cases for which a lambda is an easier to read, more concise way to do what
    I do. But inner classes have been around for a long time, and you’re sure to encounter
    us in older code. Plus, those pesky lambdas aren’t better at everything..'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0489-01.png)![image](Images/f0490-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Lambdas to the rescue! (again)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'He’s not wrong! One way to interpret the two highlighted lines of code would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: “When the `labelButton` *ActionListener gets an event,* `setText("Ouch");`”
  prefs: []
  type: TYPE_NORMAL
- en: Not only are those two ideas separated from each other in the code, the inner
    class takes FIVE lines of code to invoke the setText method. And of course, everything
    we’ve said about the labelButton code is also true about the colorButton code.
  prefs: []
  type: TYPE_NORMAL
- en: Remember a few pages back we said that in order to implement the ActionListener
    interface you had provide code for its actionPerformed method? Hmmm...does that
    ring any bells?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0490-02.png)'
  prefs: []
  type: TYPE_IMG
- en: ActionListener is a Functional Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Remember that a lambda provides an implementation for a functional interface’s
    *one and only* abstract method.**'
  prefs: []
  type: TYPE_NORMAL
- en: Since ActionListener is a functional interface, you can replace the inner classes
    we saw on the previous page with lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0491-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Lambdas, clearer and more concise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, maybe not quite yet, but once you get used to reading lambdas, we’re pretty
    sure you’ll agree that they make your code clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Using an inner class for animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw why inner classes are handy for event listeners, because you get to implement
    the same event-handling method more than once. But now we’ll look at how useful
    an inner class is when used as a subclass of something the outer class doesn’t
    extend. In other words, when the outer class and inner class are in different
    inheritance trees!
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to make a simple animation, where the circle moves across the screen
    from the upper left down to the lower right.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**How simple animation works**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Paint an object at a particular x and y coordinate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0492-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2.png) Repaint the object at a different x and y coordinate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0492-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3.png) Repeat the previous step with changing x and y values
    for as long as the animation is supposed to continue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What we really want is something like...**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0493-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The complete simple animation code**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0494-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Did it work?**'
  prefs: []
  type: TYPE_NORMAL
- en: You might not have got the smooth animation that you expected.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do wrong?
  prefs: []
  type: TYPE_NORMAL
- en: There’s one little flaw in the paintComponent() method.
  prefs: []
  type: TYPE_NORMAL
- en: '**We need to erase what was already there! Or we might get trails.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix it, all we have to do is fill in the entire panel with the background
    color, before painting the circle each time. The code below adds two lines at
    the start of the method: one to set the color to white (the background color of
    the drawing panel) and the other to fill the entire panel rectangle with that
    color. In English, the code below says, “Fill a rectangle starting at x and y
    of 0 (0 pixels from the left and 0 pixels from the top) and make it as wide and
    as high as the panel is currently.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0495-01.png)![image](Images/f0495-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: Code Kitchen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0496-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Let’s make a music video. We’ll use Java-generated random graphics that keep
    time with the music beats.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Along the way we’ll register (and listen for) a new kind of non-GUI event,
    triggered by the music itself.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember, this part is all optional. But we think it’s good for you. And you’ll
    like it. And you can use it to impress people.
  prefs: []
  type: TYPE_NORMAL
- en: (OK, sure, it might work only on people who are really easy to impress, but
    still....)
  prefs: []
  type: TYPE_NORMAL
- en: Listening for a non-GUI event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, maybe not a music video, but we *will* make a program that draws random
    graphics on the screen with the beat of the music. In a nutshell, the program
    listens for the beat of the music and draws a random graphic rectangle with each
    beat.
  prefs: []
  type: TYPE_NORMAL
- en: 'That brings up some new issues for us. So far, we’ve listened for only GUI
    events, but now we need to listen for a particular kind of MIDI event. Turns out,
    listening for a non-GUI event is just like listening for GUI events: you implement
    a listener interface, register the listener with an event source, and then sit
    back and wait for the event source to call your event-handler method (the method
    defined in the listener interface).'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to listen for the beat of the music would be to register and
    listen for the actual MIDI events so that whenever the sequencer gets the event,
    our code will get it too and can draw the graphic. But...there’s a problem. A
    bug, actually, that won’t let us listen for the MIDI events *we’re* making (the
    ones for NOTE ON).
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have to do a little workaround. There is another type of MIDI event we
    can listen for, called a ControllerEvent. Our solution is to register for ControllerEvents
    and then make sure that for every NOTE ON event, there’s a matching ControllerEvent
    fired at the same “beat.” How do we make sure the ControllerEvent is fired at
    the same time? We add it to the track just like the other events! In other words,
    our music sequence goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 1 - NOTE ON, CONTROLLER EVENT
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 2 - NOTE OFF
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 3 - NOTE ON, CONTROLLER EVENT
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 4 - NOTE OFF
  prefs: []
  type: TYPE_NORMAL
- en: and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the full program, though, let’s make it a little easier
    to make and add MIDI messages/events since in *this* program, we’re gonna make
    a lot of them.
  prefs: []
  type: TYPE_NORMAL
- en: '**What the music art program needs to do:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Make a series of MIDI messages/events to play random
    notes on a piano (or whatever instrument you choose).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Register a listener for the events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Start the sequencer playing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/4.png) Each time the listener’s event handler method is called,
    draw a random rectangle on the drawing panel, and call repaint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We’ll build it in three iterations:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Version One: Code that simplifies making and adding
    MIDI events, since we’ll be making a lot of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Version Two: Register and listen for the events, but
    without graphics. Prints a message at the command line with each beat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Version Three: The real deal. Adds graphics to version
    two.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An easier way to make messages/events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, making and adding messages and events to a track is tedious. For
    each message, we have to make the message instance (in this case, ShortMessage),
    call setMessage(), make a MidiEvent for the message, and add the event to the
    track. In the previous chapter’s code, we went through each step for every message.
    That means eight lines of code just to make a note play and then stop playing!
    Four lines to add a NOTE ON event, and four lines to add a NOTE OFF event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Things that have to happen for each event:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Make a message instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**ShortMessage msg = new ShortMessage();**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Call setMessage() with the instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**msg.setMessage(NOTE_ON, 1, instrument, 0);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Make a MidiEvent instance for the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MidiEvent noteOn = new MidiEvent(msg, 1);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/4.png) Add the event to the track'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**track.add(noteOn);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Let’s build a static utility method that makes a message and returns a MidiEvent**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0498-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Version One: using the new static makeEvent() method'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s no event handling or graphics here, just a sequence of 15 notes that
    go up the scale. The point of this code is simply to learn how to use our new
    makeEvent() method. The code for the next two versions is much smaller and simpler
    thanks to this method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0499-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Version Two: registering and getting ControllerEvents'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0500-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Code that’s different from the previous version is highlighted in gray (and
    we’ve moved the code out of the main() method into its own go() method).**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Version Three: drawing graphics in time with the music'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final version builds on Version Two by adding the GUI parts. We build a
    frame and add a drawing panel to it, and each time we get an event, we draw a
    new rectangle and repaint the screen. The only other change from Version Two is
    that the notes play randomly as opposed to simply moving up the scale.
  prefs: []
  type: TYPE_NORMAL
- en: The most important change to the code (besides building a simple GUI) is that
    we make the drawing panel implement the ControllerEventListener rather than the
    program itself. So when the drawing panel (an inner class) gets the event, it
    knows how to take care of itself by drawing the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Complete code for this version is on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: '**The drawing panel inner class:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0501-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: A bunch of Java hotshots, in full costume, are playing the party game “Who am
    I?” They give you a clue, and you try to guess who they are, based on what they
    say. Assume they always tell the truth about themselves. If they happen to say
    something that could be true for more than one guy, then write down all for whom
    that sentence applies. Fill in the blanks next to the sentence with the names
    of one or more attendees.
  prefs: []
  type: TYPE_NORMAL
- en: Who Am I?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0504-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Tonight’s attendees:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Any of the charming personalities from this chapter just might show up!**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **I got the whole GUI, in my hands.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **Every event type has one of these.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **The listener’s key method.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **This method gives JFrame its size.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **You add code to this method but never call it.** | ______________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **When the user actually does something, it’s an _____ .** | ______________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Most of these are event sources.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **I carry data back to the listener.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **An addXxxListener( ) method says an object is an _____ .** | ______________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **How a listener signs up.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **The method where all the graphics code goes.** | ______________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **I’m typically bound to an instance.** | ______________________ |'
  prefs: []
  type: TYPE_TB
- en: '| **The “g” in (Graphics g) is really of this class.** | ______________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **The method that gets paintComponent( ) rolling.** | ______________________
    |'
  prefs: []
  type: TYPE_TB
- en: '| **The package where most of the Swingers reside.** | ______________________
    |'
  prefs: []
  type: TYPE_TB
- en: '![image](Images/arr.png) **Answers in [“Who am I?”](#who_am_iquestion_mark_left_parenthesisfr).**'
  prefs: []
  type: TYPE_NORMAL
- en: BE the Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0505-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Java file on this page represents a complete source file. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it, and if it does compile, what would it do?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/arr.png) **Answers in [“BE the Compiler”](#be_the_compiler-id00003).**'
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0506-01.png)![image](Images/f0506-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code. You **may** use the same snippet more than once, and
    you won’t need to use all the snippets. Your ***goal*** is to make a class that
    will compile and run and produce the output listed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: The Amazing, Shrinking, Blue Rectangle. This program will produce a blue rectangle
    that will shrink and shrink and disappear into a field of white.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note: Each snippet from the pool can be used more than once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/arr.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_50).**'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Who am I?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Exercise”](#exercise-id000023))
  prefs: []
  type: TYPE_NORMAL
- en: '| **I got the whole GUI, in my hands.** | JFrame |'
  prefs: []
  type: TYPE_TB
- en: '| **Every event type has one of these.** | listener interface |'
  prefs: []
  type: TYPE_TB
- en: '| **The listener’s key method.** | actionPerformed( ) |'
  prefs: []
  type: TYPE_TB
- en: '| **This method gives JFrame its size.** | setSize( ) |'
  prefs: []
  type: TYPE_TB
- en: '| **You add code to this method but never call it.** | paintComponent( ) |'
  prefs: []
  type: TYPE_TB
- en: '| **When the user actually does something, it’s an ____ .** | event |'
  prefs: []
  type: TYPE_TB
- en: '| **Most of these are event sources.** | swing components |'
  prefs: []
  type: TYPE_TB
- en: '| **I carry data back to the listener.** | event object |'
  prefs: []
  type: TYPE_TB
- en: '| **An addXxxListener( ) method says an object is an ___ .** | event source
    |'
  prefs: []
  type: TYPE_TB
- en: '| **How a listener signs up.** | addXxxListener( ) |'
  prefs: []
  type: TYPE_TB
- en: '| **The method where all the graphics code goes.** | paintComponent( ) |'
  prefs: []
  type: TYPE_TB
- en: '| **I’m typically bound to an instance.** | inner class |'
  prefs: []
  type: TYPE_TB
- en: '| **The “g” in (Graphics g) is really of this class.** | Graphics2D |'
  prefs: []
  type: TYPE_TB
- en: '| **The method that gets paintComponent( ) rolling.** | repaint( ) |'
  prefs: []
  type: TYPE_TB
- en: '| **The package where most of the Swingers reside.** | javax.swing |'
  prefs: []
  type: TYPE_TB
- en: BE the Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the Compiler”](#be_the_compiler-id00003))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0507-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Pool Puzzle”](#pool_puzzle-id00006))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Amazing, Shrinking, Blue Rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0508-01.png)'
  prefs: []
  type: TYPE_IMG
