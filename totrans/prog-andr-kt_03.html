<html><head></head><body><section data-pdf-bookmark="Chapter 3. Android Fundamentals" data-type="chapter" epub:type="chapter"><div class="chapter" id="android_fundamentals">&#13;
<h1><span class="label">Chapter 3. </span>Android Fundamentals</h1>&#13;
&#13;
&#13;
<p><a data-primary="Android fundamentals" data-type="indexterm" id="ix_ch03-asciidoc0"/>The first two chapters of this book were a whirlwind review&#13;
of the Kotlin language. This chapter will review the&#13;
environment in which we will use Kotlin: Android.</p>&#13;
&#13;
<p>Android is an operating system, like Windows and MacOS.&#13;
Unlike those two systems, Android is a Linux-based OS, like&#13;
Ubuntu and Red Hat. Unlike Ubuntu and Red Hat, though, Android has&#13;
been very heavily optimized for mobile devices—battery-powered mobile devices, in particular.</p>&#13;
&#13;
<p>The most significant of these optimizations concerns what it&#13;
means to be an application. In particular, as we will see,&#13;
Android apps have much more in common with web applications&#13;
than they do with familiar desktop applications.</p>&#13;
&#13;
<p>But we’ll get to that in a moment. First, let’s look in a&#13;
little more detail at the Android environment. We’ll&#13;
look at the operating system as a stack—kind of a layer cake.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Android Stack" data-type="sect1"><div class="sect1" id="idm46669755440496">&#13;
<h1>The Android Stack</h1>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="Android stack" data-type="indexterm" id="ix_ch03-asciidoc1"/><a data-primary="Android stack" data-type="indexterm" id="ix_ch03-asciidoc2"/>Figure 3-1 shows one way of looking at Android: as a&#13;
stack of components. Each layer in the stack has a specific&#13;
task and provides specific services; each uses the&#13;
features of the layers beneath it.</p>&#13;
&#13;
<p>Walking up from the bottom, the layers are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Hardware</p>&#13;
</li>&#13;
<li>&#13;
<p>Kernel</p>&#13;
</li>&#13;
<li>&#13;
<p>System services</p>&#13;
</li>&#13;
<li>&#13;
<p>Android Runtime Environment</p>&#13;
</li>&#13;
<li>&#13;
<p>Applications</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="android_architecture">&#13;
<img alt="pawk 0301" src="assets/pawk_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>The Android stack.</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hardware" data-type="sect2"><div class="sect2" id="idm46669755428896">&#13;
<h2>Hardware</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="hardware" data-type="indexterm" id="idm46669755427664"/><a data-primary="Android stack" data-secondary="hardware" data-type="indexterm" id="idm46669755426688"/><a data-primary="hardware" data-type="indexterm" id="idm46669755425744"/>Beneath the Android stack, of course, is hardware: a&#13;
piece of warm silicon. While the hardware is not part of the&#13;
Android stack, it is important to recognize that the hardware&#13;
for which Android was designed imposes some fairly tough&#13;
constraints on the system. By far, the most significant of&#13;
these constraints is power. Most common operating systems&#13;
just assume an infinite power supply. The Android systems&#13;
cannot.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kernel" data-type="sect2"><div class="sect2" id="idm46669755424256">&#13;
<h2>Kernel</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="kernel" data-type="indexterm" id="idm46669755423088"/><a data-primary="Android stack" data-secondary="kernel" data-type="indexterm" id="idm46669755422112"/><a data-primary="kernel" data-type="indexterm" id="idm46669755421168"/>The Android operating system depends on the Linux kernel. A&#13;
kernel is responsible for providing the basic services that&#13;
developers expect: a filesystem, threads and processes,&#13;
network access, interfaces to hardware devices, and so on.&#13;
Linux is free and open source and, thus, a popular choice&#13;
for hardware and device manufacturers.</p>&#13;
&#13;
<p>Because it is based on Linux, Android bears some similarity&#13;
to the common Linux distributions: Debian, Centos,&#13;
etc. In the layers above the kernel, however, the similarity&#13;
diminishes. While most common Linux distributions are based&#13;
heavily on the GNU family of system software (and should,&#13;
properly, be called GNU/Linux), Android’s system software is&#13;
quite a bit different. It is, in general, not possible to&#13;
run common Linux applications directly on an Android system.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="System Services" data-type="sect2"><div class="sect2" id="idm46669755418896">&#13;
<h2>System Services</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="system services" data-type="indexterm" id="idm46669755417696"/><a data-primary="Android stack" data-secondary="system services" data-type="indexterm" id="idm46669755416720"/><a data-primary="system services" data-type="indexterm" id="idm46669755415776"/>The system services layer is big and complex. It includes a&#13;
wide variety of utilities, from code that runs as part of&#13;
the kernel (drivers or kernel modules), and long-running&#13;
applications that manage various housekeeping tasks&#13;
(daemons), to libraries that implement standard functions&#13;
like cryptography and media presentation.</p>&#13;
&#13;
<p>This layer includes several system services that are unique&#13;
to Android. Among them are <a data-primary="Binder" data-type="indexterm" id="idm46669755414256"/>Binder, Android’s essential&#13;
interprocess communication system;<a data-primary="ART" data-type="indexterm" id="idm46669755413424"/> ART, which has replaced&#13;
Dalvik as Android’s analog of the Java VM; and Zygote,&#13;
Android’s application container.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android Runtime Environment" data-type="sect2"><div class="sect2" id="idm46669755412160">&#13;
<h2>Android Runtime Environment</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="runtime environment" data-type="indexterm" id="idm46669755411024"/><a data-primary="Android stack" data-secondary="runtime environment" data-type="indexterm" id="idm46669755409824"/><a data-primary="runtime environment" data-type="indexterm" id="idm46669755408880"/>The layer above the system services is the implementation of&#13;
the <em>Android Runtime Environment</em>. The Android Runtime Environment is&#13;
the collection of libraries that you use from your&#13;
application by including them with <code>import</code> statements:&#13;
<em>android.view</em>, <em>android.os</em>, and so on. They are the&#13;
services provided by the layers below, made available to your&#13;
application. They are interesting because they are&#13;
implemented using two languages: usually Java and C or C++.</p>&#13;
&#13;
<p>The part of the implementation that your application imports&#13;
is likely to be written in Java. The Java code, however,&#13;
uses the<a data-primary="Java Native Interface (JNI)" data-type="indexterm" id="idm46669755405584"/> <em>Java Native Interface</em> (JNI) to invoke native&#13;
code, usually written in C or C++. It is the native&#13;
code that actually interacts with the system services.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Applications" data-type="sect2"><div class="sect2" id="idm46669755403840">&#13;
<h2>Applications</h2>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="basics" data-type="indexterm" id="idm46669755402640"/><a data-primary="Android fundamentals" data-secondary="applications" data-type="indexterm" id="idm46669755401664"/><a data-primary="Android stack" data-secondary="applications" data-type="indexterm" id="idm46669755400720"/>Finally, at the top of the stack are Android applications.&#13;
Applications, in the Android universe, are actually part&#13;
of the stack. They are made up of individually addressable&#13;
components that other applications can “call.” The Dialer,&#13;
Camera, and Contacts programs are all examples of Android&#13;
applications that are used as services by other&#13;
applications.</p>&#13;
&#13;
<p>This is the environment in which an Android application&#13;
executes. So let’s get back to looking at the anatomy of an&#13;
application itself.<a data-startref="ix_ch03-asciidoc2" data-type="indexterm" id="idm46669755398736"/><a data-startref="ix_ch03-asciidoc1" data-type="indexterm" id="idm46669755398032"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Android Application Environment" data-type="sect1"><div class="sect1" id="idm46669755439872">&#13;
<h1>The Android Application Environment</h1>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="environment" data-type="indexterm" id="ix_ch03-asciidoc3"/><a data-primary="Android fundamentals" data-secondary="application environment" data-type="indexterm" id="ix_ch03-asciidoc4"/><a data-primary="application environment" data-type="indexterm" id="ix_ch03-asciidoc5"/>Android applications are programs translated from a source&#13;
language (Java or Kotlin) into a transportable intermediate&#13;
language, <a data-primary="DEX" data-type="indexterm" id="idm46669755392112"/>DEX. The DEX code is installed on a device and&#13;
interpreted by the ART VM, when the application is run.</p>&#13;
&#13;
<p>Nearly every developer is familiar with the standard&#13;
application environment. The operating system creates a&#13;
“process”—a sort of virtual computer that appears to&#13;
belong entirely to the application. The system runs the&#13;
application code in the process, where it appears to have&#13;
its own memory, its own processors, and so on, completely&#13;
independent of other applications that might be running on&#13;
the same device. The application runs until it, itself, decides to&#13;
stop.</p>&#13;
&#13;
<p>That’s not how Android works. Android doesn’t really think&#13;
in terms of applications. For instance, Android apps don’t&#13;
contain the equivalent of Java’s <code>public static void main</code>&#13;
method, the method used to start typical Java applications.&#13;
Instead, Android apps are libraries of components. The&#13;
Android runtime,<a data-primary="Zygote" data-type="indexterm" id="idm46669755389248"/> Zygote, manages processes, lifecycles, and&#13;
so on. It calls an application’s components only when it&#13;
needs them. This makes Android apps, as hinted earlier, very&#13;
similar to web applications: they are an assemblage of&#13;
components deployed into a container.</p>&#13;
&#13;
<p>The other end of the lifecycle, terminating an application,&#13;
is perhaps even more interesting. On other operating&#13;
systems, abruptly stopping an application (<code>kill -9</code> or “Force&#13;
Quit”) is something that happens rarely and only when the&#13;
application misbehaves. On Android, it is the most common&#13;
way for an application to be terminated. Nearly every&#13;
running app will eventually be terminated abruptly.</p>&#13;
&#13;
<p>As with most web app frameworks, components are implemented&#13;
as subclasses of template base classes. Component subclasses&#13;
override the methods that are called by the framework in&#13;
order to provide application-specific behavior. Often, the&#13;
superclass has important work to do when one of these&#13;
template methods is called. In those cases, the overriding&#13;
method in the subclass must call the superclass method that&#13;
it overrides.</p>&#13;
&#13;
<p>Android supports four types of components:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Activity</p>&#13;
</li>&#13;
<li>&#13;
<p>Service</p>&#13;
</li>&#13;
<li>&#13;
<p>Broadcast receiver</p>&#13;
</li>&#13;
<li>&#13;
<p>Content provider</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Just as in a web app, the implementations of these&#13;
components must be registered in a manifest: an XML file.&#13;
Android’s manifest file is called, perhaps unsurprisingly,&#13;
<em>AndroidManifest.xml</em>. The Android container parses this&#13;
file as part of loading an application.  The application&#13;
components (not some overarching application) are the basic&#13;
units of the Android app. They are individually addressable&#13;
and may be published individually for use by other applications.</p>&#13;
&#13;
<p>So, how does an application target an Android component? With&#13;
an <code>Intent</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Intents and Intent Filters" data-type="sect2"><div class="sect2" id="idm46669755379136">&#13;
<h2>Intents and Intent Filters</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="intents and intent filters" data-type="indexterm" id="idm46669755377600"/><a data-primary="application environment" data-secondary="intents/intent filters" data-type="indexterm" id="idm46669755376608"/><a data-primary="intents/intent filters" data-type="indexterm" id="idm46669755375664"/>In Android, components are started with <code>Intent</code>s. An&#13;
<code>Intent</code> is a small packet that names the component that it&#13;
targets. It has some extra room in which it can indicate a&#13;
specific action that it would like the receiving component&#13;
to take and a few parameters to the request. One&#13;
can think of an intent as a function call: the name of the&#13;
class, the name of a particular function within that class,&#13;
and the parameters to the call. The intent is delivered by&#13;
the system to the target component. It is up to the&#13;
component to perform the requested service.</p>&#13;
&#13;
<p>It is interesting to note that, in keeping with its&#13;
component-oriented architecture, Android doesn’t actually&#13;
have any way of starting an application. Instead, clients&#13;
start a component, perhaps the <code>Activity</code> that is registered as&#13;
main for an application whose icon a user just tapped on the&#13;
Launcher page. If the application that owns the activity is&#13;
not already running, it will be started as a side effect.</p>&#13;
&#13;
<p>An intent can name its target explicitly, as shown here:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">context</code><code class="p">.</code><code class="n">startActivity</code><code class="p">(</code>&#13;
  <code class="n">Intent</code><code class="p">(</code><code class="n">context</code><code class="p">,</code> <code class="n">MembersListActivity</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">)))</code></pre>&#13;
&#13;
<p>This code fires an <code>Intent</code> at the <code>Activity</code>&#13;
<code>MembersListActivity</code>. Note that the call, <code>startActivity</code>&#13;
here, must agree with the type of the component being&#13;
started: an <code>Activity</code> in this case. There are other,&#13;
similar methods for firing intents at other kinds of&#13;
components (<code>startService</code> for a <code>Service</code>, and so on).</p>&#13;
&#13;
<p>The <code>Intent</code> fired by this line of code is called an<a data-primary="explicit intent" data-type="indexterm" id="idm46669755357104"/>&#13;
<em>explicit intent</em> because it names a specific, unique class,&#13;
in a unique application (identified by a <code>Context</code>,&#13;
discussed in a moment), to which the <code>Intent</code> is to be&#13;
delivered.</p>&#13;
&#13;
<p>Because they identify a unique, specific target, explicit&#13;
intents are faster and more secure than implicit ones. There&#13;
are places that the Android system, for reasons related to&#13;
security, requires the use of explicit intents. Even when they&#13;
are not required, explicit intents should be preferred whenever&#13;
possible.</p>&#13;
&#13;
<p>Within an application, a component can always be reached&#13;
with an explicit intent. A component from another&#13;
application that is publicly visible can also always be&#13;
reached explicitly.  So why ever use an implicit intent?&#13;
Because implicit intents allow dynamic resolution of a&#13;
request.</p>&#13;
&#13;
<p>Imagine that the email application you’ve had on your&#13;
phone for years allows editing messages with an external&#13;
editor. We now can guess that it does this by firing an&#13;
intent that might look something like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">intent</code> <code class="p">=</code> <code class="n">Intent</code><code class="p">(</code><code class="n">Intent</code><code class="p">.</code><code class="n">ACTION_EDIT</code><code class="p">))</code>&#13;
<code class="n">intent</code><code class="p">.</code><code class="n">setDataAndType</code><code class="p">(</code><code class="n">textToEditUri</code><code class="p">,</code> <code class="n">textMimeType</code><code class="p">);</code>&#13;
<code class="n">startActivityForResult</code><code class="p">(</code><code class="n">intent</code><code class="p">,</code> <code class="n">reqId</code><code class="p">);</code></pre>&#13;
&#13;
<p>The target specified in this intention is <em>not</em> explicit. The&#13;
<code>Intent</code> specifies neither a <code>Context</code> nor the&#13;
fully qualified name of a component within a context. The&#13;
intent is <em>implicit</em> and Android will allow any component at&#13;
all to register to handle it.</p>&#13;
&#13;
<p>Components register for implicit intents using an<a data-primary="IntentFilter" data-type="indexterm" id="idm46669755306528"/>&#13;
<code>IntentFilter</code>. In fact, the “Awesome Code Editor” that you&#13;
happen to have installed just 15 minutes ago&#13;
registers for exactly the intent shown in the preceding code, by including an&#13;
<code>IntentFilter</code> like this in its manifest:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;manifest</code> <code class="err">...</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;application</code>&#13;
    <code class="na">android:label=</code><code class="s">"@string/awesome_code_editor"</code><code class="nt">&gt;</code>&#13;
    ...&gt;&#13;
    <code class="nt">&lt;activity</code>&#13;
      <code class="na">android:name=</code><code class="s">".EditorActivity"</code>&#13;
      <code class="na">android:label=</code><code class="s">"@string/editor"</code><code class="nt">&gt;</code>&#13;
      <code class="nt">&lt;intent-filter&gt;</code>&#13;
        <code class="nt">&lt;action</code>&#13;
          <code class="na">android:name=</code><code class="s">"android.intent.action.EDIT"</code> <code class="nt">/&gt;</code>&#13;
        <code class="nt">&lt;category</code>&#13;
          <code class="na">android:name=</code><code class="s">"android.intent.category.TEXT"</code> <code class="nt">/&gt;</code>&#13;
      <code class="nt">&lt;/intent-filter&gt;</code>&#13;
    <code class="nt">&lt;/activity&gt;</code>&#13;
  <code class="nt">&lt;/application&gt;</code>&#13;
<code class="nt">&lt;/manifest&gt;</code></pre>&#13;
&#13;
<p>As you can see, the intent filter matches the intent that&#13;
the email application fires.</p>&#13;
&#13;
<p>When Android installs the Awesome Code Editor application it&#13;
parses the application manifest and notices that the&#13;
<code>EditorActivity</code> claims to be able to handle an <code>EDIT</code>&#13;
action for the category <code>android.intent.category.TEXT</code> (see&#13;
more in the <a href="https://oreil.ly/oJNkY">Android Developers documentation</a>).&#13;
It remembers that fact.</p>&#13;
&#13;
<p>The next time your email program requests an editor, Android&#13;
will include Awesome Code Editor in the list of editors it&#13;
offers for your use. You have just upgraded your email&#13;
program simply by installing another application. Talk about&#13;
awesome!</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Android gradually increased restrictions on the use of&#13;
implicit intents in recent releases. Because they can be&#13;
intercepted by any randomly installed application, despite&#13;
their power, implicit intents are not secure.  Recent&#13;
versions of Android have imposed strict&#13;
new constraints on their use. In particular, as of v30,&#13;
it is not possible to register for many implicit intents&#13;
in the manifest.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Context" data-type="sect2"><div class="sect2" id="idm46669755378480">&#13;
<h2>Context</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="context" data-type="indexterm" id="ix_ch03-asciidoc6"/><a data-primary="application environment" data-secondary="context" data-type="indexterm" id="ix_ch03-asciidoc7"/><a data-primary="context" data-type="indexterm" id="ix_ch03-asciidoc8"/>Because Android components are just subsystems run in a&#13;
larger container, they need some way of referring to the&#13;
container so that they can request services from it. From&#13;
within a component, the container is visible as a <code>Context</code>.&#13;
<code>Context</code>s come in a couple of flavors: component&#13;
and application.  Let’s have a look at each of them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Component context" data-type="sect3"><div class="sect3" id="idm46669755208016">&#13;
<h3>Component context</h3>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="component context" data-type="indexterm" id="idm46669755206480"/><a data-primary="application environment" data-secondary="component context" data-type="indexterm" id="idm46669755205504"/><a data-primary="context" data-secondary="component" data-type="indexterm" id="idm46669755204560"/>We’ve already seen a call like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">context</code><code class="p">.</code><code class="n">startActivity</code><code class="p">(</code>&#13;
  <code class="n">Intent</code><code class="p">(</code><code class="n">context</code><code class="p">,</code> <code class="n">MembersListActivity</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">)))</code></pre>&#13;
&#13;
<p>This call uses a <code>Context</code> twice. First, starting an&#13;
<code>Activity</code> is a function that a component requests from the&#13;
framework, the <code>Context</code>. In this case, it called the <code>Context</code> method&#13;
<code>startActivity</code>. Next, in order to make the intent explicit,&#13;
the component must identify the unique package that contains&#13;
the component it wants to start. The <code>Intent</code>’s constructor uses&#13;
the <code>context</code> passed as its first argument to get a unique&#13;
name for the application to which the <code>context</code> belongs: this call&#13;
starts an <code>Activity</code> that belongs to this application.</p>&#13;
&#13;
<p>The <code>Context</code> is an abstract class that provides access to&#13;
various resources, including:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Starting other components</p>&#13;
</li>&#13;
<li>&#13;
<p>Accessing system services</p>&#13;
</li>&#13;
<li>&#13;
<p>Accessing <code>SharedPreferences</code>, resources, and files</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Two of the Android components,<a data-primary="Activity context" data-type="indexterm" id="idm46669755186096"/> <code>Activity</code> and<a data-primary="Service" data-type="indexterm" id="idm46669755184960"/> <code>Service</code>, are&#13;
themselves <code>Context</code>s. In addition to being <code>Context</code>s,&#13;
they are also components that the Android container expects&#13;
to manage. This can lead to problems, all of which are&#13;
variations on the code shown in <a data-type="xref" href="#activity_leak">Example 3-1</a>.</p>&#13;
<div data-type="example" id="activity_leak">&#13;
<h5><span class="label">Example 3-1. </span>Do NOT do this!</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MainActivity</code> <code class="p">:</code> <code class="n">AppCompatActivity</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
    <code class="k">var</code> <code class="py">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">context</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="n">context</code> <code class="p">=</code> <code class="k">this</code>  <code class="c1">// NO!</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Our developer has decided that it would be really handy to&#13;
be able to say things like&#13;
<code>MainActivity.context.startActivity(...)</code> anywhere in their&#13;
application. In order to do that, they’ve stored a reference to&#13;
an <code>Activity</code> in a global variable, where it will be&#13;
accessible for the entire life of the application. What&#13;
could go wrong?</p>&#13;
&#13;
<p>There are two things that could go wrong, one bad and the&#13;
other horrible. Bad is when the Android framework knows that the <code>Activity</code> is no longer needed, and&#13;
would like to free it up for garbage collection, but it cannot do so.&#13;
The reference in that companion object will prevent the&#13;
<code>Activity</code> from being released, for the entire lifetime of&#13;
the application. The <code>Activity</code> has been leaked.&#13;
<code>Activity</code>s are large objects and leaking&#13;
their memory is no small matter.</p>&#13;
&#13;
<p>The second (far worse) thing, that could go wrong is that a&#13;
call to a method on the cached <code>Activity</code> could fail&#13;
catastrophically. As we will explain shortly, once the&#13;
framework decides that an <code>Activity</code> is no longer being used,&#13;
it discards it. It is done with it and will never use it&#13;
again. As a result, the object may be put into an inconsistent&#13;
state. Calling methods on it may lead to failures that are&#13;
both difficult to diagnose and reproduce.</p>&#13;
&#13;
<p>While the problem in that bit of code is pretty easy to see,&#13;
there are variants that are much more subtle. The following code&#13;
may have a similar problem:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?)</code> <code class="p">{</code>&#13;
  <code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code>&#13;
  <code class="c1">// ...</code>&#13;
  <code class="n">NetController</code><code class="p">.</code><code class="n">refresh</code><code class="p">(</code><code class="k">this</code><code class="o">::</code><code class="n">update</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It is harder to see, but the callback <code>this::update</code> is a&#13;
reference to a method on <code>this</code>, the <code>Activity</code> that&#13;
contains this <code>onCreate</code> method. Once <code>onCreate</code> completes,&#13;
the &#13;
<span class="keep-together"><code>NetController</code></span> holds a reference to this <code>Activity</code>&#13;
that does not honor its lifecycle and can incur either of&#13;
the problems described earlier.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Application context" data-type="sect3"><div class="sect3" id="idm46669755207392">&#13;
<h3>Application context</h3>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="application context" data-type="indexterm" id="idm46669755050096"/><a data-primary="application environment" data-secondary="application context" data-type="indexterm" id="idm46669755048896"/><a data-primary="ApplicationContext" data-type="indexterm" id="idm46669755047952"/><a data-primary="context" data-secondary="application" data-type="indexterm" id="idm46669755016576"/>There is another kind of context. When Android starts an&#13;
application, it usually creates a singleton instance of the&#13;
<code>Application</code> class. That instance is a <code>Context</code> and,&#13;
though it has a lifecycle, that lifecycle is essentially&#13;
congruent with the lifecycle of the application. Because it&#13;
is long-lived, it is quite safe to hold references to it&#13;
in other long-lived places. This code, similar to the&#13;
dangerous code shown earlier, is fairly safe because the <code>context</code> to&#13;
which it stores a reference is the <code>ApplicationContext</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">SafeApp</code> <code class="p">:</code> <code class="n">Application</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
    <code class="k">var</code> <code class="py">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">context</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="n">context</code> <code class="p">=</code> <code class="k">this</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Be sure to remember that, in order for the Android system to&#13;
use the custom subclass of <code>Application</code> instead of its&#13;
default, the <code>SafeApp</code> class must be registered in the&#13;
manifest, like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;manifest</code> <code class="err">...</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;application</code>&#13;
    <code class="na">android:name=</code><code class="s">".SafeApp"</code>&#13;
    <code class="err">...</code><code class="nt">&gt;</code>&#13;
    ...&#13;
  <code class="nt">&lt;/application&gt;</code>&#13;
<code class="nt">&lt;/manifest&gt;</code></pre>&#13;
&#13;
<p>Now, when the framework creates the <code>ApplicationContext</code> it&#13;
will be an instance of <code>SafeApp</code> instead of the instance of&#13;
<code>Application</code> that it would have used otherwise.</p>&#13;
&#13;
<p>There is another way to get the <code>ApplicationContext</code> as well.&#13;
Calling the <a data-primary="Context.getApplicationContext() method" data-type="indexterm" id="idm46669754933632"/>method &#13;
<span class="keep-together"><code>Context.getApplicationContext()</code></span> on any context at all, including the &#13;
<span class="keep-together"><code>ApplicationContext</code></span> itself, will always return the long-lived application context. &#13;
<span class="keep-together">But here’s</span> the bad news: the &#13;
<span class="keep-together"><code>ApplicationContext</code></span> is not a magic bullet. An &#13;
<span class="keep-together"><code>ApplicationContext</code></span> is not an <code>Activity</code>.&#13;
Its implementations of <code>Context</code> methods behave differently&#13;
from those of <code>Activity</code>. For instance, and probably most annoying,&#13;
you cannot launch <code>Activity</code> from an <code>ApplicationContext</code>.&#13;
There is a &#13;
<span class="keep-together"><code>startActivity</code></span> method on <code>ApplicationContext</code>,&#13;
but it simply generates an error message in all but a very&#13;
limited set of circumstances<a data-startref="ix_ch03-asciidoc8" data-type="indexterm" id="idm46669754925232"/><a data-startref="ix_ch03-asciidoc7" data-type="indexterm" id="idm46669754924528"/><a data-startref="ix_ch03-asciidoc6" data-type="indexterm" id="idm46669754923856"/>.<a data-startref="ix_ch03-asciidoc5" data-type="indexterm" id="idm46669754923056"/><a data-startref="ix_ch03-asciidoc4" data-type="indexterm" id="idm46669754922352"/><a data-startref="ix_ch03-asciidoc3" data-type="indexterm" id="idm46669754895568"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android Application Components: The Building Blocks" data-type="sect1"><div class="sect1" id="idm46669755396640">&#13;
<h1>Android Application Components: The Building Blocks</h1>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="components of" data-type="indexterm" id="ix_ch03-asciidoc9"/><a data-primary="Android fundamentals" data-secondary="application components" data-type="indexterm" id="ix_ch03-asciidoc10"/>Finally, we can narrow our focus to the components&#13;
themselves, the essence of an application.</p>&#13;
&#13;
<p>The lifecycles of Android application components are&#13;
managed by the Android framework, which creates and destroys&#13;
them according to its needs. Note that this absolutely&#13;
includes instantiation! Application code must <em>never</em> create&#13;
a new instance of a component.</p>&#13;
&#13;
<p>Recall that there are four types of components:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Activity</p>&#13;
</li>&#13;
<li>&#13;
<p>Service</p>&#13;
</li>&#13;
<li>&#13;
<p>Broadcast receiver</p>&#13;
</li>&#13;
<li>&#13;
<p>Content provider</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Remember, also, that the following descriptions are nothing more than&#13;
brief overviews, perhaps calling attention to potential&#13;
pitfalls or features of interest. The <a href="https://oreil.ly/PJABc">Android Developers documentation</a> is extensive, complete, and authoritative.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Activity and Its Friends" data-type="sect2"><div class="sect2" id="idm46669754884096">&#13;
<h2>The Activity and Its Friends</h2>&#13;
&#13;
<p><a data-primary="Activity component" data-type="indexterm" id="ix_ch03-asciidoc11"/><a data-primary="Android applications" data-secondary="Activity component" data-type="indexterm" id="ix_ch03-asciidoc12"/><a data-primary="Android fundamentals" data-secondary="Activity component" data-type="indexterm" id="ix_ch03-asciidoc13"/>An <code>Activity</code> component manages a single page of an application’s UI.&#13;
It is Android’s analog of a web application servlet. It uses&#13;
Android’s rich library of “widgets” to draw a single,&#13;
interactive page. Widgets (buttons, text boxes, and the like)&#13;
are the basic UI elements, and they combine a screen&#13;
representation with the input collection that gives the&#13;
widgets behavior.  We’ll discuss them in detail shortly.</p>&#13;
&#13;
<p>As mentioned previously, it is important to understand that&#13;
an <code>Activity</code> is not an application! Activities are&#13;
ephemeral and guaranteed to exist only while the page that&#13;
they manage is visible. When that page becomes invisible,&#13;
either because the application presents a different page or&#13;
because the user, for instance, takes a phone call, there is&#13;
no guarantee that Android will preserve either the&#13;
<code>Activity</code> instance or any of the state that it represents.</p>&#13;
&#13;
<p><a data-type="xref" href="#activity_lifecycle">Figure 3-2</a> shows the&#13;
state machine that controls the lifecycle of an <code>Activity</code>.&#13;
The methods—shown as state transitions—come in pairs and are&#13;
the bookends of the four states that an <code>Activity</code>&#13;
may assume: <em>destroyed</em>, <em>created</em>, <em>started</em>, and&#13;
<em>running</em>. The methods are called strictly in order. After a&#13;
call to <code>onStart</code>, for instance, Android will make only one&#13;
of two possible calls: <code>onResume</code>, to enter the next state,&#13;
or <code>onStop</code>, to revert to the previous state.</p>&#13;
&#13;
<figure><div class="figure" id="activity_lifecycle">&#13;
<img alt="pawk 0302" src="assets/pawk_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>The <code>Activity</code> lifecycle.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first pair of bookends are <code>onCreate</code> and <code>onDestroy</code>.&#13;
Between them, an <code>Activity</code> is said to be <em>created</em>. When&#13;
Android instantiates a new <code>Activity</code>, it calls its&#13;
<code>onCreate</code> method nearly immediately. Until it does so, the&#13;
<code>Activity</code> is in an inconsistent state and most of its&#13;
functions will not work. Note, in particular, that most of&#13;
an &#13;
<span class="keep-together"><code>Activity</code>’s</span> functionality is, inconveniently, not&#13;
available from its constructor.</p>&#13;
&#13;
<p><a data-primary="onCreate" data-type="indexterm" id="idm46669754863712"/>The <code>onCreate</code> method is the ideal place to do any&#13;
initialization that an <code>Activity</code> needs to do only once.&#13;
This almost always includes setting up the view hierarchy&#13;
(usually by inflating an XML layout), installing view&#13;
controllers or presenters, and wiring up text and touch&#13;
listeners.</p>&#13;
&#13;
<p><code>Activity</code>s, similarly, should not be used after the call&#13;
to their <code>onDestroy</code> method. The <code>Activity</code> is, again, in an&#13;
inconsistent state and the Android framework will make no&#13;
further use of it. (It will not, for instance, call&#13;
<code>onCreate</code> to revivify it.) Beware, though: <a data-primary="onDestroy" data-type="indexterm" id="idm46669754859280"/>the <code>onDestroy</code>&#13;
method is not necessarily the best place to perform&#13;
essential finalization! Android calls <code>onDestroy</code> only on a&#13;
best-effort basis. It is entirely possible that an&#13;
application will be terminated before all of an <code>Activity</code>s’.&#13;
<code>onDestroy</code> methods have completed.</p>&#13;
&#13;
<p>An <code>Activity</code> can be destroyed from within its own program by&#13;
calling its<a data-primary="finish() method" data-type="indexterm" id="idm46669754855776"/> <code>finish()</code> method.</p>&#13;
&#13;
<p>The next pair of methods are <code>onStart</code> and <code>onStop</code>. The&#13;
former, <code>onStart</code>, will only ever be called on an <code>Activity</code>&#13;
that is in the created state. It moves the <code>Activity</code> to its&#13;
on-deck state, called <em>started</em>. A started <code>Activity</code> may&#13;
be partially visible behind a &#13;
<span class="keep-together">dialog</span> or another app that&#13;
only incompletely fills the screen. In started state,  &#13;
<span class="keep-together">an <code>Activity</code></span> should be completely painted but should not expect&#13;
user input. A &#13;
<span class="keep-together">well-written</span> <code>Activity</code> will not run&#13;
animations or other resource-hogging tasks while it is in&#13;
the started state.</p>&#13;
&#13;
<p>The <code>onStop</code> method will only be called on a started&#13;
<code>Activity</code>. It returns it to the created state.</p>&#13;
&#13;
<p>The final pair of methods are <code>onResume</code> and <code>onPause</code>.&#13;
Between them, an <code>Activity</code>’s page is in focus on the device&#13;
and the target of user input. It is said to be <em>running</em>.&#13;
Again, these methods will only be called on an <code>Activity</code>&#13;
that is in the started or running state, respectively.</p>&#13;
&#13;
<p>Along with <code>onCreate</code>, <code>onResume</code> and <code>onPause</code> are the most&#13;
important in the lifecycle of an <code>Activity</code>. They are where&#13;
the page comes to life, starting, say, data updates,&#13;
animations, and all of the other things that make a UI feel&#13;
responsive.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>It is a good practice to respect the pairing of these methods: a beginning method and an end method. If you start something running in the beginning method of the pair, stop it in the end method of the same pair. Trying to start, say, network polling in <code>onResume</code> and stop it in <code>onStop</code> is a recipe for hard-to-find bugs.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fragments" data-type="sect3"><div class="sect3" id="idm46669754838864">&#13;
<h3>Fragments</h3>&#13;
&#13;
<p><a data-primary="Activity component" data-secondary="fragments" data-type="indexterm" id="idm46669754837488"/><a data-primary="Android applications" data-secondary="fragments" data-type="indexterm" id="idm46669754836512"/><a data-primary="fragments" data-type="indexterm" id="idm46669754835568"/><code>Fragment</code>s are an afterthought added to Android’s stable of&#13;
component-like features only at version 3 (Honeycomb,&#13;
2011). They can feel a bit “bolted on.” They were introduced&#13;
as a way of making it possible to share UI implementations&#13;
across screens with shapes and sizes so different that it&#13;
affects navigation: in particular, phones and tablets.</p>&#13;
&#13;
<p><code>Fragment</code>s are not <code>Context</code>s. Though they hold a&#13;
reference to an underlying &#13;
<span class="keep-together"><code>Activity</code></span> for most of their&#13;
lifecycle, <code>Fragment</code>s are not registered in&#13;
the manifest. They are instantiated in application code and&#13;
cannot be started with <code>Intent</code>s. They are also quite&#13;
complex. Compare <a data-type="xref" href="#fragment_view_lifecycle">Figure 3-3</a>, the state&#13;
diagram for a <code>Fragment</code>, to that of an <code>Activity</code>!</p>&#13;
&#13;
<p>A thorough discussion of how (or, for that matter, even whether)&#13;
to use <code>Fragment</code>s is well outside the scope of this book.&#13;
Briefly, however, one might think of a <code>Fragment</code> as something&#13;
like an <em>iframe</em> on a web page: almost an <code>Activity</code> embedded in an &#13;
<span class="keep-together"><code>Activity</code>.</span> They are complete, logical UI units that can be assembled in different ways to form a page.</p>&#13;
&#13;
<p>As shown, <code>Fragment</code>s have lifecycles that are&#13;
similar to (though more complex than) those of an&#13;
<code>Activity</code>. However, a <code>Fragment</code> is only useful when it is&#13;
attached to an <code>Activity</code>. This is the main reason that a&#13;
<code>Fragment</code> lifecycle is more complex: its state can&#13;
be affected by changes in the state of the <code>Activity</code> to&#13;
which it is attached.</p>&#13;
&#13;
<p>Also, just as an <code>Activity</code> is programmatically accessible&#13;
in the inconsistent state before its <code>onCreate</code> method is&#13;
called, so a <code>Fragment</code> is programmatically accessible&#13;
before it is attached to an <code>Activity</code>. <code>Fragment</code>s must be&#13;
used with great care before their <code>onAttach</code> and&#13;
<code>onCreateView</code> methods have been called.</p>&#13;
&#13;
<figure><div class="figure" id="fragment_view_lifecycle">&#13;
<img alt="The Back Store store Activities FILO." src="assets/pawk_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span><code>Fragment</code> lifecycle.</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The back stack" data-type="sect3"><div class="sect3" id="idm46669754816304">&#13;
<h3>The back stack</h3>&#13;
&#13;
<p><a data-primary="Activity component" data-secondary="back stack" data-type="indexterm" id="idm46669754814768"/><a data-primary="Android applications" data-secondary="back stack" data-type="indexterm" id="idm46669754813792"/><a data-primary="back stack" data-type="indexterm" id="idm46669754812848"/>Android supports a navigation paradigm sometimes called&#13;
<em>card-deck</em> navigation. Navigating to a new page stacks&#13;
that page on top of the previous page. When a user&#13;
presses a back button the current page is popped from&#13;
the stack to reveal the one that previously held the screen.&#13;
This paradigm is fairly intuitive for most human users: push&#13;
new cards on top; pop them off to get back to where you&#13;
were.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#back_stack_activities">Figure 3-4</a>, the current <code>Activity</code> is the&#13;
one named SecondActivity. Pushing the back button will&#13;
cause the <code>Activity</code> named MainActivity to take the screen.</p>&#13;
&#13;
<p>Note that, unlike a web browser, Android does not support&#13;
<em>forward</em> navigation. Once the user pushes the back button,&#13;
there is no simple navigational device that will allow them&#13;
to return to the popped page. Android uses this fact to&#13;
infer that it can destroy SecondActivity (in this case),&#13;
should it need the resources.</p>&#13;
&#13;
<figure><div class="figure" id="back_stack_activities">&#13;
<img alt="pawk 0304" src="assets/pawk_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>The back stack stores an <code>Activity</code>’s pages in last in, first out (LIFO) order.</h6>&#13;
</div></figure>&#13;
&#13;
<p><code>Fragment</code>s can also go on the back stack as part of a fragment&#13;
transaction, as shown in <a data-type="xref" href="#back_stack_fragments">Figure 3-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="back_stack_fragments">&#13;
<img alt="pawk 0305" src="assets/pawk_0305.png"/>&#13;
<h6><span class="label">Figure 3-5. </span>A <code>Fragment</code> transaction, on the back stack, will be reverted before the &#13;
<span class="keep-together"><code>Activity</code></span> that contains it is popped.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Adding a fragment to the back stack can be particularly useful&#13;
when combined with tagging, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Add the new tab fragment</code>&#13;
<code class="n">supportFragmentManager</code><code class="p">.</code><code class="n">beginTransaction</code><code class="p">()</code>&#13;
    <code class="p">.</code><code class="n">replace</code><code class="p">(</code>&#13;
        <code class="n">R</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">fragment_container</code><code class="p">,</code>&#13;
        <code class="n">SomeFragment</code><code class="p">.</code><code class="n">newInstance</code><code class="p">())</code>&#13;
    <code class="p">.</code><code class="n">addToBackStack</code><code class="p">(</code><code class="n">FRAGMENT_TAG</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">commit</code><code class="p">()</code></pre>&#13;
&#13;
<p>This code creates a new instance of <code>SomeFragment</code> and adds&#13;
it to the back stack, tagged with the identifier&#13;
<code>FRAGMENT_TAG</code> (a string constant). As shown in the following code, you can&#13;
use <code>supportFragmentManager</code> to pop <em>everything</em> off the&#13;
back stack, all the way to the tag:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">manager</code><code class="p">.</code><code class="n">popBackStack</code><code class="p">(</code>&#13;
    <code class="n">FRAGMENT_TAG</code><code class="p">,</code>&#13;
    <code class="n">FragmentManager</code><code class="p">.</code><code class="n">POP_BACK_STACK_INCLUSIVE</code><code class="p">)</code></pre>&#13;
&#13;
<p>When the back stack is empty, pushing the back button&#13;
returns the user to the Launcher.<a data-startref="ix_ch03-asciidoc13" data-type="indexterm" id="idm46669754740096"/><a data-startref="ix_ch03-asciidoc12" data-type="indexterm" id="idm46669754739488"/><a data-startref="ix_ch03-asciidoc11" data-type="indexterm" id="idm46669754738880"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Services" data-type="sect2"><div class="sect2" id="idm46669754883632">&#13;
<h2>Services</h2>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="services" data-type="indexterm" id="ix_ch03-asciidoc14"/><a data-primary="Android fundamentals" data-secondary="services" data-type="indexterm" id="ix_ch03-asciidoc15"/><a data-primary="services" data-type="indexterm" id="ix_ch03-asciidoc16"/>A <code>Service</code> is an Android component that is, almost exactly,&#13;
an <code>Activity</code> with no UI. That may sound a bit odd, given&#13;
that an <code>Activity</code>’s sole reason for existence is that it&#13;
manages the UI!</p>&#13;
&#13;
<p>Android was designed for hardware that is much different&#13;
from that which is common now. The first Android phone, the&#13;
HTC Dream, was announced in September of 2008. It had very&#13;
little physical memory (192 MB) and did not support virtual&#13;
memory at all. It could run no more than a handful of&#13;
applications simultaneously. Android’s designers needed a&#13;
way to know when an application was not doing useful work so&#13;
that they could reclaim its memory for other uses.</p>&#13;
&#13;
<p>It’s easy to figure out when an <code>Activity</code> is not doing&#13;
useful work. It has only one job: to manage a visible page. If&#13;
applications were composed only of <code>Activity</code>s, it would be&#13;
easy to tell when one was no longer useful and could be&#13;
terminated. When none of an application’s <code>Activity</code>s are&#13;
visible, the application is not doing anything useful and can&#13;
be reclaimed.  It’s that simple.</p>&#13;
&#13;
<p>The problem comes when an application needs to perform long-running tasks that are not attached to any UI: monitoring&#13;
location, synchronizing a dataset over the network, and so&#13;
on. While Android is definitely prejudiced toward “if the&#13;
user can’t see it, why do it?” it grudgingly acknowledges&#13;
the existence of long-running tasks and invented <code>Service</code>s to handle them.</p>&#13;
&#13;
<p>While <code>Service</code>s still have their uses, much of the work&#13;
that they were designed to do, back on earlier versions of&#13;
Android with its more limited hardware, can now be done using&#13;
other techniques. Android’s <code>WorkManager</code> is a terrific way&#13;
to manage repeating tasks. There are also other, simpler and more&#13;
maintainable ways of running tasks in the background, on a&#13;
worker thread. Something as simple as a singleton class may&#13;
be sufficient.</p>&#13;
&#13;
<p>Service components still exist, though, and still have&#13;
important roles to play.</p>&#13;
&#13;
<p>There are, actually, two different kinds of <code>Service</code>:&#13;
<em>bound</em> and <em>started</em>. Despite the fact that the <code>Service</code>&#13;
base class is, confusingly, the template for both, the two&#13;
types are completely orthogonal. A single <code>Service</code> can be&#13;
either or both.</p>&#13;
&#13;
<p>Both types of <code>Service</code> have<a data-primary="onCreate" data-type="indexterm" id="idm46669754696896"/><a data-primary="onDestroy" data-type="indexterm" id="idm46669754696160"/> <code>onCreate</code> and <code>onDestroy</code>&#13;
methods that behave exactly as they do for an <code>Activity</code>.&#13;
Since a <code>Service</code> has no UI, it does not need any of an&#13;
&#13;
<span class="keep-together"><code>Activity</code>’s</span> other templated methods.</p>&#13;
&#13;
<p>Services do have other templated methods, though.  Which of&#13;
them a specific <code>Service</code> implements depends on whether it&#13;
is started or bound.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Started Services" data-type="sect3"><div class="sect3" id="idm46669754691632">&#13;
<h3>Started Services</h3>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="started services" data-type="indexterm" id="idm46669754690224"/><a data-primary="services" data-secondary="started" data-type="indexterm" id="idm46669754689248"/><a data-primary="started services" data-type="indexterm" id="idm46669754688304"/>A <em>started</em> <code>Service</code> is initiated by sending it an <code>Intent</code>.&#13;
While it is possible to create a started service that&#13;
returns a value, doing so is inelegantly complex and&#13;
probably indicative of a design that could be improved. For&#13;
the most part, started services are fire-and-forget:&#13;
something like “put this in the database” or “send this out&#13;
to the net.”</p>&#13;
&#13;
<p>To start a service, send it an intent. The intent must name&#13;
the service, probably explicitly by passing the current&#13;
context and the service class. If the service provides&#13;
multiple functions, of course, the intent may also indicate&#13;
which of them it is intended to invoke. It might also supply&#13;
parameters appropriate for the call.</p>&#13;
&#13;
<p>The service receives the intent as the argument to a call&#13;
from the Android framework, to the method&#13;
<code>Service.onStart</code>. Note that this is not done in the “background”! The&#13;
<code>onStart</code> method runs on the main/UI thread. The <code>onStart</code>&#13;
method parses the <code>Intent</code> content and processes the&#13;
contained request appropriately.</p>&#13;
&#13;
<p>A well-behaved started <code>Service</code> will call &#13;
<span class="keep-together"><code>Service.stopSelf()</code></span> whenever it completes its work.&#13;
 This call is similar to <code>Activity.finish()</code>: it lets the framework know that the <code>Service</code> instance is no longer performing useful work and can be reclaimed. Modern versions of Android actually pay&#13;
very little attention to whether a service has stopped&#13;
itself or not. <code>Service</code>s are suspended and, possibly even&#13;
terminated, using less voluntary criteria (see the <a href="https://oreil.ly/yGloh">Android Developers documentation</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bound Services" data-type="sect3"><div class="sect3" id="bound_services">&#13;
<h3>Bound Services</h3>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="bound services" data-type="indexterm" id="ix_ch03-asciidoc17"/><a data-primary="bound services" data-type="indexterm" id="ix_ch03-asciidoc18"/><a data-primary="services" data-secondary="bound" data-type="indexterm" id="ix_ch03-asciidoc19"/>A <em>bound</em> <code>Service</code> is Android’s IPC&#13;
mechanism. Bound services provide a communication channel between a&#13;
client and a server that is process agnostic: the two ends&#13;
may or may not be part of the same application. Bound services—or at least the communication channels&#13;
they provide—are at the very heart of Android. They are&#13;
the mechanism through which applications send tasks to&#13;
system services.</p>&#13;
&#13;
<p>A bound service, itself, actually does very little. It is&#13;
just the factory for a <code>Binder</code>, a half-duplex IPC channel.&#13;
While a complete description of the Binder IPC channels and&#13;
their use is beyond the scope of this book, their structure will be&#13;
familiar to users of any of the other common IPC mechanisms.&#13;
<a data-type="xref" href="#interprocess_communication">Figure 3-6</a> illustrates the &#13;
<span class="keep-together">system.</span></p>&#13;
&#13;
<p>Typically, a service provides a <em>proxy</em> that looks like a simple&#13;
function call. The proxy <em>marshals</em> an identifier for the&#13;
requested service (essentially, the function name) and its&#13;
parameters, by converting them to data that can be transmitted&#13;
over the connection: usually aggregates of very simple data types&#13;
like integers and strings. The marshaled data is communicated, in&#13;
this case via the Binder kernel module, to a <em>stub</em> provided&#13;
by the bound service that is the target of the connection.</p>&#13;
&#13;
<figure><div class="figure" id="interprocess_communication">&#13;
<img alt="pawk 0306" src="assets/pawk_0306.png"/>&#13;
<h6><span class="label">Figure 3-6. </span>Binder IPC.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The stub <em>unmarshals</em> the data, converting it back into a function&#13;
call to the service implementation. Notice that the proxy function&#13;
and the service implementation function have the same signature:&#13;
they implement the same interface (IService, as shown in <a data-type="xref" href="#interprocess_communication">Figure 3-6</a>).</p>&#13;
&#13;
<p>Android makes <em>extensive</em> use of this mechanism in the implementation&#13;
of system services. Functions that are actually calls to remote&#13;
processes are a fundamental part of Android.</p>&#13;
&#13;
<p>An instance of the class <code>ServiceConnection</code> represents a connection to a bound service. The following code demonstrates its use:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">abstract</code> <code class="k">class</code> <code class="nc">BoundService</code><code class="p">&lt;</code><code class="n">T</code> <code class="p">:</code> <code class="n">Service</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">ServiceConnection</code> <code class="p">{</code>&#13;
    <code class="k">abstract</code> <code class="k">class</code> <code class="nc">LocalBinder</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">T</code> <code class="p">:</code> <code class="n">Service</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">Binder</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">abstract</code> <code class="k">val</code> <code class="py">service</code><code class="p">:</code> <code class="n">T</code><code class="p">?</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">var</code> <code class="py">service</code><code class="p">:</code> <code class="n">T</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
&#13;
    <code class="k">protected</code> <code class="k">abstract</code> <code class="k">val</code> <code class="py">intent</code><code class="p">:</code> <code class="n">Intent</code><code class="p">?</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">bind</code><code class="p">(</code><code class="n">ctxt</code><code class="p">:</code> <code class="n">Context</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">ctxt</code><code class="p">.</code><code class="n">bindService</code><code class="p">(</code><code class="n">intent</code><code class="p">,</code> <code class="k">this</code><code class="p">,</code> <code class="n">Context</code><code class="p">.</code><code class="n">BIND_AUTO_CREATE</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">unbind</code><code class="p">(</code><code class="n">ctxt</code><code class="p">:</code> <code class="n">Context</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">service</code> <code class="p">=</code> <code class="k">null</code>&#13;
        <code class="n">ctxt</code><code class="p">.</code><code class="n">unbindService</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">onServiceConnected</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">ComponentName</code><code class="p">,</code> <code class="n">binder</code><code class="p">:</code> <code class="n">IBinder</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">service</code> <code class="p">=</code> <code class="p">(</code><code class="n">binder</code> <code class="k">as</code><code class="p">?</code> <code class="n">LocalBinder</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;)</code><code class="o">?.</code><code class="n">service</code>&#13;
        <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"BS"</code><code class="p">,</code> <code class="s">"bound: ${service}"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">onServiceDisconnected</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">ComponentName</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">service</code> <code class="p">=</code> <code class="k">null</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A subclass of <code>BoundService</code> provides the type of the&#13;
service that will be bound, and an <code>Intent</code> that&#13;
targets it.</p>&#13;
&#13;
<p>The client side initiates a connection using the <code>bind</code>&#13;
call. In response, the framework initiates a connection to&#13;
the remote bound service object.  The remote framework calls&#13;
the bound service’s <code>onBind</code> method with the intent.  The&#13;
bound service creates and returns an implementation of&#13;
<code>IBinder</code> that is also an implementation of the interface&#13;
the client requested.  Note that this is often a&#13;
reference to the bound service itself. In other words, the <code>Service</code> is often not only the factory but&#13;
also the &#13;
<span class="keep-together">implementation.</span></p>&#13;
&#13;
<p>The service side uses the implementation provided by the&#13;
bound service to create &#13;
<span class="keep-together">the remote-side</span> stub. It then notifies&#13;
the client side that it’s ready. The client-side framework&#13;
creates the proxy and then finally calls the <code>ServiceConnection</code>’s&#13;
&#13;
<span class="keep-together"><code>onServiceConnected</code></span> method. The client now holds a live connection to the remote service. Profit!</p>&#13;
&#13;
<p>As one might guess from the presence of an&#13;
<code>onServiceDisconnected</code> method, a client can lose the&#13;
connection to a bound service at any time.  Though the&#13;
notification is usually immediate, it is definitely possible for a&#13;
client call to a service to fail even before it receives&#13;
a disconnect notification.</p>&#13;
&#13;
<p>Like a started service, bound service code does not run in the&#13;
background.  Unless explicitly made to do otherwise, bound&#13;
service code runs on the application’s main thread. This can&#13;
be confusing, though, because a bound service might run on the&#13;
main thread of a <em>different</em> application.</p>&#13;
&#13;
<p>If the code in a service implementation must run on a&#13;
background thread, it is the service implementation that is&#13;
responsible for arranging that.  Client calls to a bound&#13;
service, while asynchronous, cannot control the thread on&#13;
which the service itself runs.</p>&#13;
&#13;
<p>Services, like every other component, must be registered in&#13;
the application manifest<a data-startref="ix_ch03-asciidoc19" data-type="indexterm" id="idm46669754455392"/><a data-startref="ix_ch03-asciidoc18" data-type="indexterm" id="idm46669754454688"/><a data-startref="ix_ch03-asciidoc17" data-type="indexterm" id="idm46669754454016"/>:<a data-startref="ix_ch03-asciidoc16" data-type="indexterm" id="idm46669754453216"/><a data-startref="ix_ch03-asciidoc15" data-type="indexterm" id="idm46669754452512"/><a data-startref="ix_ch03-asciidoc14" data-type="indexterm" id="idm46669754451840"/></p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;manifest</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;application...&gt;</code>&#13;
    <code class="nt">&lt;service</code> <code class="na">android:name=</code><code class="s">".PollService"</code><code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;/application&gt;</code>&#13;
<code class="nt">&lt;/manifest&gt;</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Content Providers" data-type="sect2"><div class="sect2" id="idm46669754678192">&#13;
<h2>Content Providers</h2>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="content providers" data-type="indexterm" id="idm46669754443392"/><a data-primary="Android fundamentals" data-secondary="content providers" data-type="indexterm" id="idm46669754442192"/><a data-primary="content providers" data-type="indexterm" id="idm46669754441248"/>A <code>ContentProvider</code> is a REST-like interface to data held by&#13;
an application. Because it is an API, not simply direct&#13;
access to data, a <code>ContentProvider</code> can exercise very&#13;
fine-grained control over what it publishes and to whom it&#13;
publishes it. External applications get access to a&#13;
<code>ContentProvider</code> using a Binder IPC interface, through&#13;
which the <code>ContentProvider</code> can obtain information about the&#13;
querying process, the permissions it holds, and the type of&#13;
access it requests.</p>&#13;
&#13;
<p>Early Android applications often shared data simply by&#13;
putting it into publicly accessible files. Even then,&#13;
Android encouraged the use of <code>ContentProvider</code>s instead.&#13;
More recent versions of Android, in the interests of&#13;
security, have made it difficult to share files directly,&#13;
making <code>ContentProvider</code>s more relevant.</p>&#13;
<div class="jetpack" data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>While <code>ContentProvider</code>s provide access to stored data, you&#13;
must have some kind  of data store from which to read and&#13;
write the data. Android Jetpack offers the Room persistence&#13;
library as an option. As described in its official&#13;
documentation, Room provides “an abstraction layer to allow&#13;
for more robust  access while harnessing the full power of&#13;
SQLite.”</p>&#13;
&#13;
<p>For more information on how to save data in a local database using Room, check out the <a href="https://oreil.ly/9OwGH">Android Developers documentation</a>.</p>&#13;
</div>&#13;
&#13;
<p>One particularly interesting capability of a&#13;
<code>ContentProvider</code> is that it can pass an open file to&#13;
another program. The requesting program need not have any&#13;
way to access the file directly using a file path. The&#13;
<code>ContentProvider</code> can construct the file it passes in any&#13;
way that it wants. By passing an open file, though, the&#13;
&#13;
<span class="keep-together"><code>ContentProvider</code></span> moves itself out of the loop. It gives the&#13;
requesting program direct access to the data.  Neither the&#13;
<code>ContentProvider</code> nor any other IPC mechanism remains&#13;
between the client and the data.  The client simply reads&#13;
the file just as if it had opened that file itself.</p>&#13;
&#13;
<p>An application publishes a <code>ContentProvider</code>, as usual,&#13;
by declaring it in the application manifest:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;application...&gt;</code>&#13;
  <code class="nt">&lt;provider</code>&#13;
   <code class="na">android:name=</code><code class="s">"com.oreilly.kotlin.example.MemberProvider"</code>&#13;
   <code class="na">android:authorities=</code><code class="s">"com.oreilly.kotlin.example.members"</code>&#13;
   <code class="na">android:readPermission=</code><code class="s">"com.oreilly.kotlin.example.members.READ"</code><code class="nt">/&gt;</code>&#13;
 <code class="nt">&lt;/application&gt;</code></pre>&#13;
&#13;
<p class="pagebreak-before">This XML element says that the application contains the class&#13;
named &#13;
<span class="keep-together"><code>com.oreilly.kotlin.example.MemberProvider</code></span>, which has to be a subclass of &#13;
<span class="keep-together"><code>android.content.ContentProvider</code></span>. The&#13;
element declares that &#13;
<span class="keep-together"><code>MemberProvider</code></span> is the&#13;
authority for any requests for data from the URL&#13;
<em>content://com.oreilly.kotlin​​.exam⁠⁠ple.members</em>. Finally, the&#13;
declaration mandates that requesting applications must hold the&#13;
permission “com.oreilly.kotlin.example.members.READ” in&#13;
order to get any access at all and that even then they will get only&#13;
read access.</p>&#13;
&#13;
<p><code>ContentProvider</code>s have exactly the API one would expect from&#13;
a REST interface:</p>&#13;
<dl>&#13;
<dt><code>query()</code></dt>&#13;
<dd>&#13;
<p><a data-primary="query()" data-type="indexterm" id="idm46669754390320"/>This fetches data from a particular table.</p>&#13;
</dd>&#13;
<dt><code>insert()</code></dt>&#13;
<dd>&#13;
<p>This inserts a new row within a content provider and returns the content URI.</p>&#13;
</dd>&#13;
<dt><code>update()</code></dt>&#13;
<dd>&#13;
<p>This updates the fields of an existing row and returns the number of rows &#13;
<span class="keep-together">updated.</span></p>&#13;
</dd>&#13;
<dt><code>delete()</code></dt>&#13;
<dd>&#13;
<p>This deletes existing rows and returns the number of rows deleted.</p>&#13;
</dd>&#13;
<dt><code>getType()</code></dt>&#13;
<dd>&#13;
<p>This returns the MIME data type for the given Content URI.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The <code>ContentProvider</code> for <code>MemberProvider</code> would probably&#13;
implement only the first of these methods, because it is&#13;
read-only.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Broadcast Receivers" data-type="sect2"><div class="sect2" id="idm46669754381600">&#13;
<h2>Broadcast Receivers</h2>&#13;
&#13;
<p><a data-primary="Android applications" data-secondary="broadcast receivers" data-type="indexterm" id="idm46669754353904"/><a data-primary="Android fundamentals" data-secondary="broadcast receivers" data-type="indexterm" id="idm46669754352992"/><a data-primary="broadcast receivers" data-type="indexterm" id="idm46669754352048"/>The original concept for a <code>BroadcastReceiver</code> was as a kind&#13;
of data bus. Listeners could subscribe in order to get&#13;
notification of events that were of interest. As the system&#13;
has come of age, however, <code>BroadcastReceiver</code>s have proved&#13;
to be too expensive and too prone to security problems to&#13;
be used pervasively.  They remain mostly a tool used by the system&#13;
to signal applications of important events.</p>&#13;
&#13;
<p>Perhaps the most common use of a <code>BroadcastReceiver</code> is as a&#13;
way of starting an application, even if there has been no&#13;
user request to do so.</p>&#13;
&#13;
<p>The <code>Intent</code> <code>android.intent.action.BOOT_COMPLETED</code> is broadcast by the Android system once the OS&#13;
is stable, after a system restart. An application could&#13;
register to receive this broadcast, like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;receiver</code> <code class="na">android:name=</code><code class="s">".StartupReceiver"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;intent-filter&gt;</code>&#13;
        <code class="nt">&lt;action</code> <code class="na">android:name=</code><code class="s">"android.intent.action.BOOT_COMPLETED"</code><code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;/intent-filter&gt;</code>&#13;
<code class="nt">&lt;/receiver&gt;</code></pre>&#13;
&#13;
<p>If an application does this, its <code>StartupReceiver</code> will be started, to&#13;
receive the &#13;
<span class="keep-together"><code>BOOT_COMPLETED</code></span> <code>Intent</code> broadcast when the OS is rebooted. As&#13;
noted earlier, a side effect of starting the&#13;
<code>StartupReceiver</code> is that the application that contains&#13;
the receiver is also started.</p>&#13;
&#13;
<p>Applications have used this as a way of creating a<a data-primary="daemon" data-type="indexterm" id="idm46669754337696"/> <em>daemon</em>: an&#13;
app that is always &#13;
<span class="keep-together">running.</span>  While a hack and fragile&#13;
(even in early Android, behavior changed from version to version),&#13;
this trick worked well enough that many, many applications used&#13;
it.  Even as Android version 26 introduced some fairly&#13;
radical changes in background process management&#13;
(<code>BroadcastReceiver</code>s cannot be registered for implicit&#13;
broadcasts &#13;
<span class="keep-together">in their</span> manifests; they must instead register them&#13;
dynamically using &#13;
<span class="keep-together"><code>Context.registerReceiver</code>),</span>&#13;
developers continue to find ways to use it.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There are exceptions to the Android 26 implicit intent rule. &#13;
<span class="keep-together">Receiving</span> SMS messaging, changing locale, detecting USB devices, and &#13;
<span class="keep-together">a few</span> other intents are <em>permitted</em>, and applications may register &#13;
<span class="keep-together">for them,</span> in their manifests. <code>ACTION_USB_ACCESSORY_ATTACHED</code>, <code>ACTION_CONNECTION_STATE_CHANGED</code>, and our dear old friend <code>ACTION_BOOT_COMPLETED</code> are among the permitted intents. For more, check out the <a href="https://oreil.ly/PMNhM">Android Developers documentation</a>.</p>&#13;
</div>&#13;
&#13;
<p><code>Activity</code>, <code>Service</code>, <code>ContentProvider</code>, and <code>BroadcastReceiver</code> are the four components that are the essential&#13;
building blocks of an Android application. As Android has&#13;
grown and improved, it has introduced new abstractions that&#13;
obscure these basic mechanisms. A modern Android&#13;
application may use only one or two of these building&#13;
blocks directly, and many developers will never code a&#13;
<code>ContentProvider</code> or a <code>BroadcastReceiver</code>.</p>&#13;
&#13;
<p>The essential lesson here, which bears&#13;
repeating, is that an Android app is not an “application”&#13;
in the traditional sense.  It is more like a web&#13;
application: a collection of components that provide&#13;
services to a framework when requested to do so.<a data-startref="ix_ch03-asciidoc10" data-type="indexterm" id="idm46669754296448"/><a data-startref="ix_ch03-asciidoc9" data-type="indexterm" id="idm46669754295744"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android Application Architectures" data-type="sect1"><div class="sect1" id="idm46669754894624">&#13;
<h1>Android Application Architectures</h1>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="application architectures" data-type="indexterm" id="ix_ch03-asciidoc20"/>So far, in this chapter we’ve discussed the Android system architecture. While understanding that architecture is essential for any serious Android developer, it is not sufficient for understanding how to write resilient, bug-free Android programs. As evidence of this, one need only look at the many tools and abstractions that have been&#13;
tried and abandoned over the years of Android’s existence. Time and experience, though, have honed the Android playbook and made the path to a robust, maintainable application much easier to follow.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MVC: The Foundation" data-type="sect2"><div class="sect2" id="idm46669754291936">&#13;
<h2>MVC: The Foundation</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="MVC" data-type="indexterm" id="idm46669754290592"/><a data-primary="Model–View–Controller (MVC) pattern" data-type="indexterm" id="idm46669754289616"/><a data-primary="MVC (Model–View–Controller) pattern" data-type="indexterm" id="idm46669754288976"/>The original pattern for applications with a UI was called Model–View–Controller (MVC). The innovation that the pattern introduced was a guarantee that the view—what was rendered on the screen—was always consistent. It did this by insisting on a unidirectional cycle for data flow.</p>&#13;
&#13;
<p>It all starts with the user. They see something on the screen<a data-primary="View" data-type="indexterm" id="idm46669754287472"/> (the <em>View</em>: I told you it was a cycle!) and, in response to what they see, take some action. They touch the screen, type something, speak, whatever. They do something that will change the state of the application.</p>&#13;
&#13;
<p>Their input is fielded by the<a data-primary="Controller" data-type="indexterm" id="idm46669754285504"/> <em>Controller</em>. The Controller has two responsibilities. First, it orders the user’s input. For any given user event—say, tapping the “stop” button—all other user events happen either before that tap or after it. No two events are ever processed at the same time.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The implication that the Controller is single-threaded is one of the most important aspects of the original MVC pattern. Prior multithreaded strategies (including Java’s Abstract Window Toolkit [AWT]) often produced a nightmare of deadlocks as messages traveling in opposite directions—from the user and to the user—tried to seize the same locks in different orders.</p>&#13;
</div>&#13;
&#13;
<p>The Controller’s second&#13;
responsibility is to translate user input into operations on&#13;
a <em>Model</em>.</p>&#13;
&#13;
<p>The <a data-primary="Model, defined" data-type="indexterm" id="idm46669754281072"/>Model is the business logic of an application.  It&#13;
probably combines some kind of persistent data store and&#13;
perhaps a network connection with rules for combining and&#13;
interpreting the input from the Controller.  In the ideal&#13;
MVC architecture, it is the only component that holds the&#13;
current state of the application.</p>&#13;
&#13;
<p>The Model, again, ideally is allowed to send only one&#13;
message to the View: “things have changed.”  When the View&#13;
receives such a message it does its job.  It requests the&#13;
application state from the Model, interprets it, and renders&#13;
it on the screen. What it renders is always a consistent&#13;
snapshot of the Model. At this point, the user can see the&#13;
new state and take new actions in response.  The cycle&#13;
continues.</p>&#13;
&#13;
<p>While the MVC pattern was fairly revolutionary when it was&#13;
introduced, there is room for improvement.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Widgets" data-type="sect2"><div class="sect2" id="idm46669754278400">&#13;
<h2>Widgets</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="widgets" data-type="indexterm" id="idm46669754277200"/><a data-primary="widgets" data-type="indexterm" id="idm46669754276000"/>As we mentioned earlier in the context of the <code>Activity</code>&#13;
component, a widget is a single class that combines a&#13;
View component with a Controller component.  After the preceding&#13;
discussion of the MVC pattern and its emphasis on&#13;
separating the two, it may seem odd to find classes like&#13;
<code>Button</code>, <code>TextBox</code>, and <code>RadioButton</code> that clearly combine the&#13;
two.</p>&#13;
&#13;
<p>Widgets do not break MVC architecture.  There is still, in&#13;
each widget, distinct View and Controller code.  The&#13;
Controller portion of a widget never talks directly to the&#13;
View, and the View does not receive events from the&#13;
Controller. The sections are independent; they are just&#13;
bundled together into a single handy container.</p>&#13;
&#13;
<p>Combining the two functions just seems fairly obvious.  What&#13;
is the use of the image of a button, that can be placed&#13;
anywhere on the screen, if it doesn’t respond to clicks?  It&#13;
just makes sense that the renderer for the UI components,&#13;
and the mechanism that handles input for it, be part of the&#13;
same component.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Local Model" data-type="sect2"><div class="sect2" id="idm46669754271568">&#13;
<h2>The Local Model</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="Local Model" data-type="indexterm" id="idm46669754270368"/><a data-primary="Local Model" data-type="indexterm" id="idm46669754269392"/>With the advent of the Web, browsers, and the long delay&#13;
required for an entire MVC cycle, developers began to see&#13;
the need for keeping the state of the screen as a separate,&#13;
UI-Local Model.  Developers have, over time, referred to&#13;
this component using several names, depending on&#13;
other features of the design pattern in which it is being&#13;
used. To avoid confusion, we will refer to it, for the&#13;
rest of this chapter, as the <em>Local Model</em>.</p>&#13;
&#13;
<p>The use of a Local Model gives rise to a new pattern that is&#13;
sort of a two-layer MVC—it has even been referred to as the&#13;
“Figure Eight” pattern. When the user takes an action, the&#13;
Controller updates the Local Model instead of the Model,&#13;
because a Model update may be a network connection away.&#13;
The Local Model is not business logic. It represents, as&#13;
simply as possible, the state of the View: which buttons are&#13;
on, which are off, what text is in which box, and the color and&#13;
length of the bars in the graph.</p>&#13;
&#13;
<p>The Local Model does two things in response to an action.&#13;
First it notifies the View that things have changed so that&#13;
the View can rerender the screen from the new Local Model&#13;
state. In addition, though, with code that is analogous to&#13;
the simple MVC’s Controller, the Local Model forwards the state&#13;
changes to the Model. In response, the Model eventually&#13;
notifies—this time the Local Model—that there has been&#13;
an update and that the Local Model should sync itself.&#13;
This probably results in a second request that the View&#13;
update itself.<a data-startref="ix_ch03-asciidoc20" data-type="indexterm" id="idm46669754265824"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android Patterns" data-type="sect1"><div class="sect1" id="idm46669754264864">&#13;
<h1>Android Patterns</h1>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="patterns" data-type="indexterm" id="ix_ch03-asciidoc21"/><a data-primary="patterns, Android" data-type="indexterm" id="ix_ch03-asciidoc22"/>In Android, regardless of the pattern, an <code>Activity</code> object—or possibly its cousin, a <code>Fragment</code>—takes the role of&#13;
the View. This is more or less mandated by the structure of&#13;
the <code>Activity</code> object: it is the thing that owns the screen&#13;
and it is the thing that has access to the widgets that&#13;
comprise the view.  Over time, though, as is appropriate for&#13;
an MVC-based UI, <code>Activity</code> objects have gotten simpler and&#13;
simpler.  In a modern Android application, it is likely that&#13;
an <code>Activity</code> will do little more than inflate the view,&#13;
delegate events inbound from the user to the Local Model,&#13;
and observe Local Model state that is of interest, redrawing&#13;
itself in response to updates.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Model–View–Intent" data-type="sect2"><div class="sect2" id="idm46669754258384">&#13;
<h2>Model–View–Intent</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="Model–View–Intent" data-type="indexterm" id="idm46669754257184"/><a data-primary="Model–View–Intent (MVI) pattern" data-type="indexterm" id="idm46669754255984"/><a data-primary="MVI (Model–View–Intent) pattern" data-type="indexterm" id="idm46669754255344"/><a data-primary="patterns, Android" data-secondary="Model–View–Intent" data-type="indexterm" id="idm46669754254704"/>One of the oldest versions of MVC adopted by the Android&#13;
community was called Model–View–Intent. The pattern&#13;
decouples the <code>Activity</code> from a Model by using <code>Intent</code>s&#13;
and their payloads. While this structure produces excellent&#13;
component isolation, it can be quite slow and the code for&#13;
constructing the <code>Intents</code> quite bulky. Although it is still&#13;
used successfully, newer patterns have largely supplanted&#13;
it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Model–View–Presenter" data-type="sect2"><div class="sect2" id="idm46669754251840">&#13;
<h2>Model–View–Presenter</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="Model–View–Presenter" data-type="indexterm" id="idm46669754250496"/><a data-primary="Model–View–Presenter (MVP) pattern" data-type="indexterm" id="idm46669754249552"/><a data-primary="MVP (Model–View–Presenter) pattern" data-type="indexterm" id="idm46669754248864"/><a data-primary="patterns, Android" data-secondary="Model–View–Presenter" data-type="indexterm" id="idm46669754248176"/>A goal for all of these MVC-based patterns is to loosen&#13;
the coupling among the three components and to make&#13;
information flow unidirectionally. In a naive implementation,&#13;
though, the View and the Local Model each hold a reference&#13;
to the other.  Perhaps the View gets an instance of the&#13;
Local Model from some sort of factory and then registers&#13;
with it. Though subtle—and regardless of the&#13;
apparent direction in which information flows—holding&#13;
a reference to an object of a specific type is coupling.</p>&#13;
&#13;
<p>Over the past few years, there have been several refinements&#13;
to the MVC pattern in an attempt to reduce this coupling.&#13;
While these refinements have often resulted in better code,&#13;
the distinctions among them, and the very names&#13;
used to identify them, have not always been clear.</p>&#13;
&#13;
<p>One of the earliest refinements replaces the View and&#13;
Local Model references to each other with references to&#13;
interfaces. The pattern is often called Model–View–Presenter (MVP). In&#13;
implementations of this pattern, the Local Model holds a&#13;
reference, not to the View <code>Activity</code>, but simply to the&#13;
implementation of some interface.  The interface describes&#13;
the minimal set of operations that the Local Model can&#13;
expect from its peer. It has, essentially, no knowledge that&#13;
the View is a View: it sees only operations for updating&#13;
information.</p>&#13;
&#13;
<p>The View proxies user input events to its Presenter. The&#13;
Presenter, as described earlier, responds to the events,&#13;
updating Local Model and Model state as necessary. It then&#13;
notifies the View that it needs to redraw itself. Because&#13;
the Presenter knows exactly what changes have taken place, it may be&#13;
able to request that the View update only affected sections,&#13;
instead of forcing a redraw of the entire screen.</p>&#13;
&#13;
<p>The most important attribute of this architecture, however, is&#13;
that the Presenter (this architecture’s name for the Local&#13;
Model) can be unit tested. Tests need only mock the the&#13;
interface that the View provides to the Presenter to&#13;
completely isolate it from the View. Extremely thin views&#13;
and testable Presenters lead to much more robust&#13;
&#13;
<span class="keep-together">applications.</span></p>&#13;
&#13;
<p>But it is possible to do even better than this.  The Local Model&#13;
might hold no references to the View at all!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Model–View–ViewModel" data-type="sect2"><div class="sect2" id="idm46669754241648">&#13;
<h2>Model–View–ViewModel</h2>&#13;
&#13;
<p><a data-primary="Android fundamentals" data-secondary="Model–View–View Model" data-type="indexterm" id="idm46669754240144"/><a data-primary="Model–View–View Model (MVVM) pattern" data-type="indexterm" id="idm46669754239152"/><a data-primary="MVVM (Model–View–View Model) pattern" data-type="indexterm" id="idm46669754238384"/><a data-primary="patterns, Android" data-secondary="Model–View–View Model" data-type="indexterm" id="idm46669754237680"/>Google, with its introduction of Jetpack, supports an&#13;
architecture called Model–View–ViewModel (MVVM).&#13;
Because it’s supported, internally, by the modern Android&#13;
framework, it is the most common and most discussed pattern&#13;
for modern Android apps.</p>&#13;
&#13;
<p>In the MVVM pattern, as usual, either an <code>Activity</code> or a&#13;
<code>Fragment</code> takes the role of the View.  The View code will&#13;
be as simple as it is possible to make it, often contained&#13;
entirely within the <code>Activity</code> or <code>Fragment</code> subclass.&#13;
Perhaps some complex views will need separate classes for&#13;
image rendering or a <code>RecyclerView</code>. Even these, though,&#13;
will be instantiated and installed in the view, directly by&#13;
the <code>Activity</code> or <code>Fragment</code>.</p>&#13;
&#13;
<p>The ViewModel is responsible for wiring together the&#13;
commands necessary to update the View and the backend&#13;
Model. The novel feature of this pattern is that a&#13;
single interface, <code>Observable</code>, is used to transmit changes&#13;
in the state of the Local Model to the View.</p>&#13;
&#13;
<p>Instead of the multiple Presenter interfaces used in the&#13;
MVP pattern, the ViewModel represents viewable data&#13;
as a collection of <code>Observable</code>s.  The View simply&#13;
registers as an observer for these observables and reacts to&#13;
notifications of  changes in the data they contain.</p>&#13;
&#13;
<p>The Jetpack library calls these <code>Observable</code>s <a data-primary="LiveData" data-type="indexterm" id="idm46669754229568"/><code>LiveData</code>. A&#13;
<code>LiveData</code> object is an observable data holder class with a&#13;
single generified interface that notifies subscribers of&#13;
changes in the underlying data.</p>&#13;
&#13;
<p>Like MVP, MVVM makes mocking and unit testing easy. The&#13;
important new feature that MVVM introduces is lifecycle&#13;
awareness.</p>&#13;
&#13;
<p>The keen reader will have noticed that the version&#13;
of the MVP pattern described earlier does <em>exactly</em> the&#13;
thing we warned against in <a data-type="xref" href="#activity_leak">Example 3-1</a>: it stores the&#13;
reference to an <code>Activity</code>, an object with an Android-controlled&#13;
lifecycle, in a long-lived object!  Applications are left&#13;
to their own devices to make sure the reference&#13;
doesn’t outlive the target object.</p>&#13;
&#13;
<p>The Jetpack-supported implementation of the MVVM pattern&#13;
dramatically reduces this problem. In its implementation, the&#13;
only references to the View are the subscriptions to the&#13;
<code>LiveData</code> observables. The <code>LiveData</code> objects identify&#13;
<code>Fragment</code> and &#13;
<span class="keep-together"><code>Activity</code></span> observers, and unregister them,&#13;
automatically when their lifecycle ends.</p>&#13;
&#13;
<p>Applications built with JetPack’s version of MVVM can be&#13;
quite elegant. For a broad variety of applications, the View&#13;
will contain a single, simple, declarative method that draws&#13;
the screen. It will register that method as an observer&#13;
for ViewModel observables. The ViewModel translates&#13;
user input into calls to the backend Model and updates&#13;
its observables in response to notifications from the Model.&#13;
It’s that simple.<a data-startref="ix_ch03-asciidoc22" data-type="indexterm" id="idm46669754221200"/><a data-startref="ix_ch03-asciidoc21" data-type="indexterm" id="idm46669754220496"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669754241056">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Congratulations, you’ve successfully covered an intimidating&#13;
amount of information in a very short chapter!</p>&#13;
&#13;
<p>Remember that much of this material is foundational. It is&#13;
not important that you master all of the information&#13;
presented here. In fact, it’s quite possible that you will&#13;
never touch, for instance, a <code>ContentProvider</code> or a <code>BroadcastReceiver</code>.&#13;
Use what is practical for you, and approach mastering items&#13;
only as they become useful.</p>&#13;
&#13;
<p>Here are some key points to take with you:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An Android app is not an “application” in the traditional&#13;
sense. It is more like a web application: a collection of&#13;
components that provide services to a framework, when&#13;
requested to do so.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Android OS is a very specialized Linux distribution. Each&#13;
application is treated as an individual “user” and has its own&#13;
private file storage.</p>&#13;
</li>&#13;
<li>&#13;
<p>Android has four kinds of components. They are: <code>Activity</code>s, <code>Service</code>s,&#13;
&#13;
<span class="keep-together"><code>ContentProvider</code>s,</span> and <code>BroadcastReceiver</code>. <code>Activity</code>s, <code>Service</code>s,&#13;
and the &#13;
<span class="keep-together"><code>ContentProvider</code>s</span> must be registered and possibly given permission within the&#13;
Android manifest:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Activity</code>s are the UI of an Android application. They start their lifecycle at<a data-primary="onCreate" data-type="indexterm" id="idm46669754206576"/>&#13;
<code>onCreate</code>, are live to user interaction after<a data-primary="onResume" data-type="indexterm" id="idm46669754205248"/> <code>onResume</code>, and may be interrupted&#13;
(<code>onPause</code>) at any time.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Fragment</code>s are complex beasts with lifecycles all their own.  They&#13;
can be used to organize independent UI containers, within a UI page.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Service</code>s can be started services and/or bound. API 26&#13;
started introducing restrictions for background use of services, so&#13;
the general rule is that if the user interacts with a task in any way, a&#13;
service ought to be made into a foreground service.</p>&#13;
</li>&#13;
<li>&#13;
<p>Unless a <code>BroadcastReceiver</code> is using implicit intent that is explicitly allowed by the system&#13;
with the action, it is probably necessary to register the broadcast receiver&#13;
dynamically from application code.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Use the <code>Activity Context</code> carefully.  Activities have a lifecycle&#13;
that is not under the control of your application.  A reference&#13;
to an <code>Activity</code> <em>must</em> respect the actual lifecycle of the Activity.</p>&#13;
</li>&#13;
<li>&#13;
<p>General software architectures in Android, like MVI, MVP, and MVVM,&#13;
are designed to keep <code>Fragment</code>s and <code>Activity</code>s lean and encourage better&#13;
separation of concern and testing and while being “lifecycle-aware.”</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Now that we’ve reviewed the ground rules and explored the&#13;
playing field, our journey to achieving structured coroutines&#13;
in Kotlin officially starts. In the following chapter, we&#13;
begin to apply this foundation to examining memory and&#13;
threading in Android. Understanding the details of Android’s&#13;
organization will reveal the issues that the coming&#13;
chapters set out to solve.<a data-startref="ix_ch03-asciidoc0" data-type="indexterm" id="idm46669754193888"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>