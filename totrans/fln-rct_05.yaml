- en: Chapter 4\. Inside Reconciliation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be truly fluent in React, we need to understand *what* its functions do.
    So far, we’ve understood JSX and `React.createElement`. We’ve also understood
    the virtual DOM in some appreciable level of detail. Let’s explore the practical
    applications of it in React in this chapter, and understand what `ReactDOM.createRoot(element).​ren⁠der()`
    does. Specifically, we’ll explore *how* React builds its virtual DOM and then
    updates the real DOM through a process called reconciliation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Reconciliation
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a quick recap, React’s virtual DOM is a blueprint of our desired UI state.
    React takes this blueprint and, through a process called *reconciliation*, makes
    it a reality in a given host environment; usually a web browser, but possibly
    other environments like shells, native platforms like iOS and Android, and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code snippet contains a declarative description of what we want our UI
    state to be: a tree of elements. Both our teammates *and* React can read this
    and understand we’re trying to create a counter app with an increment button that
    increments the counter. To understand reconciliation, let’s understand what React
    does on the inside when faced with a component like this.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the JSX becomes a tree of React elements. This is what we saw in [Chapter 3](ch03.html#ch03).
    When invoked, the `App` component returns a React element whose children are further
    React elements. React elements are immutable (to us) and represent the desired
    state of the UI. They are not the actual UI state. React elements are created
    by `React.createElement` or the JSX `<` symbol, so this would be transpiled into:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This would give us a tree of created React elements that looks something like
    this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This snippet represents the virtual DOM that comes from our `Counter` component.
    Since this is the first render, this tree is now committed to the browser using
    minimal calls to imperative DOM APIs. How does React ensure minimal calls to imperative
    DOM APIs? It does so by batching vDOM updates into one real DOM update, and touching
    the DOM as little as possible for reasons discussed in earlier chapters. Let’s
    dive into this in some more detail to fully understand batching.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Batching
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html#ch03), we discussed document fragments in browsers
    as part of the DOM’s built-in APIs: lightweight containers that hold collections
    of DOM nodes that act like a temporary staging area where you can make multiple
    changes without affecting the main DOM until you finally append the document fragment
    to the DOM, triggering a single reflow and repaint.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: In a similar vein, React batches updates to the real DOM during reconciliation,
    combining multiple vDOM updates into a single DOM update. This reduces the number
    of times the real DOM has to be updated and therefore lends itself to better performance
    for web applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, let’s consider a component that updates its state multiple
    times in quick succession:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，让我们考虑一个组件，在快速连续更新其状态多次：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the `handleClick` function calls `setCount` three times in
    quick succession. Without batching, React would update the real DOM three separate
    times, even though the value of `count` only changed once. This would be wasteful
    and slow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`handleClick`函数快速连续调用`setCount`三次。如果没有批处理，React将分别三次更新实际DOM，尽管`count`的值只改变了一次。这将是低效且慢。
- en: However, because React batches updates, it makes *one* update to the DOM with
    `count + 3` instead of three updates to the DOM with `count + 1` each time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于React批处理更新，它使得*一次*更新DOM为`count + 3`而不是每次为`count + 1`分别更新三次。
- en: 'To calculate the most efficient batched update to the DOM, React will create
    a new vDOM tree as a fork of the current vDOM tree with the updated values, where
    `count` is `3`. This tree will need to be *reconciled* with what is currently
    in the browser, effectively turning `0` into `3`. React will then calculate that
    just one update is required to the DOM using the new vDOM value `3` instead of
    manually updating the DOM three times. This is how batching fits into the picture,
    and it is a part of the broader topic we’re about to dive into: reconciliation,
    or the process of reconciling the next expected DOM state with the current DOM.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算对DOM的最高效批量更新，React将创建一个新的vDOM树，作为当前vDOM树的一个分支，带有更新后的值，其中`count`是`3`。这棵树将需要与当前在浏览器中的内容进行*调和*，有效地将`0`变为`3`。然后React将计算出仅需一次更新DOM，使用新的vDOM值`3`而不是手动三次更新DOM。这就是批处理如何适应图片的一部分，这也是我们即将深入探讨的更广泛主题：调和，或者调和下一个预期DOM状态与当前DOM的过程。
- en: Before we understand what modern-day React does under the hood, let’s explore
    how React used to perform reconciliation before version 16, with the legacy “stack”
    reconciler. This will help us understand the need for today’s popular Fiber reconciler.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解现代React在内部执行之前，让我们探讨React在16版本之前使用的遗留“栈”调和器进行调和的方式。这将帮助我们理解今天流行的Fiber调和器的必要性。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, it’s worth mentioning that all of the topics we’re about to discuss
    are implementation details in React that can and likely will change over time.
    Here, we are isolating the mechanism of how React works from actual practical
    usage of React. The goal is that by understanding React’s internal mechanisms,
    we’ll have a better understanding of how to use React effectively in applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，值得一提的是，我们即将讨论的所有主题都是React的实现细节，随着时间的推移可能会发生变化。在这里，我们将React的工作机制与React的实际应用隔离开来。我们的目标是通过理解React的内部机制，更有效地在应用程序中使用React。
- en: Prior Art
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先前的艺术
- en: Previously, React used a stack data structure for rendering. To make sure we’re
    on the same page, let’s briefly discuss the stack data structure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 早期，React使用栈数据结构进行渲染。为了确保我们理解一致，让我们简要讨论栈数据结构。
- en: Stack Reconciler (Legacy)
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈调和器（遗留）
- en: In computer science, a stack is a linear data structure that follows the last
    in, first out (LIFO) principle. This means that the last element added to the
    stack will be the first one to be removed. A stack has two fundamental operations,
    push and pop, that allow elements to be added and removed from the top of the
    stack, respectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，栈是一种遵循后进先出（LIFO）原则的线性数据结构。这意味着最后添加到栈中的元素将是第一个被移除的。栈具有两个基本操作，push和pop，分别允许从栈顶添加和移除元素。
- en: 'A stack can be visualized as a collection of elements that are arranged vertically,
    with the topmost element being the most recently added one. Here’s an ASCII illustration
    of a stack with three elements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 栈可以被视为一组垂直排列的元素，其中最顶部的元素是最近添加的元素。这里有一个栈的ASCII示例，包含三个元素：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the most recently added element is `3`, which is at the top
    of the stack. The element `1`, which was added first, is at the bottom of the
    stack.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，最近添加的元素是`3`，位于栈顶。第一个添加的元素`1`位于栈底。
- en: 'In this stack, the push operation adds an element to the top of the stack.
    In code, this can be executed in JavaScript using an array and the `push` method,
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个栈中，push操作将一个元素添加到栈顶。在代码中，这可以使用JavaScript中的数组和`push`方法执行，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The pop operation removes the top element from the stack. In code, this can
    be executed in JavaScript using an array and the `pop` method, like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 操作从栈中移除顶部元素。在代码中，可以使用数组和 `pop` 方法来执行 JavaScript 中的这个操作，如下所示：'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `pop` method removes the top element (`3`) from the stack
    and returns it. The stack array now contains the remaining elements (`1` and `2`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`pop` 方法从栈中移除顶部元素（`3`）并返回它。现在栈数组中包含剩余的元素（`1` 和 `2`）。
- en: React’s original reconciler was a stack-based algorithm that was used to compare
    the old and new virtual trees and update the DOM accordingly. While the stack
    reconciler worked well in simple cases, it presented a number of challenges as
    applications grew in size and complexity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: React 的原始协调器是一种基于栈的算法，用于比较旧的和新的虚拟树，并相应地更新 DOM。虽然栈协调器在简单情况下工作良好，但随着应用程序规模和复杂性的增长，它带来了一些挑战。
- en: 'Let’s take a quick look at why this was the case. To do so, we’ll consider
    an example where we’ve got a list of updates to make:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下为什么会这样。为此，我们将考虑一个需要进行更新的列表示例：
- en: A nonessential computationally expensive component consumes CPU and renders.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个非必要的计算昂贵的组件会消耗 CPU 并进行渲染。
- en: A user types into an `input` element.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在 `input` 元素中键入。
- en: '`Button` becomes enabled if the input is valid.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Button` 如果输入有效则变为可用。'
- en: A containing `Form` component holds the state, so it rerenders.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `Form` 组件持有状态，因此会重新渲染。
- en: 'In code, we’d express this like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们会这样表达：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, the stack reconciler would render the updates sequentially without
    being able to pause or defer work. If the computationally expensive component
    blocks rendering, user input will appear on screen with an observable lag. This
    leads to poor user experience, since the text field would be unresponsive. Instead,
    it would be far more pleasant to be able to recognize the user input as a higher-priority
    update than rendering the nonessential expensive component, and update the screen
    to reflect the input, deferring rendering the computationally expensive component.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，栈协调器会按顺序渲染更新而无法暂停或延迟工作。如果计算昂贵的组件阻塞渲染，则用户输入将在屏幕上显示出可观的延迟。这会导致糟糕的用户体验，因为文本字段将无响应。相反，能够识别用户输入作为高优先级更新，而不是渲染非必要的昂贵组件，并更新屏幕以反映输入，延迟渲染计算昂贵的组件，会更加愉快。
- en: There is a need to be able to bail out of current rendering work if interrupted
    by higher-priority rendering work, like user input. To do this, React needs to
    have a sense of priority for certain types of rendering operations over others.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被用户输入等高优先级渲染工作打断，则需要能够中止当前渲染工作。为了做到这一点，React 需要对某些类型的渲染操作有优先级的概念，以区分它们。
- en: The stack reconciler did not prioritize updates, which meant that less important
    updates could block more important updates. For example, a low-priority update
    to a tooltip might block a high-priority update to a text input. Updates to the
    virtual tree were executed in the order they were received.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 栈协调器未对更新进行优先级排序，这意味着较不重要的更新可能会阻塞更重要的更新。例如，对工具提示的低优先级更新可能会阻塞对文本输入的高优先级更新。虚拟树的更新按接收顺序执行。
- en: In a React application, updates to the virtual tree can have different levels
    of importance. For example, an update to a form input might be more important
    than an update to an indicator showing the number of likes on a post, because
    the user is directly interacting with the input and expects it to be responsive.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用中，虚拟树的更新可以有不同的重要性级别。例如，对表单输入的更新可能比更新显示帖子上点赞数的指示器更重要，因为用户直接与输入交互并期望它响应迅速。
- en: In the stack reconciler, updates were executed in the order they were received,
    which meant that less important updates could block more important updates. For
    example, if a like counter update was received before a form input update, the
    like counter update would be executed first and could block the form input update.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在栈协调器中，更新按接收顺序执行，这意味着较不重要的更新可能会阻塞更重要的更新。例如，如果点赞计数器更新在表单输入更新之前接收，点赞计数器更新将首先执行并可能阻塞表单输入更新。
- en: If the like counter update takes a long time to execute (e.g., because it’s
    performing an expensive computation), this could result in a noticeable delay
    or jank in the user interface, especially if the user is interacting with the
    application during the update.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点赞计数器更新需要很长时间执行（例如，因为它正在执行昂贵的计算），这可能会导致用户界面中的明显延迟或卡顿，特别是如果用户在更新期间与应用程序交互。
- en: Another challenge with the stack reconciler was that it did not allow updates
    to be interrupted or cancelled. What this means is that even if the stack reconciler
    had a sense of update priority, there were no guarantees that it could work well
    with various priorities by bailing out of unimportant work when a high-priority
    update was scheduled.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'In any web application, not all updates are created equal: a random unexpected
    notification appearing is not as important as responding to my click on a button
    because the latter is a deliberate action that warrants an immediate reaction,
    whereas the former isn’t even expected and may not even be welcome.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In the stack reconciler, updates could not be interrupted or cancelled, which
    meant that unnecessary updates, like showing a toast, were sometimes made at the
    expense of user interactions. This could result in unnecessary work being performed
    on the virtual tree and the DOM, which negatively impacted the performance of
    the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The stack reconciler presented a number of challenges as applications grew in
    size and complexity. The main challenges were centered around jank and user interfaces
    being slow to respond. To address these challenges, the React team developed a
    new reconciler called the Fiber reconciler, which is based on a different data
    structure called a Fiber tree. Let’s explore this data structure in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The Fiber Reconciler
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Fiber reconciler involves the use of a different data structure called a
    “Fiber” that represents a single unit of work for the reconciler. Fibers are created
    from React elements that we covered in [Chapter 3](ch03.html#ch03), with the key
    difference being that they are stateful and long-lived, while React elements are
    ephemeral and stateless.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark Erikson, the maintainer of Redux and a prominent React expert, describes
    Fibers as “React’s internal data structure that represents the actual component
    tree at a point in time.” Indeed, this is a good way to think about Fibers, and
    it’s on-brand for Mark who, at the time of writing, works on time-travel debugging
    React apps full time with Replay: a tool that allows you to rewind and replay
    your app’s state for debugging. If you haven’t already, check out [Replay.io](https://www.replay.io)
    for more information.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how the vDOM is a tree of elements, React uses a Fiber tree in reconciliation
    which, as the name suggests, is a tree of Fibers that is directly modeled after
    the vDOM.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Fiber as a Data Structure
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fiber data structure in React is a key component of the Fiber reconciler.
    The Fiber reconciler allows updates to be prioritized and executed concurrently,
    which improves the performance and responsiveness of React applications. Let’s
    explore the Fiber data structure in more detail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: At its core, the Fiber data structure is a representation of a component instance
    and its state in a React application. As discussed, the Fiber data structure is
    designed to be a mutable instance and can be updated and rearranged as needed
    during the reconciliation process.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Each instance of a Fiber node contains information about the component it represents,
    including its props, state, and child components. The Fiber node also contains
    information about its position in the component tree, as well as metadata that
    is used by the Fiber reconciler to prioritize and execute updates.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a simple Fiber node:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we have a Fiber node that represents a `ClassComponent` called
    `App`. The Fiber node contains information about the component’s:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`tag`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In this case it’s `3`, which React uses to identify class components. Each type
    of component (class components, function components, Suspense and error boundaries,
    fragments, etc.) has its own numerical ID as Fibers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`App` refers to the function or class component that this Fiber represents.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '`props`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '(`{name: "Tejas", age: 30}`) represent the input props to the component, or
    input arguments to the function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '`stateNode`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The instance of the `App` component that this Fiber represents.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Its position in the component tree: `return`, `child`, `sibling`, and `index`
    each give the Fiber reconciler a way to “walk the tree,” identifying parents,
    children, siblings, and the Fiber’s index.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Fiber reconciliation involves comparing the current Fiber tree with the next
    Fiber tree and figuring out which nodes need to be updated, added, or removed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'During the reconciliation process, the Fiber reconciler creates a Fiber node
    for each React element in the virtual DOM. There is a function called `createFiberFrom​Ty⁠peAndProps`
    that does this. Of course, another way of saying “type and props” is by calling
    them React elements. As we recall, a React element is this: type and props:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function returns a Fiber derived from elements. Once the Fiber nodes have
    been created, the Fiber reconciler uses a *work loop* to update the user interface.
    The work loop starts at the root Fiber node and works its way down the component
    tree, marking each Fiber node as “dirty” if it needs to be updated. Once it reaches
    the end, it walks back up, creating a new DOM tree in memory, detached from the
    browser, that will eventually be committed (flushed) to the screen. This is represented
    by two functions: `beginWork` walks downward, marking components as “need to update,”
    and `completeWork` walks back up, constructing a tree of real DOM elements detached
    from the browser. This off-screen rendering process can be interrupted and thrown
    away at any time, since the user doesn’t see it.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The Fiber architecture takes inspiration from a concept called “double buffering”
    in the game world, where the next screen is prepared offscreen and then “flushed”
    to the current screen. To better grasp the Fiber architecture, let’s understand
    this concept in a little more detail before we move further.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Double Buffering
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Double buffering is a technique used in computer graphics and video processing
    to reduce flicker and improve perceived performance. The technique involves creating
    two buffers (or memory spaces) for storing images or frames, and switching between
    them at regular intervals to display the final image or video.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how double buffering works in practice:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The first buffer is filled with the initial image or frame.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the first buffer is being displayed, the second buffer is updated with
    new data or images.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the second buffer is ready, it is switched with the first buffer and displayed
    on the screen.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process continues, with the first and second buffers being switched at regular
    intervals to display the final image or video.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using double buffering, flicker and other visual artifacts can be reduced,
    since the final image or video is displayed without interruptions or delays.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Fiber reconciliation is similar to double buffering such that when updates happen,
    the current Fiber tree is forked and updated to reflect the new state of a given
    user interface. This is called *rendering*. Then, when the alternate tree is ready
    and accurately reflects the state a user expects to see, it is swapped with the
    current tree similarly to how video buffers are swapped in double buffering. This
    is called the *commit phase* of reconciliation or a *commit*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a work-in-progress tree, the Fiber reconciler presents a number of
    benefits:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: It can avoid making unnecessary updates to the real DOM, which can improve performance
    and reduce flicker.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can compute the new state of a UI off-screen, and throw it away if a newer
    higher-priority update needs to happen.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since reconciliation happens off-screen, it can even pause and resume without
    messing up what the user currently sees.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the Fiber reconciler, two trees are derived from a user-defined tree of
    JSX elements: one tree containing “current” Fibers, and another tree containing
    work-in-progress Fibers. Let’s explore these trees a little more.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Fiber Reconciliation
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fiber reconciliation happens in two phases: the render phase and the commit
    phase. This two-phase approach, shown in [Figure 4-1](#figure4-1), allows React
    to do rendering work that can be disposed of at any time before committing it
    to the DOM and showing a new state to users: it makes rendering interruptible.
    To be a little bit more detailed, what makes rendering feel interruptible are
    the heuristics employed by the React scheduler of yielding the execution back
    to the main thread every 5 ms, which is smaller than a single frame even on 120
    fps devices.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Reconciliation Flow in the Fiber Reconciler](assets/frea_0401.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Reconciliation flow in the Fiber reconciler
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll dive more into the details around the scheduler in [Chapter 7](ch07.html#ch07)
    as we explore React’s concurrent features. For now, though, let’s walk through
    these phases of reconciliation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The render phase
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *render phase* starts when a state-change event occurs in the `current`
    tree. React does the work of making the changes *off-screen* in the `alternate`
    tree by recursively stepping through each Fiber and setting flags that signal
    updates are pending (see [Figure 4-2](#figure4-2)). As we alluded to earlier,
    this happens in a function called `beginWork` internally in React.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Call order of the Render Phase](assets/frea_0402.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Call order of the render phase
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: beginWork
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`beginWork` is responsible for setting flags on Fiber nodes in the work-in-progress
    tree about whether or not they should update. It sets a bunch of flags and then
    recursively goes to the next Fiber node, doing the same thing until it reaches
    the bottom of the tree. When it finishes, we start calling `completeWork` on the
    Fiber nodes and walk back up.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of `beginWork` is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'More on `completeWork` later. For now, let’s dive into `beginWork`. Its signature
    includes the following arguments:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`current`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: A reference to the Fiber node in the current tree that corresponds to the work-in-progress
    node being updated. This is used to determine what has changed between the previous
    version and the new version of the tree, and what needs to be updated. This is
    *never* mutated and is only used for comparison.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`workInProgress`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The Fiber node being updated in the work-in-progress tree. This is the node
    that will be marked as “dirty” if updated and returned by the function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`renderLanes`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Render lanes is a new concept in React’s Fiber reconciler that replaces the
    older `renderExpirationTime`. It’s a bit more complex than the old `renderExpirationTime`
    concept, but it allows React to better prioritize updates and make the update
    process more efficient. Since `renderExpirationTime` is deprecated, we’ll focus
    on `renderLanes` in this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: It is essentially a bitmask that represents “lanes” in which an update is being
    processed. Lanes are a way of categorizing updates based on their priority and
    other factors. When a change is made to a React component, it is assigned a lane
    based on its priority and other characteristics. The higher the priority of the
    change, the higher the lane it is assigned to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The `renderLanes` value is passed to the `beginWork` function in order to ensure
    that updates are processed in the correct order. Updates that are assigned to
    higher-priority lanes are processed before updates that are assigned to lower-priority
    lanes. This ensures that high-priority updates, such as updates that affect user
    interaction or accessibility, are processed as quickly as possible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: In addition to prioritizing updates, `renderLanes` also helps React better manage
    concurrency. React uses a technique called “time slicing” to break up long-running
    updates into smaller, more manageable chunks. `renderLanes` plays a key role in
    this process, as it allows React to determine which updates should be processed
    first, and which updates can be deferred until later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: After the render phase is complete, the `getLanesToRetrySynchronouslyOnError`
    function is called to determine if any deferred updates were created during the
    render phase. If there are deferred updates, the `updateComponent` function starts
    a new work loop to handle them, using `beginWork` and `getNextLanes` to process
    the updates and prioritize them based on their lanes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We dive much deeper into render lanes in [Chapter 7](ch07.html#ch07), the upcoming
    chapter on concurrency. For now, let’s continue following the Fiber reconciliation
    flow.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: completeWork
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `completeWork` function applies updates to the work-in-progress Fiber node
    and constructs a new real DOM tree that represents the updated state of the application.
    It constructs this tree detached from the DOM out of the plane of browser visibility.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'If the host environment is a browser, this means doing things like `document.​crea⁠teElement`
    or `newElement.appendChild`. Keep in mind, this tree of elements is not yet attached
    to the in-browser document: React is just creating the next version of the UI
    off-screen. Doing this work off-screen makes it interruptible: whatever next state
    React is computing is not yet painted to the screen, so it can be thrown away
    in case some higher-priority update gets scheduled. This is the whole point of
    the Fiber reconciler.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of `completeWork` is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the signature is the same signature as `beginWork`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The `completeWork` function is closely related to the `beginWork` function.
    While `beginWork` is responsible for setting flags about “should update” state
    on a Fiber node, `completeWork` is responsible for constructing a new tree to
    be committed to the host environment. When `completeWork` reaches the top and
    has constructed the new DOM tree, we say that “the render phase is completed.”
    Now, React moves on to the commit phase.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The commit phase
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *commit phase* (see [Figure 4-3](#figure4-3)) is responsible for updating
    the actual DOM with the changes that were made to the virtual DOM during the render
    phase. During the commit phase, the new virtual DOM tree is committed to the host
    environment, and the work-in-progress tree is replaced with the current tree.
    It’s in this phase that all effects are also run. The commit phase is divided
    into two parts: the mutation phase and the layout phase.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![The Commit Phase with FiberRootNode](assets/frea_0403.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. The commit phase with `FiberRootNode`
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The mutation phase
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The mutation phase is the first part of the commit phase, and it is responsible
    for updating the actual DOM with the changes that were made to the virtual DOM.
    During this phase, React identifies updates that need to be made and calls a special
    function called `commitMutationEffects`. This function applies the updates that
    were made to Fiber nodes in the alternate tree during the render phase to the
    actual DOM.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an full-pseudocode example of how `commitMutationEffects` might be implemented:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: During the mutation phase, React also calls other special functions, such as
    `commit​Un⁠mount` and `commitDeletion`, to remove nodes from the DOM that are
    no longer needed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The layout phase
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The layout phase is the second part of the commit phase, and it is responsible
    for calculating the new layout of the updated nodes in the DOM. During this phase,
    React calls a special function called `commitLayoutEffects`. This function calculates
    the new layout of the updated nodes in the DOM.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Like `commitMutationEffects`, `commitLayoutEffects` is also a massive switch
    statement that calls different functions, depending on the type of node being
    updated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Once the layout phase is complete, React has successfully updated the actual
    DOM to reflect the changes that were made to the virtual DOM during the render
    phase.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: By dividing the commit phase into two parts (mutation and layout), React is
    able to apply updates to the DOM in an efficient manner. By working in concert
    with other key functions in the reconciler, the commit phase helps to ensure that
    React applications are fast, responsive, and reliable, even as they become more
    complex and handle larger amounts of data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Effects
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'During the commit phase of React’s reconciliation process, side effects are
    performed in a specific order, depending on the type of effect. There are several
    types of effects that can occur during the commit phase, including:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Placement effects
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: These effects occur when a new component is added to the DOM. For example, if
    a new button is added to a form, a placement effect will occur to add the button
    to the DOM.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Update effects
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: These effects occur when a component is updated with new props or state. For
    example, if the text of a button changes, an update effect will occur to update
    the text in the DOM.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Deletion effects
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: These effects occur when a component is removed from the DOM. For example, if
    a button is removed from a form, a deletion effect will occur to remove the button
    from the DOM.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Layout effects
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: These effects occur before the browser has a chance to paint, and are used to
    update the layout of the page. Layout effects are managed using the `useLayoutEffect`
    hook in function components and the `componentDidUpdate` lifecycle method in class
    components.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to these commit-phase effects, passive effects are user-defined
    effects that are scheduled to run after the browser has had a chance to paint.
    Passive effects are managed using the `useEffect` hook.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Passive effects are useful for performing actions that are not critical to the
    initial rendering of the page, such as fetching data from an API or performing
    analytics tracking. Because passive effects are not performed during the render
    phase, they do not affect the time required to compute a minimal set of updates
    required to bring a user interface into the developer’s desired state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 被动效应非常适合执行对页面初始渲染不关键的操作，例如从 API 获取数据或执行分析跟踪。由于被动效应不会在渲染阶段执行，因此不会影响计算将用户界面带入开发者所需状态所需的最小更新时间。
- en: Putting everything on the screen
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 把所有内容显示在屏幕上
- en: 'React maintains a `FiberRootNode` atop both trees that points to one of the
    two trees: the `current` or the `workInProgress` tree. The `FiberRootNode` is
    a key data structure that is responsible for managing the commit phase of the
    reconciliation process.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: React 在两棵树之上维护一个名为`FiberRootNode`的数据结构，指向其中一棵树：`current` 或 `workInProgress`。`FiberRootNode`
    是一个关键数据结构，负责管理协调过程的提交阶段。
- en: When updates are made to the virtual DOM, React updates the `workInProgress`
    tree, while leaving the current tree unchanged. This allows React to continue
    rendering and updating the virtual DOM, while also preserving the current state
    of the application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当对虚拟 DOM 进行更新时，React 更新`workInProgress`树，同时保持当前树不变。这使得 React 能够继续渲染和更新虚拟 DOM，同时保持应用程序的当前状态。
- en: When the rendering process is complete, React calls a function called `commitRoot`,
    which is responsible for committing the changes made to the `workInProgress` tree
    to the actual DOM. `commitRoot` switches the pointer of the `FiberRootNode` from
    the current tree to the `workInProgress` tree, making the `workInProgress` tree
    the new current tree.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染过程完成时，React 调用一个名为`commitRoot`的函数，负责将对`workInProgress`树所做的更改提交到实际的 DOM。`commitRoot`将`FiberRootNode`的指针从当前树切换到`workInProgress`树，使`workInProgress`树成为新的当前树。
- en: From this point on, any future updates are based on the new current tree. This
    process ensures that the application remains in a consistent state, and that updates
    are applied correctly and efficiently.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从此刻起，任何未来的更新都基于新的当前树。这个过程确保应用程序保持一致的状态，并且更新被正确高效地应用。
- en: All of this appears to happen instantly in the browser. This is the work of
    reconciliation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些看起来在浏览器中瞬间发生。这是协调的工作。
- en: Chapter Review
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节复习
- en: 'In this chapter, we explored the concept of React reconciliation and learned
    about the Fiber reconciler. We also learned about Fibers, which enable efficient
    and interruptible rendering in concert with a powerful scheduler. We also learned
    about the render phase and the commit phase, which are the two main phases of
    the reconciliation process. Finally, we learned about the `FiberRootNode`: a key
    data structure responsible for managing the commit phase of the reconciliation
    process.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 React 协调的概念，并了解了 Fiber 协调器。我们还学习了有关 Fibers 的知识，它们与强大的调度程序一起实现了高效和可中断的渲染。我们还学习了渲染阶段和提交阶段，这是协调过程的两个主要阶段。最后，我们了解了`FiberRootNode`：负责管理协调过程提交阶段的关键数据结构。
- en: Review Questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习问题
- en: 'Let’s ask ourselves a few questions to test our understanding of the concepts
    in this chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们自问几个问题，以测试我们对本章概念的理解：
- en: What is React reconciliation?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 React 协调？
- en: What’s the role of the Fiber data structure?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Fiber 数据结构的作用是什么？
- en: Why do we need two trees?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要两棵树？
- en: What happens when an application updates?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序更新时会发生什么？
- en: If we can answer these questions, we should be well on our way to understanding
    the Fiber reconciler and the reconciliation process in React.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能回答这些问题，我们就能更好地理解 Fiber 协调器和 React 中的协调过程。
- en: Up Next
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来
- en: In [Chapter 5](ch05.html#ch05), we’ll look at common questions in React and
    explore some advanced patterns. We’ll answer questions around how often to use
    `useMemo` and when to use `React.lazy`. We’ll also explore how to use `useReducer`
    and `useContext` to manage state in React applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html#ch05)中，我们将探讨 React 中的常见问题并探索一些高级模式。我们将回答关于何时使用`useMemo`和何时使用`React.lazy`的问题。我们还将探讨如何使用`useReducer`和`useContext`来管理
    React 应用程序中的状态。
- en: See you there!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到那里见！
