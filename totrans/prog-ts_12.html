<html><head></head><body><section data-pdf-bookmark="Chapter 12. Building and Running TypeScript" data-type="chapter" epub:type="chapter"><div class="chapter" id="typescript-in-production">&#13;
<h1><span class="label">Chapter 12. </span>Building and Running TypeScript</h1>&#13;
&#13;
&#13;
<p>If you’ve deployed and run a JavaScript application in production, then you know how to run a TypeScript application too—once you compile it to JavaScript, the two aren’t so different. This chapter is about productionizing and building TypeScript applications, but there isn’t much here that’s unique to TypeScript apps—it mostly applies to JavaScript applications too. We’ll divide it up into four sections, covering:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The things you have to do to build any TypeScript application</p>&#13;
</li>&#13;
<li>&#13;
<p>Building and running TypeScript applications on the server</p>&#13;
</li>&#13;
<li>&#13;
<p>Building and running TypeScript applications in the browser</p>&#13;
</li>&#13;
<li>&#13;
<p>Building for and publishing your TypeScript application to NPM</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building Your TypeScript Project" data-type="sect1"><div class="sect1" id="building">&#13;
<h1>Building Your TypeScript Project</h1>&#13;
&#13;
<p>Building a TypeScript project is straightforward.<a data-primary="TypeScript" data-secondary="building a project" data-type="indexterm" id="ix_TSbld"/> In this section, we’ll cover the core ideas you’ll need to understand in order to build your project for whatever environment you plan to run it in.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Project Layout" data-type="sect2"><div class="sect2" id="idm46304949862952">&#13;
<h2>Project Layout</h2>&#13;
&#13;
<p>I suggest keeping your source TypeScript code in a top-level <em>src/</em> folder, and compiling it to a top-level <em>dist/</em> folder.<a data-primary="TypeScript" data-secondary="building a project" data-tertiary="project layout" data-type="indexterm" id="idm46304949860760"/><a data-primary="folder structure for TypeScript projects" data-type="indexterm" id="idm46304949859480"/> This folder structure is a popular convention, and splitting your source code and generated code into two top-level folders can make your life easier down the line, when you’re integrating with other tooling. It also makes it easier to exclude generated artifacts from source control.</p>&#13;
&#13;
<p class="pagebreak-before">Try to stick to this convention when you can:</p>&#13;
&#13;
<pre data-type="programlisting">my-app/&#13;
├──dist/&#13;
│ ├──index.d.ts&#13;
│ ├──index.js&#13;
│ └──services/&#13;
│   ├──foo.d.ts&#13;
│   ├──foo.js&#13;
│   ├──bar.d.ts&#13;
│   └──bar.js&#13;
├──src/&#13;
│ ├──index.ts&#13;
│ └──services/&#13;
│   ├──foo.ts&#13;
│   └──bar.ts</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Artifacts" data-type="sect2"><div class="sect2" id="idm46304949856376">&#13;
<h2>Artifacts</h2>&#13;
&#13;
<p>When you compile a TypeScript<a data-primary="TypeScript" data-secondary="building a project" data-tertiary="artifacts generated by TSC" data-type="indexterm" id="idm46304949854872"/><a data-primary="TSC compiler" data-secondary="artifacts generated by" data-type="indexterm" id="idm46304949853560"/><a data-primary="JavaScript" data-secondary="TypeScript program compiled to" data-type="indexterm" id="idm46304949852616"/> program to JavaScript, there are a few different artifacts that TSC can generate for you (<a data-type="xref" href="#artifact-tsc-table">Table 12-1</a>).</p>&#13;
<table id="artifact-tsc-table">&#13;
<caption><span class="label">Table 12-1. </span>Artifacts that TSC can generate for you</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type</th>&#13;
<th>File extension</th>&#13;
<th>tsconfig.json flag</th>&#13;
<th>Emitted by default?</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>JavaScript</strong></p></td>&#13;
<td><p><em>.js</em></p></td>&#13;
<td><p><code>{"emitDeclarationOnly": false}</code></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Source maps</strong></p></td>&#13;
<td><p><em>.js.map</em></p></td>&#13;
<td><p><code>{"sourceMap": true}</code></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Type declarations</strong></p></td>&#13;
<td><p><em>.d.ts</em></p></td>&#13;
<td><p><code>{"declaration": true}</code></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Declaration maps</strong></p></td>&#13;
<td><p><em>.d.ts.map</em></p></td>&#13;
<td><p><code>{"declarationMap": true}</code></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The first type of artifact—JavaScript files—should be familiar. TSC compiles your TypeScript code to JavaScript that you can then run using a JavaScript platform like NodeJS or Chrome. If you run <code>tsc yourfile.ts</code>, TSC will typecheck <em>yourfile.ts</em> and compile it to JavaScript.</p>&#13;
&#13;
<p>The second type of artifact—source maps—is special files<a data-primary="source maps" data-type="indexterm" id="idm46304949831608"/> that link each piece of your generated JavaScript back to the specific line and column of the TypeScript file that it was generated from. This is helpful for debugging your code (Chrome DevtTools will show your TypeScript code, instead of the generated JavaScript), and for mapping lines and columns in JavaScript exception stack traces back to TypeScript (tools like those mentioned in <a data-type="xref" href="#error-monitoring-sect">“Error Monitoring”</a> do this lookup automatically if you give them your source maps).</p>&#13;
&#13;
<p>The third artifact—type declarations—lets other<a data-primary="type declarations" data-type="indexterm" id="idm46304949828968"/> TypeScript projects take advantage of your generated types.</p>&#13;
&#13;
<p>Finally, declaration maps are used to speed up compilation times for your TypeScript projects.<a data-primary="declaration maps" data-type="indexterm" id="idm46304949827560"/> You’ll read more about them in <a data-type="xref" href="#improving-compile-times">“Project References”</a>. We’ll spend the rest of this chapter talking about how and why to generate these artifacts.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dialing In Your Compile Target" data-type="sect2"><div class="sect2" id="idm46304949825576">&#13;
<h2>Dialing In Your Compile Target</h2>&#13;
&#13;
<p>JavaScript can be an unusual language to work with: not only does it have a quickly evolving<a data-primary="compile target for TypeScript projects" data-type="indexterm" id="ix_cmptrgt"/><a data-primary="JavaScript" data-secondary="compile target for TypeScript projects" data-type="indexterm" id="ix_JScmptrgt"/><a data-primary="TypeScript" data-secondary="building a project" data-tertiary="dialing in your compile target" data-type="indexterm" id="ix_TSbldcmptrg"/> specification with a yearly release cycle, but, as a programmer, you can’t always control which JavaScript version the platform you’re running your program on implements. On top of that, many JavaScript programs are <em>isomorphic</em>, meaning you can run them on either the server or the client.<a data-primary="isomorphic programs" data-type="indexterm" id="idm46304949819384"/> For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If you run your backend JavaScript program on a server that you control, then you can control exactly which JavaScript version it will run on.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you then release your backend JavaScript program as an open source project, you don’t know which JavaScript version will be supported by your consumers’ JavaScript platforms. The best you can do in a NodeJS environment is declare a range of supported NodeJS versions, but in a browser environment you’re out of luck.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you run your JavaScript in a browser, you have no idea which browser people will use to run it—the latest Chrome, Firefox, or Edge that supports most modern JavaScript features, a slightly outdated version of one of those browsers that’s missing some bleeding-edge functionality, an antiquated browser like Internet Explorer 8, or an embedded browser like the one that runs on the PlayStation 4 in your garage. The best you can do is define a minimum set of features that people’s browsers need to support to run your application, ship polyfills for as many of those features as you can, and try to detect when users are on really old browsers that your app won’t run on and show them a message saying that they need to upgrade.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you release an isomorphic JavaScript library (e.g., a logging library that runs on both browser and server), then you have to support both a minimum NodeJS version and a swath of browser JavaScript engines and versions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Not every JavaScript environment supports every JavaScript feature out of the box, but you should still try to write code in the latest language version. There are two ways to do this:</p>&#13;
<ol>&#13;
<li>&#13;
<p><em>Transpile</em> (i.e., automatically convert) applications from the latest version of JavaScript to the oldest JavaScript version that a platform you target supports<a data-primary="transpiling" data-type="indexterm" id="idm46304949810728"/>. We do this for language features like <code>for..of</code> loops and <code>async</code>/<code>await</code>, which can be automatically converted to <code>for</code> loops and <code>.then</code> calls, respectively.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Polyfill</em> (i.e., provide implementations for) any modern features that are missing in the JavaScript runtime you’re running on.<a data-primary="polyfills" data-type="indexterm" id="idm46304949806232"/> We do this for features provided by the JavaScript standard library (like <code>Promise</code>, <code>Map</code>, and <code>Set</code>) and for prototype methods (like <code>Array.prototype.includes</code> and <code>Function.prototype.bind</code>).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>TSC has built-in support for transpiling your code to older JavaScript versions, but it will not automatically polyfill your code. <a data-primary="transpiling" data-secondary="TSC support for transpiling code to older JavaScript versions" data-type="indexterm" id="idm46304949802568"/>This is worth reiterating: TSC will transpile most JavaScript features for older environments, but it will not provide implementations for missing features.</p>&#13;
&#13;
<p>TSC gives you three settings<a data-primary="TSC compiler" data-secondary="setting to dial in environments to target" data-type="indexterm" id="idm46304949800856"/> to dial in which environments you want to target:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>target</code> sets the JavaScript version you want to transpile to: <code>es5</code>, <code>es2015</code>, etc.<a data-primary="target setting (TSC)" data-type="indexterm" id="idm46304949797416"/></p>&#13;
</li>&#13;
<li>&#13;
<p><code>module</code> sets the module system you want to target: <code>es2015</code> modules, <code>commonjs</code> modules, <code>systemjs</code> modules, etc.<a data-primary="CommonJS module setting (TSC)" data-type="indexterm" id="idm46304949794184"/><a data-primary="module setting (TSC)" data-type="indexterm" id="idm46304949793432"/></p>&#13;
</li>&#13;
<li>&#13;
<p><code>lib</code> tells TypeScript which JavaScript features are available in the environments you’re targeting: <code>es5</code> features, <code>es2015</code> features, the <code>dom</code>, etc.<a data-primary="lib setting (TSC)" data-type="indexterm" id="idm46304949790216"/> It doesn’t actually implement these features—that’s what polyfills are for—but it does tell TypeScript that the features are available (either natively or via a polyfill).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The environment you plan to run your application in dictates which JavaScript version you should transpile to with <code>target</code> and what to set <code>lib</code> to. If you’re not sure, <code>es5</code> is usually a safe default for both. What you set <code>module</code> to depends on whether you’re targeting a NodeJS or browser environment, and what module loader you’re using if the latter.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you need to support an unusual set of platforms, look up which JavaScript features your target platforms support natively in Juriy Zaytsev’s (aka Kangax’s) <a href="http://kangax.github.io/compat-table/es5/">compatibility tables</a>.</p>&#13;
</div>&#13;
&#13;
<p>Let’s dig a little deeper into <code>target</code> and <code>lib</code>; we’ll leave <code>module</code> to the sections on <a data-type="xref" href="#Running-TypeScript-on-the-Server">“Running TypeScript on the Server”</a> and <a data-type="xref" href="#Running-TypeScript-in-the-Browser">“Running TypeScript in the Browser”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="target" data-type="sect3"><div class="sect3" id="idm46304949780632">&#13;
<h3>target</h3>&#13;
&#13;
<p>TSC’s built-in transpiler supports converting most JavaScript features to older JavaScript versions,<a data-primary="compile target for TypeScript projects" data-secondary="target setting" data-type="indexterm" id="idm46304949778856"/><a data-primary="transpiling" data-secondary="JavaScript features TSC does/does not transpile for" data-type="indexterm" id="idm46304949777912"/> meaning you can write your code in the latest TypeScript version and transpile it down to whatever JavaScript version you need to support. Since TypeScript supports the latest JavaScript features (like <code>async</code>/<code>await</code>, which is not yet supported by all major JavaScript platforms at the time of writing), you’ll almost always find yourself taking advantage of this built-in transpiler to convert your code to something that NodeJS and browsers understand today.</p>&#13;
&#13;
<p>Let’s take a look at which specific JavaScript features TSC does and does not transpile for older JavaScript versions (<a data-type="xref" href="#tsc-does-transpile">Table 12-2</a> and <a data-type="xref" href="#tsc-does-not-transpile">Table 12-3</a>).<sup><a data-type="noteref" href="ch12.html#idm46304949773272" id="idm46304949773272-marker">1</a></sup></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the past, there was a new revision of the JavaScript language released every few years,<a data-primary="JavaScript" data-secondary="compile target for TypeScript projects" data-tertiary="language versions and releases" data-type="indexterm" id="idm46304949771320"/> with an incrementing language version (ES1, ES3, ES5, ES6). As of 2015, the JavaScript language now has a yearly release cycle, with each language version named after the year it’s released in (ES2015, ES2016, and so on). <a data-primary="ESNext features" data-type="indexterm" id="idm46304949769672"/>Some JavaScript features, however, get TypeScript support before they’re actually slated for a specific JavaScript version; we refer to these features as “ESNext” (as in, the next revision).</p>&#13;
</div>&#13;
<table id="tsc-does-transpile">&#13;
<caption><span class="label">Table 12-2. </span>TSC does transpile</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Version</th>&#13;
<th>Feature</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>ES2015</p></td>&#13;
<td><p><code>const</code>, <code>let</code>, <code>for..of</code> loops, array/object spread (<code>...</code>), tagged template strings, classes, generators, arrow functions, function default parameters, function rest parameters, destructuring declarations/assignments/parameters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ES2016</p></td>&#13;
<td><p>Exponentiation operator (<code>**</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ES2017</p></td>&#13;
<td><p><code>async</code> functions, <code>await</code>ing promises</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ES2018</p></td>&#13;
<td><p><code>async</code> iterators</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ES2019</p></td>&#13;
<td><p>Optional parameter in catch clause</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ESNext</p></td>&#13;
<td><p>Numeric separators (<code>123_456</code>)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<table id="tsc-does-not-transpile">&#13;
<caption><span class="label">Table 12-3. </span>TSC does not transpile</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Version</th>&#13;
<th>Feature</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>ES5</p></td>&#13;
<td><p>Object getters/setters</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ES2015</p></td>&#13;
<td><p>Regex <code>y</code> and <code>u</code> flags</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ES2018</p></td>&#13;
<td><p>Regex <code>s</code> flag</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ESNext</p></td>&#13;
<td><p>BigInt (<code>123n</code>)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>To set the transpilation target, pop open your <em>tsconfig.json</em> and set the <code>target</code> field to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>es3</code> for ECMAScript 3</p>&#13;
</li>&#13;
<li>&#13;
<p><code>es5</code> for ECMAScript 5 (this is a good default if you’re not sure what to use)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>es6</code> or <code>es2015</code> for ECMAScript 2015</p>&#13;
</li>&#13;
<li>&#13;
<p><code>es2016</code> for ECMAScript 2016</p>&#13;
</li>&#13;
<li>&#13;
<p><code>es2017</code> for ECMAScript 2017</p>&#13;
</li>&#13;
<li>&#13;
<p><code>es2018</code> for ECMAScript 2018</p>&#13;
</li>&#13;
<li>&#13;
<p><code>esnext</code> for whatever the most recent ECMAScript revision is</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For example, to compile to ES5:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"target"</code><code class="p">:</code> <code class="s2">"es5"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="lib" data-type="sect3"><div class="sect3" id="lib">&#13;
<h3>lib</h3>&#13;
&#13;
<p>As I mentioned, there’s one hitch with transpiling your code to older JavaScript versions: while most language <a data-primary="lib setting (TSC)" data-type="indexterm" id="idm46304949718312"/>features can be safely transpiled (<code>let</code> to <code>var</code>, <code>class</code> to <code>function</code>), you still need to <em>polyfill</em> functionality yourself if your target environment doesn’t support a newer library feature.<a data-primary="polyfills" data-secondary="for target environment not supporting newer library feature" data-type="indexterm" id="idm46304949711912"/> Some examples are utilities like <code>Promise</code> and <code>Reflect</code>, and data structures like <code>Map</code>, <code>Set</code>, and <code>Symbol</code>. When targeting a bleeding-edge environment like the latest Chrome, Firefox, or Edge, you usually won’t need any polyfills; but if you’re targeting browsers a few versions back—or most NodeJS environments—you will need to polyfill missing features.</p>&#13;
&#13;
<p>Thankfully, you won’t need to write polyfills yourself. Instead, you can install them from a popular polyfill library like <a href="https://www.npmjs.com/package/core-js"><code>core-js</code></a>, or add polyfills to your code automatically by running your typechecked TypeScript code through Babel with <a href="https://babeljs.io/docs/en/babel-polyfill"><code>@babel/polyfill</code></a>.<a data-primary="core-js library" data-type="indexterm" id="idm46304949706552"/><a data-primary="Babel, running typechecked TypeScript code through" data-type="indexterm" id="idm46304949705848"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you plan to run your application in a browser, be careful not to bloat the size of your JavaScript <a data-primary="browsers" data-secondary="running JavaScript in, polyfills and" data-type="indexterm" id="idm46304949704056"/>bundle by including every single polyfill regardless of whether or not the browser you’re running your code in actually needs it—your target platform probably already supports some of the features you’re polyfilling. Instead, use a service like <a href="https://polyfill.io/v2/docs/">Polyfill.io</a> to load just those polyfills that your user’s browser needs.</p>&#13;
</div>&#13;
&#13;
<p>Once you’ve added polyfills to your code, it’s time to tell TSC that your environment is guaranteed to support the features you polyfilled—enter your <em>tsconfig.json</em>’s <code>lib</code> field. For example, you could use this configuration if you’ve polyfilled all ES2015<a data-primary="arrays" data-secondary="Array.prototype.includes (ES2016)" data-type="indexterm" id="idm46304949700504"/> features plus ES2016’s <code>Array.prototype.includes</code>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"lib"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"es2015"</code><code class="p">,</code> <code class="s2">"es2016.array.includes"</code><code class="p">]</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you’re running your code in the browser, <a data-primary="DOM (Document Object Model)" data-secondary="DOM type declarations, enabling" data-type="indexterm" id="idm46304949665912"/><a data-primary="type declarations" data-secondary="DOM type declarations, enabling" data-type="indexterm" id="idm46304949659240"/>also enable DOM type declarations for things like <code>window</code>, <code>document</code>, and all the other APIs you get when running your JavaScript in the browser:</p>&#13;
<pre data-code-language="js" data-type="programlisting">&#13;
<code class="p">{</code><code>&#13;
  </code><code class="s2">"compilerOptions"</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="s2">"lib"</code><code class="o">:</code><code> </code><code class="p">[</code><code class="s2">"es2015"</code><code class="p">,</code><code> </code><code class="s2">"es2016.array.include"</code><code class="p">,</code><code> </code><strong><code class="s2">"dom"</code></strong><code class="p">]</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>For a full list of<a data-primary="TypeScript" data-secondary="building a project" data-startref="ix_TSbldcmptrg" data-tertiary="dialing in your compile target" data-type="indexterm" id="idm46304949637608"/><a data-primary="JavaScript" data-secondary="compile target for TypeScript projects" data-startref="ix_JScmptrgt" data-type="indexterm" id="idm46304949617640"/><a data-primary="compile target for TypeScript projects" data-startref="ix_cmptrgt" data-type="indexterm" id="idm46304949616456"/> supported libs run <code>tsc --help</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enabling Source Maps" data-type="sect2"><div class="sect2" id="idm46304949825112">&#13;
<h2>Enabling Source Maps</h2>&#13;
&#13;
<p>Source maps are a way to link your transpiled code back to the source code it was generated from.<a data-primary="TypeScript" data-secondary="building a project" data-tertiary="enabling source maps" data-type="indexterm" id="idm46304949613736"/><a data-primary="source maps" data-secondary="enabling" data-type="indexterm" id="idm46304949612488"/> Most developer tools (like Chrome DevTools), error reporting and logging frameworks, and build tools know about source maps. Since a typical build pipeline can produce code that’s very different from the code you started with (for example, your pipeline might compile TypeScript to ES5 JavaScript, tree-shake it with Rollup, preevaluate it with Prepack, then minify it with Uglify), using source maps throughout your build pipeline can make it a lot easier to debug the resulting JavaScript.</p>&#13;
&#13;
<p>It’s generally a good idea to use source maps in development, and ship source maps to production in both browser and server environments. There’s one caveat, though: if you rely on some level of security through obscurity for your browser code, don’t ship source maps to browsers in production.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Project References" data-type="sect2"><div class="sect2" id="improving-compile-times">&#13;
<h2>Project References</h2>&#13;
&#13;
<p>As your application grows, it will take longer and longer for TSC to typecheck and compile your code.<a data-primary="TypeScript" data-secondary="building a project" data-tertiary="project references" data-type="indexterm" id="ix_TSbldprref"/> This time grows roughly linearly with the size of your codebase. When developing locally, slow incremental compile times can seriously slow down your development, and make working with TypeScript painful.</p>&#13;
&#13;
<p>To address this,<a data-primary="project references" data-type="indexterm" id="ix_projref"/><a data-primary="TSC compiler" data-secondary="project references" data-type="indexterm" id="ix_TSCprojref"/> TSC comes with a feature called <em>project references</em> that speeds up compilation times dramatically, including incremental compile times. For any project with a few hundred files or more, project references are a must-have.</p>&#13;
&#13;
<p class="pagebreak-before">Use them like this:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Split your TypeScript project into multiple projects. A project is simply a folder that contains a <em>tsconfig.json</em> and some TypeScript code. Try to split your code in such a way that code that tends to be updated together lives in the same folder.</p>&#13;
</li>&#13;
<li>&#13;
<p>In each project folder, create a <em>tsconfig.json</em> that includes at least:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"composite"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"declaration"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"declarationMap"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"rootDir"</code><code class="p">:</code> <code class="s2">"."</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"include"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="s2">"./**/*.ts"</code>&#13;
  <code class="p">],</code>&#13;
  <code class="nt">"references"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"path"</code><code class="p">:</code> <code class="s2">"../myReferencedProject"</code><code class="p">,</code>&#13;
      <code class="nt">"prepend"</code><code class="p">:</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">],</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The keys here are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>composite</code>, which tells TSC that this folder is a subproject of a larger TypeScript project.<a data-primary="composite (compiler option)" data-type="indexterm" id="idm46304949542184"/></p>&#13;
</li>&#13;
<li>&#13;
<p><code>declaration</code>, which tells TSC to emit <em>.d.ts</em> declaration files for this project.<a data-primary="declaration (compiler option)" data-type="indexterm" id="idm46304949539752"/> The way project references work, projects have access to each other’s declaration files and emitted JavaScript, but not their source TypeScript files. This creates a boundary beyond which TSC won’t try to retypecheck or recompile your code: if you update a line of code in your subproject <em>A</em>, TSC doesn’t have to retypecheck your other subproject <em>B</em>; all TSC needs to check for a type error is <em>B</em>’s type declarations. This is the core behavior that makes project references so efficient at rebuilding big projects.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>declarationMap</code>, which tells TSC to build source maps for generated type declarations.<a data-primary="declarationMap (compiler option)" data-type="indexterm" id="idm46304949536200"/></p>&#13;
</li>&#13;
<li>&#13;
<p><code>references</code>, which is an array of subprojects that your subproject depends on. <a data-primary="references (compiler option)" data-type="indexterm" id="idm46304949534184"/>Each reference’s <code>path</code> should point either to a folder that contains a <em>tsconfig.json</em>, or directly to a TSC configuration file (if your configuration file isn’t named <em>tsconfig.json</em>). <code>prepend</code> will concatenate the JavaScript and source maps generated by the subproject you’re referencing to the JavaScript and source maps generated by your subproject. Note that <code>prepend</code> is only useful when you’re using <code>outFile</code>—if you don’t use <code>outFile</code>, you can ditch the <code>prepend</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>rootDir</code>, which explicitly specifies that this subproject should be compiled relative to the root project (<code>.</code>). Alternatively, you can specify an <code>outDir</code> that’s a subfolder of the root project’s <code>outDir</code>.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Create a root <em>tsconfig.json</em> that references any subprojects that aren’t yet referenced by another subproject:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"files"</code><code class="p">:</code> <code class="p">[],</code>&#13;
  <code class="nt">"references"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code><code class="nt">"path"</code><code class="p">:</code> <code class="s2">"./myProject"</code><code class="p">},</code>&#13;
    <code class="p">{</code><code class="nt">"path"</code><code class="p">:</code> <code class="s2">"./mySecondProject"</code><code class="p">}</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Now when you compile your project with TSC, use the <code>build</code> flag to tell TSC to take project <a data-primary="build flag (TSC)" data-type="indexterm" id="idm46304949517992"/>references into account:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">tsc --build <code class="c"># Or, tsc -b for short</code></pre>&#13;
</li>&#13;
&#13;
</ol>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>At the time of writing, project references are a new TypeScript feature with some rough edges. When using them, be careful to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Rebuild the entire project (with <code>tsc -b</code>) after cloning or refetching it, in order to regenerate any missing or outdated <em>.d.ts</em> files. Alternatively, check in your generated <em>d.ts</em> files.</p>&#13;
</li>&#13;
<li>&#13;
<p>Not use <code>noEmitOnError: false</code> with project references—TSC will always hardcode the option to <code>true</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Manually make sure that a given subproject isn’t prepended by more than one other subproject. Otherwise, the doubly prepended subproject will show up twice in your compiled output. Note that if you’re just referencing and not prepending, you’re good to go.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304949414088">&#13;
<h5>Using extends to Reduce tsconfig.json Boilerplate</h5>&#13;
<p>Because you probably want all of your subprojects to share the same compiler options, it’s convenient to create a “base” <em>tsconfig.json</em> in your root directory that<a data-primary="extends option (TSC)" data-type="indexterm" id="idm46304949461896"/> subprojects’ <em>tsconfig.json</em>s can extend:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"composite"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"declaration"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"declarationMap"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"lib"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"es2015"</code><code class="p">,</code> <code class="s2">"es2016.array.include"</code><code class="p">],</code>&#13;
    <code class="nt">"rootDir"</code><code class="p">:</code> <code class="s2">"."</code><code class="p">,</code>&#13;
    <code class="nt">"sourceMap"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"strict"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"target"</code><code class="p">:</code> <code class="s2">"es5"</code><code class="p">,</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then, update your subprojects to extend it using <em>tsconfig.json</em>’s <code>extends</code> option:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"extends"</code><code class="p">:</code> <code class="s2">"../tsconfig.base"</code><code class="p">,</code>&#13;
  <code class="nt">"include"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="s2">"./**/*.ts"</code>&#13;
  <code class="p">],</code>&#13;
  <code class="nt">"references"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="p">{</code>&#13;
      <code class="nt">"path"</code><code class="p">:</code> <code class="s2">"../myReferencedProject"</code><code class="p">,</code>&#13;
      <code class="nt">"prepend"</code><code class="p">:</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">],</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Error Monitoring" data-type="sect2"><div class="sect2" id="error-monitoring-sect">&#13;
<h2>Error Monitoring</h2>&#13;
&#13;
<p>TypeScript warns you about errors at compile time,<a data-primary="project references" data-startref="ix_projref" data-type="indexterm" id="idm46304949342744"/><a data-primary="TSC compiler" data-secondary="project references" data-startref="ix_TSCprojref" data-type="indexterm" id="idm46304949341768"/><a data-primary="TypeScript" data-secondary="building a project" data-startref="ix_TSbldprref" data-tertiary="project references" data-type="indexterm" id="idm46304949340552"/><a data-primary="TypeScript" data-secondary="building a project" data-tertiary="error monitoring" data-type="indexterm" id="idm46304949339064"/><a data-primary="errors" data-secondary="monitoring in TypeScript projects" data-type="indexterm" id="idm46304949337848"/> but you also need a way to find out about exceptions that your users experience at runtime, so that you can try to prevent them at compile time (or at least fix the bug that caused the runtime error). Use an error monitoring tool like <a href="https://sentry.io">Sentry</a> or <a href="https://bugsnag.com">Bugsnag</a> to report and collate your runtime exceptions.<a data-primary="TypeScript" data-secondary="building a project" data-startref="ix_TSbld" data-type="indexterm" id="idm46304949292792"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running TypeScript on the Server" data-type="sect1"><div class="sect1" id="Running-TypeScript-on-the-Server">&#13;
<h1>Running TypeScript on the Server</h1>&#13;
&#13;
<p>To run your TypeScript code in a NodeJS environment,<a data-primary="NodeJS" data-secondary="running TypeScript code in" data-type="indexterm" id="idm46304949289672"/> just compile your code to ES2015 JavaScript (or ES5, if you’re targeting a legacy <a data-primary="TypeScript" data-secondary="running on the server" data-type="indexterm" id="idm46304949288600"/>NodeJS version) with your <em>tsconfig.json</em>’s module flag set to <code>commonjs</code>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"target"</code><code class="p">:</code> <code class="s2">"es2015"</code><code class="p">,</code>&#13;
    <code class="nt">"module"</code><code class="p">:</code> <code class="s2">"commonjs"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That will compile your ES2015 <code>import</code> and <code>export</code> calls to <code>require</code> and <span class="keep-together"><code>module.exports</code></span>, respectively, so your code will run on NodeJS with no further bundling needed.</p>&#13;
&#13;
<p>If you’re using source maps (you should be!), you’ll need to feed your source maps into your NodeJS process. <a data-primary="source maps" data-secondary="feeding into NodeJS process" data-type="indexterm" id="idm46304949275784"/>Just grab the <a href="https://www.npmjs.com/package/source-map-support"><code>source-map-support</code></a> package from NPM, and follow the package’s setup instructions. Most process monitoring, logging, and error reporting tools like <a href="https://www.npmjs.com/package/pm2">PM2</a>, <a href="https://www.npmjs.com/package/winston">Winston</a>, and <a href="https://sentry.io">Sentry</a> have built-in support for source maps.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running TypeScript in the Browser" data-type="sect1"><div class="sect1" id="Running-TypeScript-in-the-Browser">&#13;
<h1>Running TypeScript in the Browser</h1>&#13;
&#13;
<p>Compiling TypeScript to run in the browser involves a little more work than running TypeScript on the server.<a data-primary="TypeScript" data-secondary="running in the browser" data-type="indexterm" id="idm46304949241816"/><a data-primary="browsers" data-secondary="running TypeScript code in" data-type="indexterm" id="idm46304949240840"/></p>&#13;
&#13;
<p>First, pick a module system to compile to.<a data-primary="modules" data-secondary="picking module system to compile TypeScript to" data-type="indexterm" id="idm46304949239448"/> A good rule of thumb is to stick to <code>umd</code> when publishing a library for others to use (e.g., on NPM) in order to maximize compatibility with various module bundlers that people might use in their projects.</p>&#13;
&#13;
<p>If you just plan to use your code yourself without publishing it to NPM, which format you compile to depends on the module bundler you’re using. Check your bundler’s documentation—for example, Webpack and Rollup work best with ES2015 modules, while Browserify requires CommonJS modules. Here are a few guidelines:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If you’re using the <a href="https://github.com/systemjs/systemjs">SystemJS</a> module loader, set <code>module</code> to <code>systemjs</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re running your code through an ES2015-aware module bundler like <a href="https://webpack.js.org">Webpack</a> or <a href="https://github.com/rollup/rollup">Rollup</a>, set <code>module</code> to <code>es2015</code> or higher.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re using an ES2015-aware module bundler and your code uses dynamic imports (see <a data-type="xref" href="ch10.html#dynamic_imports">“Dynamic Imports”</a>), set <code>module</code> to <code>esnext</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re building a library for other projects to use, and aren’t running your code through any additional build steps after <code>tsc</code>, maximize compatibility with different loaders that people use by setting <code>module</code> to <code>umd</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re bundling your module with a CommonJS bundler like <a href="https://github.com/browserify/browserify">Browserify</a>, set <code>module</code> to <code>commonjs</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re planning to load your code with <a href="https://requirejs.org">RequireJS</a> or another AMD module loader, set <code>module</code> to <code>amd</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you want your top-level exports to be globally available on the <code>window</code> object (as you might if you’re Mussolini’s great-nephew), set <code>module</code> to <code>none</code>. Note that TSC will try to curb your enthusiasm for inflicting pain on other software engineers by compiling to <code>commonjs</code> anyway if your code is in module mode (see <a data-type="xref" href="ch10.html#module-mode">“Module Mode Versus Script Mode”</a>).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Next, configure your build pipeline to compile all your TypeScript to a single JavaScript file (usually called a “bundle”) or a set of JavaScript files.<a data-primary="JavaScript" data-secondary="configuring build pipeline to compile TypeScript code to" data-type="indexterm" id="idm46304949200040"/><a data-primary="outFile TSC flag" data-type="indexterm" id="idm46304949199096"/> While TSC can do this for you for small projects with the <code>outFile</code> TSC flag, the flag is limited to generating SystemJS and AMD bundles.<a data-primary="TSC compiler" data-secondary="generating JavaScript bundles" data-type="indexterm" id="idm46304949197880"/> And since TSC doesn’t support build plugins and intelligent code splitting the same way that a dedicated build tool like Webpack does, you’ll soon find yourself wanting a more powerful bundler.</p>&#13;
&#13;
<p>That’s why for frontend projects, you should use a more powerful build tool from the beginning.<a data-primary="build tools" data-type="indexterm" id="idm46304949196104"/> There are TypeScript plugins for whatever build tool you might be using, such as:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="http://bit.ly/2Gw3uH2"><code>ts-loader</code></a> for <a href="https://webpack.js.org">Webpack</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/2KOaZgw"><code>tsify</code></a> for <a href="http://bit.ly/2IDpfGe">Browserify</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/2vc2Sjy"><code>@babel/preset-typescript</code></a> for <a href="https://babeljs.io">Babel</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/2vanubN"><code>gulp-typescript</code></a> for <a href="https://gulpjs.com">Gulp</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/2PgUXuq"><code>grunt-ts</code></a> for <a href="https://gruntjs.com">Grunt</a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>While a full discussion of optimizing your JavaScript bundle for fast loading is outside the scope of this book,<a data-primary="JavaScript" data-secondary="optimizing bundles for fast loading" data-type="indexterm" id="idm46304949183368"/> some brief advice—not specific to TypeScript—is:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Keep your code modular, and avoid implicit dependencies in your code (these can happen when you assign things to the <code>window</code> global, or to other globals), so that your build tool can more accurately analyze your project’s dependency graph.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use dynamic imports to lazy-load code that you don’t need for your initial page load, so you don’t unnecessarily block your page from rendering.</p>&#13;
</li>&#13;
<li>&#13;
<p>Take advantage of your build tool’s automatic code splitting functionality, so that you avoid loading too much JavaScript and slowing page load unnecessarily.</p>&#13;
</li>&#13;
<li>&#13;
<p>Have a strategy for measuring page load time, either synthetically or, ideally, with real user data. As your app grows the initial load time can get slower and slower; you can only optimize that load time if you have a way to measure it. Tools like <a href="https://newrelic.com">New Relic</a> and <a href="https://www.datadoghq.com">Datadog</a> are invaluable here.</p>&#13;
</li>&#13;
<li>&#13;
<p>Keep your production build as similar as possible to your development build. The more the two diverge, the more hard-to-fix bugs you’ll have that only show up in production.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, when shipping TypeScript to run in the browser, have a strategy for polyfilling missing browser features. This might be a standard set of polyfills you ship as part of every bundle, or it might be a dynamic set of polyfills based on what features the user’s browser supports.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Publishing Your TypeScript Code to NPM" data-type="sect1"><div class="sect1" id="idm46304949243256">&#13;
<h1>Publishing Your TypeScript Code to NPM</h1>&#13;
&#13;
<p>It’s easy to compile your TypeScript code so that other TypeScript and JavaScript projects can use it.<a data-primary="NPM package manager" data-secondary="publishing TypeScript code to" data-type="indexterm" id="ix_NPMpub"/><a data-primary="TypeScript" data-secondary="publishing code to NPM" data-type="indexterm" id="ix_TSpub"/> There are a few best practices to keep in mind when compiling to JavaScript for external use:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Generate source maps, so you can debug your own code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Compile to ES5, so that others can easily build and run your code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Be mindful about which module format you compile to (UMD, CommonJS, ES2015, etc.).</p>&#13;
</li>&#13;
<li>&#13;
<p>Generate type declarations, so that other TypeScript users have types for your code.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Start by compiling your TypeScript to JavaScript with <code>tsc</code>, and generate corresponding type declarations. Be sure to configure your <em>tsconfig.json</em> to maximize compatibility with popular JavaScript environments and build systems (more on that in <a data-type="xref" href="#building">“Building Your TypeScript Project”</a>):</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
<code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
  <code class="nt">"declaration"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nt">"module"</code><code class="p">:</code> <code class="s2">"umd"</code><code class="p">,</code>&#13;
  <code class="nt">"sourceMaps"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nt">"target"</code><code class="p">:</code> <code class="s2">"es5"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Next, blacklist your TypeScript source code from getting published to NPM in your <em>.npmignore</em>, to avoid bloating the size of your package. And in your <em>.gitignore</em>, exclude generated artifacts from your Git repository to avoid polluting it:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="c"># .npmignore</code>&#13;
&#13;
*.ts <code class="c"># Ignore .ts files</code>&#13;
!*.d.ts <code class="c"># Allow .d.ts files</code></pre>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="c"># .gitignore</code>&#13;
&#13;
*.d.ts <code class="c"># Ignore .d.ts files</code>&#13;
*.js <code class="c"># Ignore .js files</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you stuck with the recommended project layout and kept your source files in <em>src/</em> and your generated files in <em>dist/</em>, your <em>.ignore</em> files will be even simpler:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="c"># .npmignore</code>&#13;
&#13;
src/ <code class="c"># Ignore source files</code></pre>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="c"># .gitignore</code>&#13;
&#13;
dist/ <code class="c"># Ignore generated files</code></pre>&#13;
</div>&#13;
&#13;
<p>Finally, add a <code>"types"</code> field to your project’s <em>package.json</em> to indicate that it comes with type declarations (note that this isn’t mandatory, but it is a helpful hint to TSC for any consumers that use TypeScript), and add a script to build your package before publishing it, to make sure that your package’s JavaScript, type declarations, and source maps are always up to date and in sync with the TypeScript you compiled them from:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"my-awesome-typescript-project"</code><code class="p">,</code>&#13;
  <code class="nt">"version"</code><code class="p">:</code> <code class="s2">"1.0.0"</code><code class="p">,</code>&#13;
  <code class="nt">"main"</code><code class="p">:</code> <code class="s2">"dist/index.js"</code><code class="p">,</code>&#13;
  <code class="nt">"types"</code><code class="p">:</code> <code class="s2">"dist/index.d.ts"</code><code class="p">,</code>&#13;
  <code class="nt">"scripts"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"prepublishOnly"</code><code class="p">:</code> <code class="s2">"tsc -d"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That’s it! Now when you <code>npm publish</code> your package to NPM, NPM will automatically compile your TypeScript to a format usable by both people that use TypeScript (with full type safety) and people that use JavaScript (with some type safety, if their code editor supports it).<a data-primary="NPM package manager" data-secondary="publishing TypeScript code to" data-startref="ix_NPMpub" data-type="indexterm" id="idm46304949117272"/><a data-primary="TypeScript" data-secondary="publishing code to NPM" data-startref="ix_TSpub" data-type="indexterm" id="idm46304949000440"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Triple-Slash Directives" data-type="sect1"><div class="sect1" id="idm46304949172728">&#13;
<h1>Triple-Slash Directives</h1>&#13;
&#13;
<p>TypeScript comes with a little-known, rarely used, and mostly outdated feature called <em>triple-slash directives</em>.<a data-primary="triple-slash directives" data-type="indexterm" id="ix_triplesl"/><a data-primary="directives" data-secondary="triple-slash" data-type="indexterm" id="ix_dirtriplesl"/><a data-primary="TypeScript" data-secondary="triple-slash directives" data-type="indexterm" id="ix_TStriplesl"/> These directives are specially formatted TypeScript comments that serve as instructions to TSC.</p>&#13;
&#13;
<p>They come in a few flavors, and in this section, we’ll cover just two of them: <code>types</code>, for eliding type-only full-module imports, and <code>amd-module</code>, for naming generated AMD modules. For a full reference, see <a data-type="xref" href="app05.html#triple-slash-directives">Appendix E</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The types Directive" data-type="sect2"><div class="sect2" id="import-elision">&#13;
<h2>The types Directive</h2>&#13;
&#13;
<p>When you import something from a module, depending on what you imported, TypeScript won’t always need to generate an <code>import</code> or <code>require</code> call when you compile your code to JavaScript.<a data-primary="directives" data-secondary="triple-slash" data-tertiary="types" data-type="indexterm" id="idm46304948988184"/><a data-primary="types directive" data-type="indexterm" id="idm46304948986936"/><a data-primary="triple-slash directives" data-secondary="types" data-type="indexterm" id="idm46304948986264"/> If you have an <code>import</code> statement whose export is only used in a type position in your module (i.e., you just imported a type from a module), TypeScript won’t generate any JavaScript code for that <code>import</code>—think of it as only existing at the type level. <a data-primary="imports" data-secondary="import elision" data-type="indexterm" id="idm46304948984168"/>This feature is called <em>import elision</em>.</p>&#13;
&#13;
<p>The exception to the rule is imports used for side effects: if you import an entire module (without importing a specific export or a wildcard from that module), that import will generate JavaScript code when you compile your TypeScript. You might do this, for instance, if you want to make sure that an ambient type defined in a script-mode module is available in your program (like we did in <a data-type="xref" href="ch06.html#extending-the-prototype">“Safely Extending the Prototype”</a>). For example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// global.ts</code>&#13;
<code class="nx">type</code> <code class="nx">MyGlobal</code> <code class="o">=</code> <code class="kt">number</code>&#13;
&#13;
<code class="c1">// app.ts</code>&#13;
<code class="kr">import</code> <code class="s1">'./global'</code></pre>&#13;
&#13;
<p>After compiling <em>app.ts</em> to JavaScript with <code>tsc app.ts</code>, you’ll notice that that the <span class="keep-together"><code>./global</code></span> import wasn’t elided:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// app.js</code>&#13;
<code class="kr">import</code> <code class="s1">'./global'</code></pre>&#13;
&#13;
<p>If you find yourself writing imports like this, you may want to start by making sure that your import really needs to use side effects, and that there isn’t some other way to rewrite your code to make it more explicit which value or type you’re importing (e.g., <code>import {MyType} from './global'</code>—which TypeScript will elide for you—instead of <code>import './global'</code>). Or, see if you can include your ambient type in your <em>tsconfig.json</em>’s <code>types</code>, <code>files</code>, or <code>include</code> field and avoid the import altogether.</p>&#13;
&#13;
<p>If neither of those works for your use case, and you want to continue to use a full-module import but avoid generating a JavaScript <code>import</code> or <code>require</code> call for that import, use the <code>types</code> triple-slash directive. A triple-slash directive is three slashes <code>///</code> followed by one of a few possible XML tags, each with its own set of required attributes. For the <code>types</code> directive, it looks like this:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Declare a dependency on an ambient type declaration:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">/// &lt;reference types="./global" /&gt;</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Declare a dependency on <em>@types/jasmine/index.d.ts</em>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">/// &lt;reference types="jasmine" /&gt;</code></pre>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You probably won’t find yourself using this directive often. And if you do, you may want to rethink how you’re using types in your project, and consider if there’s a way to rely less on ambient types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The amd-module Directive" data-type="sect2"><div class="sect2" id="triple-slash-amd">&#13;
<h2>The amd-module Directive</h2>&#13;
&#13;
<p>When compiling your TypeScript code to the AMD module format (indicated with <code>{"module": "amd"}</code> in your <em>tsconfig.json</em>), TypeScript will generate anonymous AMD modules by default.<a data-primary="modules" data-secondary="amd-module directive" data-type="indexterm" id="idm46304948839016"/><a data-primary="amd-module directive" data-type="indexterm" id="idm46304948899576"/><a data-primary="directives" data-secondary="triple-slash" data-tertiary="amd-module" data-type="indexterm" id="idm46304948898904"/><a data-primary="triple-slash directives" data-secondary="amd-module" data-type="indexterm" id="idm46304948897688"/> You can use the AMD triple-slash directive to give your emitted modules names.</p>&#13;
&#13;
<p>Let’s say you have the following code:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">export</code> <code class="kd">let</code> <code class="nx">LogService</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">log() {</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Compiling to the <code>amd</code> module format, TSC generates the following JavaScript code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">define</code><code class="p">([</code><code class="s1">'require'</code><code class="p">,</code> <code class="s1">'exports'</code><code class="p">],</code> <code class="kd">function</code><code class="p">(</code><code class="nx">require</code><code class="p">,</code> <code class="nx">exports</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">exports</code><code class="p">.</code><code class="nx">__esModule</code> <code class="o">=</code> <code class="kc">true</code>&#13;
  <code class="nx">exports</code><code class="p">.</code><code class="nx">LogService</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">log</code><code class="p">()</code> <code class="p">{</code>&#13;
      <code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>If you’re familiar with the AMD module format, you might have noticed that this is an anonymous AMD module. To give your AMD module a name, use the <code>amd-module</code> triple-slash directive in your code:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">/// &lt;amd-module name="LogService" /&gt; </code><a class="co" href="#callout_building_and_running_typescript_CO1-1" id="co_building_and_running_typescript_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="c1">&#13;
</code><code class="kr">export</code><code> </code><code class="kd">let</code><code> </code><code class="nx">LogService</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_building_and_running_typescript_CO1-2" id="co_building_and_running_typescript_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">log() {</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_building_and_running_typescript_CO1-1" id="callout_building_and_running_typescript_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We use the <code>amd-module</code> directive, and set a <code>name</code> attribute on it.</p></dd>&#13;
<dt><a class="co" href="#co_building_and_running_typescript_CO1-2" id="callout_building_and_running_typescript_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The rest of our code is unchanged.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Recompiling to the AMD module format with TSC, we now get the following JavaScript:</p>&#13;
<pre data-code-language="js" data-type="programlisting">&#13;
<em><code class="c1">/// &lt;amd-module name='LogService' /&gt;</code></em><code class="c1">&#13;
</code><code class="nx">define</code><code class="p">(</code><strong><code class="s1">'LogService'</code><code class="p">,</code><code> </code></strong><code class="p">[</code><code class="s1">'require'</code><code class="p">,</code><code> </code><code class="s1">'exports'</code><code class="p">]</code><code class="p">,</code><code> </code><code class="kd">function</code><code class="p">(</code><code class="nx">require</code><code class="p">,</code><code> </code><code class="nx">exports</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">exports</code><code class="p">.</code><code class="nx">__esModule</code><code> </code><code class="o">=</code><code> </code><code class="kc">true</code><code>&#13;
  </code><code class="nx">exports</code><code class="p">.</code><code class="nx">LogService</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">log</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
      </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code>&#13;
</code></pre>&#13;
&#13;
<p>When compiling to AMD modules, use the <code>amd-module</code> directive to make your code easier to bundle and debug (or, switch to a more modern module format like ES2015 modules if you can).<a data-primary="triple-slash directives" data-startref="ix_triplesl" data-type="indexterm" id="idm46304948641320"/><a data-primary="directives" data-secondary="triple-slash" data-startref="ix_dirtriplesl" data-type="indexterm" id="idm46304948652168"/><a data-primary="TypeScript" data-secondary="triple-slash directives" data-startref="ix_TStriplesl" data-type="indexterm" id="idm46304948650984"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304948841016">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we covered everything you need to know to build and run your TypeScript application in production, either in the browser or on the server. We discussed how to choose a JavaScript version to compile to, which libraries to mark as available in your environment (and how to polyfill libraries when they’re missing), and how to build and ship source maps with your application to make it easier to debug in production and develop locally. We then explored how to modularize your TypeScript project to keep compilation times fast. Finally, we finished up with how to run your TypeScript application on the server and in the browser, how to publish your TypeScript code to NPM for others to use, how import elision works, and—for AMD users—how to use triple-slash directives to name your modules.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304949773272"><sup><a href="ch12.html#idm46304949773272-marker">1</a></sup> If you use a language feature that TSC doesn’t transpile and your target environment doesn’t support it either, you can usually find a Babel plugin to transpile it for you. To find the most up-to-date plugin, search for “babel plugin &lt;feature name&gt;” in your favorite search engine.</p></div></div></section></body></html>