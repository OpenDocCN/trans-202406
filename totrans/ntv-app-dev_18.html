<html><head></head><body><section data-pdf-bookmark="Chapter 16. Building an App" data-type="chapter" epub:type="chapter"><div class="chapter" id="app_project">&#13;
<h1><span class="label">Chapter 16. </span>Building an App</h1>&#13;
&#13;
&#13;
<p>Imagine yourself walking through the broad, worn oak doors of Dunn &amp; Lewis Memorial Library in search of knowledge. As you enter, you are greeted with a seemingly never-ending sea of wooden shelves rivaling the Great Library of Alexandria. You stagger from shelf to shelf but have no idea what books are available and where they are located. Frustrated, and alone, you are about to leave the library for good when an old librarian beckons you closer.</p>&#13;
&#13;
<p>The librarian has a musty, but familiar, smell of old books and mahogany about him. You walk closer, but before you can go much further he points knowingly to a flyer taped on the wall that heralds your salvation: an app is available for download to help you find the books you need. Your days of wandering are over!</p>&#13;
&#13;
<p>But, where is the app? You can’t download it. What do you mean it doesn’t exist yet? The librarian whispers quietly in a gruff voice, “If you build it, they will download it,” and disappears into the darkness of the corridor.</p>&#13;
&#13;
<p>We’re going to build this app.</p>&#13;
&#13;
<p>Now, forgetting about our ominous and magical librarian for a moment, in <a data-type="xref" href="ch15.html#app_setup">Chapter 15</a>, we showed you how to set up your environment and create the simplest, most bare-bones application possible. In reality, however, apps are much more complex. For starters, they are usually more than just one screen. In order to really learn a platform it’s necessary to build something of sufficient complexity—beyond the basic “hello world” example—so you can get an understanding of the boundaries and nuances of the technologies used. To give us something complex enough to work on, we’re going to build an app for a library—yes, the same app foretold by our librarian guide—to help patrons of Dunn &amp; Lewis Memorial Library find the books they need.</p>&#13;
&#13;
<p class="less_space pagebreak-before">In<a data-primary="application creation" data-secondary="task overview" data-type="indexterm" id="idm46177214654408"/> this chapter we will:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Create a new project for our app.</p>&#13;
</li>&#13;
<li>&#13;
<p>Give a brief overview of the app we’re building.</p>&#13;
</li>&#13;
<li>&#13;
<p>Add a simple welcome screen.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s get started before the blood moon rises and our project is doomed!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a New Project" data-type="sect1"><div class="sect1" id="idm46177214627000">&#13;
<h1>Creating a New Project</h1>&#13;
&#13;
<p>Ideally, you’ve gotten your environment set up already. If not, head over to the first chapter of <a data-type="xref" href="part02.html#part_2_app">Part II</a> and spend some time to get both Android and iOS ready for development. Once you’re ready to go, let’s dive in with Android first.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android Studio" data-type="sect2"><div class="sect2" id="idm46177214624456">&#13;
<h2>Android Studio</h2>&#13;
&#13;
<p>If<a data-primary="application creation" data-secondary="creating new projects" data-tertiary="Android Studio" data-type="indexterm" id="ACcreatas16"/><a data-primary="Android Studio" data-secondary="creating new projects" data-type="indexterm" id="AScreatnew16"/> you are not coming to the new project flow directly from the installation flow, you can always get here by selecting File from the Android Studio toolbar, then New Project.</p>&#13;
&#13;
<p>Android Studio will allow you to choose from some basic project templates, like Basic Activity or Empty Activity, or more advanced things like Java Library (<em>.jar</em>, straight Java) or Android Library (<em>.aar</em>, Java, plus resources and other Android specific files). You may want to try some of these others out later, but for now, let’s just go with Empty Activity, as shown in <a data-type="xref" href="#figures_android_setup_choose_project">Figure 16-1</a>.</p>&#13;
&#13;
<p>The first step in the create project flow is to configure your project. Here, you’ll determine the application’s location on disk, the namespace, and the minimum API that your application will support. This last bit is actually pretty important. You<a data-primary="Android" data-secondary="versions of" data-type="indexterm" id="idm46177214616664"/> can always check out distribution numbers for the <a href="https://oreil.ly/3h0X1">various Android versions</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figures_android_setup_choose_project">&#13;
<img alt="Choose Project" src="assets/nmdv_1601.png"/>&#13;
<h6><span class="label">Figure 16-1. </span>Choose project</h6>&#13;
</div></figure>&#13;
&#13;
<p>At the time of this writing, it looks like it’s pretty safe to choose OS 19, codename KitKat, version 4.4. That covers all but a couple percent of the installs at this time. However, if your app is likely to target more technically savvy users, or affluent countries, you might want to choose OS 20, codename<a data-primary="Lollipop" data-type="indexterm" id="idm46177214612088"/> Lollipop, version 5.0. This will cost you about 7% of the world, but will make development a bit easier. Android 5 was a big step forward in Android development and is a line of demarcation for a lot of modern APIs. This is your decision, but for this simple project, we’ll choose<a data-primary="Kitkat" data-type="indexterm" id="idm46177214610952"/> Kitkat, as shown in <a data-type="xref" href="#figures_android_setup_configure_project">Figure 16-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figures_android_setup_configure_project">&#13;
<img alt="Configure Project" src="assets/nmdv_1602.png"/>&#13;
<h6><span class="label">Figure 16-2. </span>Configure project</h6>&#13;
</div></figure>&#13;
&#13;
<p>That’s really it! Run your project from the toolbar shortcut (looks like a green Play button) or press control/command + R or from Run select Run App or Run from the submenu.</p>&#13;
&#13;
<p>The first time you do this, you’ll need either a connected device or to create and launch an<a data-primary="Android" data-secondary="emulators" data-type="indexterm" id="idm46177214606072"/><a data-primary="emulators" data-type="indexterm" id="idm46177214605096"/> emulator, as shown in <a data-type="xref" href="#figures_android_setup_create_emulator">Figure 16-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figures_android_setup_create_emulator">&#13;
<img alt="Create Emulator" src="assets/nmdv_1603.png"/>&#13;
<h6><span class="label">Figure 16-3. </span>Create emulator and choose emulator or device</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, you should see “Hello World!” print to the screen, as shown in <a data-type="xref" href="#figures_android_setup_hello_world">Figure 16-4</a>.</p>&#13;
&#13;
<figure class="width-30"><div class="figure" id="figures_android_setup_hello_world">&#13;
<img alt="Hello, World!" src="assets/nmdv_1604.png"/>&#13;
<h6><span class="label">Figure 16-4. </span>Hello World!</h6>&#13;
</div></figure>&#13;
&#13;
<p>You should also see a toolbar with My Application (or the application you provided in the project configuration step). So how does it know to say “Hello World!”? Well, the Empty Activity project template isn’t really empty—if you open <em>MainActivity.java</em>, you’ll see a reference to a layout file, <em>R.layout.activity_main</em>. Find that file in <em>res/layout</em> or just control/command-click the line in the code editor. You’ll probably see a <code>ConstrainLayout</code>, with a <code>TextView</code> child. Note the <code>android:text</code> attribute of the <code>TextView</code> is set to the string value of “Hello World!”</p>&#13;
&#13;
<p>Let’s make a quick edit. Change the text value of the <code>TextView</code> to say “iOS is awesome!” “iOS?!” you exclaim—yep, iOS…let’s get the whole competition nonsense out of the way. Both platforms are incredible. You may prefer a feature or syntactical turn in one or the other, but let’s face it—both do an amazing job allowing us to express our ideas.</p>&#13;
&#13;
<p>Anyway—run your app again. Now you should see something a little different, as shown in <a data-type="xref" href="#figures_android_setup_ios_is_awesome">Figure 16-5</a>.</p>&#13;
&#13;
<figure class="width-30"><div class="figure" id="figures_android_setup_ios_is_awesome">&#13;
<img alt="iOS is awesome!" src="assets/nmdv_1605.png"/>&#13;
<h6><span class="label">Figure 16-5. </span>iOS is awesome!</h6>&#13;
</div></figure>&#13;
&#13;
<p>That’s it! You’ve downloaded and installed Android Studio, created a basic app, and changed some visual values. While this is a pretty basic example, don’t worry—in a couple chapters we’ll walk you through creating a full-featured app using all of the tasks in the first part of this book.<a data-primary="" data-startref="ACcreatas16" data-type="indexterm" id="idm46177214588520"/><a data-primary="" data-startref="AScreatnew16" data-type="indexterm" id="idm46177214587544"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Xcode" data-type="sect2"><div class="sect2" id="idm46177214623864">&#13;
<h2>Xcode</h2>&#13;
&#13;
<p>The<a data-primary="application creation" data-secondary="creating new projects" data-tertiary="Xcode" data-type="indexterm" id="ACcreatx16"/><a data-primary="Xcode" data-secondary="creating new projects" data-type="indexterm" id="Xappnew16"/> process of setting up an iOS project in Xcode is similar to Android Studio, but there is a bit more of a software wizard process to follow. To get started, you’ll want to launch Xcode by going to Applications and double-clicking the Xcode application. Whenever Xcode launches, you’ll see a screen similar to <a data-type="xref" href="#figures_xcode_launch">Figure 16-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figures_xcode_launch">&#13;
<img alt="Xcode splash screen" src="assets/nmdv_1606.png"/>&#13;
<h6><span class="label">Figure 16-6. </span>Xcode splash screen</h6>&#13;
</div></figure>&#13;
&#13;
<p>Click the “Create a new Xcode project” button to start your project. A new Xcode window will open, and you’ll be presented with a list of templates to provide a project skeleton with some views and boilerplate code to get your started quickly. There are a number of options available for building both applications and libraries, but we’re going to focus in on the application options available. Our particular project will have a number of screens, but for now we’re going to use “Single View App” as a way to get up and running quickly without too much overhead. Select that as an option and hit Next in the template chooser.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you don’t see the Xcode launch screen, don’t fear! Head over to the menu bar and select File &gt; New &gt; Project to get started.</p>&#13;
</div>&#13;
&#13;
<p>Next, there are a number of options we can use to bootstrap the project. Most of these options are fine with their defaults. We can change everything on this screen later, but it’s helpful to set some of them ahead of time. The first option we should fill in is Product Name. This is part of the name iOS uses for our application internally, along with the organization identifier. By default, it’s also the name that’s displayed to the user underneath the icon of the app on a device’s launch screen. Let’s put “Library Buddy” as the name of our application.</p>&#13;
&#13;
<p>The Organization Identifier field is usually a reverse domain-style identifier of a company or organization (or individual!). Feel free to use whatever identifier you’d prefer, but for the purposes of this book, we’ll use “com.oreilly” as our identifier.</p>&#13;
&#13;
<p>Make sure the language selected is Swift and none of the checkmarks for Core Data or unit and UI tests are checked. Click Next to move forward. Select the file location where you want the project to live and hit the Create button to create the project.&#13;
Whenever the project is finished being created, you’ll see the project open up in an Xcode window with the project files displayed on the left side.</p>&#13;
&#13;
<p>Click the “Build and Run” button (it looks like a play button) in the top left of the project window. This will build the project, open up an iOS Simulator, and run the application. You should see something like <a data-type="xref" href="#figures_ios_simulator">Figure 16-7</a> running inside an iOS device on your desktop when the project is built and running.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>If<a data-primary="simulators" data-type="indexterm" id="idm46177214571656"/><a data-primary="iOS" data-secondary="simulators" data-type="indexterm" id="idm46177214570920"/> there isn’t an iOS Simulator selected by default in the drop-down near the “Build and Run” button described previously, you’ll need to use it to select one. If no simulators are listed, head to the menu bar and select Window &gt; Devices &amp; Simulators to bring up the Device Organizer. Select Simulators at the top of the window and then click the “+” button at the bottom left of the screen to add a new simulator to use for development.</p>&#13;
</div>&#13;
&#13;
<figure class="width-30"><div class="figure" id="figures_ios_simulator">&#13;
<img alt="Our Single View Application running in an iOS Simulator within Xcode" src="assets/nmdv_1607.png"/>&#13;
<h6><span class="label">Figure 16-7. </span>Our “Single View Application” running in an iOS Simulator within Xcode</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the interest of fairness with our Android example—and to demonstrate a complete lack of bias or prejudice against one platform or another—let’s go ahead and add a label to our application’s screen that gives praise to Android. In the list of files, click on Main.storyboard, click the “+” button at the top right of the window, and drag a label object onto the blank white canvas. Double-click on the label so you can change the text to “Android is awesome!” Drag the label to center it in the view and build and run the application like you did before and you’ll see a screen that looks like <a data-type="xref" href="#figures_android_simulator">Figure 16-8</a>.</p>&#13;
&#13;
<figure class="width-30"><div class="figure" id="figures_android_simulator">&#13;
<img alt="Android is awesome!" src="assets/nmdv_1608.png"/>&#13;
<h6><span class="label">Figure 16-8. </span>Android is awesome!</h6>&#13;
</div></figure>&#13;
&#13;
<p>All right, we’ve got our project created and it’s (ideally) able to build and run on an iOS Simulator. Before we go further, let’s talk about what we’re building.<a data-primary="" data-startref="ACcreatx16" data-type="indexterm" id="idm46177214562168"/><a data-primary="" data-startref="Xappnew16" data-type="indexterm" id="idm46177214561192"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="App Architecture" data-type="sect1"><div class="sect1" id="idm46177214560120">&#13;
<h1>App Architecture</h1>&#13;
&#13;
<p>Without<a data-primary="application creation" data-secondary="app architecture" data-type="indexterm" id="idm46177214558440"/> getting into too much detail, the application we’re building over the next few chapters will have a number of unique screens that display different types of data. Whenever the app launches, we’ll have a Welcome screen, along with three buttons. These three buttons will take you to different parts of the app: a listing of all the books available; a listing of all books a user has saved for later; and a search screen where a user can search for a specific title or author.</p>&#13;
&#13;
<p>From these screens, we’ll also build out a separate, reusable screen that is used by each of these screens to list all the information about a particular book.</p>&#13;
&#13;
<p>One of the benefits of Android and iOS is that you are not locked into a specific choice in terms of how to structure your app. There are a number of options available, but both platforms seem to have a<a data-primary="Model-View-ViewModel (MVVM)" data-type="indexterm" id="idm46177214555608"/> preference for MVC- or MVVM-style application development. As such, we’ll use that approach to build our apps.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Model-View-Controller" data-type="sect3"><div class="sect3" id="idm46177214554504">&#13;
<h3>Model-View-Controller</h3>&#13;
&#13;
<p>Model-View-Controller or MVC<a data-primary="Model-View-Controller (MVC)" data-type="indexterm" id="idm46177214553032"/> is, arguably, the most common approach to application development. Basically, it’s an architectural pattern that guides the code structure of the objects that make up your application. The “model” in MVC is a representation of the data the application needs. This could be persisted data (i.e., books saved for later) or transient data that is received from a network request. There is a separation between this data and the views an application contains; controllers are objects that facilitate communication between both the data model and views.</p>&#13;
&#13;
<p>Typically, the controller is responsible for getting data from a database or a network resource, and it gives that data to a view or view model that’s passed to the view for display. There are special controllers that are responsible for displaying the views themselves as well. In Android, these are <code>Activity</code> objects and in iOS, they are <code>UIViewController</code>s.</p>&#13;
&#13;
<p>The primary goal of an MVC architecture is to utilize and respect the inherent boundaries in objects to prevent close coupling of objects. This makes maintenance easier, and it provides a defined, straightforward way to think about code.</p>&#13;
&#13;
<p>With MVC in mind, let’s look at how we can create the first screen a user sees when they open up the app: the welcome screen.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Building Our First Screen" data-type="sect1"><div class="sect1" id="idm46177214548632">&#13;
<h1>Building Our First Screen</h1>&#13;
&#13;
<p>If you recall from our preceding example, the application screen inside the emulator on Android and simulator on iOS is pretty basic and devoid of any kind of design or data. We should fix that.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note<a data-primary="launch screens" data-type="indexterm" id="idm46177214545704"/><a data-primary="iOS" data-secondary="launch screens" data-type="indexterm" id="idm46177214544968"/><a data-primary="Android" data-secondary="launch screens" data-type="indexterm" id="idm46177214544024"/> that both Android and iOS use the notion of a “launch screen.” This is a static image displayed while the application itself is performing setup operations. Note that very little can be done to decorate this beyond drawable objects, and things like interactive UI elements or network requests are either impossible or <span class="keep-together">unadvisable</span>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect2"><div class="sect2" id="idm46177214541704">&#13;
<h2>Android</h2>&#13;
&#13;
<p>In<a data-primary="application creation" data-secondary="building initial screen" data-tertiary="Android" data-type="indexterm" id="ACbuildand16"/><a data-primary="Android" data-secondary="application creation" data-type="indexterm" id="ANappiniti16"/> the Android framework, the launch screen happens during app initialization and only displays an XML drawable. That means no logic, and not even <code>Drawable</code> class instances are available (although, after API 26, custom XML drawables are allowed, which could reference back to a <code>Drawable</code> subclass). Also be aware that this happens so early in the process that the framework doesn’t have access to many of the values we might normally take advantage of, like API version, so trying to provide different drawable files for different versions would fail. We’ll provide detailed instruction on how to set this up in the following section.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Launch Screen" data-type="sect3"><div class="sect3" id="idm46177214535848">&#13;
<h3>Launch Screen</h3>&#13;
&#13;
<p>In the Android framework, the launch screen displayed while the application is initializing is exactly equal to the theme’s window background. This can be any <code>Drawable</code> instance, which of course means it can be a group of drawing operations grouped within a single instance. For our example, let’s use a black background and center our logo, using a <code>layer-list</code> XML <code>Drawable</code>. We’ll name the file <em>launch_drawable.xml</em> and save it in <em>res/drawable</em>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;layer-list</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;item&gt;</code>&#13;
    <code class="nt">&lt;color</code> <code class="na">android:color=</code><code class="s">"#FF000000"</code> <code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;/item&gt;</code>&#13;
  <code class="nt">&lt;item&gt;</code>&#13;
    <code class="nt">&lt;bitmap</code>&#13;
        <code class="na">android:gravity=</code><code class="s">"center"</code>&#13;
        <code class="na">android:src=</code><code class="s">"@drawable/dlml_logo"</code>&#13;
        <code class="na">android:tileMode=</code><code class="s">"disabled"</code> <code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;/item&gt;</code>&#13;
<code class="nt">&lt;/layer-list&gt;</code></pre>&#13;
&#13;
<p>You’ll notice a reference to a compiled bitmap resource. In your favorite photo editing software, generate some stylized version of the application name, library name, maybe a symbolic representation, or just the initials—whatever, it’s up to you. As with all compiled resources in Android, file names must be all lowercase, words separated with underscores, and only alphanumeric characters: a-z and 0-9. Let’s name the image file <em>dlml_logo.xml</em> and save it in our <em>res/drawable</em> directory. The system will make this a constant value of the global <code>R</code> class, in the following format: <code>R.{resource_tye}.{file_name_minus_ext}</code>, so in this case, <code>R.drawable.dlml_logo</code> would be an integer identifier for the <code>Bitmap</code> resource of our logo.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177214509240">&#13;
<h5>Drawable Resources and Density</h5>&#13;
<p>In<a data-primary="Android" data-secondary="drawable resources and density" data-type="indexterm" id="idm46177214507672"/><a data-primary="drawable resources and density (Android)" data-type="indexterm" id="idm46177214506648"/><a data-primary="density categories (Android)" data-type="indexterm" id="idm46177214505944"/> Android, each device is given a density category: low (ldpi), medium (mdpi), high (hdpi), extra high (xhdpi), extra-extra high (xxhdpi), and extra-extra-extra high (xxxhdpi). This is set by the device itself, and you don’t need to be aware of it <span class="keep-together">specifically</span>.</p>&#13;
&#13;
<p>However, you can take advantage of automatic image scaling by using specific directories inside the <em>res</em> folder. Here’s a quick breakdown:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>/res/drawable/ldpi</em> images are 75% the size of a standard image.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>/res/drawable/mdpi</em> images are 100% size, the same as you’d see in a standard webpage or photo viewing software.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>/res/drawable/hdpi</em> images are 150% size.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>/res/drawable/xhdpi</em> images are 200% size.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>/res/drawable/xxhdpi</em> images are 300% size.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>/res/drawable/xxxhdpi</em> images are 400% size.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>So if your image should be 100 pixels wide by 40 pixels tall, you should create a version at 75% size, i.e., 75 pixels wide and 30 pixels tall, and save it in the <em>/res/drawable/ldpi</em> directory. The original image would go in the <em>/res/drawable/mdpi</em> directory. Double the image to 200 pixels wide and 80 pixels tall and save it in the <em>/res/drawable/hdpi</em> directory, etc. The system will check the device’s density and find the appropriate image to display.</p>&#13;
&#13;
<p>Note that the system generally does a good job of scaling down (but not scaling up), so some developers will simply create the largest size image they wish to support (usually xxhdpi or xxxhpi) and save that in the appropriate directory, knowing that the system will scale it down appropriately for lower-density devices. That<a data-primary="Android Bundles" data-type="indexterm" id="idm46177214492744"/> said, <em>Android Bundles</em>, a fairly recent feature available on the Play Store, can smartly select the appropriate assets for a device prior to download and prepare an APK file that only contains the file that specific device needs.</p>&#13;
</div></aside>&#13;
&#13;
<p>If you so choose, you could create a double-sized image and add it to the <em>/res/drawable/xhdpi</em> directory. See the preceding note for specifics on density-specific images.</p>&#13;
&#13;
<p>Moving on from general resources and returning to our examination of theme implementation, in a values file (let’s use the <em>styles.xml</em> that Android Studio should already have created for you, in the <em>res/values</em> directory), let’s replace the project default theme with a simple theme of our own:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;style</code> <code class="na">name=</code><code class="s">"DlmlTheme"</code> <code class="na">parent=</code><code class="s">"Theme.AppCompat.Light.NoActionBar"</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;item</code> <code class="na">name=</code><code class="s">"android:windowBackground"</code><code class="nt">&gt;</code>@drawable/launch_drawable<code class="nt">&lt;/item&gt;</code>&#13;
<code class="nt">&lt;/style&gt;</code></pre>&#13;
&#13;
<p>Obviously, we could and probably should set a number of other theme-specific values, like color, action bar, and coordinator layout support, etc., but for the purpose of this example, we’ll keep it simple.</p>&#13;
&#13;
<p>To register this theme with your app, you’ll use the application’s manifest <em>AndroidManifest.xml</em>. You’ll be using this manifest file several times when configuring your application, but we’ll take it one step at a time. For now, let’s just register our theme:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;manifest</code> <code class="na">package=</code><code class="s">"com.dlml"</code>&#13;
          <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
          <code class="na">xmlns:tools=</code><code class="s">"http://schemas.android.com/tools"</code><code class="nt">&gt;</code>&#13;
&#13;
  <code class="nt">&lt;application</code>&#13;
      <code class="na">android:icon=</code><code class="s">"@mipmap/ic_launcher"</code>&#13;
      <code class="na">android:label=</code><code class="s">"@string/app_name"</code>&#13;
      <code class="na">android:roundIcon=</code><code class="s">"@mipmap/ic_launcher_round"</code>&#13;
      <code class="na">android:supportsRtl=</code><code class="s">"true"</code>&#13;
      <code class="na">android:theme=</code><code class="s">"@style/DlmlTheme"</code> <code class="nt">/&gt;</code>&#13;
&#13;
<code class="nt">&lt;/manifest&gt;</code></pre>&#13;
&#13;
<p>That’s it! Now, when your application launches, before the user can interact, they’ll see the drawable we provided in <em>launch_drawable.xml</em>. At first, while your application is still young and innocent and lightweight, this might only flash momentarily, or launch may happen so fast the user doesn’t see it at all, but as more activities, permissions, assets, resources, external libraries, and build configurations are added, initialization time will increase, so it’s usually a good idea to let the user know what application is being launched and that they’re not simply hung, but rather being hand-crafted a unique experience.<a data-primary="" data-startref="ACbuildand16" data-type="indexterm" id="idm46177214420088"/><a data-primary="" data-startref="ANappiniti16" data-type="indexterm" id="idm46177214419240"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="iOS" data-type="sect2"><div class="sect2" id="idm46177214394504">&#13;
<h2>iOS</h2>&#13;
&#13;
<p>After<a data-primary="application creation" data-secondary="building initial screen" data-tertiary="iOS" data-type="indexterm" id="ACbuildios16"/><a data-primary="iOS" data-secondary="application creation" data-type="indexterm" id="IOSappbuild16"/> you’ve added a screen on Android, you’ll find it’s not altogether different on iOS. We’re<a data-primary="storyboards" data-secondary="building initial screen" data-type="indexterm" id="idm46177214389160"/><a data-primary="Xcode" data-secondary="building initial screen" data-type="indexterm" id="idm46177214388216"/><a data-primary="Xcode" data-secondary="storyboard editor" data-type="indexterm" id="idm46177214387272"/> going to start within the storyboard editor in Xcode. Click on our application’s main storyboard, <em>Main.storyboard</em>, within the project navigator on the left side of the screen. This will bring up the storyboard editor.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There is also <em>LaunchScreen.storyboard</em>. This is used to present a design when the application is launching, but before it’s active.</p>&#13;
</div>&#13;
&#13;
<p>Storyboards are a format for keeping views—called “scenes”—and their transitions between other scenes organized within an Xcode project. They can, and should, contain multiple scenes that are linked together via segues—predetermined transitions between scenes—as well as simple views like buttons, labels, etc., within the scenes themselves. Storyboards can even link to other storyboards!</p>&#13;
&#13;
<p>When we open up <em>Main.storyboard</em>, you should see one scene called View Controller Scene in the document outline on the left. This scene is automatically created as part of the boilerplate code created in the Single View Application we created earlier. We could reuse this scene and rename it, but instead we’re going to create a new scene.</p>&#13;
&#13;
<p>First, click the Library button, the leftmost button near the top right of the project window. This will bring up a floating window where you can drag and drop views and components onto the storyboard editor. Scroll down until you see the View Controller object in the list of results, or search for “view controller” as shown below.</p>&#13;
&#13;
<p>Next, drag the View Controller object from the window down onto the storyboard editor canvas. Place the new view controller scene wherever you’d like on the canvas. Additionally, you can double-click on the View Controller object and a new scene will be placed within the canvas for you.</p>&#13;
&#13;
<p>Now, let’s add some text to this view. We do this by using the Library window again and find the Label object. Drag the label over our new view controller scene. Whenever you hover over the scene, it’ll highlight blue to indicate that this is the scene where the label will be embedded. Once you are on the correct scene, let go of the label and it’ll appear selected on the screen. You’ll also notice it appears within the<a data-primary="Document Outline" data-type="indexterm" id="idm46177214379512"/> Document Outline in our new scene on the left side of the editor as shown.</p>&#13;
&#13;
<p>Let’s change the text of the label to display something else. Within the storyboard editor, there are a number of inspectors you can toggle through on the right side of the screen. These inspectors change context based on the object selected. With the label still selected—or by clicking on it to select it—click the<a data-primary="Attributes inspector" data-type="indexterm" id="idm46177214377960"/> Attributes inspector icon, which happens to be the fourth button from the left. You should see a screen like the one shown in <a data-type="xref" href="#figures_attributes_inspector">Figure 16-9</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figures_attributes_inspector">&#13;
<img alt="Attributes inspector in Xcode" src="assets/nmdv_1609.png"/>&#13;
<h6><span class="label">Figure 16-9. </span>Attributes inspector in Xcode</h6>&#13;
</div></figure>&#13;
&#13;
<p>The<a data-primary="Xcode" data-secondary="Attributes inspector" data-type="indexterm" id="idm46177214373752"/> Attributes inspector—as well as the subsequent Size and Connections inspectors—is where most of the configuration of views themselves is done within Xcode. Within the subsection called “Label” you can see a number of options that correspond to settings for the Label object we have added to the scene. There is a text field with the string “Label” set as its value. Changing that value will change the text the label is currently displaying. Let’s update it to something like “Welcome.” We can also change the appearance or font of the label within this inspector if we’d like.</p>&#13;
&#13;
<p>Once you’re happy with how your label looks, you could build and run the application like we did earlier in this chapter by clicking the “Build and Run” button near the top of the project window. However, it won’t get you very far. Nothing will have changed as far as the app is concerned, partially due to the giant arrow pointing to the left of the original view controller scene that was included in the project template. That arrow indicates that this is initial view controller to be shown from the <span class="keep-together">storyboard</span>.</p>&#13;
&#13;
<p>Changing this is as simple as ticking a checkbox.</p>&#13;
&#13;
<p>Select our new view controller scene, not the individual views inside it, by clicking directly on the scene in the Document Outline on the left side of the screen or by clicking the white rectangle above the simulated phone screen. If the Attributes inspector isn’t active, click it again once the view controller scene has been selected. Under the View Controller subsection, there is a checkbox labeled Is Initial View Controller that should be unchecked. Check this checkbox and the giant, magic arrow should move beside your new view controller.</p>&#13;
&#13;
<p>Let’s build and run the application and see what happens.</p>&#13;
&#13;
<p>You should see within the simulator that the app has started up and used our new scene as the default scene that’s displayed. Hooray!</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177214367816">&#13;
<h5>Main Storyboard Configuration</h5>&#13;
<p>You<a data-primary="storyboards" data-secondary="Main.storyboard configurations" data-type="indexterm" id="idm46177214366472"/> might be asking how did Xcode know to use <em>Main.storyboard</em>? If there is a <em>Main.storyboard</em> file within the project, it will be used as the default storyboard unless specified otherwise in the Project Settings under Main Interface. It’s possible, and recommended, to have multiple storyboards representing areas of your application once complexity starts increasing. At that point there might not be a “main” storyboard, or <em>Main.storyboard</em> might just contain the structural shell of your application. We’re getting ahead of ourselves here, though. Just know that this is a convention over configuration system, but it’s still highly configurable!</p>&#13;
</div></aside>&#13;
&#13;
<p>Don’t celebrate quite yet, though.</p>&#13;
&#13;
<p>Although we’ve added a new screen to our application, we probably want more functionality than just displaying a static screen. In fact, we might want to change and reference some of the views on the screen in code to make them a bit more dynamic. We’ve been using the storyboard editor to create our view. Let’s take a look at the other side of displaying views in iOS: the view controller.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding a view controller" data-type="sect3"><div class="sect3" id="idm46177214334904">&#13;
<h3>Adding a view controller</h3>&#13;
&#13;
<p>To<a data-primary="Xcode" data-secondary="creating new view controllers" data-type="indexterm" id="idm46177214333336"/> create a new view controller in Xcode, one that will control our Welcome scene, we need to add a new file. To do this, click the “+” button on the bottom left of the Xcode screen and New File… or go to File &gt; New &gt; File in the menu bar. Clicking either of these options will bring up the same modal window to select the type of file we’ll be adding to our project.</p>&#13;
&#13;
<p>We<a data-primary="Cocoa Touch" data-secondary="creating new view controllers" data-type="indexterm" id="idm46177214331592"/> could select Swift File as an empty Swift file for almost any code file, but for this particular type of object file we’re creating, let’s select Cocoa Touch Class because a view controller is part of Cocoa Touch—the framework that drives iOS—and click Next.</p>&#13;
&#13;
<p>Within this screen, set the subclass to be <code>UIViewController</code> and the name to be <span class="keep-together"><code>WelcomeViewController</code></span>. Make sure “Also create XIB file” is unchecked and the language is Swift before clicking Next and the Create button to use the default location. You should now see a new file added to the project navigator on the left side of the screen named <em>WelcomeViewController.swift.</em></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There is a convention of naming view controllers with a suffix of <code>ViewController</code>. This is standard practice and encouraged over naming your view controller something like <code>WelcomeController</code> or <code>WelcomeScene</code> to follow conventions.</p>&#13;
</div>&#13;
&#13;
<p>This file contains some boilerplate code that looks like this:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">import</code> <code class="nc">UIKit</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">WelcomeViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
&#13;
        <code class="c1">// Do any additional setup after loading the view.</code>&#13;
    <code class="p">}</code>&#13;
&#13;
&#13;
    <code class="cm">/*</code>&#13;
<code class="cm">    // </code><code class="cs">MARK:</code><code class="cm"> - Navigation</code>&#13;
&#13;
<code class="cm">    // In a storyboard-based application, you will often want to do a</code>&#13;
<code class="cm">    // little preparation before navigation</code>&#13;
<code class="cm">    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {</code>&#13;
<code class="cm">        // Get the new view controller using segue.destination</code>&#13;
<code class="cm">        // Pass the selected object to the new view controller</code>&#13;
<code class="cm">    }</code>&#13;
<code class="cm">    */</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is a fairly empty file at the moment and currently only declares an object named <code>WelcomeViewController</code> that inherits from <code>UIViewController</code>. If you’ll remember from earlier in the chapter, <code>UIViewController</code> is the base class from which view controllers inherit; it’s similar (but not exactly the same) to <code>Activity</code> in the preceding Android section.</p>&#13;
&#13;
<p>Now that we have our view controller created, let’s wire this up to our view controller scene from before.</p>&#13;
&#13;
<p>Head back over to our storyboard editor by clicking on <em>Main.storyboard</em> in the project navigator on the left side of Xcode. Once you’re inside the editor, click on our new view controller scene, the one we set earlier to be the initial view controller for the app, to select it in the editor. Show the Identity inspector by clicking the third button from the left on the right side of the screen. Under the Custom Class subsection there is a field called “Class” that currently has a grayed-out <code>UIViewController</code> displayed. This is the class, or type, of object that owns this view. Set this field to <code>WelcomeViewController</code>.</p>&#13;
&#13;
<p>The first thing you might notice is that the name of our scene has changed in the Document Outline on the left. Before it read “View Controller Scene,” and it now reads “Welcome View Controller Scene.” Let’s go ahead and delete the original view controller scene that came with the project template by clicking on the scene title in the Document Outline and hitting the Delete button.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Outlets for our views" data-type="sect3"><div class="sect3" id="idm46177214334312">&#13;
<h3>Outlets for our views</h3>&#13;
&#13;
<p>Remember how we mentioned before that we wanted to be able to control views from within the view controller? We’re going to do that now with an outlet.</p>&#13;
&#13;
<p>An outlet is a way to bind a particular view to a view controller. This view is then able to be configured and passed around as a reference via code. As such, it’s easiest if we start there. Head back over to our <em>WelcomeViewController.swift</em> file. Let’s first delete the commented-out boilerplate code to wind up with a class that looks like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">import</code> <code class="nc">UIKit</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">WelcomeViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
&#13;
        <code class="c1">// Do any additional setup after loading the view</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Right below the <code>class</code> declaration, add the following line:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kr">@IBOutlet</code> <code class="kr">weak</code> <code class="kd">var</code> <code class="nv">headerLabel</code><code class="p">:</code> <code class="bp">UILabel</code><code class="p">!</code></pre>&#13;
&#13;
<p>This creates a property in the class called <code>headerLabel</code> that is of a type <code>UILabel</code>, which happens to be the same type of object our label is in our view controller scene. Now, let’s have our welcome view controller change the color of the label whenever the scene loads by adding the following line at the end of our already existing <code>viewDidLoad()</code> method:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">headerLabel</code><code class="p">.</code><code class="n">textColor</code> <code class="p">=</code> <code class="p">.</code><code class="n">red</code></pre>&#13;
&#13;
<p>This sets the <code>textColor</code> property on the label after the view is loaded to red. The whole <em>WelcomeViewController.swift</em> file should now look like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">import</code> <code class="nc">UIKit</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">WelcomeViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
    <code class="kr">@IBOutlet</code> <code class="kr">weak</code> <code class="kd">var</code> <code class="nv">headerLabel</code><code class="p">:</code> <code class="bp">UILabel</code><code class="p">!</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
        <code class="n">headerLabel</code><code class="p">.</code><code class="n">textColor</code> <code class="p">=</code> <code class="p">.</code><code class="n">red</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ve added an outlet to our view controller class, but building and running the application now won’t change anything yet. We’re so close! We still need to wire up the welcome label in our storyboard.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wiring it all up" data-type="sect3"><div class="sect3" id="idm46177214275832">&#13;
<h3>Wiring it all up</h3>&#13;
&#13;
<p>Head back over to the storyboard editor. Hold the Control button down and hold the mouse button or trackpad button down over the yellow “Welcome View Controller” icon in the floating rectangle above the scene. Drag your mouse cursor over to the welcome label we created and a blue line connecting the two should appear. Release the mouse button and a floating window labeled Outlets will appear; the <code>headerLabel</code> property we created on <code>WelcomeViewController</code> should be listed. Click on <code>headerLabel</code> and the window should disappear.</p>&#13;
&#13;
<p>Within the Connections inspector on the right side of the screen, you can confirm that <code>headerLabel</code> is now connected to <code>Header Label</code> within our scene.</p>&#13;
&#13;
<p>Build and run the application by clicking on the “Build and Run” button in the top left of the project window and you should now see a label with red text displaying the word “Welcome” on your simulator screen.<a data-primary="" data-startref="ACbuildios16" data-type="indexterm" id="idm46177214113976"/><a data-primary="" data-startref="IOSappbuild16" data-type="indexterm" id="idm46177214113000"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177214393592">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>Let’s talk about what you’ve learned in this chapter.</p>&#13;
&#13;
<p>First, we learned how to create a new project in both Android Studio and Xcode. Next, we talked a little bit about the Model-View-Controller, or MVC, architectural pattern. We also discussed the app we’re building at a very high level. Finally, we walked through the process of adding a new screen—in our case a simple welcome screen—to the library app we’re building. We also learned how to create the visual components of a view and how to wire it all up and manipulate it inside of the code.</p>&#13;
&#13;
<p>Whew. This was a long chapter and we’ve just started building something useful. Let’s take a deeper dive into our application and learn how to display some lists of data in the next chapter, as well as adding a bit more style to our app!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>