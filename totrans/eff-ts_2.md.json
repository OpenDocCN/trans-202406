["```\nfunction getElement(elOrId: string|HTMLElement|null): HTMLElement {\n  if (typeof elOrId === 'object') {\n    return elOrId;\n // ~~~~~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'\n  } else if (elOrId === null) {\n    return document.body;\n  } else {\n    const el = document.getElementById(elOrId);\n    return el;\n // ~~~~~~~~~~ 'HTMLElement | null' is not assignable to 'HTMLElement'\n  }\n}\n```", "```\ndeclare function fetch(\n  input: RequestInfo, init?: RequestInit\n): Promise<Response>;\n```", "```\ntype RequestInfo = Request | string;\n```", "```\ndeclare var Request: {\n    prototype: Request;\n    new(input: RequestInfo, init?: RequestInit): Request;\n};\n```", "```\ninterface RequestInit {\n    body?: BodyInit | null;\n    cache?: RequestCache;\n    credentials?: RequestCredentials;\n    headers?: HeadersInit;\n    // ...\n}\n```", "```\nconst x: never = 12;\n   // ~ Type '12' is not assignable to type 'never'\n```", "```\ntype A = 'A';\ntype B = 'B';\ntype Twelve = 12;\n```", "```\ntype AB = 'A' | 'B';\ntype AB12 = 'A' | 'B' | 12;\n```", "```\nconst a: AB = 'A';  // OK, value 'A' is a member of the set {'A', 'B'}\nconst c: AB = 'C';\n   // ~ Type '\"C\"' is not assignable to type 'AB'\n```", "```\n// OK, {\"A\", \"B\"} is a subset of {\"A\", \"B\"}:\nconst ab: AB = Math.random() < 0.5 ? 'A' : 'B';\nconst ab12: AB12 = ab;  // OK, {\"A\", \"B\"} is a subset of {\"A\", \"B\", 12}\n\ndeclare let twelve: AB12;\nconst back: AB = twelve;\n   // ~~~~ Type 'AB12' is not assignable to type 'AB'\n   //        Type '12' is not assignable to type 'AB'\n```", "```\ntype Int = 1 | 2 | 3 | 4 | 5 // | ...\n```", "```\ninterface Identified {\n  id: string;\n}\n```", "```\ninterface Person {\n  name: string;\n}\ninterface Lifespan {\n  birth: Date;\n  death?: Date;\n}\ntype PersonSpan = Person & Lifespan;\n```", "```\nconst ps: PersonSpan = {\n  name: 'Alan Turing',\n  birth: new Date('1912/06/23'),\n  death: new Date('1954/06/07'),\n};  // OK\n```", "```\ntype K = keyof (Person | Lifespan);  // Type is never\n```", "```\nkeyof (A&B) = (keyof A) | (keyof B)\nkeyof (A|B) = (keyof A) & (keyof B)\n```", "```\ninterface Person {\n  name: string;\n}\ninterface PersonSpan extends Person {\n  birth: Date;\n  death?: Date;\n}\n```", "```\ninterface Vector1D { x: number; }\ninterface Vector2D extends Vector1D { y: number; }\ninterface Vector3D extends Vector2D { z: number; }\n```", "```\ninterface Vector1D { x: number; }\ninterface Vector2D { x: number; y: number; }\ninterface Vector3D { x: number; y: number; z: number; }\n```", "```\nfunction getKey<K extends string>(val: any, key: K) {\n  // ...\n}\n```", "```\ngetKey({}, 'x');  // OK, 'x' extends string\ngetKey({}, Math.random() < 0.5 ? 'a' : 'b');  // OK, 'a'|'b' extends string\ngetKey({}, document.title);  // OK, string extends string\ngetKey({}, 12);\n        // ~~ Type '12' is not assignable to parameter of type 'string'\n```", "```\ninterface Point {\n  x: number;\n  y: number;\n}\ntype PointKeys = keyof Point;  // Type is \"x\" | \"y\"\n\nfunction sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {\n  // ...\n}\nconst pts: Point[] = [{x: 1, y: 1}, {x: 2, y: 0}];\nsortBy(pts, 'x');  // OK, 'x' extends 'x'|'y' (aka keyof T)\nsortBy(pts, 'y');  // OK, 'y' extends 'x'|'y'\nsortBy(pts, Math.random() < 0.5 ? 'x' : 'y');  // OK, 'x'|'y' extends 'x'|'y'\nsortBy(pts, 'z');\n         // ~~~ Type '\"z\"' is not assignable to parameter of type '\"x\" | \"y\"\n```", "```\nconst list = [1, 2];  // Type is number[]\nconst tuple: [number, number] = list;\n   // ~~~~~ Type 'number[]' is missing the following\n   //       properties from type '[number, number]': 0, 1\n```", "```\nconst triple: [number, number, number] = [1, 2, 3];\nconst double: [number, number] = triple;\n   // ~~~~~~ '[number, number, number]' is not assignable to '[number, number]'\n   //          Types of property 'length' are incompatible\n   //          Type '3' is not assignable to type '2'\n```", "```\ntype T = Exclude<string|Date, string|number>;  // Type is Date\ntype NonZeroNums = Exclude<number, 0>;  // Type is still just number\n```", "```\ninterface Cylinder {\n  radius: number;\n  height: number;\n}\n\nconst Cylinder = (radius: number, height: number) => ({radius, height});\n```", "```\nfunction calculateVolume(shape: unknown) {\n  if (shape instanceof Cylinder) {\n    shape.radius\n       // ~~~~~~ Property 'radius' does not exist on type '{}'\n  }\n}\n```", "```\ntype T1 = 'string literal';\ntype T2 = 123;\nconst v1 = 'string literal';\nconst v2 = 123;\n```", "```\ninterface Person {\n  first: string;\n  last: string;\n}\nconst p: Person = { first: 'Jane', last: 'Jacobs' };\n//    -           --------------------------------- Values\n//       ------ Type\n```", "```\nfunction email(p: Person, subject: string, body: string): Response {\n  //     ----- -          -------          ----  Values\n  //              ------           ------        ------   -------- Types\n  // ...\n}\n```", "```\nclass Cylinder {\n  radius=1;\n  height=1;\n}\n\nfunction calculateVolume(shape: unknown) {\n  if (shape instanceof Cylinder) {\n    shape  // OK, type is Cylinder\n    shape.radius  // OK, type is number\n  }\n}\n```", "```\ntype T1 = typeof p;  // Type is Person\ntype T2 = typeof email;\n    // Type is (p: Person, subject: string, body: string) => Response\n\nconst v1 = typeof p;  // Value is \"object\"\nconst v2 = typeof email;  // Value is \"function\"\n```", "```\nconst v = typeof Cylinder;  // Value is \"function\"\ntype T = typeof Cylinder;  // Type is typeof Cylinder\n```", "```\ndeclare let fn: T;\nconst c = new fn();  // Type is Cylinder\n```", "```\ntype C = InstanceType<typeof Cylinder>;  // Type is Cylinder\n```", "```\nconst first: Person['first'] = p['first'];  // Or p.first\n   // -----                    ---------- Values\n   //        ------ ------- Types\n```", "```\ntype PersonEl = Person['first' | 'last'];  // Type is string\ntype Tuple = [string, number, Date];\ntype TupleEl = Tuple[number];  // Type is string | number | Date\n```", "```\nfunction email(options: {person: Person, subject: string, body: string}) {\n  // ...\n}\n```", "```\nfunction email({person, subject, body}) {\n  // ...\n}\n```", "```\nfunction email({\n  person: Person,\n       // ~~~~~~ Binding element 'Person' implicitly has an 'any' type\n  subject: string,\n        // ~~~~~~ Duplicate identifier 'string'\n        //        Binding element 'string' implicitly has an 'any' type\n  body: string}\n     // ~~~~~~ Duplicate identifier 'string'\n     //        Binding element 'string' implicitly has an 'any' type\n) { /* ... */ }\n```", "```\nfunction email(\n  {person, subject, body}: {person: Person, subject: string, body: string}\n) {\n  // ...\n}\n```", "```\ninterface Person { name: string };\n\nconst alice: Person = { name: 'Alice' };  // Type is Person\nconst bob = { name: 'Bob' } as Person;  // Type is Person\n```", "```\nconst alice: Person = {};\n   // ~~~~~ Property 'name' is missing in type '{}'\n   //       but required in type 'Person'\nconst bob = {} as Person;  // No error\n```", "```\nconst alice: Person = {\n  name: 'Alice',\n  occupation: 'TypeScript developer'\n// ~~~~~~~~~ Object literal may only specify known properties\n//           and 'occupation' does not exist in type 'Person'\n};\nconst bob = {\n  name: 'Bob',\n  occupation: 'JavaScript developer'\n} as Person;  // No error\n```", "```\nconst people = ['alice', 'bob', 'jan'].map(name => ({name}));\n// { name: string; }[]... but we want Person[]\n```", "```\nconst people = ['alice', 'bob', 'jan'].map(\n  name => ({name} as Person)\n); // Type is Person[]\n```", "```\nconst people = ['alice', 'bob', 'jan'].map(name => ({} as Person));\n// No error\n```", "```\nconst people = ['alice', 'bob', 'jan'].map(name => {\n  const person: Person = {name};\n  return person\n}); // Type is Person[]\n```", "```\nconst people = ['alice', 'bob', 'jan'].map(\n  (name): Person => ({name})\n); // Type is Person[]\n```", "```\nconst people: Person[] = ['alice', 'bob', 'jan'].map(\n  (name): Person => ({name})\n);\n```", "```\ndocument.querySelector('#myButton').addEventListener('click', e => {\n  e.currentTarget // Type is EventTarget\n  const button = e.currentTarget as HTMLButtonElement;\n  button // Type is HTMLButtonElement\n});\n```", "```\nconst elNull = document.getElementById('foo');  // Type is HTMLElement | null\nconst el = document.getElementById('foo')!; // Type is HTMLElement\n```", "```\ninterface Person { name: string; }\nconst body = document.body;\nconst el = body as Person;\n        // ~~~~~~~~~~~~~~ Conversion of type 'HTMLElement' to type 'Person'\n        //                may be a mistake because neither type sufficiently\n        //                overlaps with the other. If this was intentional,\n        //                convert the expression to 'unknown' first\n```", "```\nconst el = document.body as unknown as Person;  // OK\n```", "```\n> 'primitive'.charAt(3)\n\"m\"\n```", "```\n// Don't do this!\nconst originalCharAt = String.prototype.charAt;\nString.prototype.charAt = function(pos) {\n  console.log(this, typeof this, pos);\n  return originalCharAt.call(this, pos);\n};\nconsole.log('primitive'.charAt(3));\n```", "```\n[String: 'primitive'] 'object' 3\nm\n```", "```\n> \"hello\" === new String(\"hello\")\nfalse\n> new String(\"hello\") === new String(\"hello\")\nfalse\n```", "```\n> x = \"hello\"\n> x.language = 'English'\n'English'\n> x.language\nundefined\n```", "```\nfunction getStringLen(foo: String) {\n  return foo.length;\n}\n\ngetStringLen(\"hello\");  // OK\ngetStringLen(new String(\"hello\"));  // OK\n```", "```\nfunction isGreeting(phrase: String) {\n  return [\n    'hello',\n    'good day'\n  ].includes(phrase);\n          // ~~~~~~\n          // Argument of type 'String' is not assignable to parameter\n          // of type 'string'.\n          // 'string' is a primitive, but 'String' is a wrapper object;\n          // prefer using 'string' when possible\n}\n```", "```\nconst s: String = \"primitive\";\nconst n: Number = 12;\nconst b: Boolean = true;\n```", "```\n> typeof BigInt(1234)\n\"bigint\"\n> typeof Symbol('sym')\n\"symbol\"\n```", "```\ninterface Room {\n  numDoors: number;\n  ceilingHeightFt: number;\n}\nconst r: Room = {\n  numDoors: 1,\n  ceilingHeightFt: 10,\n  elephant: 'present',\n// ~~~~~~~~~~~~~~~~~~ Object literal may only specify known properties,\n//                    and 'elephant' does not exist in type 'Room'\n};\n```", "```\nconst obj = {\n  numDoors: 1,\n  ceilingHeightFt: 10,\n  elephant: 'present',\n};\nconst r: Room = obj;  // OK\n```", "```\ninterface Options {\n  title: string;\n  darkMode?: boolean;\n}\nfunction createWindow(options: Options) {\n  if (options.darkMode) {\n    setDarkMode();\n  }\n  // ...\n}\ncreateWindow({\n  title: 'Spider Solitaire',\n  darkmode: true\n// ~~~~~~~~~~~~~ Object literal may only specify known properties, but\n//               'darkmode' does not exist in type 'Options'.\n//               Did you mean to write 'darkMode'?\n});\n```", "```\nconst o1: Options = document;  // OK\nconst o2: Options = new HTMLAnchorElement;  // OK\n```", "```\nconst o: Options = { darkmode: true, title: 'Ski Free' };\n                  // ~~~~~~~~ 'darkmode' does not exist in type 'Options'...\n```", "```\nconst intermediate = { darkmode: true, title: 'Ski Free' };\nconst o: Options = intermediate;  // OK\n```", "```\nconst o = { darkmode: true, title: 'Ski Free' } as Options;  // OK\n```", "```\ninterface Options {\n  darkMode?: boolean;\n  [otherOptions: string]: unknown;\n}\nconst o: Options = { darkmode: true };  // OK\n```", "```\ninterface LineChartOptions {\n  logscale?: boolean;\n  invertedYAxis?: boolean;\n  areaChart?: boolean;\n}\nconst opts = { logScale: true };\nconst o: LineChartOptions = opts;\n   // ~ Type '{ logScale: boolean; }' has no properties in common\n   //   with type 'LineChartOptions'\n```", "```\nfunction rollDice1(sides: number): number { /* ... */ }  // Statement\nconst rollDice2 = function(sides: number): number { /* ... */ };  // Expression\nconst rollDice3 = (sides: number): number => { /* ... */ };  // Also expression\n```", "```\ntype DiceRollFn = (sides: number) => number;\nconst rollDice: DiceRollFn = sides => { /* ... */ };\n```", "```\nfunction add(a: number, b: number) { return a + b; }\nfunction sub(a: number, b: number) { return a - b; }\nfunction mul(a: number, b: number) { return a * b; }\nfunction div(a: number, b: number) { return a / b; }\n```", "```\ntype BinaryFn = (a: number, b: number) => number;\nconst add: BinaryFn = (a, b) => a + b;\nconst sub: BinaryFn = (a, b) => a - b;\nconst mul: BinaryFn = (a, b) => a * b;\nconst div: BinaryFn = (a, b) => a / b;\n```", "```\nconst responseP = fetch('/quote?by=Mark+Twain');  // Type is Promise<Response>\n```", "```\nasync function getQuote() {\n  const response = await fetch('/quote?by=Mark+Twain');\n  const quote = await response.json();\n  return quote;\n}\n// {\n//   \"quote\": \"If you tell the truth, you don't have to remember anything.\",\n//   \"source\": \"notebook\",\n//   \"date\": \"1894\"\n// }\n```", "```\ndeclare function fetch(\n  input: RequestInfo, init?: RequestInit\n): Promise<Response>;\n```", "```\nasync function checkedFetch(input: RequestInfo, init?: RequestInit) {\n  const response = await fetch(input, init);\n  if (!response.ok) {\n    // Converted to a rejected Promise in an async function\n    throw new Error('Request failed: ' + response.status);\n  }\n  return response;\n}\n```", "```\nconst checkedFetch: typeof fetch = async (input, init) => {\n  const response = await fetch(input, init);\n  if (!response.ok) {\n    throw new Error('Request failed: ' + response.status);\n  }\n  return response;\n}\n```", "```\nconst checkedFetch: typeof fetch = async (input, init) => {\n  //  ~~~~~~~~~~~~   Type 'Promise<Response | HTTPError>'\n  //                     is not assignable to type 'Promise<Response>'\n  //                   Type 'Response | HTTPError' is not assignable\n  //                       to type 'Response'\n  const response = await fetch(input, init);\n  if (!response.ok) {\n    return new Error('Request failed: ' + response.status);\n  }\n  return response;\n}\n```", "```\ntype TState = {\n  name: string;\n  capital: string;\n}\n```", "```\ninterface IState {\n  name: string;\n  capital: string;\n}\n```", "```\nconst wyoming: TState = {\n  name: 'Wyoming',\n  capital: 'Cheyenne',\n  population: 500_000\n// ~~~~~~~~~~~~~~~~~~ Type ... is not assignable to type 'TState'\n//                    Object literal may only specify known properties, and\n//                    'population' does not exist in type 'TState'\n};\n```", "```\ntype TDict = { [key: string]: string };\ninterface IDict {\n  [key: string]: string;\n}\n```", "```\ntype TFn = (x: number) => string;\ninterface IFn {\n  (x: number): string;\n}\n\nconst toStrT: TFn = x => '' + x;  // OK\nconst toStrI: IFn = x => '' + x;  // OK\n```", "```\ntype TFnWithProperties = {\n  (x: number): number;\n  prop: string;\n}\ninterface IFnWithProperties {\n  (x: number): number;\n  prop: string;\n}\n```", "```\ntype TPair<T> = {\n  first: T;\n  second: T;\n}\ninterface IPair<T> {\n  first: T;\n  second: T;\n}\n```", "```\ninterface IStateWithPop extends TState {\n  population: number;\n}\ntype TStateWithPop = IState & { population: number; };\n```", "```\nclass StateT implements TState {\n  name: string = '';\n  capital: string = '';\n}\nclass StateI implements IState {\n  name: string = '';\n  capital: string = '';\n}\n```", "```\ntype AorB = 'a' | 'b';\n```", "```\ntype Input = { /* ... */ };\ntype Output = { /* ... */ };\ninterface VariableMap {\n  [name: string]: Input | Output;\n}\n```", "```\ntype NamedVariable = (Input | Output) & { name: string };\n```", "```\ntype Pair = [number, number];\ntype StringList = string[];\ntype NamedNums = [string, ...number[]];\n```", "```\ninterface Tuple {\n  0: number;\n  1: number;\n  length: 2;\n}\nconst t: Tuple = [10, 20];  // OK\n```", "```\ninterface IState {\n  name: string;\n  capital: string;\n}\ninterface IState {\n  population: number;\n}\nconst wyoming: IState = {\n  name: 'Wyoming',\n  capital: 'Cheyenne',\n  population: 500_000\n};  // OK\n```", "```\nconsole.log('Cylinder 1 x 1 ',\n  'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 1 * 1,\n  'Volume:', 3.14159 * 1 * 1 * 1);\nconsole.log('Cylinder 1 x 2 ',\n  'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 2 * 1,\n  'Volume:', 3.14159 * 1 * 2 * 1);\nconsole.log('Cylinder 2 x 1 ',\n  'Surface area:', 6.283185 * 2 * 1 + 6.283185 * 2 * 1,\n  'Volume:', 3.14159 * 2 * 2 * 1);\n```", "```\nconst surfaceArea = (r, h) => 2 * Math.PI * r * (r + h);\nconst volume = (r, h) => Math.PI * r * r * h;\nfor (const [r, h] of [[1, 1], [1, 2], [2, 1]]) {\n  console.log(\n    `Cylinder ${r} x ${h}`,\n    `Surface area: ${surfaceArea(r, h)}`,\n    `Volume: ${volume(r, h)}`);\n}\n```", "```\ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n\ninterface PersonWithBirthDate {\n  firstName: string;\n  lastName: string;\n  birth: Date;\n}\n```", "```\nfunction distance(a: {x: number, y: number}, b: {x: number, y: number}) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n```", "```\ninterface Point2D {\n  x: number;\n  y: number;\n}\nfunction distance(a: Point2D, b: Point2D) { /* ... */ }\n```", "```\nfunction get(url: string, opts: Options): Promise<Response> { /* ... */ }\nfunction post(url: string, opts: Options): Promise<Response> { /* ... */ }\n```", "```\ntype HTTPFunction = (url: string, opts: Options) => Promise<Response>;\nconst get: HTTPFunction = (url, opts) => { /* ... */ };\nconst post: HTTPFunction = (url, opts) => { /* ... */ };\n```", "```\ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n\ninterface PersonWithBirthDate extends Person {\n  birth: Date;\n}\n```", "```\ntype PersonWithBirthDate = Person & { birth: Date };\n```", "```\ninterface State {\n  userId: string;\n  pageTitle: string;\n  recentFiles: string[];\n  pageContents: string;\n}\ninterface TopNavState {\n  userId: string;\n  pageTitle: string;\n  recentFiles: string[];\n}\n```", "```\ntype TopNavState = {\n  userId: State['userId'];\n  pageTitle: State['pageTitle'];\n  recentFiles: State['recentFiles'];\n};\n```", "```\ntype TopNavState = {\n  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]\n};\n```", "```\ntype Pick<T, K> = { [k in K]: T[k] };\n```", "```\ntype TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>;\n```", "```\ninterface SaveAction {\n  type: 'save';\n  // ...\n}\ninterface LoadAction {\n  type: 'load';\n  // ...\n}\ntype Action = SaveAction | LoadAction;\ntype ActionType = 'save' | 'load';  // Repeated types!\n```", "```\ntype ActionType = Action['type'];  // Type is \"save\" | \"load\"\n```", "```\ntype ActionRec = Pick<Action, 'type'>;  // {type: \"save\" | \"load\"}\n```", "```\ninterface Options {\n  width: number;\n  height: number;\n  color: string;\n  label: string;\n}\ninterface OptionsUpdate {\n  width?: number;\n  height?: number;\n  color?: string;\n  label?: string;\n}\nclass UIWidget {\n  constructor(init: Options) { /* ... */ }\n  update(options: OptionsUpdate) { /* ... */ }\n}\n```", "```\ntype OptionsUpdate = {[k in keyof Options]?: Options[k]};\n```", "```\ntype OptionsKeys = keyof Options;\n// Type is \"width\" | \"height\" | \"color\" | \"label\"\n```", "```\nclass UIWidget {\n  constructor(init: Options) { /* ... */ }\n  update(options: Partial<Options>) { /* ... */ }\n}\n```", "```\nconst INIT_OPTIONS = {\n  width: 640,\n  height: 480,\n  color: '#00FF00',\n  label: 'VGA',\n};\ninterface Options {\n  width: number;\n  height: number;\n  color: string;\n  label: string;\n}\n```", "```\ntype Options = typeof INIT_OPTIONS;\n```", "```\nfunction getUserInfo(userId: string) {\n  // ...\n  return {\n    userId,\n    name,\n    age,\n    height,\n    weight,\n    favoriteColor,\n  };\n}\n// Return type inferred as { userId: string; name: string; age: number, ... }\n```", "```\ntype UserInfo = ReturnType<typeof getUserInfo>;\n```", "```\ninterface Name {\n  first: string;\n  last: string;\n}\ntype DancingDuo<T extends Name> = [T, T];\n\nconst couple1: DancingDuo<Name> = [\n  {first: 'Fred', last: 'Astaire'},\n  {first: 'Ginger', last: 'Rogers'}\n];  // OK\nconst couple2: DancingDuo<{first: string}> = [\n                       // ~~~~~~~~~~~~~~~\n                       // Property 'last' is missing in type\n                       // '{ first: string; }' but required in type 'Name'\n  {first: 'Sonny'},\n  {first: 'Cher'}\n];\n```", "```\nconst dancingDuo = <T extends Name>(x: DancingDuo<T>) => x;\nconst couple1 = dancingDuo([\n  {first: 'Fred', last: 'Astaire'},\n  {first: 'Ginger', last: 'Rogers'}\n]);\nconst couple2 = dancingDuo([\n  {first: 'Bono'},\n// ~~~~~~~~~~~~~~\n  {first: 'Prince'}\n// ~~~~~~~~~~~~~~~~\n//     Property 'last' is missing in type\n//     '{ first: string; }' but required in type 'Name'\n]);\n```", "```\ntype Pick<T, K> = {\n  [k in K]: T[k]\n     // ~ Type 'K' is not assignable to type 'string | number | symbol'\n};\n```", "```\ntype Pick<T, K extends keyof T> = {\n  [k in K]: T[k]\n};  // OK\n```", "```\ntype FirstLast = Pick<Name, 'first' | 'last'>;  // OK\ntype FirstMiddle = Pick<Name, 'first' | 'middle'>;\n                           // ~~~~~~~~~~~~~~~~~~\n                           // Type '\"middle\"' is not assignable\n                           // to type '\"first\" | \"last\"'\n```", "```\nconst rocket = {\n  name: 'Falcon 9',\n  variant: 'Block 5',\n  thrust: '7,607 kN',\n};\n```", "```\ntype Rocket = {[property: string]: string};\nconst rocket: Rocket = {\n  name: 'Falcon 9',\n  variant: 'v1.0',\n  thrust: '4,940 kN',\n};  // OK\n```", "```\ninterface Rocket {\n  name: string;\n  variant: string;\n  thrust_kN: number;\n}\nconst falconHeavy: Rocket = {\n  name: 'Falcon Heavy',\n  variant: 'v1',\n  thrust_kN: 15_200\n};\n```", "```\nfunction parseCSV(input: string): {[columnName: string]: string}[] {\n  const lines = input.split('\\n');\n  const [header, ...rows] = lines;\n  return rows.map(rowStr => {\n    const row: {[columnName: string]: string} = {};\n    rowStr.split(',').forEach((cell, i) => {\n      row[header[i]] = cell;\n    });\n    return row;\n  });\n}\n```", "```\ninterface ProductRow {\n  productId: string;\n  name: string;\n  price: string;\n}\n\ndeclare let csvData: string;\nconst products = parseCSV(csvData) as unknown as ProductRow[];\n```", "```\nfunction safeParseCSV(\n  input: string\n): {[columnName: string]: string | undefined}[] {\n  return parseCSV(input);\n}\n```", "```\nconst rows = parseCSV(csvData);\nconst prices: {[produt: string]: number} = {};\nfor (const row of rows) {\n  prices[row.productId] = Number(row.price);\n}\n\nconst safeRows = safeParseCSV(csvData);\nfor (const row of safeRows) {\n  prices[row.productId] = Number(row.price);\n      // ~~~~~~~~~~~~~ Type 'undefined' cannot be used as an index type\n}\n```", "```\ninterface Row1 { [column: string]: number }  // Too broad\ninterface Row2 { a: number; b?: number; c?: number; d?: number }  // Better\ntype Row3 =\n    | { a: number; }\n    | { a: number; b: number; }\n    | { a: number; b: number; c: number;  }\n    | { a: number; b: number; c: number; d: number };\n```", "```\ntype Vec3D = Record<'x' | 'y' | 'z', number>;\n// Type Vec3D = {\n//   x: number;\n//   y: number;\n//   z: number;\n// }\n```", "```\ntype Vec3D = {[k in 'x' | 'y' | 'z']: number};\n// Same as above\ntype ABC = {[k in 'a' | 'b' | 'c']: k extends 'b' ? string : number};\n// Type ABC = {\n//   a: number;\n//   b: string;\n//   c: number;\n// }\n```", "```\n> \"0\" == 0\ntrue\n```", "```\n> x = {}\n{}\n> x[[1, 2, 3]] = 2\n2\n> x\n{ '1,2,3': 1 }\n\n```", "```\n> { 1: 2, 3: 4}\n{ '1': 2, '3': 4 }\n```", "```\n> typeof []\n'object'\n```", "```\n> x = [1, 2, 3]\n[ 1, 2, 3 ]\n> x[0]\n1\n```", "```\n> x['1']\n2\n```", "```\n> Object.keys(x)\n[ '0', '1', '2' ]\n```", "```\ninterface Array<T> {\n  // ...\n  [n: number]: T;\n}\n```", "```\nconst xs = [1, 2, 3];\nconst x0 = xs[0];  // OK\nconst x1 = xs['1'];\n           // ~~~ Element implicitly has an 'any' type\n           //      because index expression is not of type 'number'\n\nfunction get<T>(array: T[], k: string): T {\n  return array[k];\n            // ~ Element implicitly has an 'any' type\n            //   because index expression is not of type 'number'\n}\n```", "```\nconst keys = Object.keys(xs);  // Type is string[]\nfor (const key in xs) {\n  key;  // Type is string\n  const x = xs[key];  // Type is number\n}\n```", "```\nfor (const x of xs) {\n  x;  // Type is number\n}\n```", "```\nxs.forEach((x, i) => {\n  i;  // Type is number\n  x;  // Type is number\n});\n```", "```\nfor (let i = 0; i < xs.length; i++) {\n  const x = xs[i];\n  if (x < 0) break;\n}\n```", "```\nfunction checkedAccess<T>(xs: ArrayLike<T>, i: number): T {\n  if (i < xs.length) {\n    return xs[i];\n  }\n  throw new Error(`Attempt to access ${i} which is past end of array.`)\n}\n```", "```\nconst tupleLike: ArrayLike<string> = {\n  '0': 'A',\n  '1': 'B',\n  length: 2,\n};  // OK\n```", "```\nfunction printTriangles(n: number) {\n  const nums = [];\n  for (let i = 0; i < n; i++) {\n    nums.push(i);\n    console.log(arraySum(nums));\n  }\n}\n```", "```\n> printTriangles(5)\n0\n1\n2\n3\n4\n```", "```\nfunction arraySum(arr: number[]) {\n  let sum = 0, num;\n  while ((num = arr.pop()) !== undefined) {\n    sum += num;\n  }\n  return sum;\n}\n```", "```\nfunction arraySum(arr: readonly number[]) {\n  let sum = 0, num;\n  while ((num = arr.pop()) !== undefined) {\n                 // ~~~ 'pop' does not exist on type 'readonly number[]'\n    sum += num;\n  }\n  return sum;\n}\n```", "```\nconst a: number[] = [1, 2, 3];\nconst b: readonly number[] = a;\nconst c: number[] = b;\n   // ~ Type 'readonly number[]' is 'readonly' and cannot be\n   //   assigned to the mutable type 'number[]'\n```", "```\nfunction arraySum(arr: readonly number[]) {\n  let sum = 0;\n  for (const num of arr) {\n    sum += num;\n  }\n  return sum;\n}\n```", "```\n> printTriangles(5)\n0\n1\n3\n6\n10\n```", "```\nFrankenstein; or, The Modern Prometheus\nby Mary Shelley\n\nYou will rejoice to hear that no disaster has accompanied the commencement\nof an enterprise which you have regarded with such evil forebodings. I arrived\nhere yesterday, and my first task is to assure my dear sister of my welfare and\nincreasing confidence in the success of my undertaking.\n\nI am already far north of London, and as I walk in the streets of Petersburgh,\nI feel a cold northern breeze play upon my cheeks, which braces my nerves and\nfills me with delight.\n```", "```\nfunction parseTaggedText(lines: string[]): string[][] {\n  const paragraphs: string[][] = [];\n  const currPara: string[] = [];\n\n  const addParagraph = () => {\n    if (currPara.length) {\n      paragraphs.push(currPara);\n      currPara.length = 0;  // Clear the lines\n    }\n  };\n\n  for (const line of lines) {\n    if (!line) {\n      addParagraph();\n    } else {\n      currPara.push(line);\n    }\n  }\n  addParagraph();\n  return paragraphs;\n}\n```", "```\n[ [], [], [] ]\n```", "```\nparagraphs.push(currPara);\n```", "```\nparagraphs.push(currPara);\ncurrPara.length = 0;  // Clear lines\n```", "```\nfunction parseTaggedText(lines: string[]): string[][] {\n  const currPara: readonly string[] = [];\n  const paragraphs: string[][] = [];\n\n  const addParagraph = () => {\n    if (currPara.length) {\n      paragraphs.push(\n        currPara\n     // ~~~~~~~~ Type 'readonly string[]' is 'readonly' and\n     //          cannot be assigned to the mutable type 'string[]'\n      );\n      currPara.length = 0;  // Clear lines\n            // ~~~~~~ Cannot assign to 'length' because it is a read-only\n            // property\n    }\n  };\n\n  for (const line of lines) {\n    if (!line) {\n      addParagraph();\n    } else {\n      currPara.push(line);\n            // ~~~~ Property 'push' does not exist on type 'readonly string[]'\n    }\n  }\n  addParagraph();\n  return paragraphs;\n}\n```", "```\nlet currPara: readonly string[] = [];\n// ...\ncurrPara = [];  // Clear lines\n// ...\ncurrPara = currPara.concat([line]);\n```", "```\nparagraphs.push([...currPara]);\n```", "```\nconst paragraphs: (readonly string[])[] = [];\n```", "```\nparagraphs.push(currPara as string[]);\n```", "```\nconst dates: readonly Date[] = [new Date()];\ndates.push(new Date());\n   // ~~~~ Property 'push' does not exist on type 'readonly Date[]'\ndates[0].setFullYear(2037);  // OK\n```", "```\ninterface Outer {\n  inner: {\n    x: number;\n  }\n}\nconst o: Readonly<Outer> = { inner: { x: 0 }};\no.inner = { x: 1 };\n// ~~~~ Cannot assign to 'inner' because it is a read-only property\no.inner.x = 1;  // OK\n```", "```\ntype T = Readonly<Outer>;\n// Type T = {\n//   readonly inner: {\n//     x: number;\n//   };\n// }\n```", "```\nlet obj: {readonly [k: string]: number} = {};\n// Or Readonly<{[k: string]: number}\nobj.hi = 45;\n//  ~~ Index signature in type ... only permits reading\nobj = {...obj, hi: 12};  // OK\nobj = {...obj, bye: 34};  // OK\n```", "```\ninterface ScatterProps {\n  // The data\n  xs: number[];\n  ys: number[];\n\n  // Display\n  xRange: [number, number];\n  yRange: [number, number];\n  color: string;\n\n  // Events\n  onClick: (x: number, y: number, index: number) => void;\n}\n```", "```\nfunction shouldUpdate(\n  oldProps: ScatterProps,\n  newProps: ScatterProps\n) {\n  let k: keyof ScatterProps;\n  for (k in oldProps) {\n    if (oldProps[k] !== newProps[k]) {\n      if (k !== 'onClick') return true;\n    }\n  }\n  return false;\n}\n```", "```\nfunction shouldUpdate(\n  oldProps: ScatterProps,\n  newProps: ScatterProps\n) {\n  return (\n    oldProps.xs !== newProps.xs ||\n    oldProps.ys !== newProps.ys ||\n    oldProps.xRange !== newProps.xRange ||\n    oldProps.yRange !== newProps.yRange ||\n    oldProps.color !== newProps.color\n    // (no check for onClick)\n  );\n}\n```", "```\ninterface ScatterProps {\n  xs: number[];\n  ys: number[];\n  // ...\n  onClick: (x: number, y: number, index: number) => void;\n\n  // Note: if you add a property here, update shouldUpdate!\n}\n```", "```\nconst REQUIRES_UPDATE: {[k in keyof ScatterProps]: boolean} = {\n  xs: true,\n  ys: true,\n  xRange: true,\n  yRange: true,\n  color: true,\n  onClick: false,\n};\n\nfunction shouldUpdate(\n  oldProps: ScatterProps,\n  newProps: ScatterProps\n) {\n  let k: keyof ScatterProps;\n  for (k in oldProps) {\n    if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) {\n      return true;\n    }\n  }\n  return false;\n}\n```", "```\ninterface ScatterProps {\n  // ...\n  onDoubleClick: () => void;\n}\n```", "```\nconst REQUIRES_UPDATE: {[k in keyof ScatterProps]: boolean} = {\n  //  ~~~~~~~~~~~~~~~ Property 'onDoubleClick' is missing in type\n  // ...\n};\n```", "```\nconst PROPS_REQUIRING_UPDATE: (keyof ScatterProps)[] = [\n  'xs',\n  'ys',\n  // ...\n];\n```"]