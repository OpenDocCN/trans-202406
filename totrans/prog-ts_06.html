<html><head></head><body><section data-pdf-bookmark="Chapter 6. Advanced Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="advanced-types">&#13;
<h1><span class="label">Chapter 6. </span>Advanced Types</h1>&#13;
&#13;
&#13;
<p>TypeScript has a world-class type system that supports powerful type-level programming features that might make even the crotchetiest Haskell programmer jealous. As you by now know, that type system isn’t just incredibly expressive, but also easy to use, and makes declaring type constraints and relationships simple, terse, and most of the time, inferred.</p>&#13;
&#13;
<p>We need such an expressive and unusual type system because JavaScript is so dynamic. Modeling things like prototypes, dynamically bound <code>this</code>, function overloads, and always-changing objects requires a rich type system and a utility belt of type operators that would make Batman do a double-take.</p>&#13;
&#13;
<p>I’ll start this chapter with a deep dive into subtyping, assignability, variance, and widening in TypeScript, giving more definition to the intuitions you’ve been developing over the last several chapters. I’ll then cover TypeScript’s control-flow-based typechecking features in more detail, including refinement and totality, and continue with some advanced type-level programming features: keying into and mapping over object types, using conditional types, defining your own type guards, and escape hatches like type assertions and definite assignment assertions. Finally, I’ll cover advanced patterns for squeezing more safety out of your types: the companion object pattern, improving inference for tuple types, simulating nominal types, and safely extending the prototype.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Relationships Between Types" data-type="sect1"><div class="sect1" id="idm46304969147496">&#13;
<h1>Relationships Between Types</h1>&#13;
&#13;
<p>Let’s begin by taking a closer look at type relations in TypeScript.<a data-primary="types" data-secondary="relationships between" data-type="indexterm" id="ix_typerel"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subtypes and Supertypes" data-type="sect2"><div class="sect2" id="idm46304969144664">&#13;
<h2>Subtypes and Supertypes</h2>&#13;
&#13;
<p>We talked a little about assignability in <a data-type="xref" href="ch03.html#talking-about-types">“Talking About Types”</a>. Now that you’ve seen most of the types TypeScript has to offer we can dive deeper, starting from the top: what’s a subtype?<a data-primary="types" data-secondary="relationships between" data-tertiary="subtypes and supertypes" data-type="indexterm" id="idm46304969142216"/></p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304969141000">&#13;
<h5>Subtype</h5>&#13;
<p>If you have two types <code>A</code> and <code>B</code>, and <code>B</code> is a subtype of <code>A</code>, then you can safely use a <code>B</code> anywhere an <code>A</code> is required (<a data-type="xref" href="#ch03-subtype_1">Figure 6-1</a>).<a data-primary="subtypes" data-type="indexterm" id="idm46304969136360"/></p>&#13;
</div></aside>&#13;
&#13;
<figure><div class="figure" id="ch03-subtype_1">&#13;
<img alt="prts 0601" src="assets/prts_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>B is a subtype of A</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you look back at <a data-type="xref" href="ch03.html#ch03-type-hierarchy">Figure 3-1</a> at the very beginning of Chapter 3, you’ll see what the subtype relations built into TypeScript are. For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Array is a subtype of Object.</p>&#13;
</li>&#13;
<li>&#13;
<p>Tuple is a subtype of Array.</p>&#13;
</li>&#13;
<li>&#13;
<p>Everything is a subtype of <code>any</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>never</code> is a subtype of everything.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you have a class <code>Bird</code> that extends <code>Animal</code>, then <code>Bird</code> is a subtype of <code>Animal</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>From the definition I just gave for subtype, that means:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Anywhere you need an Object you can also use an Array.</p>&#13;
</li>&#13;
<li>&#13;
<p>Anywhere you need an Array you can also use a Tuple.</p>&#13;
</li>&#13;
<li>&#13;
<p>Anywhere you need an <code>any</code> you can also use an Object.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can use a <code>never</code> anywhere.</p>&#13;
</li>&#13;
<li>&#13;
<p>Anywhere you need an <code>Animal</code> you can also use a <code>Bird</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As you might have guessed, <a data-primary="supertypes" data-type="indexterm" id="idm46304969119640"/>a supertype is the opposite of a subtype.</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304969118616">&#13;
<h5>Supertype</h5>&#13;
<p>If you have two types <code>A</code> and <code>B</code>, and <code>B</code> is a supertype of <code>A</code>, then you can safely use an <code>A</code> anywhere a <code>B</code> is required (<a data-type="xref" href="#ch03-subtype_2">Figure 6-2</a>).</p>&#13;
</div></aside>&#13;
&#13;
<figure><div class="figure" id="ch03-subtype_2">&#13;
<img alt="prts 0602" src="assets/prts_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>B is a supertype of A</h6>&#13;
</div></figure>&#13;
&#13;
<p>Again from the flowchart in <a data-type="xref" href="ch03.html#ch03-type-hierarchy">Figure 3-1</a>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Array is a supertype of Tuple.</p>&#13;
</li>&#13;
<li>&#13;
<p>Object is a supertype of Array.</p>&#13;
</li>&#13;
<li>&#13;
<p>Any is a supertype of everything.</p>&#13;
</li>&#13;
<li>&#13;
<p>Never is a supertype of nothing.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Animal</code> is a supertype of <code>Bird</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This is just the opposite of how subtypes work, and nothing more.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Variance" data-type="sect2"><div class="sect2" id="idm46304969144072">&#13;
<h2>Variance</h2>&#13;
&#13;
<p>For most types it’s pretty easy to intuit whether or not some type <code>A</code> is a subtype of another type <code>B</code>.<a data-primary="variance" data-type="indexterm" id="ix_varia"/><a data-primary="types" data-secondary="relationships between" data-tertiary="variance" data-type="indexterm" id="ix_typerelvar"/> For simple types like <code>number</code>, <code>string</code>, and so on, you can just look them up in the flowchart in <a data-type="xref" href="ch03.html#ch03-type-hierarchy">Figure 3-1</a>, or reason through it (”<code>number</code> is contained in the union <code>number | string</code>, so it must be a subtype of it”).</p>&#13;
&#13;
<p>But for parameterized (generic) types<a data-primary="generics" data-secondary="subtyping" data-type="indexterm" id="idm46304969095832"/><a data-primary="subtypes" data-secondary="subtyping rules for more complex types" data-type="indexterm" id="idm46304969094824"/> and other more complex types, it gets more complicated. Consider these cases:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>When is <code>Array&lt;A&gt;</code> a subtype of <code>Array&lt;B&gt;</code>?</p>&#13;
</li>&#13;
<li>&#13;
<p>When is a shape <code>A</code> a subtype of another shape <code>B</code>?</p>&#13;
</li>&#13;
<li>&#13;
<p>When is a function <code>(a: A) =&gt; B</code> a subtype of another function <code>(c: C) =&gt; D</code>?</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Subtyping rules for types that contain other types (i.e., things with type parameters like <code>Array&lt;A&gt;</code>, shapes with fields like <code>{a: number}</code>, or functions like <code>(a: A) =&gt; B</code>) are harder to reason about, and the answers aren’t as clear-cut. In fact, subtyping rules for these kinds of complex types are a big point of disagreement among programming languages—almost no two languages are alike!</p>&#13;
&#13;
<p>To make the following rules easier to read, I’m going to introduce a few pieces of syntax that let us talk about types a little more precisely and tersely. This syntax is not valid TypeScript; it’s just a way for you and me to share a common language when we talk about types. And don’t worry, I swear the syntax isn’t math:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>A &lt;: B</code> means "<code>A</code> is a subtype of or the same as the type <code>B</code>.”</p>&#13;
</li>&#13;
<li>&#13;
<p><code>A &gt;: B</code> means "<code>A</code> is a supertype of or the same as the type <code>B</code>.”</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shape and array variance" data-type="sect3"><div class="sect3" id="shape-variance">&#13;
<h3>Shape and array variance</h3>&#13;
&#13;
<p>To get some intuition for why exactly languages disagree on subtyping rules for complex types, <a data-primary="subtypes" data-secondary="subtyping rules for more complex types" data-tertiary="shapes and arrays" data-type="indexterm" id="idm46304969078232"/><a data-primary="variance" data-secondary="shape and array" data-type="indexterm" id="idm46304969077016"/><a data-primary="shapes" data-secondary="subtyping" data-type="indexterm" id="idm46304969076072"/>let me take you through an example complex type: shapes. Say you have a shape describing a user in your application. You might represent it with a pair of types that look something like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// An existing user that we got from the server</code>&#13;
<code class="nx">type</code> <code class="nx">ExistingUser</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id</code>: <code class="kt">number</code>&#13;
  <code class="nx">name</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// A new user that hasn't been saved to the server yet</code>&#13;
<code class="nx">type</code> <code class="nx">NewUser</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code>: <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now suppose an intern at your company is tasked with writing some code to delete a user. They start it like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">deleteUser</code><code class="p">(</code><code class="nx">user</code><code class="o">:</code> <code class="p">{</code><code class="nx">id?</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">name</code>: <code class="kt">string</code><code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">delete</code> <code class="nx">user</code><code class="p">.</code><code class="nx">id</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">existingUser</code>: <code class="kt">ExistingUser</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id</code>: <code class="kt">123456</code><code class="p">,</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Ima User'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">deleteUser</code><code class="p">(</code><code class="nx">existingUser</code><code class="p">)</code></pre>&#13;
&#13;
<p><code>deleteUser</code> takes an object of<a data-primary="objects" data-secondary="covariant members" data-type="indexterm" id="idm46304968951832"/><a data-primary="supertypes" data-secondary="using object type in place of expected supertype" data-type="indexterm" id="idm46304968991336"/> type <code>{id?: number, name: string}</code>, and it’s passed an <code>existingUser</code> of type <code>{id: number, name: string}</code>. Notice that the type of the <code>id</code> property (<code>number</code>) is a <em>subtype</em> of the expected type (<code>number | undefined</code>). Therefore the entire object <code>{id: number, name: string}</code> is a subtype of <code>{id?: number, name: string}</code>, so TypeScript lets it fly.</p>&#13;
&#13;
<p>Do you see the safety issue here? It’s a subtle one: after passing an <code>ExistingUser</code> to <code>deleteUser</code>, TypeScript doesn’t know that the user’s <code>id</code> has been deleted, so if we read <code>existingUser.id</code> after deleting it with <code>deleteUser(existingUser)</code>, TypeScript still thinks <code>existingUser.id</code> is of type <code>number</code>!</p>&#13;
&#13;
<p>Clearly, using an object type in a place where something expects its supertype can be unsafe. So why does TypeScript allow it? In general, TypeScript is not designed to be perfectly safe; instead, its type system tries to strike a balance between catching real mistakes and being easy to use, without you needing to get a degree in programming language theory to understand why something is an error. This specific case of un<span class="keep-together">safety</span> is a practical one: since destructive updates (like deleting a property) are relatively rare in practice, TypeScript is lax and lets you assign an object to a place where its supertype is expected.</p>&#13;
&#13;
<p>What about the opposite direction—can you assign an object to a place where its subtype is expected?</p>&#13;
&#13;
<p>Let’s add a new type for a legacy user, then delete a user of that type (imagine you’re adding types to code your coworker wrote before you started using TypeScript):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">LegacyUser</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id?</code>: <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code>&#13;
  <code class="nx">name</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">legacyUser</code>: <code class="kt">LegacyUser</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="s1">'793331'</code><code class="p">,</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Xin Yang'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">deleteUser</code><code class="p">(</code><code class="nx">legacyUser</code><code class="p">)</code> <code class="c1">// Error TS2345: Argument of type 'LegacyUser' is not</code>&#13;
                       <code class="c1">// assignable to parameter of type '{id?: number |</code>&#13;
                       <code class="c1">// undefined, name: string}'. Type 'string' is not</code>&#13;
                       <code class="c1">// assignable to type 'number | undefined'.</code></pre>&#13;
&#13;
<p>When we pass a shape with a property whose type is a supertype of the expected type, TypeScript complains.<a data-primary="shapes" data-secondary="subtype and supertype rules" data-type="indexterm" id="idm46304968915256"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304968914408"/> That’s because <code>id</code> is a <code>string | number |</code> <code><span class="keep-together">undefined</span></code>, and <code>deleteUser</code> only handles the case of an <code>id</code> that’s a <code>number | undefined</code>.</p>&#13;
&#13;
<p>TypeScript’s behavior is as follows: if you expect a shape, you can also pass a type with property types that are <code>&lt;:</code> their expected types, but you cannot pass a shape with property types that are supertypes of their expected types. When talking about types, we say that TypeScript shapes (objects and classes) are <em>covariant</em> in their property types.<a data-primary="covariance" data-type="indexterm" id="idm46304968908392"/><a data-primary="properties" data-secondary="object and class, covariance in" data-type="indexterm" id="idm46304968907688"/> That is, for an object <code>A</code> to be assignable to an object <code>B</code>, each of its properties must be <code>&lt;:</code> its corresponding property in <code>B</code>.<a data-primary="invariance" data-type="indexterm" id="idm46304968904776"/></p>&#13;
&#13;
<p>More generally, covariance is just one<a data-primary="variance" data-secondary="kinds of" data-type="indexterm" id="idm46304968903784"/> of four sorts of variance:</p>&#13;
<dl>&#13;
<dt><em>Invariance</em></dt>&#13;
<dd>&#13;
<p>You want exactly a <code>T</code>.</p>&#13;
</dd>&#13;
<dt><em>Covariance</em></dt>&#13;
<dd>&#13;
<p>You want a <code>&lt;:T</code>.</p>&#13;
</dd>&#13;
<dt><em>Contravariance</em></dt>&#13;
<dd>&#13;
<p>You want a <code>&gt;:T</code>.</p>&#13;
</dd>&#13;
<dt><em>Bivariance</em></dt>&#13;
<dd>&#13;
<p>You’re OK with either <code>&lt;:T</code> or <code>&gt;:T</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In TypeScript, every complex type is covariant in its members—objects, classes, arrays, and function return types—with one exception: function parameter types, which are <em>contravariant</em>.<a data-primary="arrays" data-secondary="covariance in array members" data-type="indexterm" id="idm46304968893000"/><a data-primary="classes" data-secondary="covariance in class members" data-type="indexterm" id="idm46304968891976"/><a data-primary="contravariance" data-type="indexterm" id="idm46304968891016"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Not all languages make this same design decision. In some languages objects are <em>invariant</em> in their property types, because as we saw, covariant property types can lead to unsafe behavior.<a data-primary="objects" data-secondary="invariant property types in some languages" data-type="indexterm" id="idm46304968888840"/> Some languages have different rules for mutable and immutable objects (try to reason through it yourself!). Some languages—like Scala, Kotlin, and Flow—even have explicit syntax for programmers to specify variance for their own data types.</p>&#13;
&#13;
<p>When designing TypeScript, its authors opted for a balance between ease of use and safety. When you make objects invariant in their property types, even though it’s safer, it can make a type system tedious to use because you end up banning things that are safe in practice (e.g., if we didn’t <code>delete</code> the <code>id</code> in <code>deleteUser</code>, then it would have been perfectly safe to pass in an object that’s a supertype of the expected type).</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Function variance" data-type="sect3"><div class="sect3" id="function-variance">&#13;
<h3>Function variance</h3>&#13;
&#13;
<p>Let’s start with a few examples.</p>&#13;
&#13;
<p>A function <code>A</code> is a subtype of function <code>B</code> if <code>A</code> has the same or<a data-primary="functions" data-secondary="variance" data-type="indexterm" id="idm46304968880824"/><a data-primary="variance" data-secondary="function" data-type="indexterm" id="idm46304968879928"/> lower arity (number of parameters) than <code>B</code> and:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>A</code>’s <code>this</code> type either isn’t specified, or is <code>&gt;: B</code>’s <code>this</code> type.</p>&#13;
</li>&#13;
<li>&#13;
<p>Each of <code>A</code>’s parameters is <code>&gt;:</code> its corresponding parameter in <code>B</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>A</code>’s return type is <code>&lt;: B</code>’s return type.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Read that over a few times, and make sure you understand what each rule means. You might have noticed that for a function <code>A</code> to be a subtype of function <code>B</code>, we say that its <code>this</code> type and parameters must be <code>&gt;:</code> their counterparts in <code>B</code>, while its return type has to be <code>&lt;:</code>! Why does the direction flip like that? Why isn’t it simply <code>&lt;:</code> for each component (<code>this</code> type, parameter types, and return type), like it is for objects, arrays, unions, and so on?</p>&#13;
&#13;
<p>To answer this question, let’s derive it ourselves. We’ll start by defining three types (we’re going to use a <code>class</code> for clarity, but this works for any choice of types where <code>A &lt;: B &lt;: C</code>):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">Animal</code> <code class="p">{}</code>&#13;
<code class="kr">class</code> <code class="nx">Bird</code> <code class="kr">extends</code> <code class="nx">Animal</code> <code class="p">{</code>&#13;
  <code class="nx">chirp() {</code><code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="kr">class</code> <code class="nx">Crow</code> <code class="kr">extends</code> <code class="nx">Bird</code> <code class="p">{</code>&#13;
  <code class="nx">caw() {</code><code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, <code>Crow</code> is a subtype of <code>Bird</code>, which is a subtype of <code>Animal</code>. That is, <code>Crow &lt;: Bird &lt;: Animal</code>.</p>&#13;
&#13;
<p>Now, let’s define a function that takes a <code>Bird</code>, and makes it chirp:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">chirp</code><code class="p">(</code><code class="nx">bird</code>: <code class="kt">Bird</code><code class="p">)</code><code class="o">:</code> <code class="nx">Bird</code> <code class="p">{</code>&#13;
  <code class="nx">bird</code><code class="p">.</code><code class="nx">chirp</code><code class="p">()</code>&#13;
  <code class="k">return</code> <code class="nx">bird</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So far, so good. What kinds of things does TypeScript let you pass into <code>chirp</code>?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">chirp</code><code class="p">(</code><code class="k">new</code> <code class="nx">Animal</code><code class="p">)</code> <code class="c1">// Error TS2345: Argument of type 'Animal' is not assignable</code>&#13;
<code class="nx">chirp</code><code class="p">(</code><code class="k">new</code> <code class="nx">Bird</code><code class="p">)</code>   <code class="c1">// to parameter of type 'Bird'.</code>&#13;
<code class="nx">chirp</code><code class="p">(</code><code class="k">new</code> <code class="nx">Crow</code><code class="p">)</code></pre>&#13;
&#13;
<p>You can<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304968758168"/> pass an instance of <code>Bird</code> (because that’s what <code>chirp</code>’s parameter <code>bird</code>’s type is) or an instance of <code>Crow</code> (because it’s a subtype of <code>Bird</code>). Great: passing in a subtype works as expected.</p>&#13;
&#13;
<p>Let’s make a new function. This time, its parameter will be a <em>function</em>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">clone</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">b</code>: <code class="kt">Bird</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Bird</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>clone</code> needs a function <code>f</code> that takes a <code>Bird</code> and returns a <code>Bird</code>. What types of functions can you safely pass for <code>f</code>? Clearly you can pass a function that takes a <code>Bird</code> and returns a <code>Bird</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">birdToBird</code><code class="p">(</code><code class="nx">b</code>: <code class="kt">Bird</code><code class="p">)</code><code class="o">:</code> <code class="nx">Bird</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">clone</code><code class="p">(</code><code class="nx">birdToBird</code><code class="p">)</code> <code class="c1">// OK</code></pre>&#13;
&#13;
<p>What about a function that takes a <code>Bird</code> and returns a <code>Crow</code>, or an <code>Animal</code>?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">birdToCrow</code><code class="p">(</code><code class="nx">d</code>: <code class="kt">Bird</code><code class="p">)</code><code class="o">:</code> <code class="nx">Crow</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">clone</code><code class="p">(</code><code class="nx">birdToCrow</code><code class="p">)</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">birdToAnimal</code><code class="p">(</code><code class="nx">d</code>: <code class="kt">Bird</code><code class="p">)</code><code class="o">:</code> <code class="nx">Animal</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">clone</code><code class="p">(</code><code class="nx">birdToAnimal</code><code class="p">)</code> <code class="c1">// Error TS2345: Argument of type '(d: Bird) =&gt; Animal' is</code>&#13;
                    <code class="c1">// not assignable to parameter of type '(b: Bird) =&gt; Bird'.</code>&#13;
                    <code class="c1">// Type 'Animal' is not assignable to type 'Bird'.</code></pre>&#13;
&#13;
<p><code>birdToCrow</code> works as expected, but <code>birdToAnimal</code> gives us an error. Why? Imagine that <code>clone</code>’s implementation looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">clone</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">b</code>: <code class="kt">Bird</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Bird</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">parent</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Bird</code>&#13;
  <code class="kd">let</code> <code class="nx">babyBird</code> <code class="o">=</code> <code class="nx">f</code><code class="p">(</code><code class="nx">parent</code><code class="p">)</code>&#13;
  <code class="nx">babyBird</code><code class="p">.</code><code class="nx">chirp</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we passed to our <code>clone</code> function an <code>f</code> that returned an <code>Animal</code>, then we couldn’t call <code>.chirp</code> on it! So TypeScript has to make sure, at compile time, that the function we passed in returns <em>at least</em> a <code>Bird</code>.</p>&#13;
&#13;
<p>We say <a data-primary="functions" data-secondary="variance" data-tertiary="covariant return types" data-type="indexterm" id="idm46304968505704"/><a data-primary="covariance" data-secondary="in function return types" data-type="indexterm" id="idm46304968504424"/><a data-primary="return types" data-secondary="covariance in" data-type="indexterm" id="idm46304968503512"/>that functions are <em>covariant</em> in their return types, which is a fancy way of saying that for a function to be a subtype of another function, its return type has to be <code>&lt;:</code> the other function’s return type.</p>&#13;
&#13;
<p>OK, what about<a data-primary="parameters" data-secondary="contravariance in function parameters" data-type="indexterm" id="idm46304968501032"/> parameter types?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">animalToBird</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">Animal</code><code class="p">)</code><code class="o">:</code> <code class="nx">Bird</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">clone</code><code class="p">(</code><code class="nx">animalToBird</code><code class="p">)</code> <code class="c1">// OK</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">crowToBird</code><code class="p">(</code><code class="nx">c</code>: <code class="kt">Crow</code><code class="p">)</code><code class="o">:</code> <code class="nx">Bird</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">clone</code><code class="p">(</code><code class="nx">crowToBird</code><code class="p">)</code> <code class="c1">// Error TS2345: Argument of type '(c: Crow) =&gt; Bird' is not</code>&#13;
                  <code class="c1">// assignable to parameter of type '(b: Bird) =&gt; Bird'.</code></pre>&#13;
&#13;
<p>For a function to be assignable to another function, its parameter types (including <code>this</code>) all have to be <code>&gt;:</code> their corresponding parameter <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304968444328"/><a data-primary="this variable" data-secondary="contravariance in function this types" data-type="indexterm" id="idm46304968443112"/>types in the other function. To see why, think about how a user might have implemented <code>crowToBird</code> before passing it into <code>clone</code>. What if they did this?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">crowToBird</code><code class="p">(</code><code class="nx">c</code>: <code class="kt">Crow</code><code class="p">)</code><code class="o">:</code> <code class="nx">Bird</code> <code class="p">{</code>&#13;
  <code class="nx">c</code><code class="p">.</code><code class="nx">caw</code><code class="p">()</code>&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="nx">Bird</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now if <code>clone</code> called <code>crowToBird</code> with a <code>new Bird</code>, we’d get an exception because <code>.caw</code> is only defined on <code>Crow</code>s, not on all <code>Bird</code>s.</p>&#13;
&#13;
<p>This means functions are <em>contravariant</em> in their parameter and <code>this</code> types. That is, for a function to be a subtype of another function, each of its parameters and its <code>this</code> type must be <code>&gt;:</code> its corresponding parameter in the other function.<a data-primary="contravariance" data-secondary="in function parameters and this types" data-type="indexterm" id="idm46304968373848"/></p>&#13;
&#13;
<p>Thankfully, you don’t have to memorize and recite these rules. Just have them in the back of your mind when your code editor gives you a red squiggly when you pass an incorrectly typed function somewhere, so you know why TypeScript is giving you the error it does.</p>&#13;
<div data-type="tip"><h1>TSC Flag: strictFunctionTypes</h1>&#13;
<p>For legacy reasons, functions in TypeScript are actually covariant in their parameter and <code>this</code> types by default. To opt into the safer, contravariant behavior we just explored, be sure to enable the <code>{"strictFunctionTypes": true}</code> flag in your <em>tsconfig.json</em>.<a data-primary="TSC compiler" data-secondary="strictFunctionTypes flag" data-type="indexterm" id="idm46304968421128"/><a data-primary="strictFunctionTypes TSC flag" data-type="indexterm" id="idm46304968420104"/></p>&#13;
&#13;
<p><code>strict</code> mode includes <code>strictFunctionTypes</code>, so if you’re already using <code>{"strict": true}</code>, you’re good to go.<a data-primary="variance" data-startref="ix_varia" data-type="indexterm" id="idm46304968417880"/><a data-primary="types" data-secondary="relationships between" data-startref="ix_typerelvar" data-tertiary="variance" data-type="indexterm" id="idm46304968416872"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Assignability" data-type="sect2"><div class="sect2" id="assignability">&#13;
<h2>Assignability</h2>&#13;
&#13;
<p>Subtype and supertype relations are core concepts in any statically typed language. They’re also important to understanding how <em>assignability</em> works (as a reminder, assignability refers to TypeScript’s rules for whether or not you can use a type <code>A</code> where another type <code>B</code> is required).<a data-primary="subtypes" data-secondary="assignability and" data-type="indexterm" id="idm46304968411848"/><a data-primary="supertypes" data-secondary="assignability and" data-type="indexterm" id="idm46304968410840"/><a data-primary="types" data-secondary="relationships between" data-tertiary="assignability" data-type="indexterm" id="idm46304968409896"/><a data-primary="assignability" data-type="indexterm" id="idm46304968408680"/></p>&#13;
&#13;
<p>When TypeScript wants to answer the question “Is type <code>A</code> assignable to type <code>B</code>?” it follows a few simple rules. For <em>non-enum types</em>—like arrays, booleans, numbers, objects, functions, classes, class instances, and strings, including literal types—<code>A</code> is assignable to <code>B</code> if either of the following is true:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>A &lt;: B</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>A</code> is <code>any</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Rule 1 is just the definition of what a subtype is: if <code>A</code> is a subtype of <code>B</code>, then wherever you need a <code>B</code> you can also use an <code>A</code>.</p>&#13;
&#13;
<p>Rule 2 is the exception to rule 1, and is a convenience for interoperating with JavaScript code.</p>&#13;
&#13;
<p>For <em>enum types</em> created with the <code>enum</code> or <code>const enum</code> keywords, a type <code>A</code> is assignable to an enum <code>B</code> if  either<a data-primary="enums" data-secondary="assignability" data-type="indexterm" id="idm46304968341992"/> of these is true:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>A</code> is a member of enum <code>B</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>B</code> has at least one member that’s a <code>number</code>, and <code>A</code> is a <code>number</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Rule 1 is exactly the same as for simple types (if <code>A</code> is a member of enum <code>B</code>, then <code>A</code>’s type is <code>B</code>, so all we’re saying is <code>B &lt;: B</code>).</p>&#13;
&#13;
<p>Rule 2 is a convenience for working with enums. As we talked about in <a data-type="xref" href="ch03.html#enums">“Enums”</a>, rule 2 is a big source of unsafety in TypeScript, and this is one reason I suggest throwing the baby out with the bathwater and avoiding enums entirely.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Widening" data-type="sect2"><div class="sect2" id="type-widening">&#13;
<h2>Type Widening</h2>&#13;
&#13;
<p><em>Type widening</em> is key to understanding how TypeScript’s type inference works. In general, TypeScript<a data-primary="types" data-secondary="relationships between" data-tertiary="type widening" data-type="indexterm" id="ix_typerelwide"/><a data-primary="type widening" data-type="indexterm" id="ix_typwide"/> will be lenient when inferring your types, and will err on the side of inferring a more general type rather than the most specific type possible. This makes your life as a programmer easier, and means less time spent quelling the typechecker’s complaints.<a data-primary="widening types" data-see="type widening" data-type="indexterm" id="idm46304968327096"/></p>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#types">Chapter 3</a>, you already saw a few instances of type widening in action. Let’s look at a few more examples.</p>&#13;
&#13;
<p>When you declare a variable in a way that allows it to be mutated later (e.g., with <code>let</code> or <code>var</code>), its type<a data-primary="variables" data-secondary="mutable, type widening" data-type="indexterm" id="idm46304968323544"/> is widened from its literal value to the base type that literal belongs to:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="s1">'x'</code>               <code class="c1">// string</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">3</code>                 <code class="c1">// number</code>&#13;
<code class="kd">var</code> <code class="nx">c</code> <code class="o">=</code> <code class="kc">true</code>              <code class="c1">// boolean</code>&#13;
<code class="kr">const</code> <code class="nx">d</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">3</code><code class="p">}</code>          <code class="c1">// {x: number}</code>&#13;
&#13;
<code class="kr">enum</code> <code class="nx">E</code> <code class="p">{</code><code class="nx">X</code><code class="p">,</code> <code class="nx">Y</code><code class="p">,</code> <code class="nx">Z</code><code class="p">}</code>&#13;
<code class="kd">let</code> <code class="nx">e</code> <code class="o">=</code> <code class="nx">E</code><code class="p">.</code><code class="nx">X</code>               <code class="c1">// E</code></pre>&#13;
&#13;
<p>Not so for<a data-primary="variables" data-secondary="immutable, no type widening" data-type="indexterm" id="idm46304968238808"/> immutable declarations:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="s1">'x'</code>             <code class="c1">// 'x'</code>&#13;
<code class="kr">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">3</code>               <code class="c1">// 3</code>&#13;
<code class="kr">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kc">true</code>            <code class="c1">// true</code>&#13;
&#13;
<code class="kr">enum</code> <code class="nx">E</code> <code class="p">{</code><code class="nx">X</code><code class="p">,</code> <code class="nx">Y</code><code class="p">,</code> <code class="nx">Z</code><code class="p">}</code>&#13;
<code class="kr">const</code> <code class="nx">e</code> <code class="o">=</code> <code class="nx">E</code><code class="p">.</code><code class="nx">X</code>             <code class="c1">// E.X</code></pre>&#13;
&#13;
<p>You can use an explicit type annotation to prevent your type from being widened:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code><code class="o">:</code> <code class="s1">'x'</code> <code class="o">=</code> <code class="s1">'x'</code>          <code class="c1">// 'x'</code>&#13;
<code class="kd">let</code> <code class="nx">b</code>: <code class="kt">3</code> <code class="o">=</code> <code class="mi">3</code>              <code class="c1">// 3</code>&#13;
<code class="kd">var</code> <code class="nx">c</code>: <code class="kt">true</code> <code class="o">=</code> <code class="kc">true</code>        <code class="c1">// true</code>&#13;
<code class="kr">const</code> <code class="nx">d</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">3</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">3</code><code class="p">}</code>  <code class="c1">// {x: 3}</code></pre>&#13;
&#13;
<p>When you reassign a nonwidened type using <code>let</code> or <code>var</code>, TypeScript widens it for you. To tell TypeScript to keep it narrow, add an explicit type annotation to your original declaration:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="s1">'x'</code>             <code class="c1">// 'x'</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code>                 <code class="c1">// string</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">c</code><code class="o">:</code> <code class="s1">'x'</code> <code class="o">=</code> <code class="s1">'x'</code>        <code class="c1">// 'x'</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">c</code>                 <code class="c1">// 'x'</code></pre>&#13;
&#13;
<p>Variables initialized to <code>null</code> or <code>undefined</code> are widened to <code>any</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="kc">null</code>              <code class="c1">// any</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code>                     <code class="c1">// any</code>&#13;
<code class="nx">a</code> <code class="o">=</code> <code class="s1">'b'</code>                   <code class="c1">// any</code></pre>&#13;
&#13;
<p>But when a variable <a data-primary="null type" data-secondary="variables initialized to, type widening" data-type="indexterm" id="idm46304968083016"/><a data-primary="undefined type" data-secondary="variables initialized to, type widening" data-type="indexterm" id="idm46304968082280"/><a data-primary="any type" data-secondary="widening of variables initialized as null or undefined to" data-type="indexterm" id="idm46304968081400"/>initialized to <code>null</code> or <code>undefined</code> leaves the scope it was declared in, TypeScript assigns it a definite type:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<b><code class="kd">function</code><code> </code><code class="nx">x() {</code></b><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">a</code><code> </code><code class="o">=</code><code> </code><code class="kc">null</code><code>            </code><em><code class="c1">// any</code></em><code class="c1">&#13;
</code><code>  </code><code class="nx">a</code><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code>                   </code><em><code class="c1">// any</code></em><code class="c1">&#13;
</code><code>  </code><code class="nx">a</code><code> </code><code class="o">=</code><code> </code><code class="s1">'b'</code><code>                 </code><em><code class="c1">// any</code></em><code class="c1">&#13;
</code><code>  </code><b><code class="k">return</code><code> </code><code class="nx">a</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">x</code><code class="p">(</code><code class="p">)</code></b><code>                       </code><em><code class="c1">// string</code></em><code class="c1">&#13;
</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The const type" data-type="sect3"><div class="sect3" id="const-types">&#13;
<h3>The const type</h3>&#13;
&#13;
<p>TypeScript comes with a special <code>const</code> type that you can use to opt out of type widening a declaration at a time. <a data-primary="const" data-secondary="using to opt out of type widening at declaration time" data-type="indexterm" id="idm46304967991592"/><a data-primary="type widening" data-secondary="preventing with const type" data-type="indexterm" id="idm46304967990648"/>Use it as a type assertion (read ahead to <a data-type="xref" href="#type-assertions">“Type Assertions”</a>):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">3</code><code class="p">}</code>                <code class="c1">// {x: number}</code>&#13;
<code class="kd">let</code> <code class="nx">b</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">3</code><code class="p">}</code>                 <code class="c1">// {x: 3}</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">3</code><code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code>       <code class="c1">// {readonly x: 3}</code></pre>&#13;
&#13;
<p><code>const</code> opts your type out of widening and recursively marks its members as <code>readonly</code>, even for deeply nested data structures:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">2</code><code class="p">}]</code>           <code class="c1">// (number | {x: number})[]</code>&#13;
<code class="kd">let</code> <code class="nx">e</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">{</code><code class="nx">x</code>: <code class="kt">2</code><code class="p">}]</code> <code class="kr">as</code> <code class="kr">const</code>  <code class="c1">// readonly [1, {readonly x: 2}]</code></pre>&#13;
&#13;
<p>Use <code>as const</code> when you want TypeScript to infer your type as narrowly as possible.<a data-primary="as const" data-type="indexterm" id="idm46304967927384"/><a data-primary="type widening" data-startref="ix_typwide" data-type="indexterm" id="idm46304967926888"/><a data-primary="types" data-secondary="relationships between" data-startref="ix_typerelwide" data-tertiary="type widening" data-type="indexterm" id="idm46304967882744"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Excess property checking" data-type="sect3"><div class="sect3" id="idm46304967881128">&#13;
<h3>Excess property checking</h3>&#13;
&#13;
<p>Type widening also comes into the picture when TypeScript checks whether or not one object type is assignable to another object type.<a data-primary="properties" data-secondary="excess property checking" data-type="indexterm" id="idm46304967879320"/><a data-primary="type widening" data-secondary="excess property checking" data-type="indexterm" id="idm46304967878376"/><a data-primary="excess property checking" data-type="indexterm" id="idm46304967877464"/></p>&#13;
&#13;
<p>Recall from <a data-type="xref" href="#shape-variance">“Shape and array variance”</a> that object types are covariant in their members. But if TypeScript stuck to this rule without doing any additional checks, it could lead to a problem.</p>&#13;
&#13;
<p>For example, consider an <code>Options</code> object you might pass into a class to configure it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Options</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">baseURL</code>: <code class="kt">string</code>&#13;
  <code class="nx">cacheSize?</code>: <code class="kt">number</code>&#13;
  <code class="nx">tier</code><code class="o">?:</code> <code class="s1">'prod'</code> <code class="o">|</code> <code class="s1">'dev'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">API</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code> <code class="nx">options</code>: <code class="kt">Options</code><code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">new</code> <code class="nx">API</code><code class="p">({</code>&#13;
  <code class="nx">baseURL</code><code class="o">:</code> <code class="s1">'https://api.mysite.com'</code><code class="p">,</code>&#13;
  <code class="nx">tier</code><code class="o">:</code> <code class="s1">'prod'</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Now, what happens if you misspell an option?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="k">new</code> <code class="nx">API</code><code class="p">({</code>&#13;
  <code class="nx">baseURL</code><code class="o">:</code> <code class="s1">'https://api.mysite.com'</code><code class="p">,</code>&#13;
  <code class="nx">tierr</code><code class="o">:</code> <code class="s1">'prod'</code>      <code class="c1">// Error TS2345: Argument of type '{tierr: string}'</code>&#13;
<code class="p">})</code>                   <code class="c1">// is not assignable to parameter of type 'Options'.</code>&#13;
                     <code class="c1">// Object literal may only specify known properties,</code>&#13;
                     <code class="c1">// but 'tierr' does not exist in type 'Options'.</code>&#13;
                     <code class="c1">// Did you mean to write 'tier'?</code></pre>&#13;
&#13;
<p>This is a common bug when working with JavaScript, so it’s really helpful that TypeScript helps us catch it.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304967737528"/> But if object types are covariant in their members, how is it that TypeScript catches this?</p>&#13;
&#13;
<p>That is:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We expected the type <code>{baseURL: string, cacheSize?: number, tier?: 'prod' | 'dev'}</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>We passed in the type <code>{baseURL: string, tierr: string}</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The type we passed in is a subtype of the type we expected, but somehow, TypeScript knew to report an error.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>TypeScript was able to catch this due to its <em>excess property checking</em>, which works like this: when you try to assign a fresh object literal type <code>T</code> to another type <code>U</code>, and <code>T</code> has properties that aren’t present in <code>U</code>, TypeScript reports an error.<a data-primary="object literals" data-secondary="fresh object literal type" data-type="indexterm" id="idm46304967728904"/><a data-primary="fresh object literal type" data-type="indexterm" id="idm46304967779448"/></p>&#13;
&#13;
<p>A <em>fresh object literal type</em> is the type TypeScript infers from an object literal. If that object literal either uses a type assertion (see <a data-type="xref" href="#type-assertions">“Type Assertions”</a>) or is assigned to a variable, then the fresh object literal type is <em>widened</em> to a regular object type, and its freshness disappears.</p>&#13;
&#13;
<p>This definition is dense, so let’s walk through our example again, trying a few more variations on the theme this time:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Options</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">baseURL</code><code>: </code><code class="kt">string</code><code>&#13;
  </code><code class="nx">cacheSize?</code><code>: </code><code class="kt">number</code><code>&#13;
  </code><code class="nx">tier</code><code class="o">?</code><code class="o">:</code><code> </code><code class="s1">'prod'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'dev'</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kr">class</code><code> </code><code class="nx">API</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code><code> </code><code class="nx">options</code><code>: </code><code class="kt">Options</code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="k">new</code><code> </code><code class="nx">API</code><code class="p">(</code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO1-1" id="co_advanced_types_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">baseURL</code><code class="o">:</code><code> </code><code class="s1">'https://api.mysite.com'</code><code class="p">,</code><code>&#13;
  </code><code class="nx">tier</code><code class="o">:</code><code> </code><code class="s1">'prod'</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="k">new</code><code> </code><code class="nx">API</code><code class="p">(</code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO1-2" id="co_advanced_types_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">baseURL</code><code class="o">:</code><code> </code><code class="s1">'https://api.mysite.com'</code><code class="p">,</code><code>&#13;
  </code><code class="nx">badTier</code><code class="o">:</code><code> </code><code class="s1">'prod'</code><code>    </code><code class="c1">// Error TS2345: Argument of type '{baseURL: string; badTier:&#13;
</code><code class="p">}</code><code class="p">)</code><code>                   </code><code class="c1">// string}' is not assignable to parameter of type 'Options'.&#13;
</code><code>&#13;
</code><code class="k">new</code><code> </code><code class="nx">API</code><code class="p">(</code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO1-3" id="co_advanced_types_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="nx">baseURL</code><code class="o">:</code><code> </code><code class="s1">'https://api.mysite.com'</code><code class="p">,</code><code>&#13;
  </code><code class="nx">badTier</code><code class="o">:</code><code> </code><code class="s1">'prod'</code><code>&#13;
</code><code class="p">}</code><code> </code><code class="kr">as</code><code> </code><code class="nx">Options</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">badOptions</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO1-4" id="co_advanced_types_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="nx">baseURL</code><code class="o">:</code><code> </code><code class="s1">'https://api.mysite.com'</code><code class="p">,</code><code>&#13;
  </code><code class="nx">badTier</code><code class="o">:</code><code> </code><code class="s1">'prod'</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="k">new</code><code> </code><code class="nx">API</code><code class="p">(</code><code class="nx">badOptions</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">options</code><code>: </code><code class="kt">Options</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO1-5" id="co_advanced_types_CO1-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
  </code><code class="nx">baseURL</code><code class="o">:</code><code> </code><code class="s1">'https://api.mysite.com'</code><code class="p">,</code><code>&#13;
  </code><code class="nx">badTier</code><code class="o">:</code><code> </code><code class="s1">'prod'</code><code>    </code><code class="c1">// Error TS2322: Type '{baseURL: string; badTier: string}'&#13;
</code><code class="p">}</code><code>                    </code><code class="c1">// is not assignable to type 'Options'.&#13;
</code><code class="k">new</code><code> </code><code class="nx">API</code><code class="p">(</code><code class="nx">options</code><code class="p">)</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO1-1" id="callout_advanced_types_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We instantiate <code>API</code> with a <code>baseURL</code> and one of our two optional properties, <code>tier</code>. This works as expected.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304967554664"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304967574552"/></p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO1-2" id="callout_advanced_types_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Here, we misspell <code>tier</code> as <code>badTier</code>. The options object we pass to <code>new API</code> is fresh (because its type is inferred, it isn’t assigned to a variable, and we don’t make a type assertion about its type), so TypeScript runs an excess property check on it, revealing the excess <code>badTier</code> property (which is defined in our options object but not on the <code>Options</code> type).</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO1-3" id="callout_advanced_types_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>We assert that our invalid options object is of type <code>Options</code>. TypeScript no longer considers it fresh, and bails out of excess property checking: no error. If you’re not familiar with the <code>as T</code> syntax, read ahead to <a data-type="xref" href="#type-assertions">“Type Assertions”</a>.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO1-4" id="callout_advanced_types_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>We assign our options object to a variable, <code>badOptions</code>. TypeScript no longer considers it to be fresh, and bails out of excess property checking: no error.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO1-5" id="callout_advanced_types_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>When we explicitly type <code>options</code> as <code>Options</code>, the object we assign to <code>options</code> is fresh, so TypeScript performs excess property checking, catching our bug. Note that in this case the excess property check doesn’t happen when we pass <code>options</code> to <code>new API</code>; rather, it happens when we try to assign our options object to the variable <code>options</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Don’t worry—you don’t need to memorize these rules. They are TypeScript’s internal heuristics for catching the most bugs possible in a practical way, so as not to be a burden on you, the programmer. Just keep them in mind when you’re wondering how TypeScript knew to complain about that one bug that even Ivan, the battle-weathered gatekeeper of your company’s codebase and master code reviewer, didn’t notice.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Refinement" data-type="sect2"><div class="sect2" id="refinement">&#13;
<h2>Refinement</h2>&#13;
&#13;
<p>TypeScript<a data-primary="types" data-secondary="relationships between" data-tertiary="refinement" data-type="indexterm" id="ix_typerelref"/><a data-primary="refinement (types)" data-type="indexterm" id="ix_refine"/><a data-primary="flow-based type inference" data-type="indexterm" id="idm46304967504056"/> performs flow-based type inference, which is a kind of symbolic execution where the typechecker uses control flow statements like <code>if</code>, <code>?</code>, <code>||</code>, and <code>switch</code>, as well as type queries like <code>typeof</code>, <code>instanceof</code>, and <code>in</code>, to <em>refine</em> types as it goes, just like a programmer reading through the code would.<sup><a data-type="noteref" href="ch06.html#idm46304967500104" id="idm46304967500104-marker">1</a></sup> It’s an incredibly convenient feature for a typechecker to have, but is another one of those things that remarkably few languages support.<sup><a data-type="noteref" href="ch06.html#idm46304967497288" id="idm46304967497288-marker">2</a></sup></p>&#13;
&#13;
<p>Let’s walk through an example. Say we’ve built an API for defining CSS rules in TypeScript, and a coworker wants to use it to set an HTML element’s <code>width</code>. They pass in the width, which we then want to parse and validate.</p>&#13;
&#13;
<p>We’ll first implement a function to parse a CSS string into a value and a unit:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// We use a union of string literals to describe</code>&#13;
<code class="c1">// the possible values a CSS unit can have</code>&#13;
<code class="nx">type</code> <code class="nx">Unit</code> <code class="o">=</code> <code class="s1">'cm'</code> <code class="o">|</code> <code class="s1">'px'</code> <code class="o">|</code> <code class="s1">'%'</code>&#13;
&#13;
<code class="c1">// Enumerate the units</code>&#13;
<code class="kd">let</code> <code class="nx">units</code>: <code class="kt">Unit</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'cm'</code><code class="p">,</code> <code class="s1">'px'</code><code class="p">,</code> <code class="s1">'%'</code><code class="p">]</code>&#13;
&#13;
<code class="c1">// Check each unit, and return null if there is no match</code>&#13;
<code class="kd">function</code> <code class="nx">parseUnit</code><code class="p">(</code><code class="nx">value</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Unit</code> <code class="o">|</code> <code class="kc">null</code> <code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">units</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">value</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="nx">units</code><code class="p">[</code><code class="nx">i</code><code class="p">]))</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">units</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="kc">null</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can then use <code>parseUnit</code> to parse a width value passed to us by a user. <code>width</code> might be a number (which we assume is in pixels), or a string with units attached, or it might be <code>null</code> or <code>undefined</code>.<a data-primary="type refinement" data-see="refinement" data-type="indexterm" id="idm46304967419800"/></p>&#13;
&#13;
<p>We take advantage of type refinement a few times in this example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Width</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">unit</code><code>: </code><code class="kt">Unit</code><code class="p">,</code><code>&#13;
  </code><code class="nx">value</code><code>: </code><code class="kt">number</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">parseWidth</code><code class="p">(</code><code class="nx">width</code><code>: </code><code class="kt">number</code><code> </code><code class="o">|</code><code> </code><code class="kt">string</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code><code> </code><code class="o">|</code><code> </code><code class="kc">undefined</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Width</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="c1">// If width is null or undefined, return early&#13;
</code><code>  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">width</code><code> </code><code class="o">==</code><code> </code><code class="kc">null</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO2-1" id="co_advanced_types_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="k">return</code><code> </code><code class="kc">null</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
&#13;
  </code><code class="c1">// If width is a number, default to pixels&#13;
</code><code>  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="k">typeof</code><code> </code><code class="nx">width</code><code> </code><code class="o">===</code><code> </code><code class="s1">'number'</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO2-2" id="co_advanced_types_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
    </code><code class="k">return</code><code> </code><code class="p">{</code><code class="nx">unit</code><code class="o">:</code><code> </code><code class="s1">'px'</code><code class="p">,</code><code> </code><code class="nx">value</code><code>: </code><code class="kt">width</code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
&#13;
  </code><code class="c1">// Try to parse a unit from width&#13;
</code><code>  </code><code class="kd">let</code><code> </code><code class="nx">unit</code><code> </code><code class="o">=</code><code> </code><code class="nx">parseUnit</code><code class="p">(</code><code class="nx">width</code><code class="p">)</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">unit</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO2-3" id="co_advanced_types_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="k">return</code><code> </code><code class="p">{</code><code class="nx">unit</code><code class="p">,</code><code> </code><code class="nx">value</code><code>: </code><code class="kt">parseFloat</code><code class="p">(</code><code class="nx">width</code><code class="p">)</code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
&#13;
  </code><code class="c1">// Otherwise, return null&#13;
</code><code>  </code><code class="k">return</code><code> </code><code class="kc">null</code><code> </code><a class="co" href="#callout_advanced_types_CO2-4" id="co_advanced_types_CO2-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO2-1" id="callout_advanced_types_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>TypeScript is smart enough to know that doing a loose equality check against <code>null</code> will return <code>true</code> for both <code>null</code> and <code>undefined</code> in JavaScript. It knows that if this check passes then we will return, and if we didn’t return that means the check didn’t pass, so from then on <code>width</code>’s type is <code>number | string</code> (it can’t be <code>null</code> or <code>undefined</code> anymore). We say that the type was refined from <code>number | string | null | undefined</code> to <code>number | string</code>.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO2-2" id="callout_advanced_types_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>A <code>typeof</code> check queries a value at runtime to see what its type is. TypeScript takes advantage of <code>typeof</code> at compile time too: in the <code>if</code> branch where the check passes, TypeScript knows that <code>width</code> is a <code>number</code>; otherwise (since that branch <code>return</code>s) <code>width</code> must be a <code>string</code>—it’s the only type left.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO2-3" id="callout_advanced_types_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Because calling <code>parseUnit</code> might return <code>null</code>, we check if it did by testing whether its result is truthy.<sup><a data-type="noteref" href="ch06.html#idm46304967201672" id="idm46304967201672-marker">3</a></sup> TypeScript knows that if <code>unit</code> is truthy then it must be of type <code>Unit</code> in the <code>if</code> branch—otherwise, <code>unit</code> must be falsy, meaning it must be of type <code>null</code> (refined from <code>Unit | null</code>).</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO2-4" id="callout_advanced_types_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Finally, we return <code>null</code>. This can only happen if the user passed a <code>string</code> for <code>width</code>, but that string contained a unit that we don’t support.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I’ve spelled out exactly what TypeScript was thinking for each of the type refinements it performed here, but I hope this was already intuitive and obvious for you, the programmer reading that code. TypeScript does a superb job of taking what’s going through your mind as you read and write code, and crystallizing it in the form of typechecking and inference rules.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discriminated union types" data-type="sect3"><div class="sect3" id="discriminated-unions">&#13;
<h3>Discriminated union types</h3>&#13;
&#13;
<p>As we just learned, TypeScript has a deep understanding of how JavaScript works, and is able to follow along as you refine your types, just like you would when you trace through your program in your head.<a data-primary="refinement (types)" data-secondary="discriminated union types" data-type="indexterm" id="idm46304967189144"/><a data-primary="union types" data-secondary="discriminated" data-type="indexterm" id="idm46304967188296"/></p>&#13;
&#13;
<p>For example, say we’re building a custom event system for an application. We start by defining a couple of event types, along with a function to handle events that come in. Imagine that <code>UserTextEvent</code> models a keyboard event (e.g., the user typed something in a text <code>&lt;input /&gt;</code>) and <code>UserMouseEvent</code> models a mouse event (e.g., the user moved their mouse to the coordinates <code>[100, 200]</code>):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">UserTextEvent</code> <code class="o">=</code> <code class="p">{</code><code class="nx">value</code>: <code class="kt">string</code><code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">UserMouseEvent</code> <code class="o">=</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">UserEvent</code> <code class="o">=</code> <code class="nx">UserTextEvent</code> <code class="o">|</code> <code class="nx">UserMouseEvent</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">handle</code><code class="p">(</code><code class="nx">event</code>: <code class="kt">UserEvent</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">event</code><code class="p">.</code><code class="nx">value</code> <code class="o">===</code> <code class="s1">'string'</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">event</code><code class="p">.</code><code class="nx">value</code>  <code class="c1">// string</code>&#13;
    <code class="c1">// ...</code>&#13;
    <code class="k">return</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">event</code><code class="p">.</code><code class="nx">value</code>    <code class="c1">// [number, number]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Inside the <code>if</code> block, TypeScript knows that <code>event.value</code> has to be a <code>string</code> (because of the <code>typeof</code> check), which implies that after the <code>if</code> block <code>event.value</code> has to be a tuple of <code>[number, number]</code> (because of the <code>return</code> in the <code>if</code> block).</p>&#13;
&#13;
<p>What happens if we make this a little more complicated? Let’s add some more information to our event types, and see how TypeScript fares when we refine our types:</p>&#13;
<pre data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">UserTextEvent</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="nx">value</code><code>: </code><code class="kt noBold">string</code><strong><code class="p">,</code><code> </code><code class="nx">target</code><code>: </code><code class="kt">HTMLInputElement</code></strong><code class="p">}</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">UserMouseEvent</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="nx">value</code><code class="o">:</code><code> </code><code class="p">[</code><code class="kt noBold">number</code><code class="p">,</code><code> </code><code class="kt noBold">number</code><code class="p">]</code><strong><code class="p">,</code><code> </code><code class="nx">target</code><code>: </code><code class="kt">HTMLElement</code></strong><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">type</code><code> </code><code class="nx">UserEvent</code><code> </code><code class="o">=</code><code> </code><code class="nx">UserTextEvent</code><code> </code><code class="o">|</code><code> </code><code class="nx">UserMouseEvent</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">handle</code><code class="p">(</code><code class="nx">event</code><code>: </code><code class="kt noBold">UserEvent</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="k">typeof</code><code> </code><code class="nx">event</code><code class="p">.</code><code class="nx">value</code><code> </code><code class="o">===</code><code> </code><code class="s1">'string'</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">event</code><code class="p">.</code><code class="nx">value</code><code>  </code><em><code class="c1">// string</code></em><code class="c1">&#13;
</code><code>    </code><strong><code class="nx">event</code><code class="p">.</code><code class="nx">target</code></strong><code> </code><em><code class="c1">// HTMLInputElement | HTMLElement (!!!)</code></em><code class="c1">&#13;
</code><code>    </code><code class="c1">// ...&#13;
</code><code>    </code><code class="k">return</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">event</code><code class="p">.</code><code class="nx">value</code><code>    </code><em><code class="c1">// [number, number]</code></em><code class="c1">&#13;
</code><code>  </code><strong><code class="nx">event</code><code class="p">.</code><code class="nx">target</code></strong><code>   </code><em><code class="c1">// HTMLInputElement | HTMLElement (!!!)</code></em><code class="c1">&#13;
</code><code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>While the refinement worked for <code>event.value</code>, it didn’t carry over to <code>event.target</code>. Why? When <code>handle</code> takes a parameter of type <code>UserEvent</code>, that doesn’t mean we have to pass a <code>UserTextEvent</code> or <code>UserMouseEvent</code>—in fact, we could pass an argument of type <code>UserMouseEvent | UserTextEvent</code>. And since members of a union might overlap, TypeScript needs a more reliable way to know when we’re in one case of a union type versus another case.</p>&#13;
&#13;
<p>The way to do this is to use a literal type to <em>tag</em> each case of your union type.<a data-primary="tags for union types" data-type="indexterm" id="idm46304967032744"/> A good tag is:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>On the same place in each case of your union type. That means the same object field if it’s a union of object types, or the same index if it’s a union of tuple types. In practice, tagged unions usually use object types.</p>&#13;
</li>&#13;
<li>&#13;
<p>Typed as a literal type (a literal string, number, boolean, etc.). You can mix and match different types of literals, but it’s good practice to stick to a single type; typically, that’s a string literal type.</p>&#13;
</li>&#13;
<li>&#13;
<p>Not generic. Tags should not take any generic type arguments.</p>&#13;
</li>&#13;
<li>&#13;
<p>Mutually exclusive (i.e., unique within the union type).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With that in mind, let’s update our event types again:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">UserTextEvent</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><strong><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'TextEvent'</code><code class="p">,</code></strong><code> </code><code class="nx">value</code><code>: </code><code class="kt">string</code><code class="p">,</code><code> </code><code class="nx">target</code><code>: </code><code class="kt">HTMLInputElement</code><code class="p">}</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">UserMouseEvent</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><strong><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'MouseEvent'</code><code class="p">,</code></strong><code> </code><code class="nx">value</code><code class="o">:</code><code> </code><code class="p">[</code><code class="kt">number</code><code class="p">,</code><code> </code><code class="kt">number</code><code class="p">]</code><code class="p">,</code><code>&#13;
                       </code><code class="nx">target</code><code>: </code><code class="kt">HTMLElement</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">type</code><code> </code><code class="nx">UserEvent</code><code> </code><code class="o">=</code><code> </code><code class="nx">UserTextEvent</code><code> </code><code class="o">|</code><code> </code><code class="nx">UserMouseEvent</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">handle</code><code class="p">(</code><code class="nx">event</code><code>: </code><code class="kt">UserEvent</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><strong><code class="nx">event</code><code class="p">.</code><code class="nx">type</code><code> </code><code class="o">===</code><code> </code><code class="s1">'TextEvent'</code></strong><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">event</code><code class="p">.</code><code class="nx">value</code><code>  </code><em><code class="c1">// string</code></em><code class="c1">&#13;
</code><code>    </code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code> </code><em><code class="c1">// HTMLInputElement</code></em><code class="c1">&#13;
</code><code>    </code><code class="c1">// ...&#13;
</code><code>    </code><code class="k">return</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">event</code><code class="p">.</code><code class="nx">value</code><code>    </code><em><code class="c1">// [number, number]</code></em><code class="c1">&#13;
</code><code>  </code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code>   </code><em><code class="c1">// HTMLElement</code></em><code class="c1">&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Now when we refine <code>event</code> based on the value of its tagged field (<code>event.type</code>), TypeScript knows that in the <code>if</code> branch <code>event</code> has to be a <code>UserTextEvent</code>, and after the <code>if</code> branch it has to be a <code>UserMouseEvent</code>. Since the tag is unique per union type, TypeScript knows that the two are mutually exclusive.</p>&#13;
&#13;
<p>Use tagged unions when writing a function that has to handle the different cases of a union type. For example, they’re invaluable when working with Flux actions, Redux reducers, or React’s <code>useReducer</code>.<a data-primary="types" data-secondary="relationships between" data-startref="ix_typerelref" data-tertiary="refinement" data-type="indexterm" id="idm46304966928088"/><a data-primary="refinement (types)" data-startref="ix_refine" data-type="indexterm" id="idm46304966926536"/><a data-primary="types" data-secondary="relationships between" data-startref="ix_typerel" data-type="indexterm" id="idm46304966925592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Totality" data-type="sect1"><div class="sect1" id="totality">&#13;
<h1>Totality</h1>&#13;
<blockquote>A programmer puts two glasses on her bedside table before going to sleep: a full one, in case she gets thirsty, and an empty one, in case she doesn’t.<a data-primary="totality" data-type="indexterm" id="ix_total"/><a data-primary="types" data-secondary="totality" data-type="indexterm" id="ix_typetotl"/>&#13;
<p data-type="attribution">Anonymous</p>&#13;
</blockquote>&#13;
&#13;
<p>Totality, also called <em>exhaustiveness checking</em>, is what allows the typechecker to make sure you’ve covered all your cases.<a data-primary="exhaustiveness checking" data-seealso="totality" data-type="indexterm" id="idm46304966877848"/> It comes to us from Haskell, OCaml, and other languages that are based around pattern matching.</p>&#13;
&#13;
<p>TypeScript will check for totality in a variety of cases, and give you helpful warnings when you’ve missed a case. This is an incredibly helpful feature for preventing real bugs.<a data-primary="return statements, totality checking" data-type="indexterm" id="idm46304966876184"/> For example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Weekday</code> <code class="o">=</code> <code class="s1">'Mon'</code> <code class="o">|</code> <code class="s1">'Tue'</code><code class="o">|</code> <code class="s1">'Wed'</code> <code class="o">|</code> <code class="s1">'Thu'</code> <code class="o">|</code> <code class="s1">'Fri'</code>&#13;
<code class="nx">type</code> <code class="nx">Day</code> <code class="o">=</code> <code class="nx">Weekday</code> <code class="o">|</code> <code class="s1">'Sat'</code> <code class="o">|</code> <code class="s1">'Sun'</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">getNextDay</code><code class="p">(</code><code class="nx">w</code>: <code class="kt">Weekday</code><code class="p">)</code><code class="o">:</code> <code class="nx">Day</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">w</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s1">'Mon'</code><code class="o">:</code> <code class="k">return</code> <code class="s1">'Tue'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We clearly missed a few days (it’s been a long week). <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2366" data-type="indexterm" id="idm46304966850280"/>TypeScript comes to the rescue:</p>&#13;
&#13;
<pre data-type="programlisting">Error TS2366: Function lacks ending return statement and&#13;
return type does not include 'undefined'.</pre>&#13;
<div data-type="tip"><h1>TSC Flag: noImplicitReturns</h1>&#13;
<p>To ask TypeScript to check that all of your functions’ code paths return a value (and throw the preceding warning if you missed a spot), enable the <code>noImplicitReturns</code> flag in your <em>tsconfig.json</em>.<a data-primary="noImplicitReturns TSC flag" data-type="indexterm" id="idm46304966828248"/><a data-primary="TSC compiler" data-secondary="noImplicitReturns flag" data-type="indexterm" id="idm46304966827544"/> Whether you enable this flag or not is up to you: some people prefer a code style with fewer explicit <code>return</code>s, and some people are fine with a few extra <code>return</code>s in the name of better type safety and more bugs caught by the typechecker.</p>&#13;
</div>&#13;
&#13;
<p>This error message is telling us that either we missed some cases and should cover them with a catchall <code>return</code> statement at the end that returns something like <code>'Sat'</code> (that’d be nice, huh), or we should adjust <code>getNextDay</code>’s return type to <code>Day |</code> <code><span class="keep-together">undefined</span></code>. After we add a <code>case</code> for each <code>Day</code>, the error goes away (try it!). Because we annotated <code>getNextDay</code>’s return type, and not all branches are guaranteed to return a value of that type, TypeScript warns us.</p>&#13;
&#13;
<p>The implementation details in this example aren’t important: no matter what kind of control structure you use—<code>switch</code>, <code>if</code>, <code>throw</code>, and so on—TypeScript will watch your back to make sure you have every case covered.</p>&#13;
&#13;
<p>Here’s another example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">isBig</code><code class="p">(</code><code class="nx">n</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&gt;=</code> <code class="mi">100</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Maybe a client’s continued voicemails about that missed deadline have you jittery, and you forgot to handle numbers under <code>100</code> in your business-critical <code>isBig</code> function.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS7030" data-type="indexterm" id="idm46304966807992"/> Again, never fear—TypeScript is watching out for you:</p>&#13;
&#13;
<pre data-type="programlisting">Error TS7030: Not all code paths return a value.</pre>&#13;
&#13;
<p>Or maybe the weekend gave you a chance to clear your mind, and you realized that you should rewrite that <code>getNextDay</code> example from earlier to be more efficient. Instead of using a <code>switch</code>, why not a constant-time lookup in an object?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">nextDay</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Mon</code><code class="o">:</code> <code class="s1">'Tue'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">nextDay</code><code class="p">.</code><code class="nx">Mon</code> <code class="c1">// 'Tue'</code></pre>&#13;
&#13;
<p>With your Bichon Frise yapping away in the other room (something about the neighbor’s dog?), you absentmindedly forgot to fill in the other days in your new <code>nextDay</code> object before you committed your code and moved on to other things.</p>&#13;
&#13;
<p>While TypeScript will give you an error the next time you try to access <code>nextDay.Tue</code>, you could have been more proactive about it when declaring <code>nextDay</code> in the first place. There are two ways to do that, as you’ll learn in <a data-type="xref" href="#record-type">“The Record Type”</a> and  <a data-type="xref" href="#mapped-types">“Mapped Types”</a>; but before we get there, let’s take a slight detour into type operators for object types.<a data-primary="totality" data-startref="ix_total" data-type="indexterm" id="idm46304966750344"/><a data-primary="types" data-secondary="totality" data-startref="ix_typetotl" data-type="indexterm" id="idm46304966749400"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Object Types" data-type="sect1"><div class="sect1" id="idm46304966923784">&#13;
<h1>Advanced Object Types</h1>&#13;
&#13;
<p>Objects are central to JavaScript, and TypeScript gives you a whole bunch of ways to express and manipulate them safely.<a data-primary="objects" data-type="indexterm" id="ix_objsadv"/><a data-primary="types" data-secondary="advanced object types" data-type="indexterm" id="ix_typeadvobj"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Operators for Object Types" data-type="sect2"><div class="sect2" id="idm46304966720184">&#13;
<h2>Type Operators for Object Types</h2>&#13;
&#13;
<p>Remember union (<code>|</code>) and intersection (<code>&amp;</code>), the two type operators I introduced in <a data-type="xref" href="ch03.html#union-intersection">“Union and intersection types”</a>?<a data-primary="type operators" data-secondary="for object types" data-type="indexterm" id="ix_typeops"/><a data-primary="objects" data-secondary="type operators for" data-type="indexterm" id="ix_objsadvtop"/> It turns out they’re not the only type operators TypeScript gives you! Let’s run through a few more type operators that come in handy for working with shapes.<a data-primary="types" data-secondary="advanced object types" data-tertiary="type operators" data-type="indexterm" id="ix_typeadvobjops"/><a data-primary="| (pipe symbol), for union types" data-type="indexterm" id="idm46304966712712"/><a data-primary="&amp; (ampersand), for intersection types" data-type="indexterm" id="idm46304966712072"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The keying-in operator" data-type="sect3"><div class="sect3" id="keying-in">&#13;
<h3>The keying-in operator</h3>&#13;
&#13;
<p>Say you have a complex nested type to model the GraphQL API response you got back from your <a data-primary="objects" data-secondary="type operators for" data-tertiary="keying-in operator" data-type="indexterm" id="idm46304966709352"/><a data-primary="type operators" data-secondary="for object types" data-tertiary="keying-in operator" data-type="indexterm" id="idm46304966708104"/><a data-primary="keying-in operator" data-type="indexterm" id="idm46304966683992"/>social media API of choice:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">APIResponse</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">user</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">userId</code>: <code class="kt">string</code>&#13;
    <code class="nx">friendList</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">count</code>: <code class="kt">number</code>&#13;
      <code class="nx">friends</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">firstName</code>: <code class="kt">string</code>&#13;
        <code class="nx">lastName</code>: <code class="kt">string</code>&#13;
      <code class="p">}[]</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You might fetch that response from the API, then render it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">getAPIResponse</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">APIResponse</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">renderFriendList</code><code class="p">(</code><code class="nx">friendList</code>: <code class="kt">unknown</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getAPIResponse</code><code class="p">()</code>&#13;
<code class="nx">renderFriendList</code><code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">friendList</code><code class="p">)</code></pre>&#13;
&#13;
<p>What should the type of <code>friendList</code> be? (It’s stubbed out as <code>unknown</code> for now.) You could type it out and reimplement your top-level <code>APIResponse</code> type in terms of it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">FriendList</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">count</code>: <code class="kt">number</code>&#13;
  <code class="nx">friends</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">firstName</code>: <code class="kt">string</code>&#13;
    <code class="nx">lastName</code>: <code class="kt">string</code>&#13;
  <code class="p">}[]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">APIResponse</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">user</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">userId</code>: <code class="kt">string</code>&#13;
    <code class="nx">friendList</code>: <code class="kt">FriendList</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">renderFriendList</code><code class="p">(</code><code class="nx">friendList</code>: <code class="kt">FriendList</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But then you’d have to come up with names for each of your top-level types, which you don’t always want (e.g., if you used a build tool to generate TypeScript types from your GraphQL schema). Instead, you can <em>key in</em> to your type:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">APIResponse</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">user</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">userId</code><code>: </code><code class="kt">string</code><code>&#13;
    </code><code class="nx">friendList</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
      </code><code class="nx">count</code><code>: </code><code class="kt">number</code><code>&#13;
      </code><code class="nx">friends</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
        </code><code class="nx">firstName</code><code>: </code><code class="kt">string</code><code>&#13;
        </code><code class="nx">lastName</code><code>: </code><code class="kt">string</code><code>&#13;
      </code><code class="p">}</code><code class="p">[</code><code class="p">]</code><code>&#13;
    </code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><strong><code class="nx">type</code><code> </code><code class="nx">FriendList</code><code> </code><code class="o">=</code><code> </code><code class="nx">APIResponse</code><code class="p">[</code><code class="s1">'user'</code><code class="p">]</code><code class="p">[</code><code class="s1">'friendList'</code><code class="p">]</code></strong><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">renderFriendList</code><code class="p">(</code><code class="nx">friendList</code><code>: </code><code class="kt">FriendList</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>You can key in to any shape (object, class constructor, or class instance), and any array. For example, to get the type of an individual friend:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Friend</code> <code class="o">=</code> <code class="nx">FriendList</code><code class="p">[</code><code class="s1">'friends'</code><code class="p">][</code><code class="kt">number</code><code class="p">]</code></pre>&#13;
&#13;
<p><code>number</code> is a way to key in to an array type; for tuples, use <code>0</code>, <code>1</code>, or another number literal type to represent the index you want to key in to.</p>&#13;
&#13;
<p>The syntax for keying in is intentionally similar to how you look up fields in regular JavaScript objects—just as you might look up a value in an object, so you can look up a type in a shape. Note that you have to use bracket notation, not dot notation, to look up property types when keying in.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The keyof operator" data-type="sect3"><div class="sect3" id="keyof">&#13;
<h3>The keyof operator</h3>&#13;
&#13;
<p>Use <code>keyof</code> to get all of an object’s keys as a union<a data-primary="keyof operator" data-type="indexterm" id="idm46304966419240"/> of string literal types.<a data-primary="objects" data-secondary="type operators for" data-tertiary="keyof operator" data-type="indexterm" id="idm46304966418408"/><a data-primary="type operators" data-secondary="for object types" data-tertiary="keyof" data-type="indexterm" id="idm46304966417192"/> Using the previous <code>APIResponse</code> example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ResponseKeys</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">APIResponse</code> <code class="c1">// 'user'</code>&#13;
<code class="nx">type</code> <code class="nx">UserKeys</code> <code class="o">=</code> <code class="nx">keyof</code> <code class="nx">APIResponse</code><code class="p">[</code><code class="s1">'user'</code><code class="p">]</code> <code class="c1">// 'userId' | 'friendList'</code>&#13;
<code class="nx">type</code> <code class="nx">FriendListKeys</code> <code class="o">=</code>&#13;
  <code class="nx">keyof</code> <code class="nx">APIResponse</code><code class="p">[</code><code class="s1">'user'</code><code class="p">][</code><code class="s1">'friendList'</code><code class="p">]</code> <code class="c1">// 'count' | 'friends'</code></pre>&#13;
&#13;
<p>Combining the keying-in and <code>keyof</code> operators, you can implement a typesafe getter function that looks up the value at the given key in an object:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">get</code><code class="o">&lt;</code><code> </code><a class="co" href="#callout_advanced_types_CO3-1" id="co_advanced_types_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">O</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">object</code><code class="p">,</code><code>&#13;
  </code><code class="nx">K</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">O</code><code> </code><a class="co" href="#callout_advanced_types_CO3-2" id="co_advanced_types_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="o">&gt;</code><code class="p">(</code><code>&#13;
  </code><code class="nx">o</code><code>: </code><code class="kt">O</code><code class="p">,</code><code>&#13;
  </code><code class="nx">k</code><code>: </code><code class="kt">K</code><code>&#13;
</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">O</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO3-3" id="co_advanced_types_CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">o</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO3-1" id="callout_advanced_types_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>get</code> is a function that takes an object <code>o</code> and a key <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO3-2" id="callout_advanced_types_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>keyof O</code> is a union of string literal types,  representing all of <code>o</code>’s keys. The generic type <code>K</code> extends—and is a subtype of—that union. For example, if <code>o</code> has the type <code>{a: number, b: string, c: boolean}</code>, then <code>keyof o</code> is the type <code>'a' | 'b' | 'c'</code>, and <code>K</code> (which extends <code>keyof o</code>) could be the type <code>'a'</code>, <code>'b'</code>, <code>'a' | 'c'</code>, or any other subtype of <code>keyof o</code>.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO3-3" id="callout_advanced_types_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>O[K]</code> is the type you get when you look up <code>K</code> in <code>O</code>. Continuing the example from <a class="co" href="#co_advanced_types_CO3-2"><img alt="2" src="assets/2.png"/></a>, if <code>K</code> is <code>'a'</code>, then we know at compile time that <code>get</code> returns a <code>number</code>. Or, if <code>K</code> is <code>'b' | 'c'</code>, then we know <code>get</code> returns <code>string | boolean</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>What’s cool about these type operators is how precisely and safely they let you describe shape types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ActivityLog</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">lastEvent</code>: <code class="kt">Date</code>&#13;
  <code class="nx">events</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>: <code class="kt">string</code>&#13;
    <code class="nx">timestamp</code>: <code class="kt">Date</code>&#13;
    <code class="nx">type</code><code class="o">:</code> <code class="s1">'Read'</code> <code class="o">|</code> <code class="s1">'Write'</code>&#13;
  <code class="p">}[]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">activityLog</code>: <code class="kt">ActivityLog</code> <code class="o">=</code> <code class="c1">// ...</code>&#13;
<code class="kd">let</code> <code class="nx">lastEvent</code> <code class="o">=</code> <code class="nx">get</code><code class="p">(</code><code class="nx">activityLog</code><code class="p">,</code> <code class="s1">'lastEvent'</code><code class="p">)</code> <code class="c1">// Date</code></pre>&#13;
&#13;
<p>TypeScript goes to work for you, verifying <em>at compile time</em> that the type of <code>lastEvent</code> is <code>Date</code>. Of course, you could extend this in order to key in to an object more deeply too. Let’s overload <code>get</code> to accept up to three keys:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Get</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO4-1" id="co_advanced_types_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="o">&lt;</code><code>&#13;
    </code><code class="nx">O</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">object</code><code class="p">,</code><code>&#13;
    </code><code class="nx">K1</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">O</code><code>&#13;
  </code><code class="o">&gt;</code><code class="p">(</code><code class="nx">o</code><code>: </code><code class="kt">O</code><code class="p">,</code><code> </code><code class="nx">k1</code><code>: </code><code class="kt">K1</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">O</code><code class="p">[</code><code class="nx">K1</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO4-2" id="co_advanced_types_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="o">&lt;</code><code>&#13;
    </code><code class="nx">O</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">object</code><code class="p">,</code><code>&#13;
    </code><code class="nx">K1</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">O</code><code class="p">,</code><code>&#13;
    </code><code class="nx">K2</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">O</code><code class="p">[</code><code class="nx">K1</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO4-3" id="co_advanced_types_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="o">&gt;</code><code class="p">(</code><code class="nx">o</code><code>: </code><code class="kt">O</code><code class="p">,</code><code> </code><code class="nx">k1</code><code>: </code><code class="kt">K1</code><code class="p">,</code><code> </code><code class="nx">k2</code><code>: </code><code class="kt">K2</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">O</code><code class="p">[</code><code class="nx">K1</code><code class="p">]</code><code class="p">[</code><code class="nx">K2</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO4-4" id="co_advanced_types_CO4-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="o">&lt;</code><code>&#13;
    </code><code class="nx">O</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">object</code><code class="p">,</code><code>&#13;
    </code><code class="nx">K1</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">O</code><code class="p">,</code><code>&#13;
    </code><code class="nx">K2</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">O</code><code class="p">[</code><code class="nx">K1</code><code class="p">]</code><code class="p">,</code><code>&#13;
    </code><code class="nx">K3</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">O</code><code class="p">[</code><code class="nx">K1</code><code class="p">]</code><code class="p">[</code><code class="nx">K2</code><code class="p">]</code><code>&#13;
  </code><code class="o">&gt;</code><code class="p">(</code><code class="nx">o</code><code>: </code><code class="kt">O</code><code class="p">,</code><code> </code><code class="nx">k1</code><code>: </code><code class="kt">K1</code><code class="p">,</code><code> </code><code class="nx">k2</code><code>: </code><code class="kt">K2</code><code class="p">,</code><code> </code><code class="nx">k3</code><code>: </code><code class="kt">K3</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">O</code><code class="p">[</code><code class="nx">K1</code><code class="p">]</code><code class="p">[</code><code class="nx">K2</code><code class="p">]</code><code class="p">[</code><code class="nx">K3</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO4-5" id="co_advanced_types_CO4-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">get</code><code>: </code><code class="kt">Get</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="nx">object</code><code>: </code><code class="kt">any</code><code class="p">,</code><code> </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">keys</code><code>: </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">result</code><code> </code><code class="o">=</code><code> </code><code class="nx">object</code><code>&#13;
  </code><code class="nx">keys</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">k</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">result</code><code> </code><code class="o">=</code><code> </code><code class="nx">result</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code><code class="p">)</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">result</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">get</code><code class="p">(</code><code class="nx">activityLog</code><code class="p">,</code><code> </code><code class="s1">'events'</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">,</code><code> </code><code class="s1">'type'</code><code class="p">)</code><code> </code><code class="c1">// 'Read' | 'Write'&#13;
</code><code>&#13;
&#13;
</code><code class="nx">get</code><code class="p">(</code><code class="nx">activityLog</code><code class="p">,</code><code> </code><code class="s1">'bad'</code><code class="p">)</code><code> </code><code class="c1">// Error TS2345: Argument of type '"bad"'&#13;
</code><code>                        </code><code class="c1">// is not assignable to parameter of type&#13;
</code><code>                        </code><code class="c1">// '"lastEvent" | "events"'.</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO4-1" id="callout_advanced_types_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We declare an overloaded function signature for <code>get</code> with three cases for when we call <code>get</code> with one key, two keys, and three keys.<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304966030392"/></p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO4-2" id="callout_advanced_types_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This one-key case is the same as the last example: <code>O</code> is a subtype of <code>object</code>, <code>K1</code> is a subtype of that object’s keys, and the return type is whatever specific type you get when you key in to <code>O</code> with <code>K1</code>.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO4-3" id="callout_advanced_types_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The two-key case is like the one-key case, but we declare one more generic type, <code>K2</code>, to model the possible keys on the nested object that results from keying into <code>O</code> with <code>K1</code>.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO4-4" id="callout_advanced_types_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>We build on <a class="co" href="#co_advanced_types_CO4-2"><img alt="2" src="assets/2.png"/></a> by keying in twice—we first get the type of <code>O[K1]</code>, then get the type of <code>[K2]</code> on the result.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO4-5" id="callout_advanced_types_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>For this example we handle up to three nested keys; if you’re writing a real-world library, you’ll probably want to handle a few more cases than that.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Cool, huh? If you have a minute, show this example to your Java friends, and be sure to gloat as you walk them through it.</p>&#13;
<div data-type="tip"><h1>TSC Flag: keyofStringsOnly</h1>&#13;
<p>In JavaScript, objects and arrays can have both string and symbol keys. And by convention, we usually use number keys for arrays, which are coerced to strings at runtime.<a data-primary="keyofStringsOnly TSC flag" data-type="indexterm" id="idm46304965844040"/><a data-primary="TSC compiler" data-secondary="keyofStringsOnly flag" data-type="indexterm" id="idm46304965843320"/></p>&#13;
&#13;
<p>Because of this, <code>keyof</code> in TypeScript returns a value of type <code>number | string | symbol</code> by default (though if you call it on a more specific shape, TypeScript can infer a more specific subtype of that union).</p>&#13;
&#13;
<p>This behavior is correct, but can make working with <code>keyof</code> wordy, as you may have to prove to TypeScript that the particular key you’re manipulating is a <code>string</code>, and not a <code>number</code> or a <code>symbol</code>.</p>&#13;
&#13;
<p>To opt into TypeScript’s legacy behavior—where keys must be strings—enable the <code>keyofStringsOnly</code> <em>tsconfig.json</em> flag.<a data-primary="types" data-secondary="advanced object types" data-startref="ix_typeadvobjops" data-tertiary="type operators" data-type="indexterm" id="idm46304965837400"/><a data-primary="objects" data-secondary="type operators for" data-startref="ix_objsadvtop" data-type="indexterm" id="idm46304965835848"/><a data-primary="type operators" data-secondary="for object types" data-startref="ix_typeops" data-type="indexterm" id="idm46304965834632"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Record Type" data-type="sect2"><div class="sect2" id="record-type">&#13;
<h2>The Record Type</h2>&#13;
&#13;
<p>TypeScript’s built-in <code>Record</code> type is a way to describe an object as a map from something to something.<a data-primary="Record type" data-type="indexterm" id="idm46304965873992"/><a data-primary="types" data-secondary="advanced object types" data-tertiary="Record" data-type="indexterm" id="idm46304965873288"/><a data-primary="objects" data-secondary="Record type" data-type="indexterm" id="idm46304965872072"/></p>&#13;
&#13;
<p>Recall from the <code>Weekday</code> example in <a data-type="xref" href="#totality">“Totality”</a> that there are two ways to enforce that an object defines a specific set of keys. <code>Record</code> types are the first.</p>&#13;
&#13;
<p>Let’s use <code>Record</code> to build a map from each day of the week to the next day of the week. With <code>Record</code>, you can put some constraints on the keys and values in <code>nextDay</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Weekday</code> <code class="o">=</code> <code class="s1">'Mon'</code> <code class="o">|</code> <code class="s1">'Tue'</code><code class="o">|</code> <code class="s1">'Wed'</code> <code class="o">|</code> <code class="s1">'Thu'</code> <code class="o">|</code> <code class="s1">'Fri'</code>&#13;
<code class="nx">type</code> <code class="nx">Day</code> <code class="o">=</code> <code class="nx">Weekday</code> <code class="o">|</code> <code class="s1">'Sat'</code> <code class="o">|</code> <code class="s1">'Sun'</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">nextDay</code>: <code class="kt">Record</code><code class="o">&lt;</code><code class="nx">Weekday</code><code class="p">,</code> <code class="nx">Day</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Mon</code><code class="o">:</code> <code class="s1">'Tue'</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, you get a nice, helpful error <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2739" data-type="indexterm" id="idm46304965866392"/>message right away:</p>&#13;
&#13;
<pre data-type="programlisting">Error TS2739: Type '{Mon: "Tue"}' is missing the following properties&#13;
from type 'Record&lt;Weekday, Day&gt;': Tue, Wed, Thu, Fri.</pre>&#13;
&#13;
<p>Adding the missing <code>Weekday</code>s to your object, of course, makes the error go away.</p>&#13;
&#13;
<p><code>Record</code> gives you one extra degree of freedom compared to regular object index signatures: with a regular<a data-primary="index signatures" data-secondary="Record object" data-type="indexterm" id="idm46304965772024"/> index signature you can constrain the types of an object’s values, but the key can only be a regular <code>string</code>, <code>number</code>, or <code>symbol</code>; with <code>Record</code>, you can also constrain the types of an object’s keys to subtypes of <code>string</code> and <code>number</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mapped Types" data-type="sect2"><div class="sect2" id="mapped-types">&#13;
<h2>Mapped Types</h2>&#13;
&#13;
<p>TypeScript gives us a second, more powerful way to declare a safer <code>nextDay</code> type: mapped types.<a data-primary="types" data-secondary="advanced object types" data-tertiary="mapped types" data-type="indexterm" id="ix_typeadvobjmap"/><a data-primary="objects" data-secondary="mapped types" data-type="indexterm" id="ix_objsadvmap"/><a data-primary="mapped types" data-type="indexterm" id="ix_mapp"/> Let’s use mapped types to say that <code>nextDay</code> is an object with a key for each <code>Weekday</code>, whose value is a <code>Day</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">nextDay</code><code class="o">:</code> <code class="p">{[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Weekday</code><code class="p">]</code><code class="o">:</code> <code class="nx">Day</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Mon</code><code class="o">:</code> <code class="s1">'Tue'</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is another way to get a helpful hint for how to fix what you missed:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nb">Error</code> <code class="nx">TS2739</code>: <code class="kt">Type</code> <code class="s1">'{Mon: "Tue"}'</code> <code class="nx">is</code> <code class="nx">missing</code> <code class="nx">the</code> <code class="nx">following</code> <code class="nx">properties</code>&#13;
<code class="nx">from</code> <code class="nx">type</code> <code class="s1">'{Mon: Weekday; Tue: Weekday; Wed: Weekday; Thu: Weekday;</code>&#13;
<code class="s1">Fri: Weekday}'</code><code class="o">:</code> <code class="nx">Tue</code><code class="p">,</code> <code class="nx">Wed</code><code class="p">,</code> <code class="nx">Thu</code><code class="p">,</code> <code class="nx">Fri</code><code class="p">.</code></pre>&#13;
&#13;
<p>Mapped types are a language feature unique to TypeScript. Like literal types, they’re a utility feature that just makes sense for the challenge that is statically typing JavaScript.</p>&#13;
&#13;
<p>As you saw, mapped types have their own special syntax. And like index signatures, you can have at most one mapped type per object:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">MyMappedType</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">Key</code> <code class="k">in</code> <code class="nx">UnionType</code><code class="p">]</code><code class="o">:</code> <code class="nx">ValueType</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As the name implies, it’s a way to map over an object’s key and value types. In fact, TypeScript uses mapped types to implement its built-in <code>Record</code> type we used earlier:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kr">extends</code> <code class="nx">keyof</code> <code class="nx">any</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Mapped types give you more power than a mere <code>Record</code> because in addition to letting you give types to an object’s keys and values, when you combine them with keyed-in types, they let you put constraints on which value type corresponds to which key name.</p>&#13;
&#13;
<p>Let’s quickly run through some of the things you can do with mapped types.</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Account</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">id</code><code>: </code><code class="kt">number</code><code>&#13;
  </code><code class="nx">isEmployee</code><code>: </code><code class="kt">boolean</code><code>&#13;
  </code><code class="nx">notes</code><code>: </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="c1">// Make all fields optional&#13;
</code><code class="nx">type</code><code> </code><code class="nx">OptionalAccount</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">[</code><code class="nx">K</code><code> </code><code class="k">in</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">Account</code><code class="p">]</code><code class="o">?</code><code class="o">:</code><code> </code><code class="nx">Account</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO5-1" id="co_advanced_types_CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="c1">// Make all fields nullable&#13;
</code><code class="nx">type</code><code> </code><code class="nx">NullableAccount</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">[</code><code class="nx">K</code><code> </code><code class="k">in</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">Account</code><code class="p">]</code><code class="o">:</code><code> </code><code class="nx">Account</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code><code> </code><a class="co" href="#callout_advanced_types_CO5-2" id="co_advanced_types_CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="c1">// Make all fields read-only&#13;
</code><code class="nx">type</code><code> </code><code class="nx">ReadonlyAccount</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">readonly</code><code> </code><code class="p">[</code><code class="nx">K</code><code> </code><code class="k">in</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">Account</code><code class="p">]</code><code class="o">:</code><code> </code><code class="nx">Account</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO5-3" id="co_advanced_types_CO5-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="c1">// Make all fields writable again (equivalent to Account)&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Account2</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="o">-</code><code class="nx">readonly</code><code> </code><code class="p">[</code><code class="nx">K</code><code> </code><code class="k">in</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">ReadonlyAccount</code><code class="p">]</code><code class="o">:</code><code> </code><code class="nx">Account</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO5-4" id="co_advanced_types_CO5-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="c1">// Make all fields required again (equivalent to Account)&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Account3</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">[</code><code class="nx">K</code><code> </code><code class="k">in</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">OptionalAccount</code><code class="p">]</code><code class="o">-</code><code class="o">?</code><code class="o">:</code><code> </code><code class="nx">Account</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO5-5" id="co_advanced_types_CO5-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO5-1" id="callout_advanced_types_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We create a new object type <code>OptionalAccount</code> by mapping over <code>Account</code>, marking each field as optional along the way.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO5-2" id="callout_advanced_types_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We create a new object type <code>NullableAccount</code> by mapping over <code>Account</code>, adding <code>null</code> as a possible value for each field along the way.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO5-3" id="callout_advanced_types_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>We create a new object type <code>ReadonlyAccount</code> by taking <code>Account</code> and making each of its fields read-only (that is, readable but not writable).</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO5-4" id="callout_advanced_types_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>We can mark fields as optional (<code>?</code>) or <code>readonly</code>, and we can also unmark them. With the minus (<code>–</code>) operator—a special type operator only available with mapped types—we can undo <code>?</code> and <code>readonly</code>, making fields required and writable again, respectively. Here we create a new object type <code>Account2</code>, equivalent to our <code>Account</code> type, by mapping over <code>ReadonlyAccount</code> and removing the <code>readonly</code> modifier with the minus (<code>–</code>) operator.<a data-primary="type operators" data-secondary="– (minus) and + (plus)" data-type="indexterm" id="idm46304965364024"/></p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO5-5" id="callout_advanced_types_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>We create a new object type <code>Account3</code>, equivalent to our original <code>Account</code> type, by mapping over <code>OptionalAccount</code> and removing the optional (<code>?</code>) operator with the minus (<code>–</code>) operator.<a data-primary="+ (plus) type operator" data-type="indexterm" id="idm46304965359064"/><a data-primary="– (minus) type operator" data-type="indexterm" id="idm46304965358456"/></p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Minus (<code>–</code>) has a corresponding plus (<code>+</code>) type operator. You will probably never use this operator directly, because it’s implied: within a mapped type, <code>readonly</code> is equivalent to <code>+readonly</code>, and <code>?</code> is equivalent to <code>+?</code>. <code>+</code> is just there for completeness.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Built-in mapped types" data-type="sect3"><div class="sect3" id="idm46304965354168">&#13;
<h3>Built-in mapped types</h3>&#13;
&#13;
<p>The mapped types we derived in the last section are so useful<a data-primary="mapped types" data-secondary="built-in" data-type="indexterm" id="idm46304965353032"/> that TypeScript ships with many of them built in:</p>&#13;
<dl>&#13;
<dt><code>Record&lt;Keys, Values&gt;</code></dt>&#13;
<dd>&#13;
<p>An object with keys of type <code>Keys</code> and values of type <code>Values</code></p>&#13;
</dd>&#13;
<dt><code>Partial&lt;Object&gt;</code></dt>&#13;
<dd>&#13;
<p>Marks every field in <code>Object</code> as optional</p>&#13;
</dd>&#13;
<dt><code>Required&lt;Object&gt;</code></dt>&#13;
<dd>&#13;
<p>Marks every field in <code>Object</code> as nonoptional</p>&#13;
</dd>&#13;
<dt><code>Readonly&lt;Object&gt;</code></dt>&#13;
<dd>&#13;
<p>Marks every field in <code>Object</code> as read-only</p>&#13;
</dd>&#13;
<dt><code>Pick&lt;Object, Keys&gt;</code></dt>&#13;
<dd>&#13;
<p>Returns a subtype of <code>Object</code>, with just the given <code>Keys</code></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Companion Object Pattern" data-type="sect2"><div class="sect2" id="companion-objects">&#13;
<h2>Companion Object Pattern</h2>&#13;
&#13;
<p>The companion object pattern comes <a data-primary="objects" data-secondary="mapped types" data-startref="ix_objsadvmap" data-type="indexterm" id="idm46304965340552"/><a data-primary="types" data-secondary="advanced object types" data-startref="ix_typeadvobjmap" data-tertiary="mapped types" data-type="indexterm" id="idm46304965339464"/><a data-primary="mapped types" data-startref="ix_mapp" data-type="indexterm" id="idm46304965338136"/>to us from <a href="http://bit.ly/2I9Nqg2">Scala</a>, and is a way to pair together objects and classes that share the same name.<a data-primary="objects" data-secondary="companion object pattern" data-type="indexterm" id="idm46304965336536"/><a data-primary="types" data-secondary="advanced object types" data-tertiary="companion object pattern" data-type="indexterm" id="idm46304965335688"/><a data-primary="companion object pattern" data-type="indexterm" id="idm46304965334600"/> In TypeScript, there’s a similar pattern that’s similarly useful—we’ll also call it the companion object pattern—that we can use to pair together a type and an object.</p>&#13;
&#13;
<p>It looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Currency</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">unit</code><code class="o">:</code> <code class="s1">'EUR'</code> <code class="o">|</code> <code class="s1">'GBP'</code> <code class="o">|</code> <code class="s1">'JPY'</code> <code class="o">|</code> <code class="s1">'USD'</code>&#13;
  <code class="nx">value</code>: <code class="kt">number</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">Currency</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">DEFAULT</code><code class="o">:</code> <code class="s1">'USD'</code><code class="p">,</code>&#13;
  <code class="nx">from</code><code class="p">(</code><code class="nx">value</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">unit</code> <code class="o">=</code> <code class="nx">Currency</code><code class="p">.</code><code class="nx">DEFAULT</code><code class="p">)</code><code class="o">:</code> <code class="nx">Currency</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code><code class="nx">unit</code><code class="p">,</code> <code class="nx">value</code><code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Remember that in TypeScript, types and values live in separate namespaces; you’ll read a little more about this in <a data-type="xref" href="ch10.html#namespace-merging">“Declaration Merging”</a>. That means in the same scope, you can have the same name (in this example, <code>Currency</code>) bound to both a type and a value. With the companion object pattern, we exploit this separate namespacing to declare a name twice: first as a type, then  as a value.</p>&#13;
&#13;
<p>This pattern has a few nice properties. It lets you group type and value information that’s semantically part of a single name (like <code>Currency</code>) together. It also lets consumers import both at once:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code><code> </code><code class="p">{</code><code class="nx">Currency</code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'./Currency'</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">amountDue</code><code>: </code><code class="kt">Currency</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO6-1" id="co_advanced_types_CO6-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">unit</code><code class="o">:</code><code> </code><code class="s1">'JPY'</code><code class="p">,</code><code>&#13;
  </code><code class="nx">value</code><code>: </code><code class="kt">83733.10</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">otherAmountDue</code><code> </code><code class="o">=</code><code> </code><code class="nx">Currency</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="mi">330</code><code class="p">,</code><code> </code><code class="s1">'EUR'</code><code class="p">)</code><code> </code><a class="co" href="#callout_advanced_types_CO6-2" id="co_advanced_types_CO6-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO6-1" id="callout_advanced_types_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Using <code>Currency</code> as a type</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO6-2" id="callout_advanced_types_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Using <code>Currency</code> as a value</p></dd>&#13;
</dl>&#13;
&#13;
<p>Use the companion object pattern when a type and an object are semantically related, with the object providing utility methods that operate on the type.<a data-primary="types" data-secondary="advanced object types" data-startref="ix_typeadvobj" data-type="indexterm" id="idm46304965202088"/><a data-primary="objects" data-startref="ix_objsadv" data-type="indexterm" id="idm46304965200840"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Function Types" data-type="sect1"><div class="sect1" id="idm46304965342120">&#13;
<h1>Advanced Function Types</h1>&#13;
&#13;
<p>Let’s take a look at a few more advanced techniques that are often used with function types.<a data-primary="types" data-secondary="function" data-type="indexterm" id="ix_typeadvfun"/><a data-primary="functions" data-type="indexterm" id="ix_funcs"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Improving Type Inference for Tuples" data-type="sect2"><div class="sect2" id="improving-type-inference-for-tuples">&#13;
<h2>Improving Type Inference for Tuples</h2>&#13;
&#13;
<p>When you declare a tuple in TypeScript, TypeScript will be lenient about inferring that tuple’s type. <a data-primary="tuples" data-secondary="improving type inference for" data-type="indexterm" id="idm46304965169064"/><a data-primary="types" data-secondary="function" data-tertiary="improving type inference for tuples" data-type="indexterm" id="idm46304965168216"/><a data-primary="functions" data-secondary="improving type inference for tuples" data-type="indexterm" id="idm46304965167064"/><a data-primary="type inference" data-secondary="improving for tuples" data-type="indexterm" id="idm46304965166152"/>It will infer the most general possible type based on what you gave it, ignoring the length of your tuple and which position holds which type:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="kc">true</code><code class="p">]</code> <code class="c1">// (number | boolean)[]</code></pre>&#13;
&#13;
<p>But sometimes you want inference that’s stricter, that would treat <code>a</code> as a fixed-length tuple and not as an array. You could, of course, use a type assertion to cast your tuple to a tuple type (more on this in <a data-type="xref" href="#type-assertions">“Type Assertions”</a>). Or, you could use an <code>as const</code> assertion (<a data-type="xref" href="#const-types">“The const type”</a>) <a data-primary="rest parameters" data-secondary="type inference for" data-type="indexterm" id="idm46304965157160"/>to infer the tuple’s type as narrowly as possible, marking it as read-only.</p>&#13;
&#13;
<p>What if you want to type your tuple as a tuple, but avoid a type assertion, and avoid the narrow inference and read-only modifier that <code>as const</code> gives you? To do that, you can take advantage of the way TypeScript infers types for rest parameters (jump back to <a data-type="xref" href="ch04.html#modelling-arity">“Using bounded polymorphism to model arity”</a> for more about that):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">tuple</code><code class="o">&lt;</code><code> </code><a class="co" href="#callout_advanced_types_CO7-1" id="co_advanced_types_CO7-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">T</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">unknown</code><code class="p">[</code><code class="p">]</code><code> </code><a class="co" href="#callout_advanced_types_CO7-2" id="co_advanced_types_CO7-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="o">&gt;</code><code class="p">(</code><code>&#13;
  </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">ts</code><code>: </code><code class="kt">T</code><code> </code><a class="co" href="#callout_advanced_types_CO7-3" id="co_advanced_types_CO7-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO7-4" id="co_advanced_types_CO7-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">ts</code><code> </code><a class="co" href="#callout_advanced_types_CO7-5" id="co_advanced_types_CO7-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">a</code><code> </code><code class="o">=</code><code> </code><code class="nx">tuple</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code> </code><code class="kc">true</code><code class="p">)</code><code> </code><code class="c1">// [number, boolean]</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO7-1" id="callout_advanced_types_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We declare a <code>tuple</code> function that we’ll use to construct tuple types (instead of using the built-in <code>[]</code> syntax).</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO7-2" id="callout_advanced_types_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We declare a single type parameter <code>T</code> that’s a subtype of <code>unknown[]</code> (meaning <code>T</code> is an array of any kind of type).</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO7-3" id="callout_advanced_types_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>tuple</code> takes a variable number of parameters, <code>ts</code>. Because <code>T</code> describes a rest parameter, TypeScript will infer a tuple type for it.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO7-4" id="callout_advanced_types_CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p><code>tuple</code> returns a value of the same tuple type that it inferred <code>ts</code> as.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO7-5" id="callout_advanced_types_CO7-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Our function returns the same argument that we passed it. The magic is all in the types.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Take advantage of this technique in order to avoid type assertions when your code uses lots of tuple types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="User-Defined Type Guards" data-type="sect2"><div class="sect2" id="user-defined-type-guards">&#13;
<h2>User-Defined Type Guards</h2>&#13;
&#13;
<p>For some kinds of <code>boolean</code>-returning functions, simply saying that your function returns a <code>boolean</code> may not be enough.<a data-primary="types" data-secondary="function" data-tertiary="user-defined type guards" data-type="indexterm" id="idm46304965025976"/><a data-primary="functions" data-secondary="user-defined type guards" data-type="indexterm" id="idm46304965024824"/><a data-primary="user-defined type guards" data-type="indexterm" id="idm46304965023864"/> For example, let’s write a function that tells you if you passed it a <code>string</code> or not:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">function</code> <code class="nx">isString</code><code class="p">(</code><code class="nx">a</code><code class="o">:</code> <code class="nx">unknown</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="k">typeof</code> <code class="nx">a</code> <code class="o">===</code> <code class="s1">'string'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">isString</code><code class="p">(</code><code class="s1">'a'</code><code class="p">)</code> <code class="c1">// evaluates to true</code>&#13;
<code class="nx">isString</code><code class="p">([</code><code class="mi">7</code><code class="p">])</code> <code class="c1">// evaluates to false</code></pre>&#13;
&#13;
<p>So far so good. What happens if you try to use <code>isString</code> in some real-world code?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">parseInput</code><code class="p">(</code><code class="nx">input</code>: <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">formattedInput</code>: <code class="kt">string</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">isString</code><code class="p">(</code><code class="nx">input</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="nx">formattedInput</code> <code class="o">=</code> <code class="nx">input</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="c1">// Error TS2339: Property 'toUpperCase'</code>&#13;
  <code class="p">}</code>                                      <code class="c1">// does not exist on type 'number'.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What gives? If <code>typeof</code> works for regular<a data-primary="typeof operator" data-type="indexterm" id="idm46304964932824"/> type refinement (see <a data-type="xref" href="#refinement">“Refinement”</a>), why doesn’t it work here?<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2339" data-type="indexterm" id="idm46304964931224"/></p>&#13;
&#13;
<p>The thing about type refinement is it’s only powerful <a data-primary="refinement (types)" data-secondary="typeof operator and changing scopes" data-type="indexterm" id="idm46304964929400"/>enough to refine the type of a variable in the scope you’re in. As soon as you leave that scope, the refinement doesn’t carry over to whatever new scope you’re in. In our <code>isString</code> implementation, we refined the input parameter’s type to <code>string</code> using <code>typeof</code>, but because type refinement doesn’t carry over to new scopes, it got lost—all TypeScript knows is that <code>isString</code> returned a <code>boolean</code>.</p>&#13;
&#13;
<p>What we can do is tell the typechecker that not only does <code>isString</code> return a <code>boolean</code>, but whenever that <code>boolean</code> is <code>true</code>, the argument we passed to <code>isString</code> is a <code>string</code>. To do that, we use something called a <em>user-defined type guard</em>:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">isString</code><code class="p">(</code><code class="nx">a</code><code>: </code><code class="kt">unknown</code><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="nx">a</code><code> </code><code class="nx">is</code><code> </code><code class="kt">string</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="k">typeof</code><code> </code><code class="nx">a</code><code> </code><code class="o">===</code><code> </code><code class="s1">'string'</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Type guards are a built-in TypeScript feature, and are what lets you refine types with <code>typeof</code> and <code>instanceof</code>.<a data-primary="type guards" data-type="indexterm" id="idm46304964865624"/> But sometimes, you need the ability to declare type guards yourself—that’s what the <code>is</code> operator is for. When you have a function that refines its parameters’ types and returns a <code>boolean</code>, you can use a user-defined type guard to make sure that refinement is flowed whenever you use that function.</p>&#13;
&#13;
<p>User-defined type guards are limited to a single parameter, but they aren’t limited to simple types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">LegacyDialog</code> <code class="o">=</code> <code class="c1">// ...</code>&#13;
<code class="nx">type</code> <code class="nx">Dialog</code> <code class="o">=</code> <code class="c1">// ...</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">isLegacyDialog</code><code class="p">(</code>&#13;
  <code class="nx">dialog</code>: <code class="kt">LegacyDialog</code> <code class="o">|</code> <code class="nx">Dialog</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">dialog</code> <code class="nx">is</code> <code class="nx">LegacyDialog</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You won’t use user-defined type guards often, but when you do, they’re awesome for writing clean, reusable code. Without them, you’d have to inline all your <code>typeof</code> and <code>instanceof</code> type guards instead of building functions like <code>isLegacyDialog</code> and <code>isString</code> to perform those same checks in a better-encapsulated, more readable way.<a data-primary="types" data-secondary="function" data-startref="ix_typeadvfun" data-type="indexterm" id="idm46304964828008"/><a data-primary="functions" data-startref="ix_funcs" data-type="indexterm" id="idm46304964826872"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conditional Types" data-type="sect1"><div class="sect1" id="conditional-types">&#13;
<h1>Conditional Types</h1>&#13;
&#13;
<p>Conditional types might be the single most unique feature in all of TypeScript.<a data-primary="conditional types" data-type="indexterm" id="ix_condtyp"/><a data-primary="types" data-secondary="conditional" data-type="indexterm" id="ix_typecond"/> At a high level, conditional types let you say, “Declare a type <code>T</code> that depends on types <code>U</code> and <code>V</code>; if <code>U &lt;: V</code>, then assign <code>T</code> to <code>A</code>, and otherwise,<a data-primary="generics" data-secondary="declaring as part of a condition" data-type="indexterm" id="idm46304964818632"/> assign <code>T</code> to <code>B</code>.”</p>&#13;
&#13;
<p>In code it might look like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">IsString</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="nx">T</code><code> </code><code class="kr">extends</code><code> </code><code class="kt">string</code><code> </code><a class="co" href="#callout_advanced_types_CO8-1" id="co_advanced_types_CO8-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="o">?</code><code> </code><code class="kc">true</code><code> </code><a class="co" href="#callout_advanced_types_CO8-2" id="co_advanced_types_CO8-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="o">:</code><code> </code><code class="kc">false</code><code> </code><a class="co" href="#callout_advanced_types_CO8-3" id="co_advanced_types_CO8-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
&#13;
</code><code class="nx">type</code><code> </code><code class="nx">A</code><code> </code><code class="o">=</code><code> </code><code class="nx">IsString</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code> </code><code class="c1">// true&#13;
</code><code class="nx">type</code><code> </code><code class="nx">B</code><code> </code><code class="o">=</code><code> </code><code class="nx">IsString</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code> </code><code class="c1">// false</code></pre>&#13;
&#13;
<p>Let’s break that down line by line.</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO8-1" id="callout_advanced_types_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We declare a new conditional type <code>IsString</code> that takes a generic type <code>T</code>. The “condition” part of this conditional type is <code>T extends string</code>; that is, “Is <code>T</code> a subtype of <code>string</code>?”</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO8-2" id="callout_advanced_types_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>If <code>T</code> is a subtype of <code>string</code>, we resolve to the type <code>true</code>.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO8-3" id="callout_advanced_types_CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Otherwise, we resolve to the type <code>false</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Note how the syntax looks just like a regular value-level ternary expression, but at the type level. And like regular ternary expressions, you can nest them too.</p>&#13;
&#13;
<p>Conditional types aren’t limited to type aliases. You can use them almost anywhere you can use a type: in type aliases, interfaces, classes, parameter types, and generic defaults in functions and methods.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Distributive Conditionals" data-type="sect2"><div class="sect2" id="distributive-conditionals">&#13;
<h2>Distributive Conditionals</h2>&#13;
&#13;
<p>While you can express simple conditions like the examples we just looked at in a variety of ways in TypeScript—with conditional types, overloaded function signatures,<a data-primary="conditional types" data-secondary="distributive" data-type="indexterm" id="idm46304964699384"/><a data-primary="types" data-secondary="conditional" data-tertiary="distributive conditionals" data-type="indexterm" id="idm46304964698536"/><a data-primary="distributive property of conditional types following" data-type="indexterm" id="idm46304964697448"/> and mapped types—conditional types let you do more. The reason for this is that they follow the <em>distributive law</em> (remember, from algebra class?). That means if you have a conditional type, then the expressions on the right are equivalent to those on the left in <a data-type="xref" href="#dist-condition-table">Table 6-1</a>.</p>&#13;
<table id="dist-condition-table">&#13;
<caption><span class="label">Table 6-1. </span>Distributing conditional types</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>This…</th>&#13;
<th>Is equivalent to</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>string extends T ? A : B</code></p></td>&#13;
<td><p><code>string extends T ? A : B</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>(string | number) extends T ? A : B</code></p></td>&#13;
<td><p><code>(string extends T ? A : B) | (number extends T ? A : B)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>(string | number | boolean) extends T ? A : B</code></p></td>&#13;
<td><p><code>(string extends T ? A : B) | (number extends T ? A : B) | (boolean extends T ? A : B)</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>I know, I know, you didn’t shell out for this book to learn about math—you’re here for the types. So let’s get more concrete. Let’s say we have a function that takes some variable of type <code>T</code>, and lifts it to an array of type <code>T[]</code>. What happens if we pass in a union type for <code>T</code>?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ToArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="p">[]</code>&#13;
<code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">ToArray</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code>          <code class="c1">// number[]</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">ToArray</code><code class="o">&lt;</code><code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="c1">// (number | string)[]</code></pre>&#13;
&#13;
<p>Pretty straightforward.<a data-primary="union types" data-secondary="adding conditional type" data-type="indexterm" id="idm46304964682872"/> Now what happens if we add a conditional type? (Note that the conditional doesn’t actually do anything here because both its branches resolve to the same type <code>T[]</code>; it’s just here to tell TypeScript to <em>distribute</em> <code>T</code> over the tuple type.) Take a look:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">ToArray2</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="nx">T</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">unknown</code><code> </code><code class="o">?</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code> </code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">A</code><code> </code><code class="o">=</code><code> </code><code class="nx">ToArray2</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code> </code><em><code class="c1">// number[]</code></em><code class="c1">&#13;
</code><code class="nx">type</code><code> </code><code class="nx">B</code><code> </code><code class="o">=</code><code> </code><code class="nx">ToArray2</code><code class="o">&lt;</code><code class="kt">number</code><code> </code><code class="o">|</code><code> </code><code class="kt">string</code><code class="o">&gt;</code><code> </code><em><code class="c1">// number[] | string[]</code></em><code class="c1">&#13;
</code></pre>&#13;
&#13;
<p>Did you catch that? When you use a conditional type, TypeScript will distribute union types over the conditional’s branches. It’s like taking the conditional type and mapping (er, <em>distributing</em>) it over each element in the union.</p>&#13;
&#13;
<p>Why does any of this matter? Well, it lets you safely express a bunch of common operations.</p>&#13;
&#13;
<p>For example, TypeScript comes<a data-primary="Without type" data-type="indexterm" id="idm46304964583816"/> with <code>&amp;</code> for computing what two types have in common and <code>|</code> for taking a union of two types. Let’s build <code>Without&lt;T, U&gt;</code>, which computes the types that are in <code>T</code> but not in <code>U</code>.</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Without</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">U</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">U</code> <code class="o">?</code> <code class="nx">never</code> : <code class="kt">T</code></pre>&#13;
&#13;
<p>You use <code>Without</code> like so:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">Without</code><code class="o">&lt;</code>&#13;
  <code class="kr">boolean</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="kr">boolean</code>&#13;
<code class="o">&gt;</code> <code class="c1">// number | string</code></pre>&#13;
&#13;
<p>Let’s walk through how TypeScript computes this type:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Start with the inputs:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">Without</code><code class="o">&lt;</code><code class="kr">boolean</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">,</code> <code class="kr">boolean</code><code class="o">&gt;</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Distribute the condition over the union:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">Without</code><code class="o">&lt;</code><code class="kr">boolean</code><code class="p">,</code> <code class="kr">boolean</code><code class="o">&gt;</code>&#13;
       <code class="o">|</code> <code class="nx">Without</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">,</code> <code class="kr">boolean</code><code class="o">&gt;</code>&#13;
       <code class="o">|</code> <code class="nx">Without</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">boolean</code><code class="o">&gt;</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Substitute in <code>Without</code>’s definition and apply <code>T</code> and <code>U</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="p">(</code><code class="kr">boolean</code> <code class="kr">extends</code> <code class="kr">boolean</code> <code class="o">?</code> <code class="nx">never</code> : <code class="kt">boolean</code><code class="p">)</code>&#13;
       <code class="o">|</code> <code class="p">(</code><code class="kt">number</code> <code class="kr">extends</code> <code class="kr">boolean</code> <code class="o">?</code> <code class="nx">never</code> : <code class="kt">number</code><code class="p">)</code>&#13;
       <code class="o">|</code> <code class="p">(</code><code class="kt">string</code> <code class="kr">extends</code> <code class="kr">boolean</code> <code class="o">?</code> <code class="nx">never</code> : <code class="kt">string</code><code class="p">)</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Evaluate the conditions:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">never</code>&#13;
       <code class="o">|</code> <code class="kt">number</code>&#13;
       <code class="o">|</code> <code class="kt">string</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Simplify:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code></pre>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>If it wasn’t for the distributive property <a data-primary="never type" data-type="indexterm" id="idm46304964351624"/>of conditional types, we would have ended up with <code>never</code> (if you’re not sure why, walk through what would happen for yourself!).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The infer Keyword" data-type="sect2"><div class="sect2" id="idm46304964700792">&#13;
<h2>The infer Keyword</h2>&#13;
&#13;
<p>The final feature of conditional types is the ability to declare generic types as part of a condition.<a data-primary="types" data-secondary="conditional" data-tertiary="declaring generics inline with infer keyword" data-type="indexterm" id="idm46304964344424"/><a data-primary="generics" data-secondary="declaring as part of a condition" data-type="indexterm" id="idm46304964343080"/><a data-primary="conditional types" data-secondary="infer keyword, declaring generics inline" data-type="indexterm" id="idm46304964342168"/> As a refresher, so far we’ve seen just one way to declare generic type parameters: using angle brackets (<code>&lt;T&gt;</code>). Conditional types have their own syntax for declaring generic types inline: the <code>infer</code> keyword.<a data-primary="infer keyword" data-type="indexterm" id="idm46304964340136"/></p>&#13;
&#13;
<p>Let’s declare a conditional type <code>ElementType</code>, which gets the type of an array’s elements:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ElementType</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">unknown</code><code class="p">[]</code> <code class="o">?</code> <code class="nx">T</code><code class="p">[</code><code class="kt">number</code><code class="p">]</code> <code class="o">:</code> <code class="nx">T</code>&#13;
<code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">ElementType</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code> <code class="c1">// number</code></pre>&#13;
&#13;
<p>Now, let’s rewrite it using <code>infer</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ElementType2</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">infer</code> <code class="nx">U</code><code class="p">)[]</code> <code class="o">?</code> <code class="nx">U</code> : <code class="kt">T</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">ElementType2</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code> <code class="c1">// number</code></pre>&#13;
&#13;
<p>In this simple example <code>ElementType</code> is equivalent to <code>ElementType2</code>. Notice how the <code>infer</code> clause declares a new type variable, <code>U</code>—TypeScript will infer the type of <code>U</code> from context, based on what <code>T</code> you passed to <code>ElementType2</code>.</p>&#13;
&#13;
<p>Also notice why we declared <code>U</code> inline instead of declaring it up front, alongside <code>T</code>. What would have happened if we did declare it up front?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ElementUgly</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">U</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">U</code><code class="p">[]</code> <code class="o">?</code> <code class="nx">U</code> : <code class="kt">T</code>&#13;
<code class="nx">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">ElementUgly</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code> <code class="c1">// Error TS2314: Generic type 'ElementUgly'</code>&#13;
                               <code class="c1">// requires 2 type argument(s).</code></pre>&#13;
&#13;
<p>Uh-oh. Because <code>ElementUgly</code> defines two generic types, <code>T</code> and <code>U</code>, we have to pass both<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2314" data-type="indexterm" id="idm46304964128984"/> of them in when instantiating <code>ElementUgly</code>. But if we do that, that defeats the point of having an <code>ElementUgly</code> type in the first place; it puts the burden of computing <code>U</code> on the caller, when we wanted <code>ElementUgly</code> to compute the type itself.</p>&#13;
&#13;
<p>Honestly, this was a bit of a silly example because we already have the keying-in operator (<code>[]</code>) to look up the type of an array’s elements.<a data-primary="keying-in operator" data-type="indexterm" id="idm46304964125080"/><a data-primary="[] (square brackets)" data-secondary="keying-in operator" data-type="indexterm" id="idm46304964124376"/> What about a more complicated example?</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">SecondArg</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">F</code> <code class="kr">extends</code> <code class="p">(</code><code class="nx">a</code>: <code class="kt">any</code><code class="p">,</code> <code class="nx">b</code>: <code class="kt">infer</code> <code class="nx">B</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code> <code class="o">?</code> <code class="nx">B</code> : <code class="kt">never</code>&#13;
&#13;
<code class="c1">// Get the type of Array.slice</code>&#13;
<code class="nx">type</code> <code class="nx">F</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nb">Array</code><code class="p">[</code><code class="s1">'prototype'</code><code class="p">][</code><code class="s1">'slice'</code><code class="p">]</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">SecondArg</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code> <code class="c1">// number | undefined</code></pre>&#13;
&#13;
<p>So, <code>[].slice</code>’s second argument is a <code>number | undefined</code>. And we know this at compile time—try doing <em>that</em> in Java.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Built-in Conditional Types" data-type="sect2"><div class="sect2" id="idm46304964345384">&#13;
<h2>Built-in Conditional Types</h2>&#13;
&#13;
<p>Conditional types let you express some really powerful operations at the type level.<a data-primary="conditional types" data-secondary="built-in" data-type="indexterm" id="idm46304964037560"/><a data-primary="types" data-secondary="conditional" data-tertiary="built-in" data-type="indexterm" id="idm46304964036584"/> That’s why TypeScript ships with a few globally available conditional types out of the box:</p>&#13;
<dl>&#13;
<dt><code>Exclude&lt;T, U&gt;</code></dt>&#13;
<dd>&#13;
<p>Like our <code>Without</code> type from before, computes those types in <code>T</code> that are not in <code>U</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="o">&gt;</code>  <code class="c1">// number</code></pre>&#13;
</dd>&#13;
<dt><code>Extract&lt;T, U&gt;</code></dt>&#13;
<dd>&#13;
<p>Computes the types in <code>T</code> that you can assign to <code>U</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">Extract</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="o">&gt;</code>  <code class="c1">// string</code></pre>&#13;
</dd>&#13;
<dt><code>NonNullable&lt;T&gt;</code></dt>&#13;
<dd>&#13;
<p>Computes a version of <code>T</code> that excludes <code>null</code> and <code>undefined</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="p">{</code><code class="nx">a?</code>: <code class="kt">number</code> <code class="o">|</code> <code class="kc">null</code><code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">A</code><code class="p">[</code><code class="s1">'a'</code><code class="p">]</code><code class="o">&gt;</code>  <code class="c1">// number</code></pre>&#13;
</dd>&#13;
<dt><code>ReturnType&lt;F&gt;</code></dt>&#13;
<dd>&#13;
<p>Computes a function’s return type (note that this doesn’t work as you’d expect for generic and overloaded functions):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">F</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code>: <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">R</code> <code class="o">=</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="nx">F</code><code class="o">&gt;</code>  <code class="c1">// string</code></pre>&#13;
</dd>&#13;
<dt><code>InstanceType&lt;C&gt;</code></dt>&#13;
<dd>&#13;
<p>Computes the instance type of a class constructor:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="p">{</code><code class="k">new</code><code class="p">()</code><code class="o">:</code> <code class="nx">B</code><code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code>: <code class="kt">number</code><code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">I</code> <code class="o">=</code> <code class="nx">InstanceType</code><code class="o">&lt;</code><code class="nx">A</code><code class="o">&gt;</code>  <code class="c1">// {b: number}</code></pre>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Escape Hatches" data-type="sect1"><div class="sect1" id="idm46304964825464">&#13;
<h1>Escape Hatches</h1>&#13;
&#13;
<p>Sometimes you don’t have time to type something perfectly, and you just want TypeScript to trust that what you’re doing is safe.<a data-primary="conditional types" data-startref="ix_condtyp" data-type="indexterm" id="idm46304963804152"/><a data-primary="types" data-secondary="conditional" data-startref="ix_typecond" data-type="indexterm" id="idm46304963803288"/><a data-primary="escape hatches" data-type="indexterm" id="ix_esc"/><a data-primary="types" data-secondary="escape hatches" data-type="indexterm" id="ix_typeesc"/> Maybe a type declaration for a third party module you’re using is wrong and you want to test your code before contributing the fix back to DefinitelyTyped,<sup><a data-type="noteref" href="ch06.html#idm46304963799608" id="idm46304963799608-marker">4</a></sup> or maybe you’re getting data from an API and you haven’t regenerated type declarations with Apollo yet.</p>&#13;
&#13;
<p>Luckily, TypeScript knows that we’re only human, and gives us a few escape hatches for when we just want to do something and don’t have time to prove to TypeScript that it’s safe.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In case it’s not obvious, you should use the following TypeScript features as little as possible. If you find yourself relying on them, you might be doing something wrong.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Assertions" data-type="sect2"><div class="sect2" id="type-assertions">&#13;
<h2>Type Assertions</h2>&#13;
&#13;
<p>If you have a type <code>B</code> and <code>A &lt;: B &lt;: C</code>, then you can assert to the typechecker that <code>B</code> is actually an <code>A</code> or a <code>C</code>.<a data-primary="escape hatches" data-secondary="type assertions" data-type="indexterm" id="ix_esctypass"/><a data-primary="types" data-secondary="escape hatches" data-tertiary="type assertions" data-type="indexterm" id="ix_typeescta"/> Notably, you can only assert that a type is a supertype or a subtype of itself—you can’t, for example, assert that a <code>number</code> is a <code>string</code>, because those types aren’t related.<a data-primary="assertions" data-secondary="type" data-type="indexterm" id="idm46304963786888"/></p>&#13;
&#13;
<p>TypeScript gives us two syntaxes for type assertions:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">formatInput</code><code class="p">(</code><code class="nx">input</code><code>: </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="c1">// ...&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">getUserInput</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kt">string</code><code> </code><code class="o">|</code><code> </code><code class="kt">number</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="c1">// ...&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">input</code><code> </code><code class="o">=</code><code> </code><code class="nx">getUserInput</code><code class="p">(</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="c1">// Assert that input is a string&#13;
</code><code class="nx">formatInput</code><code class="p">(</code><code class="nx">input</code><code> </code><code class="kr">as</code><code> </code><code class="kt">string</code><code class="p">)</code><code> </code><a class="co" href="#callout_advanced_types_CO9-1" id="co_advanced_types_CO9-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="c1">// This is equivalent to&#13;
</code><code class="nx">formatInput</code><code class="p">(</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="nx">input</code><code class="p">)</code><code> </code><a class="co" href="#callout_advanced_types_CO9-2" id="co_advanced_types_CO9-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO9-1" id="callout_advanced_types_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We use a type assertion (<code>as</code>) to tell TypeScript that <code>input</code> is a <code>string</code>, not a <code>string | number</code> as the types would have us believe.<a data-primary="as (type assertion)" data-type="indexterm" id="idm46304963686680"/> You might do this, for example, if you want to quickly test out your <code>formatInput</code> function and you know for sure that <code>getUserInput</code> returns a <code>string</code> for your test.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO9-2" id="callout_advanced_types_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The legacy syntax for type assertions uses angle brackets.<a data-primary="&lt; &gt; (angle brackets)" data-secondary="in type assertions" data-type="indexterm" id="idm46304963682504"/> The two syntaxes are functionally equivalent.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Prefer <code>as</code> syntax for type assertions over angle bracket (<code>&lt;&gt;</code>) syntax. The former is unambiguous, but the latter can clash with TSX syntax (see <a data-type="xref" href="ch09.html#tsx-jsx-ts">“TSX = JSX + TypeScript”</a>). Use TSLint’s <a href="http://bit.ly/2WEGGKe"><code>no-angle-bracket-type-assertion</code></a> rule to automatically enforce this for your codebase.<a data-primary="TSLint" data-secondary="no-angle-bracket-type-assertion rule" data-type="indexterm" id="idm46304963661656"/></p>&#13;
</div>&#13;
&#13;
<p>Sometimes, two types might not be sufficiently related, so you can’t assert that one is the other. To get around this, simply assert as <code>any</code> (remember from <a data-type="xref" href="#assignability">“Assignability”</a> that <code>any</code> is assignable to anything), <a data-primary="any type" data-secondary="type assertions as" data-type="indexterm" id="idm46304963658632"/>then spend a few minutes in the corner thinking about what you’ve done:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">addToList</code><code class="p">(</code><code class="nx">list</code>: <code class="kt">string</code><code class="p">[],</code> <code class="nx">item</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">addToList</code><code class="p">(</code><code class="s1">'this is really,'</code> <code class="kr">as</code> <code class="nx">any</code><code class="p">,</code> <code class="s1">'really unsafe'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Clearly, type assertions are unsafe, and you should avoid using them when possible.<a data-primary="types" data-secondary="escape hatches" data-startref="ix_typeescta" data-tertiary="type assertions" data-type="indexterm" id="idm46304963647448"/><a data-primary="escape hatches" data-secondary="type assertions" data-startref="ix_esctypass" data-type="indexterm" id="idm46304963646088"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Nonnull Assertions" data-type="sect2"><div class="sect2" id="non-null-assertions">&#13;
<h2>Nonnull Assertions</h2>&#13;
&#13;
<p>For the special case of nullable types—that is, a type that’s <code>T | null</code> or <code>T | null | undefined</code>—TypeScript has special syntax for asserting that a value of that type is a <code>T</code>, and not <code>null</code> or <code>undefined</code>. This comes up in a few places.<a data-primary="escape hatches" data-secondary="nonnull assertions" data-type="indexterm" id="idm46304963624488"/><a data-primary="types" data-secondary="escape hatches" data-tertiary="nonnull assertions" data-type="indexterm" id="idm46304963623512"/><a data-primary="null type" data-secondary="nonnull assertions" data-type="indexterm" id="idm46304963622296"/><a data-primary="undefined type" data-secondary="nonnull assertions" data-type="indexterm" id="idm46304963621352"/><a data-primary="nonnull assertions" data-type="indexterm" id="idm46304963620408"/></p>&#13;
&#13;
<p>For example, say we’ve written a framework for showing and hiding dialogs in a web app. Each dialog gets a unique ID, which we use to get a reference to the dialog’s DOM node. <a data-primary="dialog, closing with nonnull assertions" data-type="indexterm" id="idm46304963619288"/><a data-primary="assertions" data-secondary="nonnull" data-type="indexterm" id="idm46304963618616"/>Once a dialog is removed from the DOM, we delete its ID, indicating that it’s no longer live in the DOM:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Dialog</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">id?</code><code>: </code><code class="kt">string</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">closeDialog</code><code class="p">(</code><code class="nx">dialog</code><code>: </code><code class="kt">Dialog</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO10-1" id="co_advanced_types_CO10-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="k">return</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">setTimeout</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_advanced_types_CO10-2" id="co_advanced_types_CO10-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
    </code><code class="nx">removeFromDOM</code><code class="p">(</code><code>&#13;
      </code><code class="nx">dialog</code><code class="p">,</code><code>&#13;
      </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code><code> </code><code class="c1">// Error TS2345: Argument of type&#13;
</code><code>                                         </code><code class="c1">// 'string | undefined' is not assignable&#13;
</code><code>                                         </code><code class="c1">// to parameter of type 'string'. </code><a class="co" href="#callout_advanced_types_CO10-3" id="co_advanced_types_CO10-3"><img alt="3" src="assets/3.png"/></a><code class="c1">&#13;
</code><code>    </code><code class="p">)</code><code>&#13;
  </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">removeFromDOM</code><code class="p">(</code><code class="nx">dialog</code><code>: </code><code class="kt">Dialog</code><code class="p">,</code><code> </code><code class="nx">element</code><code>: </code><code class="kt">Element</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">element</code><code class="p">.</code><code class="nx">parentNode</code><code class="p">.</code><code class="nx">removeChild</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code><code> </code><code class="c1">// Error TS2531: Object is possibly&#13;
</code><code>                                          </code><code class="c1">//'null'. </code><a class="co" href="#callout_advanced_types_CO10-4" id="co_advanced_types_CO10-4"><img alt="4" src="assets/4.png"/></a><code class="c1">&#13;
</code><code>  </code><code class="k">delete</code><code> </code><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO10-1" id="callout_advanced_types_CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>If the dialog is already deleted (so it has no <code>id</code>), we return early.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO10-2" id="callout_advanced_types_CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We remove<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304963483256"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2531" data-type="indexterm" id="idm46304963481976"/> the dialog from the DOM on the next turn of the event loop, so that any other code that depends on <code>dialog</code> has a chance to finish running.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO10-3" id="callout_advanced_types_CO10-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Because we’re inside the arrow function, we’re now in a new scope. TypeScript doesn’t know if some code mutated <code>dialog</code> between <a class="co" href="#co_advanced_types_CO10-1"><img alt="1" src="assets/1.png"/></a> and <a class="co" href="#co_advanced_types_CO10-3"><img alt="3" src="assets/3.png"/></a>, so it invalidates the refinement we made in <a class="co" href="#co_advanced_types_CO10-1"><img alt="1" src="assets/1.png"/></a>. On top of that, while we know that if <code>dialog.id</code> is defined then an element with that ID definitely exists in the DOM (because we designed our framework that way), all TypeScript knows is that calling <code>document.</code><code><span class="keep-together">getElementById</span></code> returns an <code>HTMLElement | null</code>. We know it’ll always be a nonnullable <code>HTMLElement</code>, but TypeScript doesn’t know that—it only knows about the types we gave it.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO10-4" id="callout_advanced_types_CO10-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Similarly, while we know that the dialog is definitely in the DOM and it definitely has a parent DOM node, all TypeScript knows is that the type of <code>element.</code><code><span class="keep-together">parentNode</span></code> is <code>Node | null</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>One way to fix this is to add a bunch of <code>if (_ === null)</code> checks everywhere. While that’s the right way to do it if you’re unsure if something is <code>null</code> or not, TypeScript comes with special syntax for when you’re sure it’s not <code>null | undefined</code>:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Dialog</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">id?</code><code>: </code><code class="kt">string</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">closeDialog</code><code class="p">(</code><code class="nx">dialog</code><code>: </code><code class="kt">Dialog</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">setTimeout</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code>&#13;
    </code><code class="nx">removeFromDOM</code><code class="p">(</code><code>&#13;
      </code><code class="nx">dialog</code><code class="p">,</code><code>&#13;
      </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code><strong><code class="o">!</code></strong><code class="p">)</code><strong><code class="o">!</code></strong><code>&#13;
    </code><code class="p">)</code><code>&#13;
  </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">removeFromDOM</code><code class="p">(</code><code class="nx">dialog</code><code>: </code><code class="kt">Dialog</code><code class="p">,</code><code> </code><code class="nx">element</code><code>: </code><code class="kt">Element</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">element</code><code class="p">.</code><code class="nx">parentNode</code><strong><code class="o">!</code></strong><code class="p">.</code><code class="nx">removeChild</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code><code>&#13;
  </code><code class="k">delete</code><code> </code><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Notice the <a data-primary="! (exclamation mark), nonnull assertion operator" data-type="indexterm" id="idm46304963429016"/>sprinkling of non<code>null</code> assertion operators (<code>!</code>) that tell TypeScript that we’re sure <code>dialog.id</code>, the result of our <code>document.getElementById</code> call, and <code>element.parentNode</code> are defined. When a non<code>null</code> assertion follows a type that might be <code>null</code> or <code>undefined</code>, TypeScript will assume that the type is defined: <code>T | null | undefined</code> becomes a <code>T</code>, <code>number | string | null</code> becomes <code>number | string</code>, and so on.</p>&#13;
&#13;
<p>When you find yourself using non<code>null</code> assertions a lot, it’s often a sign that you should refactor your code. For example, we could get rid of an assertion by splitting <code>Dialog</code> into a union of two types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">VisibleDialog</code> <code class="o">=</code> <code class="p">{</code><code class="nx">id</code>: <code class="kt">string</code><code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">DestroyedDialog</code> <code class="o">=</code> <code class="p">{}</code>&#13;
<code class="nx">type</code> <code class="nx">Dialog</code> <code class="o">=</code> <code class="nx">VisibleDialog</code> <code class="o">|</code> <code class="nx">DestroyedDialog</code></pre>&#13;
&#13;
<p>We can then update <code>closeDialog</code> to take advantage of the union:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">closeDialog</code><code class="p">(</code><code class="nx">dialog</code><code>: </code><code class="kt">Dialog</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="o">!</code><strong><code class="p">(</code><code class="s1">'id'</code><code> </code><code class="k">in</code><code> </code><code class="nx">dialog</code><code class="p">)</code></strong><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">setTimeout</code><code class="p">(</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code>&#13;
    </code><code class="nx">removeFromDOM</code><code class="p">(</code><code>&#13;
      </code><code class="nx">dialog</code><code class="p">,</code><code>&#13;
      </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><strong><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code></strong><code class="p">)</code><code class="o">!</code><code>&#13;
    </code><code class="p">)</code><code>&#13;
  </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">removeFromDOM</code><code class="p">(</code><code class="nx">dialog</code><code>: </code><strong><code class="kt">VisibleDialog</code></strong><code class="p">,</code><code> </code><code class="nx">element</code><code>: </code><code class="kt">Element</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">element</code><code class="p">.</code><code class="nx">parentNode</code><code class="o">!</code><code class="p">.</code><code class="nx">removeChild</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code><code>&#13;
  </code><code class="k">delete</code><code> </code><code class="nx">dialog</code><code class="p">.</code><code class="nx">id</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>After we check that <code>dialog</code> has an <code>id</code> property defined—implying that it’s a <code>Visible</code><code><span class="keep-together">Dialog</span></code>—even inside the arrow function TypeScript knows that the reference to <code>dialog</code> hasn’t changed: the <code>dialog</code> inside the arrow function is the same <code>dialog</code> outside the function, so the refinement carries over instead of being invalidated like it was in the last example.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Definite Assignment Assertions" data-type="sect2"><div class="sect2" id="definite-assignment-assertions">&#13;
<h2>Definite Assignment Assertions</h2>&#13;
&#13;
<p>TypeScript has special syntax for the special case of non<code>null</code> assertions for definite assignment checks (as a reminder, a definite assignment check is TypeScript’s way of making sure that by the time you use a variable, that variable has been assigned a value).<a data-primary="assertions" data-secondary="definite assignment" data-type="indexterm" id="idm46304963195688"/><a data-primary="escape hatches" data-secondary="definite assignment assertions" data-type="indexterm" id="idm46304963194712"/><a data-primary="types" data-secondary="escape hatches" data-tertiary="definite assignment assertions" data-type="indexterm" id="idm46304963193800"/><a data-primary="definite assignment assertions" data-type="indexterm" id="idm46304963192616"/> For example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">userId</code>: <code class="kt">string</code>&#13;
&#13;
<code class="nx">userId</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="c1">// Error TS2454: Variable 'userId' is used</code>&#13;
                     <code class="c1">// before being assigned.</code></pre>&#13;
&#13;
<p>Clearly, TypeScript just did us a great service by<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2454" data-type="indexterm" id="idm46304963147864"/> catching this error. We declared the variable <code>userId</code>, but forgot to assign a value to it before we tried to convert it to uppercase. This would have been a runtime error if TypeScript hadn’t noticed it!</p>&#13;
&#13;
<p>But, what if our code looks more like this?</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code><code> </code><code class="nx">userId</code><code>: </code><code class="kt">string</code><code>&#13;
</code><strong><code class="nx">fetchUser</code><code class="p">(</code><code class="p">)</code></strong><code>&#13;
&#13;
</code><code class="nx">userId</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">(</code><code class="p">)</code><code> </code><em><code class="c1">// Error TS2454: Variable 'userId' is used</code></em><code class="c1">&#13;
</code><code>                     </code><em><code class="c1">// before being assigned.</code></em><code class="c1">&#13;
</code><code>&#13;
</code><strong><code class="kd">function</code><code> </code><code class="nx">fetchUser() {</code><code>&#13;
  </code><code class="nx">userId</code><code> </code><code class="o">=</code><code> </code><code class="nx">globalCache</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'userId'</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>We happen to have the world’s greatest cache, and when we query this cache we get a cache hit 100% of of the time. So after the call to <code>fetchUser</code>, <code>userId</code> is guaranteed to be defined. But TypeScript isn’t able to statically detect that, so it still throws the same error as before. We can use a definite assignment assertion to tell TypeScript that <code>userId</code> will definitely be assigned by the time we read it (notice the exclamation mark):</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">let</code><code> </code><code class="nx">userId</code><strong><code class="o">!</code></strong><code class="o">:</code><code> </code><code class="kt">string</code><code>&#13;
</code><code class="nx">fetchUser</code><code class="p">(</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="nx">userId</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">(</code><code class="p">)</code><code> </code><em><code class="c1">// OK</code></em><code class="c1">&#13;
</code><code>&#13;
</code><code class="kd">function</code><code> </code><code class="nx">fetchUser() {</code><code>&#13;
  </code><code class="nx">userId</code><code> </code><code class="o">=</code><code> </code><code class="nx">globalCache</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'userId'</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>As with type assertions and non<code>null</code> assertions, if you find yourself using definite assignment assertions often, you might be doing something wrong.<a data-primary="types" data-secondary="escape hatches" data-startref="ix_typeesc" data-type="indexterm" id="idm46304963036536"/><a data-primary="escape hatches" data-startref="ix_esc" data-type="indexterm" id="idm46304963035448"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simulating Nominal Types" data-type="sect1"><div class="sect1" id="nominal-types">&#13;
<h1>Simulating Nominal Types</h1>&#13;
&#13;
<p>By this point in the book, if I were to shake you awake at three in the morning <a data-primary="nominal types, simulating" data-type="indexterm" id="ix_nomtype"/>and yell “IS TYPESCRIPT’S TYPE SYSTEM STRUCTURAL OR NOMINAL?!” you’d yell back “OF COURSE IT’S STRUCTURAL! NOW GET OUT OF MY HOUSE OR I’LL CALL THE POLICE!”<a data-primary="types" data-secondary="escape hatches" data-tertiary="simulating nominal types" data-type="indexterm" id="ix_typeescnom"/><a data-primary="escape hatches" data-secondary="simulating nominal types" data-type="indexterm" id="ix_escnom"/> That would be a fair response to me breaking in for early morning type system questions.</p>&#13;
&#13;
<p>Laws aside, the reality is that sometimes nominal types really are useful. For example, let’s say you have a few <code>ID</code> types in your application, representing unique ways of addressing the different types of objects in your system:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">CompanyID</code> <code class="o">=</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">OrderID</code> <code class="o">=</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">UserID</code> <code class="o">=</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">ID</code> <code class="o">=</code> <code class="nx">CompanyID</code> <code class="o">|</code> <code class="nx">OrderID</code> <code class="o">|</code> <code class="nx">UserID</code></pre>&#13;
&#13;
<p>A value of type <code>UserID</code> might be a simple hash that looks like <code>"d21b1dbf"</code>. So while you might alias it as <code>UserID</code>, under the hood it’s of course just a regular <code>string</code>. A function that takes a <code>UserID</code> might look like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">queryForUser</code><code class="p">(</code><code class="nx">id</code>: <code class="kt">UserID</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is great documentation, and it helps other engineers on your team know for sure which type of <code>ID</code> they should pass in. But since <code>UserID</code> is just an alias for <code>string</code>, this approach does little to prevent bugs. An engineer might accidentally pass in the wrong type of <code>ID</code>, and the types system will be none the wiser!</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">id</code>: <code class="kt">CompanyID</code> <code class="o">=</code> <code class="s1">'b4843361'</code>&#13;
<code class="nx">queryForUser</code><code class="p">(</code><code class="nx">id</code><code class="p">)</code> <code class="c1">// OK (!!!)</code></pre>&#13;
&#13;
<p>This is where <em>nominal types</em> come in handy.<sup><a data-type="noteref" href="ch06.html#idm46304962931080" id="idm46304962931080-marker">5</a></sup> While TypeScript doesn’t support nominal types out of the box, we can simulate them with a technique called <em>type branding</em>. <a data-primary="type branding" data-type="indexterm" id="idm46304962929496"/>Type branding takes a little work to set up, and using it in TypeScript is not as smooth an experience as it is in languages that have built-in support for nominal type aliases. That said, branded types can make your program significantly safer.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Depending on your application and the size of your engineering team (the larger your team, the more likely this technique will come in handy for preventing mistakes), you may not need to do this.</p>&#13;
</div>&#13;
&#13;
<p>Start by creating a synthetic <em>type brand</em> for each of your nominal types:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="nx">type</code><code> </code><code class="nx">CompanyID</code><code> </code><code class="o">=</code><code> </code><code class="kt">string</code><code> </code><code class="o">&amp;</code><code> </code><code class="p">{</code><code class="nx">readonly</code><code> </code><code class="nx">brand</code><code>: </code><code class="kt">unique</code><code> </code><code class="nx">symbol</code><code class="p">}</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">OrderID</code><code> </code><code class="o">=</code><code> </code><code class="kt">string</code><code> </code><code class="o">&amp;</code><code> </code><code class="p">{</code><code class="nx">readonly</code><code> </code><code class="nx">brand</code><code>: </code><code class="kt">unique</code><code> </code><code class="nx">symbol</code><code class="p">}</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">UserID</code><code> </code><code class="o">=</code><code> </code><code class="kt">string</code><code> </code><code class="o">&amp;</code><code> </code><code class="p">{</code><code class="nx">readonly</code><code> </code><code class="nx">brand</code><code>: </code><code class="kt">unique</code><code> </code><code class="nx">symbol</code><code class="p">}</code></strong><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">ID</code><code> </code><code class="o">=</code><code> </code><code class="nx">CompanyID</code><code> </code><code class="o">|</code><code> </code><code class="nx">OrderID</code><code> </code><code class="o">|</code><code> </code><code class="nx">UserID</code><code>&#13;
</code></pre>&#13;
&#13;
<p>An intersection of <code>string</code> and <code>{readonly brand: unique symbol}</code> is, of course, gibberish. I chose it because it’s impossible to naturally construct that type, and the only way to create a value of that type is with an assertion. That’s the crucial property of branded types: they make it hard to accidentally use a wrong type in their place.<a data-primary="unique symbols" data-type="indexterm" id="idm46304962893096"/> I used <code>unique symbol</code> as the “brand” because it’s one of two truly nominal kinds of types in TypeScript (the other is <code>enum</code>); I took an intersection of that brand with <code>string</code> so that we can assert that a given <code>string</code> is a given branded type.<a data-primary="enums" data-type="indexterm" id="idm46304962895064"/></p>&#13;
&#13;
<p>We now need a way to create values of type <code>CompanyID</code>, <code>OrderID</code>, and <code>UserID</code>. To do that, we’ll use the companion object pattern (introduced in <a data-type="xref" href="#companion-objects">“Companion Object Pattern”</a>). We’ll make a constructor for each branded type, using a type assertion to construct a value of each of our gibberish types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">CompanyID</code><code class="p">(</code><code class="nx">id</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">id</code> <code class="kr">as</code> <code class="nx">CompanyID</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">OrderID</code><code class="p">(</code><code class="nx">id</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">id</code> <code class="kr">as</code> <code class="nx">OrderID</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">UserID</code><code class="p">(</code><code class="nx">id</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">id</code> <code class="kr">as</code> <code class="nx">UserID</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, let’s see what it feels like to use these types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">queryForUser</code><code class="p">(</code><code class="nx">id</code>: <code class="kt">UserID</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">companyId</code> <code class="o">=</code> <code class="nx">CompanyID</code><code class="p">(</code><code class="s1">'8a6076cf'</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nx">orderId</code> <code class="o">=</code> <code class="nx">OrderID</code><code class="p">(</code><code class="s1">'9994acc1'</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nx">userId</code> <code class="o">=</code> <code class="nx">UserID</code><code class="p">(</code><code class="s1">'d21b1dbf'</code><code class="p">)</code>&#13;
&#13;
<code class="nx">queryForUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">)</code>    <code class="c1">// OK</code>&#13;
<code class="nx">queryForUser</code><code class="p">(</code><code class="nx">companyId</code><code class="p">)</code> <code class="c1">// Error TS2345: Argument of type 'CompanyID' is not</code>&#13;
                        <code class="c1">// assignable to parameter of type 'UserID'.</code></pre>&#13;
&#13;
<p>What’s nice about this<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304962733208"/> approach is how little runtime overhead it has: just one function call per <code>ID</code> construction, which will probably be inlined by your JavaScript VM anyway. At runtime, each <code>ID</code> is simply a <code>string</code>—the brand is purely a compile-time construct.</p>&#13;
&#13;
<p>Again, for most applications this approach is overkill. But for large applications, and when working with easily confused types like different kinds of IDs, branded types can be a killer safety feature.<a data-primary="escape hatches" data-secondary="simulating nominal types" data-startref="ix_escnom" data-type="indexterm" id="idm46304962680408"/><a data-primary="types" data-secondary="escape hatches" data-startref="ix_typeescnom" data-tertiary="simulating nominal types" data-type="indexterm" id="idm46304962679192"/><a data-primary="nominal types, simulating" data-startref="ix_nomtype" data-type="indexterm" id="idm46304962677736"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Safely Extending the Prototype" data-type="sect1"><div class="sect1" id="extending-the-prototype">&#13;
<h1>Safely Extending the Prototype</h1>&#13;
&#13;
<p>When building JavaScript applications, tradition holds that it’s unsafe to extend prototypes for built-in types.<a data-primary="prototypes, extending safely" data-type="indexterm" id="ix_protoext"/><a data-primary="types" data-secondary="extending the prototype safely" data-type="indexterm" id="ix_typeext"/> This rule of thumb goes back to before the days of jQuery, when wise JavaScript mages built libraries like <a href="https://mootools.net">MooTools</a> that extended and overwrote built-in prototype methods directly. But when too many mages augmented prototypes at once, conflicts arose. And without static type systems, you’d only find out about these conflicts from angry users at runtime.</p>&#13;
&#13;
<p>If you’re not coming from JavaScript, you may be surprised to learn that in JavaScript, you can modify any built-in method (like <code>[].push</code>, <code>'abc'.toUpperCase</code>, or <code>Object.assign</code>) at runtime. Because it’s such a dynamic language, JavaScript gives you direct access to prototypes for every built-in object—<code>Array.prototype</code>, <code>Function.prototype</code>, <code>Object.prototype</code>, and so on.<a data-primary="arrays" data-secondary="Array type, extending safely" data-type="indexterm" id="idm46304962668104"/></p>&#13;
&#13;
<p>While back in the day extending these prototypes was unsafe, if your code is covered by a static type system like TypeScript, then you can now do it safely.<sup><a data-type="noteref" href="ch06.html#idm46304962666696" id="idm46304962666696-marker">6</a></sup></p>&#13;
&#13;
<p>For example, we’ll add a <code>zip</code> method to the <code>Array</code> prototype. It takes two things to safely extend the prototype. First, in a <em>.ts</em> file (say, <em>zip.ts</em>), we extend the type of <code>Array</code>’s prototype; then, we augment the prototype with our new <code>zip</code> method:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Tell TypeScript about .zip&#13;
</code><code class="kr">interface</code><code> </code><code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_advanced_types_CO11-1" id="co_advanced_types_CO11-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">zip</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">list</code><code>: </code><code class="kt">U</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code class="o">:</code><code> </code><code class="p">[</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">U</code><code class="p">]</code><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="c1">// Implement .zip&#13;
</code><code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">zip</code><code> </code><code class="o">=</code><code> </code><code class="kd">function</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code>&#13;
  </code><code class="k">this</code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><a class="co" href="#callout_advanced_types_CO11-2" id="co_advanced_types_CO11-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">list</code><code>: </code><code class="kt">U</code><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="p">)</code><code class="o">:</code><code> </code><code class="p">[</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">U</code><code class="p">]</code><code class="p">[</code><code class="p">]</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code> </code><code class="nx">k</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code>&#13;
    </code><code class="nx">tuple</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code><code> </code><code class="nx">list</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code><code class="p">)</code><code> </code><a class="co" href="#callout_advanced_types_CO11-3" id="co_advanced_types_CO11-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_advanced_types_CO11-1" id="callout_advanced_types_CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We start by telling TypeScript that we’re adding <code>zip</code> to <code>Array</code>. We take advantage of interface merging (<a data-type="xref" href="ch05.html#interface-merging">“Declaration Merging”</a>) to augment the global <code>Array&lt;T&gt;</code> interface, adding our own <code>zip</code> method to the already globally defined interface.</p>&#13;
&#13;
<p>Since our file doesn’t have any explicit imports or exports—meaning it’s in script mode, as described in <a data-type="xref" href="ch10.html#module-mode">“Module Mode Versus Script Mode”</a>—we were able to augment the global <code>Array</code> interface directly by declaring an interface with the exact same name as the existing <code>Array&lt;T&gt;</code> interface, and letting TypeScript take care of merging the two for us. <a data-primary="import statements" data-type="indexterm" id="idm46304962528344"/>If our file were in module mode (which might be the case if, for example, we needed to <code>import</code> something for our <code>zip</code> implementation), we’d have to wrap our global extension in a <code>declare global</code> type declaration (see <a data-type="xref" href="ch11.html#type-declarations">“Type Declarations”</a>):</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="kr">declare</code><code> </code><code class="nx">global</code><code> </code><code class="p">{</code></strong><code>&#13;
  </code><code class="kr">interface</code><code> </code><code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">zip</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">list</code><code>: </code><code class="kt">U</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code class="o">:</code><code> </code><code class="p">[</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">U</code><code class="p">]</code><code class="p">[</code><code class="p">]</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><strong><code class="p">}</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p><code>global</code> is a special namespace containing all the globally<a data-primary="global namespace" data-type="indexterm" id="idm46304962444392"/>  defined values (anything that you can use in a module-mode file without <code>import</code>ing it first; see <a data-type="xref" href="ch10.html#modules">Chapter 10</a>) that lets you augment names in the global scope from a file in module mode.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO11-2" id="callout_advanced_types_CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We then implement the <code>zip</code> method on <code>Array</code>’s prototype. We use a <code>this</code> type so that TypeScript correctly infers the <code>T</code> type of the array we’re calling <code>.zip</code> on.</p></dd>&#13;
<dt><a class="co" href="#co_advanced_types_CO11-3" id="callout_advanced_types_CO11-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Because TypeScript infers the mapping function’s return type as <code>(T | U)[]</code> (TypeScript isn’t smart enough to realize that it’s in fact always a tuple with <code>T</code> in the zeroth index and <code>U</code> in the first), we use our <code>tuple</code> utility (from <a data-type="xref" href="#improving-type-inference-for-tuples">“Improving Type Inference for Tuples”</a>) to create a tuple type without resorting to a type assertion.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Notice that when we declare <code>interface Array&lt;T&gt;</code> we augment the global <code>Array</code> namespace for our whole TypeScript project—meaning even if we don’t import <em>zip.ts</em> from our file, TypeScript will think that <code>[].zip</code> is available. But in order to augment <code>Array.prototype</code>, we have to be sure that whatever file uses <code>zip</code> loads <em>zip.ts</em> first, in order to install the <code>zip</code> method on <code>Array.prototype</code>. How do we make sure that any file that uses <code>zip</code> loads <em>zip.ts</em> first?</p>&#13;
&#13;
<p>Easy: we update our <em>tsconfig.json</em> to explicitly exclude <em>zip.ts</em> from our project, so that consumers have to explicitly <code>import</code> it first:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="err">*exclude*:</code> <code class="err">[</code>&#13;
    <code class="nt">"./zip.ts"</code>&#13;
  <code class="err">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now we can use <code>zip</code> as we please, with total safety:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="s1">'./zip'</code>&#13;
&#13;
<code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>&#13;
  <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">*</code> <code class="mi">2</code><code class="p">)</code>        <code class="c1">// number[]</code>&#13;
  <code class="p">.</code><code class="nx">zip</code><code class="p">([</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">])</code>   <code class="c1">// [number, string][]</code></pre>&#13;
&#13;
<p>Running this gives us the result of first mapping, then zipping the array:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="p">[</code>&#13;
  <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">],</code>&#13;
  <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code>&#13;
  <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">]</code>&#13;
<code class="p">]</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304962317256">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we covered the most advanced features of TypeScript’s type system: from the ins and outs of variance to <a data-primary="prototypes, extending safely" data-startref="ix_protoext" data-type="indexterm" id="idm46304962324712"/><a data-primary="types" data-secondary="extending the prototype safely" data-startref="ix_typeext" data-type="indexterm" id="idm46304962323880"/>flow-based type inference, refinement, type widening, totality, and mapped and conditional types. We then derived a few advanced patterns for working with types: type branding to simulate nominal types, taking advantage of the distributive property of conditional types to operate on types at the type level, and safely extending prototypes.</p>&#13;
&#13;
<p>If you didn’t understand or don’t remember everything, that’s OK—come back to this chapter later, and use it as a reference when you’re struggling with how to express something more safely.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46304962321368">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>For each of the following pairs of types, decide if the first type is assignable to the second type, and why or why not. Think about these in terms of subtyping and variance, and refer to the rules at the start of the chapter if you’re unsure (if you’re still unsure, just type it into your code editor to check!):</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>1</code> and <code>number</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>number</code> and <code>1</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>string</code> and <code>number | string</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>boolean</code> and <code>number</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>number[]</code> and <code>(number | string)[]</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>(number | string)[]</code> and <code>number[]</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>{a: true}</code> and <code>{a: boolean}</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>{a: {b: [string]}}</code> and <code>{a: {b: [number | string]}}</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>(a: number) =&gt; string</code> and <code>(b: number) =&gt; string</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>(a: number) =&gt; string</code> and <code>(a: string) =&gt; string</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>(a: number | string) =&gt; string</code> and <code>(a: string) =&gt; string</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>E.X</code> (defined in an enum <code>enum E {X = 'X'}</code>) and <code>F.X</code> (defined in an enum <code>enum F {X = 'X'}</code>)</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</li>&#13;
<li>&#13;
<p>If you have an object type <code>type O = {a: {b: {c: string}}}</code>, what’s the type of <code>keyof O</code>? What about <code>O['a']['b']</code>?</p>&#13;
</li>&#13;
<li>&#13;
<p>Write an <code>Exclusive&lt;T, U&gt;</code> type that computes the types that are in either <code>T</code> or <code>U</code>, but not both. For example, <code>Exclusive&lt;1 | 2 | 3, 2 | 3 | 4&gt;</code> should resolve to <code>1 | 4</code>. Write out step by step how the typechecker evaluates <code>Exclusive&lt;1 | 2, 2 | 4&gt;</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Rewrite the example (from <a data-type="xref" href="#definite-assignment-assertions">“Definite Assignment Assertions”</a>) to avoid the definite assignment assertion.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304967500104"><sup><a href="ch06.html#idm46304967500104-marker">1</a></sup> Symbolic execution is a form of program analysis where you use a special program called a symbolic evaluator to run your program the same way a runtime would, but without assigning definite values to variables; instead, each variable is modelled as a <em>symbol</em> whose value gets constrained as the program runs. Symbolic execution lets you say things like “this variable is never used,” or “this function never returns,” or “in the positive branch of the <code>if</code> statement on line 102, variable <code>x</code> is guaranteed not to be <code>null</code>.”</p><p data-type="footnote" id="idm46304967497288"><sup><a href="ch06.html#idm46304967497288-marker">2</a></sup> Flow-based type inference is supported by a handful of languages, including TypeScript, Flow, Kotlin, and Ceylon. It’s a way to refine types within a block of code, and is an alternative to C/Java-style explicit type annotations and Haskell/OCaml/Scala-style pattern matching. The idea is to take a symbolic execution engine and embed it right in the typechecker, in order to give feedback to the typechecker and reason through a program in a way that is closer to how a human programmer might do it.</p><p data-type="footnote" id="idm46304967201672"><sup><a href="ch06.html#idm46304967201672-marker">3</a></sup> JavaScript has seven falsy values: <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>0</code>, <code>-0</code>, <code>""</code>, and of course, <code>false</code>. Everything else is <span class="keep-together">truthy</span>.</p><p data-type="footnote" id="idm46304963799608"><sup><a href="ch06.html#idm46304963799608-marker">4</a></sup> <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> is the open source repository for type declarations for third-party JavaScript. To learn more, jump ahead to <a data-type="xref" href="ch11.html#third-party-js-with-dt-typings">“JavaScript That Has Type Declarations on DefinitelyTyped”</a>.</p><p data-type="footnote" id="idm46304962931080"><sup><a href="ch06.html#idm46304962931080-marker">5</a></sup> In some languages, these are also called <em>opaque types</em>.</p><p data-type="footnote" id="idm46304962666696"><sup><a href="ch06.html#idm46304962666696-marker">6</a></sup> There are other reasons why you might want to avoid extending the prototype, like code portability, making your dependency graphs more explicit, or improving performance by only loading those methods that you actually use. However, safety is no longer one of those reasons.</p></div></div></section></body></html>