- en: Chapter 14\. Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can animate and interact, stream, play, and render, but we always come back
    to the data. Data is the foundation on which we build the majority of our JavaScript
    applications. In the first part of the book we worked with the JavaScript languages
    standards for data types, in [Chapter 13](ch13.html#ch13) we fetched data from
    a remote source, and in [Chapter 20](ch20.html#ch20) we’ll work with data on the
    server, manipulating data using APIs and data sources. Data and JavaScript, friends
    forever.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to look at ways we can persist data with JavaScript
    in the browser using cookies, `sessionStorage`, `localStorage`, and IndexedDB.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Persisting Information with Cookies
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to read or set the value of a browser cookie.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `document.cookie` to set and retrieve cookie values:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To encode strings, use `encodeURIComponent`, which will remove any commas,
    semicolons, or whitespace:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Options can be added to the end of the cookie value and should be separated
    with a semicolon:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To delete a cookie, set an expiration date for the cookie that has already
    occurred:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cookies are small bits of data that are stored in the browser. They are often
    set from the server application and sent to the server with nearly every request.
    In a browser they are accessed via the `document.cookie` object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Cookies accept the following options, each separated with a semicolon:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '`domain`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The domain where the cookie is accessible. If not set, this defaults to the
    current host location. Specifying a domain allows the cookie to be accessed at
    subdomains.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`expires`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Sets a time at which the cookie expires. Accepts a date in GMTString format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`max-age`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Sets the length of time that the cookie is valid. Accepts a value in seconds.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '`path`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The path at which the cookie is accessible (such as `/` or `/app`). If not specified,
    the cookie defaults to the current path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '`secure`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: If set to `true`, the cookie will only be transmitted over `https`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '`samesite`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Defaults to `strict`. If set to `strict`, the cookie will not be sent in cross-site
    browsing. Alternatively, `lax` will send cookies on top-level GET requests.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the user can enter a value which is stored as a cookie.
    They can then retrieve the value of a specified key and delete the value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'In an HTML file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the associated *cookie.js* file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that I am using regular expressions to match the cookie values, which
    have been encoded using `encodeURIComponent`. This is because `document.cookie`
    returns a string with all of the cookie values. Using regular expressions in this
    way allows me to extract the information that I need. Regular expressions are
    covered in more detail in [Chapter 2](ch02.html#ch02).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Using sessionStorage for Client-Side Storage
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to easily store information for a single session, without running into
    the size and cross-page contamination problems associated with cookies.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the DOM Storage `sessionStorage` functionality:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`sessionStorage` allows us to easily store information in the user’s browser
    for a single session. A session lasts for as long as a single browser tab is open.
    Once the user closes the browser or tab, the session ends. Opening a new tab of
    the same page will start a new browser session.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: By comparison, the default behavior of both cookies and `localStorage` (discussed
    in [“Creating a localStorage Client-Side Data Storage Item”](#creating_a_localstorage_client-side_data))
    is to persist across sessions. As an example of the differences between these
    storage methods, [Example 14-1](#comparing_sessionstorage_and_cookies) stores
    information from a form in a cookie, `localStorage`, and `sessionStorage`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1\. Comparing `sessionStorage` and cookies
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The *cookies.js* file contains the code necessary to set, retrieve, and erase
    a given cookie:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And the *app.js* file contains the rest of the program functionality:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can get and set the data from `sessionStorage`, accessing it directly, as
    demonstrated in the solution, but a better approach is to use the `getItem()`
    and `setItem()` functions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Load the example page, add one or more values for the same key, and then click
    the “Get data” button. The result is displayed in [Figure 14-1](#getting_session_cookie_data).
    No surprises here. The data has been stored in cookies, `localStorage`, and `sessionStorage`.
    Now, open the same page in a new tab window, enter the value into the `key` form
    field, and click the “Get data” button. The activity results in a page like that
    shown in [Figure 14-2](#values_diff_tab).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 1401](assets/jsc3_1401.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1\. Displaying stored `sessionStorage` and cookie data in original
    tab
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![jsc3 1402](assets/jsc3_1402.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2\. Displaying stored `sessionStorage` and cookie data in second tab
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the new tab window, the `cookie` and `localStorage` values persist because
    the `cookie` is session specific, but the `sessionStorage`, which is specific
    to the tab window, does not.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots illustrate the difference in cross-tab persistence, one of the
    key differences between `sessionStorage` and cookies, aside from how they’re set
    and accessed in JavaScript. Hopefully, the images and the example also demonstrate
    the potential hazards involved when using `sessionStorage`, especially in circumstances
    where cookies have normally been used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: If your website or application users are familiar with the cookie persistence
    across tabbed windows, `sessionStorage` can be an unpleasant surprise. Along with
    the different behavior, there’s also the fact that browser menu options to delete
    cookies probably won’t have an impact on `sessionStorage`, which could also be
    an unwelcome surprise for your users. On the other hand, `sessionStorage` is incredibly
    clean to use, and provides a welcome storage option when we want to link storage
    to a specific tab window only.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'One last note on `sessionStorage` related to its implementation: both `sessionStorage`
    and `localStorage`, covered in the next recipe, are part of the W3C DOM Storage
    specification. Both are `window` object properties, which means they can be accessed
    globally. Both are implementations of the `Storage` object, and changes to the
    `prototype` for `Storage` result in changes to both the `sessionStorage` and `localStorage`
    objects:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Aside from the differences covered in this recipe and the next, another major
    difference is that the `Storage` objects don’t make a round trip to the server—they’re
    purely client-side storage techniques.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on the `Storage` object, `sessionStorage`, `localStorage`,
    or the Storage DOM, consult the [specification](https://oreil.ly/PgBUt). See [“Creating
    a localStorage Client-Side Data Storage Item”](#creating_a_localstorage_client-side_data)
    for a different look at how `sessionStorage` and `localStorage` can be set and
    retrieved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Creating a localStorage Client-Side Data Storage Item
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to persist form element entries (or any data) in such a way that users
    can continue where they left off if the browser crashes, the user accidentally
    closes the browser, or the internet connection is lost.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You could use cookies if the data is small enough, but that strategy doesn’t
    work in an offline situation. Another, better approach, especially when you’re
    persisting larger amounts of data or if you have to support functionality when
    no internet connection is present, is to use `localStorage`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Using sessionStorage for Client-Side Storage”](#using_sessionstorage_for_client-side_sto)
    covered `sessionStorage`, one of the DOM Storage techniques. The `localStorage`
    object interface is the same, with the same approaches to setting the data:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'and for getting the data:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Again, as with `sessionStorage`, though you can access and set data on `localStorage`
    directly, you should use `getItem()` and `setItem()`, instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Both of the storage objects support the `length` property, which provides a
    count of stored item pairs, and the `clear` method (no parameters), which clears
    out all storage. In addition, both are scoped to the HTML5 origin, which means
    that the data storage is shared across all pages in a domain, but not across protocols
    (e.g., `http` is not the same as `https`) or ports.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two is how long data is stored. The `sessionStorage`
    object only stores data for the session, but the `localStorage` object stores
    data on the client forever, or until specifically removed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sessionStorage` and `localStorage` objects also support one event: the
    `storage` event. This is an interesting event, in that it fires on all pages when
    changes are made to a `localStorage` item. It is also an area of low compatibility
    among browsers: you can capture the event on the `body` or `document` elements
    for Firefox, on the `body` for IE, or on the `document` for Safari.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 14-2](#using_localstorage_to_back_up_form_entri) demonstrates a more
    comprehensive implementation than the use case covered in the solution for this
    recipe. In the example, all elements of a small form have their `onchange` event
    handler method assigned to a function that captures the change element name and
    value, and stores the values in the local storage via `localStorage`. When the
    form is submitted, all of the stored form data is cleared.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: When the page is loaded, the form elements `onchange` event handler is assigned
    to the function to store the values, and if the value is already stored, it is
    restored to the form element. To test the application, enter data into a couple
    of the form fields—but, before clicking the Submit button, refresh the page. Without
    `localStorage`, you’d lose the data. Now, when you reload the page, the form is
    restored to the state it was in before the page was reloaded.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-2\. Using `localStorage` to back up form entries in case of page
    reload or browser crash
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the JavaScript file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The size allotted for `localStorage` varies by browser, but most are in the
    5 mb to 10 mb range. You can use a `try/catch` block to test to ensure you have
    not exceeded the limit in the user’s browser:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `localStorage` object can be used for offline work. For the form example,
    you can store the data in the `localStorage` and provide a button to click when
    connected to the internet, in order to sync the data from `localStorage` to server-side
    storage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [“Using sessionStorage for Client-Side Storage”](#using_sessionstorage_for_client-side_sto)
    for more on the `Storage` object, and on `sessionStorage` and `localStorage`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Persisting Larger Chunks of Data on the Client Using IndexedDB
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need more sophisticated data storage on the client than what’s provided
    with other persistent storage methods, such as `localStorage`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern browsers, use IndexedDB.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript file in [Example 14-3](#example_using_indexeddb) uses IndexedDB
    to create a database and a data object. Once created, it adds data and then retrieves
    the first object. A more detailed description of what’s happening is in the discussion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-3\. Example of using IndexedDB to create a datastore, add data, and
    then retreive a data object
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Discussion
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IndexedDB is the specification the W3C and others agreed to when exploring solutions
    to large data management on the client. Though it is transaction based, and supports
    the concept of a *cursor*, it isn’t a relational database system. It works with
    JavaScript objects, each of which is indexed by a given *key*, whatever you decide
    the key to be.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: IndexedDB can be both asynchronous and synchronous. It can be used for larger
    chunks of data in a traditional server or cloud application, but is also helpful
    for offline web application use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Most implementations of IndexedDB don’t restrict data storage size, but if you
    store more than 50 MB in Firefox, the user will need to provide permission. Chrome
    creates a pool of temporary storage, and each application can have up to 20% of
    it. Other agents have similar limitations. All of the main browsers support IndexedDB,
    except Opera Mini, though the overall support may not be identical.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数IndexedDB的实现不限制数据存储大小，但如果在Firefox中存储超过50 MB，则用户需要提供权限。Chrome创建一个临时存储池，每个应用程序最多可以使用其20%。其他代理程序也有类似的限制。所有主流浏览器都支持IndexedDB，除了Opera
    Mini，尽管整体支持可能不完全相同。
- en: 'As the solution demonstrates, the IndexedDB API methods trigger both success
    and error callback functions, which you can capture using traditional event handling,
    or as callback, or assign to a function. Mozilla describes the pattern of use
    with IndexedDB:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如解决方案所示，IndexedDB API方法触发成功和错误回调函数，您可以使用传统事件处理、回调函数或分配给函数来捕获这些回调。
- en: Open a database.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开数据库。
- en: Create an object store in upgrading database.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在升级数据库中创建对象存储。
- en: Start a transaction and make a request to do some database operation, like adding
    or retrieving data.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开启一个事务，并发出一个数据库操作请求，如添加或检索数据。
- en: Wait for the operation to complete by listening to the right kind of DOM event.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过监听适当类型的DOM事件等待操作完成。
- en: Do something with the results (which can be found on the request object).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理返回的结果（可以在请求对象中找到）。
- en: Starting from the top in the solution, a data object is created with three values
    to add to the datastore. The database is deleted if it exists, so that the example
    can be run multiple times. Following, a call to `open()` opens the database, if
    it exists, or creates it, if not. Because the database is deleted before the example
    is run, it’s recreated. The name and version are both necessary, because the database
    can be altered only if a new version of the database is opened.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从解决方案的顶部开始，创建一个具有三个值的数据对象以添加到数据存储中。如果数据库存在，则删除数据库，以便可以多次运行示例。随后，调用`open()`打开数据库（如果存在）或创建数据库（如果不存在）。因为在运行示例之前删除了数据库，所以它会被重新创建。名称和版本都是必需的，因为只有在打开新版本的数据库时才能修改数据库。
- en: A request object (IDBOpenDBRequest) is returned from the `open()` method, and
    whether the operation succeeds or not is triggered as events on this object. In
    the code, the `onsuccess` event handler for the object is captured to provide
    a message to the console about the success. You can also assign the database handle
    to a global variable in this event handler, but the code assigns this in the next
    event handled, the `upgradeneeded` event.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从`open()`方法返回一个请求对象（IDBOpenDBRequest），并且操作是否成功会作为该对象的事件触发。在代码中，捕获该对象的`onsuccess`事件处理程序以在控制台上提供成功的消息。您还可以在此事件处理程序中将数据库句柄分配给全局变量，但代码在下一个事件处理程序`upgradeneeded`中分配它。
- en: The `upgradeneeded` event handler is only invoked when a database doesn’t exist
    for a given database name and version. The event object also gives us a way to
    access the IDBDatabase reference, which is assigned to the global variable, `db`.
    The existing transaction can also be accessed via the event object passed as an
    argument to the event handler, and it’s accessed and assigned to a local variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定数据库名称和版本的数据库不存在时，只有`upgradeneeded`事件处理程序才会被调用。事件对象还提供了一种访问IDBDatabase引用的方式，该引用分配给全局变量`db`。现有的事务也可以通过作为事件处理程序参数传递的事件对象访问，并且它被访问并分配给一个局部变量。
- en: The event handler for this event is the only time you’ll be able to create the
    object store and its associated indexes. In the solution, a datastore named `reader`
    is created, with its key set to an autoincrementing `id`. Two other indexes are
    for the datastore’s `name` and `experience` fields. The data is also added to
    the datastore in the event, though it could have been added at a separate time,
    say when a person submits an HTML form.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件的事件处理程序是唯一可以创建对象存储及其相关索引的时间。在解决方案中，创建了一个名为`reader`的数据存储，其键设置为自增的`id`。另外两个索引用于数据存储的`name`和`experience`字段。数据也在事件中添加到数据存储中，尽管可以在其他时间添加，例如当用户提交HTML表单时。
- en: Following the `upgradeneeded` event handler, the `success` and `error` handlers
    are coded, just to provide feedback. Last but not least, the `document.onclick`
    event handler is used to trigger a database access. In the solution, a random
    data instance is accessed via the database handler, its transaction, the object
    store, and eventually, for a given key. When the query is successful, the `name`
    field is accessed and the value is printed to the console. Rather than accessing
    a single value, we can also use a cursor, but I’ll leave that for your own experimentation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`upgradeneeded`事件处理程序之后，编写了`success`和`error`处理程序，仅用于提供反馈。最后，使用`document.onclick`事件处理程序来触发数据库访问。在解决方案中，通过数据库处理程序访问随机数据实例，其事务，对象存储，并最终获得给定键的数据。当查询成功时，访问`name`字段并将其值打印到控制台。我们可以使用游标而不是访问单个值，但这留给您自己的实验。
- en: 'The resulting printouts to the console are, in order:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将按顺序打印到控制台：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Simplifying IndexedDB with a Library
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用库简化IndexedDB
- en: Problem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You’d like to work with IndexedDB in an asynchronous fashion, using JavaScript
    promises.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用JavaScript promises以异步方式处理IndexedDB。
- en: Solution
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the [IDB library](https://github.com/jakearchibald/idb), which offers usability
    improvements to the IndexedDB API as well as a wrapper for using promises.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[IDB库](https://github.com/jakearchibald/idb)，它提供了对IndexedDB API的可用性改进以及使用promises的包装器。
- en: 'The following file imports the IDB library, creates an IndexedDB data store,
    and adds data to it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件导入IDB库，创建一个IndexedDB数据存储并向其添加数据：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the example, I am loading the `idb` module from [UNPKG](https://unpkg.com),
    which allows me to directly access the module from a URL, rather than locally
    installing it. This works well for demo purposes, but in an application you will
    want to install the module via `npm` and bundle it with your code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我正在从[UNPKG](https://unpkg.com)加载`idb`模块，这使我可以直接从URL访问模块，而不是在本地安装它。这在演示目的中效果很好，但在应用程序中，您将希望通过`npm`安装模块并将其与您的代码捆绑在一起。
- en: Discussion
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: IDB bills itself as “a tiny library that mostly mirrors the IndexedDB API, but
    with small improvements that make a big difference to usability.” Using `idb`
    simplifies some of the syntax of IndexedDB, along with enabling support for asynchronous
    code execution with promises.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: IDB自称为“一个几乎与IndexedDB API完全相同的小型库，但通过一些小的改进大大提升了可用性。”使用`idb`简化了IndexedDB的某些语法，并支持使用promises执行异步代码。
- en: 'The `openDB` method opens a database and returns a promise:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`openDB`方法打开数据库并返回一个promise：'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the following example, a user can add data to the database and retrieve
    all of the data to be displayed on the page. In an HTML file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，用户可以向数据库添加数据并检索所有数据以在页面上显示。在HTML文件中：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the *idb-discussion.js* file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以及*idb-discussion.js*文件：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: I won’t go into the full API, but highly recommend consulting the [library’s
    documentation](https://github.com/jakearchibald/idb/blob/master/README.md) and
    using IDB whenever working with IndexedDB.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细介绍整个API，但强烈建议查阅[库的文档](https://github.com/jakearchibald/idb/blob/master/README.md)，并在使用IndexedDB时使用IDB。
