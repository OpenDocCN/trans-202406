<html><head></head><body><section data-pdf-bookmark="Chapter 4. Adding Workloads to the Mesh" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="LUAR_meshing_workloads">
<h1 class="calibre7"><span class="calibre">Chapter 4. </span>Adding Workloads to the Mesh</h1>


<p class="author1">Getting Linkerd running in your cluster is a great first step. But it’s
pointless to run Linkerd with nothing else: to get actual value out of your
Linkerd cluster, you’ll need to get workloads running in your service mesh. In
this chapter, we’ll show you how to do exactly that.</p>






<section data-pdf-bookmark="Workloads Versus Services" data-type="sect1" class="preface"><div class="preface" id="id128">
<h1 class="calibre8">Workloads Versus Services</h1>

<p class="author1">We’ll talk about “workloads” a lot<a data-primary="workloads" data-secondary="services versus" data-type="indexterm" id="id767" class="calibre4"/><a data-primary="services" data-secondary="workloads versus" data-type="indexterm" id="id768" class="calibre4"/> in this chapter—but sometimes we’ll also talk
about “services,” and sometimes “Services.” Unfortunately, these three things
all have slightly different meanings:<a data-primary="services" data-secondary="definition" data-type="indexterm" id="id769" class="calibre4"/><a data-primary="Services" data-secondary="definition" data-type="indexterm" id="id770" class="calibre4"/><a data-primary="services" data-secondary="Services versus" data-type="indexterm" id="id771" class="calibre4"/><a data-primary="Services" data-secondary="services versus" data-type="indexterm" id="id772" class="calibre4"/><a data-primary="services" data-secondary="resources" data-see="Services" data-type="indexterm" id="id773" class="calibre4"/></p>
<dl class="calibre10">
<dt class="calibre11">Service</dt>
<dd class="calibre12">
<p class="calibre13">A Kubernetes resource that is widely used to control how
Kubernetes allocates DNS names and IP addresses for services (see <a data-type="xref" href="#workloads-vs-services" class="calibre4">Figure 4-1</a>).</p>
</dd>
<dt class="calibre11">Workload</dt>
<dd class="calibre12">
<p class="calibre13">A thing that actually does work on your behalf. A workload receives
requests over the network and executes code to take actions. In
Kubernetes, it’s usually one or more Pods (to provide the computation),
often managed by a Deployment or DaemonSet resource, plus one or more
Services (to manage the names and IP addresses), as illustrated in <a data-type="xref" href="#workloads-vs-services" class="calibre4">Figure 4-1</a>.</p>
</dd>
<dt class="calibre11">service</dt>
<dd class="calibre12">
<p class="calibre13">A less formal term that could refer to either a Service or a
workload, depending on context. This lack of precision shows just one of
many cases where Kubernetes terminology is very much more confusing than we
would like it to be.</p>
</dd>
</dl>

<figure class="calibre23"><div class="figure" id="workloads-vs-services">
<img alt="luar 0401" src="assets/luar_0401.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 4-1. </span>The workload as distinct from the Service</h6>
</div></figure>

<p class="author1">As an application developer, you can usually just say “service” and trust that
people will be fine with the ambiguity. Unfortunately, we often need to be more
precise when talking about service meshes—hence the
discussion of <em class="hyperlink">workloads</em> here rather than <em class="hyperlink">services</em>.</p>
</div></section>






<section data-pdf-bookmark="What Does It Mean to Add a Workload to the Mesh?" data-type="sect1" class="preface"><div class="preface" id="id32">
<h1 class="calibre8">What Does It Mean to Add a Workload to the Mesh?</h1>

<p class="author1">“Adding a workload to the mesh” <a data-primary="workloads" data-secondary="adding to the mesh" data-type="indexterm" id="id774" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-type="indexterm" id="id775" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-type="indexterm" id="id776" class="calibre4"/><a data-primary="Pods" data-secondary="sidecars needed by application Pods" data-tertiary="adding workloads to the mesh" data-type="indexterm" id="ch04-addme" class="calibre4"/>really means “adding the Linkerd sidecar to
each of your workload’s Pods,” as shown in <a data-type="xref" href="#meshing-a-workload" class="calibre4">Figure 4-2</a>.</p>

<p class="author1">Ultimately, this means changing the Pod’s definition to include the sidecar
container. While you <em class="hyperlink">could</em> do this by manually editing the YAML that defines
the Pod, it’s much easier and safer to let Linkerd do the heavy lifting
instead.</p>

<p class="author1">Linkerd includes a Kubernetes <a data-primary="linkerd-proxy-injector" data-type="indexterm" id="ch04-adcon" class="calibre4"/><a data-primary="Kubernetes" data-secondary="sidecar containers" data-tertiary="admission controller" data-type="indexterm" id="ch04-adcon2" class="calibre4"/><a data-primary="Linkerd" data-secondary="architecture" data-tertiary="Kubernetes sidecar admission controller" data-type="indexterm" id="ch04-adcon3" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="sidecar model of service meshes" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="ch04-adcon4" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="ch04-adcon5" class="calibre4"/><a data-primary="proxy injector of control plane" data-type="indexterm" id="ch04-adcon6" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="ch04-adcon7" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="Kubernetes admission controller" data-type="indexterm" id="id777" class="calibre4"/>admission controller called the
<code class="calibre9">linkerd-proxy-injector</code>. Its job, unsurprisingly, is to inject Linkerd
proxies into workload Pods. <a data-primary="namespaces" data-secondary="application-code conversion webhooks" data-type="indexterm" id="id778" class="calibre4"/><a data-primary="application-code namespace conversion webhooks" data-secondary="proxy injector" data-type="indexterm" id="id779" class="calibre4"/><a data-primary="conversion webhooks" data-secondary="proxy injector" data-type="indexterm" id="id780" class="calibre4"/>Of course, it doesn’t do this blindly; instead, it
looks for Kubernetes annotations that tell it which Pods need to be injected, as shown in <a data-type="xref" href="#proxy-injector" class="calibre4">Figure 4-3</a>.</p>

<figure class="calibre23"><div class="figure" id="meshing-a-workload">
<img alt="luar 0402" src="assets/luar_0402.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 4-2. </span>Adding a workload to the mesh</h6>
</div></figure>

<figure class="calibre23"><div class="figure" id="proxy-injector">
<img alt="luar 0403" src="assets/luar_0403.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 4-3. </span>The proxy injector</h6>
</div></figure>
</div></section>






<section class="preface" data-pdf-bookmark="Injecting Individual Workloads" data-type="sect1"><div class="preface" id="id129">
<h1 class="calibre8">Injecting Individual Workloads</h1>

<p class="author1">The most common way to handle<a data-primary="linkerd-proxy-injector" data-secondary="injecting individual workloads" data-type="indexterm" id="id781" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="injecting individual workloads" data-type="indexterm" id="id782" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="injecting individual workloads" data-type="indexterm" id="id783" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="injecting individual workloads" data-type="indexterm" id="id784" class="calibre4"/><a data-primary="proxy injector of control plane" data-secondary="injecting individual workloads" data-type="indexterm" id="id785" class="calibre4"/><a data-primary="Pods" data-secondary="sidecars needed by application Pods" data-tertiary="adding individual workloads" data-type="indexterm" id="id786" class="calibre4"/> injection is to add the <code class="calibre9">linkerd.io/inject:
enabled</code> annotation directly to the Pod itself, typically by adding the
annotation to the Pod template in a Deployment, DaemonSet, etc. Whenever
<code class="calibre9">linkerd-proxy-injector</code> sees a new Pod with this annotation, it will inject
the proxy sidecar into the Pod for you.</p>

<p class="author1">It’s worth pointing out that the value of the annotation is important:
<code class="calibre9">enabled</code> means to do a normal sidecar injection. We’ll look at other
values shortly.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">All Pods Are Created Equal</h1>
<p class="author1">It doesn’t matter what kind of <a data-primary="Pods" data-secondary="sidecars needed by application Pods" data-tertiary="all Pods created equal" data-type="indexterm" id="id787" class="calibre4"/>resource is being used to create the Pod.
Deployments, DaemonSets, hand-tooled ReplicaSets, Argo Rollouts resources—all
of them create their Pods exactly the same way. What the Linkerd injector
notices is that a new Pod exists, not what caused it to be created.</p>
</div>
</div></section>






<section data-pdf-bookmark="Injecting All Workloads in a Namespace" data-type="sect1" class="preface"><div class="preface" id="id130">
<h1 class="calibre8">Injecting All Workloads in a Namespace</h1>

<p class="author1">You can add the <code class="calibre9">linkerd.io/inject</code> annotation<a data-primary="linkerd-proxy-injector" data-secondary="injecting all workloads in namespace" data-type="indexterm" id="id788" class="calibre4"/><a data-primary="proxy injector of control plane" data-secondary="injecting all workloads in namespace" data-type="indexterm" id="id789" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="injecting all workloads in namespace" data-type="indexterm" id="id790" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="injecting all workloads in namespace" data-type="indexterm" id="id791" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="injecting all workloads in namespace" data-type="indexterm" id="id792" class="calibre4"/><a data-primary="namespaces" data-secondary="injecting all workloads in namespace" data-type="indexterm" id="id793" class="calibre4"/> to a Namespace, rather
than to a Pod. Once that’s done, every new Pod created in that namespace will
be injected (and, again, it <em class="hyperlink">does not matter</em> what causes the new Pod to be
created).</p>

<p class="author1">This can be very useful for situations where automation is creating Pods, but
it’s difficult or error-prone to modify the annotations on the Pods
themselves. For example, some ingress controllers will re-create Deployments
every time you change a resource; rather than mess about with laboriously
modifying the Pod template used by the ingress controller (if it’s even
possible), you can just annotate the Namespace in which the Deployments will
be created.</p>
</div></section>






<section data-pdf-bookmark="linkerd.io/inject Values" data-type="sect1" class="preface"><div class="preface" id="linkerdio-inject-values">
<h1 class="calibre8">linkerd.io/inject Values</h1>

<p class="author1">The value of the <code class="calibre9">linkerd.io/inject</code> annotation<a data-primary="linkerd-proxy-injector" data-secondary="annotation values" data-type="indexterm" id="id794" class="calibre4"/><a data-primary="proxy injector of control plane" data-secondary="annotation values" data-type="indexterm" id="id795" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="annotation values" data-type="indexterm" id="id796" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="annotation values" data-type="indexterm" id="id797" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="annotation values" data-type="indexterm" id="id798" class="calibre4"/> does matter—it’s not just a
matter of having a non-empty string there. There are three specific values that are meaningful:</p>
<dl class="calibre10">
<dt class="calibre11"><code class="calibre14">linkerd.io/inject: enabled</code></dt>
<dd class="calibre12">
<p class="calibre13">The most common case:
<code class="calibre9">linkerd-proxy-injector</code> will add a proxy container to the Pod and tell the
proxy to run in its “normal” mode.</p>
</dd>
<dt class="calibre11"><code class="calibre14">linkerd.io/inject: ingress</code></dt>
<dd class="calibre12">
<p class="calibre13"><code class="calibre9">linkerd-proxy-injector</code> will add a proxy container to the Pod, but the
proxy will run in “ingress” mode (which we’ll discuss in <a data-type="xref" href="ch05.html#LUAR_ingress_and_linkerd" class="calibre4">Chapter 5</a>).</p>
</dd>
<dt class="calibre11"><code class="calibre14">linkerd.io/inject: disabled</code></dt>
<dd class="calibre12">
<p class="calibre13">This explicitly tells <code class="calibre9">linkerd-proxy-injector</code> to
<em class="hyperlink">not</em> add the proxy sidecar, even if there’s a Namespace annotation that would otherwise say to add the sidecar.</p>
</dd>
</dl>

<p class="author1">We’ll discuss ingress mode more in <a data-type="xref" href="ch05.html#LUAR_ingress_and_linkerd" class="calibre4">Chapter 5</a>: it’s a workaround for
ingress controllers that only know how to route requests directly to workload
endpoints. In most cases, you should use <code class="calibre9">linkerd.io/inject: enabled</code> to get
“normal” mode.<a data-startref="ch04-adcon" data-type="indexterm" id="id799" class="calibre4"/><a data-startref="ch04-adcon2" data-type="indexterm" id="id800" class="calibre4"/><a data-startref="ch04-adcon3" data-type="indexterm" id="id801" class="calibre4"/><a data-startref="ch04-adcon4" data-type="indexterm" id="id802" class="calibre4"/><a data-startref="ch04-adcon5" data-type="indexterm" id="id803" class="calibre4"/><a data-startref="ch04-adcon6" data-type="indexterm" id="id804" class="calibre4"/><a data-startref="ch04-adcon7" data-type="indexterm" id="id805" class="calibre4"/></p>
</div></section>






<section data-pdf-bookmark="Why Might You Decide Not to Add a Workload  to the Mesh?" data-type="sect1" class="preface"><div class="preface" id="id34">
<h1 class="calibre8">Why Might You Decide Not to Add a Workload 
<span class="calibre">to the Mesh?</span></h1>

<p class="author1">In general:<a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="when not to" data-type="indexterm" id="id806" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="when not to" data-type="indexterm" id="id807" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="when not to" data-type="indexterm" id="id808" class="calibre4"/></p>

<ul class="printings">
<li class="calibre6">
<p class="author1">You always want to add your application workloads to the mesh.</p>
</li>
<li class="calibre6">
<p class="author1">You never want to add cluster infrastructure to the mesh.</p>
</li>
</ul>

<p class="author1">So, for example, things<a data-primary="namespaces" data-secondary="kube-system never injected into mesh" data-type="indexterm" id="id809" class="calibre4"/><a data-primary="kube-system namespace never injected into mesh" data-type="indexterm" id="id810" class="calibre4"/> in the <code class="calibre9">kube-system</code> namespace are never injected. All
of these Pods are designed to protect themselves no matter what else is going
on, and some of them need to be sure that nothing is between them and the
network layer, so you shouldn’t inject them.</p>

<p class="author1">Likewise, a Kubernetes conversion webhook<a data-primary="application-code namespace conversion webhooks" data-secondary="generally not injected into mesh" data-type="indexterm" id="id811" class="calibre4"/><a data-primary="conversion webhooks" data-secondary="generally not injected into mesh" data-type="indexterm" id="id812" class="calibre4"/><a data-primary="namespaces" data-secondary="application-code conversion webhooks" data-type="indexterm" id="id813" class="calibre4"/> (as shown in the <code class="calibre9">application-code</code>
namespace in <a data-type="xref" href="#proxy-injector" class="calibre4">Figure 4-3</a>) generally shouldn’t be in the mesh. The webhook mechanism
itself already makes specific demands around TLS, and the mesh won’t help with
that. (It probably won’t hurt, but there’s really no point.) Another good
example here is CNI implementations: these need direct access to the network
layer and shouldn’t be injected.</p>

<p class="author1">On the other hand, the workloads that are part of your application running in
the cluster should always be injected into the mesh. All of these guidelines are
shown in <a data-type="xref" href="#inject-app-not-infrastructure" class="calibre4">Figure 4-4</a>.<a data-startref="ch04-addme" data-type="indexterm" id="id814" class="calibre4"/></p>

<figure class="calibre23"><div class="figure" id="inject-app-not-infrastructure">
<img alt="luar 0404" src="assets/luar_0404.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 4-4. </span>Inject the application, not the infrastructure</h6>
</div></figure>
</div></section>






<section data-pdf-bookmark="Other Proxy Configuration Options" data-type="sect1" class="preface"><div class="preface" id="id131">
<h1 class="calibre8">Other Proxy Configuration Options</h1>

<p class="author1">Although the basic <code class="calibre9">linkerd.io/inject</code> annotation<a data-primary="linkerd-proxy-injector" data-secondary="configuration options" data-type="indexterm" id="id815" class="calibre4"/><a data-primary="proxy injector of control plane" data-secondary="configuration options" data-type="indexterm" id="id816" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="proxy injector configuration options" data-type="indexterm" id="id817" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="proxy injector configuration options" data-type="indexterm" id="id818" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="proxy injector configuration options" data-type="indexterm" id="id819" class="calibre4"/> is the only proxy
configuration option you <em class="hyperlink">must</em> provide, there are actually quite a few other
things you can configure about the proxy. <a data-primary="linkerd-proxy-injector" data-secondary="configuration options" data-tertiary="documentation URL" data-type="indexterm" id="id820" class="calibre4"/><a data-primary="proxy injector of control plane" data-secondary="configuration options" data-tertiary="documentation URL" data-type="indexterm" id="id821" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="Linkerd proxy configuration" data-type="indexterm" id="id822" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="Linkerd proxy configuration" data-type="indexterm" id="id823" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="Linkerd proxy configuration" data-type="indexterm" id="id824" class="calibre4"/>The full list can be found in the
<a href="https://oreil.ly/9FiJF" class="calibre4">Linkerd Proxy Configuration documentation</a>, but two areas very
much worth learning about from the start are <em class="hyperlink">protocol detection</em> and
<em class="hyperlink">Kubernetes resource limits</em>.</p>
</div></section>






<section data-pdf-bookmark="Protocol Detection" data-type="sect1" class="preface"><div class="preface" id="id35">
<h1 class="calibre8">Protocol Detection</h1>

<p class="author1">As we discussed in <a data-type="xref" href="ch01.html#LUAR_service_mesh_101" class="calibre4">Chapter 1</a>, Linkerd<a data-primary="linkerd-proxy-injector" data-secondary="configuration options" data-tertiary="protocol detection" data-type="indexterm" id="ch04-prot" class="calibre4"/><a data-primary="proxy injector of control plane" data-secondary="configuration options" data-tertiary="protocol detection" data-type="indexterm" id="ch04-prot2" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="protocol detection" data-type="indexterm" id="ch04-prot3" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="protocol detection" data-type="indexterm" id="ch04-prot4" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="protocol detection" data-type="indexterm" id="ch04-prot5" class="calibre4"/><a data-primary="protocol detection" data-type="indexterm" id="ch04-prot6" class="calibre4"/><a data-primary="ports" data-secondary="protocol detection" data-type="indexterm" id="ch04-prot7" class="calibre4"/> puts a lot of effort
into operational simplicity; whenever possible, Linkerd tries to make sure
things just work when you bring your application into the mesh. Protocol
detection is a critical part of this, because Linkerd has to know the protocol
being used over a connection to correctly manage the connection, as shown in <a data-type="xref" href="#protocol-detection-overview" class="calibre4">Figure 4-5</a>.</p>

<figure class="calibre23"><div class="figure" id="protocol-detection-overview">
<img alt="luar 0405" src="assets/luar_0405.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 4-5. </span>Protocol detection</h6>
</div></figure>

<p class="author1">There are several reasons that Linkerd (or any other mesh) needs to know the
protocol in use over the wire. We’ll touch on just a few of them:<a data-primary="observability" data-secondary="protocol detection enabling" data-type="indexterm" id="id825" class="calibre4"/><a data-primary="reliability" data-secondary="protocol detection enabling" data-type="indexterm" id="id826" class="calibre4"/><a data-primary="security" data-secondary="protocol detection enabling" data-type="indexterm" id="id827" class="calibre4"/></p>
<dl class="calibre10">
<dt class="calibre11">Observability</dt>
<dd class="calibre12">
<p class="calibre13">Linkerd can’t provide proper metrics without understanding
the flow of the protocol. Identifying the beginning and end of a request is
crucial to measuring request rate and latency. Reading the status of a request
is critical to measuring the success rate.</p>
</dd>
<dt class="calibre11">Reliability</dt>
<dd class="calibre12">
<p class="calibre13">Any reliability feature beyond the most basic requires
understanding the protocol in flight. Consider load balancing, for example: if
Linkerd doesn’t know the protocol, it can only do connection-based load
balancing, where an incoming TCP connection is assigned to a specific workload
Pod.</p>

<p class="calibre13">However, connection-based load balancing doesn’t work very well for protocols
like HTTP/2 and gRPC. In these protocols, a single long-lived connection can
carry many requests, with multiple requests active at the same time. Linkerd
can dramatically improve reliability and performance by assigning individual
requests to workload Pods, rather than fixing an entire connection to a Pod.
(It’s a fun Linkerd fact that it does this automatically, with zero
configuration; just install Linkerd, and you get this for free.)</p>
</dd>
<dt class="calibre11">Security</dt>
<dd class="calibre12">
<p class="calibre13">If a workload makes a TLS connection to another workload,
Linkerd shouldn’t try to reencrypt it. It also shouldn’t try to do anything
fancy with load balancing, since it won’t be able to see anything inside the
connection. (This implies that you’ll get the best results with Linkerd by
having your workloads <em class="hyperlink">not</em> use TLS when connecting to each other: let Linkerd do mTLS
for you!)</p>
</dd>
</dl>








<section class="preface" data-pdf-bookmark="When Protocol Detection Goes Wrong" data-type="sect2"><div class="preface" id="id36">
<h2 class="calibre27">When Protocol Detection Goes Wrong</h2>

<p class="author1">Automatic protocol detection has<a data-primary="protocol detection" data-secondary="client-speaks-first protocols only" data-type="indexterm" id="id828" class="calibre4"/><a data-primary="ports" data-secondary="protocol detection" data-tertiary="client-speaks-first protocols only" data-type="indexterm" id="id829" class="calibre4"/><a data-primary="client-speaks-first protocols" data-type="indexterm" id="id830" class="calibre4"/><a data-primary="server-speaks-first protocols" data-type="indexterm" id="id831" class="calibre4"/> one major limitation: it can only work for
protocols where the entity that makes the connection is also the first one to
send data (<em class="hyperlink">client-speaks-first</em> protocols). It will fail for protocols where
the entity that <em class="hyperlink">receives</em> the connection is the first to send data
(<em class="hyperlink">server-speaks-first</em> protocols).</p>

<p class="author1">The reason for this limitation is that until Linkerd knows the protocol, it
can’t make reasonable decisions about how to do load balancing, so it can’t
decide what server to connect to, so it can’t find out what the server will
say! Every proxy has this frustratingly circular issue.</p>

<p class="author1">In the cloud native world, many—perhaps most?—common <a data-primary="client-speaks-first protocols" data-secondary="examples of" data-type="indexterm" id="id832" class="calibre4"/>protocols are,
happily, client-speaks-first protocols; for example, HTTP, gRPC, and TLS
itself are all client-speaks-first. <a data-primary="server-speaks-first protocols" data-secondary="examples of" data-type="indexterm" id="id833" class="calibre4"/>Unfortunately, there are some important
server-speaks-first protocols out there: SMTP, MySQL, and Redis are all
examples.</p>

<p class="author1">If Linkerd cannot detect<a data-primary="protocol detection" data-secondary="unable to detect" data-type="indexterm" id="id834" class="calibre4"/><a data-primary="ports" data-secondary="protocol detection" data-tertiary="unable to detect" data-type="indexterm" id="id835" class="calibre4"/> the protocol, it will assume it’s a raw TCP
connection, simply because that’s the least common denominator that will
always function. The problem is that for server-speaks-first protocols,
Linkerd will wait 10 seconds before assuming that it won’t be able to detect
the protocol, and that 10-second delay is obviously not what you want. <a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="opaque versus skip ports" data-type="indexterm" id="id836" class="calibre4"/><a data-primary="ports" data-secondary="opaque and skip ports" data-type="indexterm" id="id837" class="calibre4"/><a data-primary="opaque ports" data-type="indexterm" id="id838" class="calibre4"/><a data-primary="skip ports" data-type="indexterm" id="id839" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="opaque versus skip ports" data-type="indexterm" id="id840" class="calibre4"/>To
prevent that, you need to tell Linkerd that it should either skip the
connection entirely or treat it as opaque.</p>
</div></section>








<section data-pdf-bookmark="Opaque Ports Versus Skip Ports" data-type="sect2" class="preface"><div class="preface" id="id132">
<h2 class="calibre27">Opaque Ports Versus Skip Ports</h2>

<p class="author1">When you tell Linkerd to <em class="hyperlink">skip</em> a connection, you’re telling it to have
absolutely nothing to do with that connection. In fact, the Linkerd proxies
don’t touch the connection at all: the packets flow straight from workload to
workload.</p>

<p class="author1">This means that Linkerd can’t do mTLS, load balancing, metrics collection, or
<em class="hyperlink">anything</em>. The connection effectively happens outside the mesh entirely.</p>

<p class="author1">An <em class="hyperlink">opaque</em> connection, on the other hand, does pass through the Linkerd
proxies, <a data-primary="mTLS (mutual TLS)" data-secondary="opaque connections" data-type="indexterm" id="id841" class="calibre4"/>which means that it is carried over mTLS. It’s still encrypted and
Linkerd still enforces any policy that has been configured, but you’ll only
get per-connection metrics and load balancing (because Linkerd knows that it
can’t see into the stream to look at individual requests).</p>

<p class="author1">This distinction is shown in <a data-type="xref" href="#opaque-vs-skip" class="calibre4">Figure 4-6</a>.</p>

<figure class="calibre23"><div class="figure" id="opaque-vs-skip">
<img alt="luar 0406" src="assets/luar_0406.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 4-6. </span>Opaque ports versus skip ports</h6>
</div></figure>

<p class="author1">This all implies that if you need<a data-primary="protocol detection" data-secondary="unable to detect" data-tertiary="server-speaks-first as opaque" data-type="indexterm" id="id842" class="calibre4"/><a data-primary="server-speaks-first protocols" data-secondary="as opaque connections" data-secondary-sortas="opaque connections" data-type="indexterm" id="id843" class="calibre4"/><a data-primary="opaque ports" data-secondary="server-speaks-first protocols as opaque" data-type="indexterm" id="id844" class="calibre4"/><a data-primary="ports" data-secondary="protocol detection" data-tertiary="server-speaks-first protocols as opaque" data-type="indexterm" id="id845" class="calibre4"/> to use server-speaks-first protocols, it’s
better to mark them as opaque, rather than skipping them entirely. Skipping
should only be necessary when the destination of the traffic isn’t part of
your mesh. Since opaque connections still rely on a Linkerd proxy to do
mTLS, they can’t work if there’s no proxy there to receive the connection!</p>
</div></section>








<section data-pdf-bookmark="Configuring Protocol Detection" data-type="sect2" class="preface"><div class="preface" id="id37">
<h2 class="calibre27">Configuring Protocol Detection</h2>

<p class="author1">There are two ways to tell Linkerd<a data-primary="protocol detection" data-secondary="configuring" data-type="indexterm" id="id846" class="calibre4"/><a data-primary="linkerd-proxy-injector" data-secondary="configuration options" data-tertiary="configuring protocol detection" data-type="indexterm" id="id847" class="calibre4"/><a data-primary="ports" data-secondary="protocol detection" data-tertiary="configuring" data-type="indexterm" id="id848" class="calibre4"/><a data-primary="proxy injector of control plane" data-secondary="configuration options" data-tertiary="protocol detection configuration" data-type="indexterm" id="id849" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="configuring protocol detection" data-type="indexterm" id="id850" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="configuring protocol detection" data-type="indexterm" id="id851" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="configuring protocol detection" data-type="indexterm" id="id852" class="calibre4"/><a data-primary="skip ports" data-secondary="configuration" data-type="indexterm" id="id853" class="calibre4"/><a data-primary="opaque ports" data-secondary="configuration" data-type="indexterm" id="id854" class="calibre4"/><a data-primary="ports" data-secondary="opaque and skip ports" data-tertiary="configuration" data-type="indexterm" id="id855" class="calibre4"/><a data-primary="Server resources" data-secondary="protocol detection" data-type="indexterm" id="id856" class="calibre4"/> about protocols. You can use a Server
resource, which we’ll cover when we talk policy in <a data-type="xref" href="ch08.html#LUAR_server_policy" class="calibre4">Chapter 8</a>, or
you can use the following annotations to mark specific ports as opaque or skipped:</p>
<dl class="calibre10">
<dt class="calibre11"><code class="calibre14">config.linkerd.io/opaque-ports</code></dt>
<dd class="calibre12">
<p class="calibre13">Connections to or from these ports will always be treated as opaque.</p>
</dd>
<dt class="calibre11"><code class="calibre14">config.linkerd.io/skip-inbound-ports</code></dt>
<dd class="calibre12">
<p class="calibre13">Connections coming into this workload on these ports will always be skipped.</p>
</dd>
<dt class="calibre11"><code class="calibre14">config.linkerd.io/skip-outbound-ports</code></dt>
<dd class="calibre12">
<p class="calibre13">Connections leaving this workload on these ports will always be skipped.</p>
</dd>
</dl>

<p class="author1">All of these take comma-separated lists of port numbers or port ranges, so
all of the following are legal:</p>
<dl class="calibre10">
<dt class="calibre11"><code class="calibre14">config.linkerd.io/opaque-ports: 25</code></dt>
<dd class="calibre12">
<p class="calibre13">This will treat only port 25 as opaque.</p>
</dd>
<dt class="calibre11"><code class="calibre14">config.linkerd.io/skip-inbound-ports: 3300,9900</code></dt>
<dd class="calibre12">
<p class="calibre13">This will skip connections coming in on port 3300 or 9900.</p>
</dd>
<dt class="calibre11"><code class="calibre14">config.linkerd.io/skip-inbound-ports: 8000-9000</code></dt>
<dd class="calibre12">
<p class="calibre13">This will skip connections coming in on any port between 8000 and 9000, inclusive.</p>
</dd>
<dt class="calibre11"><code class="calibre14">config.linkerd.io/skip-outbound-ports: 25,587,8000-9000</code></dt>
<dd class="calibre12">
<p class="calibre13">This will skip connections going out on port 25, port 587, or any port between 8000 and 9000, inclusive.</p>
</dd>
</dl>

<p class="author1">There’s also a <code class="calibre9">config.linkerd.io/skip-subnets</code> option, which skips any connection to
or from any listed subnets. <a data-primary="CIDR (Classless Inter-Domain Routing)" data-type="indexterm" id="id857" class="calibre4"/><a data-primary="Classless Inter-Domain Routing" data-see="CIDR" data-type="indexterm" id="id858" class="calibre4"/><a data-primary="CIDR (Classless Inter-Domain Routing)" data-secondary="documentation URL" data-type="indexterm" id="id859" class="calibre4"/><a data-primary="resources online" data-secondary="CIDR documentation" data-type="indexterm" id="id860" class="calibre4"/>Its argument is a comma-separated list of <a href="https://oreil.ly/soiAU" class="calibre4">Classless Inter-Domain Routing (CIDR)</a>
ranges—for example, <code class="calibre9">config.linkerd.io/skip-subnets: 10.0.0.0/8,192.168.1.0/24</code>.</p>
</div></section>








<section data-pdf-bookmark="Default Opaque Ports" data-type="sect2" class="preface"><div class="preface" id="id38">
<h2 class="calibre27">Default Opaque Ports</h2>

<p class="author1">As of Linkerd 2.12, several ports<a data-primary="opaque ports" data-secondary="default opaque ports" data-type="indexterm" id="id861" class="calibre4"/><a data-primary="ports" data-secondary="opaque and skip ports" data-tertiary="default opaque ports" data-type="indexterm" id="id862" class="calibre4"/><a data-primary="server-speaks-first protocols" data-secondary="default opaque ports" data-type="indexterm" id="id863" class="calibre4"/><a data-primary="protocol detection" data-secondary="unable to detect" data-tertiary="default opaque ports" data-type="indexterm" id="id864" class="calibre4"/> are marked as opaque by default (see the list in <a data-type="xref" href="ch03.html#default-opaque-ports" class="calibre4">“Default Opaque Ports”</a> for details).</p>

<p class="author1">The default ports are meant to allow various server-speaks-first protocols, such as MySQL and SMTP, to work seamlessly with Linkerd. <a data-primary="client-speaks-first protocols" data-secondary="default opaque ports" data-type="indexterm" id="id865" class="calibre4"/><a data-primary="Server resources" data-secondary="protocol detection" data-type="indexterm" id="id866" class="calibre4"/>If you’re using these ports for client-speaks-first protocols, you’ll need to use a
Server resource to override the port default (or—better—just choose a
different port for your client-speaks-first protocol!).<a data-startref="ch04-prot" data-type="indexterm" id="id867" class="calibre4"/><a data-startref="ch04-prot2" data-type="indexterm" id="id868" class="calibre4"/><a data-startref="ch04-prot3" data-type="indexterm" id="id869" class="calibre4"/><a data-startref="ch04-prot4" data-type="indexterm" id="id870" class="calibre4"/><a data-startref="ch04-prot5" data-type="indexterm" id="id871" class="calibre4"/><a data-startref="ch04-prot6" data-type="indexterm" id="id872" class="calibre4"/><a data-startref="ch04-prot7" data-type="indexterm" id="id873" class="calibre4"/></p>
</div></section>
</div></section>






<section class="preface" data-pdf-bookmark="Kubernetes Resource Limits" data-type="sect1"><div class="preface" id="id133">
<h1 class="calibre8">Kubernetes Resource Limits</h1>

<p class="author1">Compared to protocol detection,<a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="Kubernetes resource limits" data-type="indexterm" id="id874" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="Kubernetes resource limits" data-type="indexterm" id="id875" class="calibre4"/><a data-primary="Kubernetes" data-secondary="resource limits" data-type="indexterm" id="id876" class="calibre4"/><a data-primary="APIs" data-secondary="Kubernetes API" data-tertiary="resource limits" data-type="indexterm" id="id877" class="calibre4"/><a data-primary="architecture of Linkerd" data-secondary="sidecar model of service meshes" data-tertiary="Kubernetes resource limits" data-type="indexterm" id="id878" class="calibre4"/><a data-primary="Kubernetes" data-secondary="sidecar containers" data-tertiary="resource limits" data-type="indexterm" id="id879" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="Kubernetes resource limits" data-type="indexterm" id="id880" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="annotation values" data-type="indexterm" id="id881" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="annotation values" data-type="indexterm" id="id882" class="calibre4"/><a data-primary="sidecar model" data-secondary="adding workloads to the mesh" data-tertiary="annotation values" data-type="indexterm" id="id883" class="calibre4"/><a data-primary="Kubernetes API" data-secondary="Kubernetes resources" data-tertiary="resource limits" data-type="indexterm" id="id884" class="calibre4"/> Kubernetes resource limits are much more
straightforward. There’s a simple set of annotations to set that will allow you to specify resource requests and limits, as shown in <a data-type="xref" href="#linkerd_annotations_table_ch04" class="calibre4">Table 4-1</a>.</p>
<table id="linkerd_annotations_table_ch04" class="calibre44">
<caption class="calibre45"><span class="calibre">Table 4-1. </span>Linkerd annotations for resource requests and limits</caption>
<thead class="calibre46">
<tr class="calibre47">
<th class="calibre48">Annotation</th>
<th class="calibre48">Effect</th>
</tr>
</thead>
<tbody class="calibre49">
<tr class="calibre47">
<td class="calibre50"><p class="calibre51"><code class="calibre52">config.linkerd.io/proxy-cpu-limit</code></p></td>
<td class="calibre50"><p class="calibre51">Maximum amount of CPU units that the proxy sidecar can use</p></td>
</tr>
<tr class="calibre53">
<td class="calibre50"><p class="calibre51"><code class="calibre52">config.linkerd.io/proxy-cpu-request</code></p></td>
<td class="calibre50"><p class="calibre51">Amount of CPU units that the proxy sidecar requests</p></td>
</tr>
<tr class="calibre47">
<td class="calibre50"><p class="calibre51"><code class="calibre52">config.linkerd.io/proxy-ephemeral-storage-limit</code></p></td>
<td class="calibre50"><p class="calibre51">Used to override the <code class="calibre52">limitEphemeralStorage</code> config</p></td>
</tr>
<tr class="calibre53">
<td class="calibre50"><p class="calibre51"><code class="calibre52">config.linkerd.io/proxy-ephemeral-storage-request</code></p></td>
<td class="calibre50"><p class="calibre51">Used to override the <code class="calibre52">requestEphemeralStorage</code> config</p></td>
</tr>
<tr class="calibre47">
<td class="calibre50"><p class="calibre51"><code class="calibre52">config.linkerd.io/proxy-memory-limit</code></p></td>
<td class="calibre50"><p class="calibre51">Maximum amount of memory that the proxy sidecar can use</p></td>
</tr>
<tr class="calibre53">
<td class="calibre50"><p class="calibre51"><code class="calibre52">config.linkerd.io/proxy-memory-request</code></p></td>
<td class="calibre50"><p class="calibre51">Amount of memory that the proxy sidecar requests</p></td>
</tr>
</tbody>
</table>
</div></section>






<section data-pdf-bookmark="Summary" data-type="sect1" class="preface"><div class="preface" id="id315">
<h1 class="calibre8">Summary</h1>

<p class="author1">So there you have it: the start-to-finish guide for getting your workloads to
be an effective part of the Linkerd mesh. Hopefully you now have a good
understanding of how to make everything work, and of the gotchas along the way
(like server-speaks-first protocols). Next up is getting Linkerd and ingress
controllers to play nicely together.</p>
</div></section>
</div></section></body></html>