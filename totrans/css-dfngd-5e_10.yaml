- en: Chapter 10\. Floating and Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a very long time, floated elements were the basis of all our web layout
    schemes. (This is largely because of the property `clear`, which we’ll get to
    in a bit.) But floats were never meant for layout; their use as a layout tool
    was a hack nearly as egregious as the use of tables for layout. They were just
    what we had. Floats are quite interesting and useful in their own right, however.
    This is especially true given the recent addition of float *shaping*, which allows
    the creation of nonrectangular shapes that content can flow past.
  prefs: []
  type: TYPE_NORMAL
- en: Floating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since the early 1990s, it has been possible to float images by declaring,
    for instance, `<img src="b5.gif" alt="B4" align="right">`. This causes an image
    to float to the right and allows other content (such as text) to “flow around”
    the image. The name *floating*, in fact, came from the Netscape DevEdge page “Extensions
    to HTML 2.0,” which explained the then-new `align` attribute. Unlike HTML, CSS
    lets you float any element, from images to paragraphs to lists. This is accomplished
    using the property `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to float an image to the left, you could use this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As [Figure 10-1](#floating_image_fig) illustrates, the image “floats” to the
    left side of the browser window, and the text flows around it.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1001](assets/css5_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. A floating image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can float to the `left` or `right`, as well as to the `inline-start` and
    `inline-end` edges of an element. These latter two are useful when you want to
    float an element toward the start or end of the inline axis, regardless of the
    direction that axis is pointing. (See [Chapter 6](ch06.html#basic-visual-formatting)
    for details on the inline axis.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Throughout the rest of this section, we mostly stick to `left` and `right` because
    they simplify explanations. They will also be nearly the only `float` values you
    see in the wild, at least for the next few years.
  prefs: []
  type: TYPE_NORMAL
- en: Floated Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep a few points in mind with regard to floating elements. First, a floated
    element is, in some ways, removed from the normal flow of the document, although
    it still affects the layout of the normal flow. In a manner utterly unique within
    CSS, floated elements exist almost on their own plane, yet they still have influence
    over the rest of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'This influence arises because when an element is floated, other normal-flow
    content “flows around” it. This is familiar behavior with floated images, but
    the same is true if you float a paragraph, for example. In [Figure 10-2](#floating_paragraph_fig),
    you can see this effect quite clearly, thanks to the margin added to the floated
    paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1002](assets/css5_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. A floating paragraph
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One of the first facts to notice about floated elements is that margins around
    floated elements do not collapse. If you float an image and give it 25-pixel margins,
    there will be at least 25 pixels of space around that image. If other elements
    adjacent to the image—and that means adjacent horizontally *and* vertically—also
    have margins, those margins will not collapse with the margins on the floated
    image. The following code results in [Figure 10-3](#floating_images_with_margins_fig),
    with 50 pixels of space between the two floated images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1003](assets/css5_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Floating images with margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: No floating at all
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS has one other value for `float` besides the ones we’ve discussed: `float:
    none` is used to prevent an element from floating at all.'
  prefs: []
  type: TYPE_NORMAL
- en: This might seem a little silly, since the easiest way to keep an element from
    floating is to avoid declaring a `float`, right? Well, first of all, the default
    value of `float` is `none`. In other words, the value has to exist in order for
    normal, nonfloating behavior to be possible; without it, all elements would float
    in one way or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you might want to override floating in some cases. Imagine that you’re
    using a server-wide stylesheet that floats images. On one particular page, you
    don’t want those images to float. Rather than writing a whole new stylesheet,
    you could place `img {float: none;}` in your document’s embedded stylesheet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating: The Details'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start digging into details of floating, it’s important to establish
    the concept of a *containing block*. A floated element’s containing block is the
    nearest block-level ancestor element. Therefore, in the following markup, the
    floated element’s containing block is the paragraph element that contains it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ll return to the concept of containing blocks when we discuss positioning
    in [“Positioning”](#positioning).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, a floated element generates a block box, regardless of the kind
    of element it is. Thus, if you float a link, even though the element is inline
    and would ordinarily generate an inline box, it generates a block box. It will
    be laid out and act as if it was, for example, a `<div>`. This is not unlike declaring
    `display: block` for the floated element, although it is not necessary to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A series of specific rules govern the placement of a floated element, so let’s
    cover those before digging into applied behavior. These rules are vaguely similar
    to those that govern the evaluation of margins and widths and have the same initial
    appearance of common sense. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The left (or right) outer edge of a floated element may not be to the left (or
    right) of the inner edge of its containing block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is straightforward enough. The outer-left edge of a left-floated element
    can go only as far left as the inner-left edge of its containing block. Similarly,
    the farthest right a right-floated element may go is its containing block’s inner-right
    edge, as shown in [Figure 10-4](#floating_to_the_left_fig). (In this and subsequent
    figures, the circled numbers show the position where the markup element actually
    appears in relation to the source, and the numbered boxes show the position and
    size of the floated visible element.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1004](assets/css5_1004.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-4\. Floating to the left (or right)
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: To prevent overlap with other floated elements, the left outer edge of a floated
    element must be to the right of the right outer edge of a left-floating element
    that occurs earlier in the document source, unless the top of the latter element
    is below the bottom of the earlier element. Similarly, the right outer edge of
    a floated element must be to the left of the left outer edge of a right-floating
    element that comes earlier in the document source, unless the top of the latter
    element is below the bottom of the earlier element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This rule prevents floated elements from “overwriting” each other. If an element
    is floated to the left, and another floated element is already there, the latter
    element will be placed against the outer-right edge of the previously floated
    element. If, however, a floated element’s top is below the bottom of all earlier
    floated images, it can float all the way to the inner-left edge of the parent.
    [Figure 10-5](#keeping_floats_from_overlapping_fig) shows some examples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1005](assets/css5_1005.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-5\. Keeping floats from overlapping
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The advantage of this rule is that all your floated content will be visible,
    since you don’t have to worry about one floated element obscuring another. This
    makes floating a fairly safe thing to do. The situation is markedly different
    when using positioning, where it is very easy to cause elements to overwrite one
    another.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The right outer edge of a left-floating element may not be to the right of the
    left outer edge of any right-floating element to its right. The left outer edge
    of a right-floating element may not be to the left of the right outer edge of
    any left-floating element to its left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This rule prevents floated elements from overlapping each other. Let’s say you
    have a body that is 500 pixels wide, and its sole content is two images that are
    300 pixels wide. The first is floated to the left, and the second is floated to
    the right. This rule prevents the second image from overlapping the first by 100
    pixels. Instead, it is forced down until its top is below the bottom of the right-floating
    image, as depicted in [Figure 10-6](#more_overlap_prevention_fig).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1006](assets/css5_1006.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-6\. More overlap prevention
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: A floating element’s top may not be higher than the inner top of its parent.
    If a floating element is between two collapsing margins, the floated element is
    placed as though it had a block-level parent element between the two elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first part of this rule keeps floating elements from floating all the way
    to the top of the document. [Figure 10-7](#unlike_balloons_fig) illustrates the
    correct behavior. The second part of this rule fine-tunes the alignment in some
    situations—for example, when the middle of three paragraphs is floated. In that
    case, the floated paragraph is floated as if it had a block-level parent element
    (say, a `<div>`). This prevents the floated paragraph from moving up to the top
    of whatever common parent the three paragraphs share.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1007](assets/css5_1007.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-7\. Unlike balloons, floated elements can’t float upward
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: A floating element’s top may not be higher than the top of any earlier floating
    or block-level element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly to rule 4, rule 5 keeps floated elements from floating all the way
    to the top of their parent elements. It is also impossible for a floated element’s
    top to be any higher than the top of a floated element that occurs earlier. [Figure 10-8](#keeping_floats_below_fig)
    shows an example: since the second float was forced to be below the first one,
    the third float’s top is even with the top of the second float, not the first.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1008](assets/css5_1008.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-8\. Keeping floats below their predecessors
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: A floating element’s top may not be higher than the top of any line box that
    contains a box generated by an element that comes earlier in the document source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly to rules 4 and 5, this rule further limits the upward floating of
    an element by preventing it from being above the top of a line box containing
    content that precedes the floated element. Let’s say that, right in the middle
    of a paragraph, there is a floated image. The highest the top of that image may
    be placed is the top of the line box from which the image originates. As you can
    see in [Figure 10-9](#keeping_floats_level_fig), this keeps images from floating
    too far upward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1009](assets/css5_1009.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-9\. Keeping floats level with their context
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: A left-floating element that has another floating element to its left may not
    have its right outer edge to the right of its containing block’s right edge. Similarly,
    a right-floating element that has another floating element to its right may not
    have its right outer edge to the left of its containing block’s left edge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In other words, a floating element cannot stick out beyond the edge of its containing
    element, unless it’s too wide to fit on its own. This prevents a succeeding number
    of floated elements from appearing in a horizontal line and far exceeding the
    edges of the containing block. Instead, a float that would otherwise stick out
    of its containing block by appearing next to another one will be floated down
    to a point below any previous floats, as illustrated by [Figure 10-10](#if_theres_no_room_fig)
    (in the figure, the floats start on the next line in order to more clearly illustrate
    the principle at work here).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1010](assets/css5_1010.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-10\. If there isn’t room, floats get pushed to a new “line”
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: A floating element must be placed as high as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rule 8 is, as you might expect, subject to the restrictions introduced by the
    previous seven rules. Historically, browsers aligned the top of a floated element
    with the top of the line box after the one in which the image’s tag appears. Rule
    8, however, implies that its top should be even with the top of the same line
    box as that in which its tag appears, assuming there is enough room. [Figure 10-11](#given_the_other_constraints_fig)
    shows the theoretically correct behaviors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1011](assets/css5_1011.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-11\. Given the other constraints, go as high as possible
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: A left-floating element must be put as far to the left as possible, and a right-floating
    element as far to the right as possible. A higher position is preferred to one
    that is farther to the right or left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, this rule is subject to restrictions introduced in the preceding rules.
    As you can see in [Figure 10-12](#get_as_far_to_the_left_fig), it is pretty easy
    to tell when an element has gone as far as possible to the right or left.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![css5 1012](assets/css5_1012.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 10-12\. Get as far to the left (or right) as possible
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Applied Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several interesting consequences fall out of the rules we’ve just seen, both
    because of what they say and what they don’t say. The first topic to discuss is
    what happens when the floated element is taller than its parent element.
  prefs: []
  type: TYPE_NORMAL
- en: This happens quite often, as a matter of fact. Take the example of a short document,
    composed of no more than a few paragraphs and `<h3>` elements, where the first
    paragraph contains a floated image. Further, this floated image has a margin of
    5 pixels (`5px`). You would expect the document to be rendered as shown in [Figure 10-13](#expected_floating_fig).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-13\. Expected floating behavior
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Nothing there is unusual, but [Figure 10-14](#backgrounds_and_floated_elements)
    shows what happens when you set the first paragraph to have a background.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing is different about the second example, except for the visible background.
    As you can see, the floated image sticks out of the bottom of its parent element.
    It also did so in the first example, but it was less obvious there because you
    couldn’t see the background. The floating rules we discussed earlier address only
    the left, right, and top edges of floats and their parents. The deliberate omission
    of bottom edges requires the behavior in [Figure 10-14](#backgrounds_and_floated_elements).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1014.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-14\. Backgrounds and floated elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'CSS clarified this: one important aspect of floated-element behavior is that
    a floated element will expand to contain any floated descendants. Thus, you could
    contain a float within its parent element by floating the parent, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: On a related note, consider backgrounds and their relationship to floated elements
    that occur earlier in the document, which is illustrated in [Figure 10-15](#element_backgrounds_fig_).
  prefs: []
  type: TYPE_NORMAL
- en: Because the floated element is both within and outside of the flow, this sort
    of thing is bound to happen. What’s going on? The content of the heading is being
    “displaced” by the floated element. However, the heading’s element width is still
    as wide as its parent element. Therefore, its content area spans the width of
    the parent, and so does the background. The actual content doesn’t flow all the
    way across its own content area so that it can avoid being obscured behind the
    floating element.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-15\. Element backgrounds “slide under” floated elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Negative margins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interestingly, negative margins can cause floated elements to move outside of
    their parent elements. This seems to be in direct contradiction to the rules explained
    earlier, but it isn’t. In the same way that elements can appear to be wider than
    their parents through negative margins, floated elements can appear to protrude
    out of their parents.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an image that is floated to the left, and that has left and top
    margins of `-15px`. This image is placed inside a `<div>` that has no padding,
    borders, or margins. [Figure 10-16](#floating_with_negative_fig) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1016.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-16\. Floating with negative margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Contrary to appearances, this does not violate the restrictions on floated elements
    being placed outside their parent elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the technicality that permits this behavior: a close reading of the
    rules in the previous section will show that the outer edges of a floating element
    must be within the element’s parent. However, negative margins can place the floated
    element’s content such that it effectively overlaps its own outer edge, as detailed
    in [Figure 10-17](#the_details_of_floating_fig).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-17\. The details of floating up and left with negative margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One important question arises: what happens to the document display when an
    element is floated out of its parent element by using negative margins? For example,
    an image could be floated so far up that it intrudes into a paragraph that has
    already been displayed by the user agent. In such a case, it’s up to the user
    agent to decide whether the document should be reflowed.'
  prefs: []
  type: TYPE_NORMAL
- en: The CSS specification explicitly states that user agents are not required to
    reflow previous content to accommodate things that happen later in the document.
    In other words, if an image is floated up into a previous paragraph, it will probably
    overwrite whatever was already there. This makes the utility of negative margins
    on floats somewhat limited. Hanging floats are usually fairly safe, but trying
    to push an element upward on the page is generally a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: Another way for a floated element to exceed its parent’s inner left and right
    edges occurs when the floated element is wider than its parent. In that case,
    the floated element will overflow the right or left inner edge—depending on which
    way the element is floated—in its best attempt to display itself correctly. This
    will lead to a result like that shown in [Figure 10-18](#floating_an_element_thats_wider_fig).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1018.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-18\. Floating an element that is wider than its parent
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Floats, Content, and Overlapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An interesting question is this: what happens when a float overlaps content
    in the normal flow? This can happen if, for example, a float has a negative margin
    on the side where content is flowing past (e.g., a negative left margin on a right-floating
    element). You’ve already seen what happens to the borders and backgrounds of block-level
    elements. What about inline elements?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSS 2.1 specification states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An inline box that overlaps with a float has its borders, background, and content
    all rendered “on top” of the float.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A block box that overlaps with a float has its borders and background rendered
    “behind” the float, whereas its content is rendered “on top” of the float.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate these rules, consider the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To that markup, apply the following styles, with the result seen in [Figure 10-19](#layout_behavior_when_overlapping_fig):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-19\. Layout behavior when overlapping floats
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The inline element (`strong`) completely overlaps the floated image—background,
    border, content, and all. The block elements, on the other hand, have only their
    content appear on top of the float. Their backgrounds and borders are placed behind
    the float.
  prefs: []
  type: TYPE_NORMAL
- en: 'The described overlapping behavior is independent of the document source order.
    It does not matter if an element comes before or after a float: the same behaviors
    still apply.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve talked quite a bit about floating behavior, so we have only one more subject
    to discuss before we turn to shapes. You won’t always want your content to flow
    past a floated element—in some cases, you’ll specifically want to prevent it.
    If your document is grouped into sections, you might not want the floated elements
    from one section hanging down into the next.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, you’d want to set the first element of each section to prohibit
    floating elements from appearing next to it. If the first element might otherwise
    be placed next to a floated element, it will be pushed down until it appears below
    the floated image, and all subsequent content will appear after that, as shown
    in [Figure 10-20](#displaying_an_element_fig).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1020.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-20\. Displaying an element in the clear
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is done with `clear`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to make sure all `<h3>` elements are not placed to the right of
    left-floating elements, you would declare `h3 {clear: left;}`. This can be translated
    as “make sure that the left side of an `<h3>` is clear of floating elements and
    pseudo-elements.” The following rule uses `clear` to prevent `<h3>` elements from
    flowing past floated elements to the left side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While this will push the `<h3>` past any left-floating elements, it will allow
    floated elements to appear on the right side of `<h3>` elements, as shown in [Figure 10-21](#clear_to_the_left_fig).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1021.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-21\. Clear to the left, but not the right
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To avoid this sort of thing, and to make sure that `<h3>` elements do not coexist
    on a line with any floated elements, you use the value `both`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Understandably, this value prevents coexistence with floated elements on both
    sides of the cleared element, as demonstrated in [Figure 10-22](#clear_on_both_sides_fig).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1022.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-22\. Clear on both sides
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If, on the other hand, we were worried only about `<h3>` elements being pushed
    down past floated elements to their right, then we’d use `h3 {clear: right;}`.'
  prefs: []
  type: TYPE_NORMAL
- en: As with `float`, you can give `clear` the values `inline-start` (and `both`)
    or `inline-end`. If you’re floating with those values, clearing with them makes
    sense. If you’re floating using `left` and `right`, using those values for `clear`
    is sensible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `clear: none` allows elements to float to either side of an element.
    As with `float: none`, this value mostly exists to allow for normal document behavior,
    in which elements will permit floated elements to both sides. The `none` value
    can be used to override other styles, as shown in [Figure 10-23](#not_clear_at_all_fig).
    Despite the document-wide rule that `<h3>` elements will not permit floated elements
    to either side, one `<h3>` in particular has been set so that it does permit floated
    elements on either side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1023.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-23\. Not clear at all
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `clear` property works by way of *clearance*—extra spacing added above
    an element’s top margin in order to push it past any floated elements. This means
    that the top margin of a cleared element does not change when an element is cleared.
    Its downward movement is caused by the clearance instead. Pay close attention
    to the placement of the heading’s border in [Figure 10-24](#clearing_and_its_effect_fig),
    which results from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1024.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-24\. Clearing and its effect on margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is no separation between the top border of the `<h3>` and the bottom border
    of the floated image because 25 pixels of clearance was added above the 15-pixel
    top margin in order to push the `<h3>`’s top border edge just past the bottom
    edge of the float. This occurs unless the `<h3>`’s top margin calculates to 40
    pixels or more, in which case the `<h3>` will naturally place itself below the
    float, and the `clear` value will be irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, you can’t know how far an element needs to be cleared. The way
    to make sure a cleared element has some space between its top and the bottom of
    a float is to put a bottom margin on the float itself. Therefore, if you want
    at least 15 pixels of space below the float in the previous example, you would
    change the CSS like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The floated element’s bottom margin increases the size of the float box, and
    thus the point past which cleared elements must be pushed. This is because, as
    you’ve seen before, the margin edges of a floated element define the edges of
    the floated box.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind positioning is fairly simple. It allows you to define exactly
    where element boxes will appear relative to where they would ordinarily be—or
    position them in relation to a parent element, another element, or even to the
    viewport (e.g., the browser window) itself.
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into the various kinds of positioning, it’s a good idea to look
    at what types exist and how they differ.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Positioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can choose one of five types of positioning, which affect how the element’s
    box is generated, by using the `position` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of `position` have the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static`'
  prefs: []
  type: TYPE_NORMAL
- en: The element’s box is generated as normal. Block-level elements generate a rectangular
    box that is part of the document’s flow, and inline-level boxes cause the creation
    of one or more line boxes that are flowed within their parent element.
  prefs: []
  type: TYPE_NORMAL
- en: '`relative`'
  prefs: []
  type: TYPE_NORMAL
- en: The element’s box is offset by a certain distance; `0px` by default. The element
    retains the shape it would have had were it not positioned, and the space that
    the element would ordinarily have occupied is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: '`absolute`'
  prefs: []
  type: TYPE_NORMAL
- en: The element’s box is completely removed from the flow of the document and positioned
    relative to its closest positioned ancestor, if any, or its containing block,
    which may be another element in the document or the initial containing block (described
    in the next section). Whatever space the element might have occupied in the normal
    document flow is closed up, as though the element did not exist. The positioned
    element generates a block-level box, regardless of the type of box it would have
    generated if it were in the normal flow.
  prefs: []
  type: TYPE_NORMAL
- en: '`fixed`'
  prefs: []
  type: TYPE_NORMAL
- en: The element’s box behaves as though it was set to `absolute`, but its containing
    block is the viewport itself.
  prefs: []
  type: TYPE_NORMAL
- en: '`sticky`'
  prefs: []
  type: TYPE_NORMAL
- en: The element is left in the normal flow, until the conditions that trigger its
    stickiness come to pass, at which point it is removed from the normal flow but
    its original space in the normal flow is preserved. It will then act as if absolutely
    positioned with respect to its containing block. Once the conditions to enforce
    stickiness are no longer met, the element is returned to the normal flow in its
    original space.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry so much about the details right now, as we’ll look at each of these
    kinds of positioning later. Before we do that, we need to discuss containing blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The Containing Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general terms, a *containing block* is the box that contains another element,
    as we said earlier in the chapter. As an example, in the normal-flow case, the
    root element (`<html>` in HTML) is the containing block for the `<body>` element,
    which is in turn the containing block for all its children, and so on. When it
    comes to positioning, the containing block depends entirely on the type of positioning.
  prefs: []
  type: TYPE_NORMAL
- en: For a nonroot element whose `position` value is `relative` or `static`, its
    containing block is formed by the content edge of the nearest block-level, table-cell,
    or inline-block ancestor box.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a nonroot element that has a `position` value of `absolute`, its containing
    block is set to the nearest ancestor (of any kind) that has a `position` value
    other than `static`. This happens as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the ancestor is block-level, the containing block is set to be that element’s
    padding edge; in other words, the area that would be bounded by a border.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ancestor is inline-level, the containing block is set to the content
    edge of the ancestor. In left-to-right languages, the top and left of the containing
    block are the top and left content edges of the first box in the ancestor, and
    the bottom and right edges are the bottom and right content edges of the last
    box. In right-to-left languages, the right edge of the containing block corresponds
    to the right content edge of the first box, and the left is taken from the last
    box. The top and bottom are the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no ancestors, the element’s containing block is defined to be the
    initial containing block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s an interesting variant to the containing-block rules when it comes to
    sticky-positioned elements, which is that a rectangle is defined in relation to
    the containing block called the *sticky-constraint rectangle*. This rectangle
    has everything to do with how sticky positioning works, and will be explained
    in full in [“Sticky Positioning”](#sticky-positioning).
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point: elements can be positioned outside of their containing
    block. This suggests that the term “containing block” should really be “positioning
    context,” but since the specification uses “containing block,” so will we.'
  prefs: []
  type: TYPE_NORMAL
- en: Offset Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Four of the positioning schemes described in the previous section—relative,
    absolute, sticky, and fixed—use distinct properties to describe the offset of
    a positioned element’s sides with respect to its containing block. These properties,
    which are referred to as the *offset properties*, are a big part of what makes
    positioning work. There are four physical offset properties and four logical offset
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: These properties describe an offset from the nearest side of the containing
    block (thus the term *offset properties*). The simplest way to look at it is that
    positive values cause inward offsets, moving the edges toward the center of the
    containing block, and negative values cause outward offsets.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `top` describes how far the top margin edge of the positioned element
    should be placed from the top of its containing block. In the case of `top`, positive
    values move the top margin edge of the positioned element *downward*, while negative
    values move it *above* the top of its containing block. Similarly, `left` describes
    how far to the right (for positive values) or left (for negative values) the left
    margin edge of the positioned element is from the left edge of the containing
    block. Positive values will shift the margin edge of the positioned element to
    the right, and negative values will move it to the left.
  prefs: []
  type: TYPE_NORMAL
- en: The implication of offsetting the margin edges is that it’s possible to set
    margins, borders, and padding for a positioned element; these will be preserved
    and kept with the positioned element, and they will be contained within the area
    defined by the offset properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to remember that the offset properties define an offset from
    the analogous side (e.g., `inset-block-end` defines the offset from the block-end
    side) of the containing block, not from the upper-left corner of the containing
    block. This is why, for example, one way to fill up the lower-right corner of
    a containing block is to use these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the outer-left edge of the positioned element is placed halfway
    across the containing block. This is its offset from the left edge of the containing
    block. The outer-right edge of the positioned element, on the other hand, is not
    offset from the right edge of the containing block, so the two are coincident.
    Similar reasoning holds true for the top and bottom of the positioned element:
    the outer-top edge is placed halfway down the containing block, but the outer-bottom
    edge is not moved up from the bottom. This leads to what’s shown in [Figure 10-25](#filling_lower-right-quarter).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1025](assets/css5_1025.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-25\. Filling the lower-right quarter of the containing block
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What’s depicted in [Figure 10-25](#filling_lower-right-quarter), and in most
    of the examples in this chapter, is based around absolute positioning. Since absolute
    positioning is the simplest scheme in which to demonstrate how the offset properties
    work, we’ll stick to that for now.
  prefs: []
  type: TYPE_NORMAL
- en: Note the background area of the positioned element. In [Figure 10-25](#filling_lower-right-quarter),
    it has no margins, but if it did, they would create blank space between the borders
    and the offset edges. This would make the positioned element appear as though
    it did not completely fill the lower-right quarter of the containing block. In
    truth, it *would* fill the area, because margins count as part of the area of
    a positioned element, but this fact wouldn’t be immediately apparent to the eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the following two sets of styles would have approximately the same visual
    appearance, assuming that the containing block is `100em` high by `100em` wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'By using negative offset values, we can position an element outside its containing
    block. For example, the following values will lead to the result shown in [Figure 10-26](#positioning_outside_block):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1026](assets/css5_1026.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-26\. Positioning an element outside its containing block
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to length and percentage values, the offset properties can be set
    to `auto`, which is the default value. There is no single behavior for `auto`;
    it changes based on the type of positioning used. We’ll explore how `auto` works
    later, as we consider each of the positioning types in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Inset Shorthands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the logical inset properties mentioned in the previous section,
    CSS has a few inset shorthand properties: two logical and one physical.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For both properties, you can supply one or two values. If you supply one, the
    same value is used for both sides; that is, `inset-block: 10px` will use 10 pixels
    of inset for both the block-start and block-end edges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you supply two values, the first is used for the start edge, and the second
    for the end edge. Thus, `inset-inline: 1em 2em` will use 1 em of inset for the
    inline start edge, and 2 ems of inset for the inline end edge.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s usually a lot easier to use these two shorthands for logical insets, since
    you can always supply `auto` when you don’t want to set a specific offset—for
    example, `inset-block: 25% auto`.'
  prefs: []
  type: TYPE_NORMAL
- en: The shorthand for all four edges in one property is called `inset`, but it’s
    a physical property—it’s shorthand for `top`, `bottom`, `left`, and `right`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, it looks like this should be shorthand for the logical properties, but
    it isn’t. The following two rules have the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As with other physical shorthands such as those seen in [Chapter 7](ch07.html#padding-borders-outlines-and-margins),
    the values are in the order TRBL (top, right, bottom, left), and an omitted value
    is copied from the opposite side. Thus, `inset: 20px 2em` is the same as writing
    `inset: 20px 2em 20px 2em`.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Width and Height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After determining where you’re going to position an element, you will often
    want to declare how wide and how high that element should be. In addition, you’ll
    likely want to limit how high or wide a positioned element gets.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to give your positioned element a specific width, the property to
    turn to is `width`. Similarly, `height` will let you declare a specific height
    for a positioned element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is sometimes important to set the `width` and `height` of a positioned
    element, it is not always necessary. For example, if the placement of the four
    sides of the element is described using `top`, `right`, `bottom`, and `left` (or
    with `inset-block-start`, `inset-inline-start`, etc.), then the `height` and `width`
    of the element are implicitly determined by the offsets. Assume that we want an
    absolutely positioned element to fill the left half of its containing block, from
    top to bottom. We could use these values, with the result depicted in [Figure 10-27](#positioning_offset_only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1027](assets/css5_1027.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-27\. Positioning and sizing an element by using only the offset properties
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since the default value of both `width` and `height` is `auto`, the result
    shown in [Figure 10-27](#positioning_offset_only) is exactly the same as if we
    had used these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The presence of `width` and `height` in this specific example adds nothing to
    the layout of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to add padding, a border, or a margin to the element, the presence
    of explicit values for `height` and `width` could very well make a difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will give us a positioned element that extends out of its containing block,
    as shown in [Figure 10-28](#positioning_partially_outside_block).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1028](assets/css5_1028.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-28\. Positioning an element partially outside its containing block
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This happens because (by default) the padding is added to the content area,
    and the content area’s size is determined by the values of `height` and `width`.
    To get the padding we want and still have the element fit inside its containing
    block, we would either remove the `height` and `width` declarations, explicitly
    set them both to `auto`, or set `box-sizing` to `border-box`.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting Width and Height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Should it become necessary or desirable, you can place limits on an element’s
    width by using the following properties, which we’ll refer to as the *min-max
    properties*. An element’s content area can be defined to have minimum dimensions
    by using `min-width` and `min-height`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, an element’s dimensions can be limited using the properties `max-width`
    and `max-height`.
  prefs: []
  type: TYPE_NORMAL
- en: The names of these properties make them fairly self-explanatory. What’s less
    obvious at first, but makes sense once you think about it, is that values for
    all these properties cannot be negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following styles will force the positioned element to be at least `10em`
    wide by `20em` tall, as illustrated in [Figure 10-29](#setting_minimum_width_height):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1029.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-29\. Setting a minimum width and height for a positioned element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This isn’t a very robust solution since it forces the element to be at least
    a certain size regardless of the size of its containing block. Here’s a better
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the element should be 40% as wide as the containing block but can never
    be less than `15em` wide. We’ve also changed the `bottom` and `height` so that
    they’re automatically determined. This will let the element be as tall as necessary
    to display its content, no matter how narrow it gets (never less than `15em`,
    though!).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll look at the role `auto` plays in the height and width of positioned elements
    in [“Placement and Sizing of Absolutely Positioned Elements”](#placement-and-sizing-of-absolutely-positioned-elements).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can turn all this around to keep elements from getting too wide or tall
    by using `max-width` and `max-height`. Let’s imagine that, for some reason, we
    want an element to have three-quarters the width of its containing block but to
    stop getting wider when it hits 400 pixels. The appropriate styles are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: One great advantage of the min-max properties is that they let you mix units
    with relative safety. You can use percentage-based sizes while setting length-based
    limits, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth mentioning that these min-max properties can be very useful in conjunction
    with floated elements. For example, we can allow a floated element’s width to
    be relative to the width of its parent element (which is its containing block),
    while making sure that the float’s width never goes below `10em`. The reverse
    approach is also possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will set the float to `40em` wide, unless that would be more than 40% the
    width of the containing block, in which case the float will be limited to that
    40% width.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For details on what to do with content that overflows an element when it’s been
    constrained to a certain maximum size, see [“Handling Content Overflow”](ch06.html#overflow).
  prefs: []
  type: TYPE_NORMAL
- en: Absolute Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since most of the examples and figures in the previous sections illustrate absolute
    positioning, you’ve already seen a bunch of it in action. Most of what remains
    are the details of what happens when absolute positioning is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Containing Blocks and Absolutely Positioned Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an element is positioned absolutely, it is completely removed from the
    document flow. It is then positioned with respect to its closest positioned ancestor,
    if any, otherwise its containing block, and its margin edges are placed using
    the offset properties (`top`, `left`, `inset-inline-start`, etc.). The positioned
    element does not flow around the content of other elements, nor does their content
    flow around the positioned element. This implies that an absolutely positioned
    element may overlap other elements or be overlapped by them. (We’ll see how to
    affect the overlapping order later.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The containing block for an absolutely positioned element is the nearest ancestor
    element that has a `position` value other than `static`. It is common for an author
    to pick an element that will serve as the containing block for the absolutely
    positioned element and give it a `position` of `relative` with no offsets, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the example in [Figure 10-30](#using_relative_positioning), which
    illustrates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<b>` elements in both paragraphs have been absolutely positioned. The
    difference is in the containing block used for each one. The `<b>` element in
    the first paragraph is positioned with respect to the initial containing block,
    because all of its ancestor elements have a `position` of `static`. The second
    paragraph has been set to `position: relative`, so it establishes a containing
    block for its descendants.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1030.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-30\. Using relative positioning to define containing blocks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ve probably noted that in that second paragraph, the positioned element
    overlaps some of the text content of the paragraph. There is no way to avoid this,
    short of positioning the `<b>` element outside of the paragraph or specifying
    a padding for the paragraph that is wide enough to accommodate the positioned
    element. Also, since the `<b>` element has a transparent background, the paragraph’s
    text shows through the positioned element. The only way to avoid this is to set
    a background for the positioned element, or else move it out of the paragraph
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the containing block is the root element, you could drop in an absolutely
    positioned paragraph, as follows, and get a result like that shown in [Figure 10-31](#positioning_element_contained_by_root):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The paragraph is now positioned at the very beginning of the document, half
    as wide as the document’s width and overwriting other content.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1031.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-31\. Positioning an element whose containing block is the root element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An important point to highlight is that when an element is absolutely positioned,
    it establishes a containing block for its descendant elements. For example, we
    can absolutely position an element and then absolutely position one of its children
    by using the following styles and basic markup (depicted in [Figure 10-32](#containing_blocks_from_absolute_pos)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember that if the document is scrolled, the absolutely positioned elements
    will scroll right along with it. This is true of all absolutely positioned elements
    that are not descendants of fixed-position or sticky-position elements.
  prefs: []
  type: TYPE_NORMAL
- en: This happens because, eventually, the elements are positioned in relation to
    something that’s part of the normal flow. For example, if you absolutely position
    a table, and its containing block is the initial containing block, then the positioned
    table will scroll because the initial containing block is part of the normal flow,
    and thus it scrolls.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to position elements so that they’re placed relative to the viewport
    and don’t scroll along with the rest of the document, keep reading. [“Fixed Positioning”](#fixed-positioning)
    has the answers you seek.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1032.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-32\. Absolutely positioned elements establish containing blocks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Placement and Sizing of Absolutely Positioned Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Combining the concepts of placement and sizing may seem odd, but it’s a necessity
    with absolutely positioned elements because the specification binds them closely
    together. This is not such a strange pairing, upon reflection. Consider what happens
    if an element is positioned using the four physical offset properties, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the height and width of the `<h1>`’s element box is determined by the
    placement of its outer margin edges, as shown in [Figure 10-33](#determining_height_based_on_offset).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1033.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-33\. Determining the height of an element based on the offset properties
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the containing block were made taller, the `<h1>` would also become taller;
    if the containing block were narrowed, the `<h1>` would become narrower. If we
    were to add margins or padding to the `<h1>`, that would have further effects
    on its calculated height and width.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we do all that and then also try to set an explicit height and width?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Something has to give, because it’s incredibly unlikely that all those values
    will be accurate. In fact, the containing block would have to be exactly two and
    a half times as wide as the `<h1>`’s computed value of `font-size` for all of
    the shown values to be accurate. Any other `width` would mean at least one value
    is wrong and has to be ignored. Figuring out which one depends on multiple factors,
    and the factors change depending on whether an element is replaced or nonreplaced.
    (See [Chapter 6](ch06.html#basic-visual-formatting) for replaced versus nonreplaced
    elements.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For that matter, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What should the result be? As it happens, the answer is *not* “reset the values
    to 0.” We’ll see the actual answer, starting in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-edges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When absolutely positioning an element, a special behavior applies when any
    of the offset properties other than `bottom` are set to `auto`. Let’s take `top`
    as an example. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What should happen? For `left`, the left edge of the element should be placed
    against the left edge of its containing block (which we’ll assume here to be the
    initial containing block).
  prefs: []
  type: TYPE_NORMAL
- en: For `top`, however, something much more interesting happens. The top of the
    positioned element should line up with the place where its top would have been
    if it were not positioned at all. In other words, imagine where the `<span>` would
    have been placed if its `position` value were `static`; this is its *static position*—the
    place where its top edge should be calculated to sit. Therefore, we should get
    the result shown in [Figure 10-34](#using_static_top_for_absolute_pos).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1034.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-34\. Absolutely positioning an element consistently with its “static”
    top edge
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The “[4]” sits just outside the paragraph’s content because the initial containing
    block’s left edge is to the left of the paragraph’s left edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same basic rules hold true for `left` and `right` being set to `auto`.
    In those cases, the left (or right) edge of a positioned element lines up with
    the spot where the edge would have been placed if the element weren’t positioned.
    So let’s modify our previous example so that both `top` and `left` are set to
    `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This results in [Figure 10-35](#static_pos_for_absolute_pos).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1035.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-35\. Absolutely positioning an element consistently with its “static”
    position
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The “[4]” now sits right where it would have were it not positioned. Note that,
    since it *is* positioned, its normal-flow space is closed up. This causes the
    positioned element to overlap the normal-flow content.
  prefs: []
  type: TYPE_NORMAL
- en: 'This auto-placement works only in certain situations, generally wherever there
    are few constraints on the other dimensions of a positioned element. Our previous
    example could be auto-placed because it had no constraints on its height or width,
    nor on the placement of the bottom and right edges. But suppose, for some reason,
    there had been such constraints. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to satisfy all of those values. Determining what happens
    is the subject of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Placing and Sizing Nonreplaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, the size and placement of an element depends on its containing block.
    The values of its various properties (`width`, `right`, `padding-left`, and so
    on) affect its layout, but the foundation is the containing block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the width and horizontal placement of a positioned element. It can
    be represented as an equation that states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This calculation is fairly reasonable. It’s basically the equation that determines
    how block-level elements in the normal flow are sized, except it adds `left` and
    `right` to the mix. So how do all these interact? We have a series of rules to
    work through.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if `left`, `width`, and `right` are all set to `auto`, you get the result
    seen in the previous section: the left edge is placed at its static position,
    assuming a left-to-right language. In right-to-left languages, the right edge
    is placed at its static position. The width of the element is set to be “shrink
    to fit,” which means the element’s content area is made only as wide as necessary
    to contain its content. The nonstatic position property (`right` in left-to-right
    languages, `left` in right-to-left) is set to take up the remaining distance.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This results in [Figure 10-36](#shrink-to-fit).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1036.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-36\. The “shrink-to-fit” behavior of absolutely positioned elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The top of the element is placed against the top of its containing block (the
    `<div>`, in this case), and the width of the element is just as wide as is needed
    to contain the content. The remaining distance from the right edge of the element
    to the right edge of the containing block becomes the computed value of `right`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose that only the left and right margins are set to `auto`, not `left`,
    `width`, and `right`, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What happens here is that the left and right margins, which are both `auto`,
    are set to be equal. This will effectively center the element, as shown in [Figure 10-37](#horizontally_centering_with_auto_margins).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1037.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-37\. Horizontally centering an absolutely positioned element with
    `auto` margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is basically the same as `auto`-margin centering in the normal flow. So
    let’s make the margins something other than `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a problem. The positioned `<span>`’s properties add up to only `14em`,
    whereas the containing block is `25em` wide. That’s an 11-em deficit we have to
    make up somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules state that, in this case, the user agent ignores the value for the
    inline-end side of the element and solves for that. In other words, the result
    will be the same as if we’d declared this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This results in [Figure 10-38](#ignoring_value_for_right).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1038.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-38\. Ignoring the value for `right` in an overconstrained situation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If one of the margins had been set to `auto`, that would have been changed
    instead. Suppose we change the styles to state the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The visual result would be the same as that in [Figure 10-38](#ignoring_value_for_right),
    only it would be attained by computing the right margin to `12em` instead of overriding
    the value assigned to the property `right`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, we made the left margin `auto`, *it* would be reset,
    as illustrated in [Figure 10-39](#ignoring_margin-right):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1039.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-39\. Making use of an `auto` left margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In general, if only one of the properties is set to `auto`, that property will
    be used to satisfy the equation given earlier in the section. Thus, given the
    following styles, the element’s width would expand to whatever size is needed,
    instead of “shrink-wrapping” the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'So far we’ve really examined behavior only along the horizontal axis, but very
    similar rules hold true along the vertical axis. If we take the previous discussion
    and rotate it 90 degrees, as it were, we get almost the same behavior. For example,
    the following markup results in [Figure 10-40](#vertical_layout_behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the height of the element is shrink-wrapped to the content.
    In the second, the unspecified property (`bottom`) is set to make up the distance
    between the bottom of the positioned element and the bottom of its containing
    block. In the third case, `top` is unspecified, and therefore used to make up
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1040.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-40\. Vertical layout behavior for absolutely positioned elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For that matter, auto-margins can lead to vertical centering. Given the following
    styles, the absolutely positioned `<div>` will be vertically centered within its
    containing block, as shown in [Figure 10-41](#vertically_centering_with_auto_margins):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1041](assets/css5_1041.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-41\. Vertically centering an absolutely positioned element with auto-margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are two small variations to point out. In horizontal layout, either `right`
    or `left` can be placed according to the static position if their values are `auto`.
    In vertical layout, only `top` can take on the static position; `bottom`, for
    whatever reason, cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if an absolutely positioned element’s size is overconstrained in the
    vertical direction, `bottom` is ignored. Thus, in the following situation, the
    declared value of `bottom` would be overridden by the calculated value of `5em`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There is no provision for `top` to be ignored if the properties are overconstrained.
  prefs: []
  type: TYPE_NORMAL
- en: Placing and Sizing Replaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Positioning rules are different for replaced elements (e.g., images) than they
    are for nonreplaced elements. This is because replaced elements have an intrinsic
    height and width, and therefore are not altered unless explicitly changed by the
    author. Thus, there is no concept of “shrink to fit” in the positioning of replaced
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behaviors that go into placing and sizing replaced elements are most easily
    expressed by this series of rules, to be taken one after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: If `width` is set to `auto`, the used value of `width` is determined by the
    intrinsic width of the element’s content. Thus, if an image is intrinsically 50
    pixels wide, the used value is calculated to be `50px`. If `width` is explicitly
    declared (that is, something like `100px` or `50%`), the width is set to that
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `left` has the value `auto` in a left-to-right language, replace `auto` with
    the static position. In right-to-left languages, replace an `auto` value for `right`
    with the static position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either `left` or `right` is still `auto` (in other words, it hasn’t been
    replaced in a previous step), replace any `auto` on `margin-left` or `margin-right`
    with `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, at this point, both `margin-left` and `margin-right` are still defined to
    be `auto`, set them to be equal, thus centering the element in its containing
    block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all that, if only one `auto` value is left, change it to equal the remainder
    of the equation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This leads to the same basic behaviors you saw with absolutely positioned nonreplaced
    elements, as long as you assume that there is an explicit `width` for the nonreplaced
    element. Therefore, the following two elements will have the same width and placement,
    assuming the image’s intrinsic width is 100 pixels (see [Figure 10-42](#absolutely_positioning_replaced_element)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1042](assets/css5_1042.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-42\. Absolutely positioning a replaced element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As with nonreplaced elements, if the values are overconstrained, the user agent
    is supposed to ignore the value on the inline-end side: `right` in left-to-right
    languages and `left` in right-to-left languages. Thus, in the following example,
    the declared value for `right` is overridden with a computed value of `50px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, layout along the vertical axis is governed by this series of rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If `height` is set to `auto`, the computed value of `height` is determined by
    the intrinsic height of the element’s content. Thus, the height of an image 50
    pixels tall is computed to be `50px`. If `height` is explicitly declared (that
    is, something like `100px` or `50%`), the height is set to that value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `top` has the value `auto`, replace it with the replaced element’s static
    position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `bottom` has a value of `auto`, replace any `auto` value on `margin-top`
    or `margin-bottom` with `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, at this point, both `margin-top` and `margin-bottom` are still defined to
    be `auto`, set them to be equal, thus centering the element in its containing
    block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After all that, if only one `auto` value is left, change it to equal the remainder
    of the equation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As with nonreplaced elements, if the values are overconstrained, the user agent
    is supposed to ignore the value for `bottom`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the following markup results in [Figure 10-43](#stretching_replaced_elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1043](assets/css5_1043.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-43\. Stretching replaced elements through positioning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Placement on the Z-Axis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With all of the positioning going on, there will inevitably be a situation where
    two elements will try to exist in the same place, visually speaking. One of them
    will have to overlap the other—so how do we control which element comes out “on
    top”? This is where `z-index` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: This property lets you alter the way that elements overlap one another. It takes
    its name from the coordinate system in which side-to-side is the x-axis and top-to-bottom
    is the y-axis. In such a case, the third axis—which runs from back to front, as
    you look at the display surface—is termed the *z-axis*. Thus, elements are given
    values along this axis by using `z-index`. [Figure 10-44](#conceptual_view_of_zindex)
    illustrates this system.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1044](assets/css5_1044.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-44\. A conceptual view of z-index stacking
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this coordinate system, an element with a higher `z-index` value is closer
    to the reader than those with lower `z-index` values. This will cause the high-value
    element to overlap the others, as illustrated in [Figure 10-45](#how_elements_are_stacked),
    which is a “head-on” view of [Figure 10-44](#conceptual_view_of_zindex). This
    precedence of overlapping is referred to as *stacking*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1045.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-45\. How the elements are stacked
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Any integer can be used as a value for `z-index`, including negative numbers.
    Assigning an element a negative `z-index` will move it further away from the reader;
    that is, it will be moved lower in the stack. Consider the following styles, illustrated
    in [Figure 10-46](#stacked_elements_can_overlap):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Each of the elements is positioned according to its styles, but the usual order
    of stacking is altered by the `z-index` values. Assuming the paragraphs were in
    numeric order, a reasonable stacking order would have been, from lowest to highest,
    `p#first`, `p#second`, `p#third`, `p#fourth`. This would have put `p#first` behind
    the other three elements, and `p#fourth` in front of the others. Thanks to `z-index`,
    the stacking order is under your control.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1046.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-46\. Stacked elements can overlap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the previous example demonstrates, the `z-index` values don’t need to be
    contiguous. You can assign any integer of any size. If you want to be fairly certain
    that an element stays in front of everything else, you might use a rule along
    the lines of `z-index: 100000`. This would work as expected in most cases—although
    if you ever declared another element’s `z-index` to be `100001` (or higher), it
    would appear in front.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you assign an element a value for `z-index` (other than `auto`), that
    element establishes its own local *stacking context*. This means that all of the
    element’s descendants have their own stacking order, except relative to their
    ancestor element. This is very similar to the way that elements establish new
    containing blocks. Given the following styles, you would see something like [Figure 10-47](#local_stacking_from_positioned):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1047.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-47\. Positioned elements establish local stacking contexts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note where the `<em>` elements fall in the stacking order (you can find a list
    of the various ways to establish a stacking context in [“Blending in Isolation”](ch20.html#blending-in-isolation1)
    in [Chapter 20](ch20.html#filters-compositing)). Each is correctly layered with
    respect to its parent element. Each `<em>` is drawn in front of its parent element,
    whether or not its `z-index` is negative, and parents and children are grouped
    together like layers in an editing program. (The specification keeps children
    from being drawn behind their parents when using `z-index` stacking, so the `em`
    in `p#three` is drawn on top of `p#one`, even though its `z-index` value is `-343`.)
    This is because its `z-index` value is taken with respect to its local stacking
    context: its containing block. That containing block, in turn, has a `z-index`,
    which operates within its local stacking context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more `z-index` value to examine. The CSS specification has this
    to say about the default value, `auto`:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack level of the generated box in the current stacking context is 0\.
    The box does not establish a new stacking context unless it is the root element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So, any element with `z-index: auto` can be treated as though it is set to
    `z-index: 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`z-index` is also honored by flex and grid items, even though they are not
    positioned using the `position` property. The rules are essentially the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As implied in a previous section, *fixed positioning* is just like absolute
    positioning, except the containing block of a fixed element is the *viewport*.
    A fixed-position element is totally removed from the document’s flow and does
    not have a position relative to any part of the document.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed positioning can be exploited in interesting ways. First off, it’s possible
    to create frame-style interfaces by using fixed positioning. Consider [Figure 10-48](#emulating_frames_with_fixed),
    which shows a common layout scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1048.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-48\. Emulating frames with fixed positioning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This could be done using the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fix the header and sidebar to the top and side of the viewport, where
    they will remain regardless of how the document is scrolled. The drawback here,
    though, is that the rest of the document will be overlapped by the fixed elements.
    Therefore, the rest of the content should probably be contained in its own wrapper
    element and employ something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It would even be possible to create small gaps between the three positioned
    elements by adding some appropriate margins, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Given such a case, a tiled image could be applied to the `<body>` background.
    This image would show through the gaps created by the margins, which could certainly
    be widened if the author saw fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another use for fixed positioning is to place a “persistent” element on the
    screen, like a short list of links. We could create a persistent `footer` with
    copyright and other information as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This would place the `footer` element at the bottom of the viewport and leave
    it there no matter how much the document is scrolled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many of the layout cases for fixed positioning, besides “persistent elements,”
    are handled as well, if not better, by grid layout (see [Chapter 12](ch12.html#grid-layout)
    for more).
  prefs: []
  type: TYPE_NORMAL
- en: Relative Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest of the positioning schemes to understand is *relative positioning*.
    In this scheme, a positioned element is shifted by use of the offset properties.
    However, this can have some interesting consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the surface, it seems simple enough. Suppose we want to shift an image up
    and to the left. [Figure 10-49](#relatively_positioned_element) shows the result
    of these styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1049.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-49\. A relatively positioned element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All we’ve done here is offset the image’s top-edge 20 pixels upward and offset
    the left-edge 20 pixels to the left. However, notice the blank space where the
    image would have been had it not been positioned. This happened because when an
    element is relatively positioned, it’s shifted from its normal place, but the
    space it would have occupied doesn’t disappear.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Relative positioning is very similar to translation element transforms, which
    are discussed in [Chapter 17](ch17.html#transforms).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the results of the following styles, which are depicted in [Figure 10-50](#another_relatively_positioned_element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1050.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-50\. Another relatively positioned element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, the paragraph has some blank space in it. This is where the
    `<em>` element would have been, and the layout of the `<em>` element in its new
    position exactly mirrors the space it left behind.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to shift a relatively positioned element to overlap other
    content. For example, the following styles and markup are illustrated in [Figure 10-51](#relatively_positioned_elements_overlap_content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1051.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-51\. Relatively positioned elements can overlap other content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Relative positioning has one interesting wrinkle. What happens when a relatively
    positioned element is overconstrained? For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have values that call for two very different behaviors. If we consider
    only `top: 10px`, the element should be shifted downward 10 pixels, but `bottom:
    20px` clearly calls for the element to be shifted upward 20 pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS states that when it comes to overconstrained relative positioning, one
    value is reset to be the negative of the other. Thus, `bottom` would always equal
    `-top`. This means the previous example would be treated as though it had been
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the `<strong>` element will be shifted downward 10 pixels. The specification
    also makes allowances for writing directions. In relative positioning, `right`
    always equals `-left` in left-to-right languages; but in right-to-left languages,
    this is reversed: `left` always equals `-right`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you saw in previous sections, when we relatively position an element, it
    immediately establishes a new containing block for any of its children. This containing
    block corresponds to the place where the element has been newly positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Sticky Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last type of positioning in CSS is *sticky positioning*. If you’ve ever
    used a decent music app on a mobile device, you’ve probably noticed this in action:
    as you scroll through an alphabetized list of artists, the current letter stays
    stuck at the top of the window until a new letter section is entered, at which
    point the new letter replaces the old. It’s a little hard to show in print, but
    [Figure 10-52](#sticky_positioning) takes a stab at it by showing three points
    in a scroll.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1052.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-52\. Sticky positioning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'CSS makes this sort of thing possible by declaring an element to be `position:
    sticky`, but (as usual) there’s more to it than that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, the offsets (`top`, `left`, etc.) are used to define a *sticky-positioning
    rectangle* with relation to the containing block. Take the following as an example.
    It will have the effect shown in [Figure 10-53](#sticky-positioning_rectangle),
    where the dashed line shows where the sticky-positioning rectangle is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1053](assets/css5_1053.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-53\. The sticky-positioning rectangle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the `<h2>` is in the middle of the rectangle in [Figure 10-53](#sticky-positioning_rectangle).
    That’s its place in the normal flow of the content inside the `#scrollbox` element.
    The only way to make the `<h2>` sticky is to scroll that content until the top
    of the `<h2>` touches the top of the sticky-positioning rectangle (which is `2em`
    below the top of the scrollbox)—at which point, the `<h2>` will stick there. This
    is illustrated in [Figure 10-54](#sticking_to_the_top).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1054.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-54\. Sticking to the top of the sticky-positioning rectangle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In other words, the `<h2>` sits in the normal flow until its sticky edge touches
    the sticky edge of the sticky-positioning rectangle. At that point, it sticks
    there as if absolutely positioned, *except* that it leaves behind the space it
    otherwise would have occupied in the normal flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the `#scrollbox` element doesn’t have a `position`
    declaration. One isn’t hiding offstage, either: it’s the `overflow: scroll` set
    on `#scrollbox` that creates a containing block for the sticky-positioned `<h2>`
    elements. This is a case where a containing block isn’t determined by `position`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the scrolling is reversed so that the `<h2>`’s normal-flow position moves
    lower than the top of the rectangle, the `<h2>` is detached from the rectangle
    and resumes its place in the normal flow. This is shown in [Figure 10-55](#detaching_from_the_top).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1055.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-55\. Detaching from the top of the sticky-positioning rectangle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that the reason the `<h2>` sticks to the *top* of the rectangle in these
    examples is that the value of `top` is set to something other than `auto` for
    the `<h2>` (that is, for the sticky-positioned element). You can use whatever
    offset side you want. For example, you could have elements stick to the bottom
    of the rectangle as you scroll downward through the content. The following code
    is illustrated in [Figure 10-56](#sticking_to_the_bottom):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1056.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-56\. Sticking to the bottom of the sticky-positioning rectangle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This could be a way to show footnotes or comments for a given paragraph, for
    example, while allowing them to scroll away as the paragraph moves upward. The
    same rules apply for the left and right sides, which is useful for side-scrolling
    content.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define more than one offset property to have a value other than `auto`,
    *all* of them will become sticky edges. For example, this set of styles will force
    the `<h2>` to always appear inside the scrollbox, regardless of which way its
    content is scrolled (see [Figure 10-57](#making_every_side_sticky)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1057.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-57\. Making every side a sticky side
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You might wonder: what happens if I have multiple sticky-positioned elements
    in a situation like this, and I scroll past two or more? In effect, they pile
    up on top of one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not easy to see in static images like [Figure 10-58](#sticky-header_pileup),
    but the way the headers are piling up is that the later they are in the source,
    the closer they are to the viewer. This is the usual `z-index` behavior—which
    means that you can decide which sticky elements sit on top of others by assigning
    explicit `z-index` values. For example, suppose we want the first sticky element
    in our content to sit atop all the others. By giving it `z-index: 1000`, or any
    other sufficiently high number, it would sit on top of all the other sticky elements
    that are stuck in the same place. The visual effect would be of the other elements
    “sliding under” the topmost element.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1058.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-58\. A sticky-header pileup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in this chapter, CSS offers numerous ways to affect the placement
    of basic elements. Floats may be a fundamentally simple aspect of CSS, but that
    doesn’t keep them from being useful and powerful. They fill a vital and honorable
    niche, allowing the placement of content to one side while the rest of the content
    flows around it.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to positioning, it’s possible to move elements around in ways that the
    normal flow could never accommodate. Combined with the stacking possibilities
    of the z-axis and the various overflow patterns, there’s still a lot to like in
    positioning, even in a time when flexbox and grid layout are available to us.
  prefs: []
  type: TYPE_NORMAL
