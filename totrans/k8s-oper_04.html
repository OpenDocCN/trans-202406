<html><head></head><body><section data-pdf-bookmark="Chapter 4. The Operator Framework" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_operator_framework">&#13;
<h1><span class="label">Chapter 4. </span>The Operator Framework</h1>&#13;
&#13;
&#13;
<p>There is inevitable complexity in developing an Operator, and in managing its distribution, deployment, and lifecycle.<a data-primary="Operator framework" data-type="indexterm" id="ix_OpFrm"/> The Red Hat Operator Framework makes it simpler to create and distribute Operators. It makes building Operators easier with a software development kit (SDK) that automates much of the repetitive implementation work. The Framework also provides mechanisms for deploying and managing Operators. Operator Lifecycle Manager (OLM) is an Operator that installs, manages, and upgrades other Operators.<a data-primary="Operator Lifecycle Manager (OLM)" data-type="indexterm" id="idm45261334698216"/><a data-primary="Operator Metering" data-type="indexterm" id="idm45261334697608"/> Operator Metering is a metrics system that accounts for Operators’ use of cluster resources. This chapter gives an overview of these three key parts of the Framework to prepare you to use those tools to build and distribute an example Operator. Along the way, you’ll install the <code>operator-sdk</code> command-line tool, the primary interface to SDK features.<a data-primary="operator-sdk command-line tool" data-see="Operator SDK" data-type="indexterm" id="idm45261334696184"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operator Framework Origins" data-type="sect1"><div class="sect1" id="idm45261334695208">&#13;
<h1>Operator Framework Origins</h1>&#13;
&#13;
<p>The Operator SDK builds atop the Kubernetes <a href="https://oreil.ly/AM0TP"><code>controller-runtime</code></a>, a set of libraries providing essential Kubernetes controller routines in the Go programming language.<a data-primary="Operator framework" data-secondary="origins of" data-type="indexterm" id="idm45261334692984"/> As part of the Operator Framework, the SDK provides integration points for distributing and managing Operators with OLM, and measuring them with Operator Metering.<a data-primary="Red Hat Operator Framework" data-type="indexterm" id="idm45261334691832"/><a data-primary="Operator SDK" data-seealso="Operator framework" data-type="indexterm" id="idm45261334691224"/> The SDK and the entire Red Hat Operator Framework are open source with contributors from throughout the community and other organizations, and are in the <a href="https://oreil.ly/KoyS6">process of being donated</a> to the vendor-neutral <a href="https://www.cncf.io/">Cloud Native Computing Foundation</a>, home<a data-primary="Cloud Native Computing Foundation (CNCF)" data-type="indexterm" id="idm45261334688824"/> to Kubernetes itself and many other related projects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Operator Maturity Model" data-type="sect1"><div class="sect1" id="idm45261334687960">&#13;
<h1>Operator Maturity Model</h1>&#13;
&#13;
<p>The Operator Maturity Model, depicted in <a data-type="xref" href="#fig4-1">Figure 4-1</a>, sketches a way to think about different <a data-primary="Operator Maturity Model" data-type="indexterm" id="idm45261334685672"/><a data-primary="Maturity Model" data-type="indexterm" id="idm45261334685064"/>levels of Operator functionality. You can begin with a minimum viable product that installs its operand, then add lifecycle management and upgrade capabilities, iterating over time toward complete automation for your application.</p>&#13;
&#13;
<figure><div class="figure" id="fig4-1">&#13;
<img alt="Figure 4-1: Operator Maturity Model" src="assets/kuop_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Operator Maturity Model</h6>&#13;
</div></figure>&#13;
&#13;
<p>An Operator can have humble origins and grow in sophistication over a series of development cycles. The first phase of the model requires just enough application-specific code to create any resources the operand requires. In other words, phase one is the prepared, automated installation of an application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operator SDK" data-type="sect1"><div class="sect1" id="idm45261334681512">&#13;
<h1>Operator SDK</h1>&#13;
&#13;
<p>The <a href="https://oreil.ly/IcfRf">Operator SDK</a> is a set of tools for <a data-primary="Operator SDK" data-secondary="about" data-type="indexterm" id="idm45261334679528"/><a data-primary="Operator framework" data-secondary="Operator SDK" data-type="indexterm" id="idm45261334678680"/>scaffolding, building, and preparing an Operator for deployment.<a data-primary="Go programming language" data-secondary="constructing Operators in, support by Operator SDK" data-type="indexterm" id="idm45261334677704"/> The SDK currently includes first-class support for constructing Operators in the Go programming language, with support for other languages planned.<a data-primary="Ansible playbooks" data-type="indexterm" id="idm45261334676568"/><a data-primary="Helm charts" data-secondary="adapter architecture for Operators" data-type="indexterm" id="idm45261334675960"/> The SDK also offers what might be described as an adapter architecture for <a href="https://oreil.ly/IYH2d">Helm</a> charts or <a href="https://oreil.ly/ek6jP">Ansible</a> playbooks. We’ll cover these Adapter Operators in <a data-type="xref" href="ch06.html#adapter_operators">Chapter 6</a>. In <a data-type="xref" href="ch07.html#operators_in_go_with_the_operator_sdk">Chapter 7</a> we will show how to implement application-specific management routines in Go to build a custom Operator with the SDK tool.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing the Operator SDK Tool" data-type="sect2"><div class="sect2" id="idm45261334672120">&#13;
<h2>Installing the Operator SDK Tool</h2>&#13;
&#13;
<p>The Operator SDK centers around a command-line tool, <code>operator-sdk</code>, that helps you build Operators. <a data-primary="Operator SDK" data-secondary="installing" data-type="indexterm" id="idm45261334670600"/>The SDK imposes a standard project layout, and in return creates skeletal Go source code for the basic Kubernetes API controller implementation and placeholders for your application-specific handlers. From there, the SDK provides convenience commands for building an Operator and wrapping it in a Linux container, generating the YAML-format Kubernetes manifests needed to deploy the Operator on Kubernetes clusters.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binary installation" data-type="sect3"><div class="sect3" id="idm45261334669064">&#13;
<h3>Binary installation</h3>&#13;
&#13;
<p>To install a binary for your operating system, download <code>operator-sdk</code> from <a href="https://oreil.ly/TTnC6">the Kubernetes SDK repository</a>, make it executable, and move it into a directory in your <code>$PATH</code>.<a data-primary="Operator SDK" data-secondary="installing" data-tertiary="binary installation" data-type="indexterm" id="idm45261334666152"/> The program is statically linked, so it’s ready to run on those platforms for which a release is available. At the time of this writing, the project supplies builds for macOS and Linux operating systems on the x86-64 architecture.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>With any rapidly evolving project like <code>operator-sdk</code>, it’s a good idea to check the <a href="https://oreil.ly/ZbaBT">project’s installation instructions</a> for the latest installation method.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing from source" data-type="sect3"><div class="sect3" id="idm45261334661784">&#13;
<h3>Installing from source</h3>&#13;
&#13;
<p>To get the latest development version, or for platforms with no binary distribution, build <code>operator-sdk</code> from source.<a data-primary="Operator SDK" data-secondary="installing" data-tertiary="from source" data-type="indexterm" id="idm45261334659784"/> We assume you have <code>git</code> and <code>go</code> installed:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>go</code><code> </code><code>get</code><code> </code><code>-d</code><code> </code><code>github.com/operator-framework/operator-sdk</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code class="nb">cd</code><code> </code><code class="nv">$GOPATH</code><code>/src/github.com/operator-framework/operator-sdk</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code>git</code><code> </code><code>checkout</code><code> </code><code>master</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code>make</code><code> </code><code>tidy</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code>make</code><code> </code><code>install</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>A successful build process writes the <code>operator-sdk</code> binary to your <em>$GOPATH/bin</em> directory. Run <code>operator-sdk version</code> to check it is in your <code>$PATH</code>.</p>&#13;
&#13;
<p>These are the two most common and least dependent ways to get the SDK tool. Check the project’s <a href="https://oreil.ly/fAC1b">install documentation</a> for other options. The subsequent examples in this book use version series 0.11.x of <code>operator-sdk</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operator Lifecycle Manager" data-type="sect1"><div class="sect1" id="idm45261334622968">&#13;
<h1>Operator Lifecycle Manager</h1>&#13;
&#13;
<p>Operators address the general principle that any application, on any platform, must be acquired, deployed, and managed over time.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="overview of" data-type="indexterm" id="idm45261334621256"/> Operators are themselves Kubernetes applications. While an Operator manages its operand, what manages an Operator?</p>&#13;
&#13;
<p><a href="https://oreil.ly/SDL7q">Operator Lifecycle Manager</a> takes the Operator pattern one level up the stack: it’s an Operator that acquires, deploys, and manages Operators on a Kubernetes cluster. Like an Operator for any application, OLM extends Kubernetes by way of custom resources and custom controllers so that Operators, too, can be managed declaratively, with Kubernetes tools, in terms of the Kubernetes API.</p>&#13;
&#13;
<p>OLM defines a schema for Operator metadata, called the Cluster Service Version (CSV), for describing an Operator and its dependencies. Operators with a CSV can be listed as entries in a <em>catalog</em> available to OLM running on a Kubernetes cluster.<a data-primary="catalogs (OLM)" data-type="indexterm" id="idm45261334617720"/><a data-primary="subscribing to Operators in OLM" data-type="indexterm" id="idm45261334617016"/> Users then <em>subscribe</em> to an Operator from the catalog to tell OLM to provision and manage a desired Operator. That Operator, in turn, provisions and manages its application or service on the cluster.</p>&#13;
&#13;
<p>Based on the description and parameters an Operator provides in its CSV, OLM can manage the Operator over its lifecycle: monitoring its state, taking actions to keep it running, coordinating among multiple instances on a cluster, and upgrading it to new versions. The Operator, in turn, can control its application with the latest automation features for the app’s latest versions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operator Metering" data-type="sect1"><div class="sect1" id="idm45261334602408">&#13;
<h1>Operator Metering</h1>&#13;
&#13;
<p>Operator Metering is a system for analyzing the resource usage of the Operators running on Kubernetes clusters.<a data-primary="Operator Metering" data-secondary="about" data-type="indexterm" id="idm45261334601256"/><a data-primary="Operator framework" data-secondary="Operator Metering" data-type="indexterm" id="idm45261334600408"/> Metering analyzes Kubernetes CPU, memory, and other resource metrics to calculate costs for infrastructure services. It can also examine application-specific metrics, such as those required to bill application users based on usage. Metering provides a model for ops teams to map the costs of a cloud service or a cluster resource to the application, namespace, and team consuming it.<a data-primary="reporting, customized, from Operator Metering" data-type="indexterm" id="idm45261334599000"/> It’s a platform atop which you can build customized reporting specific to your Operator and the application it manages, helping with three primary activities:</p>&#13;
<dl>&#13;
<dt>Budgeting</dt>&#13;
<dd>&#13;
<p>When using Operators on their clusters, teams can <a data-primary="budgeting, help from Operator Metering" data-type="indexterm" id="idm45261334596232"/>gain insight into how infrastructure resources are used, especially in autoscaled clusters or hybrid cloud deployments, helping improve projections and allocations to avoid waste.</p>&#13;
</dd>&#13;
<dt>Billing</dt>&#13;
<dd>&#13;
<p>When you build an Operator that provides a service to paying customers, resource usage can be tracked by billing<a data-primary="billing, help from Operator Metering" data-type="indexterm" id="idm45261334593832"/> codes or labels that reflect the internal structure of an Operator and application to calculate accurate and itemized bills.</p>&#13;
</dd>&#13;
<dt>Metrics aggregation</dt>&#13;
<dd>&#13;
<p>Service usage and metrics can be viewed across namespaces or teams.<a data-primary="metrics aggregation, help from Operator Metering" data-type="indexterm" id="idm45261334591608"/> For example, it can help you analyze the resources consumed by a PostgreSQL database Operator running many database server clusters and very many databases for different teams sharing a large Kubernetes cluster.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45261334590072">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter introduced the three pillars of the Operator Framework: the Operator SDK for building and developing Operators; Operator Lifecycle Manager for distributing, installing, and upgrading them; and Operator Metering for measuring Operator performance and resource consumption. Together these framework elements support the process of making an Operator and keeping it running.</p>&#13;
&#13;
<p>You also installed the <code>operator-sdk</code> tool, so you’re equipped with the primary tool for building Operators. To get started, we’ll first introduce the example application you will construct an Operator to manage, the Visitors Site.<a data-primary="Operator framework" data-startref="ix_OpFrm" data-type="indexterm" id="idm45261334587272"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>