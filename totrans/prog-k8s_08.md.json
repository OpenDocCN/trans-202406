["```\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Topping\nmetadata:\n  name: mozzarella\nspec:\n  cost: 1.0\n```", "```\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Pizza\nmetadata:\n  name: margherita\nspec:\n  toppings:\n  - mozzarella\n  - tomato\n```", "```\napiVersion: apiregistration.k8s.io/v1beta1\nkind: APIService\nmetadata:\n  name: *`name`*\nspec:\n  group: *`API-group-name`*\n  version: *`API-group-version`*\n  service:\n    namespace: *`custom-API-server-service-namespace`*\n    name: *`-API-server-service`*\n  caBundle: *`base64-caBundle`*\n  insecureSkipTLSVerify: *`bool`*\n  groupPriorityMinimum: 2000\n  versionPriority: 20\n\n```", "```\n// GroupPriorityMininum is the priority this group should have at least. Higher\n// priority means that the group is preferred by clients over lower priority ones.\n// Note that other versions of this group might specify even higher\n// GroupPriorityMinimum values such that the whole group gets a higher priority.\n//\n// The primary sort is based on GroupPriorityMinimum, ordered highest number to\n// lowest (20 before 10). The secondary sort is based on the alphabetical\n// comparison of the name of the object (v1.bar before v1.foo). We'd recommend\n// something like: *.k8s.io (except extensions) at 18000 and PaaSes\n// (OpenShift, Deis) are recommended to be in the 2000s\nGroupPriorityMinimum int32 `json:\"groupPriorityMinimum\"`\n\n// VersionPriority controls the ordering of this API version inside of its\n// group. Must be greater than zero. The primary sort is based on\n// VersionPriority, ordered highest to lowest (20 before 10). Since it's inside\n// of a group, the number can be small, probably in the 10s. In case of equal\n// version priorities, the version string will be used to compute the order\n// inside a group. If the version string is \"kube-like\", it will sort above non\n// \"kube-like\" version strings, which are ordered lexicographically. \"Kube-like\"\n// versions start with a \"v\", then are followed by a number (the major version),\n// then optionally the string \"alpha\" or \"beta\" and another number (the minor\n// version). These are sorted first by GA > beta > alpha (where GA is a version\n// with no suffix such as beta or alpha), and then by comparing major version,\n// then minor version. An example sorted list of versions:\n// v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.\nVersionPriority int32 `json:\"versionPriority\"`\n```", "```\nvar apiVersionPriorities = map[schema.GroupVersion]priority{\n    {Group: \"\", Version: \"v1\"}: {group: 18000, version: 1},\n    {Group: \"extensions\", Version: \"v1beta1\"}: {group: 17900, version: 1},\n    {Group: \"apps\", Version: \"v1beta1\"}:                         {group: 17800, version: 1},\n    {Group: \"apps\", Version: \"v1beta2\"}:                         {group: 17800, version: 9},\n    {Group: \"apps\", Version: \"v1\"}:                              {group: 17800, version: 15},\n    {Group: \"events.k8s.io\", Version: \"v1beta1\"}:                {group: 17750, version: 5},\n    {Group: \"authentication.k8s.io\", Version: \"v1\"}:             {group: 17700, version: 15},\n    {Group: \"authentication.k8s.io\", Version: \"v1beta1\"}:        {group: 17700, version: 9},\n    {Group: \"authorization.k8s.io\", Version: \"v1\"}:              {group: 17600, version: 15},\n    {Group: \"authorization.k8s.io\", Version: \"v1beta1\"}:         {group: 17600, version: 9},\n    {Group: \"autoscaling\", Version: \"v1\"}:                       {group: 17500, version: 15},\n    {Group: \"autoscaling\", Version: \"v2beta1\"}:                  {group: 17500, version: 9},\n    {Group: \"autoscaling\", Version: \"v2beta2\"}:                  {group: 17500, version: 1},\n    {Group: \"batch\", Version: \"v1\"}:                             {group: 17400, version: 15},\n    {Group: \"batch\", Version: \"v1beta1\"}:                        {group: 17400, version: 9},\n    {Group: \"batch\", Version: \"v2alpha1\"}:                       {group: 17400, version: 9},\n    {Group: \"certificates.k8s.io\", Version: \"v1beta1\"}:          {group: 17300, version: 9},\n    {Group: \"networking.k8s.io\", Version: \"v1\"}:                 {group: 17200, version: 15},\n    {Group: \"networking.k8s.io\", Version: \"v1beta1\"}:            {group: 17200, version: 9},\n    {Group: \"policy\", Version: \"v1beta1\"}:                       {group: 17100, version: 9},\n    {Group: \"rbac.authorization.k8s.io\", Version: \"v1\"}:         {group: 17000, version: 15},\n    {Group: \"rbac.authorization.k8s.io\", Version: \"v1beta1\"}:    {group: 17000, version: 12},\n    {Group: \"rbac.authorization.k8s.io\", Version: \"v1alpha1\"}:   {group: 17000, version: 9},\n    {Group: \"settings.k8s.io\", Version: \"v1alpha1\"}:             {group: 16900, version: 9},\n    {Group: \"storage.k8s.io\", Version: \"v1\"}:                    {group: 16800, version: 15},\n    {Group: \"storage.k8s.io\", Version: \"v1beta1\"}:               {group: 16800, version: 9},\n    {Group: \"storage.k8s.io\", Version: \"v1alpha1\"}:              {group: 16800, version: 1},\n    {Group: \"apiextensions.k8s.io\", Version: \"v1beta1\"}:         {group: 16700, version: 9},\n    {Group: \"admissionregistration.k8s.io\", Version: \"v1\"}:      {group: 16700, version: 15},\n    {Group: \"admissionregistration.k8s.io\", Version: \"v1beta1\"}: {group: 16700, version: 12},\n    {Group: \"scheduling.k8s.io\", Version: \"v1\"}:                 {group: 16600, version: 15},\n    {Group: \"scheduling.k8s.io\", Version: \"v1beta1\"}:            {group: 16600, version: 12},\n    {Group: \"scheduling.k8s.io\", Version: \"v1alpha1\"}:           {group: 16600, version: 9},\n    {Group: \"coordination.k8s.io\", Version: \"v1\"}:               {group: 16500, version: 15},\n    {Group: \"coordination.k8s.io\", Version: \"v1beta1\"}:          {group: 16500, version: 9},\n    {Group: \"auditregistration.k8s.io\", Version: \"v1alpha1\"}:    {group: 16400, version: 1},\n    {Group: \"node.k8s.io\", Version: \"v1alpha1\"}:                 {group: 16300, version: 1},\n    {Group: \"node.k8s.io\", Version: \"v1beta1\"}:                  {group: 16300, version: 9},\n}\n\n```", "```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: extension-apiserver-authentication\n  namespace: kube-system\ndata:\n  client-ca-file: |\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n  requestheader-allowed-names: '[\"aggregator\"]'\n  requestheader-client-ca-file: |\n    -----BEGIN CERTIFICATE-----\n    ...\n    -----END CERTIFICATE-----\n  requestheader-extra-headers-prefix: '[\"X-Remote-Extra-\"]'\n  requestheader-group-headers: '[\"X-Remote-Group\"]'\n  requestheader-username-headers: '[\"X-Remote-User\"]'\n```", "```\napiVersion: authorization.k8s.io/v1\nkind: SubjectAccessReview\nspec:\n  resourceAttributes:\n    group: apps\n    resource: deployments\n    verb: create\n    namespace: default\n    version: v1\n    name: example\n  user: michael\n  groups:\n  - system:authenticated\n  - admins\n  - authors\n```", "```\napiVersion: authorization.k8s.io/v1\nkind: SubjectAccessReview\nstatus:\n  allowed: true\n  denied: false\n  reason: \"rule foo allowed this request\"\n```", "```\nimport (\n    ...\n    informers \"github.com/programming-kubernetes/pizza-apiserver/pkg/\n generated/informers/externalversions\"\n)\n\nconst defaultEtcdPathPrefix = \"/registry/restaurant.programming-kubernetes.info\"\n\ntype CustomServerOptions struct {\n    RecommendedOptions *genericoptions.RecommendedOptions\n    SharedInformerFactory informers.SharedInformerFactory\n}\n\nfunc NewCustomServerOptions(out, errOut io.Writer) *CustomServerOptions {\n    o := &CustomServerOptions{\n        RecommendedOptions: genericoptions.NewRecommendedOptions(\n            defaultEtcdPathPrefix,\n            apiserver.Codecs.LegacyCodec(v1alpha1.SchemeGroupVersion),\n            genericoptions.NewProcessInfo(\"pizza-apiserver\", \"pizza-apiserver\"),\n        ),\n    }\n\n    return o\n}\n```", "```\nreturn &RecommendedOptions{\n    Etcd:           NewEtcdOptions(storagebackend.NewDefaultConfig(prefix, codec)),\n    SecureServing:  sso.WithLoopback(),\n    Authentication: NewDelegatingAuthenticationOptions(),\n    Authorization:  NewDelegatingAuthorizationOptions(),\n    Audit:          NewAuditOptions(),\n    Features:       NewFeatureOptions(),\n    CoreAPI:        NewCoreAPIOptions(),\n    ExtraAdmissionInitializers:\n      func(c *server.RecommendedConfig) ([]admission.PluginInitializer, error) {\n          return nil, nil\n      },\n    Admission:      NewAdmissionOptions(),\n    ProcessInfo:    processInfo,\n    Webhook:        NewWebhookOptions(),\n}\n```", "```\nfunc (o *CustomServerOptions) Config() (*apiserver.Config, error) {\n    err := o.RecommendedOptions.SecureServing.MaybeDefaultWithSelfSignedCerts(\n        \"localhost\", nil, []net.IP{net.ParseIP(\"127.0.0.1\")},\n    )\n    if err != nil {\n        return nil, fmt.Errorf(\"error creating self-signed cert: %v\", err)\n    }\n\n    [... omitted o.RecommendedOptions.ExtraAdmissionInitializers ...]\n\n    serverConfig := genericapiserver.NewRecommendedConfig(apiserver.Codecs)\n    err = o.RecommendedOptions.ApplyTo(serverConfig, apiserver.Scheme);\n    if err != nil {\n        return nil, err\n    }\n\n    config := &apiserver.Config{\n        GenericConfig: serverConfig,\n        ExtraConfig:   apiserver.ExtraConfig{},\n    }\n    return config, nil\n}\n```", "```\ntype ExtraConfig struct {\n    // Place your custom config here.\n}\n\ntype Config struct {\n    GenericConfig *genericapiserver.RecommendedConfig\n    ExtraConfig   ExtraConfig\n}\n\n// CustomServer contains state for a Kubernetes custom api server.\ntype CustomServer struct {\n    GenericAPIServer *genericapiserver.GenericAPIServer\n}\n\ntype completedConfig struct {\n    GenericConfig genericapiserver.CompletedConfig\n    ExtraConfig   *ExtraConfig\n}\n\ntype CompletedConfig struct {\n    // Embed a private pointer that cannot be instantiated outside of\n    // this package.\n    *completedConfig\n}\n```", "```\nfunc (cfg *Config) Complete() completedConfig {\n    c := completedConfig{\n        cfg.GenericConfig.Complete(),\n        &cfg.ExtraConfig,\n    }\n\n    c.GenericConfig.Version = &version.Info{\n        Major: \"1\",\n        Minor: \"0\",\n    }\n\n    return completedConfig{&c}\n}\n```", "```\n// New returns a new instance of CustomServer from the given config.\nfunc (c completedConfig) New() (*CustomServer, error) {\n    genericServer, err := c.GenericConfig.New(\n        \"pizza-apiserver\",\n        genericapiserver.NewEmptyDelegate(),\n    )\n    if err != nil {\n        return nil, err\n    }\n\n    s := &CustomServer{\n        GenericAPIServer: genericServer,\n    }\n\n    [ ... omitted API installation ...]\n\n    return s, nil\n}\n```", "```\nfunc (o CustomServerOptions) Run(stopCh <-chan struct{}) error {\n    config, err := o.Config()\n    if err != nil {\n        return err\n    }\n\n    server, err := config.Complete().New()\n    if err != nil {\n        return err\n    }\n\n    server.GenericAPIServer.AddPostStartHook(\"start-pizza-apiserver-informers\",\n        func(context genericapiserver.PostStartHookContext) error {\n            config.GenericConfig.SharedInformerFactory.Start(context.StopCh)\n            o.SharedInformerFactory.Start(context.StopCh)\n            return nil\n        },\n    )\n\n    return server.GenericAPIServer.PrepareRun().Run(stopCh)\n}\n```", "```\n// NewCommandStartCustomServer provides a CLI handler for 'start master' command\n// with a default CustomServerOptions.\nfunc NewCommandStartCustomServer(\n    defaults *CustomServerOptions,\n    stopCh <-chan struct{},\n) *cobra.Command {\n    o := *defaults\n    cmd := &cobra.Command{\n        Short: \"Launch a custom API server\",\n        Long:  \"Launch a custom API server\",\n        RunE: func(c *cobra.Command, args []string) error {\n            if err := o.Complete(); err != nil {\n                return err\n            }\n            if err := o.Validate(); err != nil {\n                return err\n            }\n            if err := o.Run(stopCh); err != nil {\n                return err\n            }\n            return nil\n        },\n    }\n\n    flags := cmd.Flags()\n    o.RecommendedOptions.AddFlags(flags)\n\n    return cmd\n}\n```", "```\nfunc main() {\n    logs.InitLogs()\n    defer logs.FlushLogs()\n\n    stopCh := genericapiserver.SetupSignalHandler()\n    options := server.NewCustomServerOptions(os.Stdout, os.Stderr)\n    cmd := server.NewCommandStartCustomServer(options, stopCh)\n    cmd.Flags().AddGoFlagSet(flag.CommandLine)\n    if err := cmd.Execute(); err != nil {\n        klog.Fatal(err)\n    }\n}\n```", "```\n$ cd $GOPATH/src/github.com/programming-kubernetes/pizza-apiserver\n$ etcd &\n$ go run . --etcd-servers localhost:2379 \\\n    --authentication-kubeconfig ~/.kube/config \\\n    --authorization-kubeconfig ~/.kube/config \\\n    --kubeconfig ~/.kube/config\nI0331 11:33:25.702320   64244 plugins.go:158]\n  Loaded 3 mutating admission controller(s) successfully in the following order:\n     NamespaceLifecycle,MutatingAdmissionWebhook,PizzaToppings.\nI0331 11:33:25.702344   64244 plugins.go:161]\n  Loaded 1 validating admission controller(s) successfully in the following order:\n     ValidatingAdmissionWebhook.\nI0331 11:33:25.714148   64244 secure_serving.go:116] Serving securely on [::]:443\n```", "```\n$ curl -k https://localhost:443/healthz\nok\n```", "```\n$ curl -k https://localhost:443/apis\n{\n  \"kind\": \"APIGroupList\",\n  \"groups\": []\n}\n```", "```\n// SchemeGroupVersion is group version used to register these objects\nvar SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version:\nruntime.APIVersionInternal}\n```", "```\n// Install registers the API group and adds types to a scheme\nfunc Install(scheme *runtime.Scheme) {\n    utilruntime.Must(restaurant.AddToScheme(scheme))\n    utilruntime.Must(v1beta1.AddToScheme(scheme))\n    utilruntime.Must(v1alpha1.AddToScheme(scheme))\n    utilruntime.Must(scheme.SetVersionPriority(\n        v1beta1.SchemeGroupVersion,\n        v1alpha1.SchemeGroupVersion,\n    ))\n}\n```", "```\nfunc (s *Scheme) Convert(in, out interface{}, context interface{}) error\n```", "```\n// ...an optional field that callers may use to pass info to conversion functions.\n```", "```\nfunc init() {\n    localSchemeBuilder.Register(RegisterConversions)\n}\n\n// RegisterConversions adds conversion functions to the given scheme.\n// Public to allow building arbitrary schemes.\nfunc RegisterConversions(s *runtime.Scheme) error {\n    if err := s.AddGeneratedConversionFunc(\n        (*Topping)(nil),\n        (*restaurant.Topping)(nil),\n        func(a, b interface{}, scope conversion.Scope) error {\n            return Convert_v1alpha1_Topping_To_restaurant_Topping(\n                a.(*Topping),\n                b.(*restaurant.Topping),\n                scope,\n            )\n        },\n    ); err != nil {\n        return err\n    }\n    ...\n    return nil\n}\n\n...\n```", "```\nfunc Convert_v1alpha1_PizzaSpec_To_restaurant_PizzaSpec(\n    in *PizzaSpec,\n    out *restaurant.PizzaSpec,\n    s conversion.Scope,\n) error {\n    ...\n\n    return nil\n}\n```", "```\nfunc Convert_v1alpha1_PizzaSpec_To_restaurant_PizzaSpec(\n    in *PizzaSpec,\n    out *restaurant.PizzaSpec,\n    s conversion.Scope,\n) error {\n    idx := map[string]int{}\n    for _, top := range in.Toppings {\n        if i, duplicate := idx[top]; duplicate {\n            out.Toppings[i].Quantity++\n            continue\n        }\n        idx[top] = len(out.Toppings)\n        out.Toppings = append(out.Toppings, restaurant.PizzaTopping{\n            Name: top,\n            Quantity: 1,\n        })\n    }\n\n    return nil\n}\n```", "```\nfunc autoConvert_restaurant_PizzaSpec_To_v1beta1_PizzaSpec(\n    in *restaurant.PizzaSpec,\n    out *PizzaSpec,\n    s conversion.Scope,\n) error {\n    out.Toppings = *(*[]PizzaTopping)(unsafe.Pointer(&in.Toppings))\n    return nil\n}\n```", "```\ns.Meta().Context\n```", "```\nfunc SetDefaults*`Kind`*(obj **`Type`*) {\n    ...\n}\n\n```", "```\nfunc init() {\n    localSchemeBuilder.Register(RegisterDefaults)\n}\n```", "```\nfunc SetDefaults*`Kind`*(obj **`Type`*) {\n    if obj.Foo == nil {\n        x := true\n        obj.Foo = &x\n    }\n}\n\n```", "```\nimport (\n    ...\n    \"k8s.io/apimachinery/pkg/api/apitesting/roundtrip\"\n    restaurantfuzzer \"github.com/programming-kubernetes/pizza-apiserver/pkg/apis/\n restaurant/fuzzer\"\n)\n\nfunc TestRoundTripTypes(t *testing.T) {\n    roundtrip.RoundTripTestForAPIGroup(t, Install, restaurantfuzzer.Funcs)\n}\n```", "```\n// Funcs returns the fuzzer functions for the restaurant api group.\nvar Funcs = func(codecs runtimeserializer.CodecFactory) []interface{} {\n    return []interface{}{\n        func(s *restaurant.PizzaSpec, c fuzz.Continue) {\n            c.FuzzNoCustom(s) // fuzz first without calling this function again\n\n            // avoid empty Toppings because that is defaulted\n            if len(s.Toppings) == 0 {\n                s.Toppings = []restaurant.PizzaTopping{\n                    {\"salami\", 1},\n                    {\"mozzarella\", 1},\n                    {\"tomato\", 1},\n                }\n            }\n\n            seen := map[string]bool{}\n            for i := range s.Toppings {\n                // make quantity strictly positive and of reasonable size\n                s.Toppings[i].Quantity = 1 + c.Intn(10)\n\n                // remove duplicates\n                for {\n                    if !seen[s.Toppings[i].Name] {\n                        break\n                    }\n                    s.Toppings[i].Name = c.RandString()\n                }\n                seen[s.Toppings[i].Name] = true\n            }\n        },\n    }\n}\n```", "```\nfunc (pizzaStrategy) Validate(\n    ctx context.Context, obj runtime.Object,\n) field.ErrorList {\n    pizza := obj.(*restaurant.Pizza)\n    return validation.ValidatePizza(pizza)\n}\n```", "```\n// ValidatePizza validates a Pizza.\nfunc ValidatePizza(f *restaurant.Pizza) field.ErrorList {\n    allErrs := field.ErrorList{}\n\n    errs := ValidatePizzaSpec(&f.Spec, field.NewPath(\"spec\"))\n    allErrs = append(allErrs, errs...)\n\n    return allErrs\n}\n\n// ValidatePizzaSpec validates a PizzaSpec.\nfunc ValidatePizzaSpec(\n    s *restaurant.PizzaSpec,\n    fldPath *field.Path,\n) field.ErrorList {\n    allErrs := field.ErrorList{}\n\n    prevNames := map[string]bool{}\n    for i := range s.Toppings {\n        if s.Toppings[i].Quantity <= 0 {\n            allErrs = append(allErrs, field.Invalid(\n                fldPath.Child(\"toppings\").Index(i).Child(\"quantity\"),\n                s.Toppings[i].Quantity,\n                \"cannot be negative or zero\",\n            ))\n        }\n        if len(s.Toppings[i].Name) == 0 {\n            allErrs = append(allErrs, field.Invalid(\n                fldPath.Child(\"toppings\").Index(i).Child(\"name\"),\n                s.Toppings[i].Name,\n                \"cannot be empty\",\n            ))\n        } else {\n            if prevNames[s.Toppings[i].Name] {\n                allErrs = append(allErrs, field.Invalid(\n                    fldPath.Child(\"toppings\").Index(i).Child(\"name\"),\n                    s.Toppings[i].Name,\n                    \"must be unique\",\n                ))\n            }\n            prevNames[s.Toppings[i].Name] = true\n        }\n    }\n\n    return allErrs\n}\n```", "```\nfunc (pizzaStrategy) ValidateUpdate(\n    ctx context.Context,\n    obj, old runtime.Object,\n) field.ErrorList {\n    objPizza := obj.(*restaurant.Pizza)\n    oldPizza := old.(*restaurant.Pizza)\n    return validation.ValidatePizzaUpdate(objPizza, oldPizza)\n}\n```", "```\n// Creater is an object that can create an instance of a RESTful object.\ntype Creater interface {\n    // New returns an empty object that can be used with Create after request\n    // data has been put into it.\n    // This object must be a pointer type for use with Codec.DecodeInto([]byte,\n    // runtime.Object)\n    New() runtime.Object\n\n    // Create creates a new version of a resource.\n    Create(\n        ctx context.Context,\n        obj runtime.Object,\n        createValidation ValidateObjectFunc,\n        options *metav1.CreateOptions,\n    ) (runtime.Object, error)\n}\n```", "```\ntype RESTCreateStrategy interface {\n    runtime.ObjectTyper\n    // The name generator is used when the standard GenerateName field is set.\n    // The NameGenerator will be invoked prior to validation.\n    names.NameGenerator\n\n    // NamespaceScoped returns true if the object must be within a namespace.\n    NamespaceScoped() bool\n    // PrepareForCreate is invoked on create before validation to normalize\n    // the object. For example: remove fields that are not to be persisted,\n    // sort order-insensitive list fields, etc. This should not remove fields\n    // whose presence would be considered a validation error.\n    //\n    // Often implemented as a type check and an initailization or clearing of\n    // status. Clear the status because status changes are internal. External\n    // callers of an api (users) should not be setting an initial status on\n    // newly created objects.\n    PrepareForCreate(ctx context.Context, obj runtime.Object)\n    // Validate returns an ErrorList with validation errors or nil. Validate\n    // is invoked after default fields in the object have been filled in\n    // before the object is persisted. This method should not mutate the\n    // object.\n    Validate(ctx context.Context, obj runtime.Object) field.ErrorList\n    // Canonicalize allows an object to be mutated into a canonical form. This\n    // ensures that code that operates on these objects can rely on the common\n    // form for things like comparison. Canonicalize is invoked after\n    // validation has succeeded but before the object has been persisted.\n    // This method may mutate the object. Often implemented as a type check or\n    // empty method.\n    Canonicalize(obj runtime.Object)\n}\n```", "```\n// NewREST returns a RESTStorage object that will work against API services.\nfunc NewREST(\n    scheme *runtime.Scheme,\n    optsGetter generic.RESTOptionsGetter,\n) (*registry.REST, error) {\n    strategy := NewStrategy(scheme)\n\n    store := &genericregistry.Store{\n        NewFunc:       func() runtime.Object { return &restaurant.Pizza{} },\n        NewListFunc:   func() runtime.Object { return &restaurant.PizzaList{} },\n        PredicateFunc: MatchPizza,\n\n        DefaultQualifiedResource: restaurant.Resource(\"pizzas\"),\n\n        CreateStrategy: strategy,\n        UpdateStrategy: strategy,\n        DeleteStrategy: strategy,\n    }\n    options := &generic.StoreOptions{\n        RESTOptions: optsGetter,\n        AttrFunc: GetAttrs,\n    }\n    if err := store.CompleteWithOptions(options); err != nil {\n        return nil, err\n    }\n    return &registry.REST{store}, nil\n}\n```", "```\ntype REST struct {\n  *genericregistry.Store\n}\n```", "```\nimport (\n    ...\n    \"k8s.io/apimachinery/pkg/runtime\"\n    \"k8s.io/apimachinery/pkg/runtime/serializer\"\n\n    \"github.com/programming-kubernetes/pizza-apiserver/pkg/apis/restaurant/install\"\n)\n\nvar (\n    Scheme = runtime.NewScheme()\n    Codecs = serializer.NewCodecFactory(Scheme)\n)\n```", "```\nfunc init() {\n    install.Install(Scheme)\n}\n```", "```\nfunc init() {\n    // we need to add the options to empty v1\n    // TODO: fix the server code to avoid this\n    metav1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: \"v1\"})\n    // TODO: keep the generic API server from wanting this\n    unversioned := schema.GroupVersion{Group: \"\", Version: \"v1\"}\n    Scheme.AddUnversionedTypes(unversioned,\n        &metav1.Status{},\n        &metav1.APIVersions{},\n        &metav1.APIGroupList{},\n        &metav1.APIGroup{},\n        &metav1.APIResourceList{},\n    )\n}\n```", "```\n// New returns a new instance of CustomServer from the given config.\nfunc (c completedConfig) New() (*CustomServer, error) {\n    genericServer, err := c.GenericConfig.New(\"pizza-apiserver\",\n      genericapiserver.NewEmptyDelegate())\n    if err != nil {\n        return nil, err\n    }\n\n    s := &CustomServer{\n        GenericAPIServer: genericServer,\n    }\n\n    apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(restaurant.GroupName,\n      Scheme, metav1.ParameterCodec, Codecs)\n\n    v1alpha1storage := map[string]rest.Storage{}\n\n    pizzaRest := pizzastorage.NewREST(Scheme, c.GenericConfig.RESTOptionsGetter)\n    v1alpha1storage[\"pizzas\"] = customregistry.RESTInPeace(pizzaRest)\n\n    toppingRest := toppingstorage.NewREST(\n        Scheme, c.GenericConfig.RESTOptionsGetter,\n    )\n    v1alpha1storage[\"toppings\"] = customregistry.RESTInPeace(toppingRest)\n\n    apiGroupInfo.VersionedResourcesStorageMap[\"v1alpha1\"] = v1alpha1storage\n\n    v1beta1storage := map[string]rest.Storage{}\n\n    pizzaRest = pizzastorage.NewREST(Scheme, c.GenericConfig.RESTOptionsGetter)\n    v1beta1storage[\"pizzas\"] = customregistry.RESTInPeace(pizzaRest)\n\n    apiGroupInfo.VersionedResourcesStorageMap[\"v1beta1\"] = v1beta1storage\n\n    if err := s.GenericAPIServer.InstallAPIGroup(&apiGroupInfo); err != nil {\n        return nil, err\n    }\n\n    return s, nil\n}\n```", "```\nfunc RESTInPeace(storage rest.StandardStorage, err error) rest.StandardStorage {\n    if err != nil {\n        err = fmt.Errorf(\"unable to create REST storage: %v\", err)\n        panic(err)\n    }\n    return storage\n}\n```", "```\n$ curl -k https://localhost:443/apis\n{\n  \"kind\": \"APIGroupList\",\n  \"groups\": [\n    {\n      \"name\": \"restaurant.programming-kubernetes.info\",\n      \"versions\": [\n        {\n          \"groupVersion\": \"restaurant.programming-kubernetes.info/v1beta1\",\n          \"version\": \"v1beta1\"\n        },\n        {\n          \"groupVersion\": \"restaurant.programming-kubernetes.info/v1alpha1\",\n          \"version\": \"v1alpha1\"\n        }\n      ],\n      \"preferredVersion\": {\n        \"groupVersion\": \"restaurant.programming-kubernetes.info/v1beta1\",\n        \"version\": \"v1beta1\"\n      },\n      \"serverAddressByClientCIDRs\": [\n        {\n          \"clientCIDR\": \"0.0.0.0/0\",\n          \"serverAddress\": \":443\"\n        }\n      ]\n    }\n  ]\n}\n```", "```\n// Operation is the type of resource operation being checked for\n// admission control\ntype Operation string.\n\n// Operation constants\nconst (\n    Create  Operation = \"CREATE\"\n    Update  Operation = \"UPDATE\"\n    Delete  Operation = \"DELETE\"\n    Connect Operation = \"CONNECT\"\n)\n\n// Interface is an abstract, pluggable interface for Admission Control\n// decisions.\ntype Interface interface {\n    // Handles returns true if this admission controller can handle the given\n    // operation where operation can be one of CREATE, UPDATE, DELETE, or\n    // CONNECT.\n    Handles(operation Operation) bool.\n}\n\ntype MutationInterface interface {\n    Interface\n\n    // Admit makes an admission decision based on the request attributes.\n    Admit(a Attributes, o ObjectInterfaces) (err error)\n}\n\n// ValidationInterface is an abstract, pluggable interface for Admission Control\n// decisions.\ntype ValidationInterface interface {\n    Interface\n\n    // Validate makes an admission decision based on the request attributes.\n    // It is NOT allowed to mutate.\n    Validate(a Attributes, o ObjectInterfaces) (err error)\n}\n```", "```\ntype ObjectInterfaces interface {\n    // GetObjectCreater is the ObjectCreater for the requested object.\n    GetObjectCreater() runtime.ObjectCreater\n    // GetObjectTyper is the ObjectTyper for the requested object.\n    GetObjectTyper() runtime.ObjectTyper\n    // GetObjectDefaulter is the ObjectDefaulter for the requested object.\n    GetObjectDefaulter() runtime.ObjectDefaulter\n    // GetObjectConvertor is the ObjectConvertor for the requested object.\n    GetObjectConvertor() runtime.ObjectConvertor\n}\n```", "```\n// Attributes is an interface used by AdmissionController to get information\n// about a request that is used to make an admission decision.\ntype Attributes interface {\n    // GetName returns the name of the object as presented in the request.\n    // On a CREATE operation, the client may omit name and rely on the\n    // server to generate the name. If that is the case, this method will\n    // return the empty string.\n    GetName() string\n    // GetNamespace is the namespace associated with the request (if any).\n    GetNamespace() string\n    // GetResource is the name of the resource being requested. This is not the\n    // kind. For example: pods.\n    GetResource() schema.GroupVersionResource\n    // GetSubresource is the name of the subresource being requested. This is a\n    // different resource, scoped to the parent resource, but it may have a\n    // different kind.\n    // For instance, /pods has the resource \"pods\" and the kind \"Pod\", while\n    // /pods/foo/status has the resource \"pods\", the sub resource \"status\", and\n    // the kind \"Pod\" (because status operates on pods). The binding resource for\n    // a pod, though, may be /pods/foo/binding, which has resource \"pods\",\n    // subresource \"binding\", and kind \"Binding\".\n    GetSubresource() string\n    // GetOperation is the operation being performed.\n    GetOperation() Operation\n    // IsDryRun indicates that modifications will definitely not be persisted for\n    // this request. This is to prevent admission controllers with side effects\n    // and a method of reconciliation from being overwhelmed.\n    // However, a value of false for this does not mean that the modification will\n    // be persisted, because it could still be rejected by a subsequent\n    // validation step.\n    IsDryRun() bool\n    // GetObject is the object from the incoming request prior to default values\n    // being applied.\n    GetObject() runtime.Object\n    // GetOldObject is the existing object. Only populated for UPDATE requests.\n    GetOldObject() runtime.Object\n    // GetKind is the type of object being manipulated. For example: Pod.\n    GetKind() schema.GroupVersionKind\n    // GetUserInfo is information about the requesting user.\n    GetUserInfo() user.Info\n\n    // AddAnnotation sets annotation according to key-value pair. The key\n    // should be qualified, e.g., podsecuritypolicy.admission.k8s.io/admit-policy,\n    //  where \"podsecuritypolicy\" is the name of the plugin, \"admission.k8s.io\"\n    // is the name of the organization, and \"admit-policy\" is the key\n    // name. An error is returned if the format of key is invalid. When\n    // trying to overwrite annotation with a new value, an error is\n    // returned. Both ValidationInterface and MutationInterface are\n    // allowed to add Annotations.\n    AddAnnotation(key, value string) error\n}\n```", "```\ntype CustomAdmissionPlugin struct {\n    *admission.Handler\n    ...\n}\n```", "```\nfunc (d *PizzaToppingsPlugin) Admit(\n    a admission.Attributes,\n    o ObjectInterfaces,\n) error {\n    // we are only interested in pizzas\n    if a.GetKind().GroupKind() != restaurant.Kind(\"Pizza\") {\n        return nil\n    }\n\n    ...\n}\n```", "```\nfunc (d *PizzaToppingsPlugin) Validate(\n    a admission.Attributes,\n    o ObjectInterfaces,\n) error {\n    // we are only interested in pizzas\n    if a.GetKind().GroupKind() != restaurant.Kind(\"Pizza\") {\n        return nil\n    }\n\n    ...\n}\n```", "```\n// Admit ensures that the object in-flight is of kind Pizza.\n// In addition checks that the toppings are known.\nfunc (d *PizzaToppingsPlugin) Validate(\n    a admission.Attributes,\n    _ admission.ObjectInterfaces,\n) error {\n    // we are only interested in pizzas\n    if a.GetKind().GroupKind() != restaurant.Kind(\"Pizza\") {\n        return nil\n    }\n\n    if !d.WaitForReady() {\n        return admission.NewForbidden(a, fmt.Errorf(\"not yet ready\"))\n    }\n\n    obj := a.GetObject()\n    pizza := obj.(*restaurant.Pizza)\n    for _, top := range pizza.Spec.Toppings {\n        err := _, err := d.toppingLister.Get(top.Name)\n        if err != nil && errors.IsNotFound(err) {\n            return admission.NewForbidden(\n                a,\n                fmt.Errorf(\"unknown topping: %s\", top.Name),\n            )\n        }\n    }\n\n    return nil\n}\n```", "```\nfunc Register(plugins *admission.Plugins) {\n    plugins.Register(\n        \"PizzaTopping\",\n        func(config io.Reader) (admission.Interface, error) {\n            return New()\n        },\n    )\n}\n```", "```\nfunc (o *CustomServerOptions) Complete() error {\n    // register admission plugins\n    pizzatoppings.Register(o.RecommendedOptions.Admission.Plugins)\n\n    // add admisison plugins to the RecommendedPluginOrder\n    oldOrder := o.RecommendedOptions.Admission.RecommendedPluginOrder\n    o.RecommendedOptions.Admission.RecommendedPluginOrder =\n        append(oldOrder, \"PizzaToppings\")\n\n    return nil\n}\n```", "```\nkind: AdmissionConfiguration\napiVersion: apiserver.k8s.io/v1alpha1\nplugins:\n- name: CustomAdmissionPlugin\n  path: custom-admission-plugin.yaml\n```", "```\nkind: AdmissionConfiguration\napiVersion: apiserver.k8s.io/v1alpha1\nplugins:\n- name: CustomAdmissionPlugin\n  configuration:\n    *`your-custom-yaml-inline-config`*\n\n```", "```\n// WantsExternalKubeClientSet defines a function that sets external ClientSet\n// for admission plugins that need it.\ntype WantsExternalKubeClientSet interface {\n    SetExternalKubeClientSet(kubernetes.Interface)\n    admission.InitializationValidator\n}\n\n// WantsExternalKubeInformerFactory defines a function that sets InformerFactory\n// for admission plugins that need it.\ntype WantsExternalKubeInformerFactory interface {\n    SetExternalKubeInformerFactory(informers.SharedInformerFactory)\n    admission.InitializationValidator\n}\n\n// WantsAuthorizer defines a function that sets Authorizer for admission\n// plugins that need it.\ntype WantsAuthorizer interface {\n    SetAuthorizer(authorizer.Authorizer)\n    admission.InitializationValidator\n}\n\n// WantsScheme defines a function that accepts runtime.Scheme for admission\n// plugins that need it.\ntype WantsScheme interface {\n    SetScheme(*runtime.Scheme)\n    admission.InitializationValidator\n}\n```", "```\n// InitializationValidator holds ValidateInitialization functions, which are\n// responsible for validation of initialized shared resources and should be\n// implemented on admission plugins.\ntype InitializationValidator interface {\n    ValidateInitialization() error\n}\n```", "```\n    // WantsRestaurantInformerFactory defines a function that sets\n    // InformerFactory for admission plugins that need it.\n    type WantsRestaurantInformerFactory interface {\n        SetRestaurantInformerFactory(informers.SharedInformerFactory)\n        admission.InitializationValidator\n    }\n    ```", "```\n    func (i restaurantInformerPluginInitializer) Initialize(\n        plugin admission.Interface,\n    ) {\n        if wants, ok := plugin.(WantsRestaurantInformerFactory); ok {\n            wants.SetRestaurantInformerFactory(i.informers)\n        }\n    }\n    ```", "```\n    func (o *CustomServerOptions) Config() (*apiserver.Config, error) {\n        ...\n        o.RecommendedOptions.ExtraAdmissionInitializers =\n            func(c *genericapiserver.RecommendedConfig) (\n                []admission.PluginInitializer, error,\n            ) {\n                client, err := clientset.NewForConfig(c.LoopbackClientConfig)\n                if err != nil {\n                    return nil, err\n                }\n                informerFactory := informers.NewSharedInformerFactory(\n                    client, c.LoopbackClientConfig.Timeout,\n                )\n                o.SharedInformerFactory = informerFactory\n                return []admission.PluginInitializer{\n                    custominitializer.New(informerFactory),\n                }, nil\n            }\n\n        ...\n    }\n    ```", "```\napiVersion: apiregistration.k8s.io/v1beta1\nkind: APIService\nmetadata:\n  name: *`name`*\nspec:\n  group: *`API-group-name`*\n  version: *`API-group-version`*\n  service:\n    namespace: *`custom-API-server-service-namespace`*\n    name: *`custom-API-server-service`*\n  caBundle: *`base64-caBundle`*\n  insecureSkipTLSVerify: *`bool`*\n  groupPriorityMinimum: 2000\n  versionPriority: 20\n\n```", "```\n    apiVersion: apiregistration.k8s.io/v1beta1\n    kind: APIService\n    metadata:\n      name: v1alpha1.restaurant.programming-kubernetes.info\n    spec:\n      insecureSkipTLSVerify: true\n      group: restaurant.programming-kubernetes.info\n      groupPriorityMinimum: 1000\n      versionPriority: 15\n      service:\n        name: api\n        namespace: pizza-apiserver\n      version: v1alpha1\n    ```", "```\n    apiVersion: apiregistration.k8s.io/v1beta1\n    kind: APIService\n    metadata:\n      name: v1alpha1.restaurant.programming-kubernetes.info\n    spec:\n      insecureSkipTLSVerify: true\n      group: restaurant.programming-kubernetes.info\n      groupPriorityMinimum: 1000\n      versionPriority: 15\n      service:\n        name: api\n        namespace: pizza-apiserver\n      version: v1alpha1\n    ```", "```\n    apiVersion: v1\n    kind: Service\n    metadata:\n      name: api\n      namespace: pizza-apiserver\n    spec:\n      ports:\n      - port: 443\n        protocol: TCP\n        targetPort: 8443\n      selector:\n        apiserver: \"true\"\n    ```", "```\n    apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: pizza-apiserver\n      namespace: pizza-apiserver\n      labels:\n        apiserver: \"true\"\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          apiserver: \"true\"\n      template:\n        metadata:\n          labels:\n            apiserver: \"true\"\n        spec:\n          serviceAccountName: apiserver\n          containers:\n          - name: apiserver\n            image: quay.io/programming-kubernetes/pizza-apiserver:latest\n            imagePullPolicy: Always\n            command: [\"/pizza-apiserver\"]\n            args:\n            - --etcd-servers=http://localhost:2379\n            - --cert-dir=/tmp/certs\n            - --secure-port=8443\n            - --v=4\n          - name: etcd\n            image: quay.io/coreos/etcd:v3.2.24\n            workingDir: /tmp\n    ```", "```\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: pizza-apiserver\n    spec: {}\n    ```", "```\nkind: ServiceAccount\napiVersion: v1\nmetadata:\n  name: apiserver\n  namespace: pizza-apiserver\n```", "```\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: aggregated-apiserver-clusterrole\nrules:\n- apiGroups: [\"\"]\n  resources: [\"namespaces\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n- apiGroups: [\"admissionregistration.k8s.io\"]\n  resources: [\"mutatingwebhookconfigurations\", \"validatingwebhookconfigurations\"]\n  verbs: [\"get\", \"watch\", \"list\"]\n```", "```\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: pizza-apiserver-clusterrolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: aggregated-apiserver-clusterrole\nsubjects:\n- kind: ServiceAccount\n  name: apiserver\n  namespace: pizza-apiserver\n```", "```\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: pizza-apiserver-auth-reader\n  namespace: kube-system\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: extension-apiserver-authentication-reader\nsubjects:\n- kind: ServiceAccount\n  name: apiserver\n  namespace: pizza-apiserver\n```", "```\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: pizza-apiserver:system:auth-delegator\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:auth-delegator\nsubjects:\n- kind: ServiceAccount\n  name: apiserver\n  namespace: pizza-apiserver\n```", "```\n$ cd $GOPATH/src/github.com/programming-kubernetes/pizza-apiserver\n$ cd artifacts/deployment\n$ kubectl apply -f ns.yaml # create the namespace first\n$ kubectl apply -f .       # creating all manifests described above\n```", "```\n$ kubectl get pods -A\nNAMESPACE       NAME                            READY STATUS            AGE\npizza-apiserver pizza-apiserver-7779f8d486-8fpgj 0/2  ContainerCreating 1s\n$ # some moments later\n$ kubectl get pods -A\npizza-apiserver pizza-apiserver-7779f8d486-8fpgj 2/2  Running           75s\n```", "```\n$ kubectl get apiservices v1alpha1.restaurant.programming-kubernetes.info\nNAME                                            SERVICE             AVAILABLE\nv1alpha1.restaurant.programming-kubernetes.info pizza-apiserver/api True\n```", "```\n$ kubectl get pizzas --v=7\n...\n... GET https://localhost:58727/apis?timeout=32s\n...\n... GET https://localhost:58727/apis/restaurant.programming-kubernetes.info/\n                                v1alpha1?timeout=32s\n...\n... GET https://localhost:58727/apis/restaurant.programming-kubernetes.info/\n                                v1beta1/namespaces/default/pizzas?limit=500\n... Request Headers:\n...  Accept: application/json;as=Table;v=v1beta1;g=meta.k8s.io, application/json\n...  User-Agent: kubectl/v1.15.0 (darwin/amd64) kubernetes/f873d2a\n... Response Status: 200 OK in 6 milliseconds\nNo resources found.\n```", "```\n$ cd ../examples\n$ # install toppings first\n$ ls topping* | xargs -n 1 kubectl create -f\n$ kubectl create -f pizza-margherita.yaml\npizza.restaurant.programming-kubernetes.info/margherita created\n$ kubectl get pizza -o yaml margherita\napiVersion: restaurant.programming-kubernetes.info/v1beta1\nkind: Pizza\nmetadata:\n  creationTimestamp: \"2019-05-05T13:39:52Z\"\n  name: margherita\n  namespace: default\n  resourceVersion: \"6\"\n  pizzas/margherita\n  uid: 42ab6e88-6f3b-11e9-8270-0e37170891d3\nspec:\n  toppings:\n  - name: mozzarella\n    quantity: 1\n  - name: tomato\n    quantity: 1\nstatus: {}\n```", "```\napiVersion: restaurant.programming-kubernetes.info/v1alpha1\nkind: Pizza\nmetadata:\n  name: salami\nspec:\n```", "```\n$ kubectl create -f empty-pizza.yaml\npizza.restaurant.programming-kubernetes.info/salami created\n$ kubectl get pizza -o yaml salami\napiVersion: restaurant.programming-kubernetes.info/v1beta1\nkind: Pizza\nmetadata:\n  creationTimestamp: \"2019-05-05T13:42:42Z\"\n  name: salami\n  namespace: default\n  resourceVersion: \"8\"\n  pizzas/salami\n  uid: a7cb7af2-6f3b-11e9-8270-0e37170891d3\nspec:\n  toppings:\n  - name: salami\n    quantity: 1\n  - name: mozzarella\n    quantity: 1\n  - name: tomato\n    quantity: 1\nstatus: {}\n```", "```\n$ kubectl delete pizzas --all\npizza.restaurant.programming-kubernetes.info \"margherita\" deleted\npizza.restaurant.programming-kubernetes.info \"salami\" deleted\n$ kubectl delete toppings --all\ntopping.restaurant.programming-kubernetes.info \"mozzarella\" deleted\ntopping.restaurant.programming-kubernetes.info \"salami\" deleted\ntopping.restaurant.programming-kubernetes.info \"tomato\" deleted\n$ kubectl create -f pizza-margherita.yaml\nError from server (Forbidden): error when creating \"pizza-margherita.yaml\":\n pizzas.restaurant.programming-kubernetes.info \"margherita\" is forbidden:\n   unknown topping: mozzarella\n```", "```\n$ cd ../deployment-secure\n$ make\nopenssl req -new -x509 -subj \"/CN=api.pizza-apiserver.svc\"\n  -nodes -newkey rsa:4096\n  -keyout tls.key -out tls.crt -days 365\nGenerating a 4096 bit RSA private key\n......................++\n................................................................++\nwriting new private key to 'tls.key'\n...\n$ ls *.yaml | xargs -n 1 kubectl apply -f\nclusterrolebinding.rbac.authorization.k8s.io/pizza-apiserver:system:auth-delegator unchanged\nrolebinding.rbac.authorization.k8s.io/pizza-apiserver-auth-reader unchanged\ndeployment.apps/pizza-apiserver configured\nnamespace/pizza-apiserver unchanged\nclusterrolebinding.rbac.authorization.k8s.io/pizza-apiserver-clusterrolebinding unchanged\nclusterrole.rbac.authorization.k8s.io/aggregated-apiserver-clusterrole unchanged\nserviceaccount/apiserver unchanged\nservice/api unchanged\nsecret/serving-cert created\napiservice.apiregistration.k8s.io/v1alpha1.restaurant.programming-kubernetes.info configured\napiservice.apiregistration.k8s.io/v1beta1.restaurant.programming-kubernetes.info configured\n```", "```\n$ kubectl get apiservices v1alpha1.restaurant.programming-kubernetes.info -o yaml\napiVersion: apiregistration.k8s.io/v1\nkind: APIService\nmetadata:\n  name: v1alpha1.restaurant.programming-kubernetes.info\n  ...\nspec:\n  caBundle: LS0tLS1C...\n  group: restaurant.programming-kubernetes.info\n  groupPriorityMinimum: 1000\n  service:\n    name: api\n    namespace: pizza-apiserver\n  version: v1alpha1\n  versionPriority: 15\nstatus:\n  conditions:\n  - lastTransitionTime: \"2019-05-05T14:07:07Z\"\n    message: all checks passed\n    reason: Passed\n    status: \"True\"\n    type: Available\nartifacts/deploymen\n```", "```\n$ kubectl get pizzas\nNo resources found.\n$ cd ../examples\n$ ls topping* | xargs -n 1 kubectl create -f\ntopping.restaurant.programming-kubernetes.info/mozzarella created\ntopping.restaurant.programming-kubernetes.info/salami created\ntopping.restaurant.programming-kubernetes.info/tomato created\n$ kubectl create -f pizza-margherita.yaml\npizza.restaurant.programming-kubernetes.info/margherita created\n```", "```\nconst defaultEtcdPathPrefix =\n    \"/registry/pizza-apiserver.programming-kubernetes.github.com\"\n\nfunc NewCustomServerOptions() *CustomServerOptions {\n    o := &CustomServerOptions{\n        RecommendedOptions: genericoptions.NewRecommendedOptions(\n            defaultEtcdPathPrefix,\n            ...\n        ),\n    }\n\n    return o\n}\n```"]