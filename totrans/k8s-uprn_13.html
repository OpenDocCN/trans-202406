<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 13. ConfigMaps and Secrets" data-type="chapter" epub:type="chapter"><div class="chapter" id="configmaps_secrets">
<h1><span class="label">Chapter 13. </span>ConfigMaps and Secrets</h1>
<p>It’s good practice to make container images as reusable as possible.<a data-primary="ConfigMaps" data-type="indexterm" id="ix_CfgM"/>  The same image should be able to be used for development, staging, and production.  It’s even better if the same image is general-purpose enough to be used across applications and services.  Testing and versioning are more risky and complicated if images need to be re-created for each new environment.  How then do we specialize the use of that image at runtime?</p>
<p>This is where ConfigMaps and Secrets come into play.  ConfigMaps are used to provide configuration information for workloads.  This can be either fine-grained information like a string or a composite value in the form of a file.  <a data-primary="secrets" data-type="indexterm" id="idm45664075068736"/>Secrets are similar to ConfigMaps but focus on making sensitive information available to the workload.  They can be used for things like credentials or TLS certificates.<a data-primary="credentials" data-seealso="ConfigMaps; secrets" data-type="indexterm" id="idm45664075067712"/></p>
<section data-pdf-bookmark="ConfigMaps" data-type="sect1"><div class="sect1" id="idm45664075066640">
<h1>ConfigMaps</h1>
<p>One way to think of a ConfigMap is as a Kubernetes object that defines a small filesystem.  Another way is as a set of variables that can be used when defining the environment or command line for your containers.  The key thing to note is that the ConfigMap is combined with the Pod right before it is run.  This means that the container image and the Pod definition can be reused by many
workloads just by changing the ConfigMap that is used.</p>
<section data-pdf-bookmark="Creating ConfigMaps" data-type="sect2"><div class="sect2" id="idm45664075065216">
<h2>Creating ConfigMaps</h2>
<p>Let’s jump right in and create a ConfigMap.  <a data-primary="ConfigMaps" data-secondary="creating" data-type="indexterm" id="idm45664074990512"/>Like many objects in Kubernetes, you can create these in an immediate, imperative way, or you can create them from a manifest on disk.  We’ll start with the imperative method.</p>
<p>First, suppose we have a file on disk (called <em>my-config.txt</em>) that we want to make available to the Pod in question, as shown in <a data-type="xref" href="#my-config-ex">Example 13-1</a>.</p>
<div data-type="example" id="my-config-ex">
<h5><span class="label">Example 13-1. </span>my-config.txt</h5>
<pre data-type="programlisting"># This is a sample config file that I might use to configure an application
parameter1 = value1
parameter2 = value2</pre></div>
<p>Next, let’s create a ConfigMap with that file.  We’ll also add a couple of simple key/value pairs here.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="create configmap" data-type="indexterm" id="idm45664074985296"/>  These are referred to as literal values on the command line:</p>
<pre data-type="programlisting">$ <strong>kubectl create configmap my-config \
  --from-file=my-config.txt \
  --from-literal=extra-param=extra-value \
  --from-literal=another-param=another-value</strong></pre>
<p>The equivalent YAML for the <a data-primary="YAML" data-secondary="for ConfigMap object" data-secondary-sortas="ConfigMap" data-type="indexterm" id="idm45664074982560"/>ConfigMap object we just created is as follows:</p>
<pre data-type="programlisting">$ <strong>kubectl get configmaps my-config -o yaml</strong>

apiVersion: v1
data:
  another-param: another-value
  extra-param: extra-value
  my-config.txt: |
    # This is a sample config file that I might use to configure an application
    parameter1 = value1
    parameter2 = value2
kind: ConfigMap
metadata:
  creationTimestamp: ...
  name: my-config
  namespace: default
  resourceVersion: "13556"
  selfLink: /api/v1/namespaces/default/configmaps/my-config
  uid: 3641c553-f7de-11e6-98c9-06135271a273</pre>
<p>As you can see, the ConfigMap is just some key/value pairs stored in an object.  The interesting part is when you try to <em>use</em> a ConfigMap.</p>
</div></section>
<section data-pdf-bookmark="Using a ConfigMap" data-type="sect2"><div class="sect2" id="idm45664074979024">
<h2>Using a ConfigMap</h2>
<p>There are three main ways <a data-primary="ConfigMaps" data-secondary="using" data-type="indexterm" id="ix_CfgMuse"/>to use a ConfigMap:</p>
<dl>
<dt>Filesystem</dt>
<dd>
<p>You can mount a ConfigMap into a Pod.<a data-primary="filesystems" data-secondary="using ConfigMap as filesystem" data-type="indexterm" id="idm45664074973888"/>  A file is created for each entry based on the key name.  The contents of that file are set to the value.<a data-primary="environment variables, setting with ConfigMap" data-type="indexterm" id="idm45664074972688"/></p>
</dd>
<dt>Environment variable</dt>
<dd>
<p>A ConfigMap can be used to dynamically set the value of an environment <span class="keep-together">variable</span>.</p>
</dd>
<dt>Command-line argument</dt>
<dd>
<p>Kubernetes supports dynamically creating the command line for a container based on ConfigMap values.<a data-primary="command-line arguments, using ConfigMap" data-type="indexterm" id="idm45664074968496"/></p>
</dd>
</dl>
<p>Let’s create a manifest for <code>kuard</code> that pulls all of these together, as shown in 
<span class="keep-together"><a data-type="xref" href="#kuard_config_YAML_example">Example 13-2</a></span>.</p>
<div data-type="example" id="kuard_config_YAML_example">
<h5><span class="label">Example 13-2. </span>kuard-config.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard-config</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">test-container</code><code class="w"/>
<code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kuar-demo/kuard-amd64:blue</code><code class="w"/>
<code class="w">      </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Always</code><code class="w"/>
<code class="w">      </code><code class="nt">command</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"/kuard"</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"$(EXTRA_PARAM)"</code><code class="w"/>
<code class="w">      </code><code class="nt">env</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1"># An example of an environment variable used inside the container</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ANOTHER_PARAM</code><code class="w"/>
<code class="w">          </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w"/>
<code class="w">              </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-config</code><code class="w"/>
<code class="w">              </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">another-param</code><code class="w"/>
<code class="w">        </code><code class="c1"># An example of an environment variable passed to the command to start</code><code class="w"/>
<code class="w">        </code><code class="c1"># the container (above).</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">EXTRA_PARAM</code><code class="w"/>
<code class="w">          </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w"/>
<code class="w">              </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-config</code><code class="w"/>
<code class="w">              </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">extra-param</code><code class="w"/>
<code class="w">      </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="c1"># Mounting the ConfigMap as a set of files</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-volume</code><code class="w"/>
<code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/config</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-volume</code><code class="w"/>
<code class="w">      </code><code class="nt">configMap</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-config</code><code class="w"/>
<code class="w">  </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Never</code><code class="w"/></pre></div>
<p>For the filesystem method, we create a new volume inside the Pod and give it the name <code>config-volume</code>.  <a data-primary="volumes" data-secondary="ConfigMap" data-type="indexterm" id="idm45664074768448"/>We then define this volume to be a ConfigMap volume and point at the ConfigMap to mount.  We have to specify where this gets mounted into the <code>kuard</code> container with a <code>volumeMount</code>.  In this case, we are mounting it at <span class="keep-together"><code>/config</code></span>.</p>
<p>Environment variables are specified with a special <code>valueFrom</code> member.  This references the ConfigMap and the data key to use within that ConfigMap.<a data-primary="valueFrom member" data-type="indexterm" id="idm45664074804432"/> Command-line arguments build on environment variables.  Kubernetes will perform the correct substitution with a special <code>$(<em>&lt;env-var-name&gt;</em>)</code> syntax.<a data-primary="command-line arguments, using ConfigMap" data-type="indexterm" id="idm45664074802768"/></p>
<p>Run this Pod, and let’s port-forward to examine how the app sees the world:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f kuard-config.yaml</strong>
$ <strong>kubectl port-forward kuard-config 8080</strong></pre>
<p>Now point your browser to <em>http://localhost:8080</em>.  We can look at how we’ve injected configuration values into the program in all three ways. Click the “Server Env” tab on the left.  This will show the command line that the app was launched with along with its environment, as shown in <a data-type="xref" href="#kuard-config1">Figure 13-1</a>.</p>
<figure><div class="figure" id="kuard-config1">
<img alt="kur3 1301" height="1045" src="assets/kur3_1301.png" width="1287"/>
<h6><span class="label">Figure 13-1. </span><code>kuard</code>, showing its environment</h6>
</div></figure>
<p>Here we can see that we’ve added two environment variables (<code>ANOTHER_PARAM</code> and <code>EXTRA_PARAM</code>) whose values are set via the ConfigMap.  We’ve also added an argument to the command line of <code>kuard</code> based on the <code>EXTRA_PARAM</code> value.</p>
<p>Next, click the “File system browser” tab (<a data-type="xref" href="#kuard-config2">Figure 13-2</a>).  This lets you explore the filesystem as the application sees it.  You should see an entry called <code>/config</code>. This is a volume created based on our ConfigMap.  If you navigate into that, you’ll see that a file has been created for each entry of the ConfigMap.  You’ll also see some hidden files (prepended with <em>..</em>) that are used to do a clean swap of new values when the ConfigMap is updated.</p>
<figure><div class="figure" id="kuard-config2">
<img alt="kur3 1302" height="236" src="assets/kur3_1302.png" width="1289"/>
<h6><span class="label">Figure 13-2. </span>The /config directory as seen through <code>kuard</code></h6>
</div></figure>
</div></section>
</div></section>
<section data-pdf-bookmark="Secrets" data-type="sect1"><div class="sect1" id="idm45664074789280">
<h1>Secrets</h1>
<p>While ConfigMaps are great for most configuration data, there is certain data that is extra sensitive.<a data-primary="ConfigMaps" data-secondary="using" data-startref="ix_CfgMuse" data-type="indexterm" id="idm45664074787600"/><a data-primary="ConfigMaps" data-startref="ix_CfgM" data-type="indexterm" id="idm45664074786352"/><a data-primary="secrets" data-type="indexterm" id="ix_scrt"/>  This includes passwords, security tokens, or other types of private keys.<a data-primary="keys" data-secondary="private" data-type="indexterm" id="idm45664074784336"/>  Collectively, we call this type of data “Secrets.”  Kubernetes has native support for storing and handling this data with care.</p>
<p>Secrets enable container images to be created without bundling sensitive data.  This allows containers to remain portable across environments.<a data-primary="container images" data-secondary="creating without bundling sensitive data" data-type="indexterm" id="idm45664074707184"/><a data-primary="Pods" data-secondary="exposure of secrets to" data-type="indexterm" id="idm45664074706336"/> Secrets are exposed to Pods via explicit declaration in Pod manifests and the Kubernetes API.<a data-primary="manifests (Pod)" data-secondary="Secrets declared in" data-type="indexterm" id="idm45664074705248"/>  In this way, the Kubernetes Secrets API provides an application-centric mechanism for exposing sensitive configuration information to applications in a way that’s easy to audit and leverages native OS isolation primitives.</p>
<p>The remainder of this section will explore how to create and manage Kubernetes Secrets, and also lay out best practices for exposing Secrets to Pods that require them.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>By default, Kubernetes Secrets are stored in plain text in the <code>etcd</code> storage for the cluster. <a data-primary="etcd" data-secondary="Kubernetes Secrets stored in" data-type="indexterm" id="idm45664074702480"/>Depending on your requirements, this may not be sufficient security for you. In particular, anyone who has cluster administration rights in your cluster will be able to read all of the Secrets in the cluster.</p>
<p>In recent versions of Kubernetes, support has been added for encrypting the Secrets with a user-supplied key, generally integrated into a cloud key store. Additionally, most cloud key stores have integration with <a href="https://oreil.ly/DRHt6">Kubernetes Secrets Store CSI Driver</a> volumes, enabling you to skip Kubernetes Secrets entirely and rely exclusively on the cloud provider’s key store. <a data-primary="volumes" data-secondary="Kubernetes CSI" data-type="indexterm" id="idm45664074699664"/>All of these options should provide you with sufficient tools to craft a security profile that suits your needs.</p>
</div>
<section data-pdf-bookmark="Creating Secrets" data-type="sect2"><div class="sect2" id="idm45664074698208">
<h2>Creating Secrets</h2>
<p>Secrets are created using the Kubernetes API or the <code>kubectl</code> command-line tool.<a data-primary="secrets" data-secondary="creating" data-type="indexterm" id="idm45664074696096"/>  Secrets hold one or more data elements as a collection of key/value pairs.</p>
<p>In this section, we will create a Secret to store a TLS key and certificate for the <code>kuard</code> application that meets the storage requirements listed previously.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>kuard</code> container image does not bundle a TLS certificate or key. This allows the <code>kuard</code> container to remain portable across environments and distributable through public Docker <span class="keep-together">repositories</span>.</p>
</div>
<p>The first step in creating a Secret is to obtain the raw data we want to store.<a data-primary="TLS (Transport Layer Security)" data-secondary="key and certificate for kuard application" data-type="indexterm" id="idm45664074690624"/><a data-primary="certificates" data-secondary="TLS" data-tertiary="key and certificate for kuard application" data-type="indexterm" id="idm45664074689488"/>  The TLS key and certificate for the <code>kuard</code> application can be downloaded by running the following commands:</p>
<pre data-type="programlisting">$ <strong>curl -o kuard.crt  https://storage.googleapis.com/kuar-demo/kuard.crt</strong>
$ <strong>curl -o kuard.key https://storage.googleapis.com/kuar-demo/kuard.key</strong></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>These certificates are shared with the world and they provide no actual security. Please do not use them except as a learning tool in these examples.</p>
</div>
<p>With the <em>kuard.crt</em> and <em>kuard.key</em> files stored locally, we are ready to create a Secret. Create a Secret named <code>kuard-tls</code> using the <code>create secret</code> command:</p>
<pre data-type="programlisting">$ <strong>kubectl create secret generic kuard-tls \
  --from-file=kuard.crt \
  --from-file=kuard.key</strong></pre>
<p>The <code>kuard-tls</code> Secret has been created with two data elements.<a data-primary="data elements of a Secret" data-type="indexterm" id="idm45664074680784"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="describe secrets" data-type="indexterm" id="idm45664074680016"/>  Run the following command to get details:</p>
<pre data-type="programlisting">$ <strong>kubectl describe secrets kuard-tls</strong>

Name:         kuard-tls
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Type:         Opaque

Data
====
kuard.crt:    1050 bytes
kuard.key:    1679 bytes</pre>
<p>With the <code>kuard-tls</code> Secret in place, we can consume it from a Pod by using a Secrets volume.</p>
</div></section>
<section data-pdf-bookmark="Consuming Secrets" data-type="sect2"><div class="sect2" id="idm45664074697616">
<h2>Consuming Secrets</h2>
<p>Secrets can be consumed using the Kubernetes REST API by applications that know how to call that API directly.<a data-primary="secrets" data-secondary="consuming" data-type="indexterm" id="idm45664074674720"/> However, our goal is to keep applications portable. Not only should they run well in Kubernetes, but they should run, unmodified, on other platforms.<a data-primary="volumes" data-secondary="Secrets" data-type="indexterm" id="idm45664074673456"/></p>
<p>Instead of accessing Secrets through the API server, we can use a <em>Secrets volume</em>. Secret data can be exposed to Pods using the Secrets volume type.<a data-primary="kubelet" data-secondary="Secrets volumes managed by" data-type="indexterm" id="idm45664074671616"/> Secrets volumes are managed by the <code>kubelet</code> and are created at Pod creation time. Secrets are stored on <code>tmpfs</code> volumes (aka RAM disks), and as such are not written to disk on nodes.<a data-primary="tmpfs volumes, Secrets stored in" data-type="indexterm" id="idm45664074669616"/></p>
<p>Each data element of a Secret is stored in a separate file under the target mount point specified in the volume mount. The <code>kuard-tls</code> Secret contains two data elements: <em>kuard.crt</em> and <em>kuard.key</em>. Mounting the <code>kuard-tls</code> Secrets volume to <code>/tls</code> results in the following files:</p>
<pre data-type="programlisting">/tls/kuard.crt
/tls/kuard.key</pre>
<p>The Pod manifest in <a data-type="xref" href="#kuard-secret.yaml_ex">Example 13-3</a> demonstrates how to declare a<a data-primary="manifests (Pod)" data-secondary="declaring a Secrets volume" data-type="indexterm" id="idm45664074663776"/> Secrets volume, which exposes the <code>kuard-tls</code> Secret to the <code>kuard</code> container under <code>/tls</code>.</p>
<div data-type="example" id="kuard-secret.yaml_ex">
<h5><span class="label">Example 13-3. </span>kuard-secret.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard-tls</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard-tls</code><code class="w"/>
<code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kuar-demo/kuard-amd64:blue</code><code class="w"/>
<code class="w">      </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Always</code><code class="w"/>
<code class="w">      </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">tls-certs</code><code class="w"/>
<code class="w">        </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/tls"</code><code class="w"/>
<code class="w">        </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">tls-certs</code><code class="w"/>
<code class="w">      </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard-tls</code><code class="w"/></pre></div>
<p>Create the <code>kuard-tls</code> Pod using <code>kubectl</code> and observe the log output from the running Pod:</p>
<pre data-type="programlisting">$ <strong>kubectl apply -f kuard-secret.yaml</strong></pre>
<p>Connect to the Pod by running:</p>
<pre data-type="programlisting">$ <strong>kubectl port-forward kuard-tls 8443:8443</strong></pre>
<p>Now navigate your browser to <em>https://localhost:8443</em>.  You should see some invalid certificate warnings because this is a self-signed certificate for <em>kuard.example.com</em>.  If you navigate past this warning, you should see the <code>kuard</code> server hosted via HTTPS.  Use the “File system browser” tab to find the certificates on disk in the <code>/tls</code> directory.</p>
</div></section>
<section data-pdf-bookmark="Private Container Registries" data-type="sect2"><div class="sect2" id="idm45664074675888">
<h2>Private Container Registries</h2>
<p>A special use case for Secrets is to store access credentials for private container registries. <a data-primary="secrets" data-secondary="storing access credentials for private container registries" data-type="indexterm" id="idm45664074545200"/><a data-primary="registries" data-secondary="private, storing credentials in Secrets" data-type="indexterm" id="idm45664074544256"/>Kubernetes supports using images stored on private registries, but access to those images requires credentials.<a data-primary="credentials" data-secondary="storing for private container registries using Secrets" data-type="indexterm" id="idm45664074543088"/> Private images can be stored across one or more private registries. This presents a challenge for managing credentials for each private registry on every possible node in the cluster.</p>
<p><em>Image pull Secrets</em> leverage the Secrets API to automate the distribution of private registry credentials. <a data-primary="image pull Secrets" data-type="indexterm" id="idm45664074541264"/>Image pull Secrets are stored just like regular Secrets but are consumed through the <code>spec.imagePullSecrets</code> Pod specification field.<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="create secret docker-registry" data-type="indexterm" id="idm45664074540048"/></p>
<p>Use <code>kubectl create secret docker-registry</code> to create this special kind of Secret:</p>
<pre data-type="programlisting">$ <strong>kubectl create secret docker-registry my-image-pull-secret \
  --docker-username=<em>&lt;username&gt;</em> \
  --docker-password=<em>&lt;password&gt;</em> \
  --docker-email=<em>&lt;email-address&gt;</em></strong></pre>
<p>Enable access to the private repository by referencing the image <code>pull
secret</code> in the Pod manifest file, as shown in <a data-type="xref" href="#kuard_secret_ips-yaml_ex">Example 13-4</a>.</p>
<div data-type="example" id="kuard_secret_ips-yaml_ex">
<h5><span class="label">Example 13-4. </span>kuard-secret-ips.yaml</h5>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard-tls</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard-tls</code><code class="w"/>
<code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">gcr.io/kuar-demo/kuard-amd64:blue</code><code class="w"/>
<code class="w">      </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Always</code><code class="w"/>
<code class="w">      </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">tls-certs</code><code class="w"/>
<code class="w">        </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/tls"</code><code class="w"/>
<code class="w">        </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">imagePullSecrets</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w">  </code><code class="l-Scalar-Plain">my-image-pull-secret</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">tls-certs</code><code class="w"/>
<code class="w">      </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kuard-tls</code><code class="w"/></pre></div>
<p>If you are repeatedly pulling from the same registry, you can add the
Secrets to the default service account associated with each Pod to avoid
having to specify the Secrets in every Pod you create.<a data-primary="service accounts" data-secondary="for each Pod, adding private registry Secrets to" data-secondary-sortas="each" data-type="indexterm" id="idm45664074489664"/><a data-primary="secrets" data-startref="ix_scrt" data-type="indexterm" id="idm45664074389712"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Naming Constraints" data-type="sect1"><div class="sect1" id="idm45664074388704">
<h1>Naming Constraints</h1>
<p>The key names for data items inside of a Secret or ConfigMap are defined to map to valid environment variable names.<a data-primary="secrets" data-secondary="naming constraints" data-type="indexterm" id="idm45664074387040"/><a data-primary="ConfigMaps" data-secondary="naming constraints" data-type="indexterm" id="idm45664074386064"/>  They may begin with a dot, then are followed by a letter or number, followed by characters including dots, dashes, and underscores. Dots cannot be repeated, and dots and underscores or dashes cannot be adjacent to each other.  <span class="keep-together">More formally</span>, this means that they must conform to the regular expression <span class="keep-together"><code>^[.]?[a-zAZ0-9]([.]?[a-zA-Z0-9]+[-_a-zA-Z0-9]?)*$</code></span>.  Some examples of valid and invalid names for ConfigMaps and Secrets are given in <a data-type="xref" href="#configmap_and_secret_table">Table 13-1</a>.</p>
<table id="configmap_and_secret_table">
<caption><span class="label">Table 13-1. </span>ConfigMap and Secret key examples</caption>
<thead>
<tr>
<th>Valid key name</th>
<th>Invalid key name</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>.auth_token</code></p></td>
<td><p><code>Token..properties</code></p></td>
</tr>
<tr>
<td><p><code>Key.pem</code></p></td>
<td><p><code>auth file.json</code></p></td>
</tr>
<tr>
<td><p><code>config_file</code></p></td>
<td><p><code>_password.txt</code></p></td>
</tr>
</tbody>
</table>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When selecting a key name, remember that these keys can be exposed to Pods via a volume mount.<a data-primary="keys" data-secondary="TLS, naming" data-type="indexterm" id="idm45664074350976"/> Pick a name that is going to make sense when specified on a command line or in a config file.  Storing a TLS key as <code>key.pem</code> is clearer than <code>tls-key</code> when configuring applications to access Secrets.</p>
</div>
<p>ConfigMap data values are simple UTF-8 text specified directly in the manifest. Secret data values hold arbitrary data encoded using base64.<a data-primary="base64 encoding of data values in Secrets" data-type="indexterm" id="idm45664074348432"/><a data-primary="data values, specifying for ConfigMaps or Secrets" data-type="indexterm" id="idm45664074347664"/> The use of base64 encoding makes it possible to store binary data.<a data-primary="YAML" data-secondary="Secrets stored in YAML files" data-type="indexterm" id="idm45664074346832"/>  This does, however, make it more difficult to manage Secrets that are stored in YAML files as the base64-encoded value must be put in the YAML. Note that the maximum size for a ConfigMap or Secret is <span class="keep-together">1 MB</span>.</p>
</div></section>
<section data-pdf-bookmark="Managing ConfigMaps and Secrets" data-type="sect1"><div class="sect1" id="idm45664074344784">
<h1>Managing ConfigMaps and Secrets</h1>
<p>ConfigMaps and Secrets are managed through the Kubernetes API.  <a data-primary="ConfigMaps" data-secondary="managing" data-type="indexterm" id="ix_CfgMmg"/><a data-primary="secrets" data-secondary="managing" data-type="indexterm" id="ix_scrtmg"/>The usual <span class="keep-together"><code>create</code></span>, <code>delete</code>, <code>get</code>, and <code>describe</code> commands work for manipulating these objects.</p>
<section data-pdf-bookmark="Listing" data-type="sect2"><div class="sect2" id="idm45664074338336">
<h2>Listing</h2>
<p>You can use the <code>kubectl get secrets</code> command to list all Secrets <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get secrets" data-type="indexterm" id="idm45664074336384"/><a data-primary="secrets" data-secondary="managing" data-tertiary="listing all Secrets in namespace" data-type="indexterm" id="idm45664074335136"/>in the current
namespace:</p>
<pre data-type="programlisting">$ <strong>kubectl get secrets</strong>

NAME                  TYPE                                  DATA      AGE
default-token-f5jq2   kubernetes.io/service-account-token   3         1h
kuard-tls             Opaque                                2         20m</pre>
<p>Similarly, you can list all of the <a data-primary="ConfigMaps" data-secondary="managing" data-tertiary="listing all ConfigMaps in namespace" data-type="indexterm" id="idm45664074332064"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get configmaps" data-type="indexterm" id="idm45664074330848"/>ConfigMaps in a namespace:</p>
<pre data-type="programlisting">$ <strong>kubectl get configmaps</strong>

NAME        DATA      AGE
my-config   3         1m</pre>
<p><code>kubectl describe</code> can be used to get more details on a <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="describe configmap" data-type="indexterm" id="idm45664074327632"/>single object:</p>
<pre data-type="programlisting">$ <strong>kubectl describe configmap my-config</strong>

Name:           my-config
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;

Data
====
another-param:  13 bytes
extra-param:    11 bytes
my-config.txt:  116 bytes</pre>
<p>Finally, you can see the raw data (including values in Secrets!) by using a command similar to the following: <code>kubectl get configmap my-config -o yaml</code> or <code>kubectl get secret kuard-tls</code> <code class="keep-together">-o yaml</code>.</p>
</div></section>
<section data-pdf-bookmark="Creating" data-type="sect2"><div class="sect2" id="idm45664074322816">
<h2>Creating</h2>
<p>The easiest way to create a Secret or a ConfigMap is via <code>kubectl create secret
generic</code> or <code>kubectl create configmap</code>.  There are a variety of ways to specify the data items that go into the Secret or ConfigMap.<a data-primary="ConfigMaps" data-secondary="managing" data-tertiary="creating ConfigMaps" data-type="indexterm" id="idm45664074320448"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="create configmap" data-type="indexterm" id="idm45664074319232"/>  These can be combined in a single command:</p>
<dl>
<dt><code>--from-file=<em>&lt;filename&gt;</em></code></dt>
<dd><p>Load from the file with the Secret data key that’s the same as the filename.</p></dd>
<dt><code>--from-file=<em>&lt;key&gt;</em>=<em>&lt;filename&gt;</em></code></dt>
<dd><p>Load from the file with the Secret data key explicitly specified.</p></dd>
<dt><code>--from-file=<em>&lt;directory&gt;</em></code></dt>
<dd><p>Load all the files in the specified directory where the filename is an acceptable key name.</p></dd>
<dt><code>--from-literal=<em>&lt;key&gt;</em>=<em>&lt;value&gt;</em></code></dt>
<dd><p>Use the specified key/value pair directly.</p></dd>
</dl>
</div></section>
<section data-pdf-bookmark="Updating" data-type="sect2"><div class="sect2" id="idm45664074310416">
<h2>Updating</h2>
<p>You can update a ConfigMap or Secret and have it reflected in running applications.<a data-primary="ConfigMaps" data-secondary="managing" data-tertiary="updating from a file" data-type="indexterm" id="idm45664074308912"/>  There is no need to restart if the application is configured to reread configuration values. Next, we will describe three ways to update ConfigMaps or Secrets.</p>
<section data-pdf-bookmark="Update from file" data-type="sect3"><div class="sect3" id="idm45664074307408">
<h3>Update from file</h3>
<p>If you have a manifest for your ConfigMap or Secret, you can just edit it
directly and replace it with a new version using <code>kubectl replace -f &lt;<em>filename</em>&gt;</code>.  <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="replace" data-type="indexterm" id="idm45664074304896"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="apply -f" data-type="indexterm" id="idm45664074303616"/>You can also use <code>kubectl apply -f <em>&lt;filename&gt;</em></code> if you previously created the resource with <code>kubectl apply</code>.</p>
<p>Due to the way that datafiles are encoded into these objects, updating a configuration can be a bit cumbersome; there is no <code>kubectl</code> command that supports loading data from an external file.  The data must be stored directly in the YAML manifest.</p>
<p>The most common use case is when the ConfigMap is defined as part of a directory or list of resources and everything is created and updated together.  Oftentimes these manifests will be checked into source control.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>It is generally a bad idea to check Secret YAML files into source control because it is too easy to inadvertently push these files someplace public and leak your Secrets.</p>
</div>
</div></section>
<section data-pdf-bookmark="Re-create and update" data-type="sect3"><div class="sect3" id="idm45664074298000">
<h3>Re-create and update</h3>
<p>If you store the inputs into your ConfigMaps or Secrets as separate files on disk (as opposed to embedded into YAML directly), you can use <code>kubectl</code> to re-create the manifest and then use it to update the object<a data-primary="ConfigMaps" data-secondary="managing" data-tertiary="recreating and updating" data-type="indexterm" id="idm45664074296096"/><a data-primary="secrets" data-secondary="managing" data-tertiary="recreating and updating" data-type="indexterm" id="idm45664074294848"/>, which will look something <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="create secret" data-type="indexterm" id="idm45664074293504"/>like this:</p>
<pre data-type="programlisting">$ <strong>kubectl create secret generic kuard-tls \
  --from-file=kuard.crt --from-file=kuard.key \
  --dry-run -o yaml | kubectl replace -f -</strong></pre>
<p>This command line first creates a new Secret with the same name as our
existing Secret.  If we just stopped there, the Kubernetes API server would return an error complaining that we are trying to create a Secret that already exists.  Instead, we tell <code>kubectl</code> not to actually send the data to the server but instead to dump the YAML that it <em>would have</em> sent to the API server to <code>stdout</code>.  We then pipe that to <code>kubectl replace</code> and use <code>-f -</code> to tell it to read from <code>stdin</code>.  In this way, we can update a Secret from files on disk without having to manually base64-encode data.<a data-primary="base64 encoding of data values in Secrets" data-type="indexterm" id="idm45664074287744"/></p>
</div></section>
<section data-pdf-bookmark="Edit current version" data-type="sect3"><div class="sect3" id="idm45664074286816">
<h3>Edit current version</h3>
<p>The final way to update a ConfigMap is to use <code>kubectl edit</code> to bring up a version of the ConfigMap <a data-primary="ConfigMaps" data-secondary="managing" data-tertiary="editing current version" data-type="indexterm" id="idm45664074285072"/><a data-primary="kubectl tool" data-secondary="commands" data-tertiary="edit" data-type="indexterm" id="idm45664074283824"/>in your editor so you can tweak it (you could also do this with a Secret, but you’d be stuck managing the base64 encoding of values on your own):</p>
<pre data-type="programlisting">$ <strong>kubectl edit configmap my-config</strong></pre>
<p>You should see the ConfigMap definition in your editor. Make your desired changes and then save and close your editor. The new version of the object will be pushed to the Kubernetes API server.</p>
</div></section>
<section data-pdf-bookmark="Live updates" data-type="sect3"><div class="sect3" id="idm45664074280704">
<h3>Live updates</h3>
<p>Once a ConfigMap or Secret is updated using the API, it’ll be automatically pushed to all volumes that use that ConfigMap or Secret.<a data-primary="secrets" data-secondary="managing" data-tertiary="live updates" data-type="indexterm" id="idm45664074279232"/><a data-primary="ConfigMaps" data-secondary="managing" data-tertiary="live updates" data-type="indexterm" id="idm45664074277984"/> It may take a few seconds, but the file listing and contents of the files, as seen by <code>kuard</code>, will be updated with these new values.  Using this live update feature, you can update the configuration of applications without restarting them.</p>
<p>Currently there is no built-in way to signal an application when a new version of a ConfigMap is deployed.  <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="port-forward" data-type="indexterm" id="idm45664074275456"/>It is up to the application (or some helper script) to look for the config files to change and reload them.</p>
<p>Using the file browser in <code>kuard</code> (accessed through <code>kubectl port-forward</code>) is a
great way to interactively play with dynamically updating Secrets and
ConfigMaps.</p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45664074272336">
<h1>Summary</h1>
<p>ConfigMaps and Secrets are a great way to provide dynamic configuration in
your application.<a data-primary="secrets" data-secondary="managing" data-startref="ix_scrtmg" data-type="indexterm" id="idm45664074270896"/><a data-primary="ConfigMaps" data-secondary="managing" data-startref="ix_CfgMmg" data-type="indexterm" id="idm45664074269648"/>  They allow you to create a container image (and Pod
definition) once and reuse it in different contexts. This can include using the exact same image as you move from development to staging to production.  It can also include using a single image across multiple teams and services.  Separating configuration from application code will make your applications more reliable and reusable.</p>
</div></section>
</div></section></div></body></html>