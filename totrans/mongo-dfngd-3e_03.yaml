- en: Chapter 2\. Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB is powerful but easy to get started with. In this chapter we’ll introduce
    some of the basic concepts of MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: A *document* is the basic unit of data for MongoDB and is roughly equivalent
    to a row in a relational database management system (but much more expressive).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, a *collection* can be thought of as a table with a dynamic schema.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single instance of MongoDB can host multiple independent *databases*, each
    of which contains its own collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every document has a special key, `"_id"`, that is unique within a collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB is distributed with a simple but powerful tool called the *mongo shell*.
    The *mongo* shell provides built-in support for administering MongoDB instances
    and manipulating data using the MongoDB query language. It is also a fully functional
    JavaScript interpreter that enables users to create and load their own scripts
    for a variety of purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the heart of MongoDB is the *document*: an ordered set of keys with associated
    values. The representation of a document varies by programming language, but most
    languages have a data structure that is a natural fit, such as a map, hash, or
    dictionary. In JavaScript, for example, documents are represented as objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple document contains a single key, `"greeting"`, with a value of `"Hello,
    world!"`. Most documents will be more complex than this simple one and often will
    contain multiple key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, values in documents are not just “blobs.” They can be one of
    several different data types (or even an entire embedded document—see [“Embedded
    Documents”](#embedded-documents)). In this example the value for `"greeting"`
    is a string, whereas the value for `"views"` is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in a document are strings. Any UTF-8 character is allowed in a key,
    with a few notable exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Keys must not contain the character *\0* (the `null` character). This character
    is used to signify the end of a key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *.* and *$* characters have some special properties and should be used only
    in certain circumstances, as described in later chapters. In general, they should
    be considered reserved, and drivers will complain if they are used inappropriately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB is type-sensitive and case-sensitive. For example, these documents
    are distinct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'as are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A final important thing to note is that documents in MongoDB cannot contain
    duplicate keys. For example, the following is not a legal document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *collection* is a group of documents. If a document is the MongoDB analog
    of a row in a relational database, then a collection can be thought of as the
    analog to a table.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Schemas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collections have *dynamic schemas*. This means that the documents within a
    single collection can have any number of different “shapes.” For example, both
    of the following documents could be stored in a single collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the previous documents have different keys, different numbers of
    keys, and values of different types. Because any document can be put into any
    collection, the question often arises: “Why do we need separate collections at
    all?” With no need for separate schemas for different kinds of documents, why
    *should* we use more than one collection? There are several good reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping different kinds of documents in the same collection can be a nightmare
    for developers and admins. Developers need to make sure that each query is only
    returning documents adhering to a particular schema or that the application code
    performing a query can handle documents of different shapes. If we’re querying
    for blog posts, it’s a hassle to weed out documents containing author data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s much faster to get a list of collections than to extract a list of the
    types of documents in a collection. For example, if we had a `"type"` field in
    each document that specified whether the document was a “skim,” “whole,” or “chunky
    monkey,” it would be much slower to find those three values in a single collection
    than to have three separate collections and query the correct collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping documents of the same kind together in the same collection allows for
    data locality. Getting several blog posts from a collection containing only posts
    will likely require fewer disk seeks than getting the same posts from a collection
    containing posts and author data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We begin to impose some structure on our documents when we create indexes. (This
    is especially true in the case of unique indexes.) These indexes are defined per
    collection. By putting only documents of a single type into the same collection,
    we can index our collections more efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are sound reasons for creating a schema and for grouping related types
    of documents together. While not required by default, defining schemas for your
    application is good practice and can be enforced through the use of MongoDB’s
    documentation validation functionality and object–document mapping libraries available
    for many programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A collection is identified by its name. Collection names can be any UTF-8 string,
    with a few restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The empty string (`""`) is not a valid collection name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection names may not contain the character *\0* (the `null` character),
    because this delineates the end of a collection name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should not create any collections with names that start with *system.*,
    a prefix reserved for internal collections. For example, the *system.users* collection
    contains the database’s users, and the *system.namespaces* collection contains
    information about all of the database’s collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-created collections should not contain the reserved character *$* in their
    names. The various drivers available for the database do support using *$* in
    collection names because some system-generated collections contain it, but you
    should not use *$* in a name unless you are accessing one of these collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subcollections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One convention for organizing collections is to use namespaced subcollections
    separated by the *.* character. For example, an application containing a blog
    might have a collection named *blog.posts* and a separate collection named *blog.authors*.
    This is for organizational purposes only—there is no relationship between the
    *blog* collection (it doesn’t even have to exist) and its “children.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Although subcollections do not have any special properties, they are useful
    and are incorporated into many MongoDB tools. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: GridFS, a protocol for storing large files, uses subcollections to store file
    metadata separately from content chunks (see [Chapter 6](ch06.xhtml#chapter-idx-types)
    for more information about GridFS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most drivers provide some syntactic sugar for accessing a subcollection of a
    given collection. For example, in the database shell, `db.blog` will give you
    the *blog* collection, and `db.blog.posts` will give you the *blog.posts* collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subcollections are a good way to organize data in MongoDB for many use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to grouping documents by collection, MongoDB groups collections
    into *databases*. A single instance of MongoDB can host several databases, each
    grouping together zero or more collections. A good rule of thumb is to store all
    data for a single application in the same database. Separate databases are useful
    when storing data for several applications or users on the same MongoDB server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like collections, databases are identified by name. Database names can be any
    UTF-8 string, with the following restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The empty string (*“”*) is not a valid database name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A database name cannot contain any of these characters: */*, *\*, *.*, *"*,
    ***, *<*, *>*, *:*, *|*, *?*, *$*, (a single space), or *\0* (the `null` character).
    Basically, stick with alphanumeric ASCII.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database names are case-insensitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database names are limited to a maximum of 64 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historically, prior to the use of the WiredTiger storage engine, database names
    became files on your filesystem. It is no longer the case. This explains why many
    of the previous restrictions exist in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some reserved database names, which you can access but which
    have special semantics. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*admin*'
  prefs: []
  type: TYPE_NORMAL
- en: The *admin* database plays a role in authentication and authorization. In addition,
    access to this database is required for some administrative operations. See [Chapter 19](ch19.xhtml#chapter-data-admin)
    for more information about the *admin* database.
  prefs: []
  type: TYPE_NORMAL
- en: '*local*'
  prefs: []
  type: TYPE_NORMAL
- en: This database stores data specific to a single server. In replica sets, *local*
    stores data used in the replication process. The *local* database itself is never
    replicated. (See [Chapter 10](ch10.xhtml#chapter_d1e9405) for more information
    about replication and the local database.)
  prefs: []
  type: TYPE_NORMAL
- en: '*config*'
  prefs: []
  type: TYPE_NORMAL
- en: Sharded MongoDB clusters (see [Chapter 14](ch14.xhtml#chapter_d1e10482)) use
    the *config* database to store information about each shard.
  prefs: []
  type: TYPE_NORMAL
- en: By concatenating a database name with a collection in that database you can
    get a fully qualified collection name, which is called a *namespace*. For instance,
    if you are using the *blog.posts* collection in the *cms* database, the namespace
    of that collection would be *cms.blog.posts*. Namespaces are limited to 120 bytes
    in length and, in practice, should be fewer than 100 bytes long. For more on namespaces
    and the internal representation of collections in MongoDB, see [Appendix B](app02.xhtml#appendix_see).
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Starting MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start the server, run the *mongod* executable in the Unix command-line environment
    of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re on Windows, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For detailed information on installing MongoDB on your system, see [Appendix A](app01.xhtml#appendix_d1e12346)
    or the appropriate [installation tutorial](https://oreil.ly/5WP5e) in the MongoDB
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: When run with no arguments, *mongod* will use the default data directory, */data/db/*
    (or *\data\db\* on the current volume on Windows). If the data directory does
    not already exist or is not writable, the server will fail to start. It is important
    to create the data directory (e.g., `mkdir -p /data/db/`) and to make sure your
    user has permission to write to the directory before starting MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: On startup, the server will print some version and system information and then
    begin waiting for connections. By default MongoDB listens for socket connections
    on port 27017\. The server will fail to start if that port is not available—the
    most common cause of this is another instance of MongoDB that is already running.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should always secure your *mongod* instances. See [Chapter 19](ch19.xhtml#chapter-data-admin)
    for more information on securing MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: You can safely stop *mongod* by typing Ctrl-C in the command-line-environment
    from which you launched the *mongod* server.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For more information on starting or stopping MongoDB, see [Chapter 21](ch21.xhtml#chapter-start-stop).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the MongoDB Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB comes with a JavaScript shell that allows interaction with a MongoDB
    instance from the command line. The shell is useful for performing administrative
    functions, inspecting a running instance, or just exploring MongoDB. The *mongo*
    shell is a crucial tool for using MongoDB. We’ll use it extensively throughout
    the rest of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the shell, run the *mongo* executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The shell automatically attempts to connect to a MongoDB server running on the
    local machine on startup, so make sure you start *mongod* before starting the
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell is a full-featured JavaScript interpreter, capable of running arbitrary
    JavaScript programs. To illustrate this, let’s perform some basic math:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also leverage all of the standard JavaScript libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even define and call JavaScript functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can create multiline commands. The shell will detect whether the
    JavaScript statement is complete when you press Enter. If the statement is not
    complete, the shell will allow you to continue writing it on the next line. Pressing
    Enter three times in a row will cancel the half-formed command and get you back
    to the `>` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: A MongoDB Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the ability to execute arbitrary JavaScript is useful, the real power
    of the shell lies in the fact that it is also a standalone MongoDB client. On
    startup, the shell connects to the *test* database on a MongoDB server and assigns
    this database connection to the global variable `db`. This variable is the primary
    access point to your MongoDB server through the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the database to which `db` is currently assigned, type in `db` and hit
    Enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell contains some add-ons that are not valid JavaScript syntax but were
    implemented because of their familiarity to users of SQL shells. The add-ons do
    not provide any extra functionality, but they are nice syntactic sugar. For instance,
    one of the most important operations is selecting which database to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you look at the `db` variable, you can see that it refers to the *video*
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because this is a JavaScript shell, typing a variable name will cause the name
    to be evaluated as an expression. The value (in this case, the database name)
    is then printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may access collections from the `db` variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: returns the *movies* collection in the current database. Now that we can access
    a collection in the shell, we can perform almost any database operation.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations with the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the four basic operations, create, read, update, and delete (CRUD),
    to manipulate and view data in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `insertOne` function adds a document to a collection. For example, suppose
    we want to store a movie. First, we’ll create a local variable called `movie`
    that is a JavaScript object representing our document. It will have the keys `"title"`,
    `"director"`, and `"year"` (the year it was released):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This object is a valid MongoDB document, so we can save it to the *movies*
    collection using the `insertOne` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The movie has been saved to the database. We can see it by calling `find` on
    the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that an `"_id"` key was added and that the other key/value pairs
    were saved as we entered them. The reason for the sudden appearance of the `"_id"`
    field is explained at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Read
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`find` and `findOne` can be used to query a collection. If we just want to
    see one document from a collection, we can use `findOne`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`find` and `findOne` can also be passed criteria in the form of a query document.
    This will restrict the documents matched by the query. The shell will automatically
    display up to 20 documents matching a `find`, but more can be fetched. (See [Chapter 4](ch04.xhtml#chapter_d1e3559)
    for more information on querying.)'
  prefs: []
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we would like to modify our post, we can use `updateOne`. `updateOne` takes
    (at least) two parameters: the first is the criteria to find which document to
    update, and the second is a document describing the updates to make. Suppose we
    decide to enable reviews for the movie we created earlier. We’ll need to add an
    array of reviews as the value for a new key in our document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the update, we’ll need to use an update operator, `set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the document has a `"reviews"` key. If we call `find` again, we can see
    the new key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See [“Updating Documents”](ch03.xhtml#sect1_d1e2484) for detailed information
    on updating documents.
  prefs: []
  type: TYPE_NORMAL
- en: Delete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`deleteOne` and `deleteMany` permanently delete documents from the database.
    Both methods take a filter document specifying criteria for the removal. For example,
    this would remove the movie we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Use `deleteMany` to delete all documents matching a filter.
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beginning of this chapter covered the basics of what a document is. Now
    that you are up and running with MongoDB and can try things in the shell, this
    section will dive a little deeper. MongoDB supports a wide range of data types
    as values in documents. In this section, we’ll outline all the supported types.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Documents in MongoDB can be thought of as “JSON-like” in that they are conceptually
    similar to objects in JavaScript. [JSON](http://www.json.org) is a simple representation
    of data: the specification can be described in about one paragraph (the website
    proves it) and lists only six data types. This is a good thing in many ways: it’s
    easy to understand, parse, and remember. On the other hand, JSON’s expressive
    capabilities are limited because the only types are null, boolean, numeric, string,
    array, and object.'
  prefs: []
  type: TYPE_NORMAL
- en: Although these types allow for an impressive amount of expressivity, there are
    a couple of additional types that are crucial for most applications, especially
    when working with a database. For example, JSON has no date type, which makes
    working with dates even more annoying than it usually is. There is a number type,
    but only one—there is no way to differentiate floats and integers, never mind
    any distinction between 32-bit and 64-bit numbers. There is no way to represent
    other commonly used types, either, such as regular expressions or functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB adds support for a number of additional data types while keeping JSON’s
    essential key/value–pair nature. Exactly how values of each type are represented
    varies by language, but this is a list of the commonly supported types and how
    they are represented as part of a document in the shell. The most common types
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Null'
  prefs: []
  type: TYPE_NORMAL
- en: 'The null type can be used to represent both a null value and a nonexistent
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Boolean
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a boolean type, which can be used for the values `true` and `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Number
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell defaults to using 64-bit floating-point numbers. Thus, these numbers
    both look “normal” in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For integers, use the `NumberInt` or `NumberLong` classes, which represent 4-byte
    or 8-byte signed integers, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: String
  prefs: []
  type: TYPE_NORMAL
- en: 'Any string of UTF-8 characters can be represented using the string type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Date
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB stores dates as 64-bit integers representing milliseconds since the
    Unix epoch (January 1, 1970). The time zone is not stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Regular expression
  prefs: []
  type: TYPE_NORMAL
- en: 'Queries can use regular expressions using JavaScript’s regular expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Array
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets or lists of values can be represented as arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Embedded document
  prefs: []
  type: TYPE_NORMAL
- en: 'Documents can contain entire documents embedded as values in a parent document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Object ID
  prefs: []
  type: TYPE_NORMAL
- en: 'An object ID is a 12-byte ID for documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See the section [“_id and ObjectIds”](#sect2_d1e1990) for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also a few less common types that you may need, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Binary data
  prefs: []
  type: TYPE_NORMAL
- en: Binary data is a string of arbitrary bytes. It cannot be manipulated from the
    shell. Binary data is the only way to save non-UTF-8 strings to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Code
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB also makes it possible to store arbitrary JavaScript in queries and
    documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, there are a few types that are mostly used internally (or superseded
    by other types). These will be described in the text as needed.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on MongoDB’s data format, see [Appendix B](app02.xhtml#appendix_see).
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, the `Date` class is used for MongoDB’s date type. When creating
    a new `Date` object, always call `new Date()`, not just `Date()`. Calling the
    constructor as a function (i.e., not including `new`) returns a string representation
    of the date, not an actual `Date` object. This is not MongoDB’s choice; it is
    how JavaScript works. If you are not careful to always use the `Date` constructor,
    you can end up with a mishmash of strings and dates. Strings do not match dates
    and vice versa, so this can cause problems with removing, updating, querying…pretty
    much everything.
  prefs: []
  type: TYPE_NORMAL
- en: For a full explanation of JavaScript’s `Date` class and acceptable formats for
    the constructor, see [section 15.9 of the ECMAScript specification](http://www.ecma-international.org).
  prefs: []
  type: TYPE_NORMAL
- en: Dates in the shell are displayed using local time zone settings. However, dates
    in the database are just stored as milliseconds since the epoch, so they have
    no time zone information associated with them. (Time zone information could, of
    course, be stored as the value for another key.)
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are values that can be used interchangeably for both ordered operations
    (as though they were lists, stacks, or queues) and unordered operations (as though
    they were sets).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following document, the key `"things"` has an array value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this example, arrays can contain different data types as
    values (in this case, a string and a floating-point number). In fact, array values
    can be any of the supported value types for normal key/value pairs, even nested
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great things about arrays in documents is that MongoDB “understands”
    their structure and knows how to reach inside of arrays to perform operations
    on their contents. This allows us to query on arrays and build indexes using their
    contents. For instance, in the previous example, MongoDB can query for all documents
    where `3.14` is an element of the `"things"` array. If this is a common query,
    you can even create an index on the `"things"` key to improve the query’s speed.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB also allows atomic updates that modify the contents of arrays, such
    as reaching into the array and changing the value `"pie"` to `pi`. We’ll see more
    examples of these types of operations throughout the text.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A document can be used as the value for a key. This is called an *embedded document*.
    Embedded documents can be used to organize data in a more natural way than just
    a flat structure of key/value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a document representing a person and want to store
    that person’s address, we can nest this information in an embedded `"address"`
    document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `"address"` key in this example is an embedded document with
    its own key/value pairs for `"street"`, `"city"`, and `"state"`.
  prefs: []
  type: TYPE_NORMAL
- en: As with arrays, MongoDB “understands” the structure of embedded documents and
    is able to reach inside them to build indexes, perform queries, or make updates.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss schema design in-depth later, but even from this basic example
    we can begin to see how embedded documents can change the way we work with data.
    In a relational database, the previous document would probably be modeled as two
    separate rows in two different tables (*people* and *addresses*). With MongoDB
    we can embed the `"address"` document directly within the `"person"` document.
    Thus, when used properly, embedded documents can provide a more natural representation
    of information.
  prefs: []
  type: TYPE_NORMAL
- en: The flip side of this is that there can be more data repetition with MongoDB.
    Suppose *addresses* was a separate table in a relational database and we needed
    to fix a typo in an address. When we did a join with *people* and *addresses*,
    we’d get the updated address for everyone who shares it. With MongoDB, we’d need
    to fix the typo in each person’s document.
  prefs: []
  type: TYPE_NORMAL
- en: _id and ObjectIds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every document stored in MongoDB must have an `"_id"` key. The `"_id"` key’s
    value can be any type, but it defaults to an `ObjectId`. In a single collection,
    every document must have a unique value for `"_id"`, which ensures that every
    document in a collection can be uniquely identified. That is, if you had two collections,
    each one could have a document where the value for `"_id"` was `123`. However,
    neither collection could contain more than one document with an `"_id"` of `123`.
  prefs: []
  type: TYPE_NORMAL
- en: ObjectIds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ObjectId` is the default type for `"_id"`. The `ObjectId` class is designed
    to be lightweight, while still being easy to generate in a globally unique way
    across different machines. MongoDB’s distributed nature is the main reason why
    it uses `ObjectId`s as opposed to something more traditional, like an autoincrementing
    primary key: it is difficult and time-consuming to synchronize autoincrementing
    primary keys across multiple servers. Because MongoDB was designed to be a distributed
    database, it was important to be able to generate unique identifiers in a sharded
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ObjectId`s use 12 bytes of storage, which gives them a string representation
    that is 24 hexadecimal digits: 2 digits for each byte. This causes them to appear
    larger than they are, which makes some people nervous. It’s important to note
    that even though an `ObjectId` is often represented as a giant hexadecimal string,
    the string is actually twice as long as the data being stored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create multiple new `ObjectId`s in rapid succession, you can see that
    only the last few digits change each time. In addition, a couple of digits in
    the middle of the `ObjectId` will change if you space the creations out by a couple
    of seconds. This is because of the manner in which `ObjectId`s are created. The
    12 bytes of an `ObjectId` are generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| Timestamp | Random | Counter (random start value) |'
  prefs: []
  type: TYPE_TB
- en: 'The first four bytes of an `ObjectId` are a timestamp in seconds since the
    epoch. This provides a couple of useful properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The timestamp, when combined with the next five bytes (which will be described
    in a moment), provides uniqueness at the granularity of a second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the timestamp comes first, `ObjectId`s will sort in *rough* insertion
    order. This is not a strong guarantee but does have some nice properties, such
    as making `ObjectId`s efficient to index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these four bytes exists an implicit timestamp of when each document was created.
    Most drivers expose a method for extracting this information from an `ObjectId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the current time is used in `ObjectId`s, some users worry that their
    servers will need to have synchronized clocks. Although synchronized clocks are
    a good idea for other reasons (see [“Synchronizing Clocks”](ch24.xhtml#clock-sync)),
    the actual timestamp doesn’t matter to `ObjectId`s, only that it is often new
    (once per second) and increasing.
  prefs: []
  type: TYPE_NORMAL
- en: The next five bytes of an `ObjectId` are a random value. The final three bytes
    are a counter that starts with a random value to avoid generating colliding `ObjectId`s
    on different machines.
  prefs: []
  type: TYPE_NORMAL
- en: These first nine bytes of an `ObjectId` therefore guarantee its uniqueness across
    machines and processes for a single second. The last three bytes are simply an
    incrementing counter that is responsible for uniqueness within a second in a single
    process. This allows for up to 256³ (16,777,216) unique `ObjectId`s to be generated
    *per process* in a single second.
  prefs: []
  type: TYPE_NORMAL
- en: Autogeneration of _id
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated earlier, if there is no `"_id"` key present when a document is inserted,
    one will be automatically added to the inserted document. This can be handled
    by the MongoDB server but will generally be done by the driver on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Using the MongoDB Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers how to use the shell as part of your command-line toolkit,
    customize it, and use some of its more advanced functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we connected to a local *mongod* instance above, you can connect your
    shell to any MongoDB instance that your machine can reach. To connect to a *mongod*
    on a different machine or port, specify the hostname, port, and database when
    starting the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`db` will now refer to *some-host:30000*’s `myDB` database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is handy to not connect to a *mongod* at all when starting the
    *mongo* shell. If you start the shell with `--nodb`, it will start up without
    attempting to connect to anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once started, you can connect to a *mongod* at your leisure by running ``new
    Mongo("*`hostname`*")``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After these two commands, you can use `db` normally. You can use these commands
    to connect to a different database or server at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for Using the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because *mongo* is simply a JavaScript shell, you can get a great deal of help
    for it by simply looking up JavaScript documentation online. For MongoDB-specific
    functionality, the shell includes built-in help that can be accessed by typing
    ``**`help`**``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Database-level help is provided by `db.help()` and collection-level help by
    `db.foo.help()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way of figuring out what a function is doing is to type it without the
    parentheses. This will print the JavaScript source code for the function. For
    example, if you are curious about how the `update` function works or cannot remember
    the order of parameters, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Running Scripts with the Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to using the shell interactively, you can also pass the shell JavaScript
    files to execute. Simply pass in your scripts at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The *mongo* shell will execute each script listed and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run a script using a connection to a nondefault host/port *mongod*,
    specify the address first, then the script(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This would execute the three scripts with `db` set to the *foo* database on
    *server-1:30000*.
  prefs: []
  type: TYPE_NORMAL
- en: You can print to stdout in scripts (as the preceding scripts did) using the
    `print` function. This allows you to use the shell as part of a pipeline of commands.
    If you’re planning to pipe the output of a shell script to another command, use
    the `--quiet` option to prevent the “MongoDB shell version v4.2.0” banner from
    printing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run scripts from within the interactive shell using the `load`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Scripts have access to the `db` variable (as well as any other global). However,
    shell helpers such as `use db` or `show collections` do not work from files. There
    are valid JavaScript equivalents to each of these, as shown in [Table 2-1](#table-js-helpers).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. JavaScript equivalents to shell helpers
  prefs: []
  type: TYPE_NORMAL
- en: '| Helper | Equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `use video` | `db.getSisterDB("video")` |'
  prefs: []
  type: TYPE_TB
- en: '| `show dbs` | `db.getMongo().getDBs()` |'
  prefs: []
  type: TYPE_TB
- en: '| `show collections` | `db.getCollectionNames()` |'
  prefs: []
  type: TYPE_TB
- en: 'You can also use scripts to inject variables into the shell. For example, you
    could have a script that simply initializes helper functions that you commonly
    use. The following script, for instance, may be helpful for [Part III](part03.xhtml#part3_replication)
    and [Part IV](part04.xhtml#part4_sharding). It defines a function, `connectTo`,
    that connects to the locally running database on the given port and sets `db`
    to that connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you load this script in the shell, `connectTo` is now defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In addition to adding helper functions, you can use scripts to automate common
    tasks and administrative activities.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the shell will look in the directory that you started the shell
    in (use `pwd()` to see what directory that is). If the script is not in your current
    directory, you can give the shell a relative or absolute path to it. For example,
    if you wanted to put your shell scripts in *~/my-scripts*, you could load *defineConnectTo.js*
    with `load("/home/myUser/my-scripts/defineConnectTo.js")`. Note that `load` cannot
    resolve `~`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `run` to run command-line programs from the shell. You can pass
    arguments to the function as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is of limited use, generally, as the output is formatted oddly and it doesn’t
    support pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .mongorc.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have frequently loaded scripts, you might want to put them in your *.mongorc.js*
    file. This file is run whenever you start up the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you would like the shell to greet you when you log in.
    Create a file called *.mongorc.js* in your home directory, and then add the following
    lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when you start the shell, you’ll see something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'More practically, you can use this script to set up any global variables you’d
    like to use, alias long names to shorter ones, and override built-in functions.
    One of the most common uses for *.mongorc.js* is to remove some of the more “dangerous”
    shell helpers. You can override functions like `dropDatabase` or `deleteIndexes`
    with no-ops or undefine them altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now if you try to call any of these functions, it will simply print an error
    message. Note that this technique does not protect you against malicious users;
    it can only help with fat-fingering.
  prefs: []
  type: TYPE_NORMAL
- en: You can disable loading your *.mongorc.js* by using the `--norc` option when
    starting the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Your Prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default shell prompt can be overridden by setting the `prompt` variable
    to either a string or a function. For example, if you are running a query that
    takes minutes to complete, you may want to have a prompt that displays the current
    time so you can see when the last operation finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Another handy prompt might show the current database you’re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that prompt functions should return strings and be very cautious about
    catching exceptions: it can be extremely confusing if your prompt turns into an
    exception!'
  prefs: []
  type: TYPE_NORMAL
- en: In general, your prompt function should include a call to `getLastError`. This
    catches errors on writes and reconnects you automatically if the shell gets disconnected
    (e.g., if you restart *mongod*).
  prefs: []
  type: TYPE_NORMAL
- en: The *.mongorc.js* file is a good place to set your prompt if you want to always
    use a custom one (or set up a couple of custom prompts that you can switch between
    in the shell).
  prefs: []
  type: TYPE_NORMAL
- en: Editing Complex Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The multiline support in the shell is somewhat limited: you cannot edit previous
    lines, which can be annoying when you realize that the first line has a typo and
    you’re currently working on line 15\. Thus, for larger blocks of code or objects,
    you may want to edit them in an editor. To do so, set the `EDITOR` variable in
    the shell (or in your environment, but since you’re already in the shell…):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you want to edit a variable, you can say *`edit varname`*—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When you’re done making changes, save and exit the editor. The variable will
    be parsed and loaded back into the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Add ``EDITOR="*`/path/to/editor`*";`` to your *.mongorc.js* file and you won’t
    have to worry about setting it again.
  prefs: []
  type: TYPE_NORMAL
- en: Inconvenient Collection Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fetching a collection with the ``db.*`collectionName`*`` syntax almost always
    works, unless the collection name is a reserved word or is an invalid JavaScript
    property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we are trying to access the *version* collection. We cannot
    say `db.version` because `db.version` is a method on `db` (it returns the version
    of the running MongoDB server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To actually access the *version* collection, you must use the `getCollection`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This can also be used for collection names with characters that aren’t valid
    JavaScript property names, such as *foo-bar-baz* and *123abc* (JavaScript property
    names can only contain letters, numbers, *$* and *_*, and cannot start with a
    number).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of getting around invalid properties is to use array-access syntax.
    In JavaScript, `x.y` is identical to `x[''y'']`. This means that subcollections
    can be accessed using variables, not just literal names. Thus, if you needed to
    perform some operation on every *blog* subcollection, you could iterate through
    them with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'instead of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that you cannot do `db.blog.i`, which would be interpreted as `test.blog.i`,
    not `test.blog.posts`. You must use the `db.blog[i]` syntax for `i` to be interpreted
    as a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this technique to access awkwardly named collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to query `db.@#&!` would be illegal, but `db[name]` would work.
  prefs: []
  type: TYPE_NORMAL
