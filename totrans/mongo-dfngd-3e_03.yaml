- en: Chapter 2\. Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB is powerful but easy to get started with. In this chapter we’ll introduce
    some of the basic concepts of MongoDB:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: A *document* is the basic unit of data for MongoDB and is roughly equivalent
    to a row in a relational database management system (but much more expressive).
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, a *collection* can be thought of as a table with a dynamic schema.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single instance of MongoDB can host multiple independent *databases*, each
    of which contains its own collections.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every document has a special key, `"_id"`, that is unique within a collection.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB is distributed with a simple but powerful tool called the *mongo shell*.
    The *mongo* shell provides built-in support for administering MongoDB instances
    and manipulating data using the MongoDB query language. It is also a fully functional
    JavaScript interpreter that enables users to create and load their own scripts
    for a variety of purposes.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documents
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the heart of MongoDB is the *document*: an ordered set of keys with associated
    values. The representation of a document varies by programming language, but most
    languages have a data structure that is a natural fit, such as a map, hash, or
    dictionary. In JavaScript, for example, documents are represented as objects:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simple document contains a single key, `"greeting"`, with a value of `"Hello,
    world!"`. Most documents will be more complex than this simple one and often will
    contain multiple key/value pairs:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, values in documents are not just “blobs.” They can be one of
    several different data types (or even an entire embedded document—see [“Embedded
    Documents”](#embedded-documents)). In this example the value for `"greeting"`
    is a string, whereas the value for `"views"` is an integer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in a document are strings. Any UTF-8 character is allowed in a key,
    with a few notable exceptions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Keys must not contain the character *\0* (the `null` character). This character
    is used to signify the end of a key.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *.* and *$* characters have some special properties and should be used only
    in certain circumstances, as described in later chapters. In general, they should
    be considered reserved, and drivers will complain if they are used inappropriately.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoDB is type-sensitive and case-sensitive. For example, these documents
    are distinct:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'as are these:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A final important thing to note is that documents in MongoDB cannot contain
    duplicate keys. For example, the following is not a legal document:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Collections
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *collection* is a group of documents. If a document is the MongoDB analog
    of a row in a relational database, then a collection can be thought of as the
    analog to a table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Schemas
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Collections have *dynamic schemas*. This means that the documents within a
    single collection can have any number of different “shapes.” For example, both
    of the following documents could be stored in a single collection:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the previous documents have different keys, different numbers of
    keys, and values of different types. Because any document can be put into any
    collection, the question often arises: “Why do we need separate collections at
    all?” With no need for separate schemas for different kinds of documents, why
    *should* we use more than one collection? There are several good reasons:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Keeping different kinds of documents in the same collection can be a nightmare
    for developers and admins. Developers need to make sure that each query is only
    returning documents adhering to a particular schema or that the application code
    performing a query can handle documents of different shapes. If we’re querying
    for blog posts, it’s a hassle to weed out documents containing author data.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s much faster to get a list of collections than to extract a list of the
    types of documents in a collection. For example, if we had a `"type"` field in
    each document that specified whether the document was a “skim,” “whole,” or “chunky
    monkey,” it would be much slower to find those three values in a single collection
    than to have three separate collections and query the correct collection.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping documents of the same kind together in the same collection allows for
    data locality. Getting several blog posts from a collection containing only posts
    will likely require fewer disk seeks than getting the same posts from a collection
    containing posts and author data.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We begin to impose some structure on our documents when we create indexes. (This
    is especially true in the case of unique indexes.) These indexes are defined per
    collection. By putting only documents of a single type into the same collection,
    we can index our collections more efficiently.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are sound reasons for creating a schema and for grouping related types
    of documents together. While not required by default, defining schemas for your
    application is good practice and can be enforced through the use of MongoDB’s
    documentation validation functionality and object–document mapping libraries available
    for many programming languages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Naming
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A collection is identified by its name. Collection names can be any UTF-8 string,
    with a few restrictions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The empty string (`""`) is not a valid collection name.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection names may not contain the character *\0* (the `null` character),
    because this delineates the end of a collection name.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should not create any collections with names that start with *system.*,
    a prefix reserved for internal collections. For example, the *system.users* collection
    contains the database’s users, and the *system.namespaces* collection contains
    information about all of the database’s collections.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-created collections should not contain the reserved character *$* in their
    names. The various drivers available for the database do support using *$* in
    collection names because some system-generated collections contain it, but you
    should not use *$* in a name unless you are accessing one of these collections.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subcollections
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One convention for organizing collections is to use namespaced subcollections
    separated by the *.* character. For example, an application containing a blog
    might have a collection named *blog.posts* and a separate collection named *blog.authors*.
    This is for organizational purposes only—there is no relationship between the
    *blog* collection (it doesn’t even have to exist) and its “children.”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Although subcollections do not have any special properties, they are useful
    and are incorporated into many MongoDB tools. For instance:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: GridFS, a protocol for storing large files, uses subcollections to store file
    metadata separately from content chunks (see [Chapter 6](ch06.xhtml#chapter-idx-types)
    for more information about GridFS).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most drivers provide some syntactic sugar for accessing a subcollection of a
    given collection. For example, in the database shell, `db.blog` will give you
    the *blog* collection, and `db.blog.posts` will give you the *blog.posts* collection.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subcollections are a good way to organize data in MongoDB for many use cases.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to grouping documents by collection, MongoDB groups collections
    into *databases*. A single instance of MongoDB can host several databases, each
    grouping together zero or more collections. A good rule of thumb is to store all
    data for a single application in the same database. Separate databases are useful
    when storing data for several applications or users on the same MongoDB server.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Like collections, databases are identified by name. Database names can be any
    UTF-8 string, with the following restrictions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The empty string (*“”*) is not a valid database name.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A database name cannot contain any of these characters: */*, *\*, *.*, *"*,
    ***, *<*, *>*, *:*, *|*, *?*, *$*, (a single space), or *\0* (the `null` character).
    Basically, stick with alphanumeric ASCII.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database names are case-insensitive.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database names are limited to a maximum of 64 bytes.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Historically, prior to the use of the WiredTiger storage engine, database names
    became files on your filesystem. It is no longer the case. This explains why many
    of the previous restrictions exist in the first place.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also some reserved database names, which you can access but which
    have special semantics. These are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '*admin*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The *admin* database plays a role in authentication and authorization. In addition,
    access to this database is required for some administrative operations. See [Chapter 19](ch19.xhtml#chapter-data-admin)
    for more information about the *admin* database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*local*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: This database stores data specific to a single server. In replica sets, *local*
    stores data used in the replication process. The *local* database itself is never
    replicated. (See [Chapter 10](ch10.xhtml#chapter_d1e9405) for more information
    about replication and the local database.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '*config*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Sharded MongoDB clusters (see [Chapter 14](ch14.xhtml#chapter_d1e10482)) use
    the *config* database to store information about each shard.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: By concatenating a database name with a collection in that database you can
    get a fully qualified collection name, which is called a *namespace*. For instance,
    if you are using the *blog.posts* collection in the *cms* database, the namespace
    of that collection would be *cms.blog.posts*. Namespaces are limited to 120 bytes
    in length and, in practice, should be fewer than 100 bytes long. For more on namespaces
    and the internal representation of collections in MongoDB, see [Appendix B](app02.xhtml#appendix_see).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Starting MongoDB
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start the server, run the *mongod* executable in the Unix command-line environment
    of your choice:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you’re on Windows, run this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For detailed information on installing MongoDB on your system, see [Appendix A](app01.xhtml#appendix_d1e12346)
    or the appropriate [installation tutorial](https://oreil.ly/5WP5e) in the MongoDB
    documentation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: When run with no arguments, *mongod* will use the default data directory, */data/db/*
    (or *\data\db\* on the current volume on Windows). If the data directory does
    not already exist or is not writable, the server will fail to start. It is important
    to create the data directory (e.g., `mkdir -p /data/db/`) and to make sure your
    user has permission to write to the directory before starting MongoDB.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: On startup, the server will print some version and system information and then
    begin waiting for connections. By default MongoDB listens for socket connections
    on port 27017\. The server will fail to start if that port is not available—the
    most common cause of this is another instance of MongoDB that is already running.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should always secure your *mongod* instances. See [Chapter 19](ch19.xhtml#chapter-data-admin)
    for more information on securing MongoDB.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: You can safely stop *mongod* by typing Ctrl-C in the command-line-environment
    from which you launched the *mongod* server.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For more information on starting or stopping MongoDB, see [Chapter 21](ch21.xhtml#chapter-start-stop).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the MongoDB Shell
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB comes with a JavaScript shell that allows interaction with a MongoDB
    instance from the command line. The shell is useful for performing administrative
    functions, inspecting a running instance, or just exploring MongoDB. The *mongo*
    shell is a crucial tool for using MongoDB. We’ll use it extensively throughout
    the rest of the text.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Running the Shell
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the shell, run the *mongo* executable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The shell automatically attempts to connect to a MongoDB server running on the
    local machine on startup, so make sure you start *mongod* before starting the
    shell.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell is a full-featured JavaScript interpreter, capable of running arbitrary
    JavaScript programs. To illustrate this, let’s perform some basic math:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also leverage all of the standard JavaScript libraries:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can even define and call JavaScript functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that you can create multiline commands. The shell will detect whether the
    JavaScript statement is complete when you press Enter. If the statement is not
    complete, the shell will allow you to continue writing it on the next line. Pressing
    Enter three times in a row will cancel the half-formed command and get you back
    to the `>` prompt.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: A MongoDB Client
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the ability to execute arbitrary JavaScript is useful, the real power
    of the shell lies in the fact that it is also a standalone MongoDB client. On
    startup, the shell connects to the *test* database on a MongoDB server and assigns
    this database connection to the global variable `db`. This variable is the primary
    access point to your MongoDB server through the shell.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the database to which `db` is currently assigned, type in `db` and hit
    Enter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The shell contains some add-ons that are not valid JavaScript syntax but were
    implemented because of their familiarity to users of SQL shells. The add-ons do
    not provide any extra functionality, but they are nice syntactic sugar. For instance,
    one of the most important operations is selecting which database to use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now if you look at the `db` variable, you can see that it refers to the *video*
    database:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because this is a JavaScript shell, typing a variable name will cause the name
    to be evaluated as an expression. The value (in this case, the database name)
    is then printed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'You may access collections from the `db` variable. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: returns the *movies* collection in the current database. Now that we can access
    a collection in the shell, we can perform almost any database operation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations with the Shell
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the four basic operations, create, read, update, and delete (CRUD),
    to manipulate and view data in the shell.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Create
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `insertOne` function adds a document to a collection. For example, suppose
    we want to store a movie. First, we’ll create a local variable called `movie`
    that is a JavaScript object representing our document. It will have the keys `"title"`,
    `"director"`, and `"year"` (the year it was released):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This object is a valid MongoDB document, so we can save it to the *movies*
    collection using the `insertOne` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The movie has been saved to the database. We can see it by calling `find` on
    the collection:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that an `"_id"` key was added and that the other key/value pairs
    were saved as we entered them. The reason for the sudden appearance of the `"_id"`
    field is explained at the end of this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Read
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`find` and `findOne` can be used to query a collection. If we just want to
    see one document from a collection, we can use `findOne`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`find` and `findOne` can also be passed criteria in the form of a query document.
    This will restrict the documents matched by the query. The shell will automatically
    display up to 20 documents matching a `find`, but more can be fetched. (See [Chapter 4](ch04.xhtml#chapter_d1e3559)
    for more information on querying.)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Update
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we would like to modify our post, we can use `updateOne`. `updateOne` takes
    (at least) two parameters: the first is the criteria to find which document to
    update, and the second is a document describing the updates to make. Suppose we
    decide to enable reviews for the movie we created earlier. We’ll need to add an
    array of reviews as the value for a new key in our document.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the update, we’ll need to use an update operator, `set`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now the document has a `"reviews"` key. If we call `find` again, we can see
    the new key:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: See [“Updating Documents”](ch03.xhtml#sect1_d1e2484) for detailed information
    on updating documents.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Delete
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`deleteOne` and `deleteMany` permanently delete documents from the database.
    Both methods take a filter document specifying criteria for the removal. For example,
    this would remove the movie we just created:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Use `deleteMany` to delete all documents matching a filter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The beginning of this chapter covered the basics of what a document is. Now
    that you are up and running with MongoDB and can try things in the shell, this
    section will dive a little deeper. MongoDB supports a wide range of data types
    as values in documents. In this section, we’ll outline all the supported types.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Basic Data Types
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Documents in MongoDB can be thought of as “JSON-like” in that they are conceptually
    similar to objects in JavaScript. [JSON](http://www.json.org) is a simple representation
    of data: the specification can be described in about one paragraph (the website
    proves it) and lists only six data types. This is a good thing in many ways: it’s
    easy to understand, parse, and remember. On the other hand, JSON’s expressive
    capabilities are limited because the only types are null, boolean, numeric, string,
    array, and object.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Although these types allow for an impressive amount of expressivity, there are
    a couple of additional types that are crucial for most applications, especially
    when working with a database. For example, JSON has no date type, which makes
    working with dates even more annoying than it usually is. There is a number type,
    but only one—there is no way to differentiate floats and integers, never mind
    any distinction between 32-bit and 64-bit numbers. There is no way to represent
    other commonly used types, either, such as regular expressions or functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB adds support for a number of additional data types while keeping JSON’s
    essential key/value–pair nature. Exactly how values of each type are represented
    varies by language, but this is a list of the commonly supported types and how
    they are represented as part of a document in the shell. The most common types
    are:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Null'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The null type can be used to represent both a null value and a nonexistent
    field:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Boolean
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a boolean type, which can be used for the values `true` and `false`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Number
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell defaults to using 64-bit floating-point numbers. Thus, these numbers
    both look “normal” in the shell:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For integers, use the `NumberInt` or `NumberLong` classes, which represent 4-byte
    or 8-byte signed integers, respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: String
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Any string of UTF-8 characters can be represented using the string type:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Date
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB stores dates as 64-bit integers representing milliseconds since the
    Unix epoch (January 1, 1970). The time zone is not stored:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Regular expression
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Queries can use regular expressions using JavaScript’s regular expression syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Array
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets or lists of values can be represented as arrays:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Embedded document
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Documents can contain entire documents embedded as values in a parent document:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Object ID
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'An object ID is a 12-byte ID for documents:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See the section [“_id and ObjectIds”](#sect2_d1e1990) for details.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also a few less common types that you may need, including:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Binary data
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Binary data is a string of arbitrary bytes. It cannot be manipulated from the
    shell. Binary data is the only way to save non-UTF-8 strings to the database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Code
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB also makes it possible to store arbitrary JavaScript in queries and
    documents:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, there are a few types that are mostly used internally (or superseded
    by other types). These will be described in the text as needed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: For more information on MongoDB’s data format, see [Appendix B](app02.xhtml#appendix_see).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Dates
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, the `Date` class is used for MongoDB’s date type. When creating
    a new `Date` object, always call `new Date()`, not just `Date()`. Calling the
    constructor as a function (i.e., not including `new`) returns a string representation
    of the date, not an actual `Date` object. This is not MongoDB’s choice; it is
    how JavaScript works. If you are not careful to always use the `Date` constructor,
    you can end up with a mishmash of strings and dates. Strings do not match dates
    and vice versa, so this can cause problems with removing, updating, querying…pretty
    much everything.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: For a full explanation of JavaScript’s `Date` class and acceptable formats for
    the constructor, see [section 15.9 of the ECMAScript specification](http://www.ecma-international.org).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Dates in the shell are displayed using local time zone settings. However, dates
    in the database are just stored as milliseconds since the epoch, so they have
    no time zone information associated with them. (Time zone information could, of
    course, be stored as the value for another key.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays are values that can be used interchangeably for both ordered operations
    (as though they were lists, stacks, or queues) and unordered operations (as though
    they were sets).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following document, the key `"things"` has an array value:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see from this example, arrays can contain different data types as
    values (in this case, a string and a floating-point number). In fact, array values
    can be any of the supported value types for normal key/value pairs, even nested
    arrays.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: One of the great things about arrays in documents is that MongoDB “understands”
    their structure and knows how to reach inside of arrays to perform operations
    on their contents. This allows us to query on arrays and build indexes using their
    contents. For instance, in the previous example, MongoDB can query for all documents
    where `3.14` is an element of the `"things"` array. If this is a common query,
    you can even create an index on the `"things"` key to improve the query’s speed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB also allows atomic updates that modify the contents of arrays, such
    as reaching into the array and changing the value `"pie"` to `pi`. We’ll see more
    examples of these types of operations throughout the text.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Documents
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A document can be used as the value for a key. This is called an *embedded document*.
    Embedded documents can be used to organize data in a more natural way than just
    a flat structure of key/value pairs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a document representing a person and want to store
    that person’s address, we can nest this information in an embedded `"address"`
    document:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The value for the `"address"` key in this example is an embedded document with
    its own key/value pairs for `"street"`, `"city"`, and `"state"`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: As with arrays, MongoDB “understands” the structure of embedded documents and
    is able to reach inside them to build indexes, perform queries, or make updates.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss schema design in-depth later, but even from this basic example
    we can begin to see how embedded documents can change the way we work with data.
    In a relational database, the previous document would probably be modeled as two
    separate rows in two different tables (*people* and *addresses*). With MongoDB
    we can embed the `"address"` document directly within the `"person"` document.
    Thus, when used properly, embedded documents can provide a more natural representation
    of information.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The flip side of this is that there can be more data repetition with MongoDB.
    Suppose *addresses* was a separate table in a relational database and we needed
    to fix a typo in an address. When we did a join with *people* and *addresses*,
    we’d get the updated address for everyone who shares it. With MongoDB, we’d need
    to fix the typo in each person’s document.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: _id and ObjectIds
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every document stored in MongoDB must have an `"_id"` key. The `"_id"` key’s
    value can be any type, but it defaults to an `ObjectId`. In a single collection,
    every document must have a unique value for `"_id"`, which ensures that every
    document in a collection can be uniquely identified. That is, if you had two collections,
    each one could have a document where the value for `"_id"` was `123`. However,
    neither collection could contain more than one document with an `"_id"` of `123`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: ObjectIds
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ObjectId` is the default type for `"_id"`. The `ObjectId` class is designed
    to be lightweight, while still being easy to generate in a globally unique way
    across different machines. MongoDB’s distributed nature is the main reason why
    it uses `ObjectId`s as opposed to something more traditional, like an autoincrementing
    primary key: it is difficult and time-consuming to synchronize autoincrementing
    primary keys across multiple servers. Because MongoDB was designed to be a distributed
    database, it was important to be able to generate unique identifiers in a sharded
    environment.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '`ObjectId`s use 12 bytes of storage, which gives them a string representation
    that is 24 hexadecimal digits: 2 digits for each byte. This causes them to appear
    larger than they are, which makes some people nervous. It’s important to note
    that even though an `ObjectId` is often represented as a giant hexadecimal string,
    the string is actually twice as long as the data being stored.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create multiple new `ObjectId`s in rapid succession, you can see that
    only the last few digits change each time. In addition, a couple of digits in
    the middle of the `ObjectId` will change if you space the creations out by a couple
    of seconds. This is because of the manner in which `ObjectId`s are created. The
    12 bytes of an `ObjectId` are generated as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| Timestamp | Random | Counter (random start value) |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: 'The first four bytes of an `ObjectId` are a timestamp in seconds since the
    epoch. This provides a couple of useful properties:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The timestamp, when combined with the next five bytes (which will be described
    in a moment), provides uniqueness at the granularity of a second.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the timestamp comes first, `ObjectId`s will sort in *rough* insertion
    order. This is not a strong guarantee but does have some nice properties, such
    as making `ObjectId`s efficient to index.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these four bytes exists an implicit timestamp of when each document was created.
    Most drivers expose a method for extracting this information from an `ObjectId`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the current time is used in `ObjectId`s, some users worry that their
    servers will need to have synchronized clocks. Although synchronized clocks are
    a good idea for other reasons (see [“Synchronizing Clocks”](ch24.xhtml#clock-sync)),
    the actual timestamp doesn’t matter to `ObjectId`s, only that it is often new
    (once per second) and increasing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The next five bytes of an `ObjectId` are a random value. The final three bytes
    are a counter that starts with a random value to avoid generating colliding `ObjectId`s
    on different machines.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: These first nine bytes of an `ObjectId` therefore guarantee its uniqueness across
    machines and processes for a single second. The last three bytes are simply an
    incrementing counter that is responsible for uniqueness within a second in a single
    process. This allows for up to 256³ (16,777,216) unique `ObjectId`s to be generated
    *per process* in a single second.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Autogeneration of _id
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated earlier, if there is no `"_id"` key present when a document is inserted,
    one will be automatically added to the inserted document. This can be handled
    by the MongoDB server but will generally be done by the driver on the client side.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Using the MongoDB Shell
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers how to use the shell as part of your command-line toolkit,
    customize it, and use some of its more advanced functionality.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we connected to a local *mongod* instance above, you can connect your
    shell to any MongoDB instance that your machine can reach. To connect to a *mongod*
    on a different machine or port, specify the hostname, port, and database when
    starting the shell:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`db` will now refer to *some-host:30000*’s `myDB` database.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is handy to not connect to a *mongod* at all when starting the
    *mongo* shell. If you start the shell with `--nodb`, it will start up without
    attempting to connect to anything:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once started, you can connect to a *mongod* at your leisure by running ``new
    Mongo("*`hostname`*")``:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After these two commands, you can use `db` normally. You can use these commands
    to connect to a different database or server at any time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Tips for Using the Shell
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because *mongo* is simply a JavaScript shell, you can get a great deal of help
    for it by simply looking up JavaScript documentation online. For MongoDB-specific
    functionality, the shell includes built-in help that can be accessed by typing
    ``**`help`**``:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Database-level help is provided by `db.help()` and collection-level help by
    `db.foo.help()`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way of figuring out what a function is doing is to type it without the
    parentheses. This will print the JavaScript source code for the function. For
    example, if you are curious about how the `update` function works or cannot remember
    the order of parameters, you can do the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Running Scripts with the Shell
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to using the shell interactively, you can also pass the shell JavaScript
    files to execute. Simply pass in your scripts at the command line:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The *mongo* shell will execute each script listed and exit.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run a script using a connection to a nondefault host/port *mongod*,
    specify the address first, then the script(s):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This would execute the three scripts with `db` set to the *foo* database on
    *server-1:30000*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: You can print to stdout in scripts (as the preceding scripts did) using the
    `print` function. This allows you to use the shell as part of a pipeline of commands.
    If you’re planning to pipe the output of a shell script to another command, use
    the `--quiet` option to prevent the “MongoDB shell version v4.2.0” banner from
    printing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run scripts from within the interactive shell using the `load`
    function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Scripts have access to the `db` variable (as well as any other global). However,
    shell helpers such as `use db` or `show collections` do not work from files. There
    are valid JavaScript equivalents to each of these, as shown in [Table 2-1](#table-js-helpers).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. JavaScript equivalents to shell helpers
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '| Helper | Equivalent |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| `use video` | `db.getSisterDB("video")` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| `show dbs` | `db.getMongo().getDBs()` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| `show collections` | `db.getCollectionNames()` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: 'You can also use scripts to inject variables into the shell. For example, you
    could have a script that simply initializes helper functions that you commonly
    use. The following script, for instance, may be helpful for [Part III](part03.xhtml#part3_replication)
    and [Part IV](part04.xhtml#part4_sharding). It defines a function, `connectTo`,
    that connects to the locally running database on the given port and sets `db`
    to that connection:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you load this script in the shell, `connectTo` is now defined:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In addition to adding helper functions, you can use scripts to automate common
    tasks and administrative activities.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: By default, the shell will look in the directory that you started the shell
    in (use `pwd()` to see what directory that is). If the script is not in your current
    directory, you can give the shell a relative or absolute path to it. For example,
    if you wanted to put your shell scripts in *~/my-scripts*, you could load *defineConnectTo.js*
    with `load("/home/myUser/my-scripts/defineConnectTo.js")`. Note that `load` cannot
    resolve `~`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `run` to run command-line programs from the shell. You can pass
    arguments to the function as parameters:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is of limited use, generally, as the output is formatted oddly and it doesn’t
    support pipes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .mongorc.js
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have frequently loaded scripts, you might want to put them in your *.mongorc.js*
    file. This file is run whenever you start up the shell.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you would like the shell to greet you when you log in.
    Create a file called *.mongorc.js* in your home directory, and then add the following
    lines to it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, when you start the shell, you’ll see something like:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'More practically, you can use this script to set up any global variables you’d
    like to use, alias long names to shorter ones, and override built-in functions.
    One of the most common uses for *.mongorc.js* is to remove some of the more “dangerous”
    shell helpers. You can override functions like `dropDatabase` or `deleteIndexes`
    with no-ops or undefine them altogether:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now if you try to call any of these functions, it will simply print an error
    message. Note that this technique does not protect you against malicious users;
    it can only help with fat-fingering.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: You can disable loading your *.mongorc.js* by using the `--norc` option when
    starting the shell.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Your Prompt
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default shell prompt can be overridden by setting the `prompt` variable
    to either a string or a function. For example, if you are running a query that
    takes minutes to complete, you may want to have a prompt that displays the current
    time so you can see when the last operation finished:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Another handy prompt might show the current database you’re using:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that prompt functions should return strings and be very cautious about
    catching exceptions: it can be extremely confusing if your prompt turns into an
    exception!'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In general, your prompt function should include a call to `getLastError`. This
    catches errors on writes and reconnects you automatically if the shell gets disconnected
    (e.g., if you restart *mongod*).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The *.mongorc.js* file is a good place to set your prompt if you want to always
    use a custom one (or set up a couple of custom prompts that you can switch between
    in the shell).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Editing Complex Variables
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The multiline support in the shell is somewhat limited: you cannot edit previous
    lines, which can be annoying when you realize that the first line has a typo and
    you’re currently working on line 15\. Thus, for larger blocks of code or objects,
    you may want to edit them in an editor. To do so, set the `EDITOR` variable in
    the shell (or in your environment, but since you’re already in the shell…):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, if you want to edit a variable, you can say *`edit varname`*—for example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When you’re done making changes, save and exit the editor. The variable will
    be parsed and loaded back into the shell.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Add ``EDITOR="*`/path/to/editor`*";`` to your *.mongorc.js* file and you won’t
    have to worry about setting it again.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Inconvenient Collection Names
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fetching a collection with the ``db.*`collectionName`*`` syntax almost always
    works, unless the collection name is a reserved word or is an invalid JavaScript
    property name.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we are trying to access the *version* collection. We cannot
    say `db.version` because `db.version` is a method on `db` (it returns the version
    of the running MongoDB server):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To actually access the *version* collection, you must use the `getCollection`
    function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This can also be used for collection names with characters that aren’t valid
    JavaScript property names, such as *foo-bar-baz* and *123abc* (JavaScript property
    names can only contain letters, numbers, *$* and *_*, and cannot start with a
    number).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of getting around invalid properties is to use array-access syntax.
    In JavaScript, `x.y` is identical to `x[''y'']`. This means that subcollections
    can be accessed using variables, not just literal names. Thus, if you needed to
    perform some operation on every *blog* subcollection, you could iterate through
    them with something like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种避免无效属性的方法是使用数组访问语法。在 JavaScript 中，`x.y` 和 `x['y']` 是相同的。这意味着可以使用变量访问子集合，而不仅仅是字面名称。因此，如果你需要对每个
    *blog* 子集合执行某些操作，可以像这样进行迭代：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'instead of this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that you cannot do `db.blog.i`, which would be interpreted as `test.blog.i`,
    not `test.blog.posts`. You must use the `db.blog[i]` syntax for `i` to be interpreted
    as a variable.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不能执行 `db.blog.i`，这会被解释为 `test.blog.i`，而不是 `test.blog.posts`。你必须使用 `db.blog[i]`
    语法，使 `i` 被解释为一个变量。
- en: 'You can use this technique to access awkwardly named collections:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种技术来访问命名奇特的集合：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Attempting to query `db.@#&!` would be illegal, but `db[name]` would work.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试查询 `db.@#&!` 是不合法的，但 `db[name]` 是可以的。
