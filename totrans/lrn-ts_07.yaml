- en: Chapter 5\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function arguments
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In one end, out the other
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As a return type
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In [Chapter 2, “The Type System”](ch02.xhtml#the_type_system), you saw how to
    use type annotations to annotate values of variables. Now, you’ll see how to do
    the same with function parameters and return types—and why that can be useful.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Function Parameters
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take the following `sing` function that takes in a `song` parameter and logs
    it:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What value type did the developer who wrote the `sing` function intend for the
    `song` parameter to be provided with?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Is it a `string`? Is it an object with an overridden `toString()` method? Is
    this code buggy? *Who knows?!*
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Without explicit type information declared, we may never know—TypeScript will
    consider it to be the `any` type, meaning the parameter’s type could be anything.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'As with variables, TypeScript allows you to declare the type of function parameters
    with a type annotation. Now we can use a `: string` to tell TypeScript that the
    `song` parameter is of type `string`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Much better: now we know what type `song` is meant to be!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don’t need to add proper type annotations to function parameters
    for your code to be valid TypeScript syntax. TypeScript might yell at you with
    type errors, but the emitted JavaScript will still run. The previous code snippet
    missing a type declaration on the `song` parameter will still convert from TypeScript
    to JavaScript. [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options)
    will cover how to configure TypeScript’s complaints about parameters that are
    implicitly of type `any` the way `song` is.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Required Parameters
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike JavaScript, which allows functions to be called with any number of arguments,
    TypeScript assumes that all parameters declared on a function are required. If
    a function is called with a wrong number of arguments, TypeScript will protest
    in the form of a type error. TypeScript’s argument counting will come into play
    if a function is called with either too few or too many arguments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'This `singTwo` function requires two parameters, so passing one argument and
    passing three arguments are both not allowed:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Enforcing that required parameters be provided to a function helps enforce type
    safety by making sure all expected argument values exist inside the function.
    Failing to ensure those values exist could result in unexpected behavior in code,
    such as the previous `singTwo` function logging `undefined` or ignoring an argument.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Parameter* refers to a function’s declaration of what it expects to receive
    as an argument. *Argument* refers to a value provided to a parameter in a function
    call. In the previous example, `first` and `second` are parameters, while strings
    such as `"Dreams"` are arguments.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Optional Parameters
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that in JavaScript, if a function parameter is not provided, its argument
    value inside the function defaults to `undefined`. Sometimes function parameters
    are not necessary to provide, and the intended use of the function is for that
    `undefined` value. We wouldn’t want TypeScript to report type errors for failing
    to provide arguments to those optional parameters. TypeScript allows annotating
    a parameter as optional by adding a `?` before the `:` in its type annotation—similar
    to optional object type properties.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters don’t need to be provided to function calls. Their types
    therefore always have `| undefined` added as a union type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following `announceSong` function, the `singer` parameter is marked
    optional. Its type is `string | undefined`, and it doesn’t need to be provided
    by callers of the function. If `singer` is provided, it may be a `string` value
    or `undefined`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These optional parameters are always implicitly able to be `undefined`. In the
    previous code, `singer` starts off as being of type `string | undefined`, then
    is narrowed to just `string` by the `if` statement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters are not the same as parameters with union types that happen
    to include `| undefined`. Parameters that aren’t marked as optional with a `?`
    must always be provided, even if the value is explicitly `undefined`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The `singer` parameter in this `announceSongBy` function must be provided explicitly.
    It may be a `string` value or `undefined`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Any optional parameters for a function must be the last parameters. Placing
    an optional parameter before a required parameter would trigger a TypeScript syntax
    error:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Default Parameters
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optional parameters in JavaScript may be given a default value with an `=` and
    a value in their declaration. For these optional parameters, because a value is
    provided by default, their TypeScript type does not implicitly have the `| undefined`
    union added on inside the function. TypeScript will still allow the function to
    be called with missing or `undefined` arguments for those parameters.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s type inference works similarly for default function parameter values
    as it does for initial variable values. If a parameter has a default value and
    doesn’t have a type annotation, TypeScript will infer the parameter’s type based
    on that default value.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following `rateSong` function, `rating` is inferred to be of type `number`,
    but is an optional `number | undefined` in the code that calls the function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Rest Parameters
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some functions in JavaScript are made to be called with any number of arguments.
    The `...` spread operator may be placed on the last parameter in a function declaration
    to indicate any “rest” arguments passed to the function starting at that parameter
    should all be stored in a single array.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript allows declaring the types of these rest parameters similarly to
    regular parameters, except with a `[]` syntax added at the end to indicate it’s
    an array of arguments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `singAllTheSongs` is allowed to take zero or more arguments of type `string`
    for its `songs` rest parameter:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`singAllTheSongs`可以接受零个或多个类型为`string`的参数作为它的`songs`剩余参数：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I’ll cover working with arrays in TypeScript in [Chapter 6, “Arrays”](ch06.xhtml#arrays_chapter).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第 6 章，“数组”](ch06.xhtml#arrays_chapter)中介绍在 TypeScript 中处理数组的方法。
- en: Return Types
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回类型
- en: 'TypeScript is perceptive: if it understands all the possible values returned
    by a function, it’ll know what type the function returns. In this example, `singSongs`
    is understood by TypeScript to return a `number`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是有洞察力的：如果它理解函数可能返回的所有可能值，它将知道函数的返回类型。在这个例子中，TypeScript 理解`singSongs`返回一个`number`：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If a function contains multiple `return` statements with different values, TypeScript
    will infer the return type to be a union of all the possible returned types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数包含多个不同值的`return`语句，TypeScript 将推断返回类型为所有可能返回类型的联合。
- en: 'This `getSongAt` function would be inferred to return `string | undefined`
    because its two possible returned values are typed `string` and `undefined`, respectively:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`getSongAt`函数将被推断返回`string | undefined`，因为它的两个可能返回值分别是`string`和`undefined`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Explicit Return Types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式返回类型
- en: 'As with variables, I generally recommend not bothering to explicitly declare
    the return types of functions with type annotations. However, there are a few
    cases where it can be useful specifically for functions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，我通常建议不必为具有类型注释的函数显式声明返回类型。然而，有几种情况下这样做可能会有用：
- en: You might want to enforce functions with many possible returned values always
    return the same type of value.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能希望强制函数返回多种可能值时始终返回相同类型的值。
- en: TypeScript will refuse to try to reason through return types of recursive function.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 将拒绝尝试推理递归函数的返回类型。
- en: It can speed up TypeScript type checking in very large projects—i.e., those
    with hundreds of TypeScript files or more.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以加快在非常庞大的项目中 TypeScript 的类型检查速度——例如那些包含数百个 TypeScript 文件或更多的项目。
- en: Function declaration return type annotations are placed after the `)` following
    the list of parameters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明的返回类型注释放置在参数列表后的`)`之后。
- en: 'For a function declaration, that falls just before the `{`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数声明，这是在`{`之前：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For arrow functions (also known as lambdas), that falls just before the `=>`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于箭头函数（也称为lambda函数），这是在`=>`之前：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If a `return` statement in a function returns a value not assignable to the
    function’s return type, TypeScript will give an assignability complaint.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数中的`return`语句返回一个不可分配给函数返回类型的值，TypeScript 将会给出一个可分配性的投诉。
- en: 'Here, the `getSongRecordingDate` function is explicitly declared as returning
    `Date | undefined`, but one of its return statements incorrectly provides a `string`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`getSongRecordingDate`函数明确声明为返回`Date | undefined`，但其中一个返回语句错误地提供了一个`string`：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Function Types
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: JavaScript allows us to pass functions around as values. That means we need
    a way to declare the type of a parameter or variable meant to hold a function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许我们将函数作为值传递。这意味着我们需要一种声明参数或变量类型的方式，以便保存函数。
- en: Function type syntax looks similar to an arrow function, but with a type instead
    of the body.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型的语法看起来类似于箭头函数，但其主体是一个类型而不是一个实现。
- en: 'This `nothingInGivesString` variable’s type describes a function with no parameters
    and a returned `string` value:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`nothingInGivesString`变量的类型描述了一个没有参数并返回`string`值的函数：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This `inputAndOutput` variable’s type describes a function with a `string[]`
    parameter, an optional `count` parameter, and a returned `number` value:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`inputAndOutput`变量的类型描述了一个带有`string[]`参数、可选的`count`参数以及返回`number`值的函数：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Function types are frequently used to describe callback parameters (parameters
    meant to be called as functions).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型经常用于描述回调参数（意味着将作为函数调用的参数）。
- en: 'For example, the following `runOnSongs` snippet declares the type of its `getSongAt`
    parameter to be a function that takes in an `index: number` and returns a `string`.
    Passing `getSongAt` matches that type, but `logSong` fails for taking in a `string`
    as its parameter instead of a `number`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，以下`runOnSongs`片段声明了它的`getSongAt`参数的类型为一个接受`index: number`并返回`string`的函数。传递`getSongAt`符合该类型，但`logSong`因为接受了一个`string`而不是`number`作为其参数而失败：'
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The error message for `runOnSongs(logSong)` is an example of an assignability
    error that includes a few levels of details. When complaining that two function
    types aren’t assignable to each other, TypeScript will typically give three levels
    of detail, with increasing levels of specificity:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The first indentation level prints out the two function types.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next indentation level specifies which part is mismatched.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last indentation level is the precise assignability complaint of the mismatched
    part.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the previous code snippet, those levels are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`logSong`s: `(strong: string) => string` is the provided type being assigned
    to the `getSongAt: (index: number) => string` recipient'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `song` parameter of `logSong` being assigned to the `index` parameter of
    `getSongAt`
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`song`’s `number` type is not assignable to `index`’s `string` type'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TypeScript’s multiline errors can seem daunting at first. Reading through them
    line-by-line and understanding what each part is conveying goes a long way to
    comprehending the error.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Function Type Parentheses
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function types may be placed anywhere that another type would be used. That
    includes union types.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In union types, parentheses may be used to indicate which part of an annotation
    is the function return or the surrounding union type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Later chapters that introduce more type syntaxes will show other places where
    function types must be wrapped with parentheses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Parameter Type Inferences
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be cumbersome if we had to declare parameter types for every function
    we write, including inline functions used as parameters. Fortunately, TypeScript
    can infer the types of parameters in a function provided to a location with a
    declared type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'This `singer` variable is known to be a function that takes in a parameter
    of type `string`, so the `song` parameter in the function later assigned to `singer`
    is known to be a `string`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Functions passed as arguments to parameters with function parameter types will
    have their parameter types inferred as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `song` and `index` parameters here are inferred by TypeScript
    to be `string` and `number`, respectively:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Function Type Aliases
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember type aliases from [Chapter 3, “Unions and Literals”](ch03.xhtml#unions_and_literals)?
    They can be used for function types as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'This `StringToNumber` type aliases a function that takes in a `string` and
    returns a `number`, which means it can be used later to describe the types of
    variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similarly, function parameters can themselves be typed with aliases that happen
    to refer to a function type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'This `usesNumberToString` function has a single parameter which is itself the
    `NumberToString` aliased function type:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Type aliases are particularly useful for function types. They can save a lot
    of horizontal space in having to repeatedly write out parameters and/or return
    types.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: More Return Types
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s look at two more return types: `void` and `never`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Void Returns
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some functions aren’t meant to return any value. They either have no `return`
    statements or only have `return` statements that don’t return a value. TypeScript
    allows using a `void` keyword to refer to the return type of such a function that
    returns nothing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions whose return type is `void` may not return a value. This `logSong`
    function is declared as returning `void`, so it’s not allowed to return a value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`void` can be useful as the return type in a function type declaration. When
    used in a function type declaration, `void` indicates that any returned value
    from the function would be ignored.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `songLogger` variable represents a function that takes in
    a `song: string` and doesn’t return a value:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that although JavaScript functions all return `undefined` by default if
    no real value is returned, `void` is not the same as `undefined`. `void` means
    the return type of a function will be ignored, while `undefined` is a literal
    value to be returned. Trying to assign a value of type `void` to a value whose
    type instead includes `undefined` is a type error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The distinction between `undefined` and `void` returns is particularly useful
    for ignoring any returned value from a function passed to a location whose type
    is declared as returning `void`. For example, the built-in `forEach` method on
    arrays takes in a callback that returns `void`. Functions provided to `forEach`
    can return any value they want. `records.push(record)` in the following `saveRecords`
    function returns a `number` (the returned value from an array’s `.push()`), yet
    is still allowed to be the returned value for the arrow function passed to `newRecords.forEach`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `void` type is not JavaScript. It’s a TypeScript keyword used to declare
    return types of functions. Remember, it’s an indication that a function’s returned
    value isn’t meant to be used, not a value that can itself be returned.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Never Returns
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some functions not only don’t return a value, but aren’t meant to return at
    all. Never-returning functions are those that always throw an error or run an
    infinite loop (hopefully intentionally!).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'If a function is meant to never return, adding an explicit `: never` type annotation
    indicates that any code after a call to that function won’t run. This `fail` function
    only ever throws an error, so it can help TypeScript’s control flow analysis with
    type narrowing `param` to `string`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`never` is not the same as `void`. `void` is for a function that returns nothing.
    `never` is for a function that never returns.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Function Overloads
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some JavaScript functions are able to be called with drastically different
    sets of parameters that can’t be represented just by optional and/or rest parameters.
    These functions can be described with a TypeScript syntax called *overload signatures*:
    declaring different versions of the function’s name, parameters, and return types
    multiple times before one final *implementation signature* and the body of the
    function.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: When determining whether to emit a syntax error for a call to an overloaded
    function, TypeScript will only look at the function’s overload signatures. The
    implementation signature is only used by the function’s internal logic.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'This `createDate` function is meant to be called either with one `timestamp`
    parameter or with three parameters—`month`, `day`, and `year`. Calling with either
    of those numbers of arguments is allowed, but calling with two arguments would
    cause a type error because no overload signature allows for two arguments. In
    this example, the first two lines are the overload signatures, and the third line
    is the implementation signature:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Overload signatures, as with other type system syntaxes, are erased when compiling
    TypeScript to output JavaScript.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet’s function would compile to roughly the following
    JavaScript:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Warning
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Function overloads are generally used as a last resort for complex, difficult-to-describe
    function types. It’s generally better to keep functions simple and avoid using
    function overloads when possible.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Call-Signature Compatibility
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation signature used for an overloaded function’s implementation
    is what the function’s implementation uses for parameter types and return type.
    Thus, the return type and each parameter in a function’s overload signatures must
    be assignable to the parameter at the same index in its implementation signature.
    In other words, the implementation signature has to be compatible with all of
    the overload signatures.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'This `format` function’s implementation signature declares its first parameter
    to be a `string`. While the first two overload signatures are compatible for also
    being type `string`, the third overload signature’s `() => string` type is not
    compatible:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you saw how a function’s parameters and return types can be
    inferred or explicitly declared in TypeScript:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Declaring function parameter types with type annotations
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring optional parameters, default values, and rest parameters to change
    type system behavior
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring function return types with type annotations
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing functions that don’t return a usable value with the `void` type
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing functions that don’t return at all with the `never` type
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using function overloads to describe varying function call signatures
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/functions*](https://learningtypescript.com/functions).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: What makes a TypeScript project good?
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It functions well.
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
