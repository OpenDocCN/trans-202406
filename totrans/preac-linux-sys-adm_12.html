<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 12. Troubleshooting Linux" data-type="chapter" epub:type="chapter"><div class="chapter" id="troubleshooting_linux">
<h1><span class="label">Chapter 12. </span>Troubleshooting Linux</h1>
<p>Some have compared Linux troubleshooting<a contenteditable="false" data-primary="troubleshooting Linux" data-type="indexterm" id="ix_trbl"/> to an “exercise in futility,” but troubleshooting Linux is neither so dramatic nor difficult if you simply take time to investigate what’s going on with your system. All too often, rather than perform any relevant troubleshooting, sysadmins will make a quick backup and then reimage (wipe the disk and reinstall) the system. I’m not a fan of this practice, though in cases of significant security breaches, it’s the best option.</p>
<p>This chapter teaches you general troubleshooting concepts and tools rather than how to troubleshoot a specific issue (such as how to fix a website that’s not working correctly). Troubleshooting individual problems could fill a very thick book or series of books. I discuss operating system troubleshooting, software, hardware, and security in the chapter.</p>
<p>This chapter aims to give you some basic troubleshooting skills, introduce you to essential tools, and show you how to find a solution should other options fail. Troubleshooting is a personal process; not everyone approaches it the same way. These procedures and tools have carried me through my career, but your results may vary and, eventually, you’ll find steps and guidelines that work best for you.</p>
<p>Let’s begin your lessons in troubleshooting with the operating system itself.</p>
<section data-pdf-bookmark="Reviving the Operating System" data-type="sect1"><div class="sect1" id="reviving_the_operating_system">
<h1>Reviving the Operating System</h1>
<p>Troubleshooting the operating system is either very easy or next to impossible. There seems to be no middle ground.<a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="reviving the operating system" data-type="indexterm" id="ix_trblrevOS"/> System errors are often, but not invariably, fatal. When I use the word <em>fatal</em> in this chapter, I mean unrecoverable errors that require you to reimage the system. Operating system problems can be as simple as running a filesystem check (<code>fsck</code>) and repairing a few files. <a contenteditable="false" data-primary="fsck (filesystem check)" data-type="indexterm" id="idm45657872383136"/>It can be as complex as a multiday troubleshooting session ending in a full system reimage. For example, if you experience a kernel panic, your first thought might be to reimage the system, but this is only sometimes necessary.</p>
<p>The following section demonstrates how to resolve a kernel panic.</p>
<section data-pdf-bookmark="De-escalating a Kernel Panic" data-type="sect2"><div class="sect2" id="deescalating_a_kernel_panic">
<h2>De-escalating a Kernel Panic</h2>
<p>There are multiple<a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="reviving the operating system" data-tertiary="de-escalating a kernel panic" data-type="indexterm" id="idm45657874610928"/> reasons systems boot with a kernel panic. <a contenteditable="false" data-primary="kernel panic, de-escalating" data-type="indexterm" id="idm45657872331808"/>Most of the time, it’s either a corrupted <em>initramfs</em> file or an improperly created <em>initramfs</em> file. <a contenteditable="false" data-primary="initramfs file" data-type="indexterm" id="idm45657872329728"/>The <em>initramfs</em> file is specific for each kernel, so if you’ve recently upgraded your kernel, it’s possible that the <em>initramfs</em> didn’t get created in the install process or that the <em>initramfs</em> creation process didn’t go well. Kernel panics can also result from a recent bad patch. Other issues may still cause kernel panics, such as hardware failure, but those listed here are the most common and easily remedied. A relatively simple procedure (discussed next) might make your system bootable again and save the pain of reinstalling everything.</p>
<p>Imagine you’ve received a message similar to the example in <a data-type="xref" href="#linux_kernel_panic">Figure 12-1</a>.</p>
<figure><div class="figure" id="linux_kernel_panic"><img alt="" height="342" src="assets/plsa_1201.png" width="600"/>
<h6><span class="label">Figure 12-1. </span>Linux kernel panic</h6>
</div></figure>
<p>The screen <em>freezes</em> here. There is no “press any key to continue” message. You must power off the system and power it back on to begin a new boot process. At this point, reboot your system and either start from a bootable ISO, or restart and enter the rescue process from the Grub menu. <a contenteditable="false" data-primary="ISO images" data-secondary="bootable" data-type="indexterm" id="idm45657872358384"/>You will be the root user when you boot into rescue mode or use a bootable ISO, so be careful.</p>
<p class="pagebreak-before">Display <a contenteditable="false" data-primary="kernels" data-secondary="displaying kernel version" data-type="indexterm" id="idm45657872357760"/>your kernel version:</p>
<pre data-type="programlisting">
# uname -r
3.10.0-327.el7.x86_64</pre>
<p>Run the following<a contenteditable="false" data-primary="initramfs file" data-secondary="re-creating correctly" data-type="indexterm" id="idm45657872565696"/> command <a contenteditable="false" data-primary="dracut command" data-type="indexterm" id="idm45657872321296"/>to re-create the correct <em>initramfs</em> from your kernel:</p>
<pre data-type="programlisting">
# dracut -f /boot/initramfs-3.10.0-327.el7.x86_64.img 3.10.0-327.el7.x86_64</pre>
<p>You might receive a message similar to the following:</p>
<pre data-type="programlisting">
dracut: Will not override existing initramfs (/boot/initramfs...) without --force</pre>
<p>You must create the <em>initramfs</em> file using a different command:</p>
<pre data-type="programlisting">
# mkinitrd --force \
/boot/initramfs-3.10.0-327.el7.x86_64.img 3.10.0-327.el7.x86_64</pre>
<p>Reboot your system. <a contenteditable="false" data-primary="mkinitrd --force command" data-type="indexterm" id="idm45657872315440"/>Hopefully, it will boot without issue. If you experience another kernel panic after this repair procedure, you could have a bad hard disk, another corrupted boot-related file, or a buggy kernel. Retry the rescue process and install a different kernel. <a contenteditable="false" data-primary="ISO images" data-secondary="mounting and installing kernel from" data-type="indexterm" id="idm45657872314208"/>Be sure to have your ISO image handy for the process.</p>
<p>Boot to the root rescue shell, mount your ISO image, and install the kernel that’s available in the ISO image.<a contenteditable="false" data-primary="kernels" data-secondary="installing kernel from ISO image" data-type="indexterm" id="idm45657872310720"/><a contenteditable="false" data-primary="mounting and mount points" data-secondary="root filesystem and ISO image" data-type="indexterm" id="idm45657872309952"/></p>
<p>For this example, your root filesystem is mounted on <em>/mnt/sysimage</em> and you mounted your ISO under <em>/opt/mnt</em>:</p>
<pre data-type="programlisting">
# cd /opt/mnt/install/repo/Packages

# rpm -Uvh --root=/mnt/sysimage kernel-3.10.0-1127.10.1.el7.x86_64</pre>
<p>Use the kernel package that’s in the ISO image. Now, reboot your system; if everything goes well, you should have a functioning system. If not, you should consider booting to the rescue environment again—creating a backup of critical files, if necessary—and then reimaging the system. Of course, this process may also result in kernel panic if you have a hardware problem, such as a bad disk or controller.</p>
<p>There are other sources of operating system problems, but they’re so varied that it’s impossible to cover them here. Instead, you should check the system’s logs, which the next section covers.</p>
</div></section>
<section data-pdf-bookmark="Scraping System Logs" data-type="sect2"><div class="sect2" id="scraping_system_logs">
<h2>Scraping System Logs</h2>
<p class="pagebreak-after">Scraping system logs means searching through logs for errors or other relevant messages.<a contenteditable="false" data-primary="logs" data-secondary="scraping system logs" data-type="indexterm" id="idm45657872300928"/><a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="reviving the operating system" data-tertiary="scraping system logs" data-type="indexterm" id="idm45657872299904"/> However, sysadmins live a good part of their lives in <em>/var/log</em>; sometimes, log files are all you have to rely on for troubleshooting system problems.</p>
<p>My starting <a contenteditable="false" data-primary="grep command" data-secondary="using to filter dmesg" data-type="indexterm" id="idm45657872298208"/>point is to <a contenteditable="false" data-primary="dmesg command" data-type="indexterm" id="idm45657872296544"/>issue a filtered <code>dmesg</code> command such as the following:</p>
<pre data-type="programlisting">
$ dmesg | grep -i error
[ 2.229324] RAS: Correctable Errors collector initialized.
[ 3.820963] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.
[ 3.829724] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.</pre>
<p>This often narrows the possibilities of where to look for a problem with the operating system and hardware. If you don’t find any relevant errors via <code>dmesg</code>, you can investigate further using other filters such as <code>fault</code>, <code>failed</code>, <code>undefined</code>, or <code>unknown</code>:</p>
<pre data-type="programlisting">
$ dmesg | grep -i failed
[ 3.820963] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.
[ 3.829724] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.

$ dmesg | grep -i fault
[ 0.004466] MTRR default type: uncachable
[ 0.362760] pid_max: default: 32768 minimum: 301
[ 0.710356] iommu: Default domain type: Translated
[ 0.728057] NetLabel:  unlabeled traffic allowed by default
[ 0.802045] PCI: CLS 0 bytes, default 64
[ 5.766858] systemd[1]: systemd 245.4-4ubuntu3.17 running in system mode. (+PA...
[333390.696268] systemd[1]: systemd 245.4-4ubuntu3.18 running in system mode. ...

$ dmesg | grep -i undefined

$ dmesg | grep -i unknown
[ 0.374321] SRBDS: Unknown: Dependent on hypervisor status</pre>
<p>Use your system’s log files if previous <a contenteditable="false" data-primary="grep command" data-secondary="grep -ir error *" data-type="indexterm" id="idm45657872290192"/>searches reveal nothing of value:</p>
<pre data-type="programlisting">
$ cd /var/log
$ sudo grep -ir error *</pre>
<p>This might produce a very long list. If it does, I suggest redirecting the output to a file so that you can scrape these results:</p>
<pre data-type="programlisting">
$ sudo grep -ir error * &gt; ~/errors.txt</pre>
<p>Then you can search for something more specific in this text file:</p>
<pre data-type="programlisting">
$ cd
$ grep host errors.txt</pre>
<p>I grepped for <code>host</code> here, but <a contenteditable="false" data-primary="grep command" data-secondary="grep host errors.txt" data-type="indexterm" id="idm45657872285136"/>you should <code>grep</code> for whatever term you need to search for in these results. Refine this process until you find the relevant error that fits your problem. It can take time. This is my process, but it usually yields valuable information and provides me with a few next steps for further investigation.</p>
<p>The next section deals with software troubleshooting and my process for finding errors and problems.<a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="reviving the operating system" data-startref="ix_trblrevOS" data-type="indexterm" id="idm45657872472976"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Unraveling Software Problems" data-type="sect1"><div class="sect1" id="unraveling_software_problems">
<h1>Unraveling Software Problems</h1>
<p>Software troubleshooting can be tricky. <a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="software problems" data-type="indexterm" id="ix_trblsft"/>The root cause of software problems might not be the software.<a contenteditable="false" data-primary="software troubleshooting" data-type="indexterm" id="ix_sfttrbl"/> Still, the problem can manifest itself as a software issue until you investigate further. As any experienced sysadmin will tell you, software problems can have root causes in hardware, other software, file corruption or deletion, software dependency issues, network problems, duplicated ports, duplicated IP addresses, and dozens of possible configuration or misconfiguration problems anywhere on the system.<a contenteditable="false" data-primary="configurations" data-secondary="problems with" data-type="indexterm" id="idm45657872276272"/> Software error messages won’t necessarily pinpoint a solution, but they’re a first step. However, error codes and logs are a good starting place for troubleshooting.</p>
<p>In this section, I direct you to locate and sift through system and application logs and to perform any built-in or vendor-supplied status and configuration checks.</p>
<section data-pdf-bookmark="Inspecting System Logs" data-type="sect2"><div class="sect2" id="inspecting_system_logs">
<h2>Inspecting System Logs</h2>
<p>System logs are a great starting place to find errors, failures, and successes. Yes, successes are not necessarily benign. <a contenteditable="false" data-primary="software troubleshooting" data-secondary="inspecting system logs" data-type="indexterm" id="idm45657872270384"/><a contenteditable="false" data-primary="logs" data-secondary="inspecting system logs" data-type="indexterm" id="idm45657872268688"/>Think about the scenario where someone has breached your network, logs into a system with a legitimate account, becomes root, and then exfiltrates confidential data or encrypts your data. It’s only the acting <span class="keep-together">party—</span>the person fraudulently accessing the system—that isn’t legitimate. The system sees every login and action from this malicious actor as normal, legitimate, and successful. These actions probably wouldn’t set off any alarms at all.</p>
<p>Your system logs show what’s happening, so don’t discount checking for successful logins. In a later section of this chapter, I give you an example security script that shows you logins at a glance for your inspection.<a contenteditable="false" data-primary=" /var/log directory" data-primary-sortas="var" data-type="indexterm" id="idm45657873339040"/></p>
<p>System logs are located in <em>/var/log</em>. To read these files, you must have root privileges.</p>
<p>Although the output is too long and too wide for the text of this book, here are the two troubleshooting filters I use on system logs:</p>
<pre data-type="programlisting">
$ sudo grep -i error *.log
$ sudo grep -i fail *.log</pre>
<p>I always use the <code>-i</code> option to ignore case so that I’m sure to catch every instance of error and fail regardless of how the log captures them. <a contenteditable="false" data-primary="grep command" data-secondary="grep -i fail" data-type="indexterm" id="idm45657872570480"/><a contenteditable="false" data-primary="grep command" data-secondary="grep -i error" data-type="indexterm" id="idm45657872336064"/>The next section deals with checking application-specific logs, often more helpful than relying on system logs alone.</p>
</div></section>
<section data-pdf-bookmark="Checking Application Logs" data-type="sect2"><div class="sect2" id="checking_application_logs">
<h2>Checking Application Logs</h2>
<p>Fortunately, application logs provide specific errors or error codes that help you troubleshoot software problems. <a contenteditable="false" data-primary="application logs, checking" data-type="indexterm" id="idm45657872263984"/><a contenteditable="false" data-primary="software troubleshooting" data-secondary="checking application logs" data-type="indexterm" id="idm45657872263344"/><a contenteditable="false" data-primary="logs" data-secondary="checking application logs" data-type="indexterm" id="idm45657872264624"/>These logs may be located in <em>/var/log</em>, under the application’s home directory, or in some other directory, but always in a subdirectory named <em>log</em> or <em>logs</em>. For example, Apache’s logs are often in <em>/var/log/httpd</em>, but on Red Hat Enterprise Linux–based systems, there is also a symbolic link from <em>/etc/httpd/logs</em> to <em>/var/log/httpd</em>. Often these links exist to be backward compatible with other applications.</p>
</div></section>
<section data-pdf-bookmark="Leveraging Internal Application Checks" data-type="sect2"><div class="sect2" id="leveraging_internal_application_checks">
<h2>Leveraging Internal Application Checks</h2>
<p>Some developers include configuration checkers and specific tools with their software to help you identify, isolate, and troubleshoot problems.<a contenteditable="false" data-primary="software troubleshooting" data-secondary="leveraging internal application checks" data-type="indexterm" id="idm45657872255488"/><a contenteditable="false" data-primary="application checks (internal)" data-type="indexterm" id="idm45657872253600"/> These utilities are your best option when facing application-specific configuration issues and failures.<a contenteditable="false" data-primary="configurations" data-secondary="checking for applications" data-type="indexterm" id="idm45657872251472"/> Some configuration files have a rather complex syntax, and missing a single parenthesis or semicolon can be extremely difficult to isolate.</p>
<p>For example, the following command provides excellent feedback to check your Apache HTTP Server configuration syntax.<a contenteditable="false" data-primary="Apache HTTP Server configuration syntax, checking" data-type="indexterm" id="idm45657872249264"/><a contenteditable="false" data-primary="httpd.conf file" data-type="indexterm" id="idm45657872248624"/> When everything in the <em>httpd.conf</em> is configured correctly, you receive a <code>Syntax OK</code> message:</p>
<pre data-type="programlisting">
$ apachectl configtest
Syntax OK</pre>
<p>However, if a configuration directive is incorrect, your <code>configtest</code> results isolate the problem:</p>
<pre data-type="programlisting">
$ apachectl configtest
AH00526: Syntax error on line 34 of /etc/httpd/conf/httpd.conf:
Invalid command 'ServerBoot', perhaps misspelled or defined by a module not 
included in the server configuration</pre>
<p>The configuration is also checked on the start or restart of the application:</p>
<pre data-type="programlisting">
$ sudo apachectl restart
Job for httpd.service failed because the control process exited with error code.
See "systemctl status httpd.service" and "journalctl -xe" for details.

$ systemctl status httpd.service
httpd.service - The Apache HTTP Server
  Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled; vendor prese...
  Active: failed (Result: exit-code) since Sun 2022-10-16 08:49:44 EDT; 17s ago
    Docs: man:httpd.service(8)
  Process: 58661 ExecReload=/usr/sbin/httpd $OPTIONS -k graceful (code=exited,...
  Process: 59189 ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND (code=exited,...
Main PID: 59189 (code=exited, status=1/FAILURE)
  Status: "Reading configuration..."

Oct 16 08:49:44 server1 systemd[1]: httpd.service: Succeeded.
Oct 16 08:49:44 server1 systemd[1]: Stopped The Apache HTTP Server.
Oct 16 08:49:44 server1 systemd[1]: Starting The Apache HTTP Server...
Oct 16 08:49:44 server1 httpd[59189]: AH00526: Syntax error on line 34 of /etc...
Oct 16 08:49:44 server1 httpd[59189]: Invalid command 'ServerBoot', perhaps mi...
Oct 16 08:49:44 server1 systemd[1]: httpd.service: Main process exited, code=e...
Oct 16 08:49:44 server1 systemd[1]: httpd.service: Failed with result 'exit-co...
Oct 16 08:49:44 server1 systemd[1]: Failed to start The Apache HTTP Server.</pre>
<p>In the preceding error message, the line <code>Oct 16 08:49:44 server1 httpd[59189]: AH00526: Syntax error on line 34 of /etc/httpd/conf/httpd.conf:</code> (part of which has been elided in the preceding code listing) informs me there is a syntax error in my configuration file and I need to investigate further:</p>
<pre data-type="programlisting">
$ cd /var/log
$ sudo grep -ir "Syntax error" *
Binary file journal/027dd8a8c9624671b26d07e94eae8f1d/system.journal matches</pre>
<p>The results of my search don’t help troubleshoot<a contenteditable="false" data-primary="journalctl utility" data-type="indexterm" id="idm45657872302544"/> the syntax error, so I use the other recommended system tool, <code>journalctl</code>, from the preceding <code>apachectl</code> <code>restart</code> command (<code>See "systemctl status httpd.service" and "journalctl -xe" for details.</code>), the results are just as vague:</p>
<pre data-type="programlisting">
$ sudo journalctl -xe
-- Support: https://access.redhat.com/support
--
-- The unit httpd.service has entered the 'failed' state with result 'exit-code'.
Oct 16 08:49:44 server1 systemd[1]: Failed to start The Apache HTTP Server.
-- Subject: Unit httpd.service has failed
-- Defined-By: systemd
-- Support: https://access.redhat.com/support
--
-- Unit httpd.service has failed.
--
-- The result is failed.</pre>
<p>Your best course of action is to examine lines in the <em>httpd.conf</em> file you changed that caused the error. Common problems such as misspelling or using an incorrect directive are typical reasons for syntax errors.</p>
</div></section>
<section data-pdf-bookmark="Managing Firewalls and Their Rules" data-type="sect2"><div class="sect2" id="managing_firewalls_and_their_rules">
<h2>Managing Firewalls and Their Rules</h2>
<p>Firewalls are great for slowing down intruders, but they can also interfere with troubleshooting. <a contenteditable="false" data-primary="software troubleshooting" data-secondary="managing firewalls and their rules" data-type="indexterm" id="idm45657872231584"/><a contenteditable="false" data-primary="firewalls" data-secondary="managing firewalls and their rules" data-type="indexterm" id="idm45657872230816"/>Avoid the temptation to disable your firewall during troubleshooting. Instead, add new rules to accommodate what you need to do. You might forget to re-enable the firewall, which can lead to disastrous consequences.</p>
<p>The firewall isn’t 100% foolproof, but it has value in slowing down a would-be intruder. Sometimes its existence is enough to deter a malicious actor and encourage them to seek out easier prey. It’s frustrating to troubleshoot a new service for hours to eventually remember that it could be your firewall causing the problem.</p>
</div></section>
<section data-pdf-bookmark="Removing and Reinstalling Software" data-type="sect2"><div class="sect2" id="removing_and_reinstalling_software">
<h2>Removing and Reinstalling Software</h2>
<p>Endless troubleshooting is often an exercise in patience-testing and isn’t recommended. <a contenteditable="false" data-primary="software troubleshooting" data-secondary="removing and reinstalling software" data-type="indexterm" id="idm45657872733200"/><a contenteditable="false" data-primary="removing and reinstalling software" data-type="indexterm" id="idm45657872731712"/>There’s no set standard for how long you should spend troubleshooting a software problem, but at some point, you must determine that further <span class="keep-together">troubleshooting</span> is a waste of your valuable time. You should back up the application’s configuration files and data at that time and then remove and reinstall it.</p>
<p>Before reinstalling an application, be sure you have installed the latest stable package available or downloaded the latest stable source code. If you were on the latest version, try returning to an earlier stable version. Also, be sure that your system is updated and has the latest compatible tools and utilities for your application. The <em>README</em> or <em>INSTALL</em> text files, included with source code packages, often list compatible compiler versions and versions of other required supporting software.</p>
</div></section>
<section data-pdf-bookmark="Rebooting Your System" data-type="sect2"><div class="sect2" id="rebooting_your_system">
<h2>Rebooting Your System</h2>
<p>The concept of regular system rebooting is not only foreign to many Linux system administrators; it’s downright unheard of.<a contenteditable="false" data-primary="rebooting the system" data-type="indexterm" id="idm45657872234480"/><a contenteditable="false" data-primary="software troubleshooting" data-secondary="rebooting the system" data-type="indexterm" id="idm45657872569360"/> However, rebooting should be a part of regular system maintenance. Rebooting refreshes both hardware and software configurations, but it also informs you of any failures or problems.<a contenteditable="false" data-primary="systemctl utility" data-secondary="systemctl enable command" data-type="indexterm" id="idm45657872220640"/> For example, you might find that some applications don’t start automatically after a reboot. Perhaps you didn’t <code>enable</code> them with a <code>systemctl enable <em>service_name</em></code> command. Starting a service places it into memory, sets up listening ports, and allows connectivity. Still, that service, unless enabled, will not start on the next reboot, whether human-initiated or one resulting from a crash.</p>
<p>The <code>dmesg</code> command informs you of any problems from your latest reboot.<a contenteditable="false" data-primary="dmesg command" data-secondary="informing of problems from latest reboot" data-type="indexterm" id="idm45657873667632"/> You can discover both software and hardware errors by filtering the results. Here are two such examples:</p>
<pre data-type="programlisting">
$ dmesg | grep -i error
[ 8.741308] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.
[ 8.741321] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.

$ dmesg | grep -i fail
[ 0.063026] acpi PNP0A03:00: fail to add MMCONFIG information, can't access ...
[ 8.741308] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.
[ 8.741321] [drm:vmw_host_log [vmwgfx]] *ERROR* Failed to send host log message.</pre>
<p>Rebooting your systems shouldn’t be controversial. <a contenteditable="false" data-primary="cold rebooting" data-type="indexterm" id="idm45657872598320"/><a contenteditable="false" data-primary="warm rebooting" data-type="indexterm" id="idm45657872212208"/>Monthly warm booting (restart) and quarterly cold booting (power off/on) is a standard part of many enterprise maintenance cycles, as is patching, security auditing, and port scanning. The next section is a discussion of hardware troubleshooting.<a contenteditable="false" data-primary="software troubleshooting" data-startref="ix_sfttrbl" data-type="indexterm" id="idm45657872211104"/><a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="software problems" data-startref="ix_trblsft" data-type="indexterm" id="idm45657873712304"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Dealing with Hardware Failures" data-type="sect1"><div class="sect1" id="dealing_with_hardware_failures">
<h1>Dealing with Hardware Failures</h1>
<p>Troubleshooting hardware is generally very easy; hardware<a contenteditable="false" data-primary="hardware failures" data-type="indexterm" id="ix_hdwfail"/> either works or doesn’t.<a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="hardware failures, handling" data-type="indexterm" id="ix_trblhdw"/> There are times when hardware begins to fail, and you experience erratic behavior, such as intermittent functionality of a network interface card (NIC) or file corruption on a failing hard disk. <a contenteditable="false" data-primary="NICs (network interface cards)" data-secondary="problems with" data-type="indexterm" id="idm45657872321504"/>But often a hardware device fails and you must replace it. Data center server systems have built-in redundancy of several subsystems so that failures aren’t catastrophic. Always purchase server systems with redundant power supplies, multiple NICs, and plenty of RAM.<a contenteditable="false" data-primary="disks" data-secondary="multidisk arrays such as RAID 10" data-type="indexterm" id="idm45657872359088"/><a contenteditable="false" data-primary="multidisk arrays" data-type="indexterm" id="idm45657874706192"/> Set up disks in arrays such as RAID 10 so that failures don’t ruin your evenings and weekends.</p>
<p>Even if you have a multidisk array, please note that if one of the drives fails, there will be a performance impact. You’ll receive a warning that a disk has failed, and if you have physical access to the system, it’s easy to determine, via status lights, which disk has failed. And, although there’s an expense involved, you should have multiple new disks on hand to swap out when failures occur. <a contenteditable="false" data-primary="SSDs (solid-state drives)" data-type="indexterm" id="idm45657872196464"/>The other option is to migrate to solid-state drives (SSDs) that run cooler and have a longer lifespan than mechanical drives. Remember that heat is the enemy of electronics, which is why data centers seem windy and chilly. Heat dissipation is one of the big problems and major design features of any good data center.</p>
<p>The following sections cover preemptive troubleshooting, diagnostics, and hardware replacement and a discussion of system design.</p>
<section data-pdf-bookmark="Preemptively Troubleshooting Hardware" data-type="sect2"><div class="sect2" id="preemptively_troubleshooting_hardware">
<h2>Preemptively Troubleshooting Hardware</h2>
<p>Unless you have some very smart hardware diagnostics from <a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="hardware failures, handling" data-tertiary="preemptively troubleshooting hardware" data-type="indexterm" id="idm45657872222240"/>a blade server system chassis or a third-party software suite, preemptive hardware failure prediction isn’t possible. <a contenteditable="false" data-primary="hardware failures" data-secondary="preemptively troubleshooting hardware" data-type="indexterm" id="idm45657872223008"/>Native Linux commands provide you with a general listing or status. Still, if your hardware components are operating, it’s rare to find a “flagged” device or to receive a warning about an imminent failure.</p>
<p>Hardware failures are difficult to predict because, as I mentioned earlier, hardware either works or doesn’t. Some hardware components <em>can</em> partially fail. Network interface cards (NICs) can begin to fail and “jabber” or send malformed packets. Jabbering network cards are failing and should be replaced.<a contenteditable="false" data-primary="NICs (network interface cards)" data-secondary="partial failures of" data-type="indexterm" id="idm45657872233152"/></p>
<p>Mechanical hard disks can partially fail by corrupting files or by booting incorrectly, randomly, or not at all. <a contenteditable="false" data-primary="disks" data-secondary="partial failures of" data-type="indexterm" id="idm45657872188128"/>Sometimes a failing hard drive will temporarily repair itself after a cold boot. Sometimes you can hear a mechanical hard disk spinning up, spinning down, clicking, or <em>clunking</em> when they fail. Use a recent backup and replace the drive. Use solid-state drives whenever possible. Mirror your drives whenever possible too. Solid-state drives will fail on a general or all-or-nothing basis. I’ve never seen a solid-state drive partially fail.</p>
<p>Memory “sticks” will generally fail on an all-or-nothing basis.<a contenteditable="false" data-primary="memory sticks, failures of" data-type="indexterm" id="idm45657872198960"/> I’ve never seen one partially fail. The RAM doesn’t count up completely during the boot process when a memory stick fails. For example, if a system contains 64 GB of RAM, it might only recognize 48 GB. Although memory sticks may fail individually, they are read in pairs. So if you have eight 8 GB memory sticks in a system to add up to a total of 64 GB, and you have a single stick failure, the RAM count fails in pairs. To clarify, if your system has four banks of two memory sticks (8 GB each × 8 sticks = 64 GB), and one memory stick fails, then its paired memory stick will also appear to have failed, and you will see only 48 GB of RAM count up on boot.</p>
<p>The next section introduces you to a handful of useful hardware commands.</p>
</div></section>
<section data-pdf-bookmark="Gathering System Hardware Information" data-type="sect2"><div class="sect2" id="gathering_system_hardware_information">
<h2>Gathering System Hardware Information</h2>
<p>I don’t have any<a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="hardware failures, handling" data-tertiary="gathering system hardware information" data-type="indexterm" id="ix_trblhdwinfo"/> bare metal systems with Linux on them. <a contenteditable="false" data-primary="hardware failures" data-secondary="gathering system hardware information" data-type="indexterm" id="idm45657872178944"/>I only have virtual machines to work with. I suggest using the commands discussed in this section to collect hardware data for every unique physical system you manage and keeping this information where you can easily refer to it later. Gather hardware information for each bare-metal system and then collect the same information for a single virtual machine from each virtualization platform.<a contenteditable="false" data-primary="virtual hardware" data-type="indexterm" id="idm45657872177600"/> Virtual hardware is very consistent per platform and even between virtual hosts. In other words, if you have all VMware hosts and your host software version is consistent, then your virtual machine hardware should all be the same. <a contenteditable="false" data-primary="virtual machines (VMs)" data-type="indexterm" id="idm45657872194384"/>Virtual machines may move among hosts without issue because their virtual hardware is generic and consistent regardless of what the underlying hardware looks like.</p>
<p>The commands presented in this section gather information about your hardware, and while some of the information might overlap, it’s still good to gather information from multiple commands. As you’ll see, some commands gather specific details about your hardware, while others gather only product names and functions. You can execute the commands as a regular user, but some warn you to use the root account, or the information might be incomplete or inaccurate. All commands in this section are run as the root user. The output from these commands is generally too long to fully reproduce in this book, but I’ll provide excerpts for each to give you an idea of what the commands report. There are multiple options available for each command that offer custom output and reports. Refer to each command’s man page to learn more about their options. Finally, note that depending on your specific Linux distro, some of the tools discussed might be present and other tools might need to be installed.</p>
<section data-pdf-bookmark="hwinfo" data-type="sect3"><div class="sect3" id="hwinfo">
<h3>hwinfo</h3>
<p>The <code>hwinfo</code> utility probes your system’s hardware and reports on its findings. The report is very long but very thorough. <a contenteditable="false" data-primary="hwinfo --short command" data-type="indexterm" id="idm45657872164816"/><a contenteditable="false" data-primary="hardware failures" data-secondary="gathering system hardware information" data-tertiary="using hwinfo" data-type="indexterm" id="idm45657872164176"/>You can use the <code>--short</code> option to create an abbreviated summary report. The following listing is the complete short report:</p>
<pre class="widows42" data-type="programlisting">
# hwinfo --short
cpu:                                                           
                       Intel(R) Core(TM) i5-5350U CPU @ 1.80GHz, 1800 MHz
keyboard:
  /dev/input/event2    AT Translated Set 2 keyboard
mouse:
  /dev/input/mice      Mouse
graphics card:
                       VMware VMWARE0405
sound:
                       Intel 82801AA AC'97 Audio Controller
storage:
                       Intel 82801HM/HEM (ICH8M/ICH8M-E) SATA Controller [AHCI...
                       Intel 82371AB/EB/MB PIIX4 IDE
network:
  enp0s3               Intel PRO/1000 MT Desktop Adapter
network interface:
  lo                   Loopback network interface
  enp0s3               Ethernet network interface
disk:
  /dev/sdb             VBOX HARDDISK
  /dev/sdc             VBOX HARDDISK
  /dev/sda             VBOX HARDDISK
partition:
  /dev/sdc1            Partition
  /dev/sda1            Partition
  /dev/sda2            Partition
cdrom:
  /dev/sr0             VBOX CD-ROM
usb controller:
                       Apple KeyLargo/Intrepid USB
bios:
                       BIOS
bridge:
                       Intel 82371SB PIIX3 ISA [Natoma/Triton II]
                       Intel 82371AB/EB/MB PIIX4 ACPI
                       Intel 440FX - 82441FX PMC [Natoma]
hub:
                       Linux Foundation 1.1 root hub
memory:
                       Main Memory
unknown:
                       FPU
                       DMA controller
                       PIC
                       Keyboard controller
                       InnoTek Systemberatung VirtualBox Guest Service</pre>
<p>The entire report is very long, but the short version is complete without all the details. Creating both reports for each system you manage is a good strategy.</p>
<p class="pagebreak-after">Next, we’ll cover the so-called “<code>ls</code> commands” for hardware. Each one begins with the letters <code>ls</code> and lists various pieces of a system’s hardware complement.</p>
</div></section>
<section data-pdf-bookmark="lshw" data-type="sect3"><div class="sect3" id="lshw">
<h3 class="less_space">lshw</h3>
<p>The <code>lshw</code> utility provides detailed <a contenteditable="false" data-primary="hardware failures" data-secondary="gathering system hardware information" data-tertiary="using lshw" data-type="indexterm" id="idm45657872146896"/>hardware information, including CPU, mainboard, memory, firmware, cache configuration, and bus speeds. <a contenteditable="false" data-primary="lshw command" data-type="indexterm" id="idm45657872143520"/>You can optionally create an HTML report version with the <code>-html</code> option. The following is a partial output from the <code>lshw</code> command with no options:</p>
<pre data-type="programlisting">
# lshw
server1                    
    description: Computer
    product: VirtualBox
    vendor: innotek GmbH
    version: 1.2
    serial: 0
    width: 64 bits
    capabilities: smbios-2.5 dmi-2.5 vsyscall32
    configuration: family=Virtual Machine uuid=1f88c169-07a7-024b-8d54-6dc9070...</pre>
<p>The <code>lshw</code> utility is a comprehensive hardware snapshot of your system. The remainder of this section’s <code>ls</code> commands are specific to subsystems.</p>
</div></section>
<section data-pdf-bookmark="lspci" data-type="sect3"><div class="sect3" id="lspci">
<h3>lspci</h3>
<p>The <code>lspci</code> utility lists<a contenteditable="false" data-primary="hardware failures" data-secondary="gathering system hardware information" data-tertiary="using lspci" data-type="indexterm" id="idm45657872138608"/> all PCI devices, their<a contenteditable="false" data-primary="PCI devices, listing" data-type="indexterm" id="idm45657872137584"/> manufacturer, and<a contenteditable="false" data-primary="lspci command" data-type="indexterm" id="idm45657872136560"/> version information:</p>
<pre data-type="programlisting">
# lspci
00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)
00:02.0 VGA compatible controller: VMware SVGA II Adapter
00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Contro...
00:04.0 System peripheral: InnoTek Systemberatung GmbH VirtualBox Guest Service
00:05.0 Multimedia audio controller: Intel Corporation 82801AA AC'97 Audio Con...
00:06.0 USB controller: Apple Inc. KeyLargo/Intrepid USB
00:07.0 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 08)
00:0d.0 SATA controller: Intel Corporation 82801HM/HEM (ICH8M/ICH8M-E) SATA Co...</pre>
<p>One of the most interesting options for <code>lshw</code> is <code>-sanitize</code>, which removes any sensitive information from the report.<a contenteditable="false" data-primary="lshw command" data-secondary="-sanitize option" data-type="indexterm" id="idm45657872132160"/></p>
</div></section>
<section data-pdf-bookmark="lsblk" data-type="sect3"><div class="sect3" id="lsblk">
<h3>lsblk</h3>
<p>The <code>lsblk</code> utility lists all block devices, their mount points, sizes, and other information. <a contenteditable="false" data-primary="lsblk command" data-type="indexterm" id="idm45657872128176"/><a contenteditable="false" data-primary="block devices" data-secondary="listing with lsblk" data-type="indexterm" id="idm45657872127040"/>To view a complete report available from <code>lsblk</code>, you must execute it as root because of how it queries information from <em>sysfs</em> and the <em>udev db</em> (if available):</p>
<pre data-type="programlisting">
# lsblk
NAME                MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda                   8:0    0    8G  0 disk
├─sda1                8:1    0    1G  0 part /boot
└─sda2                8:2    0    7G  0 part
  ├─cl-root         253:0    0  6.2G  0 lvm  /
  └─cl-swap         253:1    0  820M  0 lvm  [SWAP]
sdb                   8:16   0  1.5G  0 disk
└─vgsw-software--lv 253:2    0  1.5G  0 lvm  /sw
sdc                   8:32   0    1G  0 disk
└─sdc1                8:33   0 1023M  0 part /home
sr0                  11:0    1 1024M  0 rom</pre>
<p>You can use other options to extract more information, such as device owner, permissions, and UUID. <a contenteditable="false" data-primary="lsblk command" data-secondary="-fm option" data-type="indexterm" id="idm45657872122224"/>The output isn’t formatted correctly for this text, but you can enter the following command to see extended block device information:</p>
<pre data-type="programlisting">
# lsblk -fm</pre>
<p>The <code>lsblk</code> utility does not report on RAM disk devices.</p>
</div></section>
<section data-pdf-bookmark="lscpu" data-type="sect3"><div class="sect3" id="lscpu">
<h3>lscpu</h3>
<p>The <code>lscpu</code> utility reports  <a contenteditable="false" data-primary="hardware failures" data-secondary="gathering system hardware information" data-tertiary="using lscpu" data-type="indexterm" id="idm45657872118368"/>architecture <a contenteditable="false" data-primary="lscpu command" data-type="indexterm" id="idm45657872116752"/>information <a contenteditable="false" data-primary="CPUs" data-secondary="getting architecture information about with lscpu" data-type="indexterm" id="idm45657872115488"/>about a system’s CPUs. It has a lot of options, and some must be stacked, or used together, so refer to the man page to review specific requirements for the report you need:</p>
<pre data-type="programlisting">
# lscpu
Architecture:        x86_64
CPU op-mode(s):      32-bit, 64-bit
Byte Order:          Little Endian
CPU(s):              1
On-line CPU(s) list: 0
Thread(s) per core:  1
Core(s) per socket:  1
Socket(s):           1
NUMA node(s):        1
Vendor ID:           GenuineIntel
CPU family:          6
Model:               61
Model name:          Intel(R) Core(TM) i5-5350U CPU @ 1.80GHz
Stepping:            4
CPU MHz:             1799.999
BogoMIPS:            3599.99
Hypervisor vendor:   KVM
Virtualization type: full
L1d cache:           32K
L1i cache:           32K
L2 cache:            256K
L3 cache:            3072K
NUMA node0 CPU(s):   0
Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca ...</pre>
<p>CPUs rarely fail, but the information is valuable if you need to check for compatibility or when upgrading to a new CPU generation.</p>
<p>Using these utilities for troubleshooting a system requires gathering pre-failure information as a hardware audit and then comparing those initial reports with those after a suspected failure. <a contenteditable="false" data-primary="diff utility" data-secondary="using diff on pre- and post-failure hardware reports" data-type="indexterm" id="idm45657872124000"/>A simple <code>diff</code> between the pre- and post-failure reports will inform you of any differences. Remember that this works because many of these utilities probe your hardware when you execute them rather than only reading a configuration from a static system text file.<a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="hardware failures, handling" data-startref="ix_trblhdwinfo" data-tertiary="gathering system hardware information" data-type="indexterm" id="idm45657872111216"/></p>
<p>The next section covers security troubleshooting and tools you use to assess your security.<a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="hardware failures, handling" data-startref="ix_trblhdw" data-type="indexterm" id="idm45657872106688"/><a contenteditable="false" data-primary="hardware failures" data-startref="ix_hdwfail" data-type="indexterm" id="idm45657872105728"/></p>
</div></section>
</div></section>
</div></section>
<section data-pdf-bookmark="Creating Automated Security Checks" data-type="sect1"><div class="sect1" id="creating_automated_security_checks">
<h1>Creating Automated Security Checks</h1>
<p>Before troubleshooting a problem, you must know it exists. <a contenteditable="false" data-primary="troubleshooting Linux" data-secondary="creating automated security checks" data-type="indexterm" id="idm45657872101728"/><a contenteditable="false" data-primary="automation" data-secondary="creating automated security checks" data-type="indexterm" id="idm45657872100768"/><a contenteditable="false" data-primary="security" data-secondary="creating automated security checks" data-type="indexterm" id="idm45657872099424"/>The way to find out if you have a problem is through observation via logs, reports, failed processes, removed or damaged files, compromised accounts, and so on. Detecting and fixing security issues is a full-time job for software and personnel. In other words, if you manage more than a handful of server systems, and depending on their criticality, you need to purchase security software with monitoring, automatic updating, notification, and some security tools and utilities for system scanning, auditing, and mitigation. Furthermore, a single tool isn’t sufficient. You need an intrusion detection/prevention system, firewalls, SELinux, anti-malware, and numerous secure system configurations to improve your systems’ overall security profile.</p>
<p>In this section, I cover creating a daily security report that you can automate for reporting on system security. It’s impossible to watch every system 24 hours per day unless you have some automated processes taking care of it for you. Malicious actors and applications often stop, disrupt, or erase logs to cover their covert operations, so sometimes, the lack of information tells you that you have a problem.</p>
<p>As I start my day, I prefer to view an automated security report as an HTML page to determine if any problems require further investigation. <a contenteditable="false" data-primary="scripting" data-secondary="example of daily security check script" data-type="indexterm" id="idm45657875193408"/>The following is an example of a daily security script (<em>daily_report.sh</em>) that I’ve used in the past. The <em>/opt/note</em> directory is a web-enabled directory aliased as <em>reports</em> in my Apache config. I’ve spaced it so that it’s easier to read:</p>
<pre data-type="programlisting">
#!/bin/bash

#Daily Report Script

today=`date +%m-%d-%Y`

touch /opt/note/$today.xhtml

echo "&lt;pre&gt;" &gt;&gt; /opt/note/$today.xhtml

echo "Last Log " &gt;&gt; /opt/note/$today.xhtml
last | grep root &gt;&gt; /opt/note/$today.xhtml

echo "Non-privileged accounts in the Last Log " &gt;&gt; /opt/note/$today.xhtml
last | grep -v root &gt;&gt; /opt/note/$today.xhtml

echo " " &gt;&gt; /opt/note/$today.xhtml

echo "Root Accounts " &gt;&gt; /opt/note/$today.xhtml
grep :0 /etc/passwd &gt;&gt; /opt/note/$today.xhtml

echo " " &gt;&gt; /opt/note/$today.xhtml

echo "Files modified since yesterday " &gt;&gt; /opt/note/$today.xhtml
find /etc -mtime -1 &gt;&gt; /opt/note/$today.xhtml

echo "&lt;/pre&gt;" &gt;&gt; /opt/note/$today.xhtml</pre>
<p>Creating the report file as <em>today’sdate.xhtml</em> ensures you can keep a list of these files for comparison. <a contenteditable="false" data-primary="diff utility" data-secondary="using to check for security breaches" data-type="indexterm" id="idm45657872088960"/>For example, if you believe you have a possible breach, you can perform a <code>diff</code> on two files to see if there are differences you should be aware of:</p>
<pre data-type="programlisting">
# diff 10-20-2022.xhtml 10-21-2022.xhtml</pre>
<p>No response means the files are the same. However, if you perform a <code>diff</code> and receive something similar to the following, you need to begin investigating further:</p>
<pre data-type="programlisting">
# diff 10-20-2022.xhtml 10-21-2022.xhtml

4a5
&gt; jamd:x:0:0:root:/root:/bin/sh</pre>
<p>This <code>diff</code> shows that someone has created a new root-level account, <code>jamd</code>, on <code>10-21-2022</code>. <a contenteditable="false" data-primary="root user" data-secondary="illegally created root account by intruder" data-type="indexterm" id="idm45657872083120"/>Unfortunately, the way the intruder created this account, any file that <code>jamd</code> touches, modifies, or creates will have root ownership and will look as if the root account created or modified it. And, now that <code>jamd</code> has a root account, they can change the root password, remove accounts from <em>/etc/passwd</em>, and remove the <em>/etc/sudoers</em> file, essentially excluding system administrators from accessing the system except for through the console.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Intruders rarely lock out system administrators because doing so will cause action and remediation. Instead, intruders try to cover their actions and use the systems for data exfiltration or attack other systems inside or outside the current network.</p>
</div>
<p>You can filter logs by specific errors or redirect output from other commands to the file, such as a firewall status check. <a contenteditable="false" data-primary="logs" data-secondary="filtering by specific errors" data-type="indexterm" id="idm45657872108928"/>Place the commands in this script that you use to check on your systems’ security and then set <a contenteditable="false" data-primary="cron jobs" data-secondary="setting up to run security check script daily" data-type="indexterm" id="idm45657872073824"/>up a <code>cron</code> job as <code>www-data</code> to run the script daily and check it as soon as you get to work to begin some forensic investigation or breathe easy and continue your day. Ensure that the <code>www-data</code> user has read, write, and execute permissions on the <em>/opt/note</em> directory.</p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00013">
<h1>Summary</h1>
<p>Troubleshooting is a learned skill that takes time and experience to sharpen, but remember to rely on your coworkers, knowledge bases, logs, and your favorite internet search engine to help you navigate difficult problems. There’s no shame in looking for help from a variety of sources. And remember, sometimes the best solution is to abandon a lengthy troubleshooting session and start with a clean installation.</p>
<p><a data-type="xref" href="ch13.xhtml#securing_your_system">Chapter 13</a> deals with securing your system, an ongoing task requiring focus, skill, and multiple layers of action.<a contenteditable="false" data-primary="troubleshooting Linux" data-startref="ix_trbl" data-type="indexterm" id="idm45657874626512"/></p>
</div></section>
</div></section></div></body></html>