- en: Chapter 21\. Query Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 21.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexes are utilized to find rows quickly if they are created and used as intended.
    Here are the main reasons to use indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Utilize `WHERE` clause in `SELECT` statement efficiently to find rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the best query execution plan by the index’s uniqueness of values stored
    in a given column, known as cardinality, and the least number of rows returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the join operations between different tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes are vital to efficiently scanning and searching for values in tables.
    Without them, MySQL would need to read all of the rows in a given table when performing
    a query. Due to different table sizes, MySQL has to bring all the data read from
    the table to memory, and it can only sort, filter, and return values of the selected
    data. This operation may require additional resources to copy data to a new temporary
    table to perform sort operations. Indexes are crucial to query performance; hence
    non-indexed tables are a considerable overhead to a database unless they are small
    reference tables.
  prefs: []
  type: TYPE_NORMAL
- en: For a fast query performance, a primary key for each table representing one
    or more columns is required. While using the InnoDB storage engine, the table’s
    data is physically ordered to do fast lookups and sorts using primary key columns.
    The ideal table design uses a covering index where the query results are computed
    using index columns. Most of the indexes used by MySQL are stored in B-trees which
    allows fast data access due to reduced data access time.
  prefs: []
  type: TYPE_NORMAL
- en: If the table is big in data size and does not have any keys creating an extra
    field like `table_name_id` as a primary key can bring a considerable benefit in
    setting unique pointers doing join operations. InnoDB tables always have a clustered
    index representing a primary key, if not already created by a user. A clustered
    index is a table where the data and the rows are stored in the table’s order on
    the key values in one direction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If no WHERE clause is used in a query, it’s a full table scan for MySQL optimizer.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This does not change whether index exists or not for the `customer` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some key terms you’ll need to know before getting started
    with index strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Table Scan
  prefs: []
  type: TYPE_NORMAL
- en: The table scan means reading all rows in the given table while performing a
    query. A developer should avoid full table scans as much as possible, including
    doing `COUNT(*)` operations.
  prefs: []
  type: TYPE_NORMAL
- en: Tree traversal
  prefs: []
  type: TYPE_NORMAL
- en: The tree traversal is a method that indexes uses to access data in hops. Indexes
    goal is to make minimum hops via traversal to fetch data. Fewer the number of
    leaf nodes faster the index traversal.
  prefs: []
  type: TYPE_NORMAL
- en: Leaf Nodes
  prefs: []
  type: TYPE_NORMAL
- en: Leaf Nodes is part of the B-tree index structure. They maintain the changes
    in the index as data changes. They establish a doubly linked list to connect index
    leaf nodes.
  prefs: []
  type: TYPE_NORMAL
- en: B-tree Structure
  prefs: []
  type: TYPE_NORMAL
- en: B-tree is a self-balancing tree data structure that keeps data sorted and allows
    searches, sequential access, insertions, and deletions in logarithmic time. The
    B-tree is a generalization of a binary search tree in that a node can have more
    than two children.
  prefs: []
  type: TYPE_NORMAL
- en: While the B-tree index is commonly used among MySQL storage engines, different
    kinds of data structures are used for hash indexes. Hash indexes have different
    characteristics and have it’s own use cases. Consult [“Comparison of B-Tree and
    Hash Indexes”](https://dev.mysql.com/doc/refman/8.0/en/index-btree-hash.html)
    in the MySQL User Reference Manual for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While indexes help retrieve rows faster, over-creating or keeping unused indexes
    is a burden to the database’s I/O operation. Every index leaf page ( lowest level
    of the index where all of the keys for the index appear in sorted order) must
    be maintained for all `UPDATE`/`INSERT`/`DELETE` operations hence creating extra
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 21.1 Creating Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your query is very slow to respond.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an index on your column to retrieve just the rows you are seeking.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tables without indexes are just logbook data written randomly with no reference
    to look up. As a result most of the queries to such tables are slow. The exception
    only applies to reference tables with a limited number of rows depending on schema
    design.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL recommends giving each table a Primary Key column with `NOT NULL` characteristic
    for each row.
  prefs: []
  type: TYPE_NORMAL
- en: We have a table called `top_names` from `Names_2010Census.csv` data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]top_names[PRE2]top_name[PRE3]name_rank[PRE4]name_count[PRE5]prop100k[PRE6]cum_prop100k[PRE7]pctwhite[PRE8]pctblack[PRE9]pctapi[PRE10]pctaian[PRE11]pct2prace[PRE12]pcthispanic[PRE13]'
  prefs: []
  type: TYPE_NORMAL
- en: 'And you load the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created and loaded our table, we can proceed with the following
    query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see below, MySQL has to do full table scan to find any rows in this
    table outside of its `PRIMARY KEY`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our sample query seeks a string match on the `top_name` field; hence having
    an index on this type of data will increase query performance. First we create
    an index to meet `WHERE` clause of this query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We then check if the optimizer has chosen this new index for the same query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Dropping indexes may be required for few reasons. After you make sure the index
    is no longer needed or needs to be recreated, you may drop them using the following
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 21.2 Creating Surrogate Primary Key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Table without Primary Key is not performant enough.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add Primary Key to all InnoDB tables.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A primary key gives you a way to uniquely identify a row in the table. In case
    of InnoDB, a primary key is synonymous with a clustered index: a special index
    that stores row data. When an InnoDB table is created by a user without explicitly
    defining a primary key, InnoDB takes the first unique index that in an index with
    B-Tree structure exists in the table and makes it the clustered index. A clustered
    index is also often referred as physically order of the records on disk. A clustered
    index is a table stored in and if no unique index exists, InnoDB creates a surrogate
    key, called `GEN_CLUST_INDEX` on an automatically generated unique 6-bytes identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: When InnoDB creates secondary indexes, it is useful to resolve queries because
    it copies primary key columns to each secondary index row. If primary key is unnecessarily
    large all secondary indexes would be large as well. Therefore it is very important
    to choose suitable column for the primary key.
  prefs: []
  type: TYPE_NORMAL
- en: In our example on [Recipe 21.1](#nch-queryperf-queryperf-create-index), natural
    primary key is `top_name` that takes 26 bytes. Defining `top_name` as a primary
    key will increase size of every row in the secondary index by 26 bytes. Therefore
    we show here a technique of creating 4-byte integer surrogate keys with property
    `AUTO_INCREMENT`, so it increases monotonically. It is also better than surrogate
    key that InnoDB creates explicitly, because it is smaller and we have full control
    over its values.
  prefs: []
  type: TYPE_NORMAL
- en: Our table is comparatively small but for large tables such difference could
    be critical. Besides space, larger indexes require more time to search through.
  prefs: []
  type: TYPE_NORMAL
- en: This table is missing a field with a `PRIMARY KEY`. The best way to include
    one this table is to add an `id` field with properties `AUTO INCREMENT NOT NULL`.
    Ideally, you would create this in advance of loading any data to the table to
    order table in the tablespace physically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Although the following is a complete index scan, it will use the new `PRIMARY
    KEY` field we have created to count the number of rows in the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about, see MySQL documentation for further details
    on [Primary Key Optimization.](https://dev.mysql.com/doc/refman/8.0/en/primary-key-optimization.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 21.3 Maintaining Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know if existing indexes are effective for your queries and drop
    those which are not.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn basic index operations.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better control your data, use indexes efficiently by studying data and access
    types of your schema. To continue our example from the previous recipe, we will
    examine existing indexes for `top_names` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, what matters most is the `cardinality` of the index. Indexes are better
    utilized if the column has many different values. So, in short, indexes are inefficient
    on boolean and redundant values.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, cardinality of the index `idx_names` is close to the cardinality
    of the primary key. This shows that the index has good selectivity. Actually,
    this index could be also `unique` that we can confirm by querying number of the
    distinct values in this column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since we’ve already created an index on the `top_name` column, we can drop that
    index, then create a new, unique one. First to drop the index execute following
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, `ALTER TABLE` syntax can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a unique index specify keyword `UNIQUE` for the `CREATE INDEX` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can rename an existing index created on the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Not all `index` operations are In Place; some index operations will cause table
    rebuild, which may negatively impact the server’s performance for large data sizes.
    Care must be taken before executing DDL operations. DDL (Data Definition Language)
    implies changing the structure of table definition as known as the database schema.
    For further details please consult [MySQL Documentation.](https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html#online-ddl-index-operations)
  prefs: []
  type: TYPE_NORMAL
- en: 21.4 Deciding When a Query Can Use an Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your table has an index, but queries are still slow.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check query plan using `EXPLAIN` to make sure right index is used.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexes are part of query plans to access data faster by using the shortest
    possible path. When MySQL optimizer makes a decision, it considers indexes, cardinality,
    number of rows, and more. Here’s an example of a query where index exists for
    a column but MySQL can not utilize it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: From the `Explain` plan output, We have no index that matches the key criteria
    of the query. There are indexes on this table and looks like we’ll need another
    index on `name_rank` field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the query plan again after creating the new index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Our query is seeking for a `name_rank` that is less than ten from the `top_names`
    table. Without newly created `idx_name_rank` on the `name_rank` column, the optimizer
    has to evaluate all the 161604 rows in the table to filter 11 rows in return.
    With the index in place it accesses just those 11 rows.
  prefs: []
  type: TYPE_NORMAL
- en: 21.5 Deciding Order for Multiple Column Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to speed up your multiple column query.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use covering index with multiple columns.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Best query performance can be achieved if query results are computed entirely
    from the index pages without reading the actual table data. A covering index is
    a solution for queries referencing more than one column. This type of index contains
    the required data; hence, it does not need to execute additional reads on the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we have a query that requires having a filter on one
    column (`name_rank`) and sort by another column (`name_count`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We will create an index on the columns that we think are required for the optimizer
    to choose the fstest path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, MySQL cannot use the index against the following query and it
    ends up needing to do a full table scan again. The reason is, despite having both
    columns of the query in the filter the, index is ordered reverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate why the order of index columns matters, let’s look at the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the: ``KEY `idx_name_rank_count` (`name_rank`,`name_count`)`` first drop
    the previous index in reverse order and create a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have created a covering index for both columns our SELECT statement proposes
    on name_rank and name_count filters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the `EXPLAIN` output, the optimizer chooses `idx_name_rank_count`
    for this query with a new covering index.
  prefs: []
  type: TYPE_NORMAL
- en: 21.6 Using Ascending and Descending Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to scan your data in ascending or descending order without a performance
    penalty.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use ascending and descending indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL can scan indexes in reverse order with a performance penalty due to index
    pages being physically ordered. In order to create a matching index for the `ORDER
    BY` clause, use `DESC` for descending, `ASC` for ascending index types.
  prefs: []
  type: TYPE_NORMAL
- en: The ideal query performance comes from when you can avoid scanning an index
    backward. It’s also a combination of sorting and filtering with the `DESC` indexes.
    When MySQL optimizer chooses a query plan, it evaluates if it can take advantage
    of these when the query needs descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Remember descending indexes are supported for the InnoDB storage engine, and
    there are some limitations to its use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, descending indexes have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: They are supported by all data types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DISTINCT` clause can use any index with a matching column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be used for `MIN()`/`MAX()` optimization when not used in conjunction
    with the `GROUP BY` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are only limited to `BTREE` and `HASH` indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are not supported for `FULLTEXT` or `SPATIAL` index types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following example starts with creating covering index for our desired sorting
    for fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]top_name[PRE39],[PRE40]prop100k[PRE41],[PRE42]cum_prop100k[PRE43]'
  prefs: []
  type: TYPE_NORMAL
- en: After creating the covering index for all `ORDER BY` clauses, optimizer columns
    choose the `idx_desc_01`. This is particularly good for index optimization and
    sorting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When we do `SELECT * FROM top_names`, instead of specifying columns order by
    `top_name` field, it uses previously created index, and by default, it is ascending
    order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate the use of descending indexes, we will create a new index and
    use `DESC` to apply that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again using top_name with another column `prop100k` to illustrate the use of
    `DESC` index on the `top_name` column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Order matters as MySQL use the left-most order rule for the indexes compared
    to `ORDER BY` clause. Changing the order of columns in the composite index will
    change the behavior of the query result. Also, be careful on using `SELECT * FROM`
    when sorting by multiple fields as `*` will use the column order from table definition,
    which may end up with different fields than the `ORDER BY` clause intends to.
  prefs: []
  type: TYPE_NORMAL
- en: 21.7 Using Function-Based Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to search or sort by an expression but MySQL calculates result of the
    expression for each row, therefore cannot use indexes. Performance of the query
    is poor.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use functional indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some types of information are more easily analyzed using not the original values,
    but an expression computed from them. For example, column `size` in the table
    `mail` stores size in bytes that is hard to interpret on first glance. It would
    be much easier to work with if using kilobytes (`KB`) instead. However, you may
    not want to lose precision that storage in bytes provides.
  prefs: []
  type: TYPE_NORMAL
- en: You can have both precision and usability if you store data in bytes and use
    expressions to query the table. For example, to find messages that are larger
    than 100 KB, use the following query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: However, MySQL would not be able to use index on the column `size` to resolve
    this query, because it calculates expression for each row. To resolve this issue
    use function-based indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the function-based index is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Mind double brackets: if you omit one pair, MySQL will think you are passing
    a column name instead of the expression and will return an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an index on `ROUND(size/1024)` and check if MySQL will use it to
    resolve the query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The index will not be used to resolve the query because function `ROUND` returns
    data in the `NEWDECIMAL` type for values that have floating point and `100` is
    `LONGLONG`. You can examine the result if start *mysql* client with the option
    `--column-type-info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We need to use command *unbuffer*, because *mysql* buffers `--column-type-info`
    result and it cannot be piped to *grep* otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: To clarify,to force MySQL to use the index,you need to compare result of the
    expression with a floating point value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, cast the result of the function `ROUND` to the integer value
    when creating the index. And this also forces MySQL to use the index to resolve
    the query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 21.8 Using Indexes on Generated Columns with JSON Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to perform search inside JSON data but it is slow.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a generated column, created from an expression that searches for a JSON
    value and an index on this column.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will discuss a table `book_authors`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The table contains book records per author in the JSON column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you want to search for a specific author you may consider searching by their
    name and lastname.
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE INDEX` command creates an index on a column in the table. JSON data
    stored in a single column, therefore any index, created with simple `CREATE INDEX`
    command would index whole JSON document while you may need to search only part
    of it.'
  prefs: []
  type: TYPE_NORMAL
- en: More over, `CREATE INDEX` command will fail for the JSON column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Solution for this issue would be use of a generated column and creating index
    on it. Values in generated columns are created using expression, defined at the
    column creation time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we created a column, generated from the expression `JSON_EXTRACT(author,
    ''$.lastname'')`. We can also use operators `->` and `->>` to extract JSON value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We used function `JSON_UNQUOTE` and operator `->>` in our expressions to remove
    trailing quotes in author’s names if they exist.
  prefs: []
  type: TYPE_NORMAL
- en: Two new columns `name` and `lastname` do not take any space and generated each
    time when a query accesses the table.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to improve performance of your `SELECT` queries in price of additional
    storage and slowness at the write time define generated columns with keyworkd
    `STORED`. In this case expression would be executed only once: when values, used
    in the expression, are inserted or modified and then physically stored on the
    disk.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create an index on our new generated columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: To access data using newly created index refer new columns as any other column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`EXPLAIN` confirms that the new index is used.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about using JSON in MySQL, see [Chapter 19](ch19.xhtml#nch-json).
  prefs: []
  type: TYPE_NORMAL
- en: 21.9 Using Full Text Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to take advantage of keyword search, but queries on text fields are
    slow.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `FULLTEXT` indexes for full-text searches.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL supports `FULLTEXT` indexes for limited but on popular storage engines
    such as InnoDB and MyISAM. Although neither of the storage engines are originally
    designed to index large text operations, they can still use them to comb performance
    for specific queries.
  prefs: []
  type: TYPE_NORMAL
- en: '`FULLTEXT` indexes have two other conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: It can only be used it for `CHAR`, `VARCHAR`, or `TEXT` columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can only use when `MATCH()` or `AGAINST()` clause in a `SELECT` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In MySQL, `MATCH()` function performs a full-text search by accepting a comma-separated
    list of columns where `AGAINST()` takes a string to search.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`FULLTEXT` index can be used with a combination of B-tree index on the same
    column as their purpose is different. `FULLTEXT` is for finding keywords versus
    matching values in the field.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FULLTEXT` text searches also have three different modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Natural language mode (default) is the search mode for simple phrases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Boolean mode` is for using boolean operators in search mode. Recall that the
    same strategy discussed in [Recipe 7.17](ch07.xhtml#nch-strings-strings-full-text-boolean)
    similarly use of operators here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Query expansion mode` is the search mode for similar or related values to
    a search expression. In short, this mode will return relevant matches against
    a searched keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: InnoDB storage engine can take advantage of the following optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Queries that only return the `ID` field of the search rank. Search rank is defined
    as relevance rank as a measure to show how good is the match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries that sort the matching rows in descending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimizer will choose the none fulltext index on the `top_name` column.
    This is due to the query being written to optimize InnoDB’s b-tree index with
    pattern matching instead of literal comparison. For more information, see [Recipe
    7.10](ch07.xhtml#nch-strings-strings-pat-sql). This type of query is very efficient
    given the data type we have in this example with indexed unique string values
    in this `top_name` column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now if we try a pattern match against the same column, we will be able to utilize
    full text index for the given column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we can see MySQL chooses to use the `FULLTEXT` index. Although
    it’s useful to have `FULLTEXT` index availability in MySQL, it comes with many
    restrictions. Please refer to MySQL documentation for further details on [Full-Text
    Restrictions.](https://dev.mysql.com/doc/refman/8.0/en/fulltext-restrictions.html)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Despite the availability of full-text indexes in the InnoDB storage engine,
    there may be better alternatives in the market to take this off of MySQL workload
    and put it on another optimized storage system.
  prefs: []
  type: TYPE_NORMAL
- en: 21.10 Utilizing Spatial Indexes and Geographical Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to store and query geographic coordinates effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use MySQL’s improved Spatial Reference System.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL 8 contains all SRS (Spatial Reference System) identifications from EPSG
    (European Petroleum Survey Group) agency. These SRS identifications are stored
    with a unique name and SRID in `information_schema`.
  prefs: []
  type: TYPE_NORMAL
- en: These systems represent different variations of geographic data references.
    You can query details of these from `information_schema`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: SRS_ID 4326 represents widespread web map projections used in Google Maps, OpenStreetMaps,
    etc., whereas 4326 is GPS coordinates used for tracking locations.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we have point of interest data that we keep in our database. We will
    create a table and load sample data to it using SRID 4326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now create an index on the geometry column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We will demonstrate how to measure the distance between these two points of
    interest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This is a representation of a straight line between these two points of interest.
    Of course, this isn’t a car route planning example; this is more like a bird’s
    flight from point A to B in meters.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check what MySQL used as query optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Since the `ST_Distance` function does not use a table to calculate distance
    between these two locations, it does not use a table in the query; hence there’s
    no index optimization allowed.
  prefs: []
  type: TYPE_NORMAL
- en: You can further improve on the distance calculation about Earth spherical shape
    should be using `ST_Distance_Sphere`, which will result in slightly different
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Let’s say we have a polygon around Istanbul for covering our target search area.
    The required polygon coordinates can be generated via another application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This time we’ll search points of interest using `ST_Within` function from that
    polygon area. There are many functions built into MySQL’s Spatial Reference implementation.
    For details please refer to MySQL documentation [Spatial Analysis Functions.](https://dev.mysql.com/doc/refman/8.0/en/spatial-analysis-functions.html)
    Spatial functions can be grouped into few categories such:'
  prefs: []
  type: TYPE_NORMAL
- en: Create geometries in various formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert geometries between formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access qualitative and quantitative properties of geometry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe relations between two geometries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new geometries from existing ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functions allow developers to get faster access to the data and better
    utilize spatial analysis within MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: In the following query, we are utilizing both `ST_AsText` and `ST_Within` functions
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76] ` [PRE77] ` [PRE78]towers[PRE79]position[PRE80],` `@``poly``)` `;`'
  prefs: []
  type: TYPE_NORMAL
- en: +--------+----------------+------------------------+ | poi_id | name           |
    towers                 |
  prefs: []
  type: TYPE_NORMAL
- en: +--------+----------------+------------------------+ |      1 | Maiden's Tower
    | POINT(41.0211 29.0041) |
  prefs: []
  type: TYPE_NORMAL
- en: '|      2 | Galata Tower   | POINT(41.0256 28.9742) |'
  prefs: []
  type: TYPE_TB
- en: +--------+----------------+------------------------+ 2 rows in set (0.00 sec)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: mysql> `EXPLAIN`  `SELECT`  `poi_id``,` `name``,`
  prefs: []
  type: TYPE_NORMAL
- en: -> `ST_AsText``([PRE82]position[PRE83])` `AS` `` ` [PRE84] ` `` `FROM` `poi`
    `WHERE` `ST_Within``(` `` ` [PRE85] ` [PRE86]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 21.11 Creating and Using Histograms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to join two or more tables,but MySQL’s optimizer does not choose the
    right query plan.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use optimizer histograms to aid decision making.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexes are helpful for resolving query plans but they could not always be used
    to create the best query execution plan. This applies to situations when the optimizer
    needs to identify order in which to join two or more tables.
  prefs: []
  type: TYPE_NORMAL
- en: Assume you have two tables. One stores product categories in a shop and another
    stores sales data. Number of categories is small while number of sold items is
    huge. You may have a dozen categories and millions of sold items. When you join
    two tables MySQL has to decide which table to query first. If it queries small
    table first it has to retrieve all items in the selected category, then filter
    them. If number of items in the selected category is huge and number of filtered
    items is small query would be not effective. On the other side, if you need items
    from the single category while range, selected from the larger table, returns
    many rows from all categories you will have to discard them all except single
    category.
  prefs: []
  type: TYPE_NORMAL
- en: One of solutions to this issue is to have a combined index that takes category
    id and condition in the larger table. But this solution may not work for complicated
    queries when such a combined index is not applicable to the combinarion of the
    `WHERE` condition and `JOIN` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another issue with indexes is that they operate by cardinality: number of unique
    values in the index. But when data distribution is not even optimizer can make
    false conclusions when uses cardinality only. Assume you have one million items
    with certain characteristic and 10 items with another one. If the optimizer decides
    to select data that satisfy first condition the query would take much more time
    if compare with one that first selects items that satisfy the second one. Unfortunately
    it is not possible to make correct conclusion using information about cardinality
    only.'
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue MySQL 8.0 introduces optimizer histograms. They are a
    lightweight data structure that store information about how many unique values
    exist in each data bucket.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how optimizer histograms work let’s consider a table of six rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: As you see the table contains one row with value 1, two rows with value 2 and
    three rows with value 3.
  prefs: []
  type: TYPE_NORMAL
- en: If we run `EXPLAIN` on queries, selecting different rows in this table we will
    notice that number of rows, filtered from the result is same no matter which value
    we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Number of filtered rows shows how many rows would be filtered from the retrieved
    result. Since our table does not have indexes MySQL first retrieves all rows from
    the table then filters those which satisfy condition. Without any hint optimizer
    thinks that MySQL will leave only one row from the result no matter which condition
    we use.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a histogram and check if it changes anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Histograms are stored in the data dictionary table `column_statistics` and can
    be examined by querying table `COLUMN_STATISTICS` in Information Schema.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Three buckets contain information about data ranges. Value 1 takes 1/6 of the
    table (one row out of six), values 1 and 2 both take a half (0.5) of the table
    and together with value 3 they fill the table. Number of items in each bucket
    stored as fraction of one. Field `number-of-buckets-specified` contains number
    of buckets, specified at the histogram creation time. Default value is 100 but
    you are free to specify any number between 1 and 1024\. If number of unique elements
    in the column exceeds number of buckets `histogram-type` will change from `singleton`
    to `equi-height` and each bucket could contain a range of values instead of only
    one in case of `singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms affect the value for the `filtered` field in the `EXPLAIN` output.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below values for the filtered rows correct and reflect content
    of the table. In case if we search value 1, five of six table rows are predicted
    to be removed from the result set, which correct. For the value 2 only two rows
    (33.33%) would be left in the result, and in case of value 3 half of the table
    will be filtered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Histograms do not help to access data: they are statistic only, not physical
    structure like indexes. They, instead, affect query execution plan and, particularly,
    order of tables joined. For example, if we decide to join `histograms` table with
    itself order will be different depending from the condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The true power of histograms are demonstrated on large tables. The companion
    GitHub repository has data for two tables: `goods_shops` and `goods_characteristics`.
    They are created without histograms by default while having indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If we want to find number of laptops with screen size that is less than 13 inches
    and the manufacturer one of Lenovo, Dell, Toshiba, Samsung or Acer, available
    by Premium or Urgent delivery in Moscow or Kiev we may use a following query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The query took over 6 minutes, which is quite long for two tables of less than
    half-million rows. Reason for this is that table `goods_shops` contains just few
    rows that satisfy condition for the shop location and delivery options while table
    `goods_characteristics` has much more rows that satisfy laptop size and manufacturer
    condition. In such a situation it would be better to select data from the table
    `goods_shops` first while optimizers decides opposite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Indexes would not help here, because they use cardinality that is same for the
    any value in the indexed column. Here is when histograms can show their power.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Once a histogram is created, the optimizer joins tables in the effective order
    and query takes slightly more than one second instead of six minutes in the previous
    run.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For additional information about using histograms in MySQL, see [Billion Goods
    in Few Categories: How Histograms Save a Life?](https://www.percona.com/resources/webinars/billion-goods-few-categories-how-histograms-save-life).'
  prefs: []
  type: TYPE_NORMAL
- en: 21.12 Writing Performant Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write efficient queries.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Study how MySQL accesses data and adjust your queries to help MySQL perform
    its job faster.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen in this chapter, there are many iterations of index implementation
    in MySQL. While, we take advantage of these index types, we also need to know
    how MySQL accesses data. The optimizer is a very advanced part of MySQL but still
    does not always make correct decisions. When it doesn’t choose the right path,
    we’ll end up with poor query performance, which may lead to degraded service or
    outage in our applications at production. The best way to writing performant queries
    is to know how MySQL accesses data.
  prefs: []
  type: TYPE_NORMAL
- en: The other point here is being at scale is different than using the application
    in a monolith environment. As the concurrency increases with data size, the decision
    optimizer will choose the fastest data route that will be more complex to handle.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL uses a cost-based model to estimate the cost of various operations during
    query execution in the following order.
  prefs: []
  type: TYPE_NORMAL
- en: Find the optimal method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the access method useful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Estimate the cost of using the access method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the lowest cost access method possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the order of Query Execution that MySQL chooses:'
  prefs: []
  type: TYPE_NORMAL
- en: Table Scan
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Index Scan
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Index Lookup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Range Scan
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Index Merge
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loose Index Scan
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following are some known reasons for slow index lookups for those still
    using an index with poor performance outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Low cardinality
  prefs: []
  type: TYPE_NORMAL
- en: When data is not diverse enough to identify a fast traversal, MySQL will end
    up doing a full table scan.
  prefs: []
  type: TYPE_NORMAL
- en: Large data sets
  prefs: []
  type: TYPE_NORMAL
- en: Returning large data sets often causes problems. Even if they are correctly
    filtered they may be useless as your application can’t process them fast enough.
    Only target data that are needed in your query and filter the rest out.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple index traversal
  prefs: []
  type: TYPE_NORMAL
- en: If you have a query hitting multiple indexes, the extra I/O operation hopping
    through pages will lead to slow query performance.
  prefs: []
  type: TYPE_NORMAL
- en: Non-leading column lookup
  prefs: []
  type: TYPE_NORMAL
- en: If you do not use the leading column for a covering index, a covering index
    cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: Data type mismatch
  prefs: []
  type: TYPE_NORMAL
- en: Indexes can not help if data types don’t match when querying columns.
  prefs: []
  type: TYPE_NORMAL
- en: Character Set / Collation mismatch
  prefs: []
  type: TYPE_NORMAL
- en: Data access should be unified around the character set and collation of the
    query.
  prefs: []
  type: TYPE_NORMAL
- en: Suffix lookup
  prefs: []
  type: TYPE_NORMAL
- en: Looking for a suffix will degrade performance significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Index as argument
  prefs: []
  type: TYPE_NORMAL
- en: Using an indexed column as an argument will not efficiently use the index.
  prefs: []
  type: TYPE_NORMAL
- en: Stale Statistics
  prefs: []
  type: TYPE_NORMAL
- en: MySQL updates statistics based on the index cardinality. This helps the optimizer
    to make decisions for the fastest path possible.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Bug
  prefs: []
  type: TYPE_NORMAL
- en: It’s rare, but a possible. MySQL bug can cause slow index lookups.
  prefs: []
  type: TYPE_NORMAL
- en: Query types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When designing the application it is useful to recognize common query patterns,
    when they can be applied and when not.
  prefs: []
  type: TYPE_NORMAL
- en: Point Select
  prefs: []
  type: TYPE_NORMAL
- en: One of the fastest methods to access your data is to do a point select targeting
    indexed column directly. In this case, the optimizer already knows the page that
    your data sits on if the index exists in that column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: in this case,`names_id` column, is the Primary Key column of the table, so the
    access is straight to that page’s path by the optimizer.
  prefs: []
  type: TYPE_NORMAL
- en: Range Select
  prefs: []
  type: TYPE_NORMAL
- en: This type of `SELECT` is when you need a range of rows from your data set. MySQL
    can still use an index to access the data directly using the index on the same
    column as in `WHERE` clause of the query. This type of access method uses a single
    index or subset of values from an index or indexes. The range index is also known
    as using single or multi-part index utilization. In the following example, the
    optimizer uses comparison on `name_rank` field with `<` and `>` operators. Also,
    for all index types, `AND` or `OR` combinations will be a range condition. For
    MySQL fastest lookup is Primary Key. Remember this is also the physical order
    of the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Covering Indexes
  prefs: []
  type: TYPE_NORMAL
- en: Covering indexes are indexes that could be used to resolve the query without
    accessing rows data. To make sure other supporting indexes cover your query, we
    should use secondary indexes at times. An index should be leftmost first and each
    additional field in a composite key. Query should not access columns that do not
    exist in the index (see [Recipe 21.5](#nch-queryperf-queryperf-index-mulitple)).
  prefs: []
  type: TYPE_NORMAL
- en: The following example, index used to resolve query condition without accessing
    table data but in the end table data is accessed, because we asked for the `top_name`
    column that does not exist in the index. Statement `Using index condition` in
    the `Extra` field of the `EXPLAIN` output confirms that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This query uses covering index. Statement `Using index` confirms that. A primary
    key is already part of the covering index; hence no need to include `names_id`
    into the covering index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Data type matching
  prefs: []
  type: TYPE_NORMAL
- en: Data types are another crucial fact to use indexes efficiently. Using numeric
    for numeric comparison is essential for the optimizer. The following query is
    a bad example of how MySQL does not like this data type conversion when it comes
    down to `names_id` an `INTEGER` field with string. Below please see the warning
    message we get.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: While the query may return results MySQL has to perform job to convert string
    into number and loose precision.
  prefs: []
  type: TYPE_NORMAL
- en: Negative conditions
  prefs: []
  type: TYPE_NORMAL
- en: Often times most efficient indexes can not be used for these types of queries.
    This is because MySQL has to select all rows from the table or index, then filter
    those which are not in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid negative clauses if possible as they are inefficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IS NOT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IS NOT NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOT IN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOT LIKE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: ORDER BY operations
  prefs: []
  type: TYPE_NORMAL
- en: Sorting operations can be expensive as the data set grows, especially if the
    query cannot use index to resolve `ORDER BY`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The same applies to the `LIMIT` operations. These type of queries usually return
    a small set of data with high cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Query above selects large number of rows and then discards most of them.
  prefs: []
  type: TYPE_NORMAL
- en: JOINs
  prefs: []
  type: TYPE_NORMAL
- en: Join operations are an original way of combining or referencing data from two
    or more tables. While SQL joins serve a particular purpose, they can create a
    cartesian product on query results if not used properly. Using `INNER` joins to
    filter only the intersection of tables in `SELECT` statement is highly advised
    versus `LEFT JOIN`s. Although using `INNER JOIN` is not always possible to comply
    with the required business logic. In those cases, still targeting indexed fields
    will benefit query execution time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In MySQL `JOIN` is a synonymous of `INNER JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: To help the optimizer to choose the best possible path to access your data by
    creating correct indexes and writing efficient queries. This type of approach
    will improve your throughput overall. Add only indexes you need and don’t over-index
    tables. Avoiding duplicate indexes another best practice to achieve performant
    queries. Identify if the same indexes in your table may cause a slow down on both
    reads and writes.
  prefs: []
  type: TYPE_NORMAL
