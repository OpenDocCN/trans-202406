- en: Chapter 8\. Policy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。政策
- en: Once a system is constructed on solid foundations, it must be used correctly
    to maintain its integrity. Building a sea-fort to defend an island from pirates
    is half the battle, followed by posting guards to the watchtower and being prepared
    for defense at any time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个系统建立在坚实的基础上，就必须正确使用以保持其完整性。建造一个海上要塞来抵御海盗是一场战斗的一半，接着是派遣守卫到瞭望塔，并随时准备进行防御。
- en: Like the orders to the fort’s guards, the policies applied to a cluster define
    the range of behaviors allowed. For example, what security configuration options
    a pod must use, storage and network options, container images, and any other feature
    of the workloads.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对要塞守卫的命令一样，应用于集群的政策定义了允许的行为范围。例如，一个 pod 必须使用什么安全配置选项，存储和网络选项，容器镜像，以及工作负载的任何其他特性。
- en: Policies must be synchronized across clusters and cloud (admission controllers,
    IAM policy, security sidecars, service mesh, `seccomp` and AppArmor profiles)
    and enforced. And policies must target workloads, which raises a question of identity.
    Can we prove the identity of a workload before giving it privileges?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 政策必须在集群和云中同步（准入控制器，IAM 政策，安全边车，服务网格，`seccomp` 和 AppArmor 配置文件）并加以执行。政策必须针对工作负载，这引发了一个身份的问题。我们能证明一个工作负载的身份吗，在给予其特权之前？
- en: In this chapter we look at what happens when policies are not enforced, how
    identity for workloads and operators should be managed, and how the Captain would
    try to engage with potential holes in our defensive walls.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看当政策未被执行时会发生什么，工作负载和操作员的身份应该如何管理，以及船长将如何尝试与我们防御墙上的潜在漏洞进行交互。
- en: We will first review different types of policies and discuss the out-of-the-box
    (OOTB) features of Kubernetes in this area. Then we move on to threat models and
    common expectations concerning policies such as auditing. The bulk of the chapter
    we spend with the access control topic, specifically around role-based access
    control (RBAC) and further on we investigate the generic handling of policies
    for Kubernetes, based on projects such as the Open Policy Agent (OPA) and Kyverno.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将审查不同类型的政策，并讨论 Kubernetes 在这一领域的开箱即用（OOTB）功能。然后我们转向威胁模型和关于审计等政策的常见期望。本章的大部分内容我们将花在访问控制主题上，特别是围绕基于角色的访问控制（RBAC），然后我们进一步研究基于项目如开放策略代理（OPA）和
    Kyverno 的 Kubernetes 政策的通用处理。
- en: Types of Policies
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 政策类型
- en: 'In real-world scenarios—that is, when you’re running workloads in production—in
    the context of a business, you have to consider different types of policies:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中——也就是说，当你在生产中运行工作负载时——在业务的背景下，你必须考虑不同类型的政策：
- en: Technical policies
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 技术政策
- en: These are usually well understood and straightforward to implement (for example,
    runtime or network communication policies).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常很容易理解并且易于实施（例如，运行时或网络通信政策）。
- en: Organizational policies
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 组织政策
- en: Arriving at these policies can, depending on the organization, be challenging
    (for example, “developers only deploy to test and dev environments”).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这些政策可能会因组织而异具有挑战性（例如，“开发人员只能部署到测试和开发环境”）。
- en: Regulatory policies
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 法规政策
- en: These policies are dependent on the vertical your workload is operating in and
    can, depending on the level of compliance, take a lot of time and energy to implement
    (for example, the Payment Card Industry Data Security Standards [PCI DSS] policy
    that cardholder data transmitted across open, public networks must be [encrypted](https://oreil.ly/iSQEE)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些政策取决于您的工作负载所在的行业，根据合规性水平的不同，可能需要大量时间和精力来实施（例如，要求卡片持有人数据在开放的公共网络上传输时必须[加密](https://oreil.ly/iSQEE)的
    PCI DSS 政策）。
- en: In the context of this chapter, we focus mainly on how to define and enforce
    policies that can be explicitly stated. In [Chapter 10](ch10.xhtml#ch-organizations)
    we go further and look at the organizational context and how usually, despite
    all policies in place, the human user (as the weakest link in the chain), provides
    the Captain with a welcome entry angle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的背景下，我们主要关注如何定义和执行可以明确陈述的政策。在[第 10 章](ch10.xhtml#ch-organizations)中，我们将进一步探讨组织背景，通常情况下，尽管所有政策已经到位，但人类用户（作为链条中最薄弱的环节）为船长提供了一个受欢迎的入口角度。
- en: Let’s first have a look at what Kubernetes brings, by default, to the table.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看 Kubernetes 默认提供了什么。
- en: Defaults
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认值
- en: Policy is essential to keeping Kubernetes secure, but by default little is enabled.
    Configuration mutates with time for most software as new features come out; misconfiguration
    is a common attack vector, and Kubernetes is no different.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 策略对于保持 Kubernetes 安全至关重要，但默认情况下很少启用。大多数软件的配置随着时间的推移而变化，随着新功能的推出，配置错误成为常见的攻击向量，Kubernetes
    也不例外。
- en: Reusing and extending open source policy configuration for your needs is often
    safer than rolling out your own, and to protect against regressions you must test
    your infrastructure and security code with tools like [conftest](https://oreil.ly/Jvg7z)
    before you deploy it; in [“Open Policy Agent”](#open-policy-agent) we will dive
    deeper into this topic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于满足您需求的重复使用和扩展开源策略配置通常比自行推出更安全，为了防止退化，您必须使用诸如 [conftest](https://oreil.ly/Jvg7z)
    等工具测试基础设施和安全代码，我们将在 [“开放策略代理”](#open-policy-agent) 深入探讨此主题。
- en: '[Figure 8-1](#tweet-brad-psp), sums up the sentiment nicely. In it, Kubernetes
    security practitioner [Brad Geesaman](https://oreil.ly/KaOWm) points out the dangers
    of not having admission control enabled by default; see also the respective [TGIK
    episdode](https://oreil.ly/kHpfU).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-1](#tweet-brad-psp)，很好地总结了这种情感。在这张图片中，Kubernetes 安全从业者 [Brad Geesaman](https://oreil.ly/KaOWm)
    指出了默认未启用准入控制的危险性；还可以参见相应的 [TGIK episode](https://oreil.ly/kHpfU)。'
- en: Now, what are the defaults that the Captain might be able to exploit, if you’re
    asleep at the helm?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果船长在岗位上睡着了，会有哪些默认设置可以被利用呢？
- en: '![tweet-brad-not-a-container-escape](Images/haku_0801.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![tweet-brad-not-a-container-escape](Images/haku_0801.png)'
- en: Figure 8-1\. Brad Geesaman sagely reminding us of the dangers of Kubernetes
    defaults, and the importance of adding admission control
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. Brad Geesaman 明智地提醒我们 Kubernetes 默认设置的危险性，以及添加准入控制的重要性。
- en: Kubernetes offers out-of-the-box support for some policies, including for controlling
    network traffic, limiting resource usage, runtime behavior, and most prominently
    for access control, which we will dive deeper into in [“Authentication and Authorization”](#policy-authn-authz)
    and [“Role-Based Access Control (RBAC)”](#rbac) before we shift our attention
    to generic policies in [“Generic Policy Engines”](#generic-policy-engines).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一些策略的即插即用支持，包括控制网络流量、限制资源使用、运行时行为以及最主要的访问控制，我们将在 [“认证和授权”](#policy-authn-authz)
    以及 [“基于角色的访问控制（RBAC）”](#rbac) 之前深入探讨这些内容，然后转向 [“通用策略引擎”](#generic-policy-engines)。
- en: Let’s have a closer look now at the defaults and see what challenges we face.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更仔细地看一看默认设置，并看看我们面临哪些挑战。
- en: Network Traffic
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络流量
- en: The `NetworkPolicy` resource, in conjunction with a CNI plug-in that enforces
    it, allow us to put policies constraining network traffic in place (also see [Chapter 5](ch05.xhtml#ch-networking)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`NetworkPolicy` 资源与强制执行它的 CNI 插件结合使用，允许我们制定约束网络流量的策略（另见 [第 5 章](ch05.xhtml#ch-networking)）。'
- en: Limiting Resource Allocations
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制资源分配
- en: In Kubernetes, by default, containers in pods are not restricted concerning
    compute resource consumption. Since Kubernetes 1.10 you can use [LimitRanges](https://oreil.ly/nQsYU)
    to constrain container and pod resource allocations on a per-namespace basis.
    This policy type is enforced via an admission controller, with the implication
    that it doesn’t apply to running pods.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，默认情况下，Pod 中的容器在计算资源消耗方面没有限制。自 Kubernetes 1.10 版本开始，您可以使用 [LimitRanges](https://oreil.ly/nQsYU)
    在每个命名空间基础上约束容器和 Pod 的资源分配。这种策略类型通过准入控制器强制执行，意味着不适用于正在运行的 Pod。
- en: 'To see how LimitRanges work in action, assume you want to limit the memory
    containers can use in the `dev` namespace to 2 GB of RAM. You would define the
    policy like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 LimitRanges 在实际操作中的工作方式，假设您想要限制 `dev` 命名空间中容器可使用的内存为 2 GB。您可以定义如下策略：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assuming you stored the preceding YAML snippet in a file called *dev-mem-limits.yaml*
    you would then, in order to enforce the limit range, execute the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您将前面的 YAML 片段存储在名为 *dev-mem-limits.yaml* 的文件中，则为了强制执行限制范围，您将执行以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you now tried to create a pod with a container that attempts to use more
    memory, you’d get an error message of type 403 Forbidden.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试创建一个尝试使用更多内存的容器的 Pod，您将收到类型为 403 Forbidden 的错误消息。
- en: Resource Quotas
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源配额
- en: In a multitenant environment, where a cluster is shared among multiple teams,
    a particular team could potentially use more than its fair share of the available
    resources as provided by the worker nodes (CPU, RAM, etc.). [Resource quotas](https://oreil.ly/7sZLF)
    are a policy type allowing you to control these quotas.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户环境中，一个集群被多个团队共享，一个特定的团队可能会使用超过工作节点（CPU、RAM 等）提供的公平份额。[资源配额](https://oreil.ly/7sZLF)
    是一种策略类型，允许您控制这些配额。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Certain Kubernetes distributions, such as OpenShift, for example, extend namespaces
    in a way (there it’s called “project”) that things like resource quotas are available
    and enforced out of the box.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 Kubernetes 发行版（例如 OpenShift）以一种方式扩展命名空间（在那里称为“项目”），使得资源配额等功能可以直接使用和强制执行。
- en: 'For concrete usages, peruse the in-depth article [“How to Use Kubernetes Resource
    Quotas”](https://oreil.ly/MZKxX) and also check out the Google Cloud blog post
    on the topic, [“Kubernetes Best Practices: Resource Requests and Limits”](https://oreil.ly/eTrf5).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具体的用法，请查阅深入文章 [“如何使用 Kubernetes 资源配额”](https://oreil.ly/MZKxX)，同时查看 Google
    Cloud 关于此主题的博客文章 [“Kubernetes 最佳实践：资源请求和限制”](https://oreil.ly/eTrf5)。
- en: In addition, since Kubernetes v1.20 there is also a possibility to limit the
    number of [process IDs](https://oreil.ly/AJaM8) a pod may use on a per-node basis.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，自 Kubernetes v1.20 起，还有可能限制每个节点基础上的 pod 使用的 [进程 ID](https://oreil.ly/AJaM8)
    的数量。
- en: Runtime Policies
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时策略
- en: '[Pod Security Policies](https://oreil.ly/NfYXy) (PSPs) allow you to define
    fine-grained authorization of pod creation and updates.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pod 安全策略](https://oreil.ly/NfYXy)（PSPs）允许您定义对 pod 创建和更新的精细授权。'
- en: 'Let’s say you want to set default `seccomp` and AppArmor profiles with PSPs,
    as also shown in the canonical docs example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望使用 PSP 设置默认的 `seccomp` 和 AppArmor 配置文件，正如经典文档示例中所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There is an issue with PSPs, though. They are at time of writing of the book
    in the [process of being deprecated](https://oreil.ly/YWAEJ).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，PSP 在撰写本书时存在一些问题。它们正在 [被淘汰的过程中](https://oreil.ly/YWAEJ)。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Increasingly, organizations are looking into the [OPA Constraints Framework](https://oreil.ly/9eC1B)
    as a replacement for PSPs, so maybe this is something you want to consider as
    well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的组织正在考虑使用 [OPA 约束框架](https://oreil.ly/9eC1B) 替代 PSP，因此这可能也是您要考虑的内容。
- en: 'The good news is that replacements for PSPs exist: upstream, they are replaced
    by [Pod Security Standards](https://oreil.ly/bvJzZ) (PSS) (the Aqua Security blog
    post [“Kubernetes Pod Security Policy Deprecation: All You Need to Know”](https://oreil.ly/ayg7a)
    goes into further detail here), and alternatively you can use frameworks discussed
    in [“Generic Policy Engines”](#generic-policy-engines) to cover runtime policies.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，PSP 的替代方案已经存在：在上游，它们被 [Pod 安全标准](https://oreil.ly/bvJzZ)（PSS）取代（Aqua Security
    的博客文章 ["Kubernetes Pod 安全策略淘汰：您需要了解的一切"](https://oreil.ly/ayg7a) 进一步详细介绍了这里），您也可以使用在
    [“通用策略引擎”](#generic-policy-engines) 中讨论的框架来覆盖运行时策略。
- en: Access Control Policies
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制策略
- en: Kubernetes is, concerning authentication and authorization, flexible and extensible.
    We discuss the details of access control policies in [“Authentication and Authorization”](#policy-authn-authz)
    and specifically role-based access control (RBAC) in [“Role-Based Access Control
    (RBAC)”](#rbac).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证和授权方面，Kubernetes 是灵活且可扩展的。我们将在 [“认证和授权”](#policy-authn-authz) 中讨论访问控制策略的详细信息，特别是基于角色的访问控制（RBAC）在
    [“基于角色的访问控制（RBAC）”](#rbac) 中讨论。
- en: Now, with the overview on built-in policies in Kubernetes out of the way, what
    does the threat modeling in the policies space look like? Let’s find out.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Kubernetes 内置策略的概述已经完成，那么策略空间中的威胁建模是什么样的呢？让我们来找出答案。
- en: Threat Model
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁模型
- en: 'The threat model relevant in the context of policies is broad, however sometimes
    they may subtly be hidden within other topics and/or not explicitly called out.
    Let’s have a look at some scenarios of past attacks pertinent to the policy space
    using examples from the 2016 to 2019 time frame:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略的背景下相关的威胁模型是广泛的，但有时它们可能会微妙地隐藏在其他主题中，或者没有明确地被提出。让我们来看看从2016年到2019年时间段的一些相关策略空间的过去攻击场景示例：
- en: '[CVE-2016-5392](https://oreil.ly/dPmHr) describes an attack where the API server
    (in a multitenant environment) allowed remote authenticated users with knowledge
    of other project names to obtain sensitive project and user information via vectors
    related to the watch-cache list.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CVE-2016-5392](https://oreil.ly/dPmHr)描述了一种攻击，其中API服务器（在多租户环境中）允许具有其他项目名称知识的远程经过身份验证的用户通过与观察-缓存列表相关的向量获取敏感项目和用户信息。'
- en: Certain versions of CoreOS Tectonic mount a direct proxy to the cluster at */api/kubernetes/*,
    accessible without authentication to and allowing an attacker to directly connect
    to the API server, as observed in [CVE-2018-5256](https://oreil.ly/FsmL2).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定版本的CoreOS Tectonic在*/api/kubernetes/*直接代理到集群，无需认证即可访问，并允许攻击者直接连接到API服务器，正如[CVE-2018-5256](https://oreil.ly/FsmL2)所观察到的。
- en: In [CVE-2019-3818](https://oreil.ly/9ZJHR), the `kube-rbac-proxy` container
    did not honor TLS configurations, allowing for use of insecure ciphers and TLS
    1.0\. An attacker could target traffic sent over a TLS connection with a weak
    configuration and potentially break the encryption.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[CVE-2019-3818](https://oreil.ly/9ZJHR)中，`kube-rbac-proxy`容器未尊重TLS配置，允许使用不安全的密码和TLS
    1.0。攻击者可以针对使用弱配置的TLS连接发送的流量，并可能破解加密。
- en: In [CVE-2019-11245](https://oreil.ly/N5RfD) we see how an attacker could exploit
    the fact that certain `kubelet` versions did not specify an explicit `runAsUser`
    attempt to run as UID 0 (root) on container restart, or if the image was previously
    pulled to the node.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[CVE-2019-11245](https://oreil.ly/N5RfD)中，我们看到攻击者可以利用某些`kubelet`版本未指定显式的`runAsUser`而尝试在容器重新启动时以UID
    0（root）身份运行，或者如果镜像先前已拉到节点上。
- en: As per [CVE-2019-11247](https://oreil.ly/DcLvA) the Kubernetes API server mistakenly
    allowed access to a cluster-scoped custom resource if the request was made as
    if the resource were namespaced. Authorizations for the resource accessed in this
    manner are enforced using roles and role bindings within the namespace, meaning
    that a user with access only to a resource in one namespace could create, view,
    update, or delete the cluster-scoped resource.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据[CVE-2019-11247](https://oreil.ly/DcLvA)，Kubernetes API服务器错误地允许对集群范围的自定义资源进行访问，如果请求伪装成在特定命名空间内的资源。以此方式访问的资源的授权是通过命名空间内的角色和角色绑定来强制执行的，这意味着只有对一个命名空间内的资源有访问权限的用户可以创建、查看、更新或删除集群范围的资源。
- en: In [CVE-2020-8554](https://oreil.ly/fxRTk) it’s possible for an attack to person-in-the-middle
    traffic, which in multitenant environments may intercept traffic to other tenants.
    The new [DenyServiceExternalIPs](https://oreil.ly/SDAHG) admission controller
    was added as there is currently no patch for this issue.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[CVE-2020-8554](https://oreil.ly/fxRTk)中，攻击者可能通过中间人攻击方式拦截流量，这在多租户环境中可能会截取到其他租户的流量。新的[DenyServiceExternalIPs](https://oreil.ly/SDAHG)入口控制器被添加，因为目前对此问题尚无修补程序。
- en: Common Expectations
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见期望
- en: In the following sections, we review some common expectations—that is, policy-related
    situations and methods that are well-established—and how they are addressed by
    defaults in Kubernetes and, in case there are no OOTB functions available, point
    to examples that work on top of Kubernetes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下各节中，我们审查一些常见期望—即与策略相关的情况和已确立的方法—以及它们如何在Kubernetes中的默认设置中解决，并在没有OOTB（Out Of
    The Box）功能可用的情况下，指出在Kubernetes之上运行的示例。
- en: Breakglass Scenario
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突破玻璃场景
- en: When we say breakglass scenario we routinely think of a process to bypass the
    default access control regime, in case of an emergency. The emergency could be
    an external event like a natural disaster or an attacker trying to mess with your
    cluster. If such a functionality is provided, the breakglass accounts offered
    are usually highly privileged (so to stop the bleeding) and oftentimes time-boxed.
    As breakglass access is granted, what happens in the background is that owners
    are notified and the account is recorded for auditing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说突破玻璃场景时，通常指的是一种绕过默认访问控制制度的过程，以应对紧急情况。紧急情况可能是外部事件，如自然灾害或攻击者试图干扰您的集群。如果提供了这样的功能，所提供的突破玻璃账户通常是高度特权的（以止血为目的），并且通常会设有时间限制。一旦授予了突破玻璃访问权限，在背景中会通知所有者并记录账户以供审计。
- en: While Kubernetes does not ship with breakglass features by default, there are
    examples, such as GKE’s binary authorization [breakglass capability](https://oreil.ly/ruud4),
    that show how this might work in practice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kubernetes默认不提供突破玻璃功能，但有些例子，如GKE的二进制授权[突破玻璃能力](https://oreil.ly/ruud4)，展示了这在实践中如何运作。
- en: Auditing
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计
- en: Kubernetes comes with [auditing](https://oreil.ly/PeOUe) built in. In the API
    server, each request generates an audit event, which is preprocessed according
    to a policy that states what is recorded and then written to a backend; currently
    logfiles and webhooks (sends events to an external HTTP API) are supported.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes自带[审计功能](https://oreil.ly/PeOUe)。在API服务器中，每个请求生成一个审计事件，根据策略预处理记录，并将其写入后端；目前支持日志文件和Webhook（将事件发送到外部HTTP
    API）。
- en: The configurable audit levels range from `None` (do not record event) to `RequestResponse`
    (record event metadata, request and response bodies).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可配置的审计级别从`None`（不记录事件）到`RequestResponse`（记录事件元数据、请求和响应主体）。
- en: 'An example policy to capture events on ConfigMaps may look as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获ConfigMaps事件的示例策略可能如下所示：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The [OOTB auditing features](https://oreil.ly/AxDwJ) of Kubernetes are a good
    starting point and many security and observability vendors offer, based on it,
    additional functionality, be it a more convenient interface or integrations with
    destinations, including but not limited to the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的[OOTB审计功能](https://oreil.ly/AxDwJ)是一个很好的起点，许多安全和可观测性供应商基于此提供额外的功能，无论是更方便的界面还是与目标的集成，包括但不限于以下内容：
- en: Sysdig [“Kubernetes Audit Logging”](https://oreil.ly/ZS5tm)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sysdig [“Kubernetes审计日志”](https://oreil.ly/ZS5tm)
- en: Datadog [“Kubernetes Audit Logs”](https://oreil.ly/4WTOv)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Datadog [“Kubernetes审计日志”](https://oreil.ly/4WTOv)
- en: 'Splunk/Outcold [“Monitoring Kubernetes: Metrics and Log Forwarding”](https://oreil.ly/GKvaW)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Splunk/Outcold [“监控Kubernetes：指标和日志转发”](https://oreil.ly/GKvaW)
- en: As a good practice, enable auditing and try to find the right balance between
    verbosity (audit level) and retention period.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个良好的实践，启用审计并尝试在详细度（审计级别）和保留期之间找到合适的平衡。
- en: Authentication and Authorization
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: If you consider a Kubernetes cluster, there are different types of resources,
    both in-cluster (such as a pod or a namespace) as well as out-of-cluster (for
    example, the load balancer of your cloud provider), that a service may provision.
    In this section we will dive into the topic of defining and checking the access
    a person or a program requires to access resources necessary to carry out a task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑一个Kubernetes集群，有不同类型的资源，包括集群内（如pod或命名空间）以及集群外（例如云提供商的负载均衡器），一个服务可能需要提供这些资源。在本节中，我们将深入讨论定义和检查访问所需资源的主题。
- en: In the context of access control, when we say authorization we mean the process
    of checking the permissions concerning a certain action, for example to create
    or delete a resource, for a given identity. This identity can represent a human
    user or a program, which we usually refer to as workload identity. Verifying the
    identity of a subject, human or machine, is called authentication.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问控制的背景下，当我们说授权时，我们指的是检查某个操作的权限，例如为给定身份（人类用户或程序，通常称为工作负载身份）创建或删除资源的过程。验证主体的身份，无论是人类用户还是机器，都称为认证。
- en: '[Figure 8-2](#fig-k8s-access-control-overview) shows, on a high level, how
    the access to resources works in a Kubernetes cluster, covering the authentication
    and authorization steps.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](#fig-k8s-access-control-overview) 在高层次上展示了在Kubernetes集群中访问资源的工作方式，涵盖了认证和授权步骤。'
- en: '![Kubernetes access control overview](Images/haku_0802.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes访问控制概述](Images/haku_0802.png)'
- en: 'Figure 8-2\. Kubernetes access control overview (source: [Kubernetes documentation](https://oreil.ly/lHeUm))'
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-2\. Kubernetes访问控制概述（来源：[Kubernetes文档](https://oreil.ly/lHeUm)）
- en: The first step in the API server is the authentication of the request via one
    or more of the configured authentication modules such as client certificates,
    passwords, or JSON Web Tokens (JWT). If an API server cannot authenticate the
    request, it rejects it with a 401 HTTP status. However, if the authentication
    succeeds, the API server moves on to the authorization step.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器中的第一步是通过配置的一个或多个认证模块（如客户端证书、密码或JSON Web Tokens（JWT））对请求进行认证。如果API服务器无法对请求进行身份验证，则以401
    HTTP状态拒绝该请求。但是，如果认证成功，则API服务器继续进行授权步骤。
- en: In this step the API server uses one of the configured authorization modules
    to determine if the access is allowed; it takes the credentials along with the
    requested path, resource (pod, service, etc.) and verb (create, get, etc.), and
    if at least one module grants access, the request is allowed. If the authorization
    fails, an 403 HTTP status code is returned. The most widely used authorization
    module nowadays is RBAC (see [“Role-Based Access Control (RBAC)”](#rbac)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中，API服务器使用配置的授权模块之一来确定是否允许访问；它将凭据与请求的路径、资源（pod、服务等）和动词（创建、获取等）一起使用，如果至少一个模块授予访问权限，则允许该请求。如果授权失败，则返回403
    HTTP状态码。目前最常用的授权模块是RBAC（参见[“基于角色的访问控制（RBAC）”](#rbac)）。
- en: In the following sections, we will first review the defaults Kubernetes has,
    show how those can be attacked, and subsequently discuss how to monitor and defend
    against attacks in the access control space.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将首先审查Kubernetes的默认设置，展示如何可能受到攻击，随后讨论如何在访问控制空间内监视和防御这些攻击。
- en: Human Users
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人类用户
- en: Kubernetes does not consider [human users](https://oreil.ly/Y8sP0) as first-class
    citizens, in contrast to machines (or applications), which are represented by
    so-called service accounts (see [“Service accounts”](#service-accounts)). In other
    words, there are no core Kubernetes resources representing human users in Kubernetes
    proper.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes不将[人类用户](https://oreil.ly/Y8sP0)视为一等公民，与机器（或应用程序）相反，后者由所谓的服务账号表示（参见[“服务账号”](#service-accounts)）。换句话说，在Kubernetes中没有核心资源代表人类用户。
- en: In practice, organizations oftentimes want to map Kubernetes cluster users to
    existing user directories such as LDAP servers like Azure Directory and ideally
    provide single sign-on (SSO).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，组织通常希望将Kubernetes集群用户映射到现有用户目录，如Azure Directory，并理想地提供单点登录（SSO）。
- en: 'As usual, there are the two options available: buy or build. If you’re using
    the Kubernetes distribution of your cloud provider, check the integrations there.
    If you’re looking into building out SSO yourself, there are a number of open source
    tools available that allow you to do this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，有两个选择可供选择：购买或自行构建。如果您使用云提供商的Kubernetes发行版，请检查集成情况。如果您打算自行构建SSO，有许多开源工具可供选择：
- en: OpenID Connect (OIDC)/OAuth 2.0–based solutions, such as available via [Dex](https://oreil.ly/BLDzz).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于OpenID Connect（OIDC）/OAuth 2.0的解决方案，例如通过[Dex](https://oreil.ly/BLDzz)提供的解决方案。
- en: Security Assertion Markup Language (SAML)–based solutions, such as offered by
    [Teleport](https://oreil.ly/jXtnG).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于安全声明标记语言（SAML）的解决方案，例如由[Teleport](https://oreil.ly/jXtnG)提供的解决方案。
- en: In addition, there are more complete open source offerings such as [Keycloak](https://oreil.ly/tC4ZP),
    supporting a range of use cases from SSO to policy enforcement.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有更完整的开源解决方案，如[Keycloak](https://oreil.ly/tC4ZP)，支持从SSO到策略执行的各种用例。
- en: While humans don’t have a native representation in Kubernetes, your workload
    does.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然人类在Kubernetes中没有本地表示，但您的工作负载确实有。
- en: Workload Identity
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作负载身份
- en: In contrast to human users, workloads such as a deployment owning pods are indeed
    first-class citizens in Kubernetes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与人类用户相比，拥有pod的部署等工作负载确实是Kubernetes中的一等公民。
- en: Service accounts
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务账号
- en: 'By default, a [service account](https://oreil.ly/FxOIu) represents the identity
    of an app in Kubernetes. A service account is a namespaced resource that can be
    used in the context of a pod to authenticate your app against the API server.
    Its canonical form is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，[服务账号](https://oreil.ly/FxOIu)代表Kubernetes中应用程序的身份。服务账号是一种命名空间资源，可在pod的上下文中用于将您的应用程序与API服务器进行身份验证。其规范形式如下：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As part of the control plane, [three controllers](https://oreil.ly/Rrn4a) jointly
    implement the service account automation, that is, managing Secrets and tokens:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 作为控制平面的一部分，[三个控制器](https://oreil.ly/Rrn4a)共同实现了服务账号的自动化管理，即管理机密和令牌：
- en: 'The ServiceAccount admission controller, part of the API server, acts on pod
    creation and update. The controller checks if service account used by the pod
    exists, and in case it does not, rejects the pod (or, if no service account is
    specified, uses the `default` service account). In addition, it manages a volume,
    making the service account available via a well-known location: */var/run/secrets/kubernetes.io/serviceaccount*.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccount准入控制器是API服务器的一部分，负责处理pod的创建和更新。控制器检查用于pod的服务账号是否存在，如果不存在，则拒绝该pod（或者，如果未指定服务账号，则使用`default`服务账号）。此外，它管理一个卷，使服务账号通过已知位置可用：*/var/run/secrets/kubernetes.io/serviceaccount*。
- en: The TokenController, part of the control plane component called controller manager,
    watches service accounts and creates or deletes the respective tokens. These are
    JSON Web Tokens (JWT) as defined in RFC 7519.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TokenController是控制平面组件控制器管理器的一部分，负责监视服务账户并创建或删除相应的令牌。这些令牌是RFC 7519中定义的JSON Web
    Tokens（JWT）。
- en: The ServiceAccount controller, also part of the controller manager, ensures
    that in every namespace a service account `default` exists.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccount控制器，也是控制器管理器的一部分，确保在每个命名空间中存在一个名为`default`的服务账户。
- en: 'For example, the `default` service account in the `kube-system` namespace would
    be referred to as `system:serviceaccount:kube-system:default` and would look something
    like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`kube-system`命名空间中的`default`服务账户将被称为`system:serviceaccount:kube-system:default`，并且看起来像以下内容：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_policy_CO1-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO1-1)'
- en: The `default` service account
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`服务账户'
- en: '[![2](Images/2.png)](#co_policy_CO1-2)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO1-2)'
- en: In the `kube-system` namespace
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kube-system`命名空间中
- en: '[![3](Images/3.png)](#co_policy_CO1-3)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_policy_CO1-3)'
- en: Using the Secret with the name `default-token-v9vsm`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为`default-token-v9vsm`的Secret
- en: 'We saw that the `default` service account uses a Secret called `default-token-v9vsm`,
    so let have a look at it with `kubectl -n kube-system get secret default-token-v9vsm
    -o yaml`, which yields the following YAML doc (edited to fit):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`kube-system`命名空间中的`default`服务账户使用了名为`default-token-v9vsm`的Secret，因此让我们用`kubectl
    -n kube-system get secret default-token-v9vsm -o yaml`查看它，得到以下编辑后的YAML文档：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Your application can use the data managed by the control plane components as
    described previously from within the pod. For example, from inside a container,
    the volume is available at:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可以使用控制平面组件从Pod内部访问的数据，正如前面描述的那样。例如，在容器内部，该卷在以下位置可用：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The JWT token that the TokenController created is readily available for you:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: TokenController创建的JWT令牌现已准备就绪供您使用：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Service accounts are regularly used as building blocks and can be combined with
    other mechanisms such as [projected volumes](https://oreil.ly/Tardt) (discussed
    in [Chapter 6](ch06.xhtml#ch-storage), and the `kubelet` for workload identity
    management.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount经常用作构建块，并可与其他机制（如[投影卷](https://oreil.ly/Tardt)（在[第6章](ch06.xhtml#ch-storage)中讨论）和`kubelet`用于工作负载身份管理）结合使用。
- en: For example, the EKS feature [IAM roles for service accounts](https://oreil.ly/XXPUv)
    demonstrates such a combination in action.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，EKS功能[IAM角色用于服务账户](https://oreil.ly/XXPUv)展示了这样一个组合的实际应用。
- en: While handy, the service account does not provide for a cryptographically strong
    workload identity out-of-the-box and hence may be not sufficient for certain use
    cases.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然方便，但ServiceAccount默认情况下不提供强大的工作负载身份标识，因此可能不足以满足某些用例的需求。
- en: Cryptographically strong identities
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码强的身份标识
- en: '[Secure Production Identity Framework for Everyone](https://spiffe.io) (SPIFFE)
    is a Cloud Native Computing Foundation (CNCF) project that establishes identities
    for your workloads. [SPIRE](https://oreil.ly/e5bRL) is a production-ready reference
    implementation of the SPIFFE APIs allowing performance of node and workload attestation;
    that is, you can automatically assign cryptographically strong identities to resources
    like pods.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[每个人的安全生产身份框架](https://spiffe.io)（SPIFFE）是一个云原生计算基金会（CNCF）项目，为您的工作负载建立身份。[SPIRE](https://oreil.ly/e5bRL)是SPIFFE
    API的生产就绪参考实现，允许进行节点和工作负载的认证；也就是说，您可以自动为像Pod这样的资源分配密码强的身份标识。'
- en: 'In SPIFFE, a workload is a program deployed using a specific configuration,
    defined in the context of a trust domain, such as a Kubernetes cluster. The identity
    of the workload is in the form of a so-called SPIFFE ID, which comes in the general
    schema shown as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在SPIFFE中，工作负载是使用特定配置部署的程序，在信任域的上下文中定义，例如Kubernetes集群。工作负载的身份以所谓的SPIFFE ID形式存在，其一般模式如下所示：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An SVID (short for SPIFFE Verifiable Identity Document) is the document, for
    example a X.509 certificate JWT token, a workload proves its identity toward a
    caller. The SVID is valid if it has been signed by an authority in the trust domain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: SVID（SPIFFE可验证身份文件的简称）是文档，例如X.509证书JWT令牌，用于工作负载向调用者证明其身份。如果SVID由信任域中的授权机构签名，则SVID有效。
- en: If you are not familiar with SPIFFE and want to read up on it, we recommend
    having a look at the [terminology section of the SPIFFE docs](https://oreil.ly/6pwBP).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对SPIFFE不熟悉，并想了解更多，我们建议查看[SPIFFE文档的术语部分](https://oreil.ly/6pwBP)。
- en: 'With this we’ve reached the end of the general authentication and authorization
    discussion and focus now on a central topic in Kubernetes security: role-based
    access control.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，我们已经完成了关于一般身份验证和授权的讨论，现在集中于Kubernetes安全中的一个核心主题：基于角色的访问控制。
- en: Role-Based Access Control (RBAC)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: Nowadays, the default mechanism for granting humans and workloads access to
    resources in Kubernetes is [role-based access control (RBAC)](https://oreil.ly/Z8wA3).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，在Kubernetes中授予人类和工作负载对资源的访问权限的默认机制是基于角色的访问控制（RBAC）。
- en: We will first review the defaults, then discuss how to understand RBAC using
    tools to analyze and visualize the relations, and finally we review attacks in
    this space.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将回顾默认设置，然后讨论如何使用工具来分析和可视化关系，最后我们将回顾这个领域中的攻击。
- en: RBAC Recap
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC总结
- en: 'In the context of RBAC we use the following terminology:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在RBAC的上下文中，我们使用以下术语：
- en: An *identity* is a human user or service account.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*身份*是指人类用户或服务账户。'
- en: A *resource* is something (like a namespace or deployment) we want to provide
    access to.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源*是我们想要提供访问权限的东西（如命名空间或部署）。'
- en: A *role* is used to define conditions for actions on resources.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*角色*用于定义对资源执行操作的条件。'
- en: A *role binding* attaches a role to an identity, effectively representing the
    permissions of a set of actions concerning specified resources.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*角色绑定*将角色附加到身份，有效地表示涉及指定资源的一组操作权限。'
- en: 'Allowed actions of an identity on a given resource are called verbs that come
    in two flavors: read-only ones (`get` and `list`) and read-write ones (`create`,
    `update`, `patch`, `delete`, and `deletecollection`). Further, the scope of a
    role can be cluster-wide or in the context of a Kubernetes namespace.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 赋予身份对指定资源的允许操作称为动词，有两种类型：只读动词（`get`和`list`）和读写动词（`create`、`update`、`patch`、`delete`和`deletecollection`）。此外，角色的作用范围可以是整个集群或Kubernetes命名空间的上下文。
- en: By default, Kubernetes comes with privilege escalation prevention. That is,
    users can create or update a role only if they already have all the permissions
    contained in the role.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes带有特权升级预防措施。也就是说，只有当用户已经拥有角色中包含的所有权限时，才能创建或更新角色。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are two types of roles in Kubernetes: roles and cluster roles. The difference
    is the scope: the former is only relevant and valid in the context of a namespace,
    whereas the latter works cluster-wide. The same is true for the respective bindings.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中有两种角色类型：角色和集群角色。它们的区别在于作用范围：前者仅在命名空间的上下文中相关和有效，而后者在整个集群范围内有效。相应的绑定也是如此。
- en: Last but not least, Kubernetes defines a number of [default roles](https://oreil.ly/Ned1s)
    you might want to review before defining your own roles (or use them as starting
    points).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，在定义自己的角色之前，Kubernetes定义了一些[默认角色](https://oreil.ly/Ned1s)可能需要您进行审查（或者以它们作为起点）。
- en: 'For example, there’s a default cluster role called `edit` predefined (note
    that the output has been cut down to fit):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个名为`edit`的默认集群角色预定义（注意输出已经被缩减以适应）。
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A Simple RBAC Example
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的RBAC示例
- en: 'In this section, we have a look at a simple RBAC example: assume you want to
    give a developer `joey` the permission to view resources of type deployments in
    the `yolo` namespace.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简单介绍一个RBAC示例：假设您希望授予开发者`joey`在`yolo`命名空间中查看部署类型资源的权限。
- en: 'Let’s first create a cluster role called `view-deploys` that defines the actions
    allowed for the targeted resources with the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`view-deploys`的集群角色，定义了对目标资源允许的操作，使用以下命令：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command creates a resource with a YAML representation as shown
    in the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建的资源具有以下的YAML表示：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_policy_CO2-1)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO2-1)'
- en: The targeted resources of this cluster role
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集群角色的目标资源
- en: '[![2](Images/2.png)](#co_policy_CO2-2)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO2-2)'
- en: The allowed actions when this cluster role is bound
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定此集群角色时允许的操作
- en: 'Next, we equip the targeted principal with the cluster role we created in the
    previous step. This is achieved by the following command that binds the `view-deploys`
    cluster role to the user `joey`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为之前步骤中创建的目标主体分配目标集群角色。这通过以下命令实现，将`view-deploys`集群角色绑定到用户`joey`：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you execute this command you create a resource with a YAML representation
    like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此命令时，将创建一个具有以下YAML表示的资源：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](Images/1.png)](#co_policy_CO3-1)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO3-1)'
- en: The scope of the role binding
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 角色绑定的范围
- en: '[![2](Images/2.png)](#co_policy_CO3-2)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO3-2)'
- en: The cluster role we want to use (bind)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用的集群角色（bind）
- en: '[![3](Images/3.png)](#co_policy_CO3-3)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_policy_CO3-3)'
- en: The targeted principal (subject) to bind the cluster role to
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将集群角色绑定到的目标主体（主体）
- en: Now, looking at a bunch of YAML code to determine what the permissions are is
    usually not the way you want to go. Given its graph nature, usually you want some
    visual representation, something akin to what is depicted in [Figure 8-3](#fig-rbac-example-graph).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通常不建议直接查看大量的YAML代码以确定权限。鉴于其图形化特性，通常希望有一些视觉表示，类似于[图8-3](#fig-rbac-example-graph)中所示的内容。
- en: For this case it looks pretty straightforward, but alas the reality is much
    more complicated and messy. Expect to deal with hundreds of roles, bindings, and
    subjects and actions across core Kubernetes resources as well as custom resource
    definitions (CRDs).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况看起来相当简单，但实际情况要复杂得多而混乱。预计将涉及核心Kubernetes资源以及自定义资源定义（CRD）中数百个角色、绑定、主体和操作。
- en: 'So, how can you figure out what’s going on, how can you truly understand the
    RBAC setup in your cluster? As usual, the answer is: additional software.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何找出发生了什么，如何真正理解您集群中的RBAC设置呢？通常的答案是：使用额外的软件。
- en: '![Example RBAC graph showing what developer `joey` is allowed to do](Images/haku_0803.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![示例RBAC图表显示了开发者`joey`被允许执行的操作](Images/haku_0803.png)'
- en: Figure 8-3\. Example RBAC graph showing what developer `joey` is allowed to
    do
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-3\. 示例RBAC图表显示了开发者`joey`被允许执行的操作。
- en: Authoring RBAC
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 撰写RBAC
- en: 'According to the least privileges principle, you should only grant exactly
    the permissions necessary to carry out a specific task. But how do you arrive
    at the exact permissions? Too few means the task will fail, but too much power
    can yield a field day for attackers. A good way to go about this is to automate
    it: let’s have a look at a small but powerful tool called `audit2rbac` that can
    generate Kubernetes RBAC roles and role bindings covering API requests made by
    a user.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据最小权限原则，您应该仅授予执行特定任务所需的确切权限。但是如何确定确切的权限？权限太少会导致任务失败，但权限过多可能会为攻击者带来大好时机。解决这个问题的一个好方法是自动化：让我们来看看一个称为`audit2rbac`的小而强大的工具，它可以生成涵盖用户发出的API请求的Kubernetes
    RBAC角色和角色绑定。
- en: As a concrete example we’ll use an EKS cluster running in AWS. First, install
    [awslogs](https://oreil.ly/nWB5K) and also [audit2rbac](https://oreil.ly/hU8mO)
    for your platform.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，我们将使用在AWS上运行的EKS集群。首先，在您的平台上安装[awslogs](https://oreil.ly/nWB5K)，同时也要安装[audit2rbac](https://oreil.ly/hU8mO)。
- en: For the following you need two terminal sessions as we use the first command
    (`awslogs`) in a blocking mode.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下操作，您需要两个终端会话，因为我们在阻塞模式下使用第一个命令（`awslogs`）。
- en: 'First, in one terminal session, create the audit log by tailing the CloudWatch
    output as follows (note, you can also directly pipe into `audit2rbac`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在一个终端会话中，通过尾随CloudWatch输出创建审计日志，如下所示（请注意，您也可以直接管道传输到`audit2rbac`）：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While the `awslogs` snippet shown here uses an AWS-specific method to grab the
    logs, the principle stays the same. For example, to [view GKE logs](https://oreil.ly/j2sB0)
    you could use `gcloud logging read` and [AKS offers a similar way to access logs.](https://oreil.ly/ikRda)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此处显示的`awslogs`片段使用了AWS特定的方法来获取日志，但原理仍然相同。例如，要[查看GKE日志](https://oreil.ly/j2sB0)，您可以使用`gcloud
    logging read`，而[AKS提供了类似的访问日志的方法。](https://oreil.ly/ikRda)
- en: Now, in another terminal session, execute the `kubectl` command with the user
    you want to create the RBAC setting for. In the case shown we’re already logged
    in as said user, otherwise you can impersonate them with `--as`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个终端会话中，使用要为其创建RBAC设置的用户执行`kubectl`命令。在所示的情况下，我们已经作为该用户登录，否则您可以使用`--as`来冒充他们。
- en: 'Let’s say you want to generate the necessary role and binding for listing all
    the default resources (such as pods, services, etc.) across all namespaces. You
    would use the following command (note that the output is not shown):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要为列出所有默认资源（例如pods、services等）跨所有命名空间生成必要的角色和绑定。您将使用以下命令（请注意，此处未显示输出）：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point we should have the audit log in *audit-log.json* and can use
    it as an input for `audit2rbac` as shown in the following. Let’s consume the audit
    log and create RBAC roles and bindings for a specific user:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该已经有了*audit-log.json*中的审计日志，并且可以将其作为`audit2rbac`的输入，如下所示。让我们消费审计日志，并为特定用户创建RBAC角色和绑定：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_policy_CO4-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO4-1)'
- en: Specify target user for the role binding.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 指定角色绑定的目标用户。
- en: '[![2](Images/2.png)](#co_policy_CO4-2)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO4-2)'
- en: Specify the logs to use as an input.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要用作输入的日志。
- en: 'After running the preceding command, the resulting RBAC resources, comprising
    a cluster role and a cluster role binding that permit the user `kubernetes-admin`
    to successfully execute `kubectl get all -A`, is now available in *list-all.yaml*
    (note that the output has been trimmed):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令后，生成的RBAC资源包括一个允许用户`kubernetes-admin`成功执行`kubectl get all -A`的集群角色和集群角色绑定，现在可以在*list-all.yaml*中找到（注意输出已经被截断）：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_policy_CO5-1)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO5-1)'
- en: The generated cluster role allowing you to list the default resources across
    all namespaces
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的集群角色允许您列出所有命名空间中的默认资源
- en: '[![2](Images/2.png)](#co_policy_CO5-2)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO5-2)'
- en: The binding, giving the user `kubernetes-admin` the permissions
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户`kubernetes-admin`授权绑定权限
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: There’s also a `krew` plug-in called [who-can](https://oreil.ly/9TsqY) allowing
    you to gather the same information, quickly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为[who-can](https://oreil.ly/9TsqY)的`krew`插件，允许您快速收集相同的信息。
- en: That was some (automagic) entertainment, was it not? Automating the creation
    of the roles helps you in enforcing least privileges as otherwise the temptation
    to simply “give access to everything to make it work” is indeed a big one, playing
    into the hands of the Captain and their greedy crew.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是一些（自动化）娱乐，不是吗？自动化角色创建帮助您执行最小权限原则，否则“简单地赋予访问所有内容以使其工作”的诱惑确实很大，正符合船长及其贪婪的船员们的要求。
- en: 'Next up: how to read and understand RBAC in a scalable manner.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来：如何以可伸缩的方式阅读和理解RBAC。
- en: Analyzing and Visualizing RBAC
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析和可视化RBAC
- en: Given their nature, with RBAC you end up with a huge forest of directed acyclic
    graph (DAGs), including the subjects, roles, their bindings, and actions. Trying
    to manually comprehend the connections is almost impossible, so you want to either
    visualize the graphs and/or use tooling to query for specific paths.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的本质，使用RBAC会导致一个包含主体、角色、它们的绑定和操作的庞大有向无环图（DAGs）。试图手动理解这些连接几乎是不可能的，因此您希望能够可视化这些图表和/或使用工具来查询特定路径。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: To address the challenge of discovering RBAC tooling and good practices, we
    maintain [rbac.dev](https://rbac.dev), open to suggestions for additions via issues
    and pull requests.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决发现RBAC工具和良好实践的挑战，我们维护[rbac.dev](https://rbac.dev)，欢迎通过问题和拉取请求提出建议。
- en: For example, let’s assume you would like to perform a static analysis on your
    RBAC setup. You could consider using [krane](https://oreil.ly/M9aUx), a tool that
    identifies potential security risks and also makes suggestions on how to mitigate
    those.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想对您的RBAC设置进行静态分析。您可以考虑使用[krane](https://oreil.ly/M9aUx)，这是一个可以识别潜在安全风险并提出如何减轻风险的工具。
- en: To demonstrate RBAC visualization in action, let’s walk through two examples.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示RBAC可视化的实际应用，让我们通过两个示例进行说明。
- en: 'The first example to visualize RBAC is a [krew plug-in](https://oreil.ly/CG1q7)
    called `rbac-view` ([Figure 8-4](#fig-screen-shot-rbac-view)) that you can run
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于可视化RBAC的例子是一个[krew插件](https://oreil.ly/CG1q7)，称为`rbac-view`（[图8-4](#fig-screen-shot-rbac-view)），您可以按以下步骤运行：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![Screen shot of the `rbac-view` web interface in action](Images/haku_0804.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![`rbac-view` Web界面的截图](Images/haku_0804.png)'
- en: Figure 8-4\. Screenshot of the `rbac-view` web interface in action
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-4\. `rbac-view` Web界面的截图
- en: Then you open the link provided, here `http://localhost:8800`, in a browser
    and can interactively view and query roles.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器中打开提供的链接，这里是`http://localhost:8800`，可以交互式地查看和查询角色。
- en: 'The second example is a CLI tool called [rback](https://oreil.ly/sVFlg), invented
    and codeveloped by one of the authors. `rback` queries RBAC-related information
    and generates a graph representation of service accounts, (cluster) roles, and
    the access rules in `dot` format:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是一个名为[rback](https://oreil.ly/sVFlg)的CLI工具，由其中一位作者发明和共同开发。`rback`查询与RBAC相关的信息，并以`dot`格式生成服务账户（集群）角色和访问规则的图表表示：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_policy_CO6-1)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO6-1)'
- en: List the resources to include in the graph.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列出要包含在图表中的资源。
- en: '[![2](Images/2.png)](#co_policy_CO6-2)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO6-2)'
- en: 'Set the scope (in our case: cluster-wide).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 设置范围（在我们的情况下是：整个集群）。
- en: '[![3](Images/3.png)](#co_policy_CO6-3)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_policy_CO6-3)'
- en: Feed the resulting JSON into `rback` via `stdin`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`stdin`将生成的JSON输入到`rback`中。
- en: '[![4](Images/4.png)](#co_policy_CO6-4)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_policy_CO6-4)'
- en: Feed the `rback` output in `dot` format to the `dot` program to generate the
    image `rback-output.png`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `rback` 输出以 `dot` 格式提供给 `dot` 程序，生成图片 `rback-output.png`。
- en: If you do have [dot](https://oreil.ly/suqyg) installed you would find the output
    in the file called *rback-output.png*, which would look something like shown in
    [Figure 8-5](#fig-rback-output).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了 [dot](https://oreil.ly/suqyg)，你会在名为 *rback-output.png* 的文件中找到输出，它看起来类似于[图
    8-5](#fig-rback-output)。
- en: '![Output of running `rback` against an EKS cluster](Images/haku_0805.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![运行 `rback` 对 EKS 集群的输出](Images/haku_0805.png)'
- en: Figure 8-5\. Output of running `rback` against an EKS cluster
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-5\. 运行 `rback` 对 EKS 集群的输出
- en: RBAC-Related Attacks
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 RBAC 有关的攻击
- en: 'There are not that many RBAC-related attacks found in the wild, indicated by
    CVEs. The basic patterns include:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外发现的与 RBAC 相关的攻击并不多，这可以通过 CVE 表明。基本模式包括：
- en: Too-loose permissions. Oftentimes, due to time constraints or not being aware
    of the issue, more permissions than actually needed to carry out a task are granted.
    For example, you want to state people are allowed to manage deployments and really
    all they need is to list and describe them, but you also give edit rights to them.
    This is violating the least privileges principle and a skilled attacker can misuse
    this setting.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限过于宽松。通常由于时间限制或不了解问题，会授予比实际需要更多的权限来执行任务。例如，你希望人们被允许管理部署，而实际上他们只需要列出和描述它们，但你也给了他们编辑权限。这违反了最小权限原则，一个熟练的攻击者可以利用这种设置。
- en: 'Demarcation line blurry. The shared responsibilities model in the context of
    running containers in a cloud environment might not always be super clear. For
    example, while it’s usually clear who is responsible for patching the worker nodes,
    it’s not always explicit who maintains application packages and their dependencies.
    Too liberal RBAC settings suggested as defaults can, if not properly reviewed,
    lead to an attack vector both subtle—as in: “ah, I thought *you* are taking care
    of it”—and potentially with an unwelcome outcome when the T&C of the service have
    not been carefully perused.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边界线模糊。在云环境中运行容器的背景下，共享责任模型可能并不总是非常清晰。例如，虽然通常清楚谁负责修补工作节点，但不总是明确谁维护应用程序包及其依赖项。如果默认建议过于宽松的
    RBAC 设置未经适当审核，可能会成为一个潜在的攻击向量，如：“啊，我以为*你*负责这个”，以及当服务的条款和条件没有被仔细审查时可能带来不受欢迎的结果。
- en: Prior to Helm 3, there was an overly privileged component present that caused
    all sorts of [security concerns](https://oreil.ly/d6uXV), especially [confused
    deputy](https://oreil.ly/RKeUC) situations. While this is less and less of an
    issue, you might want to double check if there’s still some Helm 2 used in your
    clusters.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Helm 3 之前，存在一个过于特权的组件，引发了各种[安全问题](https://oreil.ly/d6uXV)，特别是[混淆的副手](https://oreil.ly/RKeUC)情况。虽然这已经越来越不是问题，但你可能需要仔细检查一下你的集群中是否仍在使用一些
    Helm 2。
- en: With the RBAC fun wrapped up, let’s now move on to the topic of generic policy
    handling and engines for said purpose. The basic idea being that, rather than
    hardcode certain policy types, making them part of Kubernetes proper, one has
    a generic way to define policies and enforce it using one of the many [Kubernetes
    extension](https://oreil.ly/MvJMK) mechanisms.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RBAC 结束后，让我们现在转向通用策略处理和引擎的话题。基本思想是，与其硬编码某些策略类型，使其成为 Kubernetes 的一部分，不如用一种通用的方式来定义策略，并使用其中的一个[Kubernetes扩展](https://oreil.ly/MvJMK)机制来强制执行。
- en: Generic Policy Engines
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用策略引擎
- en: Let’s discuss generic policy engines that can be used in the context of Kubernetes
    to define and enforce any kind of policy, from organizational to regulatory ones.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下通用策略引擎，在 Kubernetes 的背景下可以用来定义和执行任何类型的策略，从组织到法规方面的。
- en: Open Policy Agent
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放策略代理
- en: '[Open Policy Agent](https://oreil.ly/xqarT) (OPA) is a graduated CNCF project
    that provides a general-purpose policy engine that unifies policy enforcement.
    The policies in OPA are represented in a high-level declarative language called
    Rego. It lets you specify policy as code and simple APIs to externalize policy
    decision-making, that is, moving it out of your own software. As you can see in
    [Figure 8-6](#fig-opa-concept), OPA decouples policy decision-making from policy
    enforcement.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[开放策略代理](https://oreil.ly/xqarT)（OPA）是一个毕业于 CNCF 的项目，提供了一个通用的策略引擎，统一了策略执行。OPA
    中的策略用一种高级声明性语言 Rego 表示。它允许你将策略作为代码来指定，并提供简单的 API 来外部化策略决策，即将其移出你自己的软件。正如你在[图 8-6](#fig-opa-concept)中看到的，OPA
    将策略决策与策略执行解耦。'
- en: When you need to make a policy decision somewhere in your code (`service`),
    you’d use the OPA API to query the policy in question. As an input the OPA server
    takes the current request data (in JSON format) as well as a policy (in Rego format)
    as input and computes an answer such as “access allowed” or “here is a list of
    relevant locations.” Note that the answer is not a binary one and entirely depends
    on the rules and data provided, computed in a deterministic manner.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在代码中（`service`）做出策略决策时，你会使用OPA API来查询相关策略。作为输入，OPA服务器接受当前请求数据（以JSON格式）以及策略（以Rego格式），并计算诸如“允许访问”或“这是相关位置列表”的答案。请注意，答案不是二元的，完全取决于规则和提供的数据，以确定性的方式计算。
- en: Let’s look at a concrete [example](https://oreil.ly/TP45q) (one of the examples
    from the Rego online playground). Imagine you want to make sure that every resource
    has a `costcenter` label that starts with `cccode-`, and if that’s not the case
    the user receives a message that this is missing and cannot proceed (for example,
    cannot deploy an app).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的[示例](https://oreil.ly/TP45q)（来自Rego在线播放器的示例之一）。假设你希望确保每个资源都有一个以`cccode-`开头的`costcenter`标签，如果不是这种情况，则用户会收到一条消息，说明缺少此内容，因此无法继续（例如，无法部署应用程序）。
- en: '![OPA concept](Images/haku_0806.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![OPA概念](Images/haku_0806.png)'
- en: Figure 8-6\. OPA concept
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-6\. OPA概念
- en: 'In Rego, the rule would look something like the following (we will get back
    to this example in [“Gatekeeper”](#opa-gatekeeper) in greater detail):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rego中，规则会像以下示例一样（我们将在[“门卫”](#opa-gatekeeper)中详细介绍此示例）：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#co_policy_CO7-1)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO7-1)'
- en: Is the `costcenter` label present?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`costcenter`标签是否存在？'
- en: '[![2](Images/2.png)](#co_policy_CO7-2)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO7-2)'
- en: Does the `costcenter` label start with a certain prefix?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`costcenter`标签是否以某个特定前缀开头？'
- en: Now, let’s assume someone does a `kubectl apply` that causes a pod to be created
    that does not have a label.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设有人执行了`kubectl apply`导致创建一个没有标签的Pod。
- en: Note
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The way OPA rather literally hooks into the API server is achieved via one of
    the many Kubernetes extension mechanisms. In this case it uses the [Dynamic Admission
    Control](https://oreil.ly/k5274); to be more precise, it registers a webhook that
    the API server calls before the respective resource is persisted in `etcd`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: OPA与API服务器连接的方式相当直接，通过Kubernetes的许多扩展机制之一实现。在这种情况下，它使用[动态准入控制](https://oreil.ly/k5274)，更准确地说，它注册了一个Webhook，API服务器在将相应资源持久化到`etcd`之前调用它。
- en: In other words, the `AdmissionReview` resource shown in the example is what
    the API server sends to the OPA server, registered as a webhook.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，示例中显示的`AdmissionReview`资源是API服务器发送到已注册为Webhook的OPA服务器的内容。
- en: 'As a result of the `kubectl` command the API server generates an `AdmissionReview`
    resource, in the following shown as a JSON document:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`kubectl`命令的结果，API服务器生成一个`AdmissionReview`资源，如下所示为JSON文档：
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With the preceding input, the OPA engine would compute the following output,
    which in turn would be, for example, fed back by the API server to `kubectl` and
    shown to the user on the command line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述输入，OPA引擎将计算以下输出，然后API服务器会将其反馈给`kubectl`并显示在命令行上的用户，例如：
- en: '[PRE23]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, how to rectify the situation and make it work? Simply add a label:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何纠正这种情况并使其正常工作？只需添加一个标签：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This should go without saying, but it is always a good idea to [test your policies](https://oreil.ly/FUmBU)
    before you deploy them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不言而喻的，但在部署策略之前，始终测试您的策略[是一个好主意](https://oreil.ly/FUmBU)。
- en: Rego is a little different than what you might be used to and the best analogue
    we could come up with is XSLT. If you do decide to adopt Rego, consider internalizing
    some [tips](https://oreil.ly/0hmL6).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Rego与您可能熟悉的东西有些不同，我们能想到的最好类比可能是XSLT。如果您决定采用Rego，请考虑内部化一些[提示](https://oreil.ly/0hmL6)。
- en: Using OPA directly
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接使用OPA
- en: To use OPA on the command line directly or in the context of an editor is fairly
    straightforward.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在命令行上或编辑器环境中使用OPA相当简单。
- en: First, let’s see how to evaluate a given input and a policy. You start, as usual,
    with [installing OPA](https://oreil.ly/qpIvc). Given that it’s written in Go,
    this means a single, self-contained binary.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看如何评估给定的输入和策略。您可以像通常一样开始[安装OPA](https://oreil.ly/qpIvc)。由于它是用Go编写的，这意味着它是一个单独的自包含二进制文件。
- en: 'Next, let’s say we want to use the `costcenter` example and evaluate it on
    the command line, assuming you have stored the `AdmissionReview` resource in a
    file called *input.json* and the Rego rules in *cc-policy.rego*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设我们要使用 `costcenter` 示例，并在命令行上评估它，假设你已将 `AdmissionReview` 资源存储在名为 *input.json*
    的文件中，而 Rego 规则存储在 *cc-policy.rego* 中：
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](Images/1.png)](#co_policy_CO8-1)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO8-1)'
- en: Specify the input OPA should use (an `AdmissionReview` resource).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 指定 OPA 应使用的输入（一个 `AdmissionReview` 资源）。
- en: '[![2](Images/2.png)](#co_policy_CO8-2)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO8-2)'
- en: Specify what rules to use (in Rego format).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要使用的规则（以 Rego 格式）。
- en: '[![3](Images/3.png)](#co_policy_CO8-3)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_policy_CO8-3)'
- en: Set the evaluation context.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 设置评估上下文。
- en: '[![4](Images/4.png)](#co_policy_CO8-4)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_policy_CO8-4)'
- en: Specify output.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 指定输出。
- en: 'That was easy enough! But we can go a step further: how about using OPA/Rego
    in an editor, for developing new policies?'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够简单了！但我们可以更进一步：尝试在编辑器中使用 OPA/Rego 开发新的策略如何？
- en: Interestingly enough, a [range of IDEs and editors](https://oreil.ly/ezA46),
    from VSCode to `vim`, are supported (see [Figure 8-7](#fig-opa-vim)).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，从 VSCode 到 `vim`，支持[一系列 IDE 和编辑器](https://oreil.ly/ezA46)（见[图 8-7](#fig-opa-vim)）。
- en: '![Screen shot of the Rego plug-in for `vim`](Images/haku_0807.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![vim 中的 Rego 插件截图](Images/haku_0807.png)'
- en: Figure 8-7\. Screenshot of the Rego plug-in for `vim`
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-7\. `vim` 中的 Rego 插件截图
- en: In the context of managing OPA policies across a fleet of clusters, you may
    want to consider evaluating Styra’s [Declarative Authorization Service (DAS) offering](https://www.styra.com),
    an enterprise OPA solution coming with some useful features such as centralized
    policy management and logging, as well as impact analysis.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理一组集群中的 OPA 策略时，你可能需要考虑评估 Styra 的[声明授权服务（DAS）产品](https://www.styra.com)，这是一个企业级
    OPA 解决方案，带有一些实用的功能，如集中策略管理、日志记录和影响分析。
- en: Tip
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: You can type-check Rego policies in OPA with JSON schema. This adds another
    layer of validation and can help policy developers to catch bugs. Learn more about
    this topic via [“Type Checking Your Rego Policies with JSON Schema in OPA”](https://oreil.ly/LpPfj).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 OPA 中使用 JSON Schema 对 Rego 策略进行类型检查。这增加了另一层验证，有助于策略开发者捕获错误。更多关于此主题的信息，请参考“《使用
    JSON Schema 在 OPA 中对你的 Rego 策略进行类型检查》”（https://oreil.ly/LpPfj）。
- en: Do you have to use Rego directly, though? No you do not have to, really. Let’s
    discuss alternatives in the context of Kubernetes, next.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，你是否真的必须直接使用 Rego 呢？实际上并不必须。接下来让我们在 Kubernetes 的背景下讨论替代方案。
- en: Gatekeeper
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gatekeeper
- en: Given that Rego is a DSL and has a learning curve, folks oftentimes wonder if
    they should use it directly or if there are more Kubernetes-native ways to use
    OPA. In fact the [Gatekeeper project](https://oreil.ly/VvSgk) allows exactly for
    this.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于 Rego 是一种 DSL 并具有学习曲线，人们经常会疑惑是否应该直接使用它，还是是否有更符合 Kubernetes 本地化的方法来使用 OPA。事实上，[Gatekeeper
    项目](https://oreil.ly/VvSgk) 正是允许这样做的。
- en: Tip
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: If you’re unsure if you should be using Gatekeeper over OPA directly, there
    are plenty of nice articles available that discuss the topic in greater detail;
    for example, [“Differences Between OPA and Gatekeeper for Kubernetes Admission
    Control”](https://oreil.ly/tBNvD) and [“Integrating Open Policy Agent (OPA) With
    Kubernetes”](https://oreil.ly/AJJhy).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定是应该直接使用 Gatekeeper 还是 OPA，有很多好文章可以详细讨论这个话题；例如，“《OPA 和 Gatekeeper 在 Kubernetes
    准入控制上的区别》”（https://oreil.ly/tBNvD）和“《将 Open Policy Agent（OPA）与 Kubernetes 集成》”（https://oreil.ly/AJJhy）。
- en: 'What Gatekeeper does is essentially introduce a separation of concerns: so-called
    templates represent the policies (encoding Rego) and as an end user you would
    interface with CRDs that use said templates. An admission controller configured
    in the API server takes care of the enforcement of the policies, then.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Gatekeeper 的作用实质上是引入了关注点分离：所谓的模板代表了策略（编码为 Rego），作为最终用户，你将与使用这些模板的 CRD 接口交互。API
    服务器中配置的准入控制器负责执行这些策略。
- en: Let’s have a look at how the previous example concerning `costcenter` labels
    being required could look with Gatekeeper. We assume that you have [installed
    Gatekeeper already](https://oreil.ly/6fGJp).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看之前关于需要 `costcenter` 标签的示例如何使用 Gatekeeper。我们假设你已经[安装了 Gatekeeper](https://oreil.ly/6fGJp)。
- en: 'First, you define the template, defining a new CRD called `K8sCostcenterLabels`
    in a file called *costcenter_template.yaml*:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 *costcenter_template.yaml* 文件中定义模板，定义一个名为 `K8sCostcenterLabels` 的新 CRD：
- en: '[PRE26]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](Images/1.png)](#co_policy_CO9-1)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO9-1)'
- en: This defines the schema for the `parameters` field.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了 `parameters` 字段的模式。
- en: '[![2](Images/2.png)](#co_policy_CO9-2)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO9-2)'
- en: This definition checks if the `costcenter` label is provided or not. Note that
    each rule contributes individually to the resulting (error) messages.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此定义检查是否提供了 `costcenter` 标签。请注意，每个规则都会单独对最终（错误）消息做出贡献。
- en: '[![3](Images/3.png)](#co_policy_CO9-3)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_policy_CO9-3)'
- en: The `not` keyword in this rule turns an undefined statement into a truthy statement.
    That is, if any of the keys are missing, this statement is true.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则中的 `not` 关键字将一个未定义的语句转换为真值语句。也就是说，如果任何键缺失，则该语句为真。
- en: '[![4](Images/4.png)](#co_policy_CO9-4)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_policy_CO9-4)'
- en: In this rule we check if the `costcenter` label is formatted appropriately.
    In other words, we require that it *must* start with `cccode-`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规则中，我们检查 `costcenter` 标签是否格式正确。换句话说，我们要求它*必须*以 `cccode-` 开头。
- en: 'When you have the CRD defined, you then can install it as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义了 CRD 后，可以按如下方式安装它：
- en: '[PRE27]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To use the `costcenter` template CRD, you have to define a concrete instance
    (a custom resource, or CR for short), so put the following in a file called *req_cc.yaml*:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `costcenter` 模板 CRD，你必须定义一个具体的实例（简称 CR），所以将以下内容放入一个名为 *req_cc.yaml* 的文件中：
- en: '[PRE28]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Which you then create using the following command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下命令创建它：
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After this command, the Gatekeeper controller knows about the policy and enforces
    it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，Gatekeeper 控制器就会知道该策略并执行它。
- en: To check if the preceding policy works, you can create a namespace that doesn’t
    have a label and if you then tried to create the namespace, for example using
    `kubectl apply`, you would see an error message containing “Every resource must
    have a costcenter label” along with the resource creation denial.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查前述策略是否有效，可以创建一个不带标签的命名空间，然后尝试创建该命名空间，例如使用 `kubectl apply`，你会看到一个包含“每个资源必须有成本中心标签”的错误消息以及资源创建被拒绝。
- en: 'With this you have a basic idea of how Gatekeeper works. Now let’s move on
    to an alternative way to effectively achieve the same: the CNCF Kyverno project.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个你可以初步了解 Gatekeeper 的工作原理。现在让我们转向另一种有效实现相同目标的方法：CNCF Kyverno 项目。
- en: Kyverno
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kyverno
- en: 'Another way to go about managing and enforcing policies is a CNCF project by
    the name of [Kyverno](https://kyverno.io). This project, initiated by Nirmata,
    is conceptually similar to Gatekeeper. Kyverno works as shown in [Figure 8-8](#fig-kyverno-concept):
    it runs as a dynamic admission controller, supporting both validating and mutating
    admission webhooks.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种管理和强制执行策略的方式是一个名为[Kyverno](https://kyverno.io)的 CNCF 项目。这个项目由 Nirmata 发起，概念上类似于
    Gatekeeper。Kyverno 的工作方式如[图 8-8](#fig-kyverno-concept)所示：它作为动态准入控制器运行，支持验证和变异准入
    Webhook。
- en: '![Kyverno concept](Images/haku_0808.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![Kyverno 概念](Images/haku_0808.png)'
- en: Figure 8-8\. Kyverno concept
  id: totrans-297
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-8\. Kyverno 概念
- en: 'So, what’s the difference between using Gatekeeper or plain OPA, then? Well,
    rather than directly or indirectly using Rego, with Kyverno you can do the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用 Gatekeeper 或纯 OPA 有什么区别呢？与其直接或间接使用 Rego，使用 Kyverno，你可以做以下操作：
- en: '[PRE30]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](Images/1.png)](#co_policy_CO10-1)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_policy_CO10-1)'
- en: Defines what resources to target, in this case namespaces.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了要定位的资源，本例中是命名空间。
- en: '[![2](Images/2.png)](#co_policy_CO10-2)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_policy_CO10-2)'
- en: Defines the expected pattern; in case this is not achieved, the preceding error
    message is returned via webhook to client.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了预期的模式；如果未达到预期，则通过 Webhook 将前述错误消息返回给客户端。
- en: Does the preceding YAML look familiar? This is our costcenter-labels-are-required
    example from earlier on.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 前述 YAML 看起来熟悉吗？这是我们之前介绍的需要 costcenter 标签的示例。
- en: Learn more about getting started from Gaurav Agarwal’s article [“Policy as Code
    on Kubernetes with Kyverno”](https://oreil.ly/KxQGc) and watch [“Introduction
    to Kyverno”](https://oreil.ly/H8kMm) from David McKay’s excellent Rawkode Live
    series on YouTube.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于如何从 Gaurav Agarwal 的文章[《Kubernetes 上的策略即代码》](https://oreil.ly/KxQGc)开始，以及观看
    David McKay 在 YouTube 的精彩 Rawkode Live 系列中的[《Kyverno 简介》](https://oreil.ly/H8kMm)。
- en: Both OPA/Gatekeeper and Kyverno fail open, meaning that if the policy engine
    service called by the API server webhook is down and hence unable to validate
    an inbound change, they will proceed unvalidated. Depending on your requirements
    this may not be what you want, but the reasoning behind this is to prevent DOSing
    your cluster and subsequently slowing it down or potentially bringing down the
    control plane at all.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**OPA/Gatekeeper** 和 **Kyverno** 都是开放式失败的，这意味着如果由 API 服务器 Webhook 调用的策略引擎服务停机并因此无法验证入站更改，则会继续未经验证。根据您的需求，这可能不是您想要的，但背后的原因是防止集群被
    DOS 攻击，从而减慢或潜在地使控制平面崩溃。'
- en: 'Both have auditing functionalities as well as a scanning mode that addresses
    this situation. For a more fine-grained comparison, we recommend you peruse Chip
    Zoller’s blog post [“Kubernetes Policy Comparison: OPA/Gatekeeper vs. Kyverno”](https://oreil.ly/qBd3l).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都具有审计功能以及解决此情况的扫描模式。为了更细致的比较，我们建议您阅读 Chip Zoller 的博文 [“Kubernetes 策略比较：OPA/Gatekeeper
    vs. Kyverno”](https://oreil.ly/qBd3l)。
- en: Let’s now have a further look at other options in this space.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进一步看看这个领域中的其他选择。
- en: Other Policy Offerings
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他策略产品
- en: In this last section on handling policies for and in Kubernetes we review some
    projects and offerings that you may want to consider using in addition to or as
    an alternative to the previously discussed ones.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 Kubernetes 的策略时，我们回顾了一些项目和产品，您可能希望考虑额外使用或作为前面讨论的替代品。
- en: 'Given that a Kubernetes cluster doesn’t operate in a vacuum, but in a certain
    environment such as the case with managed offerings that would be the cloud provider
    of your choice, you may indeed already be using some of the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Kubernetes 集群不是在真空中运行的，而是在某个环境中，例如您选择的云提供商，您可能已经在使用以下一些功能：
- en: '[OSO](https://oreil.ly/e4r3X)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[OSO](https://oreil.ly/e4r3X)'
- en: This is a library for building authorization in your application. It comes with
    a set of APIs built on top of a declarative policy language called Polar, as well
    as a CLI/REPL and a debugger and REPL. With OSO you can express policies like
    “these types of users can see these sorts of information,” as well as implement
    role-based access control in your app.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于构建应用程序授权的库。它提供了一组基于名为 Polar 的声明性策略语言的 API，以及一个 CLI/REPL 和一个调试器和 REPL。通过
    OSO，您可以表达诸如“这些类型的用户可以查看这些信息”之类的策略，并在应用程序中实施基于角色的访问控制。
- en: '[Cilium policy](https://oreil.ly/FB7RB) and [Calico policy](https://oreil.ly/xyh87)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cilium 策略](https://oreil.ly/FB7RB) 和 [Calico 策略](https://oreil.ly/xyh87)'
- en: These extend the functionalities of Kubernetes network policies.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展了 Kubernetes 网络策略的功能。
- en: '[AWS Identity and Access Management (IAM)](https://oreil.ly/Bi835)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[AWS Identity and Access Management (IAM)](https://oreil.ly/Bi835)'
- en: This has a range of policies, from identity-based to resource-based to organization-level
    policies. There are also more specialized offerings; for example, in the context
    of Amazon EKS, you can define [security groups for pods](https://oreil.ly/yZH2Q).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有从基于身份的策略到基于资源的策略再到组织级别策略的一系列策略。还有更多专业化的产品；例如，在 Amazon EKS 的上下文中，您可以为 Pod
    定义 [安全组](https://oreil.ly/yZH2Q)。
- en: '[Google Identity and Access Management (IAM)](https://oreil.ly/D7O3F)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[Google Identity and Access Management (IAM)](https://oreil.ly/D7O3F)'
- en: This has a rich and powerful policy model, similar to Kubernetes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这具有丰富而强大的策略模型，类似于 Kubernetes。
- en: '[Azure Policy](https://oreil.ly/c6N8J)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[Azure 策略](https://oreil.ly/c6N8J)'
- en: This allows stating business-level policies and they in addition offer Azure
    RBAC for access control purposes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许定义业务级别的策略，并且除了提供 Azure RBAC 用于访问控制目的外。
- en: '[CrossGuard](https://oreil.ly/rUBSA)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[CrossGuard](https://oreil.ly/rUBSA)'
- en: By Pulumi, this is described as “Policy as Code,” offering to define and enforce
    guardrails across cloud providers.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Pulumi 提供的 “策略即代码”，提供定义和强制实施跨云提供商的防护栏。
- en: Conclusion
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Policy is essential to securing your clusters, and thought is required to map
    your teams to their groups and roles. Roles that allow transitive access to other
    service accounts may offer a path to privilege escalation. Also, don’t forget
    to threat model the impact of credential compromise, and always use 2FA for humans.
    Last but not least, as usual, automating as much as possible, including policy
    testing and validation, pays off in the long run.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 策略对于保护您的集群至关重要，需要考虑将团队映射到其组和角色。允许跨服务账户进行传递访问的角色可能会提供特权升级的路径。另外，不要忘记威胁建模凭证泄露的影响，并始终为人员使用双因素认证。最后但同样重要的是，尽可能自动化，包括策略测试和验证，在长远来看将会产生回报。
- en: The wonderful Kubernetes and wider CNCF ecosystem has already provided a wealth
    of open source solutions, so in our experience it’s usually not a problem to find
    a tool but to figure out which out of the, say, ten tools available is the best
    and will still be supported when the Captain’s grandchildren have taken over.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 美妙的Kubernetes和更广泛的CNCF生态系统已经提供了大量开源解决方案，因此根据我们的经验，通常不是找到工具的问题，而是弄清楚在所有可用的十个工具中，哪一个是最好的，并且在船长的孙子接管时仍然得到支持。
- en: With this we’ve reached the end of the policy chapter and will now turn our
    attention to the question of what happens if the Captain somehow, despite of all
    our controls put in place, manages to break in. In other words, we discuss intrusion
    detection systems (IDS) to detect unexpected activity. Arrrrrrr!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本章政策已经讨论完毕，现在我们将转向一个问题：即使尽管我们设置了所有的控制措施，船长还是设法闯入了，我们将如何处理。换句话说，我们将讨论入侵检测系统（IDS）来检测意外活动。Arrrrrrr！
