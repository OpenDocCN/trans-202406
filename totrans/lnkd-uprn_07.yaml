- en: Chapter 7\. mTLS, Linkerd, and Certificates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章\. mTLS、Linkerd和证书
- en: Moving from a monolithic application to a microservices application puts us
    in a very interesting position as far as security is concerned. Where the monolith
    provided a natural security perimeter at the edge of its process, a microservices
    application has no natural security perimeter at all. Sensitive information that
    was previously protected by being passed in a function call inside the process
    now has to be sent over the network, as shown in [Figure 7-1](#monolith-vs-microservices).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从单体应用转向微服务应用，在安全方面使我们处于一个非常有趣的位置。单体应用在其进程边缘提供了一个自然的安全边界，而微服务应用则完全没有自然的安全边界。以前通过在进程内部的函数调用中传递的敏感信息现在必须通过网络发送，如图[7-1](#monolith-vs-microservices)所示。
- en: '![luar 0701](assets/luar_0701.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0701](assets/luar_0701.png)'
- en: Figure 7-1\. Security stance in a monolithic versus a microservices application
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1\. 单体与微服务应用中的安全立场
- en: Additionally, the microservices are often running on infrastructure and network
    resources provided by outside teams, organizations, or even companies. If nothing
    is done to counter the threat, it’s all too easy for an attacker with access to
    the network to read, intercept, and modify communications between microservices.
    This is obviously a serious problem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，微服务通常运行在由外部团队、组织甚至公司提供的基础设施和网络资源上。如果不采取措施来抵御威胁，攻击者很容易在访问网络的情况下读取、拦截和修改微服务之间的通信。这显然是一个严重的问题。
- en: Finally, the network doesn’t even provide any secure way for a given microservice
    to know who made a call to it. The called microservice can find out the caller’s
    IP and MAC addresses, but these aren’t actually secure—it’s very easy to spoof
    the sender’s IP address, for example. Things just get worse when the application
    is running on a network it doesn’t control.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，网络甚至没有提供任何安全的方式让特定的微服务知道是谁在调用它。被调用的微服务可以找出调用者的IP和MAC地址，但这些并不是真正安全的——例如，伪造发送者的IP地址非常容易。当应用运行在它无法控制的网络上时，情况只会变得更糟。
- en: Secure Communications
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全通信
- en: 'To allow any microservices application to work, we need *secure communications*.
    There are three distinct elements to truly secure communications:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使任何微服务应用程序正常工作，我们需要*安全通信*。真正安全通信有三个不同的要素：
- en: Authenticity
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 真实性
- en: We must be confident that we are talking to who we think we’re talking to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确信我们与我们认为正在交谈的人在交谈。
- en: Confidentiality
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 保密性
- en: We must be confident that no one can read the data being sent over the connection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确信没有人能读取发送到连接上的数据。
- en: Integrity
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完整性
- en: We must be confident that our messages haven’t been altered in transit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确信我们的消息在传输过程中没有被篡改。
- en: 'These aren’t new problems, and many different techniques have evolved to address
    them in various ways. Linkerd relies on one of the most trusted of these: *mutual
    TLS*, or *mTLS*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是新问题，而且已经有许多不同的技术以各种方式演变来解决它们。Linkerd依赖于其中一个最值得信赖的技术之一：*双向TLS*，或者*mTLS*。
- en: TLS and mTLS
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TLS和mTLS
- en: TLS, defined by [RFC 8446](https://oreil.ly/K6Wwg), is a battle-tested, industry-standard
    mechanism for secure communications that dates back to 1999. It’s the same mechanism
    that web browsers have used for years to securely communicate with banks, shopping
    sites, etc. The modern Internet has been relying on TLS for nearly 25 years, and
    cryptanalysts have being trying for at least that long to find weaknesses in it.
    TLS provides authenticity, confidentiality, and integrity using the architecture
    shown in [Figure 7-2](#tls-architecture-diagram-2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TLS由[RFC 8446](https://oreil.ly/K6Wwg)定义，是一个经过实战检验的行业标准安全通信机制，可以追溯到1999年。这是Web浏览器多年来与银行、购物网站等进行安全通信所使用的相同机制。现代互联网已经依赖TLS近25年了，而密码分析学家至少有这么长时间在尝试找到它的弱点。TLS使用图[7-2](#tls-architecture-diagram-2)所示的架构提供真实性、保密性和完整性。
- en: '![luar 0702](assets/luar_0702.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0702](assets/luar_0702.png)'
- en: Figure 7-2\. TLS architecture
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2\. TLS架构
- en: (Linkerd specifically uses TLS version 1.3, but all TLS versions have used the
    same architecture.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: （Linkerd特别使用TLS版本1.3，但所有TLS版本都使用相同的架构。）
- en: TLS ensures confidentiality by encrypting data in transit and integrity by adding
    message digests—cryptographic checksums—so that the receiver can validate that
    the data sent hasn’t been altered. This takes care of two of our three concerns.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TLS通过在传输中加密数据和添加消息摘要（加密校验和），确保了机密性和完整性，以便接收方可以验证发送的数据未被修改。这解决了我们三个关注点中的两个。
- en: Authenticity is more complex. TLS uses *certificates* to cryptographically allow
    validating the identity of both the sender and the receiver. The TLS standard
    always requires the receiving end to identify itself by sending a certificate.
    In many cases, this is all that’s needed; for example, when you use your web browser
    to visit a shopping site, it’s not terribly useful for your browser to send a
    certificate since the shopping site will require you to log in separately.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 真实性更加复杂。TLS 使用*证书*来加密验证发送方和接收方的身份。TLS 标准始终要求接收端通过发送证书来识别自己。在许多情况下，这已经足够了；例如，当您使用网页浏览器访问购物网站时，浏览器发送证书并不是非常有用，因为购物网站会要求您单独登录。
- en: For a service mesh, though, we need to authenticate both ends of the connection.
    This means we require both ends to send certificates for identification. When
    we use TLS like this (as Linkerd does), we call it mutual TLS or mTLS to distinguish
    it from the case where only the receiver identifies itself. This is shown in [Figure 7-3](#tls-vs-mtls).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务网格来说，我们需要验证连接的双端。这意味着我们需要双方发送证书以进行身份验证。当我们像这样使用 TLS（就像 Linkerd 那样），我们称之为双向
    TLS 或 mTLS，以区别于只有接收端进行身份验证的情况。这在[图 7-3](#tls-vs-mtls)中有所展示。
- en: '![luar 0703](assets/luar_0703.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0703](assets/luar_0703.png)'
- en: Figure 7-3\. TLS compared to mTLS
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. TLS 与 mTLS 比较
- en: 'Using certificates in both directions lets mTLS build on the guarantees provided
    by TLS: it provides a cryptographically validated identity of the client as well
    as the server, while still maintaining encryption in transit. For Linkerd, this
    means that mTLS guarantees that your workloads know whom they’re talking to and
    that no third party will be able to intercept or listen in on their communication.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向使用证书的情况下，mTLS 利用了 TLS 提供的保证：它不仅为客户端和服务器提供了经过加密验证的身份，同时还保持了传输中的加密。对于 Linkerd，这意味着
    mTLS 可以确保您的工作负载知道它们在与谁通信，且没有第三方能够拦截或监听它们的通信。
- en: mTLS and Certificates
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mTLS 和证书
- en: 'As we first discussed in [Chapter 2](ch02.html#LUAR_intro_to_linkerd), the
    certificates that mTLS relies on are built on keypairs consisting of a public
    key and a private key. The private key (of course) needs to be kept private: only
    the entity that the keypair identifies can know it. The public key, on the other
    hand, should be widely distributed: it’s what allows verifying the identity of
    the entity holding the private key, so everyone who needs to communicate with
    that entity needs the public key.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 2 章](ch02.html#LUAR_intro_to_linkerd)中首次讨论的那样，mTLS 依赖的证书是建立在公钥和私钥对上的。私钥（当然）需要保密：只有标识该密钥对的实体可以知道它。另一方面，公钥应该广泛分发：这就是验证持有私钥实体身份的依据，因此每个需要与该实体通信的人都需要这个公钥。
- en: Certificates give us a way to associate a *name* and other metadata with the
    keypair, which is useful because it allows us humans to more easily work with
    the certificate. They also give us a way for one certificate to attest that another
    is valid (*signing* or *issuing* a certificate), which is useful because it makes
    it much simpler to determine whether or not we trust a certificate.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 证书使我们能够将*名称*和其他元数据与密钥对关联起来，这非常有用，因为它使我们人类更容易处理证书。它们还使得一个证书可以证明另一个证书的有效性（*签名*或*发布*证书），这非常有用，因为它大大简化了我们是否信任证书的判断。
- en: 'Using certificates to sign other certificates creates a *trust hierarchy*,
    as shown in [Figure 7-4](#certificate-hierarchy-diagram-2). This hierarchy is
    important: mTLS can know that a certificate is valid as long as it has access
    to any of the public keys higher up in the hierarchy, and systems built on mTLS
    (including Linkerd) take advantage of this property.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用证书签署其他证书会创建一个*信任层级*，如[图 7-4](#certificate-hierarchy-diagram-2)所示。这种层级非常重要：mTLS
    可以通过访问层级结构中更高的任何公钥来验证证书的有效性，而建立在 mTLS 之上的系统（包括 Linkerd）利用了这一特性。
- en: '![luar 0704](assets/luar_0704.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0704](assets/luar_0704.png)'
- en: Figure 7-4\. The certificate trust hierarchy
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. 证书信任层级
- en: 'Finally, it’s important to limit the lifespan of a given keypair: the longer
    a key is used, the greater the danger if it’s compromised. Every so often, we
    need to replace the keys in use for a given certificate. This involves creating
    a new keypair, then generating a new certificate, and finally getting it properly
    signed. This entire process is called *rotating* the certificate; it is the main
    source of operational complexity when working with certificates.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，限制给定密钥对的使用寿命非常重要：密钥使用越长时间，如果被泄露，危险越大。因此，我们需要定期更换正在使用的证书密钥。这涉及创建新的密钥对，然后生成新的证书，并最终确保它得到正确签名。整个过程称为
    *轮换* 证书；这是在处理证书时的主要操作复杂性来源。
- en: Linkerd and mTLS
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linkerd 和 mTLS
- en: Linkerd transparently adds mTLS to all of your interapplication communications.
    This means that all meshed traffic is protected against interception and tampering.
    It also means your workloads can be certain of which workloads they’re communicating
    with at all times.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd 透明地为所有应用间通信添加了 mTLS。这意味着所有网格化的流量都受到拦截和篡改的保护。这还意味着您的工作负载可以确保它们始终知道正在与哪些工作负载通信。
- en: This can only work if every meshed workload has a valid TLS certificate associated
    with that workload, and if all these *workload certificates* are part of the same
    trust hierarchy. Managing this by hand would be incredibly difficult, so Linkerd
    helps to automate it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当每个网格化工作负载都有与该工作负载相关联的有效 TLS 证书，并且所有这些 *工作负载证书* 都属于相同的信任层次结构时，才能正常工作。手动管理这些将非常困难，因此
    Linkerd 帮助自动化了这一过程。
- en: We talked about adding workloads to the mesh in [Chapter 4](ch04.html#LUAR_meshing_workloads),
    but let’s revisit that in a bit more detail. When a workload is added to the mesh,
    it gets a `linkerd2-proxy` container added to its Pod. That container will be
    configured to intercept all TCP traffic going into and out of the Pod, and it
    will always attempt to build an mTLS session when a connection is made with another
    Pod. If the other Pod also has a `linkerd2-proxy`—meaning that it’s part of the
    mesh!—then the connection will be protected with mTLS.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第四章](ch04.html#LUAR_meshing_workloads) 中讨论了如何将工作负载添加到网格中，但让我们稍微详细地重新讨论一下。当将工作负载添加到网格中时，会向其
    Pod 添加一个 `linkerd2-proxy` 容器。该容器将被配置为拦截进出 Pod 的所有 TCP 流量，并且在与另一个 Pod 建立连接时始终尝试建立
    mTLS 会话。如果另一个 Pod 也有 `linkerd2-proxy` —— 意味着它是网格的一部分！—— 那么连接将受到 mTLS 保护。
- en: 'Since this mTLS connection happens from proxy to proxy, the application containers
    within the Pods never even know that mTLS is happening: from an application perspective,
    all communications between Pods look like they’re using cleartext. This means
    that the application Pods don’t see any information about the certificates that
    Linkerd is using, which in turn means that they don’t need any special code to
    handle certificate information.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此 mTLS 连接是从代理到代理的，Pod 中的应用容器甚至不知道 mTLS 是如何进行的：从应用程序的角度来看，Pod 之间的所有通信看起来都像是使用明文。这意味着应用
    Pod 看不到 Linkerd 使用的任何证书信息，进而意味着它们不需要任何特殊的代码来处理证书信息。
- en: Protocol Detection and the Proxy
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议检测和代理
- en: The fact that the proxy intercepts *all* communication between Pods means that
    you may sometimes need to give it extra information about the protocol, or indeed
    not try to do mTLS. This is all covered at some length in [Chapter 4](ch04.html#LUAR_meshing_workloads),
    but a good rule of thumb is that as long as the client speaks first, you’re probably
    OK. If the server speaks first, you’ll need to do some configuration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 代理拦截 *所有* 与 Pod 之间的通信意味着，有时您可能需要向其提供有关协议的额外信息，或者确实不尝试使用 mTLS。在 [第四章](ch04.html#LUAR_meshing_workloads)
    中详细讨论了所有这些内容，但一个很好的经验法则是，只要客户端先发言，那么一切都会正常。如果服务器先发言，则需要进行一些配置。
- en: 'Of course, that’s only true if the server is in the mesh! If you’re trying
    to communicate from a meshed Pod to an unmeshed Pod, you will always need to tell
    Linkerd to skip the traffic: it won’t be able to do mTLS without the destination
    Pod being part of the mesh.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这仅适用于服务器在网格中的情况！如果您尝试从网格化 Pod 向非网格化 Pod 进行通信，您将始终需要告诉 Linkerd 跳过此流量：否则，它将无法在目标
    Pod 不在网格中时执行 mTLS。
- en: Certificates and Linkerd
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 证书和 Linkerd
- en: 'We talked about Linkerd certificates back in [Chapter 3](ch03.html#LUAR_deploying_linkerd).
    In this section, we’ll go into more detail about exactly what these certificates
    are used for, how they are created, and what needs to happen when you want to
    rotate them. We’re going to cover the three tiers of certificates used in Linkerd:
    trust anchor, identity issuer, and workload certificates.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 3 章](ch03.html#LUAR_deploying_linkerd) 中讨论了 Linkerd 证书。在本节中，我们将详细介绍这些证书的具体用途、创建方法以及在需要旋转时的操作。我们将涵盖
    Linkerd 使用的三个层次的证书：信任锚、身份签发者和工作负载证书。
- en: From Linkerd’s point of view, trust starts with its trust anchor certificate,
    as shown in [Figure 7-5](#linkerd-trust-diagram-2). The trust anchor can, of course,
    be signed by some other higher-level certificate—as far as Linkerd is concerned,
    though, trust stops with the trust anchor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linkerd 的角度来看，信任始于其信任锚证书，如 [图 7-5](#linkerd-trust-diagram-2) 所示。信任锚当然可以由其他更高级的证书签名——然而对于
    Linkerd 来说，信任在信任锚止步。
- en: '![luar 0705](assets/luar_0705.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0705](assets/luar_0705.png)'
- en: Figure 7-5\. The Linkerd trust hierarchy
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. Linkerd 信任层次结构
- en: Linkerd automatically handles the generation, distribution, and rotation of
    workload certificates, while relying on the user to manage the trust anchor and
    the identity issuer. This is shown in [Figure 7-6](#linkerd-certificate-management).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd 自动处理工作负载证书的生成、分发和旋转，同时依赖用户管理信任锚和身份签发者。这在 [图 7-6](#linkerd-certificate-management)
    中有所展示。
- en: '![luar 0706](assets/luar_0706.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0706](assets/luar_0706.png)'
- en: Figure 7-6\. Linkerd certificate management
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. Linkerd 证书管理
- en: Never Let Your Certificates Expire
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永远不要让您的证书过期。
- en: Because Linkerd requires mTLS connections between Pods by default, the health
    and security of the certificates it uses are absolutely critical to the healthy
    operation of the mesh—and thus your platform. If certificates expire, or can’t
    be generated for new Pods, *you will incur downtime*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Linkerd 默认要求 Pod 之间进行 mTLS 连接，所以它使用的证书的健康和安全性对网格的正常运行以及您的平台至关重要。如果证书过期或无法为新的
    Pod 生成，*您将遭受停机*。
- en: This is the most common cause of downtime in production Linkerd clusters. Understanding
    and monitoring your Linkerd certificates is vital.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生产 Linkerd 集群中停机的最常见原因。了解和监控您的 Linkerd 证书至关重要。
- en: The Linkerd Trust Anchor
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linkerd 信任锚
- en: 'The Linkerd *trust anchor* is the certificate that provides the foundation
    for all trust in your cluster. It is used for exactly two things:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd *信任锚* 是您的集群中所有信任的基础证书。它仅用于两件事：
- en: When installing Linkerd, you will use the trust anchor to issue the Linkerd
    identity issuer certificate, which we’ll discuss in the next section. This requires
    access to both the private and public keys of the trust anchor and is something
    done outside of Linkerd, before installation.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Linkerd 时，您将使用信任锚来发布 Linkerd 身份签发者证书，我们将在下一节中讨论这一点。这需要在安装之前，在 Linkerd 之外访问信任锚的私钥和公钥。
- en: Whenever a workload makes an mTLS connection to another workload, both workloads
    use the identity issuer and the trust anchor to verify the identity of the other
    workload. This requires access to only the public key of the trust anchor and
    happens constantly while the mesh is operating.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当工作负载与另一个工作负载进行 mTLS 连接时，两个工作负载都使用身份签发者和信任锚来验证对方的身份。这需要访问信任锚的公钥，并在网格运行时不断进行。
- en: Since only the public key is needed for in-cluster operations (the second bullet
    in the preceding list), we recommend that you never store your trust anchor’s
    private key in your Kubernetes cluster. Instead, store the trust anchor in a secure
    system outside of Kubernetes and only copy its public key into the cluster, as
    we’ll cover in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为只有在集群内操作时需要公钥（上述列表中的第二个小点），我们建议您永远不要将信任锚的私钥存储在 Kubernetes 集群中。相反，将信任锚存储在 Kubernetes
    之外的安全系统中，并仅将其公钥复制到集群中，正如我们将在本章中介绍的那样。
- en: 'One very important thing to realize is that the trust anchor is not intrinsically
    tied to a cluster: it is completely independent of network topology or cluster
    boundaries. This means that if you give multiple clusters the same trust anchor,
    they’ll be able to do secure mTLS between workloads in different clusters, as
    shown in [Figure 7-7](#multicluster-trust-hierarchy-1). This is extremely powerful,
    as it makes multicluster meshes very easy to set up.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，信任锚点与集群没有固有的联系：它完全独立于网络拓扑或集群边界。这意味着如果你给多个集群相同的信任锚点，它们将能够在不同集群中的工作负载之间进行安全的mTLS，如[图7-7](#multicluster-trust-hierarchy-1)所示。这非常强大，因为它使多集群网格设置变得非常容易。
- en: '![luar 0707](assets/luar_0707.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0707](assets/luar_0707.png)'
- en: Figure 7-7\. Multicluster trust hierarchy
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-7\. 多集群信任层次
- en: Correspondingly, two clusters that should *not* be able to communicate with
    each other should *not* share a trust anchor! For most organizations, this implies
    not sharing trust anchors across environment tiers—that is, test clusters shouldn’t
    have the same trust anchor as development or production clusters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，两个不应该相互通信的集群*不*应该共享信任锚点！对于大多数组织来说，这意味着不应该跨环境层次共享信任锚点——也就是说，测试集群不应该与开发或生产集群共享相同的信任锚点。
- en: The Linkerd Identity Issuer
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linkerd身份颁发者
- en: At the second level of the Linkerd trust hierarchy is the identity issuer certificate,
    as we also briefly touched on in [Chapter 3](ch03.html#LUAR_deploying_linkerd).
    The identity issuer is used by the Linkerd control plane’s identity controller
    to issue workload certificates, as shown in [Figure 7-8](#issuer-certificate-diagram).
    Since the identity issuer is used to sign certificates, Linkerd must have access
    to both the private and public keys of the identity issuer certificate, which
    means that it must be stored in a Secret in the cluster.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linkerd信任层次的第二级是身份颁发者证书，正如我们在[第3章](ch03.html#LUAR_deploying_linkerd)中简要提到的那样。身份颁发者由Linkerd控制平面的身份控制器用于颁发工作负载证书，如[图7-8](#issuer-certificate-diagram)所示。由于身份颁发者用于签署证书，Linkerd必须可以访问身份颁发者证书的私钥和公钥，这意味着它必须存储在集群中的一个秘密位置。
- en: '![luar 0708](assets/luar_0708.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0708](assets/luar_0708.png)'
- en: Figure 7-8\. The issuer certificate and the identity controller
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-8\. 颁发者证书和身份控制器
- en: The identity issuer must be signed by the trust anchor, and since it must be
    stored in the cluster, each cluster must have its own identity issuer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 身份颁发者必须由信任锚点签署，并且由于它必须存储在集群中，每个集群必须有自己的身份颁发者。
- en: Linkerd Cannot Warn You If You Share Identity Issuer Certificates
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linkerd无法警告您如果共享身份颁发者证书
- en: There isn’t any good way for Linkerd to warn you if you accidentally use the
    same identity issuer certificate in two clusters, and in fact everything will
    work. *Don’t do this*, though. If you do, the two clusters will become indistinguishable,
    and an evildoer will potentially be able to use one cluster to create a workload
    certificate that can bypass authorization policy in the other cluster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心在两个集群中使用相同的身份颁发者证书，Linkerd没有任何良好的方法来警告你，实际上一切都会正常运行。*不要这样做*。如果你这样做了，两个集群将变得无法区分，恶意用户有可能利用一个集群创建一个绕过另一个集群授权策略的工作负载证书。
- en: Make sure that each cluster has a unique identity issuer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 确保每个集群都有一个唯一的身份颁发者。
- en: Linkerd Workload Certificates
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linkerd工作负载证书
- en: Finally, we come to the certificates that actually do the work of providing
    mTLS between our applications. When a workload is added to a Linkerd mesh, the
    Linkerd proxy associated with each workload Pod automatically requests a workload
    certificate from the Linkerd identity controller. This workload certificate is
    the basis for the workload’s identity. It will be signed by the identity issuer
    certificate, and since every other workload has access to the public keys of the
    identity issuer and the trust anchor, the validity of the workload certificate
    can be verified all the way back to the trust anchor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到实际执行应用程序之间提供mTLS功能的证书。当一个工作负载被添加到Linkerd网格中时，与每个工作负载Pod关联的Linkerd代理会自动向Linkerd身份控制器请求一个工作负载证书。这个工作负载证书是工作负载身份的基础。它将由身份颁发者证书签署，由于每个其他工作负载都可以访问身份颁发者和信任锚点的公钥，可以验证工作负载证书的有效性直到信任锚点。
- en: 'The workload certificate for each Pod is cryptographically linked to the Kubernetes
    ServiceAccount assigned to the Pod, and its name includes the name of the ServiceAccount
    and the namespace. This allows your Pods to be uniquely identified when they communicate
    with each other. It also provides us with the identity we will need later when
    we build policy. The basic format for the identity name is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Pod 的工作负载证书都与分配给 Pod 的 Kubernetes ServiceAccount 在密码学上相关联，其名称包括 ServiceAccount
    和命名空间的名称。这使得在它们彼此通信时能够唯一标识您的 Pods。当我们建立策略时，这也为我们提供了稍后将需要的身份。身份名称的基本格式为：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: where `$clusterDomain` will be `cluster.local` if you haven’t overridden it.
    (Most single-cluster Linkerd installations won’t need to override this.)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `$clusterDomain` 没有被覆盖时，它将是 `cluster.local`。（大多数单集群 Linkerd 安装不需要覆盖此设置。）
- en: Linkerd handles workload certificates completely automatically; you should never
    need to worry about managing them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd 完全自动处理工作负载证书；您不应该担心管理它们。
- en: Certificate Lifetimes and Rotation
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书的生命周期和旋转
- en: As we mentioned earlier, the longer you use a given key, the more valuable it
    tends to be to break that key. For this reason, certificates are given fixed lifespans,
    and they must be replaced before they expire. Replacing a certificate with a new
    one is called *rotating* the certificate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用特定密钥的时间越长，突破该密钥的价值就越大。因此，证书被赋予固定的寿命，并且在其到期之前必须替换。用新证书替换证书称为*旋转*证书。
- en: Choosing exactly how often to rotate certificates is a balancing act. Rotating
    very frequently is most secure, but it can disrupt normal operations and require
    an impractical amount of effort. Rotating very infrequently—or not at all—is very
    simple, but also very insecure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，选择证书旋转的频率是一种权衡。频繁旋转最安全，但可能会干扰正常运作并需要不切实际的努力。很少或不旋转非常简单，但也非常不安全。
- en: 'Linkerd handles rotating workload certificates for you: by default, workload
    certificates expire every 24 hours. However, rotating the identity issuer and
    trust anchor certificates is left up to you, since your organization’s policy
    will often dictate how often you’ll be rotating. The critical things to consider
    are:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd 会自动为您旋转工作负载证书：默认情况下，工作负载证书每 24 小时过期一次。然而，身份发行者和信任锚点证书的旋转由您决定，因为通常您的组织政策会决定您需要多频繁地旋转。需要考虑的关键因素是：
- en: Every time you rotate the trust anchor, you *must* also rotate the identity
    issuer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你旋转信任锚点时，你*必须*同时旋转身份发行者。
- en: This is because the trust anchor must sign the identity issuer. If you’ve just
    generated a new trust anchor, there’s no way the old identity issuer can be signed
    by the new trust anchor, so you need a new identity issuer too.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为信任锚点必须签署身份发行者。如果你刚刚生成了一个新的信任锚点，旧的身份发行者无法由新的信任锚点签署，因此你也需要一个新的身份发行者。
- en: In turn, this means that you *cannot* rotate the trust anchor more often than
    the identity issuer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这意味着你*不能*比身份发行者更频繁地旋转信任锚点。
- en: Every time you rotate the identity issuer, you *may* also rotate the workload
    certificates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你旋转身份发行者时，你*可能*也要旋转工作负载证书。
- en: Since workload certificates are automatically rotated by Linkerd, when you rotate
    the identity issuer you can opt to just wait for Linkerd to rotate the workload
    certificates. If you want to be sure they’re rotated immediately, just restart
    the workloads.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linkerd 自动处理工作负载证书的旋转，当你旋转身份发行者时，你可以选择等待 Linkerd 自动旋转工作负载证书。如果你希望立即确保它们被旋转，请重新启动工作负载。
- en: 'The way you rotate a certificate depends on which certificate it is:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转证书的方式取决于它是哪种证书：
- en: Rotating the trust anchor
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转信任锚点
- en: 'Rotating the trust anchor is actually out of scope for this book: in practice,
    if you adhere to the principle that clusters themselves should be ephemeral, it
    can be more practical to simply have the lifespan of the trust anchor mirror that
    of the cluster. You can find more about rotating the trust anchor in the [official
    Linkerd docs](https://oreil.ly/9fAPV).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，本书的内容不涵盖旋转信任锚点：实践中，如果你遵循集群本身应该是临时的原则，那么将信任锚点的生命周期与集群的生命周期保持一致可能更实际。你可以在
    [官方 Linkerd 文档](https://oreil.ly/9fAPV) 中找到更多关于旋转信任锚点的信息。
- en: Rotating the identity issuer
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转身份发行者
- en: Rotating the identity issuer is a basic operational task in Linkerd. Ideally,
    you’ll automate rotating the identity issuer with a tool like Venafi’s [cert-manager](https://cert-manager.io),
    and we show how to do this in this chapter. You can also manually rotate the trust
    anchor using the procedure shown in the [official Linkerd docs](https://oreil.ly/CN9IB).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linkerd中，轮换身份颁发者是一项基本的操作任务。理想情况下，您将使用诸如Venafi的[cert-manager](https://cert-manager.io)之类的工具自动化轮换身份颁发者，并且我们在本章中展示了如何操作。您还可以根据[官方Linkerd文档](https://oreil.ly/CN9IB)中的过程手动轮换信任锚。
- en: Whether you automate identity issuer rotation or do it manually, it is critical
    that you practice rotating the identity issuer *before* the identity issuer expires.
    Having a mechanism that you’ve never tested can be worse than not having anything
    set up at all.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是自动化身份颁发者轮换还是手动进行，重要的是在身份颁发者到期之前*练习*轮换身份颁发者。拥有一个从未测试过的机制可能比根本没有设置更糟糕。
- en: Rotating the workload certificates
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 轮换工作负载证书
- en: Workload certificates are automatically rotated by the Linkerd control plane,
    so you should almost never need to deal with them. (As noted previously, if you
    *do* want to rotate a workload certificate, just restart the workload.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载证书由Linkerd控制平面自动轮换，因此您几乎不需要处理它们。（正如之前提到的，如果您确实希望轮换工作负载证书，只需重新启动工作负载。）
- en: By default, workload certificates are valid for 24 hours, and the control plane
    will begin attempting to rotate a workload certificate once it’s hit 70% of its
    effective lifetime.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，工作负载证书有效期为24小时，控制平面将在其有效生命周期的70%后开始尝试轮换工作负载证书。
- en: Tuning Workload Certificates
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整工作负载证书
- en: If needed, you can tune the lifespan of workload certificates by setting the
    `issuanceLifetime` value when installing Linkerd, but recognize that there are
    two important operational concerns if you reduce this value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以通过在安装Linkerd时设置`issuanceLifetime`值来调整工作负载证书的生命周期，但要注意，如果您缩短此值，则存在两个重要的操作问题。
- en: First, you increase the frequency with which your Pods communicate with the
    identity controller, which increases the load on the identity controller.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您增加了Pod与身份控制器通信的频率，这会增加身份控制器的负载。
- en: 'Second, you reduce the amount of time you have to address problems with renewals.
    The proxy will begin attempting to renew at 70% of the lifespan: for a 24-hour
    lifespan, this means it will start trying with about 7 hours to go before the
    certificate expires, giving you about 7 hours to solve any problems that come
    up. If the whole lifespan is just 2 hours, you’ll only have about half an hour
    to work with if anything goes wrong.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您减少了解决更新问题的时间。代理将开始尝试在生命周期的70%进行更新：对于24小时的生命周期，这意味着在证书过期前大约还有7小时开始尝试更新，如果出现任何问题，您将有大约7小时来解决。如果整个生命周期只有2小时，如果出现任何问题，您将只有大约半小时来解决。
- en: As you have likely surmised, we’ve only skimmed the surface of how certificates
    work in general, and in Linkerd in particular, but you should now have more than
    enough information to understand how certificates are used in Linkerd.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经推测到的那样，我们只是浅显地介绍了证书的一般工作原理，特别是在Linkerd中，但是现在您应该已经有足够的信息来理解在Linkerd中如何使用证书。
- en: Certificate Management in Linkerd
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linkerd中的证书管理
- en: It should be clear at this point that certificate management is a critical part
    of securing a production Linkerd installation. Properly managing certificates
    is an important way to reduce the likelihood of an incident. It can also help
    minimize time to recovery and the overall impact if something does go wrong.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，明显应该清楚证书管理是保护生产Linkerd安装的关键部分。正确管理证书是减少事件发生可能性的重要方式。它还可以帮助最小化恢复时间和如果发生故障的整体影响。
- en: 'With that in mind, our recommendations for everyone using Linkerd for any kind
    of production use are:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们建议所有使用Linkerd进行任何类型的生产使用的人：
- en: Couple the life of the trust anchor to the life of the cluster.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将信任锚的生命周期与集群的生命周期耦合。
- en: It’s definitely possible to rotate the trust anchor, but treating the entire
    cluster as ephemeral and periodically rotating the whole cluster tends to make
    disaster recovery and provider migration ultimately simpler.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以轮换信任锚，但将整个集群视为临时的并定期轮换整个集群通常会使灾难恢复和提供者迁移变得更简单。
- en: Automate rotating the identity issuer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化轮换身份颁发者。
- en: It’s definitely possible to manage the identity issuer by hand, but we *strongly*
    recommend using a tool like cert-manager to regularly rotate the identity issuer
    certificate every few days instead. This shorter lifespan for the identity issuer
    can dramatically limit the scope of any incident, and using cert-manager makes
    it almost unnoticeable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 确实可以手动管理身份发行者，但我们*强烈建议*使用类似 cert-manager 的工具来定期轮换身份发行者证书，例如每隔几天一次。这种更短的身份发行者寿命可以大大限制任何事故的范围，而使用
    cert-manager 几乎是不可察觉的。
- en: Automatic Certificate Management with cert-manager
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cert-manager 进行自动证书管理
- en: Venafi’s cert-manager is a CNCF project that manages automatic certificate generation
    and rotation, as shown in [Figure 7-9](#rotation-with-cert-manager). We’re not
    going to cover the detailed inner workings of cert-manager (that’s beyond the
    scope of this book); instead, we’re going to focus on the concepts required to
    understand how to use cert-manager with Linkerd.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Venafi 的 cert-manager 是一个 CNCF 项目，用于管理自动证书生成和轮换，如[图 7-9](#rotation-with-cert-manager)所示。我们不会详细介绍
    cert-manager 的内部工作原理（这超出了本书的范围）；相反，我们将重点放在理解如何与 Linkerd 一起使用 cert-manager 的概念上。
- en: '![luar 0709](assets/luar_0709.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![luar 0709](assets/luar_0709.png)'
- en: Figure 7-9\. Automatic issuer certificate rotation with cert-manager
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-9\. 使用 cert-manager 自动轮换发行者证书
- en: Installing cert-manager
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 cert-manager
- en: 'We start by installing cert-manager using Helm to manage our install, as shown
    in [Example 7-1](#EX9-1). To follow along, you’ll need the following tools available
    in your environment:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过 Helm 安装 cert-manager 来管理我们的安装，如[示例 7-1](#EX9-1)所示。要跟进操作，您需要在环境中准备以下工具：
- en: '`kubectl`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`'
- en: '`k3d` or another tool for getting a local Kubernetes cluster'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `k3d` 或其他工具获取本地 Kubernetes 集群
- en: '`helm3`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helm3`'
- en: Example 7-1\. Installing cert-manager
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1\. 安装 cert-manager
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Software Versions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件版本
- en: Be aware that our examples are using specific versions to make sure that things
    work at the time of this writing. There may be more updated versions available
    by the time you read this, though; make sure you’re using appropriate versions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的示例使用特定版本，以确保在撰写本文时工作正常。但是，在您阅读本文时可能已有更新版本，请确保使用适当的版本。
- en: Configuring cert-manager for Linkerd
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Linkerd 的 cert-manager
- en: 'While a deep dive into cert-manager is out of scope for this book, it’s definitely
    worth discussing its overall architecture for our use case. cert-manager is configured
    with Issuer and Certificate resources: an Issuer resource tells cert-manager where
    to find the keys it needs to issue a certificate, and a Certificate resource tells
    cert-manager which Issuer to use for a specific certificate.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书不涵盖 cert-manager 的深入介绍，但讨论其整体架构对我们的使用场景是非常值得的。cert-manager 配置了 Issuer 和
    Certificate 资源：Issuer 资源告诉 cert-manager 在哪里找到其需要发行证书的密钥，而 Certificate 资源告诉 cert-manager
    使用哪个 Issuer 为特定证书发行证书。
- en: In our case, as shown in [Figure 7-9](#rotation-with-cert-manager), we’ll create
    an Issuer that holds the trust anchor keys and a Certificate that describes how
    to use that Issuer to get a Linkerd issuer certificate.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，如[图 7-9](#rotation-with-cert-manager)所示，我们将创建一个持有信任锚点密钥的 Issuer，并且一个描述如何使用该
    Issuer 获取 Linkerd 发行者证书的 Certificate。
- en: 'We mentioned at the beginning of the chapter that you never want to add your
    root CA’s private key to your Kubernetes cluster. Because standing up an external
    key store is out of scope for this book, we’re going to break that rule in [Example 7-2](#EX9-2)
    and use cert-manager with the trust anchor stored in a Kubernetes Secret. In any
    real production environment you would *not* do this, but the overall setup will
    stay the same, with one Issuer and one Certificate: you’ll just change the Issuer
    definition to use your external agent instead. (cert-manager supports many different
    external agents; see [the documentation](https://oreil.ly/f5354).)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开头提到，永远不要将根 CA 的私钥添加到 Kubernetes 集群中。由于在本书范围内部署外部密钥存储是不切实际的，我们将在[示例 7-2](#EX9-2)中违反此规则，并使用
    cert-manager 将信任锚点存储在 Kubernetes Secret 中。在任何真实的生产环境中，您都*不应*这样做，但总体设置将保持不变，一个
    Issuer 和一个 Certificate：只需将 Issuer 定义更改为使用您的外部代理即可（cert-manager 支持许多不同的外部代理；参见[文档](https://oreil.ly/f5354)）。
- en: Keep the Trust Anchor Key out of the Cluster!
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将信任锚点密钥保持在集群外！
- en: Again, *do not* use this setup in production. It can be made safer, but having
    your trust anchor’s secret key in the cluster will never be as safe as having
    it exist only in an external store.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不要在生产中使用此设置。它可以更安全，但是您的信任锚点密钥存在集群中永远不会像仅存在于外部存储中那样安全。
- en: Example 7-2\. Generating certificates for Linkerd
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. 为 Linkerd 生成证书
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s go back over what we just did. We started by installing cert-manager into
    our cluster, which will automate the process of issuing and rotating certificates.
    We then created a trust anchor and told cert-manager to use that certificate to
    automatically create and rotate Linkerd’s issuer certificate. The issuer certificate
    is an intermediary CA that Linkerd will use to create, distribute, and rotate
    the individual workload certificates. cert-manager will rotate the issuer certificate
    every 48 hours, as we defined in its Certificate object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下刚才的步骤。我们首先将 cert-manager 安装到我们的集群中，这将自动化证书的发布和轮换过程。然后我们创建了一个信任锚点，并告诉
    cert-manager 使用该证书来自动创建和轮换 Linkerd 的颁发者证书。颁发者证书是 Linkerd 将用来创建、分发和轮换各个工作负载证书的中间
    CA。cert-manager 将按照我们在其证书对象中定义的每 48 小时轮换一次颁发者证书。
- en: Let’s take a quick tour around our cluster, as shown in [Example 7-3](#EX9-3),
    to see what cert-manager will actually do with this setup.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下我们的集群，如[示例 7-3](#EX9-3)所示，看看 cert-manager 实际上如何处理这个设置。
- en: Example 7-3\. Looking around
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. 四处看看
- en: '[PRE4]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that out of the way, we can now install Linkerd.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，现在我们可以安装 Linkerd 了。
- en: Installing Linkerd using cert-manager
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 cert-manager 安装 Linkerd
- en: Once cert-manager is set up to issue certs, we need to install Linkerd so that
    it knows to use the certificates that cert-manager is managing, as shown in [Figure 7-9](#rotation-with-cert-manager).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 cert-manager 设置好发布证书，我们需要安装 Linkerd，以便它知道使用 cert-manager 管理的证书，如[图 7-9](#rotation-with-cert-manager)所示。
- en: You’ll remember that in [Chapter 3](ch03.html#LUAR_deploying_linkerd) we went
    through the various ways to install Linkerd. We’ll use Helm for our installation,
    as shown in [Example 7-4](#EX9-4), since we recommend that folks hoping to run
    Linkerd in production install Linkerd with Helm.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，在[第三章](ch03.html#LUAR_deploying_linkerd)中，我们讨论了安装 Linkerd 的各种方法。我们将使用 Helm
    进行安装，如[示例 7-4](#EX9-4)所示，因为我们建议希望在生产环境中运行 Linkerd 的人使用 Helm 来安装 Linkerd。
- en: Example 7-4\. Installing Linkerd with cert-manager
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. 使用 cert-manager 安装 Linkerd
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that, you now have a fully functional Linkerd instance with an actively
    and automatically rotating issuer certificate. You’ve added a significant amount
    of security to your environment and ensured that your cluster will get new certificates
    on a regular basis. It’s important to actively monitor cert-manager and check
    that your certificates are being rotated regularly. An expired issuer certificate
    is one of the few ways Linkerd can actively take down your applications, and its
    health and safety is critical to your platform.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您现在拥有一个完全功能的 Linkerd 实例，并且具有主动和自动轮换颁发者证书。您已经为您的环境添加了大量安全性，并确保您的集群定期获得新的证书。积极监控
    cert-manager 并检查您的证书是否定期轮换非常重要。过期的颁发者证书是 Linkerd 可以主动关闭您的应用程序的少数方式之一，其健康和安全对您的平台至关重要。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve covered a lot of ground in this chapter. mTLS and certificate handling
    are complex topics, even though they’ve been around for a long time. The challenge
    is that to properly secure a cloud native application, right now you need to know
    more about this stuff than you might like.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中涵盖了大量内容。即使 mTLS 和证书处理已经存在很长时间，但它们仍然是复杂的主题。挑战在于，为了正确保护云原生应用程序，您现在需要比您可能希望了解更多关于这些内容。
- en: 'One of the ways that Linkerd simplifies the process of hardening your environment
    is making mTLS effectively automatic, allowing any Linkerd user to rely on mTLS’s
    well-trusted identity and encryption mechanisms for secure communications. Another
    way is that Linkerd gives you control over critical certificate management operations:
    Linkerd’s ability to issue certificates for your application’s workloads, then
    rotate them frequently and automatically, gives you some powerful tools you need
    to reduce the likelihood and impact of any security incident.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Linkerd 简化您强化环境流程的一种方式是使 mTLS 成为有效自动化，允许任何 Linkerd 用户依赖于 mTLS 的广受信任的身份验证和加密机制来进行安全通信。另一种方式是，Linkerd
    让您控制关键的证书管理操作：Linkerd 能够为您的应用程序工作负载颁发证书，然后频繁且自动地轮换它们，为您减少安全事件的可能性和影响提供了一些强大的工具。
