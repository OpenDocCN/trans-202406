- en: Chapter 7\. mTLS, Linkerd, and Certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving from a monolithic application to a microservices application puts us
    in a very interesting position as far as security is concerned. Where the monolith
    provided a natural security perimeter at the edge of its process, a microservices
    application has no natural security perimeter at all. Sensitive information that
    was previously protected by being passed in a function call inside the process
    now has to be sent over the network, as shown in [Figure 7-1](#monolith-vs-microservices).
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0701](assets/luar_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Security stance in a monolithic versus a microservices application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Additionally, the microservices are often running on infrastructure and network
    resources provided by outside teams, organizations, or even companies. If nothing
    is done to counter the threat, it’s all too easy for an attacker with access to
    the network to read, intercept, and modify communications between microservices.
    This is obviously a serious problem.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the network doesn’t even provide any secure way for a given microservice
    to know who made a call to it. The called microservice can find out the caller’s
    IP and MAC addresses, but these aren’t actually secure—it’s very easy to spoof
    the sender’s IP address, for example. Things just get worse when the application
    is running on a network it doesn’t control.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To allow any microservices application to work, we need *secure communications*.
    There are three distinct elements to truly secure communications:'
  prefs: []
  type: TYPE_NORMAL
- en: Authenticity
  prefs: []
  type: TYPE_NORMAL
- en: We must be confident that we are talking to who we think we’re talking to.
  prefs: []
  type: TYPE_NORMAL
- en: Confidentiality
  prefs: []
  type: TYPE_NORMAL
- en: We must be confident that no one can read the data being sent over the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Integrity
  prefs: []
  type: TYPE_NORMAL
- en: We must be confident that our messages haven’t been altered in transit.
  prefs: []
  type: TYPE_NORMAL
- en: 'These aren’t new problems, and many different techniques have evolved to address
    them in various ways. Linkerd relies on one of the most trusted of these: *mutual
    TLS*, or *mTLS*.'
  prefs: []
  type: TYPE_NORMAL
- en: TLS and mTLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TLS, defined by [RFC 8446](https://oreil.ly/K6Wwg), is a battle-tested, industry-standard
    mechanism for secure communications that dates back to 1999. It’s the same mechanism
    that web browsers have used for years to securely communicate with banks, shopping
    sites, etc. The modern Internet has been relying on TLS for nearly 25 years, and
    cryptanalysts have being trying for at least that long to find weaknesses in it.
    TLS provides authenticity, confidentiality, and integrity using the architecture
    shown in [Figure 7-2](#tls-architecture-diagram-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0702](assets/luar_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. TLS architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: (Linkerd specifically uses TLS version 1.3, but all TLS versions have used the
    same architecture.)
  prefs: []
  type: TYPE_NORMAL
- en: TLS ensures confidentiality by encrypting data in transit and integrity by adding
    message digests—cryptographic checksums—so that the receiver can validate that
    the data sent hasn’t been altered. This takes care of two of our three concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticity is more complex. TLS uses *certificates* to cryptographically allow
    validating the identity of both the sender and the receiver. The TLS standard
    always requires the receiving end to identify itself by sending a certificate.
    In many cases, this is all that’s needed; for example, when you use your web browser
    to visit a shopping site, it’s not terribly useful for your browser to send a
    certificate since the shopping site will require you to log in separately.
  prefs: []
  type: TYPE_NORMAL
- en: For a service mesh, though, we need to authenticate both ends of the connection.
    This means we require both ends to send certificates for identification. When
    we use TLS like this (as Linkerd does), we call it mutual TLS or mTLS to distinguish
    it from the case where only the receiver identifies itself. This is shown in [Figure 7-3](#tls-vs-mtls).
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0703](assets/luar_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. TLS compared to mTLS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Using certificates in both directions lets mTLS build on the guarantees provided
    by TLS: it provides a cryptographically validated identity of the client as well
    as the server, while still maintaining encryption in transit. For Linkerd, this
    means that mTLS guarantees that your workloads know whom they’re talking to and
    that no third party will be able to intercept or listen in on their communication.'
  prefs: []
  type: TYPE_NORMAL
- en: mTLS and Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we first discussed in [Chapter 2](ch02.html#LUAR_intro_to_linkerd), the
    certificates that mTLS relies on are built on keypairs consisting of a public
    key and a private key. The private key (of course) needs to be kept private: only
    the entity that the keypair identifies can know it. The public key, on the other
    hand, should be widely distributed: it’s what allows verifying the identity of
    the entity holding the private key, so everyone who needs to communicate with
    that entity needs the public key.'
  prefs: []
  type: TYPE_NORMAL
- en: Certificates give us a way to associate a *name* and other metadata with the
    keypair, which is useful because it allows us humans to more easily work with
    the certificate. They also give us a way for one certificate to attest that another
    is valid (*signing* or *issuing* a certificate), which is useful because it makes
    it much simpler to determine whether or not we trust a certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using certificates to sign other certificates creates a *trust hierarchy*,
    as shown in [Figure 7-4](#certificate-hierarchy-diagram-2). This hierarchy is
    important: mTLS can know that a certificate is valid as long as it has access
    to any of the public keys higher up in the hierarchy, and systems built on mTLS
    (including Linkerd) take advantage of this property.'
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0704](assets/luar_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. The certificate trust hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, it’s important to limit the lifespan of a given keypair: the longer
    a key is used, the greater the danger if it’s compromised. Every so often, we
    need to replace the keys in use for a given certificate. This involves creating
    a new keypair, then generating a new certificate, and finally getting it properly
    signed. This entire process is called *rotating* the certificate; it is the main
    source of operational complexity when working with certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd and mTLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linkerd transparently adds mTLS to all of your interapplication communications.
    This means that all meshed traffic is protected against interception and tampering.
    It also means your workloads can be certain of which workloads they’re communicating
    with at all times.
  prefs: []
  type: TYPE_NORMAL
- en: This can only work if every meshed workload has a valid TLS certificate associated
    with that workload, and if all these *workload certificates* are part of the same
    trust hierarchy. Managing this by hand would be incredibly difficult, so Linkerd
    helps to automate it.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about adding workloads to the mesh in [Chapter 4](ch04.html#LUAR_meshing_workloads),
    but let’s revisit that in a bit more detail. When a workload is added to the mesh,
    it gets a `linkerd2-proxy` container added to its Pod. That container will be
    configured to intercept all TCP traffic going into and out of the Pod, and it
    will always attempt to build an mTLS session when a connection is made with another
    Pod. If the other Pod also has a `linkerd2-proxy`—meaning that it’s part of the
    mesh!—then the connection will be protected with mTLS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this mTLS connection happens from proxy to proxy, the application containers
    within the Pods never even know that mTLS is happening: from an application perspective,
    all communications between Pods look like they’re using cleartext. This means
    that the application Pods don’t see any information about the certificates that
    Linkerd is using, which in turn means that they don’t need any special code to
    handle certificate information.'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Detection and the Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that the proxy intercepts *all* communication between Pods means that
    you may sometimes need to give it extra information about the protocol, or indeed
    not try to do mTLS. This is all covered at some length in [Chapter 4](ch04.html#LUAR_meshing_workloads),
    but a good rule of thumb is that as long as the client speaks first, you’re probably
    OK. If the server speaks first, you’ll need to do some configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, that’s only true if the server is in the mesh! If you’re trying
    to communicate from a meshed Pod to an unmeshed Pod, you will always need to tell
    Linkerd to skip the traffic: it won’t be able to do mTLS without the destination
    Pod being part of the mesh.'
  prefs: []
  type: TYPE_NORMAL
- en: Certificates and Linkerd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about Linkerd certificates back in [Chapter 3](ch03.html#LUAR_deploying_linkerd).
    In this section, we’ll go into more detail about exactly what these certificates
    are used for, how they are created, and what needs to happen when you want to
    rotate them. We’re going to cover the three tiers of certificates used in Linkerd:
    trust anchor, identity issuer, and workload certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: From Linkerd’s point of view, trust starts with its trust anchor certificate,
    as shown in [Figure 7-5](#linkerd-trust-diagram-2). The trust anchor can, of course,
    be signed by some other higher-level certificate—as far as Linkerd is concerned,
    though, trust stops with the trust anchor.
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0705](assets/luar_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. The Linkerd trust hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Linkerd automatically handles the generation, distribution, and rotation of
    workload certificates, while relying on the user to manage the trust anchor and
    the identity issuer. This is shown in [Figure 7-6](#linkerd-certificate-management).
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0706](assets/luar_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Linkerd certificate management
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Never Let Your Certificates Expire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Linkerd requires mTLS connections between Pods by default, the health
    and security of the certificates it uses are absolutely critical to the healthy
    operation of the mesh—and thus your platform. If certificates expire, or can’t
    be generated for new Pods, *you will incur downtime*.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most common cause of downtime in production Linkerd clusters. Understanding
    and monitoring your Linkerd certificates is vital.
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd Trust Anchor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Linkerd *trust anchor* is the certificate that provides the foundation
    for all trust in your cluster. It is used for exactly two things:'
  prefs: []
  type: TYPE_NORMAL
- en: When installing Linkerd, you will use the trust anchor to issue the Linkerd
    identity issuer certificate, which we’ll discuss in the next section. This requires
    access to both the private and public keys of the trust anchor and is something
    done outside of Linkerd, before installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a workload makes an mTLS connection to another workload, both workloads
    use the identity issuer and the trust anchor to verify the identity of the other
    workload. This requires access to only the public key of the trust anchor and
    happens constantly while the mesh is operating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since only the public key is needed for in-cluster operations (the second bullet
    in the preceding list), we recommend that you never store your trust anchor’s
    private key in your Kubernetes cluster. Instead, store the trust anchor in a secure
    system outside of Kubernetes and only copy its public key into the cluster, as
    we’ll cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'One very important thing to realize is that the trust anchor is not intrinsically
    tied to a cluster: it is completely independent of network topology or cluster
    boundaries. This means that if you give multiple clusters the same trust anchor,
    they’ll be able to do secure mTLS between workloads in different clusters, as
    shown in [Figure 7-7](#multicluster-trust-hierarchy-1). This is extremely powerful,
    as it makes multicluster meshes very easy to set up.'
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0707](assets/luar_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. Multicluster trust hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Correspondingly, two clusters that should *not* be able to communicate with
    each other should *not* share a trust anchor! For most organizations, this implies
    not sharing trust anchors across environment tiers—that is, test clusters shouldn’t
    have the same trust anchor as development or production clusters.
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd Identity Issuer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the second level of the Linkerd trust hierarchy is the identity issuer certificate,
    as we also briefly touched on in [Chapter 3](ch03.html#LUAR_deploying_linkerd).
    The identity issuer is used by the Linkerd control plane’s identity controller
    to issue workload certificates, as shown in [Figure 7-8](#issuer-certificate-diagram).
    Since the identity issuer is used to sign certificates, Linkerd must have access
    to both the private and public keys of the identity issuer certificate, which
    means that it must be stored in a Secret in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0708](assets/luar_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. The issuer certificate and the identity controller
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The identity issuer must be signed by the trust anchor, and since it must be
    stored in the cluster, each cluster must have its own identity issuer.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd Cannot Warn You If You Share Identity Issuer Certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There isn’t any good way for Linkerd to warn you if you accidentally use the
    same identity issuer certificate in two clusters, and in fact everything will
    work. *Don’t do this*, though. If you do, the two clusters will become indistinguishable,
    and an evildoer will potentially be able to use one cluster to create a workload
    certificate that can bypass authorization policy in the other cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that each cluster has a unique identity issuer.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd Workload Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we come to the certificates that actually do the work of providing
    mTLS between our applications. When a workload is added to a Linkerd mesh, the
    Linkerd proxy associated with each workload Pod automatically requests a workload
    certificate from the Linkerd identity controller. This workload certificate is
    the basis for the workload’s identity. It will be signed by the identity issuer
    certificate, and since every other workload has access to the public keys of the
    identity issuer and the trust anchor, the validity of the workload certificate
    can be verified all the way back to the trust anchor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workload certificate for each Pod is cryptographically linked to the Kubernetes
    ServiceAccount assigned to the Pod, and its name includes the name of the ServiceAccount
    and the namespace. This allows your Pods to be uniquely identified when they communicate
    with each other. It also provides us with the identity we will need later when
    we build policy. The basic format for the identity name is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where `$clusterDomain` will be `cluster.local` if you haven’t overridden it.
    (Most single-cluster Linkerd installations won’t need to override this.)
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd handles workload certificates completely automatically; you should never
    need to worry about managing them.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Lifetimes and Rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, the longer you use a given key, the more valuable it
    tends to be to break that key. For this reason, certificates are given fixed lifespans,
    and they must be replaced before they expire. Replacing a certificate with a new
    one is called *rotating* the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing exactly how often to rotate certificates is a balancing act. Rotating
    very frequently is most secure, but it can disrupt normal operations and require
    an impractical amount of effort. Rotating very infrequently—or not at all—is very
    simple, but also very insecure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linkerd handles rotating workload certificates for you: by default, workload
    certificates expire every 24 hours. However, rotating the identity issuer and
    trust anchor certificates is left up to you, since your organization’s policy
    will often dictate how often you’ll be rotating. The critical things to consider
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time you rotate the trust anchor, you *must* also rotate the identity
    issuer.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the trust anchor must sign the identity issuer. If you’ve just
    generated a new trust anchor, there’s no way the old identity issuer can be signed
    by the new trust anchor, so you need a new identity issuer too.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, this means that you *cannot* rotate the trust anchor more often than
    the identity issuer.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you rotate the identity issuer, you *may* also rotate the workload
    certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Since workload certificates are automatically rotated by Linkerd, when you rotate
    the identity issuer you can opt to just wait for Linkerd to rotate the workload
    certificates. If you want to be sure they’re rotated immediately, just restart
    the workloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you rotate a certificate depends on which certificate it is:'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the trust anchor
  prefs: []
  type: TYPE_NORMAL
- en: 'Rotating the trust anchor is actually out of scope for this book: in practice,
    if you adhere to the principle that clusters themselves should be ephemeral, it
    can be more practical to simply have the lifespan of the trust anchor mirror that
    of the cluster. You can find more about rotating the trust anchor in the [official
    Linkerd docs](https://oreil.ly/9fAPV).'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the identity issuer
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the identity issuer is a basic operational task in Linkerd. Ideally,
    you’ll automate rotating the identity issuer with a tool like Venafi’s [cert-manager](https://cert-manager.io),
    and we show how to do this in this chapter. You can also manually rotate the trust
    anchor using the procedure shown in the [official Linkerd docs](https://oreil.ly/CN9IB).
  prefs: []
  type: TYPE_NORMAL
- en: Whether you automate identity issuer rotation or do it manually, it is critical
    that you practice rotating the identity issuer *before* the identity issuer expires.
    Having a mechanism that you’ve never tested can be worse than not having anything
    set up at all.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the workload certificates
  prefs: []
  type: TYPE_NORMAL
- en: Workload certificates are automatically rotated by the Linkerd control plane,
    so you should almost never need to deal with them. (As noted previously, if you
    *do* want to rotate a workload certificate, just restart the workload.)
  prefs: []
  type: TYPE_NORMAL
- en: By default, workload certificates are valid for 24 hours, and the control plane
    will begin attempting to rotate a workload certificate once it’s hit 70% of its
    effective lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning Workload Certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If needed, you can tune the lifespan of workload certificates by setting the
    `issuanceLifetime` value when installing Linkerd, but recognize that there are
    two important operational concerns if you reduce this value.
  prefs: []
  type: TYPE_NORMAL
- en: First, you increase the frequency with which your Pods communicate with the
    identity controller, which increases the load on the identity controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you reduce the amount of time you have to address problems with renewals.
    The proxy will begin attempting to renew at 70% of the lifespan: for a 24-hour
    lifespan, this means it will start trying with about 7 hours to go before the
    certificate expires, giving you about 7 hours to solve any problems that come
    up. If the whole lifespan is just 2 hours, you’ll only have about half an hour
    to work with if anything goes wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: As you have likely surmised, we’ve only skimmed the surface of how certificates
    work in general, and in Linkerd in particular, but you should now have more than
    enough information to understand how certificates are used in Linkerd.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Management in Linkerd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be clear at this point that certificate management is a critical part
    of securing a production Linkerd installation. Properly managing certificates
    is an important way to reduce the likelihood of an incident. It can also help
    minimize time to recovery and the overall impact if something does go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, our recommendations for everyone using Linkerd for any kind
    of production use are:'
  prefs: []
  type: TYPE_NORMAL
- en: Couple the life of the trust anchor to the life of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: It’s definitely possible to rotate the trust anchor, but treating the entire
    cluster as ephemeral and periodically rotating the whole cluster tends to make
    disaster recovery and provider migration ultimately simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Automate rotating the identity issuer.
  prefs: []
  type: TYPE_NORMAL
- en: It’s definitely possible to manage the identity issuer by hand, but we *strongly*
    recommend using a tool like cert-manager to regularly rotate the identity issuer
    certificate every few days instead. This shorter lifespan for the identity issuer
    can dramatically limit the scope of any incident, and using cert-manager makes
    it almost unnoticeable.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Certificate Management with cert-manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Venafi’s cert-manager is a CNCF project that manages automatic certificate generation
    and rotation, as shown in [Figure 7-9](#rotation-with-cert-manager). We’re not
    going to cover the detailed inner workings of cert-manager (that’s beyond the
    scope of this book); instead, we’re going to focus on the concepts required to
    understand how to use cert-manager with Linkerd.
  prefs: []
  type: TYPE_NORMAL
- en: '![luar 0709](assets/luar_0709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. Automatic issuer certificate rotation with cert-manager
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Installing cert-manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start by installing cert-manager using Helm to manage our install, as shown
    in [Example 7-1](#EX9-1). To follow along, you’ll need the following tools available
    in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k3d` or another tool for getting a local Kubernetes cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`helm3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 7-1\. Installing cert-manager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Software Versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be aware that our examples are using specific versions to make sure that things
    work at the time of this writing. There may be more updated versions available
    by the time you read this, though; make sure you’re using appropriate versions.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring cert-manager for Linkerd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While a deep dive into cert-manager is out of scope for this book, it’s definitely
    worth discussing its overall architecture for our use case. cert-manager is configured
    with Issuer and Certificate resources: an Issuer resource tells cert-manager where
    to find the keys it needs to issue a certificate, and a Certificate resource tells
    cert-manager which Issuer to use for a specific certificate.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, as shown in [Figure 7-9](#rotation-with-cert-manager), we’ll create
    an Issuer that holds the trust anchor keys and a Certificate that describes how
    to use that Issuer to get a Linkerd issuer certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned at the beginning of the chapter that you never want to add your
    root CA’s private key to your Kubernetes cluster. Because standing up an external
    key store is out of scope for this book, we’re going to break that rule in [Example 7-2](#EX9-2)
    and use cert-manager with the trust anchor stored in a Kubernetes Secret. In any
    real production environment you would *not* do this, but the overall setup will
    stay the same, with one Issuer and one Certificate: you’ll just change the Issuer
    definition to use your external agent instead. (cert-manager supports many different
    external agents; see [the documentation](https://oreil.ly/f5354).)'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the Trust Anchor Key out of the Cluster!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, *do not* use this setup in production. It can be made safer, but having
    your trust anchor’s secret key in the cluster will never be as safe as having
    it exist only in an external store.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Generating certificates for Linkerd
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go back over what we just did. We started by installing cert-manager into
    our cluster, which will automate the process of issuing and rotating certificates.
    We then created a trust anchor and told cert-manager to use that certificate to
    automatically create and rotate Linkerd’s issuer certificate. The issuer certificate
    is an intermediary CA that Linkerd will use to create, distribute, and rotate
    the individual workload certificates. cert-manager will rotate the issuer certificate
    every 48 hours, as we defined in its Certificate object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a quick tour around our cluster, as shown in [Example 7-3](#EX9-3),
    to see what cert-manager will actually do with this setup.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. Looking around
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that out of the way, we can now install Linkerd.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Linkerd using cert-manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once cert-manager is set up to issue certs, we need to install Linkerd so that
    it knows to use the certificates that cert-manager is managing, as shown in [Figure 7-9](#rotation-with-cert-manager).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll remember that in [Chapter 3](ch03.html#LUAR_deploying_linkerd) we went
    through the various ways to install Linkerd. We’ll use Helm for our installation,
    as shown in [Example 7-4](#EX9-4), since we recommend that folks hoping to run
    Linkerd in production install Linkerd with Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. Installing Linkerd with cert-manager
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With that, you now have a fully functional Linkerd instance with an actively
    and automatically rotating issuer certificate. You’ve added a significant amount
    of security to your environment and ensured that your cluster will get new certificates
    on a regular basis. It’s important to actively monitor cert-manager and check
    that your certificates are being rotated regularly. An expired issuer certificate
    is one of the few ways Linkerd can actively take down your applications, and its
    health and safety is critical to your platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered a lot of ground in this chapter. mTLS and certificate handling
    are complex topics, even though they’ve been around for a long time. The challenge
    is that to properly secure a cloud native application, right now you need to know
    more about this stuff than you might like.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the ways that Linkerd simplifies the process of hardening your environment
    is making mTLS effectively automatic, allowing any Linkerd user to rely on mTLS’s
    well-trusted identity and encryption mechanisms for secure communications. Another
    way is that Linkerd gives you control over critical certificate management operations:
    Linkerd’s ability to issue certificates for your application’s workloads, then
    rotate them frequently and automatically, gives you some powerful tools you need
    to reduce the likelihood and impact of any security incident.'
  prefs: []
  type: TYPE_NORMAL
