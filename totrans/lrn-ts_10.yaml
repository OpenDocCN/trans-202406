- en: Chapter 8\. Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functional devs
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try to *never* use classes
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Too intense for me
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The world of JavaScript during TypeScript’s creation and release in the early
    2010s was quite different from today. Features such as arrow functions and `let`/`const`
    variables that would later be standardized in ES2015 were still distant hopes
    on the horizon. Babel was a few years away from its first commit; its predecessor
    tools such as Traceur that converted newer JavaScript syntax to old hadn’t achieved
    full mainstream adoption.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s early marketing and feature set were tailored to that world. In
    addition to its type checking, its transpiler was emphasized—with classes as a
    frequent example. Nowadays TypeScript’s class support is just one feature among
    many to support all JavaScript language features. TypeScript neither encourages
    nor discourages class use or any other popular JavaScript pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Class Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript generally understands methods the same way it understands standalone
    functions. Parameter types default to `any` unless given a type or default value;
    calling the method requires an acceptable number of arguments; return types can
    generally be inferred if the function is not recursive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code snippet defines a `Greeter` class with a `greet` class method that
    takes in a single required parameter of type `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Class constructors are treated like typical class methods with regards to their
    parameters. TypeScript will perform type checking to make sure a correct number
    of arguments with correct types are provided to method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Greeted` constructor also expects its `message: string` parameter to
    be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I’ll cover constructors in the context of subclasses later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Class Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To read from or write to a property on a class in TypeScript, it must be explicitly
    declared in the class. Class properties are declared using the same syntax as
    interfaces: their name followed optionally by a type annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript will not attempt to deduce what members may exist on a class from
    their assignments in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `destination` is allowed to be assigned to and accessed on
    instances of the `FieldTrip` class because it is explicitly declared as a `string`.
    The `this.nonexistent` assignment in the constructor is not allowed because the
    class does not declare a `nonexistent` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly declaring class properties allows TypeScript to quickly understand
    what is or is not allowed to exist on instances of classes. Later, when class
    instances are in use, TypeScript uses that understanding to give a type error
    if code attempts to access a member of a class instance not known to exist, such
    as with this continuation’s `trip.nonexistent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Function Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s recap some JavaScript method scoping and syntax fundamentals for a bit,
    as they can be surprising if you’re not accustomed to them. JavaScript contains
    two syntaxes for declaring a member on a class to be a callable function: *method*
    and *property*.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve already shown the method approach of putting parentheses after the member
    name, like `myFunction() {}`. The method approach assigns a function to the class
    prototype, so all class instances use the same function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `WithMethod` class declares a `myMethod` method that all instances are
    able to refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The other syntax is to declare a property whose value happens to be a function.
    This creates a new function per instance of the class, which can be useful with
    `() =>` arrow functions whose `this` scope should always point to the class instance
    (at the time and memory cost of creating a new function per class instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'This `WithProperty` class contains a single property of name `myProperty` and
    type `() => void` that will be re-created for each class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Function properties can be given parameters and return types using the same
    syntax as class methods and standalone functions. After all, they’re a value assigned
    to a class member and the value happens to be a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `WithPropertyParameters` class has a `takesParameters` property of type
    `(input: string) => number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Initialization Checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With strict compiler settings enabled, TypeScript will check that each property
    declared whose type does not include `undefined` is assigned a value in the constructor.
    This strict initialization checking is useful because it prevents code from accidentally
    forgetting to assign a value to a class property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `WithValue` class does not assign a value to its `unused` property,
    which TypeScript recognizes as a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Without strict initialization checking, a class instance could be allowed to
    access a value that might be `undefined` even though the type system says it can’t
    be.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example would compile happily if strict initialization checking didn’t
    happen, but the resultant JavaScript would crash at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The billion-dollar mistake strikes again!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring strict property initialization checking with TypeScript’s `strictPropertyInitialization`
    compiler option is covered in [Chapter 12, “Using IDE Features”](ch12.xhtml#using_ide_features).
  prefs: []
  type: TYPE_NORMAL
- en: Definitely assigned properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although strict initialization checking is useful most of the time, you may
    come across some cases where a class property is intentionally able to be unassigned
    after the class constructor. If you are absolutely sure a property should not
    have strict initialization checking applied to it, you can add a `!` after its
    name to disable the check. Doing so asserts to TypeScript that the property will
    be assigned a value other than `undefined` before its first usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ActivitiesQueue` class is meant to be re-initialized any number of times
    separately from its constructor, so its `pending` property must be asserted with
    a `!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Needing to disable strict initialization checking on a class property is often
    a sign of code being set up in a way that doesn’t lend itself well to type checking.
    Instead of adding a `!` assertion and reducing type safety for the property, consider
    refactoring the class to no longer need the assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like interfaces, classes in TypeScript may declare a property as optional
    by adding a `?` after its declaration name. Optional properties behave roughly
    the same as properties whose types happen to be a union that includes `| undefined`.
    Strict initialization checking won’t mind if they’re not explicitly set in their
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `OptionalProperty` class marks its `property` as optional, so it’s allowed
    to not be assigned in the class constructor regardless of strict property initialization
    checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Read-Only Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again much like interfaces, classes in TypeScript may declare a property as
    read-only by adding the `readonly` keyword before its declaration name. The `readonly`
    keyword exists purely within the type system and is removed when compiling to
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Properties declared as `readonly` may only be assigned initial values where
    they are declared or in a constructor. Any other location—including methods on
    the class itself—may only read from the properties, not write to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `text` property on the `Quote` class is given a value
    in the constructor, but the other uses cause type errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: External users of your code, such as consumers of any npm packages you published,
    might not respect `readonly` modifiers—especially if they’re writing JavaScript
    and don’t have type checking. If you need true read-only protection, consider
    using `#` private fields and/or `get()` function properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties declared as `readonly` with an initial value of a primitive have
    a slight quirk compared to other properties: they are inferred to be their value’s
    narrowed *literal* type if possible, rather than the wider *primitive*. TypeScript
    feels comfortable with a more aggressive initial type narrowing because it knows
    the value won’t be changed later; it is similar to `const` variables taking on
    narrower types than `let` variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the class properties are both initially declared as a string
    literal, so in order to widen one of them to `string`, a type annotation is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Widening a property’s type explicitly is not necessary very often. Still, it
    can sometimes be useful in the case of conditional logic in constructors like
    the one in `RandomQuote`.
  prefs: []
  type: TYPE_NORMAL
- en: Classes as Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are relatively unique in the type system in that a class declaration
    creates both a runtime value—the class itself—as well as a type that can be used
    in type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of this `Teacher` class is used to annotate a `teacher` variable,
    telling TypeScript that it should be assigned only values that are assignable
    to the `Teacher` class—such as instances of the `Teacher` class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, TypeScript will consider any object type that happens to include
    all the same members of a class to be assignable to the class. This is because
    TypeScript’s structural typing cares only about the shape of objects, not how
    they’re declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `withSchoolBus` takes in a parameter of type `SchoolBus`. That can be
    satisfied by any object that happens to have a `getAbilities` property of type
    `() => string[]`, such as an instance of the `SchoolBus` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In most real-world code, developers don’t pass object values in places that
    ask for class types. This structural checking behavior may seem unexpected but
    doesn’t come up very often.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 7, “Interfaces”](ch07.xhtml#interfaces), I showed you how interfaces
    allow TypeScript developers to set up expectations for object shapes in code.
    TypeScript allows a class to declare its instances as adhering to an interface
    by adding the `implements` keyword after the class name, followed by the name
    of an interface. Doing so indicates to TypeScript that instances of the class
    should be assignable to each of those interfaces. Any mismatches would be called
    out as type errors by the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `Student` class correctly implements the `Learner` interface
    by including its property `name` and method `study`, but `Slacker` is missing
    a `study` and thus results in a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Interfaces meant to be implemented by classes are a typical reason to use the
    method syntax for declaring an interface member as a function—as used by the `Learner`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marking a class as implementing an interface doesn’t change anything about
    how the class is used. If the class already happened to match up to the interface,
    TypeScript’s type checker would have allowed its instances to be used in places
    where an instance of the interface is required anyway. TypeScript won’t even infer
    the types of methods or properties on the class from the interface: if we had
    added a `study(hours) {}` method to the `Slacker` example, TypeScript would consider
    the `hours` parameter an implicit `any` unless we gave it a type annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the `Student` class causes implicit `any` type errors because
    it doesn’t provide type annotations on its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Implementing an interface is purely a safety check. It does not copy any interface
    members onto the class definition for you. Rather, implementing an interface signals
    your intention to the type checker and surfaces type errors in the class definition,
    rather than later on where class instances are used. It’s similar in purpose to
    adding a type annotation to a variable even though it has an initial value.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Multiple Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes in TypeScript are allowed to be declared as implementing multiple interfaces.
    The list of implemented interfaces for a class may be any number of interface
    names with commas in-between.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, both classes are required to have at least a `grades` property
    to implement `Graded` and a `report` property to implement `Reporter`. The `Empty`
    class has two type errors for failing to implement either of the interfaces properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In practice, there may be some interfaces whose definitions make it impossible
    to have a class implement both. Attempting to declare a class implementing two
    conflicting interfaces will result in at least one type error on the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `AgeIsANumber` and `AgeIsNotANumber` interfaces declare very
    different types for an `age` property. Neither the `AsNumber` class nor `NotAsNumber`
    class properly implement both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Cases where two interfaces describe very different object shapes generally indicate
    you shouldn’t try to implement them with the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript adds type checking onto the JavaScript concept of a class extending,
    or subclassing, another class. To start, any method or property declared on a
    base class will be available on the subclass, also known as the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `Teacher` declares a `teach` method that may be used by instances
    of the `StudentTeacher` subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Extension Assignability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subclasses inherit members from their base class much like derived interfaces
    extend base interfaces. Instances of subclasses have all the members of their
    base class and thus may be used wherever an instance of the base is required.
    If a base class doesn’t have all the members a subclass does, then it can’t be
    used when the more specific subclass is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances of the following `Lesson` class may not be used where instances of
    its derived `OnlineLesson` are required, but derived instances may be used to
    satisfy either the base or subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Per TypeScript’s structural typing, if all the members on a subclass already
    exist on its base class with the same type, then instances of the base class are
    still allowed to be used in place of the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `LabeledPastGrades` only adds an optional property to `PastGrades`,
    so instances of the base class may be used in place of the subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In most real-world code, subclasses generally add new required type information
    on top of their base class. This structural checking behavior may seem unexpected
    but doesn’t come up very often.
  prefs: []
  type: TYPE_NORMAL
- en: Overridden Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with vanilla JavaScript, subclasses are not required by TypeScript to define
    their own constructor. Subclasses without their own constructor implicitly use
    the constructor from their base class.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, if a subclass does declare its own constructor, then it must
    call its base class constructor via the `super` keyword. Subclass constructors
    may declare any parameters regardless of what their base class requires. TypeScript’s
    type checker will make sure that the call to the base class constructor uses the
    correct parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `PassingAnnouncer`’s constructor correctly calls the base
    constructor with a `number` argument, while `FailingAnnouncer` gets a type error
    for forgetting to make that call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As per JavaScript rules, the constructor of a subclass must call the base constructor
    before accessing `this` or `super`. TypeScript will report a type error if it
    sees a `this` or `super` being accessed before `super()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `ContinuedGradesTally` class erroneously refers to `this.grades`
    in its constructor before calling to `super()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Overridden Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subclasses may redeclare new methods with the same names as the base class,
    as long as the method on the subclass method is assignable to the method on the
    base class. Remember, since subclasses can be used wherever the original class
    is used, the types of the new methods must be usable in place of the original
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `FailureCounter`’s `countGrades` method is permitted because
    it has the same first parameter and return type as the base `GradeCounter`’s `countGrades`
    method. `AnyFailureChecker`’s `countGrades` causes a type error for having the
    wrong return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Overridden Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subclasses may also explicitly redeclare properties of their base class with
    the same name, as long as the new type is assignable to the type on the base class.
    As with overridden methods, subclasses must structurally match up with base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Most subclasses that redeclare properties do so either to make those properties
    a more specific subset of a type union or to make the properties a type that extends
    from the base class property’s type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the base class `Assignment` declares its `grade` to be `number
    |` `undefined`, while the subclass `GradedAssignment` declares it as a `number`
    that must always exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Expanding the allowed set of values of a property’s union type is not allowed,
    as doing so would make the subclass property no longer assignable to the base
    class property’s type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `VagueGrade`’s `value` tries to add `| string` on top of the
    base class `NumericGrade`’s `number` type, causing a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Abstract Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can sometimes be useful to create a base class that doesn’t itself declare
    the implementation of some methods, but instead expects a subclass to provide
    them. Marking a class as abstract is done by adding TypeScript’s `abstract` keyword
    in front of the class name and in front of any method intended to be abstract.
    Those abstract method declarations skip providing a body in the abstract base
    class; instead, they are declared the same way an interface would be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `School` class and its `getStudentTypes` method are marked
    as `abstract`. Its subclasses—`Preschool` and `Absence`—are therefore expected
    to implement `getStudentTypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: An abstract class cannot be instantiated directly, as it doesn’t have definitions
    for some methods that its implementation may assume do exist. Only nonabstract
    (“concrete”) classes can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the `School` example, attempting to call `new School` would result
    in a TypeScript type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Abstract classes are often used in frameworks where consumers are expected
    to fill out details of a class. The class may be used as a type annotation to
    indicate values must adhere to the class—as with the earlier example of `school:
    School`—but creating new instances must be done with subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: Member Visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript includes the ability to start the name of a class member with `#`
    to mark it as a “private” class member. Private class members may only be accessed
    by instances of that class. JavaScript runtimes enforce that privacy by throwing
    an error if an area of code outside the class tries to access the private method
    or property.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript’s class support predates JavaScript’s true `#` privacy, and while
    TypeScript supports private class members, it also allows a slightly more nuanced
    set of privacy definitions on class methods and properties that exist solely in
    the type system. TypeScript’s member visibilities are achieved by adding one of
    the following keywords before the declaration name of a class member:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` (default)'
  prefs: []
  type: TYPE_NORMAL
- en: Allowed to be accessed by anybody, anywhere
  prefs: []
  type: TYPE_NORMAL
- en: '`protected`'
  prefs: []
  type: TYPE_NORMAL
- en: Allowed to be accessed only by the class itself and its subclasses
  prefs: []
  type: TYPE_NORMAL
- en: '`private`'
  prefs: []
  type: TYPE_NORMAL
- en: Allowed to be accessed only by the class itself
  prefs: []
  type: TYPE_NORMAL
- en: These keywords exist purely within the type system. They’re removed along with
    all other type system syntax when the code is compiled to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `Base` declares two `public` members, one `protected`, one `private`,
    and one true private with `#truePrivate`. `Subclass` is allowed to access the
    `public` and `protected` members but not `private` or `#truePrivate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The key difference between TypeScript’s member visibilities and JavaScript’s
    true private declarations is that TypeScript’s exist only in the type system,
    while JavaScript’s also exist at runtime. A TypeScript class member declared as
    `protected` or `private` will compile to the same JavaScript code as if they were
    declared `public` explicitly or implicitly. As with interfaces and type annotations,
    visibility keywords are erased when outputting JavaScript. Only `#` private fields
    are truly private in runtime JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility modifiers may be marked along with `readonly`. To declare a member
    both as `readonly` and with an explicit visibility, the visibility comes first.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `TwoKeywords` class declares its `name` member as both `private` and `readonly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is not permitted to mix TypeScript’s old member visibility keyword
    with JavaScript’s new `#` private fields. Private fields are always private by
    default, so there’s no need to additionally mark them with the `private` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Static Field Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript allows declaring members on a class itself—rather than its instances—using
    the `static` keyword. TypeScript supports using the `static` keyword on its own
    and/or with `readonly` and/or with one of the visibility keywords. When combined,
    the visibility keyword comes first, then `static`, then `readonly`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `HasStatic` class puts them all together to make its `static` `prompt`
    and `answer` properties both `readonly` and `protected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using read-only and/or visibility modifiers to static class fields is useful
    for restricting those fields from being accessed or modified outside their class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced a plethora of type system features and syntaxes around
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and using class methods and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking properties `readonly` and/or optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using class names as types in type annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing interfaces to enforce class instance shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending classes, along with assignability and override rules for subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking classes and methods as abstract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding type system modifiers to class fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/classes*](https://learningtypescript.com/classes).
  prefs: []
  type: TYPE_NORMAL
- en: Why do object-oriented programming developers always wear suits?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because they’ve got class.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
