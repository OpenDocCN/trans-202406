<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Modular JavaScript Design Patterns"><div class="chapter" id="modern-modular-javascript-design-patterns">
<h1><span class="label">Chapter 10. </span>Modular JavaScript Design Patterns</h1>


<p>In the world of scalable JavaScript,<a data-type="indexterm" data-primary="modular design patterns" data-secondary="about" id="idm45017694928832"/><a data-type="indexterm" data-primary="modules" data-secondary="modular defined" data-seealso="modular design patterns" id="idm45017694927984"/><a data-type="indexterm" data-primary="modular design patterns" data-secondary="about" data-tertiary="modules" data-seealso="Module pattern; modules" id="idm45017694926896"/><a data-type="indexterm" data-primary="loose coupling" data-secondary="decoupling applications via modularity" id="idm45017694925568"/><a data-type="indexterm" data-primary="dependencies" data-secondary="decoupling applications via modularity" id="idm45017694924656"/><a data-type="indexterm" data-primary="coupling" data-secondary="decoupling applications via modularity" id="idm45017694923744"/><a data-type="indexterm" data-primary="decoupling" data-secondary="applications in modern JavaScript" id="idm45017694922832"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="modern syntax and features" data-tertiary="modules for decoupling applications" id="idm45017694921920"/><a data-type="indexterm" data-primary="modules" data-secondary="decoupling applications" id="idm45017694920768"/><a data-type="indexterm" data-primary="applications decoupled in JavaScript" id="idm45017694919824"/> when we say an application is <em>modular</em>, we often mean it’s composed of a set of highly decoupled, distinct pieces of functionality stored in modules.  Loose coupling facilitates easier maintainability of apps by removing <em>dependencies</em> where possible. When implemented efficiently, it becomes pretty easy to see how changes to one part of a system may affect another.</p>

<p>In the earlier chapters, we covered the importance of modular programming and the modern way of implementing modular design patterns. While <a href="https://oreil.ly/Pcc5o">ES2015</a> introduced native modules to JavaScript, writing modular JavaScript was still possible before 2015.</p>

<p>In this section, we will look at three formats for modular JavaScript using classic JavaScript (ES5) syntax: Asynchronous Module Definition (AMD), CommonJS, and Universal Module Definition (UMD). To learn more about JavaScript modules, please refer to <a data-type="xref" href="ch05.xhtml#modern-javascript-syntax">Chapter 5</a>, which covers ES2015+ syntax for module imports, exports, and more.</p>






<section data-type="sect1" data-pdf-bookmark="A Note on Script Loaders"><div class="sect1" id="a-note-on-script-loaders">
<h1>A Note on Script Loaders</h1>

<p>It isn’t easy to discuss AMD and<a data-type="indexterm" data-primary="script loaders" id="idm45017694914288"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="script loaders" id="idm45017694913584"/><a data-type="indexterm" data-primary="CommonJS" data-secondary="script loaders" id="idm45017694912624"/><a data-type="indexterm" data-primary="RequireJS" id="idm45017694911680"/><a data-type="indexterm" data-primary="curl.js" id="idm45017694911008"/> CommonJS modules without talking about <a href="https://oreil.ly/ssCQT">script loaders</a>. Script loading was a means to a goal. Modular JavaScript could be implemented only using compatible script loaders.</p>

<p>Several great loaders were available for handling module loading in the AMD and CommonJS formats, but I personally preferred <a href="https://oreil.ly/Ri_9R">RequireJS</a> and <a href="https://oreil.ly/s7QRg">curl.js</a>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="AMD"><div class="sect1" id="amd">
<h1>AMD</h1>

<p>The<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" id="ch10-amd"/><a data-type="indexterm" data-primary="modular design patterns" data-secondary="AMD (Asynchronous Module Definition)" id="ch10-amd2"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="about" id="idm45017694903104"/><a data-type="indexterm" data-primary="modules" data-secondary="AMD module format overview" data-seealso="AMD (Asynchronous Module Definition)" id="idm45017694902144"/><a data-type="indexterm" data-primary="APIs" data-secondary="AMD" data-seealso="AMD (Asynchronous Module Definition)" id="idm45017694900896"/> AMD format was introduced as a proposal for defining modules in which both the module and dependencies can be <a href="https://oreil.ly/iTNe3">asynchronously loaded</a>. The overall goal for the AMD format is to provide a solution for modular JavaScript that developers could use. It has several distinct advantages, including being both asynchronous and highly flexible by nature, which removes the tight coupling one might commonly find between code and module identity. Many developers enjoyed using AMD, and one could consider it a reliable stepping stone toward <a href="https://oreil.ly/yxADG">JavaScript modules</a>, which were unavailable at the time.</p>

<p>AMD began as a draft specification for a module format on the CommonJS list, but as it couldn’t reach full consensus, further development of the format moved to the <a href="https://oreil.ly/0-XeU">amdjs group</a>.</p>

<p>It was embraced by projects including Dojo, MooTools, and even jQuery. Although the term <em>CommonJS AMD format</em> has been seen in the wild occasionally, it’s best to refer to it as just AMD or Async Module support because not all participants on the CommonJS list wished to pursue it.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There was a time when the proposal was referred to as Modules Transport/C. However, because the spec wasn’t geared toward transporting existing CommonJS modules but rather for defining modules, it made more sense to opt for the AMD naming 
<span class="keep-together">convention.</span></p>
</div>








<section data-type="sect2" data-pdf-bookmark="Getting Started with Modules"><div class="sect2" id="getting-started-with-modules">
<h2>Getting Started with Modules</h2>

<p>The first two concepts worth noting about<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="define() method for module definition" id="idm45017694891696"/><a data-type="indexterm" data-primary="define() method for AMD module definition" id="idm45017694890640"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="require() method for module dependencies" id="idm45017694889872"/><a data-type="indexterm" data-primary="require() method for AMD module dependencies" id="idm45017694888880"/><a data-type="indexterm" data-primary="dependencies" data-secondary="require() method for module dependencies" id="idm45017694888176"/> AMD are the ideas of a <code>define</code> method for facilitating module definition and a <code>require</code> method for handling dependency loading. <code>define</code> is used to define named or unnamed modules using the following 
<span class="keep-together">signature:</span></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">define</code><code class="p">(</code>
    <code class="nx">module_id</code> <code class="cm">/*optional*/</code><code class="p">,</code>
    <code class="p">[</code><code class="nx">dependencies</code><code class="p">]</code> <code class="cm">/*optional*/</code><code class="p">,</code>
    <code class="nx">definition</code> <code class="kd">function</code> <code class="p">{}</code> <code class="cm">/*function for instantiating the module or object*/</code>
<code class="p">);</code></pre>

<p>As we can tell by the inline comments, the <code>module_id</code> is an optional argument that is typically required only when non-AMD concatenation tools are being used (there may be some other edge cases where it’s useful, too). When this argument is left out, we refer to the module as <em>anonymous</em>.<a data-type="indexterm" data-primary="define() method for AMD module definition" data-secondary="anonymous modules" id="idm45017694879376"/><a data-type="indexterm" data-primary="modules" data-secondary="anonymous modules" id="idm45017694859984"/><a data-type="indexterm" data-primary="anonymous modules" id="idm45017694859152"/></p>

<p>When working with anonymous modules, the idea of a module’s identity is DRY (Don’t repeat yourself), making it trivial to avoid duplication of filenames and code. Because the code is more portable, it can be easily moved to other locations (or around the filesystem) without needing to alter the code itself or change its module ID. Consider the <code>module_id</code> similar to the concept of folder paths.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Developers can run this same code on multiple environments using an AMD optimizer that works with a CommonJS environment such as <a href="https://oreil.ly/48dSL">r.js</a>.</p>
</div>

<p>Back to the <code>define</code> signature, the <code>dependencies</code> argument represents an array of dependencies required by the module we are defining, and the third argument 
<span class="keep-together">(<code>definition</code></span> <code>function</code> or <code>factory function</code>) is a function that’s executed to instantiate our module. A bare bones module could be defined as in <a data-type="xref" href="#understanding_AMD_define">Example 10-1</a>.</p>
<div id="understanding_AMD_define" data-type="example">
<h5><span class="label">Example 10-1. </span>Understanding AMD: <code>define()</code></h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// A module_id (myModule) is used here for demonstration purposes only</code>
<code class="nx">define</code><code class="p">(</code> <code class="s2">"myModule"</code><code class="p">,</code>

    <code class="p">[</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">],</code>

    <code class="c1">// module definition function</code>
    <code class="c1">// dependencies (foo and bar) are mapped to function parameters</code>
    <code class="kd">function</code> <code class="p">(</code> <code class="nx">foo</code><code class="p">,</code> <code class="nx">bar</code> <code class="p">)</code> <code class="p">{</code>
        <code class="c1">// return a value that defines the module export</code>
        <code class="c1">// (i.e., the functionality we want to expose for consumption)</code>

        <code class="c1">// create your module here</code>
        <code class="kd">var</code> <code class="nx">myModule</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">doStuff</code><code class="o">:</code><code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"Yay! Stuff"</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code>

    <code class="k">return</code> <code class="nx">myModule</code><code class="p">;</code>
<code class="p">});</code>

<code class="c1">// An alternative version could be...</code>
<code class="nx">define</code><code class="p">(</code> <code class="s2">"myModule"</code><code class="p">,</code>

    <code class="p">[</code><code class="s2">"math"</code><code class="p">,</code> <code class="s2">"graph"</code><code class="p">],</code>

    <code class="kd">function</code> <code class="p">(</code> <code class="nx">math</code><code class="p">,</code> <code class="nx">graph</code> <code class="p">)</code> <code class="p">{</code>

        <code class="c1">// Note that this is a slightly different pattern</code>
        <code class="c1">// With AMD, it's possible to define modules in a few</code>
        <code class="c1">// different ways due to its flexibility with</code>
        <code class="c1">// certain aspects of the syntax</code>
        <code class="k">return</code> <code class="p">{</code>
            <code class="nx">plot</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">){</code>
                <code class="k">return</code> <code class="nx">graph</code><code class="p">.</code><code class="nx">drawPie</code><code class="p">(</code> <code class="nx">math</code><code class="p">.</code><code class="nx">randomGrid</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">)</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code>
<code class="p">});</code></pre></div>

<p>On the other hand, <code>require</code> is typically<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="require() method for module dependencies" id="ch10-req"/><a data-type="indexterm" data-primary="require() method for AMD module dependencies" id="ch10-req2"/><a data-type="indexterm" data-primary="dependencies" data-secondary="require() method for module dependencies" id="ch10-req3"/> used to load code in a top-level JavaScript file or within a module should we wish to fetch dependencies dynamically. An example of its usage is in <a data-type="xref" href="#understanding_AMD_require">Example 10-2</a>.</p>
<div id="understanding_AMD_require" data-type="example">
<h5><span class="label">Example 10-2. </span>Understanding AMD: <code>require()</code></h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Consider "foo" and "bar" are two external modules</code>
<code class="c1">// In this example, the "exports" from the two modules</code>
<code class="c1">// loaded are passed as function arguments to the</code>
<code class="c1">// callback (foo and bar) so that they can similarly be accessed</code>

<code class="nx">require</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">],</code> <code class="kd">function</code> <code class="p">(</code> <code class="nx">foo</code><code class="p">,</code> <code class="nx">bar</code> <code class="p">)</code> <code class="p">{</code>
        <code class="c1">// rest of your code here</code>
        <code class="nx">foo</code><code class="p">.</code><code class="nx">doSomething</code><code class="p">();</code>
<code class="p">});</code></pre></div>

<p><a data-type="xref" href="#dynamically-loaded-dependencies">Example 10-3</a> shows a dynamically loaded dependency:</p>
<div id="dynamically-loaded-dependencies" data-type="example">
<h5><span class="label">Example 10-3. </span>Dynamically loaded dependencies</h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">define</code><code class="p">(</code><code class="kd">function</code> <code class="p">(</code> <code class="nx">require</code> <code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">isReady</code> <code class="o">=</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">foobar</code><code class="p">;</code>

    <code class="c1">// note the inline require within our module definition</code>
    <code class="nx">require</code><code class="p">([</code><code class="s2">"foo"</code><code class="p">,</code> <code class="s2">"bar"</code><code class="p">],</code> <code class="kd">function</code> <code class="p">(</code> <code class="nx">foo</code><code class="p">,</code> <code class="nx">bar</code> <code class="p">)</code> <code class="p">{</code>
        <code class="nx">isReady</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
        <code class="nx">foobar</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">()</code> <code class="o">+</code> <code class="nx">bar</code><code class="p">();</code>
    <code class="p">});</code>

    <code class="c1">// we can still return a module</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">isReady</code><code class="o">:</code> <code class="nx">isReady</code><code class="p">,</code>
        <code class="nx">foobar</code><code class="o">:</code> <code class="nx">foobar</code>
    <code class="p">};</code>
<code class="p">});</code></pre></div>

<p><a data-type="xref" href="#understanding-amd-plugins">Example 10-4</a> shows defining an AMD-compatible plug-in.<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="require() method for module dependencies" data-tertiary="plug-in defined" id="idm45017694602960"/><a data-type="indexterm" data-primary="require() method for AMD module dependencies" data-secondary="plug-in definition example" id="idm45017694581216"/><a data-type="indexterm" data-primary="plug-ins defined via AMD require" id="idm45017694580320"/></p>
<div id="understanding-amd-plugins" data-type="example" class="pagebreak-before less_space">
<h5><span class="label">Example 10-4. </span>Understanding AMD: plug-ins</h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// With AMD, it's possible to load in assets of almost any kind</code>
<code class="c1">// including text-files and HTML. This enables us to have template</code>
<code class="c1">// dependencies which can be used to skin components either on</code>
<code class="c1">// page-load or dynamically.</code>

<code class="nx">define</code><code class="p">(</code> <code class="p">[</code><code class="s2">"./templates"</code><code class="p">,</code> <code class="s2">"text!./template.md"</code><code class="p">,</code><code class="s2">"css!./template.css"</code> <code class="p">],</code>

    <code class="kd">function</code><code class="p">(</code> <code class="nx">templates</code><code class="p">,</code> <code class="nx">template</code> <code class="p">){</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">templates</code> <code class="p">);</code>
        <code class="c1">// do something with our templates here</code>
    <code class="p">}</code>

<code class="p">});</code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Although <code>css!</code> is included for loading<a data-type="indexterm" data-primary="CSS (Cascading Style Sheets)" data-secondary="loaded with AMD require" id="idm45017694504112"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="require() method for module dependencies" data-tertiary="CSS loading" id="idm45017694503232"/><a data-type="indexterm" data-primary="require() method for AMD module dependencies" data-secondary="CSS loading" id="idm45017694502080"/> Cascading Style Sheets (CSS) dependencies in the preceding example, it’s important to remember that this approach has some caveats, such as not being able to establish when the CSS is fully loaded. Depending on how we approach our build process, it may also result in CSS being included as a dependency in the optimized file, so use CSS as a loaded dependency in such cases with caution. If you’re interested in doing this, we can explore <a href="https://oreil.ly/PrLim">@VIISON’s RequireJS CSS plug-in</a>.</p>
</div>

<p>This example could simply be looked at as <code>requirejs(["app/myModule"], 
<span class="keep-together">function(){})</span></code>, which indicates the loader’s top-level globals are being used. This is how to kick off the top-level loading of modules with different AMD loaders. However, if a <code>define()</code> function is passed as a local require, all <code>require([]</code>) examples apply to both types of loader: curl.js and RequireJS (Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#loading-amd-using-requirejs">10-5</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#loading-amd-using-curljs">10-6</a>).<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="script loaders" data-tertiary="RequireJS for AMD modules" id="idm45017694495136"/><a data-type="indexterm" data-primary="RequireJS" data-secondary="AMD module loading" id="idm45017694493808"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="script loaders" data-tertiary="curl.js for AMD modules" id="idm45017694492864"/><a data-type="indexterm" data-primary="curl.js" data-secondary="AMD module loading" id="idm45017694491632"/><a data-type="indexterm" data-primary="script loaders" data-secondary="AMD supported" data-tertiary="curl.js for AMD modules" id="idm45017694490688"/><a data-type="indexterm" data-primary="script loaders" data-secondary="AMD supported" data-tertiary="RequireJS for AMD modules" id="idm45017694489472"/><a data-type="indexterm" data-primary="RequireJS" id="idm45017694461056"/><a data-type="indexterm" data-primary="curl.js" id="idm45017694460528"/><a data-type="indexterm" data-primary="Yabble" id="idm45017694459856"/><a data-type="indexterm" data-primary="PINF" id="idm45017694459184"/></p>
<div id="loading-amd-using-requirejs" data-type="example">
<h5><span class="label">Example 10-5. </span>Loading AMD modules using RequireJS</h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">require</code><code class="p">([</code><code class="s2">"app/myModule"</code><code class="p">],</code>

    <code class="kd">function</code><code class="p">(</code> <code class="nx">myModule</code> <code class="p">){</code>
        <code class="c1">// start the main module which in turn</code>
        <code class="c1">// loads other modules</code>
        <code class="kd">var</code> <code class="nx">module</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">myModule</code><code class="p">();</code>
        <code class="nx">module</code><code class="p">.</code><code class="nx">doStuff</code><code class="p">();</code>
<code class="p">});</code></pre></div>
<div id="loading-amd-using-curljs" data-type="example" class="less_space pagebreak-before">
<h5><span class="label">Example 10-6. </span>Loading AMD modules using curl.js</h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">curl</code><code class="p">([</code><code class="s2">"app/myModule.js"</code><code class="p">],</code>

    <code class="kd">function</code><code class="p">(</code> <code class="nx">myModule</code> <code class="p">){</code>
        <code class="c1">// start the main module which in turn</code>
        <code class="c1">// loads other modules</code>
        <code class="kd">var</code> <code class="nx">module</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">myModule</code><code class="p">();</code>
        <code class="nx">module</code><code class="p">.</code><code class="nx">doStuff</code><code class="p">();</code>

<code class="p">});</code></pre></div>

<p>What follows is the code for modules with deferred dependencies:<a data-type="indexterm" data-startref="ch10-req" id="idm45017694377728"/><a data-type="indexterm" data-startref="ch10-req2" id="idm45017694377120"/><a data-type="indexterm" data-startref="ch10-req3" id="idm45017694376512"/><a data-type="indexterm" data-primary="dependencies" data-secondary="require() method for module dependencies" data-tertiary="deferred dependencies" id="idm45017694375872"/><a data-type="indexterm" data-primary="require() method for AMD module dependencies" data-secondary="deferred dependencies" id="idm45017694374688"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="require() method for module dependencies" data-tertiary="deferred dependencies" id="idm45017694373776"/><a data-type="indexterm" data-primary="deferred dependencies via require() method" id="idm45017694372624"/></p>

<pre data-type="programlisting" data-code-language="html"><code class="p">&lt;</code><code class="nt">pre</code> <code class="na">xmlns</code><code class="o">=</code><code class="s">"http://www.w3.org/1999/xhtml"</code> <code class="na">id</code><code class="o">=</code><code class="s">"I_programlisting11_id234274"</code>
<code class="na">data-type</code><code class="o">=</code><code class="s">"programlisting"</code> <code class="na">data-code-language</code><code class="o">=</code><code class="s">"javascript"</code><code class="p">&gt;</code>


// This could be compatible with jQuery's Deferred implementation,
// futures.js (slightly different syntax) or any one of a number
// of other implementations

define(["lib/Deferred"], function( Deferred ){
    var defer = new Deferred();

    require(["lib/templates/?index.html","lib/data/?stats"],
        function( template, data ){
            defer.resolve( { template: template, data:data } );
        }
    );
    return defer.promise();
});

<code class="p">&lt;/</code><code class="nt">pre</code><code class="p">&gt;</code></pre>

<p>As we’ve seen in previous sections, design patterns can be highly effective in improving how we approach structuring solutions to common development problems.<a data-type="indexterm" data-primary="modular design patterns" data-secondary="AMD (Asynchronous Module Definition)" data-tertiary="AMD module design patterns" id="idm45017694324432"/><a data-type="indexterm" data-primary="Hann, John" id="idm45017694323344"/> <a href="https://oreil.ly/SrQI5">John Hann</a> has given some excellent presentations about AMD module design patterns covering the Singleton, Decorator, Mediator, and others. I highly recommend checking out his <a href="https://oreil.ly/7koME">slides</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="AMD Modules with jQuery"><div class="sect2" id="amd-modules-with-jquery">
<h2>AMD Modules with jQuery</h2>

<p>jQuery comes with only one file. However, given the plug-in-based nature of the library, we can demonstrate how straightforward it is to define an AMD module that uses it here:<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="jQuery and" id="idm45017694319488"/><a data-type="indexterm" data-primary="jQuery" data-secondary="AMD modules with" id="idm45017694318544"/></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Code in app.js. baseURl set to the lib folder</code>
<code class="c1">// containing jquery, jquery.color, and lodash files.</code>
<code class="nx">define</code><code class="p">([</code><code class="s2">"jquery"</code><code class="p">,</code><code class="s2">"jquery.color"</code><code class="p">,</code><code class="s2">"lodash"</code><code class="p">],</code> <code class="kd">function</code><code class="p">(</code> <code class="nx">$</code><code class="p">,</code> <code class="nx">colorPlugin</code><code class="p">,</code> <code class="nx">_</code> <code class="p">){</code>
    <code class="c1">// Here we've passed in jQuery, the color plugin, and Lodash</code>
    <code class="c1">// None of these will be accessible in the global scope, but we</code>
    <code class="c1">// can easily reference them below.</code>

    <code class="c1">// Pseudorandomize an array of colors, selecting the first</code>
    <code class="c1">// item in the shuffled array</code>
    <code class="kd">var</code> <code class="nx">shuffleColor</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">first</code><code class="p">(</code> <code class="nx">_</code><code class="p">.</code><code class="nx">shuffle</code><code class="p">([</code><code class="s2">"#AAA"</code><code class="p">,</code><code class="s2">"#FFF"</code><code class="p">,</code><code class="s2">"#111"</code><code class="p">,</code><code class="s2">"#F16"</code><code class="p">]));</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">shuffleColor</code><code class="p">);</code>

    <code class="c1">// Animate the background color of any elements with the class</code>
    <code class="c1">// "item" on the page using the shuffled color</code>
    <code class="nx">$</code><code class="p">(</code> <code class="s2">".item"</code> <code class="p">).</code><code class="nx">animate</code><code class="p">(</code> <code class="p">{</code><code class="s2">"backgroundColor"</code><code class="o">:</code> <code class="nx">shuffleColor</code> <code class="p">}</code> <code class="p">);</code>

    <code class="c1">// What we return can be used by other modules</code>
    <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{};</code>
<code class="p">});</code></pre>

<p>However, there is something missing from this example, and it’s the registration 
<span class="keep-together">concept.</span></p>










<section data-type="sect3" data-pdf-bookmark="Registering jQuery as an async-compatible module"><div class="sect3" id="registering-jquery-as-an-async-compatible-module">
<h3>Registering jQuery as an async-compatible module</h3>

<p>One of the key features that landed<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="jQuery and" data-tertiary="registering jQuery as async module" id="idm45017694215408"/><a data-type="indexterm" data-primary="jQuery" data-secondary="AMD modules with" data-tertiary="registering jQuery as async module" id="idm45017694214224"/> in jQuery 1.7 was support for registering jQuery as an asynchronous module. A number of compatible script loaders (including RequireJS and curl) are capable of loading modules using an asynchronous module format, which means fewer hacks are required to get things working.</p>

<p>If a developer wants to use AMD and does not want her jQuery version leaking into the global space, she should call <code>noConflict</code> in their top-level module that uses jQuery. In addition, since multiple versions of jQuery can be on a page, there are special considerations that an AMD loader must account for, so jQuery only registers with AMD loaders that have recognized these concerns, which are indicated by the loader specifying <code>define.amd.jQuery</code>. RequireJS and curl are two loaders that do so.</p>

<p>The named AMD provides a robust and safe safety blanket for most use cases:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Account for the existence of more than one global</code>
<code class="c1">// instance of jQuery in the document, cater for testing</code>
<code class="c1">// .noConflict()</code>

<code class="kd">var</code> <code class="nx">jQuery</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">jQuery</code> <code class="o">||</code> <code class="s2">"jQuery"</code><code class="p">,</code>
<code class="nx">$</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">$</code> <code class="o">||</code> <code class="s2">"$"</code><code class="p">,</code>
<code class="nx">originaljQuery</code> <code class="o">=</code> <code class="nx">jQuery</code><code class="p">,</code>
<code class="nx">original$</code> <code class="o">=</code> <code class="nx">$</code><code class="p">;</code>

<code class="nx">define</code><code class="p">([</code><code class="s2">"jquery"</code><code class="p">]</code> <code class="p">,</code> <code class="kd">function</code> <code class="p">(</code> <code class="nx">$</code> <code class="p">)</code> <code class="p">{</code>
    <code class="nx">$</code><code class="p">(</code> <code class="s2">".items"</code> <code class="p">).</code><code class="nx">css</code><code class="p">(</code> <code class="s2">"background"</code><code class="p">,</code><code class="s2">"green"</code> <code class="p">);</code>
    <code class="k">return</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{};</code>
<code class="p">});</code></pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Why was AMD a better choice for writing modular JavaScript?"><div class="sect3" id="why-is-amd-a-better-choice-for-writing-modular-javascript">
<h3>Why was AMD a better choice for writing modular JavaScript?</h3>

<p>We have now reviewed several code<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="benefits of" id="idm45017694140016"/> samples taking us through what AMD is capable of. It appears to be more than just a typical Module pattern, but why was it a better choice for modular application development?</p>

<ul>
<li>
<p>Provides a clear proposal for how to approach defining flexible modules.</p>
</li>
<li>
<p>Significantly cleaner than the present global namespace and <code>&lt;script&gt;</code> tag solutions many of us rely on. There’s a clean way to declare standalone modules and dependencies they may have.</p>
</li>
<li>
<p>Module definitions are encapsulated, helping us to avoid pollution of the global namespace.</p>
</li>
<li>
<p>Arguably works better than some alternative solutions (e.g., CommonJS, which we’ll be looking at shortly). It doesn’t have issues with cross-domain, local, or debugging and doesn’t rely on server-side tools to be used. Most AMD loaders support loading modules in the browser without a build process.</p>
</li>
<li>
<p>Provides a “transport” approach for including multiple modules in a single file. Other approaches like CommonJS have yet to agree on a transport format.</p>
</li>
<li>
<p>It’s possible to lazy-load scripts if this is needed.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Most of the points mentioned are valid for YUI’s module-loading strategy.<a data-type="indexterm" data-primary="YUI library (Yahoo)" data-secondary="module-loading strategy" id="idm45017694087200"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="related reading links" id="idm45017694086320"/><a data-type="indexterm" data-primary="resources online" data-secondary="AMD related reading" id="idm45017694085408"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="script loaders" id="idm45017694084464"/><a data-type="indexterm" data-primary="script loaders" data-secondary="AMD supported" id="idm45017694083552"/></p>
</div>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Related reading for AMD"><div class="sect3" id="idm45017694082352">
<h3>Related reading for AMD</h3>

<ul>
<li>
<p><a href="https://oreil.ly/uPEJg">The RequireJS Guide to AMD</a></p>
</li>
<li>
<p><a href="https://oreil.ly/Z04H9">What’s the Fastest Way to Load AMD Modules?</a></p>
</li>
<li>
<p><a href="https://oreil.ly/W4Fqi">AMD vs. CommonJS, What’s the Better Format?</a></p>
</li>
<li>
<p><a href="https://oreil.ly/A9S7c">The Future Is Modules Not Frameworks</a></p>
</li>
<li>
<p><a href="https://oreil.ly/Tkti9">AMD No Longer a CommonJS Specification</a></p>
</li>
<li>
<p><a href="https://oreil.ly/AB01l">On Inventing JavaScript Module Formats and Script Loaders</a></p>
</li>
<li>
<p><a href="https://oreil.ly/jdTYO">The AMD Mailing List</a></p>
</li>
</ul>
</div></section>










<section data-type="sect3" class="pagebreak-before less_space" data-pdf-bookmark="Script loaders and frameworks that support AMD"><div class="sect3" id="what-script-loaders-frameworks-support-amd">
<h3>Script loaders and frameworks that support AMD</h3>

<p>In-browser:</p>

<ul>
<li>
<p><a href="https://oreil.ly/Ri_9R">RequireJS</a></p>
</li>
<li>
<p><a href="https://oreil.ly/fi105">curl.js</a></p>
</li>
<li>
<p><a href="https://oreil.ly/oBWDi">Yabble</a></p>
</li>
<li>
<p><a href="https://oreil.ly/C28-D">PINF</a></p>
</li>
<li>
<p>And more</p>
</li>
</ul>

<p>Server-side:</p>

<ul>
<li>
<p><a href="https://oreil.ly/Ri_9R">RequireJS</a></p>
</li>
<li>
<p><a href="https://oreil.ly/TJldu">PINF</a></p>
</li>
</ul>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="AMD Conclusions"><div class="sect2" id="amd-conclusions">
<h2>AMD Conclusions</h2>

<p>Having used AMD for several projects,<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="about" id="idm45017694057696"/> I conclude that it ticks a lot of the checkboxes that developers creating serious applications might desire from a better module format. It avoids the need to worry about globals, supports named modules, doesn’t require server transformation to function, and is a pleasure to use for dependency management.</p>

<p>It’s also an excellent addition for modular development using Backbone.js, ember.js, or other structural frameworks for keeping applications organized.</p>

<p>As AMD was heavily discussed within the Dojo and CommonJS worlds, we know it’s had time to mature and evolve. We also know it’s been battle-tested in the wild by a number of large companies to build nontrivial applications (IBM, BBC iPlayer), and so, if it didn’t work, chances are they would have abandoned it, but they didn’t.</p>

<p>That said, there are still areas where AMD could have been improved. Developers who have used the format for some time may feel the AMD boilerplate/wrapper code was an annoying overhead. While I share this concern, there were tools such as <a href="https://oreil.ly/TLSYv">Volo</a> that helped work around these issues, and I would argue that, on the whole, the pros with using AMD far outweighed the cons.<a data-type="indexterm" data-startref="ch10-amd" id="idm45017694054720"/><a data-type="indexterm" data-startref="ch10-amd2" id="idm45017694054016"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="CommonJS"><div class="sect1" id="commonjs">
<h1>CommonJS</h1>

<p>The CommonJS module proposal specifies<a data-type="indexterm" data-primary="CommonJS" id="ch10-cjs"/><a data-type="indexterm" data-primary="modular design patterns" data-secondary="CommonJS" id="ch10-cjs2"/><a data-type="indexterm" data-primary="CommonJS" data-secondary="about" id="idm45017694049184"/><a data-type="indexterm" data-primary="APIs" data-secondary="CommonJS" data-seealso="CommonJS" id="idm45017694048240"/> a simple API for declaring modules server-side. Unlike AMD, it attempts to cover broader concerns such as I/O, file-system, promises, and more.</p>

<p>Originally called ServerJS in a project<a data-type="indexterm" data-primary="Dangoor, Kevin" id="idm45017694046512"/> started by Kevin Dangoor back in 2009, the format was later formalized by <a href="https://oreil.ly/EUFt3">CommonJS</a>, a volunteer working group that aims to design, prototype, and standardize JavaScript APIs. They attempted to ratify standards for both <a href="https://oreil.ly/v_hsu">modules</a> and <a href="https://oreil.ly/Trgzj">packages</a>.</p>








<section data-type="sect2" data-pdf-bookmark="Getting Started"><div class="sect2" id="getting-started">
<h2>Getting Started</h2>

<p>From a structural perspective, a CommonJS module is a reusable piece of JavaScript that exports specific objects made available to any dependent code. Unlike AMD, there are typically no function wrappers around such modules (so we won’t see <code>define</code> here, for example).</p>

<p>CommonJS modules contain two primary parts: <a data-type="indexterm" data-primary="CommonJS" data-secondary="exports free variable" id="idm45017694040528"/><a data-type="indexterm" data-primary="export free variable for CommonJS" id="idm45017694039552"/><a data-type="indexterm" data-primary="CommonJS" data-secondary="require() function" id="idm45017694038912"/><a data-type="indexterm" data-primary="require() function for CommonJS" id="idm45017694037968"/>a free variable named <code>exports</code>, which includes the objects a module wishes to make available to other modules, and a <code>require</code> function that modules can use to import the exports of other modules (Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#understanding-common-js-exports">10-7</a>, <a data-type="xref" data-xrefstyle="select:labelnumber" href="#basic-consumption-of-exports">10-8</a>, and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#amd-equivalent-first-commonjs">10-9</a>).</p>
<div id="understanding-common-js-exports" data-type="example">
<h5><span class="label">Example 10-7. </span>Understanding CommonJS: <code>require()</code> and <code>exports</code></h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// package/lib is a dependency we require</code>
<code class="kd">var</code> <code class="nx">lib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"package/lib"</code><code class="p">);</code>

<code class="c1">// behavior for our module</code>
<code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
  <code class="nx">lib</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"hello world!"</code><code class="p">);</code>
<code class="p">}</code>

<code class="c1">// export (expose) foo to other modules</code>
<code class="nx">exports</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">;</code></pre></div>
<div id="basic-consumption-of-exports" data-type="example">
<h5><span class="label">Example 10-8. </span>Basic consumption of <code>exports</code></h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Import the module containing the foo function</code>
<code class="kd">var</code> <code class="nx">exampleModule</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"./example-10-9"</code><code class="p">);</code>

<code class="c1">// Consume the 'foo' function from the imported module</code>
<code class="nx">exampleModule</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code></pre></div>

<p>In <a data-type="xref" href="#basic-consumption-of-exports">Example 10-8</a>, we first import the module containing the <code>foo</code> function from <a data-type="xref" href="#understanding-common-js-exports">Example 10-7</a> using the <code>require()</code> function. Then, we consume the <code>foo</code> function by calling it from the imported module with <code>exampleModule.foo()</code>.</p>
<div id="amd-equivalent-first-commonjs" data-type="example" class="less_space pagebreak-before">
<h5><span class="label">Example 10-9. </span>AMD-equivalent of the first CommonJS example</h5>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// CommonJS module getting started</code>
<code class="c1">// AMD-equivalent of CommonJS example</code>
<code class="c1">// AMD module format</code>
<code class="nx">define</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">require</code><code class="p">){</code>
<code class="kd">var</code> <code class="nx">lib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code> <code class="s2">"package/lib"</code> <code class="p">);</code>

<code class="c1">// some behavior for our module</code>
<code class="kd">function</code> <code class="nx">foo</code><code class="p">(){</code>
   <code class="nx">lib</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"hello world!"</code> <code class="p">);</code>
<code class="p">}</code>

<code class="c1">// export (expose) foo for other modules</code>
<code class="k">return</code> <code class="p">{</code>
   <code class="nx">foobar</code><code class="o">:</code> <code class="nx">foo</code>
<code class="p">};</code>
<code class="p">});</code></pre></div>

<p>This can be done as AMD supports a<a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="CommonJS wrapping feature" id="idm45017693880720"/><a data-type="indexterm" data-primary="CommonJS" data-secondary="AMD supporting CommonJS wrapping feature" id="idm45017693903984"/> <a href="https://oreil.ly/IzG9s">simplified CommonJS wrapping</a> feature.<a data-type="indexterm" data-primary="CommonJS" data-secondary="consuming multiple dependencies" id="idm45017693902384"/><a data-type="indexterm" data-primary="dependencies" data-secondary="CommonJS consuming multiple" id="idm45017693901424"/><a data-type="indexterm" data-primary="export free variable for CommonJS" data-secondary="consuming multiple dependencies" id="idm45017693900464"/><a data-type="indexterm" data-primary="require() function for CommonJS" data-secondary="consuming multiple dependencies" id="idm45017693899488"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Consuming Multiple Dependencies"><div class="sect2" id="idm45017693898384">
<h2>Consuming Multiple Dependencies</h2>

<p><em>app.js</em>:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kd">var</code> <code class="nx">modA</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code> <code class="s2">"./foo"</code> <code class="p">);</code>
<code class="kd">var</code> <code class="nx">modB</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code> <code class="s2">"./bar"</code> <code class="p">);</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">app</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(){</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"Im an application!"</code> <code class="p">);</code>
<code class="p">}</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">foo</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(){</code>
    <code class="k">return</code> <code class="nx">modA</code><code class="p">.</code><code class="nx">helloWorld</code><code class="p">();</code>
<code class="p">}</code></pre>

<p><em>bar.js:</em></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">exports</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s2">"bar"</code><code class="p">;</code></pre>

<p><em>foo.js:</em></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">require</code><code class="p">(</code> <code class="s2">"./bar"</code> <code class="p">);</code>
<code class="nx">exports</code><code class="p">.</code><code class="nx">helloWorld</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(){</code>
    <code class="k">return</code> <code class="s2">"Hello World!!"</code>
<code class="p">}</code></pre>
</div></section>








<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="CommonJS in Node.js"><div class="sect2" id="idm45017695520336">
<h2>CommonJS in Node.js</h2>

<p>The ES module format has become<a data-type="indexterm" data-primary="CommonJS" data-secondary="Node.js" id="idm45017693744800"/><a data-type="indexterm" data-primary="Node.js (Node)" data-secondary="CommonJS" id="idm45017693743824"/> the standard format for encapsulating JavaScript code for reuse, but CommonJS is the default in Node.js. CommonJS modules are the original way to package JavaScript code for <a href="https://oreil.ly/4Bh_O">Node.js</a>, although starting with version 13.2.0, Node.js has stable support of ES modules.</p>

<p>By default, Node.js treats the following as CommonJS modules:<a data-type="indexterm" data-primary=".js extension for scripts" data-secondary="Node.js module support" data-primary-sortas="js" id="idm45017693741680"/></p>

<ul>
<li>
<p>Files with a <em>.cjs</em> extension</p>
</li>
<li>
<p>Files with a <em>.js</em> extension when the nearest parent <em>package.json</em> file contains a top-level field <em>type</em> with a value of <em>commonjs</em></p>
</li>
<li>
<p>Files with a <em>.js</em> extension when the nearest parent <em>package.json</em> file doesn’t contain a top-level field <em>type</em></p>
</li>
<li>
<p>Files with an extension that is not <em>.mjs</em>, <em>.cjs</em>, <em>.json</em>, <em>.node</em>, or <em>.js</em></p>
</li>
</ul>

<p>Calling <code>require()</code> always uses<a data-type="indexterm" data-primary="require() function for CommonJS" data-secondary="Node.js and CommonJS" id="idm45017693704832"/><a data-type="indexterm" data-primary="ECMAScript" data-secondary="Node.js calling import()" id="idm45017693703856"/> the CommonJS module loader, while calling <code>import()</code> always uses the ECMAScript module loader irrespective of the type value configured in the nearest parent <em>package.json</em>.</p>

<p>Many Node.js libraries and modules are written with CommonJS. For browser support, all major browsers support the ES module syntax, and you can use import/export in frameworks like React and Vue.js. These frameworks use a transpiler like Babel to compile the import/export syntax to <code>require()</code>, which older Node.js versions natively support. Libraries written using ES6 module syntax will be transpiled to CommonJS under the hood if you run the code in Node.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Is CommonJS Suitable for the Browser?"><div class="sect2" id="idm45017693700720">
<h2>Is CommonJS Suitable for the Browser?</h2>

<p>There are developers who feel that CommonJS<a data-type="indexterm" data-primary="CommonJS" data-secondary="browser suitability" id="idm45017693699024"/><a data-type="indexterm" data-primary="browsers" data-secondary="CommonJS suitability" id="idm45017693698048"/><a data-type="indexterm" data-primary="APIs" data-secondary="CommonJS" id="idm45017693697104"/> is better suited to server-side development, which is one reason there was a disagreement over whether AMD or CommonJS should be used as the de facto standard before ES2015. Some arguments against CommonJS were that many CommonJS APIs address server-oriented features that one would be unable to implement at a browser level in JavaScript—for example, <em>io</em>, <em>system</em>, and <em>js</em> could be considered unimplementable by the nature of their 
<span class="keep-together">functionality.</span></p>

<p>Regardless, it’s useful to know how to structure CommonJS modules so that we can better appreciate how they fit in when defining modules that may be used everywhere. Modules with applications on both the client and server include validation, conversion, and templating engines. <a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="benefits of" data-tertiary="CommonJS on server side" id="idm45017693693936"/>Some developers approached choosing which format to use by opting for CommonJS when a module can be used in a server-side environment and using AMD or ES2015 if this is not the case.</p>

<p>ES2015 and AMD modules can define more granular things like constructors and functions. CommonJS modules can only define objects, which can be tedious to work with if we’re trying to obtain constructors from them. For new projects in Node.js, ES2015 modules provide an alternative to CommonJS on the server and also ensure that the syntax is identical to the client-side code. Thus, it creates an easier route to isomorphic JavaScript, which can run in the browser or on the server.</p>

<p>Although it’s beyond the scope of this section,<a data-type="indexterm" data-primary="CommonJS" data-secondary="require() function" data-tertiary="AMD versus CommonJS" id="idm45017693691760"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="require() method for module dependencies" data-tertiary="CommonJS versus AMD" id="idm45017693690160"/><a data-type="indexterm" data-primary="require() function for CommonJS" data-secondary="AMD and CommonJS" id="idm45017693688832"/><a data-type="indexterm" data-primary="require() method for AMD module dependencies" data-secondary="CommonJS and AMD" id="idm45017693687872"/> you may have noticed that there were different types of <code>require</code> methods mentioned when discussing AMD and CommonJS. The concern with a similar naming convention is confusion, and the community is split on the merits of a global <code>require</code> function.<a data-type="indexterm" data-primary="Hann, John" id="idm45017693685968"/> John Hann’s suggestion here is that rather than calling it <code>require</code>, which would probably fail to achieve the goal of informing users about the different between a global and inner <code>require</code>, it may make more sense to rename the global loader method something else (e.g., the name of the library). It’s for this reason that a loader like curl.js uses <code>curl()</code> instead of <code>require</code>.<a data-type="indexterm" data-startref="ch10-cjs" id="idm45017693683312"/><a data-type="indexterm" data-startref="ch10-cjs2" id="idm45017693682576"/><a data-type="indexterm" data-primary="CommonJS" data-secondary="related reading links" id="idm45017693681904"/><a data-type="indexterm" data-primary="resources online" data-secondary="CommonJS related reading" id="idm45017693680960"/></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Related Reading for CommonJS"><div class="sect2" id="idm45017693680000">
<h2>Related Reading for CommonJS</h2>

<ul>
<li>
<p><a href="https://oreil.ly/NeuFT">JavaScript Growing Up</a></p>
</li>
<li>
<p><a href="https://oreil.ly/Nb-5e">The RequireJS Notes on CommonJS</a></p>
</li>
<li>
<p><a href="https://oreil.ly/ZpO5u">Taking Baby Steps with Node.js and CommonJS—Creating Custom Modules</a></p>
</li>
<li>
<p><a href="https://oreil.ly/gJhQA">Asynchronous CommonJS Modules for the Browser</a></p>
</li>
<li>
<p><a href="https://oreil.ly/rL3C2">The CommonJS Mailing List</a></p>
</li>
</ul>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="AMD and CommonJS: Competing, but Equally Valid Standards"><div class="sect1" id="amd-commonjs-competing-but-equally-valid-standards">
<h1>AMD and CommonJS: Competing, but Equally Valid Standards</h1>

<p>Both AMD and CommonJS are valid module formats with different end goals.<a data-type="indexterm" data-primary="modular design patterns" data-secondary="AMD and CommonJS equally valid" id="idm45017693670048"/><a data-type="indexterm" data-primary="CommonJS" data-secondary="AMD and CommonJS equally valid" id="idm45017693669056"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="CommonJS and AMD equally valid" id="idm45017693668096"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="about" id="idm45017693667120"/></p>

<p>AMD adopts a browser-first approach to development, opting for asynchronous behavior and simplified backward compatibility, but it doesn’t have any concept of file I/O. It supports objects, functions, constructors, strings, JSON, and many other types of modules, running natively in the browser. It’s incredibly flexible.</p>

<p>CommonJS, on the other hand,<a data-type="indexterm" data-primary="CommonJS" data-secondary="about" id="idm45017693665360"/> takes a server-first approach, assuming synchronous behavior, no global <em>baggage</em>, and attempts to cater to the future (on the server). What I mean by this is that because CommonJS supports unwrapped modules, it can feel a little closer to the ES2015+ specifications, freeing us of the <code>define()</code> wrapper that AMD enforces. CommonJS modules, however, support objects only as modules.</p>








<section data-type="sect2" data-pdf-bookmark="UMD: AMD and CommonJS-Compatible Modules for Plug-ins"><div class="sect2" id="umd-amd-and-commonjs-compatible-modules-for-plugins">
<h2>UMD: AMD and CommonJS-Compatible Modules for Plug-ins</h2>

<p>These solutions could be a little lacking<a data-type="indexterm" data-primary="modular design patterns" data-secondary="UMD (Universal Module Definition)" id="ch10-umd"/><a data-type="indexterm" data-primary="UMD (Universal Module Definition)" id="ch10-umd2"/><a data-type="indexterm" data-primary="Universal Module Definition" data-see="UMD" id="idm45017693659408"/><a data-type="indexterm" data-primary="UMD (Universal Module Definition)" data-secondary="about" id="idm45017693658400"/> for developers wishing to create modules that can work in browser and server-side environments. <a data-type="indexterm" data-primary="Burke, James" id="idm45017693657200"/>To help alleviate this, James Burke, I, and several other developers created <a href="https://oreil.ly/HaHHJ">Universal Module Definition (UMD)</a>.</p>

<p>UMD is an experimental module format that allows the definition of modules that work in both client and server environments with all or most of the popular script-loading techniques available at the time of writing. Although the idea of (yet) another module format may be daunting, we will cover UMD briefly for thoroughness.</p>

<p>We began defining UMD by looking at<a data-type="indexterm" data-primary="CommonJS" data-secondary="AMD supporting CommonJS wrapping feature" id="idm45017693654672"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="CommonJS wrapping feature" id="idm45017693653728"/> the simplified CommonJS wrapper supported in the AMD specification. Developers wishing to write modules as if they were CommonJS modules could use the following CommonJS-compatible format:</p>










<section data-type="sect3" data-pdf-bookmark="Basic AMD hybrid format"><div class="sect3" id="basic-amd-hybrid-format">
<h3>Basic AMD hybrid format</h3>

<pre data-type="programlisting" data-code-language="javascript"><code class="nx">define</code><code class="p">(</code> <code class="kd">function</code> <code class="p">(</code> <code class="nx">require</code><code class="p">,</code> <code class="nx">exports</code><code class="p">,</code> <code class="nx">module</code> <code class="p">){</code>

    <code class="kd">var</code> <code class="nx">shuffler</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code> <code class="s2">"lib/shuffle"</code> <code class="p">);</code>

    <code class="nx">exports</code><code class="p">.</code><code class="nx">randomize</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code> <code class="nx">input</code> <code class="p">){</code>
        <code class="k">return</code> <code class="nx">shuffler</code><code class="p">.</code><code class="nx">shuffle</code><code class="p">(</code> <code class="nx">input</code> <code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code></pre>

<p>It’s essential, however, to note that a module is really only treated as a CommonJS module if it doesn’t contain a dependency array and the definition function contains one parameter at minimum. This also won’t work correctly on some devices (e.g., the PS3). <a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="CommonJS wrapping feature" data-tertiary="documentation link" id="idm45017693634416"/><a data-type="indexterm" data-primary="CommonJS" data-secondary="AMD supporting CommonJS wrapping feature" data-tertiary="documentation link" id="idm45017693622592"/><a data-type="indexterm" data-primary="resources online" data-secondary="AMD-supported CommonJS wrapper documentation" id="idm45017693621504"/>For further information about the wrapper, see the <a href="https://oreil.ly/7A9k6">RequireJS documentation</a>.</p>

<p>Taking this further, we wanted to provide several different patterns that worked with AMD and CommonJS and solved typical compatibility problems developers wishing to develop such modules had with other environments.</p>

<p>One such variation we can see next allows us to use CommonJS, AMD, or browser globals to create a module.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Using CommonJS, AMD, or browser globals to create a module"><div class="sect3" id="using-commonjs-amd-or-browser-globals-to-create-a-module">
<h3>Using CommonJS, AMD, or browser globals to create a module</h3>

<p>Define a module <code>commonJsStrict</code>, which depends<a data-type="indexterm" data-primary="UMD (Universal Module Definition)" data-secondary="CommonJS, AMD, or browser globals creating module" id="idm45017693615824"/> on another module called <code>b</code>. The filename implies the module’s name, and it’s best practice for the filename and the exported global to have the same name.</p>

<p>If the module <code>b</code> also uses the same boilerplate type in the browser, it will create a global <code>.b</code> that is used.<a data-type="indexterm" data-primary="this keyword" data-secondary="instead of browser global reference" id="idm45017693612864"/> If we don’t wish to support the browser global patch, we can remove the <code>root</code> and pass <code>this</code> as the first argument to the top function:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="p">(</code><code class="kd">function</code> <code class="p">(</code> <code class="nx">root</code><code class="p">,</code> <code class="nx">factory</code> <code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code> <code class="k">typeof</code> <code class="nx">exports</code> <code class="o">===</code> <code class="s1">'object'</code> <code class="p">)</code> <code class="p">{</code>
        <code class="c1">// CommonJS</code>
        <code class="nx">factory</code><code class="p">(</code> <code class="nx">exports</code><code class="p">,</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'b'</code><code class="p">)</code> <code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code> <code class="k">typeof</code> <code class="nx">define</code> <code class="o">===</code> <code class="s1">'function'</code> <code class="o">&amp;&amp;</code> <code class="nx">define</code><code class="p">.</code><code class="nx">amd</code> <code class="p">)</code> <code class="p">{</code>
        <code class="c1">// AMD. Register as an anonymous module.</code>
        <code class="nx">define</code><code class="p">(</code> <code class="p">[</code><code class="s1">'exports'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code> <code class="nx">factory</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="c1">// Browser globals</code>
        <code class="nx">factory</code><code class="p">(</code> <code class="p">(</code><code class="nx">root</code><code class="p">.</code><code class="nx">commonJsStrict</code> <code class="o">=</code> <code class="p">{}),</code> <code class="nx">root</code><code class="p">.</code><code class="nx">b</code> <code class="p">);</code>
    <code class="p">}</code>
<code class="p">}(</code><code class="k">this</code><code class="p">,</code> <code class="kd">function</code> <code class="p">(</code> <code class="nx">exports</code><code class="p">,</code> <code class="nx">b</code> <code class="p">)</code> <code class="p">{</code>
    <code class="c1">//use b in some fashion.</code>

    <code class="c1">// attach properties to the exports object to define</code>
    <code class="c1">// the exported module properties.</code>
    <code class="nx">exports</code><code class="p">.</code><code class="nx">action</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{};</code>
<code class="p">}));</code></pre>

<p>The UMD repository contains variations covering modules that work optimally in the browser, those best for providing exports, those optimal for CommonJS runtimes, and even those that work best for defining jQuery plug-ins, which we will look at next.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="jQuery plug-ins that function in all environments"><div class="sect3" id="jquery-plugins-that-function-in-all-environments">
<h3>jQuery plug-ins that function in all environments</h3>

<p>UMD provides two patterns for working<a data-type="indexterm" data-primary="UMD (Universal Module Definition)" data-secondary="jQuery plug-ins for AMD, browser globals, CommonJS" id="ch10-umdplug"/><a data-type="indexterm" data-primary="jQuery" data-secondary="plug-ins for AMD, browser globals, CommonJS" id="ch10-umdplug2"/> with jQuery plug-ins: one that defines plug-ins that work well with AMD and browser globals and another that can also work in CommonJS environments. jQuery is not likely to be used in most CommonJS environments, so keep this in mind unless we’re working with an environment that does play well with it.</p>

<p>We will now define a plug-in composed of a core and an extension to that core. 
<span class="keep-together">The core</span> plug-in is loaded into a <code>$.core</code> namespace, which can then be easily 
<span class="keep-together">extended</span> using plug-in extensions via the namespacing pattern. Plug-ins loaded 
<span class="keep-together">via <code>script</code></span> tags automatically populate a <code>plugin</code> namespace under <code>core</code> (i.e., <code>$.core.plugin.methodName()</code>).</p>

<p>The pattern can be nice to work with, because plug-in extensions can access properties and methods defined in the base or, with a bit of tweaking, override default behavior so that it can be extended to do more. A loader is also not required to make any of this fully functional.</p>

<p>For more details of what is being done, please see the inline comments in these code samples.</p>

<p class="pagebreak-before"><em>usage.html:</em></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="o">&lt;</code><code class="nx">script</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"text/javascript"</code> <code class="nx">src</code><code class="o">=</code><code class="s2">"jquery.min.js"</code><code class="o">&gt;&lt;</code><code class="err">/script&gt;</code>
<code class="o">&lt;</code><code class="nx">script</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"text/javascript"</code> <code class="nx">src</code><code class="o">=</code><code class="s2">"pluginCore.js"</code><code class="o">&gt;&lt;</code><code class="err">/script&gt;</code>
<code class="o">&lt;</code><code class="nx">script</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"text/javascript"</code> <code class="nx">src</code><code class="o">=</code><code class="s2">"pluginExtension.js"</code><code class="o">&gt;&lt;</code><code class="err">/script&gt;</code>

<code class="o">&lt;</code><code class="nx">script</code> <code class="nx">type</code><code class="o">=</code><code class="s2">"text/javascript"</code><code class="o">&gt;</code>

<code class="nx">$</code><code class="p">(</code><code class="kd">function</code><code class="p">(){</code>

    <code class="c1">// Our plug-in "core" is exposed under a core namespace in</code>
    <code class="c1">// this example, which we first cache</code>
    <code class="kd">var</code> <code class="nx">core</code> <code class="o">=</code> <code class="nx">$</code><code class="p">.</code><code class="nx">core</code><code class="p">;</code>

    <code class="c1">// Then use some of the built-in core functionality to</code>
    <code class="c1">// highlight all divs in the page yellow</code>
    <code class="nx">core</code><code class="p">.</code><code class="nx">highlightAll</code><code class="p">();</code>

    <code class="c1">// Access the plug-ins (extensions) loaded into the "plugin"</code>
    <code class="c1">// namespace of our core module:</code>

    <code class="c1">// Set the first div in the page to have a green background.</code>
    <code class="nx">core</code><code class="p">.</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">setGreen</code><code class="p">(</code> <code class="s2">"div:first"</code><code class="p">);</code>
    <code class="c1">// Here we're making use of the core's "highlight" method</code>
    <code class="c1">// under the hood from a plug-in loaded in after it</code>

    <code class="c1">// Set the last div to the "errorColor" property defined in</code>
    <code class="c1">// our core module/plug-in. If we review the code further down,</code>
    <code class="c1">// we can see how easy it is to consume properties and methods</code>
    <code class="c1">// between the core and other plug-ins</code>
    <code class="nx">core</code><code class="p">.</code><code class="nx">plugin</code><code class="p">.</code><code class="nx">setRed</code><code class="p">(</code><code class="s2">"div:last"</code><code class="p">);</code>
<code class="p">});</code>

<code class="o">&lt;</code><code class="err">/script&gt;</code></pre>

<p><em>pluginCore.js:</em></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Module/plug-in core</code>
<code class="c1">// Note: the wrapper code we see around the module is what enables</code>
<code class="c1">// us to support multiple module formats and specifications by</code>
<code class="c1">// mapping the arguments defined to what a specific format expects</code>
<code class="c1">// to be present. Our actual module functionality is defined lower</code>
<code class="c1">// down, where a named module and exports are demonstrated.</code>
<code class="c1">//</code>
<code class="c1">// Note that dependencies can just as easily be declared if required</code>
<code class="c1">// and should work as demonstrated earlier with the AMD module examples.</code>

<code class="p">(</code><code class="kd">function</code> <code class="p">(</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">definition</code> <code class="p">){</code>
  <code class="kd">var</code> <code class="nx">theModule</code> <code class="o">=</code> <code class="nx">definition</code><code class="p">(),</code>
      <code class="c1">// this is considered "safe":</code>
      <code class="nx">hasDefine</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">define</code> <code class="o">===</code> <code class="s2">"function"</code> <code class="o">&amp;&amp;</code> <code class="nx">define</code><code class="p">.</code><code class="nx">amd</code><code class="p">,</code>
      <code class="nx">hasExports</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">module</code> <code class="o">!==</code> <code class="s2">"undefined"</code> <code class="o">&amp;&amp;</code> <code class="nx">module</code><code class="p">.</code><code class="nx">exports</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code> <code class="nx">hasDefine</code> <code class="p">){</code> <code class="c1">// AMD Module</code>
    <code class="nx">define</code><code class="p">(</code><code class="nx">theModule</code><code class="p">);</code>
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code> <code class="nx">hasExports</code> <code class="p">)</code> <code class="p">{</code> <code class="c1">// Node.js Module</code>
    <code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">theModule</code><code class="p">;</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code> <code class="c1">// Assign to common namespaces or simply the global object (window)</code>
    <code class="p">(</code> <code class="k">this</code><code class="p">.</code><code class="nx">jQuery</code> <code class="o">||</code> <code class="k">this</code><code class="p">.</code><code class="nx">ender</code> <code class="o">||</code> <code class="k">this</code><code class="p">.</code><code class="nx">$</code> <code class="o">||</code> <code class="k">this</code><code class="p">)[</code><code class="nx">name</code><code class="p">]</code> <code class="o">=</code> <code class="nx">theModule</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">})(</code> <code class="s2">"core"</code><code class="p">,</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">module</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
    <code class="nx">module</code><code class="p">.</code><code class="nx">plugins</code> <code class="o">=</code> <code class="p">[];</code>
    <code class="nx">module</code><code class="p">.</code><code class="nx">highlightColor</code> <code class="o">=</code> <code class="s2">"yellow"</code><code class="p">;</code>
    <code class="nx">module</code><code class="p">.</code><code class="nx">errorColor</code> <code class="o">=</code> <code class="s2">"red"</code><code class="p">;</code>

  <code class="c1">// define the core module here and return the public API</code>

  <code class="c1">// This is the highlight method used by the core highlightAll()</code>
  <code class="c1">// method and all of the plug-ins highlighting elements different</code>
  <code class="c1">// colors</code>
  <code class="nx">module</code><code class="p">.</code><code class="nx">highlight</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code> <code class="nx">el</code><code class="p">,</code><code class="nx">strColor</code> <code class="p">){</code>
    <code class="k">if</code><code class="p">(</code> <code class="k">this</code><code class="p">.</code><code class="nx">jQuery</code> <code class="p">){</code>
      <code class="nx">jQuery</code><code class="p">(</code><code class="nx">el</code><code class="p">).</code><code class="nx">css</code><code class="p">(</code> <code class="s2">"background"</code><code class="p">,</code> <code class="nx">strColor</code> <code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="p">{</code>
      <code class="nx">highlightAll</code><code class="o">:</code><code class="kd">function</code><code class="p">(){</code>
        <code class="nx">module</code><code class="p">.</code><code class="nx">highlight</code><code class="p">(</code><code class="s2">"div"</code><code class="p">,</code> <code class="nx">module</code><code class="p">.</code><code class="nx">highlightColor</code><code class="p">);</code>
      <code class="p">}</code>
  <code class="p">};</code>

<code class="p">});</code></pre>

<p><em>pluginExtension.js:</em></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// Extension to module core</code>

<code class="p">(</code><code class="kd">function</code> <code class="p">(</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">definition</code> <code class="p">)</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">theModule</code> <code class="o">=</code> <code class="nx">definition</code><code class="p">(),</code>
        <code class="nx">hasDefine</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">define</code> <code class="o">===</code> <code class="s2">"function"</code><code class="p">,</code>
        <code class="nx">hasExports</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">module</code> <code class="o">!==</code> <code class="s2">"undefined"</code> <code class="o">&amp;&amp;</code> <code class="nx">module</code><code class="p">.</code><code class="nx">exports</code><code class="p">;</code>

    <code class="k">if</code> <code class="p">(</code> <code class="nx">hasDefine</code> <code class="p">)</code> <code class="p">{</code> <code class="c1">// AMD Module</code>
        <code class="nx">define</code><code class="p">(</code><code class="nx">theModule</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code> <code class="nx">hasExports</code> <code class="p">)</code> <code class="p">{</code> <code class="c1">// Node.js Module</code>
        <code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">theModule</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>

        <code class="c1">// Assign to common namespaces or simply the global object (window)</code>
        <code class="c1">// account for flat-file/global module extensions</code>
        <code class="kd">var</code> <code class="nx">obj</code> <code class="o">=</code> <code class="kc">null</code><code class="p">,</code>
            <code class="nx">namespaces</code><code class="p">,</code>
            <code class="nx">scope</code><code class="p">;</code>

        <code class="nx">obj</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
        <code class="nx">namespaces</code> <code class="o">=</code> <code class="nx">name</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">"."</code><code class="p">);</code>
        <code class="nx">scope</code> <code class="o">=</code> <code class="p">(</code> <code class="k">this</code><code class="p">.</code><code class="nx">jQuery</code> <code class="o">||</code> <code class="k">this</code><code class="p">.</code><code class="nx">ender</code> <code class="o">||</code> <code class="k">this</code><code class="p">.</code><code class="nx">$</code> <code class="o">||</code> <code class="k">this</code> <code class="p">);</code>

        <code class="k">for</code> <code class="p">(</code> <code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">namespaces</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">)</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">packageName</code> <code class="o">=</code> <code class="nx">namespaces</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
            <code class="k">if</code> <code class="p">(</code> <code class="nx">obj</code> <code class="o">&amp;&amp;</code> <code class="nx">i</code> <code class="o">==</code> <code class="nx">namespaces</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code> <code class="p">)</code> <code class="p">{</code>
                <code class="nx">obj</code><code class="p">[</code><code class="nx">packageName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">theModule</code><code class="p">;</code>
            <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code> <code class="k">typeof</code> <code class="nx">scope</code><code class="p">[</code><code class="nx">packageName</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"undefined"</code> <code class="p">)</code> <code class="p">{</code>
                <code class="nx">scope</code><code class="p">[</code><code class="nx">packageName</code><code class="p">]</code> <code class="o">=</code> <code class="p">{};</code>
            <code class="p">}</code>
            <code class="nx">obj</code> <code class="o">=</code> <code class="nx">scope</code><code class="p">[</code><code class="nx">packageName</code><code class="p">];</code>
        <code class="p">}</code>

    <code class="p">}</code>
<code class="p">})(</code> <code class="s2">"core.plugin"</code> <code class="p">,</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>

    <code class="c1">// Define our module here and return the public API.</code>
    <code class="c1">// This code could be easily adapted with the core to</code>
    <code class="c1">// allow for methods that overwrite and extend core functionality</code>
    <code class="c1">// in order to expand the highlight method to do more if we wish.</code>
    <code class="k">return</code> <code class="p">{</code>
        <code class="nx">setGreen</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code> <code class="nx">el</code> <code class="p">)</code> <code class="p">{</code>
            <code class="nx">highlight</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">);</code>
        <code class="p">},</code>
        <code class="nx">setRed</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code> <code class="nx">el</code> <code class="p">)</code> <code class="p">{</code>
            <code class="nx">highlight</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="nx">errorColor</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">};</code>

<code class="p">});</code></pre>

<p>UMD doesn’t aim to replace AMD or CommonJS but merely offers some supplemental assistance for developers wishing to get their code working in more environments today. For further information or to contribute suggestions toward this experimental format, see <a href="https://oreil.ly/H2pUf">this GitHub page</a>.<a data-type="indexterm" data-startref="ch10-umd" id="idm45017692779728"/><a data-type="indexterm" data-startref="ch10-umd2" id="idm45017692779088"/><a data-type="indexterm" data-startref="ch10-umdplug" id="idm45017692778416"/><a data-type="indexterm" data-startref="ch10-umdplug2" id="idm45017692777744"/><a data-type="indexterm" data-primary="AMD (Asynchronous Module Definition)" data-secondary="related reading links" id="idm45017692777072"/><a data-type="indexterm" data-primary="UMD (Universal Module Definition)" data-secondary="related reading links" id="idm45017692776160"/><a data-type="indexterm" data-primary="resources online" data-secondary="AMD related reading" id="idm45017692775248"/><a data-type="indexterm" data-primary="resources online" data-secondary="UMD related reading" id="idm45017692718784"/></p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Related reading for UMD and AMD"><div class="sect3" id="further-reading">
<h3>Related reading for UMD and AMD</h3>

<ul>
<li>
<p><a href="https://oreil.ly/Zgs_G">Using AMD Loaders to Write and Manage Modular JavaScript</a></p>
</li>
<li>
<p><a href="https://oreil.ly/IP22B">AMD Module Patterns: Singleton</a></p>
</li>
<li>
<p><a href="https://oreil.ly/I-3jy">Standards and Proposals for JavaScript Modules and jQuery</a></p>
</li>
</ul>
</div></section>
</div></section>
</div></section>






<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Summary"><div class="sect1" id="ch10_conclusion">
<h1>Summary</h1>

<p>This section reviewed several options for writing modular JavaScript using different module formats before ES2015+.</p>

<p>These formats had several advantages over using the Module pattern alone, including avoiding the need to manage global variables, better support for static and dynamic dependency management, improved compatibility with script loaders, better compatibility for modules on the server, and more.</p>

<p>To conclude our discussion of classic design and architecture patterns, I want to touch on one area where we can apply patterns to structure and organize our JavaScript code in the next chapter on Namespacing patterns.</p>
</div></section>
</div></section></div></body></html>