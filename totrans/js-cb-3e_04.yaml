- en: Chapter 3\. Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are few ingredients more essential to everyday programming than numbers.
    Many modern languages have a set of different numeric data types to use in different
    scenarios, like integers, decimals, floating point values, and so on. But when
    it comes to numbers, JavaScript reveals its rushed, slightly improvised creation
    as a loosely-typed scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until recently, JavaScript had just a single do-everything numeric data type
    called `Number`. Today, it has two: the standard `Number` you use almost all of
    the time, and the very specialized `BigInt` that you only consider when you need
    to deal with huge whole numbers. You’ll use both in this chapter, along with the
    utility methods of the `Math` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating Random Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to generate a random whole number that falls in a set range (for example,
    from 1 to 6).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `Math.random()` method to generate a floating-point value between
    0 and 1\. Usually, you’ll scale this fractional value and round it, so you end
    up with an integer in a specific range. Assuming your range spans from some minimum
    number `min` to a maximum number `max`, here’s the statement you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you want to pick a random number between 1 and 6, the code
    becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now possible values of `randomNumber` are 1, 2, 3, 4, 5, or 6.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Math` object is stocked full of static utility methods you can call at
    any time. This recipe uses `Math.random()` to get a random fractional number,
    and `Math.floor()` to truncate the decimal portion, leaving you with an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works, let’s consider a sample run-through. First, `Math.random()`
    picks a value between 0 and 1, like *0.374324823*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That number is multiplied by the number of values in your range (in this example,
    6), becoming *2.245948938*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `Math.floor()` function truncates this to just *2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the starting number of the range is added, giving the final result
    of *3*. Repeat this calculation and you’ll get a different number, but it will
    always be an integer from the range we’ve set of 1 to 6.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Math.floor()` method is only one way to round numbers. See [“Rounding to
    a Specific Decimal Place”](#rounding_specific_decimal) for more.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to understand that numbers generated by `Math.random()` are
    *pseudorandom*, which means they can be guessed or reverse engineered. They are
    not random enough for cryptography, lotteries, or complex modelling. For more
    about the difference, see [“Generating Cryptographically Secure Random Numbers”](#generating_secure_random_numbers).
    And if you need a way to generate a repeatable sequence of pseudorandom numbers,
    refer to [“Extra: Building a Repeatable Pseudorandom Number Generator”](ch06.html#repeatable_PRNG).'
  prefs: []
  type: TYPE_NORMAL
- en: Generating Cryptographically Secure Random Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a random number that can’t be easily reverse engineered (guessed).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `window.crypto` property to get an instance of the `Crypto` object.
    Use the `Crypto.getRandomValues()` method to generate random values that have
    more *entropy* than those produced by `Math.random()`. (In other words, they are
    much less likely to be repeated or predicted—see the Discussion section for full
    details.)
  prefs: []
  type: TYPE_NORMAL
- en: The `Crypto.getRandomValues()` method works differently from `Math.random()`.
    Rather than giving you a floating-point number between 0 and 1, `getRandomValues()`
    fills an array with random integers. You can choose whether these integers are
    8-bit, 16-bit, or 32-bit, and whether they are signed or unsigned. (A signed data
    type can be negative or positive, whereas an unsigned number is only positive.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an accepted workaround to convert the output of `getRandomValues()`
    to a fractional value between 0 and 1\. The trick is to divide the random value
    by the maximum possible number that data type can contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now work with `randomFraction` in the same way that you work with the
    number returned from `Math.random()`. For example, you can convert it to a random
    integer in a specific range, as explained in [“Generating Random Numbers”](#generating_random_numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re running your code in the Node.js runtime environment, you won’t have
    access to a `window` object. However, you can get access to a very similar implementation
    of the Web Crypto API using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a lot to unpack in this example. First, even if you don’t dig deeper
    into *how* this code works, you need to be aware of a few important details about
    the implementation of `Crypto.getRandomValues()`:'
  prefs: []
  type: TYPE_NORMAL
- en: Technically, `Crypto` creates pseudorandom numbers that are generated by a mathematical
    formula, like those provided by `Math.random()`. The difference is that these
    numbers are considered *cryptographically strong*, because the random number generator
    is seeded with a truly random value. The benefit of this trade-off is that `getRandomValues()`
    has similar performance to `Math.random()`. (It’s fast.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no way to know how the `Crypto` object is seeded, because that’s up
    to the implementation (for web page code, that means the browser manufacturer),
    which in turn relies on functionality in the operating system. Usually, the seed
    is created using a combination of recently recorded details about keyboard timings,
    mouse movements, and hardware readings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter how good your random numbers are, if your JavaScript code is running
    in a browser, it’s exposed to a great number of attacks. After all, there’s nothing
    to stop a malicious party from seeing your code and creating an altered copy that
    bypasses all random number generation. If your code is running on a server, the
    situation is different.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s look closer at how `getRandomValues()` works. Before you call `getRandomValues()`,
    you must create a *typed array*, which is an array-like object that can only hold
    values of a specific data type. (We say *array-like* because it behaves like an
    array, but it isn’t an instance of the official `Array` type.) JavaScript provides
    several strongly typed array objects you can use: like `Uint32Array` (for an array
    of unsigned 32-bit integers), `Uint16Array`, `Uint8Array`, and the signed counterparts
    `Int32Array`, `Int16Array`, and `Int8Array`. You create this array to be as big
    as you want, and `getRandomValues()` will fill the whole buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we make room for just one value in the `Uint32Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to divide this random value by the maximum possible unsigned
    32-bit integer, which is 4,294,967,295\. This number is cleaner in its hexadecimal
    representation, `0xffffffff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As this code shows, you also need to add 1 to the maximum value. That’s because
    the random value could theoretically land exactly on the maximum integer value.
    If it did, the `randomFraction` would become 1, which differs from `Math.random()`
    and most other random number generators. (And a tiny unexpected variation from
    the norm is something that can lead to a incorrect assumption, and then a bug
    further down the road.)
  prefs: []
  type: TYPE_NORMAL
- en: Rounding to a Specific Decimal Place
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to round a number to a certain precision (for example, 124.793 to 124.80
    or 120).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `Math.round()` method to round a number to the nearest whole
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Oddly enough, the `round()` method doesn’t take an argument that lets you specify
    a number of decimal places to keep. If you want a different degree of precision,
    it’s up to you to multiply your number by the appropriate power of 10, round it,
    and then divide it by the same power of 10 after rounding. Here’s the general
    formula for this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you want to round to two decimal places, the code becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you want to round *left* of decimal place (for example, to the nearest tens,
    hundreds, and so on), just use a negative number for `numberOfDecimalPlaces`.
    For example, –1 rounds to the nearest 10, –2 rounds to the nearest 100, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Math` object has several static methods for turning fractional values into
    integers. The `floor()` method removes all decimal digits, rounding a number down
    to the nearest whole number. The `ceil()` method does the reverse, and always
    rounds a fractional number up to the next whole number. The `round()` method rounds
    to the closest whole number.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important points you need to know about how `round()` works:'
  prefs: []
  type: TYPE_NORMAL
- en: An exact value of 0.5 is always rounded up, even though it is equally distant
    from both the next lower and next higher integer. In finance and science, different
    rounding techniques are often used to remove this bias (such as rounding some
    0.5 values up and others down). But if you want that behavior in JavaScript, you
    need to implement it yourself or use a third-party library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When rounding negative numbers, JavaScript rounds –0.5 up *toward zero*. That
    means that –4.5 is rounded to –4, which is different than the rounding implementation
    in many other programming languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rounding numbers is one way to get a numeric value closer to an appropriate
    display format. If you’re using rounding to prepare a number to show to a user,
    you may also be interested in the `Number` formatting methods described in [“Converting
    a Numeric Value to a Formatted String”](ch02.html#converting_number_to_string).
  prefs: []
  type: TYPE_NORMAL
- en: Preserving Accuracy in Decimal Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All numbers in JavaScript are floating point values, which suffer minute rounding
    errors with certain operations. In some applications (for example, when dealing
    with amounts of money), these errors may not be acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Floating point rounding errors are a well-understood phenomenon that exists
    in almost every programming language. To see it in JavaScript, run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can’t avoid the rounding error, but you can minimize it. If you’re working
    with a currency type that has two decimal places of precision (like dollars),
    consider multiplying all values by 100 to avoid dealing with decimals. Instead
    of writing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Use currency variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This solves the problem for operations that work out to exact whole numbers,
    like adding and subtracting numbers of cents. But what happens when you need to
    calculate tax or interest? In these situations you’ll end up with fractional values
    no matter what, and you need to do what businesses and banks do—round your values
    immediately after your transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The floating point rounding issue stems from the fact that some decimal values
    can’t be stored in binary representation without rounding. The same problem occurs
    with decimal numbering systems (for example, try to write the result of 1/3).
    The difference with floating point numbers is that the effect is *counterintuitive*.
    We don’t expect to have trouble adding 0.1 and 0.2, because in decimal notation
    both fractions can be represented exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Although other programming languages experience the same phenomenon, many of
    them include an alternate data type for decimal or currency values. JavaScript
    does not. However, there is a proposal for a [new Decimal type](https://github.com/tc39/proposal-decimal),
    which could be incorporated into a future version of the JavaScript language.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you perform a lot of financial calculations, you can simplify your life by
    using a third-party library like [*bignumber.js*](https://github.com/MikeMcl/bignumber.js),
    which provides a customized numeric data type that works a lot like the ordinary
    `Number`, but preserves exact precision for a fixed number of decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a String to a Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to parse a number in a string and convert it to the number data type.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s always safe to convert a number into a string, because that operation can’t
    fail. The reverse task—converting a string into a number, so you can use it in
    calculations—is a more delicate affair.
  prefs: []
  type: TYPE_NORMAL
- en: 'The canonical approach is to use the `Number()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Number()` function won’t accept formatting like currency symbols and comma
    separators. It *will* allow extra spaces at the beginning and end of the string.
    The `Number()` function also converts empty strings or strings with only whitespace
    to the number 0\. This might be a reasonable default (for example, if you’re retrieving
    user input from a text box), but it’s not always appropriate. To avoid this case,
    consider testing for a whitespace-only string before you call `Number()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If a conversion fails, the `Number()` function assigns the value `NaN` (for
    *not a number*) to your variable. You can test for this failure by calling the
    `Number.isNaN()` method immediately after you use `Number()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `isFinite()` method is almost the same as `isNaN()`, except it avoids strange
    edge cases, like `1/0`, which returns a value of `infinity`. If you use the `isNaN()`
    method on `infinity`, it somewhat dubiously returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate approach is to use the `parseFloat()` method. It’s a slightly looser
    conversion that tolerates text after the number. However, `parseFloat()` is stricter
    with blank strings, which it refuses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers use some conversion tricks that are functionally equivalent to the
    `Number`() function, like multiplying a string by 1 (`numberInString*1`) or using
    the unary operator (`+numberInString`). But using `Number()` or `parseFloat()`
    is preferred for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a formatted number (like *2,300*), you need to do more work to convert
    it. The `Number()` method will return `NaN`, and `parseFloat()` will stop at the
    comma and treat it as 2\. Unfortunately, although JavaScript has an `Intl.NumberFormat`
    object that can *create* formatted strings from numbers (see [“Converting a Numeric
    Value to a Formatted String”](ch02.html#converting_number_to_string)), it doesn’t
    provide parsing functionality for the reverse operation.
  prefs: []
  type: TYPE_NORMAL
- en: You can use regular expressions to take care of tasks like removing commas from
    a string (see [“Replacing All Occurrences of a String”](ch02.html#replacing_all_occurrences_string)).
    But a home brew solution can be risky, because some locales use commas to separate
    thousands, while others use them to separate decimals. In situations like these,
    a well-used, well-tested JavaScript library like [Numeral](http://numeraljs.com)
    is a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Decimal to a Hexadecimal Value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a decimal value, and need to find its hexadecimal equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Number.toString()` method, with an argument that specifies the base
    you are converting *to*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, numbers in JavaScript are base 10, or decimal. However, they can
    also be converted to a different *radix*, including hexadecimal (16) and octal
    (8). Hexadecimal numbers begin with `0x` (a zero followed by lowercase x). Octal
    numbers used to begin with just a zero (0), but now should begin with a zero and
    then a Latin letter *O* (upper or lowercase):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A decimal number can be converted to another radix, in a range from 2 to 36:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To complete the octal and hexadecimal presentation, you’ll need to concatenate
    the `0o` to the octal, and the `0x` to the hexadecimal value. But remember, once
    you’ve converted your number into a string, don’t expect to use it in any sort
    of numeric calculation, no matter how it’s formatted.
  prefs: []
  type: TYPE_NORMAL
- en: Although decimals can be converted to any base number (between a range of 2
    to 36), only the octal, hexadecimal, and decimal numbers can be manipulated directly
    as numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Between Degrees and Radians
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have an angle in degrees. To use the value in the `Math` object’s trigonometric
    functions, you need to convert the degrees to radians.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert degrees to radians, multiply the degree value by `(Math.PI/180)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So if you have a 90 degree angle, the calculation becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert radians to degrees, multiply the radians value by `(180/Math.PI)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the trigonometric methods of the `Math` object (`sin()`, `cos()`, `tan()`,
    `asin()`, `acos()`, `atan()`, and `atan2()`) take values in radians, and return
    radians as a result. Yet it’s not unusual for people to provide values in degrees
    rather than radians, as degrees are the more familiar unit of measure.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Length of a Circular Arc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the radius of a circle, and the angle of an arc in degrees, find the length
    of the arc.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `Math.PI` to convert degrees to radians, and use the result in a formula
    to find the length of the arc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The length of a circular arc is found by multiplying the circle’s radius times
    the angle of the arc, in radians.
  prefs: []
  type: TYPE_NORMAL
- en: If the angle is given in degrees, you’ll need to convert the degree to radians
    first, before multiplying the angle by the radius. This calculation is frequently
    used when drawing shapes in SVG, as covered in [Chapter 15](ch15.html#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating Very Large Numbers with BigInt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to work with very large integers (above 2^(53)), without losing precision.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `BigInt` data type, which can hold integers of any size, limited only
    by system memory (or the `BigInt` implementation of the JavaScript engine you’re
    using).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a `BigInt` in two ways. You use the `BigInt()` function, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can add the letter *n* to the end of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows the difference between an ordinary `Number` and the `BigInt`
    for very large values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you log a `BigInt` to the developer console, it appears with an *n* appended
    to its value (as in *9007199254740992n*). This convention makes it easy to recognize
    `BigInt` values. But if you just want the numeric value of your `BigInt`, you
    simply need to convert it to text first, with `BigInt.toString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s native `Number` type conforms to the IEEE-754 specification for
    64-bit, double-precision floating-point numbers. The standard has acceptable,
    known limitations and inaccuracies. One practical limitation is that integers
    cannot be accurately represented past 2^(53). Beyond this point, inaccuracies
    in representation which had previously been confined to the right of the decimal
    place (see [“Preserving Accuracy in Decimal Values”](#preserving_decimal_accuracy))
    jump over to the left of the decimal place. Put another way, as the JavaScript
    engine counts higher, the chance for inaccuracy grows. Once we are past 2^(53),
    the inaccuracy is larger than 1 and shows up in calculations with integral numbers,
    not just decimal values.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has a partial solution to this problem with the `BigInt` type, introduced
    as part of the ECMAScript 2020 specification. A `BigInt` is an arbitrarily sized
    integer that allows you to represent exceedingly large numbers. Practically speaking,
    there is no upper limit to the bit width of a `BigInt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all of the operators you are used to using with regular numbers can
    be used on a `BigInt`, including addition (`+`), subtraction (`-`), multiplication
    (`*`), division (`/`), and exponentiation (`**`). However, `BigInt` is an integer
    and does not store fractional values. When you perform a division operation, `BigInt`
    quietly discards the decimal portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`BigInts` and `Numbers` are not interchangeable nor are they interoperable.
    But they can be converted to one another using the `Number()` and `BigInt()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You need to perform a conversion if you want to use a `BigInt` with a method
    that expects a `Number`, like the methods of the `Math` object. Similarly, you
    need to perform a conversion if you want to use a `Number` in a calculation with
    another `BigInt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attempt to convert a `Number` that holds a fractional value into a `BigInt`,
    you’ll receive a `RangeError`. You can avoid this possibility by rounding first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to keep operations consistent with the type. Sometimes what seems
    like a simple operation can fail because you accidentally combine a `BigInt` with
    an ordinary number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can compare a `BigInt` value against a `Number` value using the standard
    comparison operators (`<`, `>`, `<=`, `>=`). If you want to test if a `BigInt`
    and a number are equal, use the loose equality operators (`==` and `!=`). Strict
    equality (`===`) will always return `false`, because `BigInt` and `Number` are
    different data types. Or, better yet, explicitly convert your `Number` to a `BigInt`
    and then compare it with `===`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to consider with `BigInt`: it is not (at publishing time) serializable
    to JSON. Attempts to call `JSON.stringify()` on a `BigInt` yield a syntax error.
    You have several options to consider as a solution. You could monkey-patch your
    `BigInt` implementation with an appropriate `toJSON()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You could also use a library like [granola](https://github.com/kanongil/granola),
    which provides JSON-compatiable stringifiers for a number of values, including
    `BigInt`.
  prefs: []
  type: TYPE_NORMAL
