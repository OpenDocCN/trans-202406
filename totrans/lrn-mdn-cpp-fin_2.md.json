["```\nint vector_sum_of_ints()\n{\n\tvector<int> v = { 1,2,3 };\n\tint sum = 0;\n\tfor (int elem : v) sum += elem;\n\treturn sum;\n}\n```", "```\nmodule;\t// The global fragment\n#include <vector>\nexport module CppMod;\t// The global fragment ends at this point, and \n\t\t\t\t\t// the functionality of the module starts here.\nusing std::vector;\n// Declare the function first, using the\n// export keyword to make it accessible outside the module.\nexport int vector_sum_of_ints();\n// Implementation of the function.  The export keyword\n// is not necessary here as it is already included \n// in the declaration.\nint vector_sum_of_ints()\n{\n\tvector<int> v = { 1,2,3 };\n\tint sum = 0;\n\tfor (int elem : v) sum += elem;\n\treturn sum;\n}\n```", "```\n#include <iostream>\t\t// #include <iostream> as usual\nusing std::cout;\nusing std::endl;\nimport CppMod;\t\t// Import the CppMod module\n\t\t\t\t// containing the vector_sum_of_ints function.\nint main()\n{\n\tcout << vector_sum_of_ints() << endl;\n}\n```", "```\nmodule;\n#include <vector>\nexport module CppMod;\nusing std::vector;\nexport int vector_sum_of_ints();\nint add_stuff (int n);\nint vector_sum_of_ints()\n{\n\tvector<int> v = { 1,2,3 };\n\tint sum = 0;\n\tfor (int elem : v) sum += elem;\n\tsum = add_one(sum);\n\treturn sum;\n}\nint add_stuff (int n)\n{\n\treturn n + n;\n}\n```", "```\nmodule;\n#include <vector>\nexport module CppMod;\nusing std::vector;\nexport int vector_sum_of_ints();\nint add_one(int n);\nint k = 0;\nint vector_sum_of_ints()\n{\n\tvector<int> v = { 1,2,3 };\n\tint sum = 0;\n\tfor (int elem : v) sum += elem;\n\tsum = add_k(sum);\n\treturn sum + k;\t\t// k still = 6; returns 18\n}\nint add_stuff(int n)\n{\n\tk = n;\t\t\t// k = 6\n\treturn k + n;\t\t// 12\n}\n```", "```\nmodule;\n#include <vector>\nexport module CppMod;\nusing std::vector;\n// Interface section is here:\nexport int vector_sum_of_ints();\nint add_stuff(int n);\nint k = 0;\n// Implementations are placed in the private fragment:\nmodule:private;\nint vector_sum_of_ints()\n{\n\tvector<int> v = { 1,2,3 };\n\tint sum = 0;\n\tfor (int elem : v) sum += elem;\n\tsum = add_stuff(sum);\n\treturn sum + k;\t\t// k still = 6; returns 18\n}\nint add_stuff(int n)\n{\n\tk = n;\t\t\t// k = 6\n\treturn k + n;\t\t// 12\n}\n```", "```\n#include <vector>\n#include <algorithm>\n```", "```\nimport <vector>;\t\t// Note these require a semicolon\nimport <algorithm>;\n```", "```\nexport module CppMod;\nimport <vector>;\nusing std::vector;\n```", "```\n// Define module A that imports module B:\nexport module A;\nimport B;\n```", "```\n// Define module C that imports module A:\nexport module C;\nimport A;\nimport B;\t\t// Not implicitly imported with module A.\n\t\t\t// Must be explicitly imported if functions\n\t\t\t// in B are also to be used inside module C\n```", "```\n// MyHeader.h\n#include “YourHeader.h”\n#include <vector>\n```", "```\n#include “MyHeader.h”\nint main()\n{\n\t// This will compile:\n\tauto y = my_header_fcn(…);\n\t// But so will these lines:\n\tauto z = your_header_fcn(…);\n\tstd::vector <double> v;\n}\n```", "```\n// File Enums.ixx\nexport module Enums;\nexport enum class PayoffType\n{\n\tCALL,\n\tPUT\n};\n```", "```\nmodule;\n#include <cmath>\t// cstuff headers (derived from stuff.h) \n\t\t\t\t// should be #include(d) in the global fragment\n```", "```\nexport module BlackScholesFcns;\n// <cmath> functions used below:\nusing std::log;\nusing std::erf;\n```", "```\n// Standard Library header units, and using aliases\nimport <numbers>;\nusing std::numbers::sqrt2;\nimport <algorithm>;\nusing std::max;\n```", "```\nexport import Enums;\n```", "```\nexport double black_scholes_price(double strike, double spot, double rate,\n\tdouble sigma, double year_frac, PayoffType pot);\n// Internal functions and variables\nvoid dee_fcns(double strike, double rate, double spot,\n\tdouble sigma, double year_frac);\ndouble norm_cdf(double x);\n```", "```\n// Internal module variables\ndouble d1 = 0.0, d2 = 0.0;\t\t// d1 and d2 values in Black-Scholes\n```", "```\ndouble black_scholes_price(double strike, double spot, double rate,\n\tdouble sigma, double year_frac, PayoffType pot)\n{\n\tdouble opt_price = 0.0;\n\t// phi, as in the James book: \n\tdouble phi = (pot == PayoffType::CALL) ? 1.0 : -1.0;\n\tif (year_frac > 0.0)\n\t{\t\t\n\t\tdee_fcns(strike, rate, spot, sigma, year_frac);\n\t\tdouble n_dee_one = norm_cdf(phi * d1);\t\t// N(d1)\n\t\tdouble n_dee_two = norm_cdf(phi * d2); \t// N(d2)\n\t\tdouble disc_fctr = exp(-rate * year_frac);\n\t\topt_price = phi * (spot * n_dee_one - disc_fctr * strike * n_dee_two);\n\t}\n\telse\n\t{\n\t\topt_price = max(phi * (spot - strike), 0.0);\n\t}\n\treturn opt_price;\n}\nmodule : private;\nvoid dee_fcns(double strike, double rate, double spot,\n\tdouble sigma, double year_frac)\n{\n\tdouble numer = log(spot / strike) + rate * year_frac\n\t\t+ 0.5 * year_frac * sigma * sigma;\n\tdouble sigma_sqrt = sigma * sqrt(year_frac);\n\td1 = numer / sigma_sqrt;\n\td2 = d1 - sigma_sqrt;\n}\ndouble norm_cdf(double x)\n{\n\treturn (1.0 + erf(x / sqrt2)) / 2.0;\n}\n```", "```\nimport BlackScholesFcns;\n```", "```\n\tstrike = 200.0;\n\tporc = PayoffType::PUT;\n\tspot = 185.0;\n\trate = 0.05;\n\tsigma = 0.25;\n\tyear_frac = 0.25;\n\tcout << \"Put Option price = \"\n\t\t<< black_scholes_price(strike, spot, rate, sigma, year_frac, porc )\n\t\t<< endl;\n```", "```\nexport module BlackScholesClass;\n```", "```\nexport class BlackScholes\n{\npublic:\n\tdouble black_scholes_price(double strike, double spot, double rate,\n\t\tdouble sigma, double year_frac, PayoffType pot);\nprivate:\n\tvoid dee_fcns_(double strike, double rate, double spot,\n\t\tdouble sigma, double year_frac);\n\tdouble norm_cdf_(double x);\n\tdouble d1_ = 0.0, d2_ = 0.0;\n};\n```", "```\ndouble BlackScholes::black_scholes_price(double strike, double spot, double rate,\n\tdouble sigma, double year_frac, PayoffType pot)\n{\n\tdouble opt_price = 0.0;\n\t// phi, as in the James book: \n\tdouble phi = (pot == PayoffType::CALL) ? 1.0 : -1.0;\n\tif (year_frac > 0.0) . . . \n\treturn opt_price;\n}\netc. . .\n```", "```\nexport module ThisModule;\nexport double maximum(double x, double y)\n{\n\tdouble max_val = x > y ? x : y;\n\treturn max_val;\n}\nexport module ThatModule;\nexport double maximum(double x, double y)\n{\n\tdouble max_val = 2*x > 2*y ? x : y;\n\treturn max_val;\n}\n```", "```\n// In some other location:\nimport ThisModule;\nimport ThatModule;\n//. . .\ndouble compare_max(double x, double y)\n{\n\treturn maximum(x, y);\t// Compiler error!\n} \n```", "```\nexport module ThisModule;\nexport namespace this_nsp\n{\n\texport double maximum(double x, double y)\n\t{\n\t\tdouble max_val = x > y ? x : y;\n\t\treturn max_val;\n\t}\n}\nexport module ThatModule;\nexport namespace that_nsp\n{\n\texport double maximum(double x, double y)\n\t{\n\t\tdouble max_val = 2*x > 2*y ? x : y;\n\t\treturn max_val;\n\t}\n}\n```", "```\nimport ThisModule;\nimport ThatModule;\n//. . .\ndouble compare_max(double x, double y)\n{\n\treturn this_nsp::maximum(x, y);\t// Will now compile\n}\n```", "```\nimport ThisModule;\nimport ThatModule;\nusing that_nsp::maximum\n// …\ndouble compare_max(double x, double y)\n{\n\treturn this_nsp::maximum(x, y);\t// Will also compile\n}\n```", "```\nimport ThisModule;\nimport ThatModule;\nusing namespace this_nsp;\nusing namespace that_nsp;\n// . . .\ndouble compare_max(double x, double y)\n{\n\treturn maximum(x, y);\t// Compiler error!\n}\n```", "```\n`using namespace::std;`\n```", "```\nimport <vector>;\nimport ThisModule;\n//. . .\nstd::vector<double> v;\nreturn this_nsp::maximum(x, y);\n```", "```\nimport <vector>;\nusing std::vector;\nimport ThisModule;\nusing this_nsp::maximum; \n```"]