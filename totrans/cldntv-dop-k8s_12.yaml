- en: Chapter 10\. Configuration and Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。配置和 Secrets
- en: If you want to keep a secret, you must also hide it from yourself.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想保守一个秘密，你必须也要从自己那里隐藏它。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: George Orwell, *1984*
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: George Orwell，*1984*
- en: 'It’s very useful to be able to separate the *logic* of your Kubernetes application
    from its *configuration*: that is, any values or settings that might change over
    the life of the application. Configuration values commonly include things like
    environment-specific settings, DNS addresses of third-party services, and authentication
    credentials.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将 Kubernetes 应用程序的逻辑与其配置分离开来非常有用：即可能在应用程序生命周期内发生变化的任何值或设置。配置值通常包括诸如特定于环境的设置、第三方服务的
    DNS 地址和身份验证凭据等内容。
- en: While you could simply put these values directly into your code, that’s not
    a very flexible approach. For one thing, changing a configuration value would
    require a complete rebuild and redeploy of the application. It’s much better to
    separate these values out from the code and read them in from a file, or from
    environment variables.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以直接将这些值放入您的代码中，但这并不是一个非常灵活的方法。首先，更改配置值将需要完全重建和重新部署应用程序。最好是将这些值从代码中分离出来，并从文件或环境变量中读取它们。
- en: Kubernetes provides a few different ways to help you manage configuration. One
    is to pass values to the application via environment variables in the Pod spec
    (see [“Environment Variables”](ch08.html#envvars)). Another is to store configuration
    data directly in Kubernetes, using the ConfigMap and Secret objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了几种不同的方法来帮助您管理配置。一种方法是通过 Pod 规范中的环境变量向应用程序传递值（参见 [“环境变量”](ch08.html#envvars)）。另一种方法是直接将配置数据存储在
    Kubernetes 中，使用 ConfigMap 和 Secret 对象。
- en: In this chapter we’ll explore ConfigMaps and Secrets in detail, and look at
    some practical techniques for managing configuration and secrets in applications,
    using the demo application as an example.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨 ConfigMaps 和 Secrets，并查看一些管理应用程序中配置和密钥的实用技术，使用演示应用程序作为示例。
- en: ConfigMaps
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ConfigMaps
- en: The ConfigMap is the primary object for storing configuration data in Kubernetes.
    You can think of it as being a named set of key-value pairs that stores configuration
    data. Once you have a ConfigMap, you can supply that data to an application either
    by creating a file in the Pod, or by injecting it into the Pod’s environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 是 Kubernetes 中存储配置数据的主要对象。您可以将其视为一个命名的键值对集合，用于存储配置数据。一旦创建了 ConfigMap，您可以通过在
    Pod 中创建文件或将其注入到 Pod 的环境中来为应用程序提供数据。
- en: In this section, we’ll look at some different ways to get data into a ConfigMap,
    and then explore the various ways you can extract that data and feed it into your
    Kubernetes application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨将数据输入到 ConfigMap 中的几种不同方法，然后探索将这些数据提取并馈送到您的 Kubernetes 应用程序中的各种方法。
- en: Creating ConfigMaps
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ConfigMaps
- en: 'Suppose you want to create a YAML configuration file in your Pod’s filesystem
    named *config.yaml*, with the following contents:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在 Pod 的文件系统中创建一个名为 *config.yaml* 的 YAML 配置文件，并具有以下内容：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Given this set of values, how do you turn them into a ConfigMap resource that
    you can apply to Kubernetes?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些值集合，您如何将它们转换为可应用于 Kubernetes 的 ConfigMap 资源？
- en: 'One way is to specify that data as literal YAML values in the ConfigMap manifest.
    This is what the manifest for a ConfigMap object looks like:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方式是将数据指定为 ConfigMap 清单中的 YAML 字面值。这是 ConfigMap 对象清单的样子：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You could create a ConfigMap by writing the manifest from scratch, and adding
    the values from *config.yaml* into the `data` section, as we’ve done in this example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从头开始编写清单来创建 ConfigMap，并将 *config.yaml* 中的值添加到 `data` 部分，就像我们在这个例子中所做的那样。
- en: 'An easier way, though, is to let `kubectl` do some of the work for you. You
    can create a ConfigMap directly from a YAML file as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，更简单的方法是让 `kubectl` 为您做一些工作。您可以直接从 YAML 文件创建 ConfigMap 如下所示：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To export the manifest file that corresponds to this ConfigMap, run:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出与此 ConfigMap 对应的清单文件，请运行：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This writes a YAML manifest representation of the cluster’s ConfigMap resource
    to the file *demo-config.yaml*, however it will contain extra info like the `status`
    section that you may want to remove before applying again (see [“Exporting Resources”](ch07.html#exportflag)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将写入集群的 ConfigMap 资源的 YAML 清单表示到文件 *demo-config.yaml*，但它将包含额外的信息，如 `status`
    部分，您可能希望在再次应用之前将其删除（参见 [“导出资源”](ch07.html#exportflag)）。
- en: Setting Environment Variables from ConfigMaps
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 ConfigMaps 设置环境变量
- en: Now that we have the required configuration data in a ConfigMap object, how
    do we then get that data into a container? Let’s look at a complete example using
    our demo application. You’ll find the code in the *hello-config-env* directory
    of the demo repo.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 ConfigMap 对象中拥有了所需的配置数据，那么如何将这些数据传输到容器中呢？让我们看一个使用我们演示应用程序的完整示例。您将在演示存储库的*hello-config-env*目录中找到代码。
- en: It’s the same demo application we’ve used in previous chapters that listens
    for HTTP requests and responds with a greeting (see [“Looking at the Source Code”](ch02.html#demo-source)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前章节中使用的相同演示应用程序，它监听 HTTP 请求并以问候语回复（参见[“查看源代码”](ch02.html#demo-source)）。
- en: 'This time, though, instead of hard coding the string `Hello` into the application,
    we’d like to make the greeting configurable. So there’s a slight modification
    to the `handler` function to read this value from the environment variable `GREETING`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这次我们不会将字符串`Hello`硬编码到应用程序中，而是希望将问候语设置为可配置。因此，稍微修改了`handler`函数以从环境变量`GREETING`中读取该值：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don’t worry about the exact details of the Go code; it’s just a demo. Suffice
    it to say that if the `GREETING` environment variable is present when the program
    runs, it will use that value when responding to requests. Whatever language you’re
    using to write applications, it’s a good bet that you’ll be able to read environment
    variables with it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心 Go 代码的具体细节；这只是一个演示。可以肯定的是，如果在程序运行时存在`GREETING`环境变量，它将在响应请求时使用该值。无论您使用何种语言编写应用程序，都可以使用它来读取环境变量。
- en: Now, let’s create the ConfigMap object to hold the greeting value. You’ll find
    the manifest file for the ConfigMap, along with the modified Go application, in
    the *hello-config-env* directory of the demo repo.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 ConfigMap 对象以保存问候值。您将在演示存储库的*hello-config-env*目录中找到 ConfigMap 清单文件，以及修改后的
    Go 应用程序。
- en: 'It looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to make this data visible in the container’s environment, we need
    to modify the Deployment slightly. Here’s the relevant part of the demo Deployment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些数据在容器的环境中可见，我们需要稍微修改部署。以下是演示部署的相关部分：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we’re using a different container image tag to that in previous examples
    (see [“Image Identifiers”](ch08.html#image-identifiers)). The `:hello-config-env`
    tag gets us the modified version of the demo application that reads the `GREETING`
    variable: `cloudnatived/demo:hello-config-env`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了不同的容器镜像标签，与之前的示例不同（参见[“镜像标识符”](ch08.html#image-identifiers)）。`:hello-config-env`标签让我们获取修改后的演示应用程序版本，该版本读取`GREETING`变量：`cloudnatived/demo:hello-config-env`。
- en: The second point of interest is the `env` section. Remember from [“Environment
    Variables”](ch08.html#envvars) that you can create environment variables with
    literal values by adding a `name`/`value` pair.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其次感兴趣的是`env`部分。从[“环境变量”](ch08.html#envvars)中记得，您可以通过添加`name`/`value`对来创建具有字面值的环境变量。
- en: We still have `name` here, but instead of `value`, we’ve specified `valueFrom`.
    This tells Kubernetes that, rather than taking a literal value for the variable,
    it should look elsewhere to find the value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里仍然有`name`，但是我们使用了`valueFrom`而不是`value`。这告诉 Kubernetes，它不应该使用变量的字面值，而是应该去其他地方找到该值。
- en: '`configMapKeyRef` tells it to reference a specific key in a specific ConfigMap.
    The name of the ConfigMap to look at is `demo-config`, and the key we want to
    look up is `greeting`. We created this data with the ConfigMap manifest, so it
    should now be available to read into the container’s environment.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`configMapKeyRef`告诉它引用特定 ConfigMap 中的特定键。要查看的 ConfigMap 的名称是`demo-config`，我们要查找的键是`greeting`。我们使用
    ConfigMap 清单创建了这些数据，所以现在应该可以将其读取到容器的环境中。'
- en: If the ConfigMap doesn’t exist, the Deployment won’t be able to run (its Pod
    will show a status of `CreateContainerConfigError`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ConfigMap 不存在，部署将无法运行（其 Pod 将显示`CreateContainerConfigError`状态）。
- en: 'That’s everything you need to make the updated application work, so go ahead
    and deploy the manifests to your Kubernetes cluster. From the demo repo directory,
    run the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使更新后的应用程序工作所需的一切，因此继续将清单部署到您的 Kubernetes 集群。从演示存储库目录中运行以下命令：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As before, to see the application in your web browser, you’ll need to forward
    a local port to the Pod’s port 8888:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，要在 Web 浏览器中查看应用程序，您需要将本地端口转发到 Pod 的端口8888：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (We didn’t bother creating a Service this time; while you’d use a Service with
    a real production app, for this example we’ve just used `kubectl` to forward the
    local port directly to the `demo` Deployment.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: （这次我们没有费心创建一个 Service；尽管在实际的生产应用程序中您会使用 Service，但在这个示例中，我们只是直接使用 `kubectl` 将本地端口转发到
    `demo` Deployment。）
- en: 'If you point your web browser to http://localhost:9999/, you should see, if
    all is well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将您的网络浏览器指向 http://localhost:9999/，如果一切正常，您应该能看到：
- en: '`Hola, 世界`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hola, 世界`'
- en: Setting the Whole Environment from a ConfigMap
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 ConfigMap 设置整个环境
- en: While you can set one or two environment variables from individual ConfigMap
    keys, as we saw in the previous example, that could get tedious for a large number
    of variables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以从单个 ConfigMap 键设置一两个环境变量，就像我们在前面的示例中看到的那样，但对于大量变量来说，这可能会变得乏味。
- en: 'Fortunately, there’s an easy way to take all the keys from a ConfigMap and
    turn them into environment variables, using `envFrom`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种简单的方法可以从 ConfigMap 中获取所有键，并将它们转换为环境变量，使用 `envFrom`：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now every setting in the `demo-config` ConfigMap will be a variable in the container’s
    environment. Because in our example ConfigMap the key is called `greeting`, the
    environment variable will also be named `greeting` (in lowercase). To make your
    environment variable names uppercase when you’re using `envFrom`, change them
    in the ConfigMap.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`demo-config` ConfigMap 中的每个设置都将成为容器环境中的变量。因为在我们的示例 ConfigMap 中键称为 `greeting`，所以环境变量也将被命名为
    `greeting`（小写）。如果您在使用 `envFrom` 时希望使环境变量名大写，请在 ConfigMap 中进行更改。
- en: You can also set other environment variables for the container in the normal
    way, using `env`, either by putting the literal values in the manifest file or
    using a `ConfigMapKeyRef`, as in our previous example. Kubernetes allows you to
    use either `env`, `envFrom`, or both at once to set environment variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以像在我们之前的示例中那样，在清单文件中直接放置文字值或使用 `ConfigMapKeyRef`，正常方式设置容器的其他环境变量。Kubernetes
    允许您同时使用 `env`、`envFrom` 或两者来设置环境变量。
- en: If a variable set in `env` has the same name as one set in `envFrom`, it will
    take precedence. For example, if you set the variable `GREETING` in both `env`
    and a ConfigMap referenced in `envFrom`, the value specified in `env` will override
    the one from the ConfigMap.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 `env` 中设置的变量与在 `envFrom` 中引用的 ConfigMap 中设置的变量名称相同，则将优先使用 `env` 中指定的值。例如，如果您在
    `env` 和 `envFrom` 中引用的 ConfigMap 中同时设置了变量 `GREETING`，则 `env` 中指定的值将覆盖 ConfigMap
    中的值。
- en: Using Environment Variables in Command Arguments
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在命令参数中使用环境变量
- en: While it’s useful to be able to put configuration data into a container’s environment,
    sometimes you need to supply it as command-line arguments for the container’s
    entrypoint instead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将配置数据放入容器环境非常有用，但有时您需要将其作为容器入口点的命令行参数来提供。
- en: You can do this by sourcing the environment variables from the ConfigMap, as
    in the previous example, but using the special Kubernetes syntax `$(VARIABLE)`
    to reference them in the command-line arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从 ConfigMap 中获取环境变量，如前面的示例那样，但使用特殊的 Kubernetes 语法 `$(VARIABLE)` 在命令行参数中引用它们。
- en: 'In the *hello-config-args* directory of the demo repo, you’ll find this example
    in the *deployment.yaml* file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示库的 *hello-config-args* 目录中，您可以在 *deployment.yaml* 文件中找到这个示例：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we’ve added an `args` field for the container spec, which will pass our
    custom arguments to the container’s default entrypoint (`/bin/demo`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为容器规范添加了一个 `args` 字段，这将把我们的自定义参数传递给容器的默认入口点（`/bin/demo`）。
- en: Kubernetes replaces anything of the form `$(VARIABLE)` in a manifest with the
    value of the environment variable `VARIABLE`. Since we’ve created the `GREETING`
    variable and set its value from the ConfigMap, it’s available for use in the container’s
    command line.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 会将清单中形式为 `$(VARIABLE)` 的任何内容替换为环境变量 `VARIABLE` 的值。由于我们已创建了 `GREETING`
    变量并从 ConfigMap 设置了其值，因此可以在容器的命令行中使用它。
- en: 'When you apply these manifests, the value of `GREETING` will be passed to the
    demo app in this way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当您应用这些清单时，`GREETING` 的值将以这种方式传递给演示应用程序：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the effect in your web browser:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在您的网络浏览器中看到效果：
- en: '`Salut, 世界`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Salut, 世界`'
- en: Creating Config Files from ConfigMaps
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 ConfigMap 创建配置文件
- en: 'We’ve seen a couple of different ways of getting data from Kubernetes ConfigMaps
    into applications: via the environment and via the container command line. More
    complex applications, however, often expect to read their configuration from files
    on disk.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种不同的方法将 Kubernetes ConfigMap 中的数据传递到应用程序中：通过环境和通过容器命令行。然而，更复杂的应用程序通常希望从磁盘上的文件中读取它们的配置。
- en: 'Fortunately, Kubernetes gives us a way to create such files directly from a
    ConfigMap. First, let’s change our ConfigMap so that instead of a single key,
    it stores a complete YAML file (which happens to only contain one key, but it
    could be a hundred, if you like):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kubernetes 提供了一种直接从 ConfigMap 创建这些文件的方法。首先，让我们更改我们的 ConfigMap，使其不再是单个键，而是存储一个完整的
    YAML 文件（这个文件恰好只包含一个键，但如果您愿意，它可以是一百个）：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead of setting the key `greeting`, as we did in the previous example, we’re
    creating a new key called `config`, and assigning it a *block* of data (the pipe
    symbol `|` in YAML indicates that what follows is a block of raw data). This is
    the data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例中设置 `greeting` 键不同，我们正在创建一个名为 `config` 的新键，并将其分配给一个数据 *块*（YAML 中的竖线符号
    `|` 表示接下来是一个原始数据块）。这就是数据的内容：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It happens to be valid YAML, but don’t be confused by that; it could be JSON,
    TOML, plain text, or any other format. Whatever it is, Kubernetes will eventually
    write the whole block of data, as is, to a file on our container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它碰巧是有效的 YAML，但不要因此而困惑；它可以是 JSON、TOML、纯文本或任何其他格式。无论是什么，Kubernetes 最终都会将整个数据块按原样写入容器中的文件。
- en: 'Now that we’ve stored the necessary data, let’s deploy it to Kubernetes. In
    the *hello-config-file* directory of the demo repo, you’ll find the Deployment
    template, containing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经存储了必要的数据，让我们将其部署到 Kubernetes。在 demo 仓库的 *hello-config-file* 目录中，您会找到包含
    Deployment 模板的内容：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Looking at the `volumes` section, you can see that we create a Volume named
    `demo-config-volume`, from the existing `demo-config` ConfigMap.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `volumes` 部分，您可以看到我们从现有的 `demo-config` ConfigMap 创建了一个名为 `demo-config-volume`
    的 Volume。
- en: 'In the container’s `volumeMounts` section, we mount this volume on the `mountPath:
    /config/`, select the key `config`, and write it to the path *demo.yaml*. The
    result of this will be that Kubernetes will create a file in the container at
    */config/demo.yaml*, containing the `demo-config` data in YAML format:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '在容器的 `volumeMounts` 部分，我们将此 Volume 挂载在 `mountPath: /config/` 上，选择 `config`
    键，并将其写入路径 *demo.yaml*。其结果将是，Kubernetes 将在容器中创建一个文件 */config/demo.yaml*，其中包含 YAML
    格式中的 `demo-config` 数据：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The demo application will read its config from this file on startup. As before,
    apply the manifests using this command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 演示应用程序将在启动时从此文件读取其配置。像以前一样，使用以下命令应用清单：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the results in your web browser:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在您的 Web 浏览器中看到结果：
- en: '`Buongiorno, 世界`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buongiorno, 世界`'
- en: 'If you want to see what the ConfigMap data looks like in the cluster, run the
    following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看集群中 ConfigMap 数据的内容，请运行以下命令：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you update a ConfigMap and change its values, the corresponding file (*/config/demo.yaml*
    in our example) will be updated automatically. Some applications may autodetect
    that their config file has changed and reread it; others may not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更新 ConfigMap 并更改其值，则相应的文件（在我们的示例中为 */config/demo.yaml*）将自动更新。某些应用程序可能会自动检测到其配置文件已更改并重新读取它；其他则可能不会。
- en: One option is to redeploy the application to pick up the changes (see [“Updating
    Pods on a Config Change”](#configchange)), but this may not be necessary if the
    application has a way to trigger a live reload, such as a Unix signal (for example
    `SIGHUP`), or run a command in the container.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是重新部署应用程序以获取更改（参见[“更新 Pods 的配置更改”](#configchange)），但如果应用程序有触发实时重新加载的方式，例如
    Unix 信号（例如 `SIGHUP`）或在容器中运行命令，这可能并不必要。
- en: Updating Pods on a Config Change
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 Pods 的配置更改
- en: 'Suppose you have a Deployment running in your cluster, and you want to change
    some values in its ConfigMap. If you’re using a Helm chart (see [“Helm: A Kubernetes
    Package Manager”](ch04.html#helm-intro)), there’s a neat trick to have it automatically
    detect a config change and reload your Pods. Add this annotation to your Deployment
    spec:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在集群中运行一个 Deployment，并且您想更改其 ConfigMap 中的一些值。如果您正在使用 Helm chart（参见[“Helm：Kubernetes
    包管理器”](ch04.html#helm-intro)），有一个巧妙的技巧可以使其自动检测配置更改并重新加载您的 Pods。在您的 Deployment
    规范中添加此注释：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because the Deployment template now includes a hash sum of the config settings,
    if these settings change, then so will the hash. When you run `helm upgrade`,
    Helm will detect that the Deployment spec has changed, and restart all the Pods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Deployment 模板现在包含配置设置的哈希值，如果这些设置更改，哈希也会更改。当您运行 `helm upgrade` 时，Helm 将检测到
    Deployment 规范已更改，并重新启动所有 Pods。
- en: Kubernetes Secrets
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes Secrets
- en: We’ve seen that the Kubernetes ConfigMap object provides a flexible way of storing
    and accessing configuration data in the cluster. However, most applications have
    some config data that is secret and sensitive, such as passwords or API keys.
    While we could use ConfigMaps to store these, that’s not an ideal solution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Kubernetes ConfigMap 对象提供了一种灵活的方式来存储和访问集群中的配置数据。然而，大多数应用程序都有一些涉及密码或 API
    密钥等机密和敏感的配置数据。虽然我们可以使用 ConfigMaps 来存储这些数据，但这并不是一个理想的解决方案。
- en: 'Instead, Kubernetes provides a special type of object intended to store secret
    data: the Secret. Let’s see an example of how to use it with the demo application.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Kubernetes 提供了一种特殊的对象类型来存储秘密数据：Secret。让我们看一个如何在演示应用程序中使用它的示例。
- en: 'First, here’s the Kubernetes manifest for the Secret (see *hello-secret-env/k8s/secret.yaml*):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是 Secret 的 Kubernetes 清单（参见 *hello-secret-env/k8s/secret.yaml*）：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the secret key is `magicWord`, and the secret value is the
    word [`xyzzy`](https://oreil.ly/Ww0ME) (a very useful word in computing). As with
    a ConfigMap, you can put multiple keys and values into a Secret. Here, just to
    keep things simple, we’re only using one key-value pair.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，秘密键是 `magicWord`，秘密值是单词 [`xyzzy`](https://oreil.ly/Ww0ME)（在计算中非常有用）。与 ConfigMap
    一样，你可以在 Secret 中放入多个键和值。这里为了简单起见，我们只使用一个键值对。
- en: Using Secrets as Environment Variables
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Secrets 作为环境变量
- en: 'Just like ConfigMaps, Secrets can be made visible to containers by putting
    them into environment variables, or mounting them as a file on the container’s
    filesystem. In this example, we’ll set an environment variable to the value of
    the Secret:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 ConfigMaps 一样，Secrets 可以通过将它们放入环境变量或者将它们作为文件挂载到容器的文件系统中，从而对容器可见。在这个例子中，我们将设置一个环境变量，其值为
    Secret 的值：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We set the environment variable `MAGIC_WORD` exactly as we did when using a
    ConfigMap, except that now it’s a `secretKeyRef` instead of a `configMapKeyRef`
    (see [“Setting Environment Variables from ConfigMaps”](#envconfig)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了环境变量 `MAGIC_WORD`，方式与使用 ConfigMap 时完全相同，只是现在是一个 `secretKeyRef` 而不是 `configMapKeyRef`（参见
    [“从 ConfigMaps 设置环境变量”](#envconfig)）。
- en: 'Run the following command in the demo repo directory to apply these manifests:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示库目录中运行以下命令来应用这些清单：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As before, forward a local port to the Deployment so you can see the results
    in your web browser:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，将本地端口转发到 Deployment，以便在 Web 浏览器中查看结果：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Browse to *http://localhost:9999/* and you should see:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到 *http://localhost:9999/*，你应该能看到：
- en: '`The magic word is "xyzzy"`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`魔法词是 "xyzzy"`'
- en: Writing Secrets to Files
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入 Secrets 到文件
- en: In this example, we’ll mount the Secret on the container as a file. You’ll find
    the code for this example in the *hello-secret-file* folder of the demo repo.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将把 Secret 作为文件挂载到容器中。你可以在演示库的 *hello-secret-file* 文件夹中找到这个示例的代码。
- en: 'In order to mount the Secret in a file on the container, we use a Deployment
    like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在容器中将 Secret 挂载为文件，我们使用了如下的 Deployment：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just as we did in [“Creating Config Files from ConfigMaps”](#hello-config-file),
    we create a Volume (`demo-secret-volume` in this example), and mount it on the
    container in the `volumeMounts` section of the spec. The `mountPath` is `/secrets`,
    and Kubernetes will create one file in this directory for each of the key-value
    pairs defined in the Secret.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 [“从 ConfigMaps 创建配置文件”](#hello-config-file) 中所做的一样，我们创建了一个 Volume（本例中为
    `demo-secret-volume`），并在 spec 的 `volumeMounts` 部分将其挂载到容器上。`mountPath` 是 `/secrets`，Kubernetes
    将在该目录下为 Secret 中定义的每个键值对创建一个文件。
- en: We’ve only defined one key-value pair in the example Secret, named `magicWord`,
    so this manifest will create the read-only file */secrets/magicWord* on the container,
    and the contents of the file will be the secret data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例 Secret 中，我们只定义了一个名为 `magicWord` 的键值对，因此此清单将在容器中创建只读文件 */secrets/magicWord*，文件的内容将是秘密数据。
- en: 'If you apply this manifest in the same way as for the previous example, you
    should see the same results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像前面的示例一样应用这个清单，你应该能看到相同的结果：
- en: '`The magic word is "xyzzy"`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`魔法词是 "xyzzy"`'
- en: Reading Secrets
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取 Secrets
- en: In the previous section, we were able to use `kubectl describe` to see the data
    inside the ConfigMap. Can we do the same with a Secret?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们能够使用 `kubectl describe` 查看 ConfigMap 中的数据。我们能否对 Secret 也做同样的操作呢？
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that this time, the actual data is not shown. Kubernetes Secrets are
    `Opaque`, which means they’re not shown in `kubectl describe` output, in log messages,
    or in the terminal. This prevents secret data being exposed accidentally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次不显示实际数据。Kubernetes 的 Secrets 是 `Opaque` 类型，这意味着它们不会显示在 `kubectl describe`
    的输出中，也不会出现在日志消息或终端中。这可以防止秘密数据意外暴露。
- en: 'You can see an obfuscated version of the secret data by using `kubectl get`
    with YAML output format:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `kubectl get` 命令以 YAML 输出格式查看秘密数据的模糊版本：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: base64
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: base64
- en: What’s that `eHl6enk=`? That doesn’t look much like our original secret data.
    In fact, it’s a *base64* representation of the Secret. Base64 is a scheme for
    encoding arbitrary binary data as a character string.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `eHl6enk=` 是什么？它看起来与我们原始的秘密数据不太相似。事实上，这是 Secret 的 *base64* 表示。Base64 是一种将任意二进制数据编码为字符字符串的方案。
- en: Because the secret data could be nonprintable binary data (for example, a Transport
    Layer Security [TLS] encryption key), Kubernetes Secrets are always stored in
    base64 format.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为秘密数据可能是不可打印的二进制数据（例如，传输层安全 [TLS] 加密密钥），所以 Kubernetes Secrets 总是以 base64 格式存储。
- en: 'The text `eHl6enk=` is the base64-encoded version of our secret word `xyzzy`.
    You can verify this using the `base64 --decode` command in the terminal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 文本 `eHl6enk=` 是我们秘密词 `xyzzy` 的 base64 编码版本。您可以在终端使用 `base64 --decode` 命令验证这一点：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So although Kubernetes protects you from accidentally printing secret data to
    the terminal, or in log files, if you have permission to read the Secrets in a
    particular namespace, you can get the data in base64 format and then decode it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Kubernetes 可以防止您意外地将秘密数据打印到终端或日志文件中，但如果您有权限读取特定命名空间中的 Secrets，则可以获取以 base64
    格式编码的数据，然后解码它。
- en: 'If you need to base64-encode some text (for instance, to add it to a Secret),
    use the `base64` tool with the `-n` flag to avoid including a newline character:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要对一些文本进行 base64 编码（例如，将其添加到 Secret 中），请使用带有 `-n` 标志的 `base64` 工具以避免包含换行符：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Access to Secrets
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 Secrets
- en: Who can read or edit Secrets? That’s controlled by the Kubernetes access control
    mechanism, RBAC, which we’ll talk about in much more detail in [“Introducing Role-Based
    Access Control (RBAC)”](ch11.html#rbac).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 谁可以读取或编辑 Secrets？这由 Kubernetes 访问控制机制 RBAC 控制，我们将在 [“介绍基于角色的访问控制（RBAC）”](ch11.html#rbac)
    中详细讨论。
- en: Encryption at Rest
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态加密
- en: What about someone with access to the `etcd` database where all Kubernetes information
    is stored? Could they access the secret data, even without API permissions to
    read the Secret object?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果有人能够访问存储所有 Kubernetes 信息的 `etcd` 数据库呢？即使没有 API 权限读取 Secret 对象，他们也能访问秘密数据吗？
- en: From Kubernetes version 1.7 onward, *encryption at rest* is supported. That
    means that the secret data in the `etcd` database is actually stored encrypted
    on disk, and unreadable even to someone who can access the database directly.
    Only the Kubernetes API server has the key to decrypt this data. In a properly
    configured cluster, encryption at rest should be enabled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Kubernetes 版本 1.7 开始，支持 *静态加密*。这意味着存储在 `etcd` 数据库中的秘密数据实际上以加密形式存储在磁盘上，即使可以直接访问数据库的人也无法阅读。只有
    Kubernetes API 服务器有解密此数据的密钥。在正确配置的集群中，应启用静态加密。
- en: Keeping Secrets and ConfigMaps
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持 Secrets 和 ConfigMaps
- en: 'As of version 1.21, Kubernetes supports [Immutable Secrets](https://oreil.ly/5797O)
    and [Immutable ConfigMaps](https://oreil.ly/baz5W). Adding `immutable: true` to
    the Secret or ConfigMap manifest will prevent it from being modified. The only
    way to change an Immutable Secret or ConfigMap is to delete and re-create a new
    one.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '从版本 1.21 开始，Kubernetes 支持 [不可变的 Secrets](https://oreil.ly/5797O) 和 [不可变的 ConfigMaps](https://oreil.ly/baz5W)。在
    Secret 或 ConfigMap 的清单中添加 `immutable: true` 将阻止其被修改。更改不可变的 Secret 或 ConfigMap
    的唯一方法是删除并重新创建一个新的。'
- en: 'Sometimes you’ll have Kubernetes resources that you never want to be deleted
    from the cluster. If you are using Helm, then you can use a Helm-specific annotation
    to prevent a resource from being removed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会有一些 Kubernetes 资源，您永远不希望它们从集群中删除。如果您使用 Helm，则可以使用 Helm 特定的注释来防止资源被删除：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Secrets Management Strategies
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**保密管理策略**'
- en: In the example in the previous section, our secret data was protected against
    unauthorized access once it was stored in the cluster. But the secret data was
    represented in plain text in our manifest files.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的示例中，一旦我们将秘密数据存储在集群中，就能保护它免受未授权访问。但秘密数据在我们的清单文件中以明文形式表示。
- en: You should never expose secret data like this in files that are committed to
    source control. So how do you manage and store secret data securely before it’s
    applied to the Kubernetes cluster?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您永远不应该在提交到源代码控制的文件中公开此类机密数据。那么，在应用于 Kubernetes 集群之前，如何安全地管理和存储机密数据呢？
- en: 'Whatever tool or strategy you choose for managing secrets in your applications,
    you’ll need it to answer at least the following questions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择何种工具或策略来管理应用程序中的机密信息，您都需要至少回答以下问题：
- en: Where do you store secrets so that they are highly available?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该将机密信息存储在何处，以确保其高可用性？
- en: How do you make secrets available to your running applications?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使机密信息对运行中的应用程序可用？
- en: What needs to happen to your running applications when you rotate or change
    secrets?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您更换或更改机密信息时，运行中的应用程序需要执行哪些操作？
- en: In this section we’ll look at some of the popular secrets management strategies,
    and examine how each of them tackles these questions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些流行的机密管理策略，并分析它们如何处理这些问题。
- en: Encrypt Secrets in Version Control
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在版本控制中加密机密信息
- en: The first and perhaps simplest option for secrets management is to store your
    secrets directly in your version control repos alongside your source code, but
    in encrypted form. Secrets that are stored in source code repos should never be
    saved in plain text. Instead, they are encrypted in a form that can only be decrypted
    with a certain trusted key, either at deploy time or at startup time. The application
    can then read and use the decrypted secrets just like any other configuration
    data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 处理机密信息的第一种，也许是最简单的选项是将机密信息直接存储在版本控制存储库中，与源代码一起，但是以加密形式存储。存储在源代码存储库中的机密信息绝不能以明文保存。相反，它们以一种只能在部署时或启动时使用某个受信任密钥解密的形式加密。然后，应用程序可以像处理任何其他配置数据一样读取和使用解密后的机密信息。
- en: Encrypting secrets in version control lets you review and track changes to secrets,
    just as you would do for changes to application code. And so long as your version
    control repositories are highly available, your secrets will be highly available
    as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本控制中加密机密信息，您可以像处理应用程序代码更改一样审查和跟踪机密信息的更改。只要您的版本控制存储库具有高可用性，您的机密信息也将具有高可用性。
- en: To change or rotate secrets, just decrypt them in your local copy of the source,
    update them, re-encrypt, and commit the change to version control.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改或轮换机密信息，只需在源代码的本地副本中解密它们，更新它们，重新加密并将更改提交到版本控制。
- en: While this strategy is simple to implement and has no dependencies except the
    key and the encryption/decryption tool, there are a few potential drawbacks. If
    the same secret is used by multiple applications, they all need a copy of it in
    their source code. This means rotating the secret is more work, because you have
    to make sure you’ve found and changed all instances of it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种策略实施简单，除了密钥和加密/解密工具外没有依赖性，但也存在一些潜在的缺点。如果多个应用程序使用相同的机密信息，则所有应用程序都需要其源代码中的副本。这意味着更换机密信息会更费功夫，因为您必须确保找到并更改了所有实例。
- en: There is also a serious risk of accidentally committing plain-text secrets to
    version control. Mistakes do happen, and even with private version control repositories,
    any secret so committed should be considered compromised, and you should rotate
    it as soon as possible. Reconciling merge conflicts in source control with encrypted
    secrets can also be tricky.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在意外提交明文机密信息到版本控制也存在严重风险。错误是难免的，即使是私有版本控制存储库，任何这样提交的机密信息都应视为已泄露，应尽快进行更换。在源代码控制中处理带有加密机密信息的合并冲突也可能会有些棘手。
- en: Nonetheless, this strategy could be a good starting point for smaller teams
    or for noncritical secrets. It’s relatively low-touch and easy to set up, while
    still being flexible enough to handle multiple apps and different types of secret
    data. In the final section of this chapter, we’ll outline some options for encryption/decryption
    tools you can use to do this, but first, let’s briefly describe the other secrets
    management strategies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，对于小团队或非关键机密信息而言，该策略可能是一个很好的起点。它相对不需要太多干预和易于设置，同时仍足够灵活，可以处理多个应用程序和不同类型的机密数据。在本章的最后一节中，我们将概述一些您可以使用的加密/解密工具选项，但首先，让我们简要描述其他机密管理策略。
- en: Use a Dedicated Secrets Management Tool
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用专用机密管理工具
- en: While encrypting secrets in source code is a relatively easy way to get started,
    you may want to evaluate using a dedicated secrets management tool, such as [HashiCorp’s
    Vault](https://www.vaultproject.io) or [Square’s Keywhiz](https://square.github.io/keywhiz).
    You could also consider using a managed cloud service such as [AWS Secrets Manager](https://oreil.ly/IVAhS),
    [Azure’s Key Vault](https://oreil.ly/4WaXg), or [Google’s Secret Manager](https://oreil.ly/257Ue).
    These tools handle the secure storing of all of your application secrets in one
    central place in a highly available way, and can also control which users and
    service accounts have permissions to add, remove, change, or view secrets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在源代码中加密机密信息是一个相对简单的入门方法，但您可能希望评估使用专用的机密管理工具，例如 [HashiCorp 的 Vault](https://www.vaultproject.io)
    或 [Square 的 Keywhiz](https://square.github.io/keywhiz)。您还可以考虑使用托管的云服务，例如 [AWS
    Secrets Manager](https://oreil.ly/IVAhS)，[Azure 的 Key Vault](https://oreil.ly/4WaXg)，或者
    [Google 的 Secret Manager](https://oreil.ly/257Ue)。这些工具以高可用的方式安全地存储所有应用程序机密，并且还可以控制哪些用户和服务账户具有添加、删除、更改或查看机密的权限。
- en: In a secrets management system, all actions are audited and reviewable, making
    it easier to analyze security breaches and prove regulatory compliance. Some of
    these tools also provide the ability to automatically rotate secrets on a regular
    basis, which is not only a good idea in any case, but is also required by many
    corporate security policies. Developers can have their own individual credentials,
    with permission to read or write secrets for only the applications that they’re
    responsible for.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在机密管理系统中，所有操作都经过审计和可审查，这样更容易分析安全漏洞并证明合规性。一些工具还提供定期自动轮换机密的能力，这不仅在任何情况下都是个好主意，而且在许多企业安全策略中也是必需的。开发人员可以拥有自己的个人凭据，只有对他们负责的应用程序的读取或写入机密的权限。
- en: How do applications get their data from a secrets management tool? One common
    way is to use a service account with read-only access to the secrets vault so
    that each application can only read the secrets it needs. Often an Init container
    (see [“Init Containers”](ch08.html#init-containers)) is used to first pull and
    decrypt the secrets and then mount them into the Pod using a Volume.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序如何从机密管理工具获取数据？一种常见的方法是使用一个具有对机密保险库只读访问权限的服务账户，以便每个应用程序只能读取其所需的机密。通常会使用一个初始化容器（参见[“初始化容器”](ch08.html#init-containers)）首先拉取并解密机密，然后通过卷挂载到
    Pod 中。
- en: While a central secrets management system is the most powerful and flexible
    option available, it also adds significant complexity to your infrastructure,
    especially if you decide to host the tooling yourself. Using a managed solution
    would free you up from running this infrastructure, but they come with added cost
    to your cloud bill. You will also need to implement a process or some middleware
    to your applications to consume secrets securely. While applications could be
    built to access a particular secrets vault directly, this may be more expensive
    and time-consuming than simply adding a layer in front of them that gets secrets
    and puts them in the application’s environment or config file at startup time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然集中式机密管理系统是目前最强大和灵活的选择，但它也会给您的基础架构增加相当多的复杂性，特别是如果您决定自行托管工具。使用托管解决方案将使您摆脱运行此基础架构的负担，但会增加您的云账单成本。您还需要为应用程序实施一些中间件或流程来安全地使用机密。虽然应用程序可以直接访问特定的机密保险库，但与直接在其前面添加一个获取机密并在应用程序启动时将其放入环境或配置文件中的层相比，这可能更昂贵和耗时。
- en: Encrypting Secrets with Sops
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sops 加密机密信息
- en: Let’s now look at a popular encryption tool that you can use for storing your
    secrets securely in source control. Sops (short for *secrets operations*), from
    the Mozilla project, is an encryption/decryption tool that is compatible with
    YAML, JSON, or binary files, and supports multiple encryption backends, including
    [`age`](https://oreil.ly/d6jtA), [Azure Key Vault](https://oreil.ly/4WaXg), [AWS’s
    Key Management Service (KMS)](https://oreil.ly/pyDJT), and [Google’s Cloud KMS](https://oreil.ly/N7Bo4).
    Visit the [Sops project home page](https://oreil.ly/7oGbC) for installation and
    usage instructions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看一个流行的加密工具，您可以使用它在源代码中安全存储您的机密信息。Sops（*secrets operations* 的缩写），来自 Mozilla
    项目，是一个与 YAML、JSON 或二进制文件兼容的加密/解密工具，支持多种加密后端，包括 [`age`](https://oreil.ly/d6jtA)，[Azure
    Key Vault](https://oreil.ly/4WaXg)，[AWS 的密钥管理服务 (KMS)](https://oreil.ly/pyDJT)，以及
    [Google 的 Cloud KMS](https://oreil.ly/N7Bo4)。访问 [Sops 项目主页](https://oreil.ly/7oGbC)
    获取安装和使用说明。
- en: 'Rather than encrypting the whole file, Sops encrypts only the individual secret
    values in key-value pairs. For example, if your plain-text file contains:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Sops不是加密整个文件，而是仅加密键-值对中的个别密钥值。例如，如果你的明文文件包含：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'when you encrypt it with Sops, the resulting file will look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用Sops加密时，生成的文件将如下所示：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This makes it easy to review the code without needing to decrypt the value in
    order to understand which key is being used.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以轻松地查看代码，而无需解密值就能理解使用的哪个密钥。
- en: Encrypting a File with Sops
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sops加密文件
- en: Let’s try out Sops by encrypting a file. As we mentioned, Sops doesn’t actually
    handle encryption itself; it delegates that to a different backend tool. We’ll
    use Sops with a tool called `age` in this example to encrypt a file containing
    a secret. The end result will be a file that you could safely commit to version
    control.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试Sops来加密一个文件。正如我们提到的，Sops实际上不处理加密本身；它将其委托给一个不同的后端工具。在本例中，我们将使用一个名为`age`的工具与Sops一起加密一个包含秘密的文件。最终结果将是一个可以安全提交到版本控制的文件。
- en: 'We won’t get into the details of how exactly encryption with `age` works, but
    just know that, like SSH and TLS, it’s a *public key* cryptosystem. Instead of
    encrypting data with a single key, it actually uses a pair of keys: one public,
    one private. You can safely share your public key with others, but you should
    never give out your private key.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讨论`age`加密的工作原理，但请知道，它像SSH和TLS一样，是一种*公钥*加密系统。它不是用单一密钥加密数据，而是使用一对密钥：一个公钥，一个私钥。你可以安全地与他人分享你的公钥，但绝不能泄露你的私钥。
- en: Let’s generate your key pair now. First, [install age](https://oreil.ly/CPGhH),
    if you haven’t already.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们生成你的密钥对。首先，[安装age](https://oreil.ly/CPGhH)，如果你还没有安装。
- en: 'Once that’s installed, run this command to generate a new key pair:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，请运行以下命令生成一个新的密钥对：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once your key has been successfully generated, make a note of the `Public key`.
    It will be unique to you and identifies the key you just created. The *key.txt*
    file also contains your private key, so it should be stored securely and never
    committed into source control.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的密钥成功生成，请记下`Public key`。它将是唯一的，并且标识刚刚创建的密钥。*key.txt*文件还包含你的私钥，因此应该安全地存储，永远不要提交到源代码控制中。
- en: Now let’s encrypt a file using Sops and `age`. You will also need to have Sops
    installed on your machine, if you haven’t already.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用Sops和`age`来加密一个文件。如果你还没有在你的机器上安装Sops，请先安装它。
- en: 'First let’s create a test secret YAML file to encrypt:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们创建一个测试秘密的YAML文件来加密：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And now, use Sops to encrypt it. Pass your key fingerprint to the `--age` switch
    and your `Public key` from above, like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Sops进行加密。将你的密钥指纹传递给`--age`开关和上面的`Public key`，就像这样：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Success! The *test.yaml* file is encrypted securely, and the value of `password`
    is scrambled and can only be decrypted with your private key. You will also notice
    that Sops added some metadata to the bottom of the file so that it will know how
    to decrypt it in the future.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！*test.yaml*文件已经安全加密，`password`的值被加密并且只能用你的私钥解密。你还会注意到，Sops在文件底部添加了一些元数据，以便将来如何解密它。
- en: A nice feature of Sops is that because only the *value* of `password` is encrypted,
    the YAML format of the file is preserved and you can still view the names of the
    keys.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Sops的一个很好的特性是，因为只有`password`的*值*被加密，文件的YAML格式保持不变，你仍然可以查看密钥的名称。
- en: 'To make sure that we can get the encrypted data back, and to check that it
    matches what we put in, run:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们能够恢复加密数据，并检查它是否与我们输入的匹配，请运行：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `SOPS_AGE_KEY_FILE` part of the command points to the location of the key
    file you originally generated with `age`. You could consider storing that file
    in the default location that Sops expects, which is your *$HOME/sops/* directory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 命令中的`SOPS_AGE_KEY_FILE`部分指向你最初与`age`生成的密钥文件的位置。你可以考虑将该文件存储在Sops期望的默认位置，即你的*$HOME/sops/*目录。
- en: When it comes time to deploy the application, you can use Sops in decrypt mode
    to produce the plain-text secrets that your application uses—but remember to delete
    the plain-text files afterward, and don’t ever check them in to version control!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署应用程序时，可以使用Sops解密模式来生成应用程序使用的明文密钥——但记住在之后删除明文文件，并且永远不要提交它们到版本控制！
- en: When using Sops as part of a centralized CI/CD pipeline, your deploy server
    infrastructure would also need an `age` key and to be a [trusted recipient](https://oreil.ly/zjPJs)
    in order to decrypt the file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为集中式CI/CD流水线的一部分使用Sops时，您的部署服务器基础架构还需要一个`age`密钥，并且必须是一个[受信任的接收者](https://oreil.ly/zjPJs)，以便解密文件。
- en: 'Now that you know how to use Sops, you can encrypt any sensitive data in your
    source code, whether that’s application config files, Kubernetes YAML resources,
    or anything else. Later on, we’ll show you how to use Sops this way with Helm
    charts. You can not only decrypt secrets when deploying your application with
    Helm, but also use different sets of secrets, depending on the deployment environment:
    for example, `staging` versus `production` (see [“Managing Helm Chart Secrets
    with Sops”](ch12.html#helmsops)).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用Sops，在您的源代码中可以加密任何敏感数据，无论是应用程序配置文件、Kubernetes YAML资源还是其他任何内容。接下来，我们将向您展示如何在Helm
    chart中以这种方式使用Sops。您不仅可以在使用Helm部署应用程序时解密秘密，还可以根据部署环境使用不同的秘密集：例如，`staging`与`production`（参见[“使用Sops管理Helm
    Chart中的秘密”](ch12.html#helmsops)）。
- en: It is also worth mentioning that if you need to manage encrypted secrets inside
    of a Helm chart, you can do that with a plugin called `helm-secrets`. When you
    run `helm upgrade...` or `helm install...`, `helm-secrets` will decrypt your secrets
    for deployment. For more information about `helm-secrets`, including installation
    and usage instructions, consult the [GitHub repo](https://oreil.ly/p3KBj).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，如果您需要在Helm chart中管理加密的秘密，可以使用名为`helm-secrets`的插件来完成。当您运行`helm upgrade...`或`helm
    install...`时，`helm-secrets`将解密部署所需的秘密。有关`helm-secrets`的更多信息，包括安装和使用说明，请参阅[GitHub仓库](https://oreil.ly/p3KBj)。
- en: Using a KMS Backend
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用KMS后端
- en: 'If you are using Amazon KMS or Google Cloud KMS for key management in the cloud,
    you can also use them with Sops. Using a KMS key works exactly the same as in
    our `age` example, but the metadata in the file will be different. Instead, the
    `sops:` section at the bottom might look something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在云中使用Amazon KMS或Google Cloud KMS进行密钥管理，也可以将它们与Sops一起使用。在我们的`age`示例中，使用KMS密钥的方式完全相同，但文件中的元数据将不同。文件底部的`sops:`部分可能看起来像这样：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just like with `age`, the key ID (`arn:aws:kms...`) is embedded in the file
    so that Sops knows how to decrypt it later.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`age`一样，文件中嵌入了密钥ID（`arn:aws:kms...`），以便Sops知道如何稍后解密它。
- en: Sealed Secrets
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sealed Secrets
- en: Another good option for storing encrypted secrets in source control is an open
    source tool maintained by the folks at Bitnami called [Sealed Secrets](https://oreil.ly/Lq6Zo).
    Unlike with Sops, in this case the encryption keys are actually generated, installed,
    and stored inside of your Kubernetes clusters, making the deployment and decryption
    process straightforward.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在源代码控制中存储加密密钥的好选择是Bitnami团队维护的开源工具[Sealed Secrets](https://oreil.ly/Lq6Zo)。与Sops不同的是，在这种情况下，加密密钥实际上是在您的Kubernetes集群内生成、安装和存储的，使部署和解密过程变得简单直接。
- en: Once Sealed Secrets is installed, you can use the `kubeseal` client tool to
    encrypt a Kubernetes Secret. This generates a new `SealedSecret` that can then
    be safely committed into your source control repo, much like the encrypted YAML
    files with Sops. When applied to the cluster, the Sealed Secret tooling will decrypt
    the `SealedSecret` object from inside Kubernetes and securely pass it to your
    application Pods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Sealed Secrets后，您可以使用`kubeseal`客户端工具来加密Kubernetes Secret。这将生成一个新的`SealedSecret`，然后可以安全地提交到您的源代码仓库中，就像使用Sops加密的YAML文件一样。在应用到集群时，Sealed
    Secret工具将从Kubernetes内部解密`SealedSecret`对象，并安全传递给您的应用程序Pod。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Configuration and secrets is one of the topics that people ask us about the
    most in relation to Kubernetes. We’re glad to be able to devote a chapter to it,
    and to outline some ways you can connect your applications with the settings and
    data they need.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Kubernetes相关的配置和密钥是人们最常询问我们的主题之一。我们很高兴能够为此奉献一章，并概述一些将您的应用程序连接到所需设置和数据的方法。
- en: 'The most important things we’ve learned:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到的最重要的事情：
- en: Separate your configuration data from application code and deploy it using Kubernetes
    ConfigMaps and Secrets. That way, you don’t need to redeploy your app every time
    you change a password.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置数据与应用程序代码分离，并使用Kubernetes ConfigMaps和Secrets进行部署。这样，每次更改密码时，您无需重新部署应用程序。
- en: You can get data into ConfigMaps by writing it directly in your Kubernetes manifest
    file, or use `kubectl` to convert an existing YAML file into a ConfigMap spec.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过直接在你的Kubernetes清单文件中编写数据，或使用`kubectl`将现有的YAML文件转换为ConfigMap规范，将数据输入到ConfigMaps中。
- en: Once data is in a ConfigMap, you can insert it into a container’s environment,
    or into the command-line arguments of its entrypoint. Alternatively, you can write
    the data to a file that is mounted on the container.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦数据在ConfigMap中，你可以将它插入到容器的环境中，或者插入到其入口点的命令行参数中。或者，你可以将数据写入挂载在容器上的文件中。
- en: Secrets work just like ConfigMaps, except that the data is encrypted at rest,
    and obfuscated in `kubectl` output.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密的工作方式与ConfigMaps类似，不同之处在于数据在静态时加密，并在`kubectl`输出中混淆。
- en: A simple way to manage secrets is to store them directly in your source code
    repo, but encrypt them using Sops or another text-based encryption tool.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理秘密的一个简单方法是将它们直接存储在源代码仓库中，但使用Sops或其他基于文本的加密工具对其进行加密。
- en: Don’t overlook secrets management, especially at first. Start with something
    your team understands and that provides a secure process for managing secrets
    on your team.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忽视秘密管理，特别是在初始阶段。从团队理解的东西开始，提供一个安全的管理团队秘密的流程。
- en: Dedicated secret management tools like Vault, or hosted cloud KMS tools, add
    cost and complexity to your stack, but offer better auditing and flexibility for
    securing your secrets.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Vault这样的专用秘密管理工具，或者托管的云KMS工具，增加了堆栈的成本和复杂性，但提供了更好的审计和灵活性，用于安全地保护你的秘密。
- en: Sops is an encryption tool that works with key-value files like YAML and JSON.
    It can get its encryption key from a local keyring, or cloud key management services
    like Amazon KMS and Google Cloud KMS.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sops是一种加密工具，适用于像YAML和JSON这样的键值文件。它可以从本地密钥环或云密钥管理服务（如Amazon KMS和Google Cloud
    KMS）获取其加密密钥。
- en: Sealed Secrets makes it easy to store encrypted secrets in source control and
    securely pass them to your applications from within a Kubernetes cluster.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sealed Secrets使得在源代码控制中存储加密的秘密并从Kubernetes集群内安全传递它们到你的应用程序变得容易。
