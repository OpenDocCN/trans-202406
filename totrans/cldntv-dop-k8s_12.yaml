- en: Chapter 10\. Configuration and Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to keep a secret, you must also hide it from yourself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: George Orwell, *1984*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s very useful to be able to separate the *logic* of your Kubernetes application
    from its *configuration*: that is, any values or settings that might change over
    the life of the application. Configuration values commonly include things like
    environment-specific settings, DNS addresses of third-party services, and authentication
    credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: While you could simply put these values directly into your code, that’s not
    a very flexible approach. For one thing, changing a configuration value would
    require a complete rebuild and redeploy of the application. It’s much better to
    separate these values out from the code and read them in from a file, or from
    environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides a few different ways to help you manage configuration. One
    is to pass values to the application via environment variables in the Pod spec
    (see [“Environment Variables”](ch08.html#envvars)). Another is to store configuration
    data directly in Kubernetes, using the ConfigMap and Secret objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll explore ConfigMaps and Secrets in detail, and look at
    some practical techniques for managing configuration and secrets in applications,
    using the demo application as an example.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ConfigMap is the primary object for storing configuration data in Kubernetes.
    You can think of it as being a named set of key-value pairs that stores configuration
    data. Once you have a ConfigMap, you can supply that data to an application either
    by creating a file in the Pod, or by injecting it into the Pod’s environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at some different ways to get data into a ConfigMap,
    and then explore the various ways you can extract that data and feed it into your
    Kubernetes application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you want to create a YAML configuration file in your Pod’s filesystem
    named *config.yaml*, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Given this set of values, how do you turn them into a ConfigMap resource that
    you can apply to Kubernetes?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to specify that data as literal YAML values in the ConfigMap manifest.
    This is what the manifest for a ConfigMap object looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You could create a ConfigMap by writing the manifest from scratch, and adding
    the values from *config.yaml* into the `data` section, as we’ve done in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way, though, is to let `kubectl` do some of the work for you. You
    can create a ConfigMap directly from a YAML file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To export the manifest file that corresponds to this ConfigMap, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This writes a YAML manifest representation of the cluster’s ConfigMap resource
    to the file *demo-config.yaml*, however it will contain extra info like the `status`
    section that you may want to remove before applying again (see [“Exporting Resources”](ch07.html#exportflag)).
  prefs: []
  type: TYPE_NORMAL
- en: Setting Environment Variables from ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the required configuration data in a ConfigMap object, how
    do we then get that data into a container? Let’s look at a complete example using
    our demo application. You’ll find the code in the *hello-config-env* directory
    of the demo repo.
  prefs: []
  type: TYPE_NORMAL
- en: It’s the same demo application we’ve used in previous chapters that listens
    for HTTP requests and responds with a greeting (see [“Looking at the Source Code”](ch02.html#demo-source)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, though, instead of hard coding the string `Hello` into the application,
    we’d like to make the greeting configurable. So there’s a slight modification
    to the `handler` function to read this value from the environment variable `GREETING`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry about the exact details of the Go code; it’s just a demo. Suffice
    it to say that if the `GREETING` environment variable is present when the program
    runs, it will use that value when responding to requests. Whatever language you’re
    using to write applications, it’s a good bet that you’ll be able to read environment
    variables with it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create the ConfigMap object to hold the greeting value. You’ll find
    the manifest file for the ConfigMap, along with the modified Go application, in
    the *hello-config-env* directory of the demo repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make this data visible in the container’s environment, we need
    to modify the Deployment slightly. Here’s the relevant part of the demo Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we’re using a different container image tag to that in previous examples
    (see [“Image Identifiers”](ch08.html#image-identifiers)). The `:hello-config-env`
    tag gets us the modified version of the demo application that reads the `GREETING`
    variable: `cloudnatived/demo:hello-config-env`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second point of interest is the `env` section. Remember from [“Environment
    Variables”](ch08.html#envvars) that you can create environment variables with
    literal values by adding a `name`/`value` pair.
  prefs: []
  type: TYPE_NORMAL
- en: We still have `name` here, but instead of `value`, we’ve specified `valueFrom`.
    This tells Kubernetes that, rather than taking a literal value for the variable,
    it should look elsewhere to find the value.
  prefs: []
  type: TYPE_NORMAL
- en: '`configMapKeyRef` tells it to reference a specific key in a specific ConfigMap.
    The name of the ConfigMap to look at is `demo-config`, and the key we want to
    look up is `greeting`. We created this data with the ConfigMap manifest, so it
    should now be available to read into the container’s environment.'
  prefs: []
  type: TYPE_NORMAL
- en: If the ConfigMap doesn’t exist, the Deployment won’t be able to run (its Pod
    will show a status of `CreateContainerConfigError`).
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s everything you need to make the updated application work, so go ahead
    and deploy the manifests to your Kubernetes cluster. From the demo repo directory,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, to see the application in your web browser, you’ll need to forward
    a local port to the Pod’s port 8888:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (We didn’t bother creating a Service this time; while you’d use a Service with
    a real production app, for this example we’ve just used `kubectl` to forward the
    local port directly to the `demo` Deployment.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you point your web browser to http://localhost:9999/, you should see, if
    all is well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hola, 世界`'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Whole Environment from a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you can set one or two environment variables from individual ConfigMap
    keys, as we saw in the previous example, that could get tedious for a large number
    of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there’s an easy way to take all the keys from a ConfigMap and
    turn them into environment variables, using `envFrom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now every setting in the `demo-config` ConfigMap will be a variable in the container’s
    environment. Because in our example ConfigMap the key is called `greeting`, the
    environment variable will also be named `greeting` (in lowercase). To make your
    environment variable names uppercase when you’re using `envFrom`, change them
    in the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set other environment variables for the container in the normal
    way, using `env`, either by putting the literal values in the manifest file or
    using a `ConfigMapKeyRef`, as in our previous example. Kubernetes allows you to
    use either `env`, `envFrom`, or both at once to set environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: If a variable set in `env` has the same name as one set in `envFrom`, it will
    take precedence. For example, if you set the variable `GREETING` in both `env`
    and a ConfigMap referenced in `envFrom`, the value specified in `env` will override
    the one from the ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: Using Environment Variables in Command Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it’s useful to be able to put configuration data into a container’s environment,
    sometimes you need to supply it as command-line arguments for the container’s
    entrypoint instead.
  prefs: []
  type: TYPE_NORMAL
- en: You can do this by sourcing the environment variables from the ConfigMap, as
    in the previous example, but using the special Kubernetes syntax `$(VARIABLE)`
    to reference them in the command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *hello-config-args* directory of the demo repo, you’ll find this example
    in the *deployment.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve added an `args` field for the container spec, which will pass our
    custom arguments to the container’s default entrypoint (`/bin/demo`).
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes replaces anything of the form `$(VARIABLE)` in a manifest with the
    value of the environment variable `VARIABLE`. Since we’ve created the `GREETING`
    variable and set its value from the ConfigMap, it’s available for use in the container’s
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you apply these manifests, the value of `GREETING` will be passed to the
    demo app in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the effect in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Salut, 世界`'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Config Files from ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen a couple of different ways of getting data from Kubernetes ConfigMaps
    into applications: via the environment and via the container command line. More
    complex applications, however, often expect to read their configuration from files
    on disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Kubernetes gives us a way to create such files directly from a
    ConfigMap. First, let’s change our ConfigMap so that instead of a single key,
    it stores a complete YAML file (which happens to only contain one key, but it
    could be a hundred, if you like):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of setting the key `greeting`, as we did in the previous example, we’re
    creating a new key called `config`, and assigning it a *block* of data (the pipe
    symbol `|` in YAML indicates that what follows is a block of raw data). This is
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It happens to be valid YAML, but don’t be confused by that; it could be JSON,
    TOML, plain text, or any other format. Whatever it is, Kubernetes will eventually
    write the whole block of data, as is, to a file on our container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve stored the necessary data, let’s deploy it to Kubernetes. In
    the *hello-config-file* directory of the demo repo, you’ll find the Deployment
    template, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the `volumes` section, you can see that we create a Volume named
    `demo-config-volume`, from the existing `demo-config` ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the container’s `volumeMounts` section, we mount this volume on the `mountPath:
    /config/`, select the key `config`, and write it to the path *demo.yaml*. The
    result of this will be that Kubernetes will create a file in the container at
    */config/demo.yaml*, containing the `demo-config` data in YAML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The demo application will read its config from this file on startup. As before,
    apply the manifests using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the results in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Buongiorno, 世界`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see what the ConfigMap data looks like in the cluster, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you update a ConfigMap and change its values, the corresponding file (*/config/demo.yaml*
    in our example) will be updated automatically. Some applications may autodetect
    that their config file has changed and reread it; others may not.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to redeploy the application to pick up the changes (see [“Updating
    Pods on a Config Change”](#configchange)), but this may not be necessary if the
    application has a way to trigger a live reload, such as a Unix signal (for example
    `SIGHUP`), or run a command in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Pods on a Config Change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you have a Deployment running in your cluster, and you want to change
    some values in its ConfigMap. If you’re using a Helm chart (see [“Helm: A Kubernetes
    Package Manager”](ch04.html#helm-intro)), there’s a neat trick to have it automatically
    detect a config change and reload your Pods. Add this annotation to your Deployment
    spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because the Deployment template now includes a hash sum of the config settings,
    if these settings change, then so will the hash. When you run `helm upgrade`,
    Helm will detect that the Deployment spec has changed, and restart all the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen that the Kubernetes ConfigMap object provides a flexible way of storing
    and accessing configuration data in the cluster. However, most applications have
    some config data that is secret and sensitive, such as passwords or API keys.
    While we could use ConfigMaps to store these, that’s not an ideal solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, Kubernetes provides a special type of object intended to store secret
    data: the Secret. Let’s see an example of how to use it with the demo application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s the Kubernetes manifest for the Secret (see *hello-secret-env/k8s/secret.yaml*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the secret key is `magicWord`, and the secret value is the
    word [`xyzzy`](https://oreil.ly/Ww0ME) (a very useful word in computing). As with
    a ConfigMap, you can put multiple keys and values into a Secret. Here, just to
    keep things simple, we’re only using one key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: Using Secrets as Environment Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like ConfigMaps, Secrets can be made visible to containers by putting
    them into environment variables, or mounting them as a file on the container’s
    filesystem. In this example, we’ll set an environment variable to the value of
    the Secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We set the environment variable `MAGIC_WORD` exactly as we did when using a
    ConfigMap, except that now it’s a `secretKeyRef` instead of a `configMapKeyRef`
    (see [“Setting Environment Variables from ConfigMaps”](#envconfig)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the demo repo directory to apply these manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, forward a local port to the Deployment so you can see the results
    in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Browse to *http://localhost:9999/* and you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '`The magic word is "xyzzy"`'
  prefs: []
  type: TYPE_NORMAL
- en: Writing Secrets to Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’ll mount the Secret on the container as a file. You’ll find
    the code for this example in the *hello-secret-file* folder of the demo repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mount the Secret in a file on the container, we use a Deployment
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did in [“Creating Config Files from ConfigMaps”](#hello-config-file),
    we create a Volume (`demo-secret-volume` in this example), and mount it on the
    container in the `volumeMounts` section of the spec. The `mountPath` is `/secrets`,
    and Kubernetes will create one file in this directory for each of the key-value
    pairs defined in the Secret.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only defined one key-value pair in the example Secret, named `magicWord`,
    so this manifest will create the read-only file */secrets/magicWord* on the container,
    and the contents of the file will be the secret data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you apply this manifest in the same way as for the previous example, you
    should see the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '`The magic word is "xyzzy"`'
  prefs: []
  type: TYPE_NORMAL
- en: Reading Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we were able to use `kubectl describe` to see the data
    inside the ConfigMap. Can we do the same with a Secret?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this time, the actual data is not shown. Kubernetes Secrets are
    `Opaque`, which means they’re not shown in `kubectl describe` output, in log messages,
    or in the terminal. This prevents secret data being exposed accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an obfuscated version of the secret data by using `kubectl get`
    with YAML output format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: base64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s that `eHl6enk=`? That doesn’t look much like our original secret data.
    In fact, it’s a *base64* representation of the Secret. Base64 is a scheme for
    encoding arbitrary binary data as a character string.
  prefs: []
  type: TYPE_NORMAL
- en: Because the secret data could be nonprintable binary data (for example, a Transport
    Layer Security [TLS] encryption key), Kubernetes Secrets are always stored in
    base64 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text `eHl6enk=` is the base64-encoded version of our secret word `xyzzy`.
    You can verify this using the `base64 --decode` command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So although Kubernetes protects you from accidentally printing secret data to
    the terminal, or in log files, if you have permission to read the Secrets in a
    particular namespace, you can get the data in base64 format and then decode it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to base64-encode some text (for instance, to add it to a Secret),
    use the `base64` tool with the `-n` flag to avoid including a newline character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Access to Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Who can read or edit Secrets? That’s controlled by the Kubernetes access control
    mechanism, RBAC, which we’ll talk about in much more detail in [“Introducing Role-Based
    Access Control (RBAC)”](ch11.html#rbac).
  prefs: []
  type: TYPE_NORMAL
- en: Encryption at Rest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about someone with access to the `etcd` database where all Kubernetes information
    is stored? Could they access the secret data, even without API permissions to
    read the Secret object?
  prefs: []
  type: TYPE_NORMAL
- en: From Kubernetes version 1.7 onward, *encryption at rest* is supported. That
    means that the secret data in the `etcd` database is actually stored encrypted
    on disk, and unreadable even to someone who can access the database directly.
    Only the Kubernetes API server has the key to decrypt this data. In a properly
    configured cluster, encryption at rest should be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Secrets and ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of version 1.21, Kubernetes supports [Immutable Secrets](https://oreil.ly/5797O)
    and [Immutable ConfigMaps](https://oreil.ly/baz5W). Adding `immutable: true` to
    the Secret or ConfigMap manifest will prevent it from being modified. The only
    way to change an Immutable Secret or ConfigMap is to delete and re-create a new
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you’ll have Kubernetes resources that you never want to be deleted
    from the cluster. If you are using Helm, then you can use a Helm-specific annotation
    to prevent a resource from being removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Secrets Management Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the example in the previous section, our secret data was protected against
    unauthorized access once it was stored in the cluster. But the secret data was
    represented in plain text in our manifest files.
  prefs: []
  type: TYPE_NORMAL
- en: You should never expose secret data like this in files that are committed to
    source control. So how do you manage and store secret data securely before it’s
    applied to the Kubernetes cluster?
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever tool or strategy you choose for managing secrets in your applications,
    you’ll need it to answer at least the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Where do you store secrets so that they are highly available?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make secrets available to your running applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What needs to happen to your running applications when you rotate or change
    secrets?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section we’ll look at some of the popular secrets management strategies,
    and examine how each of them tackles these questions.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt Secrets in Version Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and perhaps simplest option for secrets management is to store your
    secrets directly in your version control repos alongside your source code, but
    in encrypted form. Secrets that are stored in source code repos should never be
    saved in plain text. Instead, they are encrypted in a form that can only be decrypted
    with a certain trusted key, either at deploy time or at startup time. The application
    can then read and use the decrypted secrets just like any other configuration
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting secrets in version control lets you review and track changes to secrets,
    just as you would do for changes to application code. And so long as your version
    control repositories are highly available, your secrets will be highly available
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: To change or rotate secrets, just decrypt them in your local copy of the source,
    update them, re-encrypt, and commit the change to version control.
  prefs: []
  type: TYPE_NORMAL
- en: While this strategy is simple to implement and has no dependencies except the
    key and the encryption/decryption tool, there are a few potential drawbacks. If
    the same secret is used by multiple applications, they all need a copy of it in
    their source code. This means rotating the secret is more work, because you have
    to make sure you’ve found and changed all instances of it.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a serious risk of accidentally committing plain-text secrets to
    version control. Mistakes do happen, and even with private version control repositories,
    any secret so committed should be considered compromised, and you should rotate
    it as soon as possible. Reconciling merge conflicts in source control with encrypted
    secrets can also be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, this strategy could be a good starting point for smaller teams
    or for noncritical secrets. It’s relatively low-touch and easy to set up, while
    still being flexible enough to handle multiple apps and different types of secret
    data. In the final section of this chapter, we’ll outline some options for encryption/decryption
    tools you can use to do this, but first, let’s briefly describe the other secrets
    management strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Dedicated Secrets Management Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While encrypting secrets in source code is a relatively easy way to get started,
    you may want to evaluate using a dedicated secrets management tool, such as [HashiCorp’s
    Vault](https://www.vaultproject.io) or [Square’s Keywhiz](https://square.github.io/keywhiz).
    You could also consider using a managed cloud service such as [AWS Secrets Manager](https://oreil.ly/IVAhS),
    [Azure’s Key Vault](https://oreil.ly/4WaXg), or [Google’s Secret Manager](https://oreil.ly/257Ue).
    These tools handle the secure storing of all of your application secrets in one
    central place in a highly available way, and can also control which users and
    service accounts have permissions to add, remove, change, or view secrets.
  prefs: []
  type: TYPE_NORMAL
- en: In a secrets management system, all actions are audited and reviewable, making
    it easier to analyze security breaches and prove regulatory compliance. Some of
    these tools also provide the ability to automatically rotate secrets on a regular
    basis, which is not only a good idea in any case, but is also required by many
    corporate security policies. Developers can have their own individual credentials,
    with permission to read or write secrets for only the applications that they’re
    responsible for.
  prefs: []
  type: TYPE_NORMAL
- en: How do applications get their data from a secrets management tool? One common
    way is to use a service account with read-only access to the secrets vault so
    that each application can only read the secrets it needs. Often an Init container
    (see [“Init Containers”](ch08.html#init-containers)) is used to first pull and
    decrypt the secrets and then mount them into the Pod using a Volume.
  prefs: []
  type: TYPE_NORMAL
- en: While a central secrets management system is the most powerful and flexible
    option available, it also adds significant complexity to your infrastructure,
    especially if you decide to host the tooling yourself. Using a managed solution
    would free you up from running this infrastructure, but they come with added cost
    to your cloud bill. You will also need to implement a process or some middleware
    to your applications to consume secrets securely. While applications could be
    built to access a particular secrets vault directly, this may be more expensive
    and time-consuming than simply adding a layer in front of them that gets secrets
    and puts them in the application’s environment or config file at startup time.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting Secrets with Sops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s now look at a popular encryption tool that you can use for storing your
    secrets securely in source control. Sops (short for *secrets operations*), from
    the Mozilla project, is an encryption/decryption tool that is compatible with
    YAML, JSON, or binary files, and supports multiple encryption backends, including
    [`age`](https://oreil.ly/d6jtA), [Azure Key Vault](https://oreil.ly/4WaXg), [AWS’s
    Key Management Service (KMS)](https://oreil.ly/pyDJT), and [Google’s Cloud KMS](https://oreil.ly/N7Bo4).
    Visit the [Sops project home page](https://oreil.ly/7oGbC) for installation and
    usage instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than encrypting the whole file, Sops encrypts only the individual secret
    values in key-value pairs. For example, if your plain-text file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'when you encrypt it with Sops, the resulting file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This makes it easy to review the code without needing to decrypt the value in
    order to understand which key is being used.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting a File with Sops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try out Sops by encrypting a file. As we mentioned, Sops doesn’t actually
    handle encryption itself; it delegates that to a different backend tool. We’ll
    use Sops with a tool called `age` in this example to encrypt a file containing
    a secret. The end result will be a file that you could safely commit to version
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t get into the details of how exactly encryption with `age` works, but
    just know that, like SSH and TLS, it’s a *public key* cryptosystem. Instead of
    encrypting data with a single key, it actually uses a pair of keys: one public,
    one private. You can safely share your public key with others, but you should
    never give out your private key.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s generate your key pair now. First, [install age](https://oreil.ly/CPGhH),
    if you haven’t already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that’s installed, run this command to generate a new key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once your key has been successfully generated, make a note of the `Public key`.
    It will be unique to you and identifies the key you just created. The *key.txt*
    file also contains your private key, so it should be stored securely and never
    committed into source control.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s encrypt a file using Sops and `age`. You will also need to have Sops
    installed on your machine, if you haven’t already.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s create a test secret YAML file to encrypt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, use Sops to encrypt it. Pass your key fingerprint to the `--age` switch
    and your `Public key` from above, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Success! The *test.yaml* file is encrypted securely, and the value of `password`
    is scrambled and can only be decrypted with your private key. You will also notice
    that Sops added some metadata to the bottom of the file so that it will know how
    to decrypt it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: A nice feature of Sops is that because only the *value* of `password` is encrypted,
    the YAML format of the file is preserved and you can still view the names of the
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that we can get the encrypted data back, and to check that it
    matches what we put in, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `SOPS_AGE_KEY_FILE` part of the command points to the location of the key
    file you originally generated with `age`. You could consider storing that file
    in the default location that Sops expects, which is your *$HOME/sops/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to deploy the application, you can use Sops in decrypt mode
    to produce the plain-text secrets that your application uses—but remember to delete
    the plain-text files afterward, and don’t ever check them in to version control!
  prefs: []
  type: TYPE_NORMAL
- en: When using Sops as part of a centralized CI/CD pipeline, your deploy server
    infrastructure would also need an `age` key and to be a [trusted recipient](https://oreil.ly/zjPJs)
    in order to decrypt the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to use Sops, you can encrypt any sensitive data in your
    source code, whether that’s application config files, Kubernetes YAML resources,
    or anything else. Later on, we’ll show you how to use Sops this way with Helm
    charts. You can not only decrypt secrets when deploying your application with
    Helm, but also use different sets of secrets, depending on the deployment environment:
    for example, `staging` versus `production` (see [“Managing Helm Chart Secrets
    with Sops”](ch12.html#helmsops)).'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that if you need to manage encrypted secrets inside
    of a Helm chart, you can do that with a plugin called `helm-secrets`. When you
    run `helm upgrade...` or `helm install...`, `helm-secrets` will decrypt your secrets
    for deployment. For more information about `helm-secrets`, including installation
    and usage instructions, consult the [GitHub repo](https://oreil.ly/p3KBj).
  prefs: []
  type: TYPE_NORMAL
- en: Using a KMS Backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Amazon KMS or Google Cloud KMS for key management in the cloud,
    you can also use them with Sops. Using a KMS key works exactly the same as in
    our `age` example, but the metadata in the file will be different. Instead, the
    `sops:` section at the bottom might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Just like with `age`, the key ID (`arn:aws:kms...`) is embedded in the file
    so that Sops knows how to decrypt it later.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another good option for storing encrypted secrets in source control is an open
    source tool maintained by the folks at Bitnami called [Sealed Secrets](https://oreil.ly/Lq6Zo).
    Unlike with Sops, in this case the encryption keys are actually generated, installed,
    and stored inside of your Kubernetes clusters, making the deployment and decryption
    process straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Once Sealed Secrets is installed, you can use the `kubeseal` client tool to
    encrypt a Kubernetes Secret. This generates a new `SealedSecret` that can then
    be safely committed into your source control repo, much like the encrypted YAML
    files with Sops. When applied to the cluster, the Sealed Secret tooling will decrypt
    the `SealedSecret` object from inside Kubernetes and securely pass it to your
    application Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration and secrets is one of the topics that people ask us about the
    most in relation to Kubernetes. We’re glad to be able to devote a chapter to it,
    and to outline some ways you can connect your applications with the settings and
    data they need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important things we’ve learned:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate your configuration data from application code and deploy it using Kubernetes
    ConfigMaps and Secrets. That way, you don’t need to redeploy your app every time
    you change a password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get data into ConfigMaps by writing it directly in your Kubernetes manifest
    file, or use `kubectl` to convert an existing YAML file into a ConfigMap spec.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once data is in a ConfigMap, you can insert it into a container’s environment,
    or into the command-line arguments of its entrypoint. Alternatively, you can write
    the data to a file that is mounted on the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets work just like ConfigMaps, except that the data is encrypted at rest,
    and obfuscated in `kubectl` output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple way to manage secrets is to store them directly in your source code
    repo, but encrypt them using Sops or another text-based encryption tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t overlook secrets management, especially at first. Start with something
    your team understands and that provides a secure process for managing secrets
    on your team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dedicated secret management tools like Vault, or hosted cloud KMS tools, add
    cost and complexity to your stack, but offer better auditing and flexibility for
    securing your secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sops is an encryption tool that works with key-value files like YAML and JSON.
    It can get its encryption key from a local keyring, or cloud key management services
    like Amazon KMS and Google Cloud KMS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sealed Secrets makes it easy to store encrypted secrets in source control and
    securely pass them to your applications from within a Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
