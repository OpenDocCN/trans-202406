- en: Chapter 10\. Configuration and Secrets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to keep a secret, you must also hide it from yourself.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: George Orwell, *1984*
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s very useful to be able to separate the *logic* of your Kubernetes application
    from its *configuration*: that is, any values or settings that might change over
    the life of the application. Configuration values commonly include things like
    environment-specific settings, DNS addresses of third-party services, and authentication
    credentials.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: While you could simply put these values directly into your code, that’s not
    a very flexible approach. For one thing, changing a configuration value would
    require a complete rebuild and redeploy of the application. It’s much better to
    separate these values out from the code and read them in from a file, or from
    environment variables.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides a few different ways to help you manage configuration. One
    is to pass values to the application via environment variables in the Pod spec
    (see [“Environment Variables”](ch08.html#envvars)). Another is to store configuration
    data directly in Kubernetes, using the ConfigMap and Secret objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll explore ConfigMaps and Secrets in detail, and look at
    some practical techniques for managing configuration and secrets in applications,
    using the demo application as an example.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ConfigMap is the primary object for storing configuration data in Kubernetes.
    You can think of it as being a named set of key-value pairs that stores configuration
    data. Once you have a ConfigMap, you can supply that data to an application either
    by creating a file in the Pod, or by injecting it into the Pod’s environment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll look at some different ways to get data into a ConfigMap,
    and then explore the various ways you can extract that data and feed it into your
    Kubernetes application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Creating ConfigMaps
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you want to create a YAML configuration file in your Pod’s filesystem
    named *config.yaml*, with the following contents:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Given this set of values, how do you turn them into a ConfigMap resource that
    you can apply to Kubernetes?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to specify that data as literal YAML values in the ConfigMap manifest.
    This is what the manifest for a ConfigMap object looks like:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You could create a ConfigMap by writing the manifest from scratch, and adding
    the values from *config.yaml* into the `data` section, as we’ve done in this example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'An easier way, though, is to let `kubectl` do some of the work for you. You
    can create a ConfigMap directly from a YAML file as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To export the manifest file that corresponds to this ConfigMap, run:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This writes a YAML manifest representation of the cluster’s ConfigMap resource
    to the file *demo-config.yaml*, however it will contain extra info like the `status`
    section that you may want to remove before applying again (see [“Exporting Resources”](ch07.html#exportflag)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Setting Environment Variables from ConfigMaps
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the required configuration data in a ConfigMap object, how
    do we then get that data into a container? Let’s look at a complete example using
    our demo application. You’ll find the code in the *hello-config-env* directory
    of the demo repo.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 ConfigMap 对象中拥有了所需的配置数据，那么如何将这些数据传输到容器中呢？让我们看一个使用我们演示应用程序的完整示例。您将在演示存储库的*hello-config-env*目录中找到代码。
- en: It’s the same demo application we’ve used in previous chapters that listens
    for HTTP requests and responds with a greeting (see [“Looking at the Source Code”](ch02.html#demo-source)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在之前章节中使用的相同演示应用程序，它监听 HTTP 请求并以问候语回复（参见[“查看源代码”](ch02.html#demo-source)）。
- en: 'This time, though, instead of hard coding the string `Hello` into the application,
    we’d like to make the greeting configurable. So there’s a slight modification
    to the `handler` function to read this value from the environment variable `GREETING`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这次我们不会将字符串`Hello`硬编码到应用程序中，而是希望将问候语设置为可配置。因此，稍微修改了`handler`函数以从环境变量`GREETING`中读取该值：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Don’t worry about the exact details of the Go code; it’s just a demo. Suffice
    it to say that if the `GREETING` environment variable is present when the program
    runs, it will use that value when responding to requests. Whatever language you’re
    using to write applications, it’s a good bet that you’ll be able to read environment
    variables with it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心 Go 代码的具体细节；这只是一个演示。可以肯定的是，如果在程序运行时存在`GREETING`环境变量，它将在响应请求时使用该值。无论您使用何种语言编写应用程序，都可以使用它来读取环境变量。
- en: Now, let’s create the ConfigMap object to hold the greeting value. You’ll find
    the manifest file for the ConfigMap, along with the modified Go application, in
    the *hello-config-env* directory of the demo repo.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建 ConfigMap 对象以保存问候值。您将在演示存储库的*hello-config-env*目录中找到 ConfigMap 清单文件，以及修改后的
    Go 应用程序。
- en: 'It looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to make this data visible in the container’s environment, we need
    to modify the Deployment slightly. Here’s the relevant part of the demo Deployment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些数据在容器的环境中可见，我们需要稍微修改部署。以下是演示部署的相关部分：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that we’re using a different container image tag to that in previous examples
    (see [“Image Identifiers”](ch08.html#image-identifiers)). The `:hello-config-env`
    tag gets us the modified version of the demo application that reads the `GREETING`
    variable: `cloudnatived/demo:hello-config-env`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了不同的容器镜像标签，与之前的示例不同（参见[“镜像标识符”](ch08.html#image-identifiers)）。`:hello-config-env`标签让我们获取修改后的演示应用程序版本，该版本读取`GREETING`变量：`cloudnatived/demo:hello-config-env`。
- en: The second point of interest is the `env` section. Remember from [“Environment
    Variables”](ch08.html#envvars) that you can create environment variables with
    literal values by adding a `name`/`value` pair.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其次感兴趣的是`env`部分。从[“环境变量”](ch08.html#envvars)中记得，您可以通过添加`name`/`value`对来创建具有字面值的环境变量。
- en: We still have `name` here, but instead of `value`, we’ve specified `valueFrom`.
    This tells Kubernetes that, rather than taking a literal value for the variable,
    it should look elsewhere to find the value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里仍然有`name`，但是我们使用了`valueFrom`而不是`value`。这告诉 Kubernetes，它不应该使用变量的字面值，而是应该去其他地方找到该值。
- en: '`configMapKeyRef` tells it to reference a specific key in a specific ConfigMap.
    The name of the ConfigMap to look at is `demo-config`, and the key we want to
    look up is `greeting`. We created this data with the ConfigMap manifest, so it
    should now be available to read into the container’s environment.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`configMapKeyRef`告诉它引用特定 ConfigMap 中的特定键。要查看的 ConfigMap 的名称是`demo-config`，我们要查找的键是`greeting`。我们使用
    ConfigMap 清单创建了这些数据，所以现在应该可以将其读取到容器的环境中。'
- en: If the ConfigMap doesn’t exist, the Deployment won’t be able to run (its Pod
    will show a status of `CreateContainerConfigError`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ConfigMap 不存在，部署将无法运行（其 Pod 将显示`CreateContainerConfigError`状态）。
- en: 'That’s everything you need to make the updated application work, so go ahead
    and deploy the manifests to your Kubernetes cluster. From the demo repo directory,
    run the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使更新后的应用程序工作所需的一切，因此继续将清单部署到您的 Kubernetes 集群。从演示存储库目录中运行以下命令：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As before, to see the application in your web browser, you’ll need to forward
    a local port to the Pod’s port 8888:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，要在 Web 浏览器中查看应用程序，您需要将本地端口转发到 Pod 的端口8888：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (We didn’t bother creating a Service this time; while you’d use a Service with
    a real production app, for this example we’ve just used `kubectl` to forward the
    local port directly to the `demo` Deployment.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'If you point your web browser to http://localhost:9999/, you should see, if
    all is well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`Hola, 世界`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Whole Environment from a ConfigMap
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you can set one or two environment variables from individual ConfigMap
    keys, as we saw in the previous example, that could get tedious for a large number
    of variables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there’s an easy way to take all the keys from a ConfigMap and
    turn them into environment variables, using `envFrom`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now every setting in the `demo-config` ConfigMap will be a variable in the container’s
    environment. Because in our example ConfigMap the key is called `greeting`, the
    environment variable will also be named `greeting` (in lowercase). To make your
    environment variable names uppercase when you’re using `envFrom`, change them
    in the ConfigMap.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: You can also set other environment variables for the container in the normal
    way, using `env`, either by putting the literal values in the manifest file or
    using a `ConfigMapKeyRef`, as in our previous example. Kubernetes allows you to
    use either `env`, `envFrom`, or both at once to set environment variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If a variable set in `env` has the same name as one set in `envFrom`, it will
    take precedence. For example, if you set the variable `GREETING` in both `env`
    and a ConfigMap referenced in `envFrom`, the value specified in `env` will override
    the one from the ConfigMap.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Using Environment Variables in Command Arguments
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it’s useful to be able to put configuration data into a container’s environment,
    sometimes you need to supply it as command-line arguments for the container’s
    entrypoint instead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: You can do this by sourcing the environment variables from the ConfigMap, as
    in the previous example, but using the special Kubernetes syntax `$(VARIABLE)`
    to reference them in the command-line arguments.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *hello-config-args* directory of the demo repo, you’ll find this example
    in the *deployment.yaml* file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we’ve added an `args` field for the container spec, which will pass our
    custom arguments to the container’s default entrypoint (`/bin/demo`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes replaces anything of the form `$(VARIABLE)` in a manifest with the
    value of the environment variable `VARIABLE`. Since we’ve created the `GREETING`
    variable and set its value from the ConfigMap, it’s available for use in the container’s
    command line.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'When you apply these manifests, the value of `GREETING` will be passed to the
    demo app in this way:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the effect in your web browser:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`Salut, 世界`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Creating Config Files from ConfigMaps
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen a couple of different ways of getting data from Kubernetes ConfigMaps
    into applications: via the environment and via the container command line. More
    complex applications, however, often expect to read their configuration from files
    on disk.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Kubernetes gives us a way to create such files directly from a
    ConfigMap. First, let’s change our ConfigMap so that instead of a single key,
    it stores a complete YAML file (which happens to only contain one key, but it
    could be a hundred, if you like):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Instead of setting the key `greeting`, as we did in the previous example, we’re
    creating a new key called `config`, and assigning it a *block* of data (the pipe
    symbol `|` in YAML indicates that what follows is a block of raw data). This is
    the data:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It happens to be valid YAML, but don’t be confused by that; it could be JSON,
    TOML, plain text, or any other format. Whatever it is, Kubernetes will eventually
    write the whole block of data, as is, to a file on our container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve stored the necessary data, let’s deploy it to Kubernetes. In
    the *hello-config-file* directory of the demo repo, you’ll find the Deployment
    template, containing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Looking at the `volumes` section, you can see that we create a Volume named
    `demo-config-volume`, from the existing `demo-config` ConfigMap.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'In the container’s `volumeMounts` section, we mount this volume on the `mountPath:
    /config/`, select the key `config`, and write it to the path *demo.yaml*. The
    result of this will be that Kubernetes will create a file in the container at
    */config/demo.yaml*, containing the `demo-config` data in YAML format:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The demo application will read its config from this file on startup. As before,
    apply the manifests using this command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the results in your web browser:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '`Buongiorno, 世界`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see what the ConfigMap data looks like in the cluster, run the
    following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you update a ConfigMap and change its values, the corresponding file (*/config/demo.yaml*
    in our example) will be updated automatically. Some applications may autodetect
    that their config file has changed and reread it; others may not.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: One option is to redeploy the application to pick up the changes (see [“Updating
    Pods on a Config Change”](#configchange)), but this may not be necessary if the
    application has a way to trigger a live reload, such as a Unix signal (for example
    `SIGHUP`), or run a command in the container.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Updating Pods on a Config Change
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you have a Deployment running in your cluster, and you want to change
    some values in its ConfigMap. If you’re using a Helm chart (see [“Helm: A Kubernetes
    Package Manager”](ch04.html#helm-intro)), there’s a neat trick to have it automatically
    detect a config change and reload your Pods. Add this annotation to your Deployment
    spec:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because the Deployment template now includes a hash sum of the config settings,
    if these settings change, then so will the hash. When you run `helm upgrade`,
    Helm will detect that the Deployment spec has changed, and restart all the Pods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen that the Kubernetes ConfigMap object provides a flexible way of storing
    and accessing configuration data in the cluster. However, most applications have
    some config data that is secret and sensitive, such as passwords or API keys.
    While we could use ConfigMaps to store these, that’s not an ideal solution.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, Kubernetes provides a special type of object intended to store secret
    data: the Secret. Let’s see an example of how to use it with the demo application.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s the Kubernetes manifest for the Secret (see *hello-secret-env/k8s/secret.yaml*):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the secret key is `magicWord`, and the secret value is the
    word [`xyzzy`](https://oreil.ly/Ww0ME) (a very useful word in computing). As with
    a ConfigMap, you can put multiple keys and values into a Secret. Here, just to
    keep things simple, we’re only using one key-value pair.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Using Secrets as Environment Variables
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like ConfigMaps, Secrets can be made visible to containers by putting
    them into environment variables, or mounting them as a file on the container’s
    filesystem. In this example, we’ll set an environment variable to the value of
    the Secret:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We set the environment variable `MAGIC_WORD` exactly as we did when using a
    ConfigMap, except that now it’s a `secretKeyRef` instead of a `configMapKeyRef`
    (see [“Setting Environment Variables from ConfigMaps”](#envconfig)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the demo repo directory to apply these manifests:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As before, forward a local port to the Deployment so you can see the results
    in your web browser:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Browse to *http://localhost:9999/* and you should see:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '`The magic word is "xyzzy"`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Writing Secrets to Files
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’ll mount the Secret on the container as a file. You’ll find
    the code for this example in the *hello-secret-file* folder of the demo repo.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mount the Secret in a file on the container, we use a Deployment
    like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just as we did in [“Creating Config Files from ConfigMaps”](#hello-config-file),
    we create a Volume (`demo-secret-volume` in this example), and mount it on the
    container in the `volumeMounts` section of the spec. The `mountPath` is `/secrets`,
    and Kubernetes will create one file in this directory for each of the key-value
    pairs defined in the Secret.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only defined one key-value pair in the example Secret, named `magicWord`,
    so this manifest will create the read-only file */secrets/magicWord* on the container,
    and the contents of the file will be the secret data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'If you apply this manifest in the same way as for the previous example, you
    should see the same results:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`The magic word is "xyzzy"`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Reading Secrets
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we were able to use `kubectl describe` to see the data
    inside the ConfigMap. Can we do the same with a Secret?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that this time, the actual data is not shown. Kubernetes Secrets are
    `Opaque`, which means they’re not shown in `kubectl describe` output, in log messages,
    or in the terminal. This prevents secret data being exposed accidentally.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an obfuscated version of the secret data by using `kubectl get`
    with YAML output format:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: base64
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What’s that `eHl6enk=`? That doesn’t look much like our original secret data.
    In fact, it’s a *base64* representation of the Secret. Base64 is a scheme for
    encoding arbitrary binary data as a character string.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Because the secret data could be nonprintable binary data (for example, a Transport
    Layer Security [TLS] encryption key), Kubernetes Secrets are always stored in
    base64 format.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The text `eHl6enk=` is the base64-encoded version of our secret word `xyzzy`.
    You can verify this using the `base64 --decode` command in the terminal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So although Kubernetes protects you from accidentally printing secret data to
    the terminal, or in log files, if you have permission to read the Secrets in a
    particular namespace, you can get the data in base64 format and then decode it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to base64-encode some text (for instance, to add it to a Secret),
    use the `base64` tool with the `-n` flag to avoid including a newline character:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Access to Secrets
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Who can read or edit Secrets? That’s controlled by the Kubernetes access control
    mechanism, RBAC, which we’ll talk about in much more detail in [“Introducing Role-Based
    Access Control (RBAC)”](ch11.html#rbac).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Encryption at Rest
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about someone with access to the `etcd` database where all Kubernetes information
    is stored? Could they access the secret data, even without API permissions to
    read the Secret object?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: From Kubernetes version 1.7 onward, *encryption at rest* is supported. That
    means that the secret data in the `etcd` database is actually stored encrypted
    on disk, and unreadable even to someone who can access the database directly.
    Only the Kubernetes API server has the key to decrypt this data. In a properly
    configured cluster, encryption at rest should be enabled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Secrets and ConfigMaps
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As of version 1.21, Kubernetes supports [Immutable Secrets](https://oreil.ly/5797O)
    and [Immutable ConfigMaps](https://oreil.ly/baz5W). Adding `immutable: true` to
    the Secret or ConfigMap manifest will prevent it from being modified. The only
    way to change an Immutable Secret or ConfigMap is to delete and re-create a new
    one.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you’ll have Kubernetes resources that you never want to be deleted
    from the cluster. If you are using Helm, then you can use a Helm-specific annotation
    to prevent a resource from being removed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Secrets Management Strategies
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the example in the previous section, our secret data was protected against
    unauthorized access once it was stored in the cluster. But the secret data was
    represented in plain text in our manifest files.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: You should never expose secret data like this in files that are committed to
    source control. So how do you manage and store secret data securely before it’s
    applied to the Kubernetes cluster?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever tool or strategy you choose for managing secrets in your applications,
    you’ll need it to answer at least the following questions:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Where do you store secrets so that they are highly available?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make secrets available to your running applications?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What needs to happen to your running applications when you rotate or change
    secrets?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section we’ll look at some of the popular secrets management strategies,
    and examine how each of them tackles these questions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Encrypt Secrets in Version Control
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first and perhaps simplest option for secrets management is to store your
    secrets directly in your version control repos alongside your source code, but
    in encrypted form. Secrets that are stored in source code repos should never be
    saved in plain text. Instead, they are encrypted in a form that can only be decrypted
    with a certain trusted key, either at deploy time or at startup time. The application
    can then read and use the decrypted secrets just like any other configuration
    data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting secrets in version control lets you review and track changes to secrets,
    just as you would do for changes to application code. And so long as your version
    control repositories are highly available, your secrets will be highly available
    as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: To change or rotate secrets, just decrypt them in your local copy of the source,
    update them, re-encrypt, and commit the change to version control.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: While this strategy is simple to implement and has no dependencies except the
    key and the encryption/decryption tool, there are a few potential drawbacks. If
    the same secret is used by multiple applications, they all need a copy of it in
    their source code. This means rotating the secret is more work, because you have
    to make sure you’ve found and changed all instances of it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: There is also a serious risk of accidentally committing plain-text secrets to
    version control. Mistakes do happen, and even with private version control repositories,
    any secret so committed should be considered compromised, and you should rotate
    it as soon as possible. Reconciling merge conflicts in source control with encrypted
    secrets can also be tricky.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, this strategy could be a good starting point for smaller teams
    or for noncritical secrets. It’s relatively low-touch and easy to set up, while
    still being flexible enough to handle multiple apps and different types of secret
    data. In the final section of this chapter, we’ll outline some options for encryption/decryption
    tools you can use to do this, but first, let’s briefly describe the other secrets
    management strategies.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Use a Dedicated Secrets Management Tool
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While encrypting secrets in source code is a relatively easy way to get started,
    you may want to evaluate using a dedicated secrets management tool, such as [HashiCorp’s
    Vault](https://www.vaultproject.io) or [Square’s Keywhiz](https://square.github.io/keywhiz).
    You could also consider using a managed cloud service such as [AWS Secrets Manager](https://oreil.ly/IVAhS),
    [Azure’s Key Vault](https://oreil.ly/4WaXg), or [Google’s Secret Manager](https://oreil.ly/257Ue).
    These tools handle the secure storing of all of your application secrets in one
    central place in a highly available way, and can also control which users and
    service accounts have permissions to add, remove, change, or view secrets.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: In a secrets management system, all actions are audited and reviewable, making
    it easier to analyze security breaches and prove regulatory compliance. Some of
    these tools also provide the ability to automatically rotate secrets on a regular
    basis, which is not only a good idea in any case, but is also required by many
    corporate security policies. Developers can have their own individual credentials,
    with permission to read or write secrets for only the applications that they’re
    responsible for.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: How do applications get their data from a secrets management tool? One common
    way is to use a service account with read-only access to the secrets vault so
    that each application can only read the secrets it needs. Often an Init container
    (see [“Init Containers”](ch08.html#init-containers)) is used to first pull and
    decrypt the secrets and then mount them into the Pod using a Volume.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: While a central secrets management system is the most powerful and flexible
    option available, it also adds significant complexity to your infrastructure,
    especially if you decide to host the tooling yourself. Using a managed solution
    would free you up from running this infrastructure, but they come with added cost
    to your cloud bill. You will also need to implement a process or some middleware
    to your applications to consume secrets securely. While applications could be
    built to access a particular secrets vault directly, this may be more expensive
    and time-consuming than simply adding a layer in front of them that gets secrets
    and puts them in the application’s environment or config file at startup time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting Secrets with Sops
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s now look at a popular encryption tool that you can use for storing your
    secrets securely in source control. Sops (short for *secrets operations*), from
    the Mozilla project, is an encryption/decryption tool that is compatible with
    YAML, JSON, or binary files, and supports multiple encryption backends, including
    [`age`](https://oreil.ly/d6jtA), [Azure Key Vault](https://oreil.ly/4WaXg), [AWS’s
    Key Management Service (KMS)](https://oreil.ly/pyDJT), and [Google’s Cloud KMS](https://oreil.ly/N7Bo4).
    Visit the [Sops project home page](https://oreil.ly/7oGbC) for installation and
    usage instructions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than encrypting the whole file, Sops encrypts only the individual secret
    values in key-value pairs. For example, if your plain-text file contains:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'when you encrypt it with Sops, the resulting file will look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This makes it easy to review the code without needing to decrypt the value in
    order to understand which key is being used.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting a File with Sops
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try out Sops by encrypting a file. As we mentioned, Sops doesn’t actually
    handle encryption itself; it delegates that to a different backend tool. We’ll
    use Sops with a tool called `age` in this example to encrypt a file containing
    a secret. The end result will be a file that you could safely commit to version
    control.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t get into the details of how exactly encryption with `age` works, but
    just know that, like SSH and TLS, it’s a *public key* cryptosystem. Instead of
    encrypting data with a single key, it actually uses a pair of keys: one public,
    one private. You can safely share your public key with others, but you should
    never give out your private key.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Let’s generate your key pair now. First, [install age](https://oreil.ly/CPGhH),
    if you haven’t already.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that’s installed, run this command to generate a new key pair:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once your key has been successfully generated, make a note of the `Public key`.
    It will be unique to you and identifies the key you just created. The *key.txt*
    file also contains your private key, so it should be stored securely and never
    committed into source control.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s encrypt a file using Sops and `age`. You will also need to have Sops
    installed on your machine, if you haven’t already.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s create a test secret YAML file to encrypt:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And now, use Sops to encrypt it. Pass your key fingerprint to the `--age` switch
    and your `Public key` from above, like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Success! The *test.yaml* file is encrypted securely, and the value of `password`
    is scrambled and can only be decrypted with your private key. You will also notice
    that Sops added some metadata to the bottom of the file so that it will know how
    to decrypt it in the future.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: A nice feature of Sops is that because only the *value* of `password` is encrypted,
    the YAML format of the file is preserved and you can still view the names of the
    keys.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that we can get the encrypted data back, and to check that it
    matches what we put in, run:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `SOPS_AGE_KEY_FILE` part of the command points to the location of the key
    file you originally generated with `age`. You could consider storing that file
    in the default location that Sops expects, which is your *$HOME/sops/* directory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to deploy the application, you can use Sops in decrypt mode
    to produce the plain-text secrets that your application uses—but remember to delete
    the plain-text files afterward, and don’t ever check them in to version control!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: When using Sops as part of a centralized CI/CD pipeline, your deploy server
    infrastructure would also need an `age` key and to be a [trusted recipient](https://oreil.ly/zjPJs)
    in order to decrypt the file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how to use Sops, you can encrypt any sensitive data in your
    source code, whether that’s application config files, Kubernetes YAML resources,
    or anything else. Later on, we’ll show you how to use Sops this way with Helm
    charts. You can not only decrypt secrets when deploying your application with
    Helm, but also use different sets of secrets, depending on the deployment environment:
    for example, `staging` versus `production` (see [“Managing Helm Chart Secrets
    with Sops”](ch12.html#helmsops)).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth mentioning that if you need to manage encrypted secrets inside
    of a Helm chart, you can do that with a plugin called `helm-secrets`. When you
    run `helm upgrade...` or `helm install...`, `helm-secrets` will decrypt your secrets
    for deployment. For more information about `helm-secrets`, including installation
    and usage instructions, consult the [GitHub repo](https://oreil.ly/p3KBj).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Using a KMS Backend
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Amazon KMS or Google Cloud KMS for key management in the cloud,
    you can also use them with Sops. Using a KMS key works exactly the same as in
    our `age` example, but the metadata in the file will be different. Instead, the
    `sops:` section at the bottom might look something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just like with `age`, the key ID (`arn:aws:kms...`) is embedded in the file
    so that Sops knows how to decrypt it later.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Sealed Secrets
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another good option for storing encrypted secrets in source control is an open
    source tool maintained by the folks at Bitnami called [Sealed Secrets](https://oreil.ly/Lq6Zo).
    Unlike with Sops, in this case the encryption keys are actually generated, installed,
    and stored inside of your Kubernetes clusters, making the deployment and decryption
    process straightforward.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Once Sealed Secrets is installed, you can use the `kubeseal` client tool to
    encrypt a Kubernetes Secret. This generates a new `SealedSecret` that can then
    be safely committed into your source control repo, much like the encrypted YAML
    files with Sops. When applied to the cluster, the Sealed Secret tooling will decrypt
    the `SealedSecret` object from inside Kubernetes and securely pass it to your
    application Pods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration and secrets is one of the topics that people ask us about the
    most in relation to Kubernetes. We’re glad to be able to devote a chapter to it,
    and to outline some ways you can connect your applications with the settings and
    data they need.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important things we’ve learned:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Separate your configuration data from application code and deploy it using Kubernetes
    ConfigMaps and Secrets. That way, you don’t need to redeploy your app every time
    you change a password.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get data into ConfigMaps by writing it directly in your Kubernetes manifest
    file, or use `kubectl` to convert an existing YAML file into a ConfigMap spec.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过直接在你的Kubernetes清单文件中编写数据，或使用`kubectl`将现有的YAML文件转换为ConfigMap规范，将数据输入到ConfigMaps中。
- en: Once data is in a ConfigMap, you can insert it into a container’s environment,
    or into the command-line arguments of its entrypoint. Alternatively, you can write
    the data to a file that is mounted on the container.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦数据在ConfigMap中，你可以将它插入到容器的环境中，或者插入到其入口点的命令行参数中。或者，你可以将数据写入挂载在容器上的文件中。
- en: Secrets work just like ConfigMaps, except that the data is encrypted at rest,
    and obfuscated in `kubectl` output.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密的工作方式与ConfigMaps类似，不同之处在于数据在静态时加密，并在`kubectl`输出中混淆。
- en: A simple way to manage secrets is to store them directly in your source code
    repo, but encrypt them using Sops or another text-based encryption tool.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理秘密的一个简单方法是将它们直接存储在源代码仓库中，但使用Sops或其他基于文本的加密工具对其进行加密。
- en: Don’t overlook secrets management, especially at first. Start with something
    your team understands and that provides a secure process for managing secrets
    on your team.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要忽视秘密管理，特别是在初始阶段。从团队理解的东西开始，提供一个安全的管理团队秘密的流程。
- en: Dedicated secret management tools like Vault, or hosted cloud KMS tools, add
    cost and complexity to your stack, but offer better auditing and flexibility for
    securing your secrets.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Vault这样的专用秘密管理工具，或者托管的云KMS工具，增加了堆栈的成本和复杂性，但提供了更好的审计和灵活性，用于安全地保护你的秘密。
- en: Sops is an encryption tool that works with key-value files like YAML and JSON.
    It can get its encryption key from a local keyring, or cloud key management services
    like Amazon KMS and Google Cloud KMS.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sops是一种加密工具，适用于像YAML和JSON这样的键值文件。它可以从本地密钥环或云密钥管理服务（如Amazon KMS和Google Cloud
    KMS）获取其加密密钥。
- en: Sealed Secrets makes it easy to store encrypted secrets in source control and
    securely pass them to your applications from within a Kubernetes cluster.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sealed Secrets使得在源代码控制中存储加密的秘密并从Kubernetes集群内安全传递它们到你的应用程序变得容易。
