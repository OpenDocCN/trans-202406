<html><head></head><body><section data-pdf-bookmark="Chapter 4. The bpf() System Call" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_bpfleft_parenthesisright_parenthesi">&#13;
<h1><span class="label">Chapter 4. </span>The bpf() System Call</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-type="indexterm" id="ch04.html0"/>As you saw in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>, when user space applications want the kernel to do something on their behalf, they make requests using the system call API. It therefore makes sense that if a user space application wants to load an eBPF program into the kernel, there must be some system calls involved. In fact, there’s a system call named <code>bpf()</code>, and in this chapter I’ll show you how it’s used to load and interact with eBPF programs and maps.</p>&#13;
<p>It’s worth noting that the eBPF code running in the kernel does not use syscalls to access maps. The syscall interface is only used by user space applications. Instead, eBPF programs use helper functions to read and write to maps; you already saw examples of this in the previous two chapters.</p>&#13;
<p>If you go on to write eBPF programs yourself, there’s a good chance you won’t directly call these <code>bpf()</code> system calls yourself. There are libraries that I’ll discuss later in the book that offer higher-level abstractions to make things easier. That said, those abstractions generally map pretty directly to the underlying syscall commands you’ll see in this chapter. Whatever library you’re using, you’ll need a grasp of the underlying operations—loading a program, creating and accessing maps, and so on—that you’ll see in this chapter.</p>&#13;
<p>Before I show you examples of <code>bpf()</code> system calls, let’s consider what the <a href="https://oreil.ly/NJdIM">manpage for <code>bpf()</code> says</a>, which is that <code>bpf()</code> is used to “perform a command on an extended BPF map or program.” It also tells us that <code>bpf()</code>’s signature is as follows:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">bpf</code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">cmd</code><code class="p">,</code><code class="w"> </code><code class="k">union</code><code class="w"> </code><code class="nc">bpf_attr</code><code class="w"> </code><code class="o">*</code><code class="n">attr</code><code class="p">,</code><code class="w"> </code><code class="kt">unsigned</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">size</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>The first argument to <code>bpf()</code>, <code>cmd</code>, specifies which command to perform. The <code>bpf()</code> syscall doesn’t just do one thing—there are lots of different commands that can be used to manipulate eBPF programs and maps. <a data-type="xref" href="#a_userspace_program_interacts_with_ebpf">Figure 4-1</a> shows an overview of some of the common commands the user space code might use to load eBPF programs, create maps, attach programs to events, and access the key–value pairs in a map.</p>&#13;
<figure><div class="figure" id="a_userspace_program_interacts_with_ebpf">&#13;
<img alt="A user space program interacts with eBPF programs and maps in the kernel using syscalls" src="assets/lebp_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>A userspace program interacts with eBPF programs and maps in the kernel using syscalls</h6>&#13;
</div></figure>&#13;
<p>The <code>attr</code> argument to the <code>bpf()</code> syscall holds whatever data is needed to specify the parameters for the command, and <code>size</code> indicates how many bytes of data there are in <code>attr</code>.</p>&#13;
<p>You already met <code>strace</code> in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>, when I used it to show how user space code makes many requests across the syscall API. In this chapter I’ll use it to demonstrate how the <code>bpf()</code> syscall is used. The output from <code>strace</code> includes the arguments to each syscall, but to keep the example output in this chapter from being too cluttered, I’ll omit lots of the details from the <code>attr</code> arguments unless they are particularly <span class="keep-together">interesting</span>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You’ll find the code, along with instructions for setting up an environment to run it in, at <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a>. The code for this chapter is in the <em>chapter4</em> directory.</p>&#13;
</div>&#13;
<p>For this example I’m going to use a BCC program called <em>hello-buffer-config.py</em>, which builds on the examples you saw in <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>. Like the <em>hello-buffer.py</em> example, this program sends a message to the perf buffer whenever it runs, conveying information from the kernel to user space about <code>execve()</code> syscall events. What’s new in this version is that it allows for different messages to be configured for each user ID.</p>&#13;
<p class="pagebreak-before">Here’s the eBPF source code:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="w"> </code><code class="p">{</code><code class="w">                                          </code><a class="co" href="#list_id_4_1" id="code_id_4_1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="n">BPF_HASH</code><code class="p">(</code><code class="n">config</code><code class="p">,</code><code class="w"> </code><code class="n">u32</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="p">)</code><code class="p">;</code><code class="w">                    </code><a class="co" href="#list_id_4_2" id="code_id_4_2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="n">BPF_PERF_OUTPUT</code><code class="p">(</code><code class="n">output</code><code class="p">)</code><code class="p">;</code><code class="w">                                     </code><a class="co" href="#list_id_4_3" id="code_id_4_3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="k">struct</code><code class="w"> </code><code class="nc">data_t</code><code class="w"> </code><code class="p">{</code><code class="w">                                              </code><a class="co" href="#list_id_4_4" id="code_id_4_4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">pid</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">uid</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">command</code><code class="p">[</code><code class="mi">16</code><code class="p">]</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">hello</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">                                       </code><a class="co" href="#list_id_4_5" id="code_id_4_5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">data_t</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="w"> </code><code class="o">*</code><code class="n">p</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"</code><code class="s">Hello World</code><code class="s">"</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">data</code><code class="p">.</code><code class="n">pid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_pid_tgid</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="o">&gt;</code><code class="w"> </code><code class="mi">32</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">data</code><code class="p">.</code><code class="n">uid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_uid_gid</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="mh">0xFFFFFFFF</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">bpf_get_current_comm</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">config</code><code class="p">.</code><code class="n">lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">uid</code><code class="p">)</code><code class="p">;</code><code class="w">                              </code><a class="co" href="#list_id_4_6" id="code_id_4_6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">p</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">     </code><code class="n">bpf_probe_read_kernel</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">p</code><code class="o">-</code><code class="o">&gt;</code><code class="n">message</code><code class="p">)</code><code class="p">;</code><code class="w">      </code><code class="w">&#13;
</code><code class="w">  </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">     </code><code class="n">bpf_probe_read_kernel</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">message</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">output</code><code class="p">.</code><code class="n">perf_submit</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_4_1" id="list_id_4_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>This line indicates that there’s a structure definition, <code>user_msg_t</code>, for holding a 12-character message.</dd>&#13;
<dt><a class="co" href="#code_id_4_2" id="list_id_4_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>The BCC macro <code>BPF_HASH</code> is used to define a hash table map called <code>config</code>. It will hold values of type <code>user_msg_t</code>, indexed by keys of type <code>u32</code>, which is the right size for a user ID. (If you don’t specify the types for the keys and values, BCC defaults to <code>u64</code> for both.)</dd>&#13;
<dt><a class="co" href="#code_id_4_3" id="list_id_4_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>The perf buffer output is defined in exactly the same way as in <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>. You can submit arbitrary data to a buffer, so there’s no need to specify any data types here…</dd>&#13;
<dt><a class="co" href="#code_id_4_4" id="list_id_4_4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>…although in practice, in this example the program always submits a <code>data_t</code> structure. This is also unchanged from the <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a> example.</dd>&#13;
<dt><a class="co" href="#code_id_4_5" id="list_id_4_5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd>Most of the rest of the eBPF program is unchanged from the <code>hello()</code> version you saw earlier.</dd>&#13;
<dt><a class="co" href="#code_id_4_6" id="list_id_4_6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd>The only difference is that having used a helper function to get the user ID, the code looks for an entry in the <code>config</code> hash map with that user ID as the key. If there is a matching entry, the value contains a message that gets used instead of the default “Hello World.”</dd>&#13;
</dl>&#13;
<p>The Python code has two additional lines:</p>&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">b</code><code class="p">[</code><code class="s2">"config"</code><code class="p">][</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">0</code><code class="p">)]</code> <code class="o">=</code> <code class="n">ct</code><code class="o">.</code><code class="n">create_string_buffer</code><code class="p">(</code><code class="sa">b</code><code class="s2">"Hey root!"</code><code class="p">)</code>&#13;
<code class="n">b</code><code class="p">[</code><code class="s2">"config"</code><code class="p">][</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">501</code><code class="p">)]</code> <code class="o">=</code> <code class="n">ct</code><code class="o">.</code><code class="n">create_string_buffer</code><code class="p">(</code><code class="sa">b</code><code class="s2">"Hi user 501!"</code><code class="p">)</code></pre>&#13;
<p>These define messages in the <code>config</code> hash table for user IDs 0 and 501, which correspond to the root user and my user ID on this virtual machine. This code uses Python’s <code>ctypes</code> package to ensure that the key and value have the same types as those used in the C definition of <code>user_msg_t</code>.</p>&#13;
<p>Here’s some illustrative output from this example, along with the commands I ran in a second terminal to obtain it:</p>&#13;
<pre data-type="programlisting">Terminal 1                             Terminal 2&#13;
$ ./hello-buffer-config.py &#13;
37926 501 bash Hi user 501!            ls &#13;
37927 501 bash Hi user 501!            sudo ls&#13;
37929 0 sudo Hey root!&#13;
37931 501 bash Hi user 501!            sudo -u daemon ls&#13;
37933 1 sudo Hello World</pre>&#13;
<p>Now that you’ve got an idea of what this program does, I’d like to show you the <code>bpf()</code> system calls that are used when it runs. I’ll run it again using <code>strace</code>, specifying <code>-e bpf</code> to indicate that I am only interested in seeing the <code>bpf()</code> syscall:</p>&#13;
<pre data-type="programlisting">$ strace -e bpf ./hello-buffer-config.py</pre>&#13;
<p>The output you’ll see if you try this yourself shows several calls to this syscall. For each, you’ll see the command indicating what the <code>bpf()</code> syscall should do. The broad outline looks like this:</p>&#13;
<pre data-type="programlisting">bpf(BPF_BTF_LOAD, ...) = 3&#13;
bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY…) = 4&#13;
bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_HASH...) = 5&#13;
bpf(BPF_PROG_LOAD, {prog_type=BPF_PROG_TYPE_KPROBE,...prog_name="hello",...) = 6&#13;
bpf(BPF_MAP_UPDATE_ELEM, ...}&#13;
...</pre>&#13;
<p>Let’s examine them one by one. Neither you, the reader, nor I have infinite patience, so I won’t discuss every single argument to every single call! I’ll focus on the parts that I think really help to tell the story of what’s happening when a user space program interacts with an eBPF program.</p>&#13;
<section data-pdf-bookmark="Loading BTF Data" data-type="sect1"><div class="sect1" id="loading_btf_data">&#13;
<h1>Loading BTF Data</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="loading BTF data" data-type="indexterm" id="idm46123199896288"/><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="loading BTF data" data-type="indexterm" id="idm46123199894912"/>The first call to <code>bpf()</code> that I see looks like this:</p>&#13;
<pre data-type="programlisting">bpf(BPF_BTF_LOAD, {btf="\237\353\1\0...}, 128) = 3</pre>&#13;
<p>In this case the command you can see in the output is <code>BPF_BTF_LOAD</code>. This is just one of a set of valid commands that are (at least at the time of this writing) most comprehensively documented within the kernel source code.<sup><a data-type="noteref" href="ch04.html#ch04fn1" id="ch04fn1-marker">1</a></sup></p>&#13;
<p>It’s possible that you won’t see a call with this command if you’re using a relatively old Linux kernel, as it relates to BTF, or BPF Type Format.<sup><a data-type="noteref" href="ch04.html#ch04fn2" id="ch04fn2-marker">2</a></sup> BTF allows eBPF programs to be portable across different kernel versions so that you can compile a program on one machine and use it on another, which might be using a different kernel version and hence have different kernel data structures. I’ll discuss this in more detail in <span class="keep-together"><a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a></span>.</p>&#13;
<p>This call to <code>bpf()</code> is loading a blob of BTF data into the kernel, and the return code from the <code>bpf()</code> system call (<code>3</code> in my example) is a file descriptor that refers to that data.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a contenteditable="false" data-primary="file descriptor" data-type="indexterm" id="idm46123199883136"/>A <em>file descriptor</em> is an identifier for an open file (or file-like object). If you open a file (with the <code>open()</code> or <code>openat()</code> system call) the return code is a file descriptor, which is then passed as an argument to other syscalls such as <code>read()</code> or <code>write()</code> to perform operations on that file. Here the blob of data isn’t exactly a file, but it is given a file descriptor as an identifier that can be used for future operations that refer to it.</p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Creating Maps" data-type="sect1"><div class="sect1" id="creating_maps">&#13;
<h1>Creating Maps</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="creating maps" data-type="indexterm" id="idm46123199842192"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="creating" data-type="indexterm" id="idm46123199840976"/>The next <code>bpf()</code> creates the <code>output</code> perf buffer map:</p>&#13;
<pre data-type="programlisting">bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_PERF_EVENT_ARRAY, , key_size=4, &#13;
value_size=4, max_entries=4, ... map_name="output", ...}, 128) = 4</pre>&#13;
<p><a contenteditable="false" data-primary="BPF_MAP_CREATE" data-type="indexterm" id="idm46123199837824"/>You can probably guess from the command name <code>BPF_MAP_CREATE</code> that this call creates an eBPF map. You can see that the type of this map is <code>PERF_EVENT_ARRAY</code> and it is called <code>output</code>. The keys and values in this perf event map are 4 bytes long. There’s also a limit of four key–value pairs that can be held in this map, defined by the field <code>max_entries</code>; I’ll explain why there are four entries in this map later in this chapter. The return value of <code>4</code> is the file descriptor for the user space code to access the <code>output</code> map.</p>&#13;
<p>The next <code>bpf()</code> system call in the output creates the <code>config</code> map:</p>&#13;
<pre data-type="programlisting">bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_HASH, key_size=4, value_size=12,&#13;
max_entries=10240... map_name="config", ...btf_fd=3,...}, 128) = 5</pre>&#13;
<p>This map is defined to be a hash table map, with keys that are 4 bytes long (which corresponds to a 32-bit integer that can be used to hold a user ID) and values that are 12 bytes long (which matches the length of the <code>msg_t</code> structure). I didn’t specify the size of the table, so it has been given BCC’s default size of 10,240 entries.</p>&#13;
<p>This <code>bpf()</code> system call also returns a file descriptor, <code>5</code>, which will be used to refer to this <code>config</code> map in future syscalls.</p>&#13;
<p>You can also see the field <code>btf_fd=3</code>, which tells the kernel to use the BTF file descriptor <code>3</code> that was obtained earlier. As you’ll see in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, BTF information describes the layout of data structures, and including this in the definition of the map means there’s information about the layout of the key and value types used in this map. This is used by tools like <code>bpftool</code> to pretty-print map dumps, making them human readable—you saw an example of this in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Loading a Program" data-type="sect1"><div class="sect1" id="loading_a_program">&#13;
<h1>Loading a Program</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="loading programs" data-type="indexterm" id="idm46123199823648"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="loading with bpf() syscall" data-type="indexterm" id="idm46123199822176"/>So far you have seen the example program using syscalls to load BTF data into the kernel and create some eBPF maps. The next thing it does is load the eBPF program being loaded into the kernel with the following <code>bpf()</code> syscall:</p>&#13;
<pre data-type="programlisting">bpf(BPF_PROG_LOAD, {prog_type=BPF_PROG_TYPE_KPROBE, insn_cnt=44,&#13;
insns=0xffffa836abe8, license="GPL", ... prog_name="hello", ... &#13;
expected_attach_type=BPF_CGROUP_INET_INGRESS, prog_btf_fd=3,...}, 128) = 6</pre>&#13;
<p>Quite a few of the fields here are interesting:</p>&#13;
<ul>&#13;
<li><p>The <code>prog_type</code> field describes the program type, which here indicates that it’s intended to be attached to a kprobe. You’ll learn more about program types in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.</p></li>&#13;
<li><p>The <code>insn_cnt</code> field means “instruction count.” This is the number of bytecode instructions in the program.</p></li>&#13;
<li><p>The bytecode instructions that make up this eBPF program are held in memory at the address specified in the <code>insns</code> field.</p></li>&#13;
<li><p>This program was specified as GPL licensed so that it can use GPL-licensed BPF helper functions.</p></li>&#13;
<li><p>The program name is <code>hello</code>.</p></li>&#13;
<li><p>The <code>expected_attach_type</code> of <code>BPF_CGROUP_INET_INGRESS</code> might seem surprising, because that sounds like something to do with ingress network traffic, but you know this eBPF program is going to be attached to a kprobe. In fact, the <code>expected_attach_type</code> field is only used for some program types, and <code>BPF_PROG_TYPE_KPROBE</code> isn’t one of them. <code>BPF_CGROUP_INET_INGRESS</code> just happens to be the first in the list of BPF attachment types,<sup><a data-type="noteref" href="ch04.html#ch04fn3" id="ch04fn3-marker">3</a></sup> so it has the value <code>0</code>.</p></li>&#13;
<li><p>The <code>prog_btf_fd</code> field tells the kernel which blob of previously loaded BTF data to use with this program. The value <code>3</code> here corresponds to the file descriptor you saw returned from the <code>BPF_BTF_LOAD</code> syscall (and it’s the same blob of BTF data used for the <code>config</code> map).</p></li>&#13;
</ul>&#13;
<p>If the program had failed verification (which I’ll discuss in <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>), this syscall would have returned a negative value, but here you can see it returned the file descriptor 6. To recap, at this point the file descriptors have the meanings shown in <a data-type="xref" href="#file_descriptors_when_running_hello_buf">Table 4-1</a>.</p>&#13;
<table class="border" id="file_descriptors_when_running_hello_buf">&#13;
<caption><span class="label">Table 4-1. </span>File descriptors when running hello-buffer-config.py after loading the program</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>File descriptor</th>&#13;
<th>Represents</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>3</code></td>&#13;
<td>BTF data</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>4</code></td>&#13;
<td><code>output</code> perf buffer map</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>5</code></td>&#13;
<td><code>config</code> hash table map</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>6</code></td>&#13;
<td><code>hello</code> eBPF program</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Modifying a Map from User Space" data-type="sect1"><div class="sect1" id="modifying_a_map_from_user_space">&#13;
<h1>Modifying a Map from User Space</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="modifying a map from user space" data-type="indexterm" id="ch04.html2"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="modifying from user space" data-type="indexterm" id="ch04.html3"/>You already saw the line in the Python user space source code that configures special messages that will be displayed for the root user with user ID 0, and for the user with ID 501:</p>&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">b</code><code class="p">[</code><code class="s2">"config"</code><code class="p">][</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">0</code><code class="p">)]</code> <code class="o">=</code> <code class="n">ct</code><code class="o">.</code><code class="n">create_string_buffer</code><code class="p">(</code><code class="sa">b</code><code class="s2">"Hey root!"</code><code class="p">)</code>&#13;
<code class="n">b</code><code class="p">[</code><code class="s2">"config"</code><code class="p">][</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">501</code><code class="p">)]</code> <code class="o">=</code> <code class="n">ct</code><code class="o">.</code><code class="n">create_string_buffer</code><code class="p">(</code><code class="sa">b</code><code class="s2">"Hi user 501!"</code><code class="p">)</code></pre>&#13;
<p>You can see these entries being defined in the map through syscalls like this:</p>&#13;
<pre>bpf(BPF_MAP_UPDATE_ELEM, {map_fd=5, key=0xffffa7842490, value=0xffffa7a2b410,&#13;
flags=BPF_ANY}, 128) = 0</pre>&#13;
<p><a contenteditable="false" data-primary="BPF_MAP_UPDATE_ELEM" data-type="indexterm" id="idm46123199767872"/>The <code>BPF_MAP_UPDATE_ELEM</code> command updates the key–value pair in a map. The <code>BPF_ANY</code> flag indicates that if the key doesn’t already exist in this map, it should be created. There are two of these calls, corresponding to the two entries configured for two different user IDs.</p>&#13;
<p>The <code>map_fd</code> field identifies which map is being operated on. You can see that in this case it’s <code>5</code>, which is the file descriptor value returned earlier when the <code>config</code> map was created.</p>&#13;
<p>File descriptors are assigned by the kernel for a particular process, so this value of <code>5</code> is only valid for this particular user space process in which the Python program is running. However, multiple user space programs (and multiple eBPF programs in the kernel) can all access the same map. Two user space programs that access the same map structure in the kernel might very well be assigned different file descriptor values; equally, two user space programs might have the same file descriptor value for entirely different maps.</p>&#13;
<p>Both the key and the value are pointers, so you can’t tell the numeric value of either the key or the value from this <code>strace</code> output. <a contenteditable="false" data-primary="bpftool" data-secondary="viewing map contents with" data-type="indexterm" id="idm46123199721408"/>You could, however, use <code>bpftool</code> to view the map’s contents and see something like this:</p>&#13;
<pre data-type="programlisting">$ bpftool map dump name config&#13;
[{&#13;
        "key": 0,&#13;
        "value": {&#13;
            "message": "Hey root!"&#13;
        }&#13;
    },{&#13;
        "key": 501,&#13;
        "value": {&#13;
            "message": "Hi user 501!"&#13;
        }&#13;
    }&#13;
]</pre>&#13;
<p>How does <code>bpftool</code> know how to format this output? For example, how does it know the value is a structure, with a field called <code>message</code> that contains a string? The answer is that it uses the definitions in the BTF information included on the <code>BPF_MAP_CREATE</code> syscall that defined this map. You’ll see more details on how BTF conveys this information in the next chapter.</p>&#13;
<p>You’ve now seen how user space interacts with the kernel to load programs and maps and to update the information in a map. In the sequence of syscalls you have seen up to this point, the program hasn’t yet been attached to an event. This step has to happen; otherwise, the program will never be triggered.</p>&#13;
<p>Fair warning: different types of eBPF programs get attached to different events in a variety of different ways! Later in this chapter I’ll show you the syscalls used in this example to attach to the kprobe event, and in this case it doesn’t involve <code>bpf()</code>. In contrast, in the exercises at the end of this chapter I will show you another example where a <code>bpf()</code> syscall is used to attach a program to a raw tracepoint event.</p>&#13;
<p>Before we get to those details, I’d like to discuss what happens when you quit running the program. You’ll find that the program and maps are automatically unloaded, and this happens because the kernel is keeping track of them using <em>reference counts</em>.<a contenteditable="false" data-primary="" data-startref="ch04.html3" data-type="indexterm" id="idm46123199704256"/><a contenteditable="false" data-primary="" data-startref="ch04.html2" data-type="indexterm" id="idm46123199702976"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BPF Program and Map References" data-type="sect1"><div class="sect1" id="bpf_program_and_map_references">&#13;
<h1>BPF Program and Map References</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="program and map references" data-type="indexterm" id="ch04.html4"/><a contenteditable="false" data-primary="map references" data-type="indexterm" id="ch04.html5"/><a contenteditable="false" data-primary="references, program and map" data-type="indexterm" id="ch04.html6"/>You know that loading a BPF program into the kernel with the <code>bpf()</code> syscall returns a file descriptor. Within the kernel, this file descriptor is a <em>reference</em> to the program. The user space process that made the syscall owns this file descriptor; when that process exits, the file descriptor gets released, and the reference count to the program is decremented. <a contenteditable="false" data-primary="unloading programs" data-type="indexterm" id="idm46123199694592"/>When there are no references left to a BPF program, the kernel removes the program.</p>&#13;
<p>An additional reference is created when you <em>pin</em> a program to the filesystem.</p>&#13;
<section data-pdf-bookmark="Pinning" data-type="sect2"><div class="sect2" id="pinning">&#13;
<h2>Pinning</h2>&#13;
<p><a contenteditable="false" data-primary="pinning" data-type="indexterm" id="idm46123199690496"/><a contenteditable="false" data-primary="references, program and map" data-secondary="pinning and" data-type="indexterm" id="idm46123199689392"/>You already saw pinning in action in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>, with the following command:</p>&#13;
<pre data-type="programlisting">bpftool prog load hello.bpf.o /sys/fs/bpf/hello</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>These pinned objects aren’t real files persisted to disk. <a contenteditable="false" data-primary="pseudo filesystem" data-type="indexterm" id="idm46123199685328"/>They are created on a <em>pseudo filesystem</em>, which behaves like a regular disk-based filesystem with directories and files. But they are held in memory, which means they will not remain in place over a system reboot.</p>&#13;
</div>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="pinning with" data-secondary-sortas="pinning" data-type="indexterm" id="idm46123199683136"/>If <code>bpftool</code> were to allow you to load the program without pinning it, that would be pointless, because the file descriptor gets released when <code>bpftool</code> exits, and if there are zero references, the program would get deleted, so nothing useful would have been achieved. But pinning it to the filesystem means there is an additional reference to the program, so the program remains loaded after the command completes.</p>&#13;
<p>The reference counter also gets incremented when a BPF program is attached to a hook that will trigger it. The behavior of these reference counts depends on the BPF program type. You’ll learn more about these program types in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>, but there are some that relate to tracing (like kprobes and tracepoints) and are always associated with a user space process; for these types of eBPF programs, the kernel’s reference count gets decremented when that process exits. Programs that are attached within the network stack or cgroups (short for “control groups”) aren’t associated with any user space process, so they stay in place even after the user space program that loads them exits. <a contenteditable="false" data-primary="ip link" data-type="indexterm" id="idm46123199679104"/>You already saw an example of this when loading an XDP program with the <code>ip link</code> command:</p>&#13;
<pre data-type="programlisting">ip link set dev eth0 xdp obj hello.bpf.o sec xdp</pre>&#13;
<p>The <code>ip</code> command has completed, and there is no definition of a pinned location, but nevertheless, <code>bpftool</code> will show you that the XDP program is loaded in the kernel:</p>&#13;
<pre data-type="programlisting">$ bpftool prog list&#13;
… &#13;
1255: xdp  name hello  tag 9d0e949f89f1a82c  gpl&#13;
        loaded_at 2022-11-01T19:21:14+0000  uid 0&#13;
        xlated 48B  jited 108B  memlock 4096B  map_ids 612</pre>&#13;
<p>The reference count for this program is nonzero, because of the attachment to the XDP hook that persisted after the <code>ip link</code> command completed.</p>&#13;
<p>eBPF maps also have reference counters, and they get cleaned up when their reference count drops to zero. Each eBPF program that uses a map increments the counter, as does each file descriptor that user space programs might hold to the map.</p>&#13;
<p>It’s possible that the source code for an eBPF program might define a map that the program doesn’t actually reference. Suppose you wanted to store some metadata about a program; you could define it as a global variable, and as you saw in the previous chapter, this information gets stored in a map. If the eBPF program doesn’t do anything with that map, there won’t automatically be a reference count from the program to the map. There’s a <code>BPF(BPF_PROG_BIND_MAP)</code> syscall that associates a map with a program so that the map doesn’t get cleaned up as soon as the user space loader program exits and is no longer holding a file descriptor reference to the map.</p>&#13;
<p>Maps can also be pinned to the filesystem, and user space programs can gain access to the map by knowing the path to the map.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Alexei Starovoitov wrote a good description of BPF reference counters and file descriptors in his blog post <a href="https://oreil.ly/vofxH">“Lifetime of BPF Objects”</a>.</p>&#13;
</div>&#13;
<p>Another way to create a reference to a BPF program is with a BPF link.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BPF Links" data-type="sect2"><div class="sect2" id="bpf_links">&#13;
<h2>BPF Links</h2>&#13;
<p><a contenteditable="false" data-primary="links, BPF" data-type="indexterm" id="idm46123199668112"/><a contenteditable="false" data-primary="references, program and map" data-secondary="BPF links and" data-type="indexterm" id="idm46123199667008"/>BPF links provide a layer of abstraction between an eBPF program and the event it’s attached to. A BPF link itself can be pinned to the filesystem, which creates an additional reference to the program. This means the user space process that loaded the program into the kernel can terminate, leaving the program loaded. The file descriptor for the user space loader program gets freed up, decreasing the count of references to the program, but the reference count will be nonzero because of the BPF link.</p>&#13;
<p>You’ll get an opportunity to see BPF links in action if you follow the exercises at the end of this chapter. For now, let’s get back to the sequence of <code>bpf()</code> syscalls used by <em>hello-buffer-config.py</em>.<a contenteditable="false" data-primary="" data-startref="ch04.html6" data-type="indexterm" id="idm46123199664160"/><a contenteditable="false" data-primary="" data-startref="ch04.html5" data-type="indexterm" id="idm46123199662752"/><a contenteditable="false" data-primary="" data-startref="ch04.html4" data-type="indexterm" id="idm46123199661376"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Additional Syscalls Involved in eBPF" data-type="sect1"><div class="sect1" id="additional_syscalls_involved_in_ebpf">&#13;
<h1>Additional Syscalls Involved in eBPF</h1>&#13;
<p>To recap, so far you have seen <code>bpf()</code> syscalls that add the BTF data, program and maps, and map data to the kernel. The next thing the <code>strace</code> output shows relates to setting up the perf buffer.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The rest of this chapter dives relatively deeply into the syscall sequences involved when using perf buffers, ring buffers, kprobes, and map iterations. Not all eBPF programs need to do these things, so if you’re in a hurry or you’re finding it a bit too detailed, feel free to skip to the chapter summary. I won’t be offended!</p>&#13;
</div>&#13;
<section data-pdf-bookmark="Initializing the Perf Buffer" data-type="sect2"><div class="sect2" id="initializing_the_perf_buffer">&#13;
<h2>Initializing the Perf Buffer</h2>&#13;
<p><a contenteditable="false" data-primary="BPF_MAP_UPDATE_ELEM" data-type="indexterm" id="idm46123199653696"/><a contenteditable="false" data-primary="bpf() system calls" data-secondary="perf buffers" data-type="indexterm" id="idm46123199652592"/><a contenteditable="false" data-primary="perf buffers" data-secondary="initializing" data-type="indexterm" id="idm46123199651216"/>You have seen the <code>bpf(BPF_MAP_UPDATE_ELEM)</code> calls that add entries into the <code>config</code> map. Next, the output shows some calls that look like this:</p>&#13;
<pre data-type="programlisting">bpf(BPF_MAP_UPDATE_ELEM, {map_fd=4, key=0xffffa7842490, value=0xffffa7a2b410,&#13;
flags=BPF_ANY}, 128) = 0</pre>&#13;
<p>These look very similar to the calls that defined the <code>config</code> map entries, except in this case the map’s file descriptor is <code>4</code>, which represents the <code>output</code> perf buffer map.</p>&#13;
<p>As before, the key and the value are pointers, so you can’t tell the numeric value of either the key or the value from this <code>strace</code> output. I see this syscall repeated four times with identical values for all the parameters, though there’s no way of knowing whether the values the pointers hold have changed between each call. Looking at these <code>BPF_MAP_UPDATE_ELEM bpf()</code> calls leaves some unanswered questions about how the buffer is set up and used:</p>&#13;
<ul>&#13;
<li><p>Why are there four calls to <code>BPF_MAP_UPDATE_ELEM</code>? Does this relate to the fact that the <code>output</code> map was created with a maximum of four entries?</p></li>&#13;
<li><p>After these four instances of <code>BPF_MAP_UPDATE_ELEM</code>, no more <code>bpf()</code> syscalls appear in the <code>strace</code> output. That might seem a little odd, because the map is there so that the eBPF program can write data every time it is triggered, and you’ve seen data being displayed by the user space code. That data is clearly not being retrieved from the map with <code>bpf()</code> syscalls, so how is it obtained?</p></li>&#13;
</ul>&#13;
<p>You’ve also yet to see any evidence of how the eBPF program is getting attached to the kprobe event that triggers it. To get the explanation for all these concerns, I need <code>strace</code> to show a few more syscalls when running this example, like this:</p>&#13;
<pre data-type="programlisting">$ strace -e bpf,perf_event_open,ioctl,ppoll ./hello-buffer-config.py</pre>&#13;
<p>For brevity, I’m going to ignore calls to <code>ioctl()</code> that aren’t specifically related to the eBPF functionality of this example.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Attaching to Kprobe Events" data-type="sect2"><div class="sect2" id="attaching_to_kprobe_events">&#13;
<h2>Attaching to Kprobe Events</h2>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="attaching to kprobe events" data-type="indexterm" id="idm46123199636000"/><a contenteditable="false" data-primary="kprobes" data-secondary="attaching eBPF program to kprobe event" data-type="indexterm" id="idm46123199634384"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="attaching to kprobe events" data-type="indexterm" id="idm46123199632992"/><a contenteditable="false" data-primary="event" data-secondary="attaching eBPF to kprobe events" data-type="indexterm" id="idm46123199631600"/>You’ve seen that file descriptor 6 was assigned to represent the eBPF program <em>hello</em> once it was loaded into the kernel. To attach the eBPF program to an event, you also need a file descriptor representing that particular event. The following line from the <code>strace</code> output shows the creation of the file descriptor for the <code>execve()</code> kprobe:</p>&#13;
<pre data-type="programlisting">perf_event_open({type=0x6 /* PERF_TYPE_??? */, ...},...) = 7</pre>&#13;
<p>According to the <a href="https://oreil.ly/xpRJs">manpage for the <code>perf_event_open()</code> syscall</a><a contenteditable="false" data-primary="perf_event_open()" data-type="indexterm" id="idm46123199626336"/>, it “creates a file descriptor that allows measuring performance information.” You can see from the output that <code>strace</code> doesn’t know how to interpret the type parameter with the value <code>6</code>, but if you examine that manpage further, it describes how Linux supports dynamic types of <a contenteditable="false" data-primary="Performance Measurement Unit (PMU)" data-type="indexterm" id="idm46123199623952"/>Performance Measurement Unit:</p>&#13;
<blockquote>&#13;
<p>…there is a subdirectory per PMU instance under <em>/sys/bus/event_source/devices</em>. In each subdirectory there is a type file whose content is an integer that can be used in the type field.</p>&#13;
</blockquote>&#13;
<p>Sure enough, if you look under that directory, you’ll find a <em>kprobe/type</em> file:</p>&#13;
<pre data-type="programlisting">$ cat /sys/bus/event_source/devices/kprobe/type&#13;
6</pre>&#13;
<p>From this, you can see that the call to <code>perf_event_open()</code> has a type set to the value <code>6</code> to indicate that it’s a kprobe type of perf event.</p>&#13;
<p>Unfortunately, <code>strace</code> doesn’t output the details that would conclusively show that the kprobe is attached to the <code>execve()</code> syscall, but I hope there is enough evidence here to convince you that that’s what the file descriptor returned here represents.</p>&#13;
<p>The return code from <code>perf_event_open()</code> is <code>7</code>, and this represents the file descriptor for the kprobe’s perf event, and you know that file descriptor <code>6</code> represents the <em>hello</em> eBPF program. <a contenteditable="false" data-primary="ioctl" data-type="indexterm" id="ch04.html8"/>The manpage for <code>perf_event_open()</code> also explains how to use <code>ioctl()</code> to create the attachment between the two:</p>&#13;
<blockquote>&#13;
<p><code>PERF_EVENT_IOC_SET_BPF</code> [...] allows attaching a Berkeley Packet Filter (BPF) program to an existing kprobe tracepoint event. The argument is a BPF program file descriptor that was created by a previous <code>bpf(2)</code> system call.</p>&#13;
</blockquote>&#13;
<p>This explains the following <code>ioctl()</code> syscall that you’ll see in the <code>strace</code> output, with arguments referring to the two file descriptors:</p>&#13;
<pre data-type="programlisting">ioctl(7, PERF_EVENT_IOC_SET_BPF, 6)     = 0</pre>&#13;
<p>There is also another <code>ioctl()</code> call that turns the kprobe event on:</p>&#13;
<pre data-type="programlisting">ioctl(7, PERF_EVENT_IOC_ENABLE, 0)      = 0</pre>&#13;
<p>With this in place, the eBPF program should be triggered whenever <code>execve()</code> is run on this machine.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Setting Up and Reading Perf Events" data-type="sect2"><div class="sect2" id="setting_up_and_reading_perf_events">&#13;
<h2>Setting Up and Reading Perf Events</h2>&#13;
<p><a contenteditable="false" data-primary="BPF_MAP_UPDATE_ELEM" data-type="indexterm" id="idm46123199603568"/><a contenteditable="false" data-primary="bpf() system calls" data-secondary="perf events" data-type="indexterm" id="idm46123199602464"/><a contenteditable="false" data-primary="perf buffers" data-secondary="setting up/reading perf events" data-type="indexterm" id="idm46123199601088"/>I already mentioned that I see four calls to <code>bpf(BPF_MAP_UPDATE_ELEM)</code> related to the output perf buffer. With the additional syscalls being traced, the <code>strace</code> output shows four sequences, like this:</p>&#13;
<pre data-type="programlisting">perf_event_open({type=PERF_TYPE_SOFTWARE, size=0 /* PERF_ATTR_SIZE_??? */, &#13;
config=PERF_COUNT_SW_BPF_OUTPUT, ...}, -1, <strong>X</strong>, -1, PERF_FLAG_FD_CLOEXEC) = <strong>Y</strong>&#13;
&#13;
ioctl(<strong>Y</strong>, PERF_EVENT_IOC_ENABLE, 0)      = 0&#13;
&#13;
bpf(BPF_MAP_UPDATE_ELEM, {map_fd=4, key=0xffffa7842490, value=0xffffa7a2b410,&#13;
flags=BPF_ANY}, 128) = 0</pre>&#13;
<p>I’ve used <code>X</code> to indicate where the output shows values <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code> in the four instances of this call. Referring to the manpage for the <code>perf_event_open()</code> syscall, you’ll see that this is the <code>cpu</code>, and the field before it is <code>pid</code> or process ID. From the manpage:</p>&#13;
<blockquote>&#13;
<p>pid == -1 and cpu &gt;= 0</p>&#13;
<p>This measures all processes/threads on the specified CPU.</p>&#13;
</blockquote>&#13;
<p>The fact that this sequence happens four times corresponds to there being four CPU cores in my laptop. This, at last, is the explanation for why there are four entries in the “output” perf buffer map: there is one for each CPU core. It also explains the “array” part of the map type name <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>, as the map doesn’t just represent one perf ring buffer but an array of buffers, one for each core.</p>&#13;
<p>If you write eBPF programs, you won’t need to worry about details like handling the number of cores, as this will be taken care of for you by any of the eBPF libraries discussed in <a data-type="xref" href="ch10.html#ebpf_programming">Chapter 10</a>, but I think it’s an interesting aspect of the syscalls you see when you use <code>strace</code> on this program.</p>&#13;
<p>The <code>perf_event_open()</code> calls each return a file descriptor, which I’ve represented as <code>Y</code>; these have the values <code>8</code>, <code>9</code>, <code>10</code>, and <code>11</code>. The <code>ioctl()</code> syscalls enable the perf output for each of these file descriptors<a contenteditable="false" data-primary="" data-startref="ch04.html8" data-type="indexterm" id="idm46123199584016"/>. The <code>BPF_MAP_UPDATE_ELEM bpf()</code> syscalls set the map entry to point to the perf ring buffer for each CPU core to indicate where it can submit data.</p>&#13;
<p>User space code can then use <code>ppoll()</code> on all four of these output stream file descriptors so that it can get the data output, whichever core happens to run the eBPF program <em>hello</em> for any given <code>execve()</code> kprobe event. Here’s the syscall to <code>ppoll()</code>:</p>&#13;
<pre data-type="programlisting">ppoll([{fd=8, events=POLLIN}, {fd=9, events=POLLIN}, {fd=10, events=POLLIN},&#13;
{fd=11, events=POLLIN}], 4, NULL, NULL, 0) = 1 ([{fd=8, revents=POLLIN}])</pre>&#13;
<p>As you’ll see if you try running the example program yourself, these <code>ppoll()</code> calls block until there is something to read from one of the file descriptors. You won’t see the return code written to the screen until something triggers <code>execve()</code>, which causes the eBPF program to write data that user space retrieves using this <code>ppoll()</code> call.</p>&#13;
<p>In <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a> I mentioned that if you have a kernel of version 5.8 or above, BPF ring buffers are now preferred over perf buffers.<sup><a data-type="noteref" href="ch04.html#ch04fn4" id="ch04fn4-marker">4</a></sup> Let’s take a look at a modified version of the same example code that uses a ring buffer.</p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Ring Buffers" data-type="sect1"><div class="sect1" id="ring_buffers_id000008">&#13;
<h1>Ring Buffers</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="ring buffers" data-type="indexterm" id="ch04.html9"/><a contenteditable="false" data-primary="ring buffers" data-type="indexterm" id="ch04.html10"/>As <a contenteditable="false" data-primary="perf buffers" data-secondary="ring buffers versus" data-type="indexterm" id="idm46123199568112"/><a contenteditable="false" data-primary="ring buffers" data-secondary="perf buffers versus" data-type="indexterm" id="idm46123199566704"/>discussed in the <a href="https://oreil.ly/RN_RA">kernel documentation</a>, ring buffers are preferred over perf buffers partly for performance reasons, but also to ensure that the ordering of data is preserved, even if the data is submitted by different CPU cores. There is just one buffer, shared across all cores.</p>&#13;
<p>There aren’t many changes needed to convert <em>hello-buffer-config.py</em> to use a ring buffer. In the accompanying GitHub repo you’ll find this example as <em>chapter4/hello-ring-buffer-config.py</em>. <a data-type="xref" href="#differences_between_example_bcc_code_us">Table 4-2</a> shows the differences.</p>&#13;
<table class="border" id="differences_between_example_bcc_code_us">&#13;
<caption><span class="label">Table 4-2. </span>Differences between example BCC code using a perf buffer and a ring buffer</caption>&#13;
<thead>&#13;
<tr>&#13;
<th><em>hello-buffer-config.py</em></th>&#13;
<th><em>hello-ring-buffer-config.py</em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>BPF_PERF_OUTPUT(output);</code></td>&#13;
<td><code>BPF_RINGBUF_OUTPUT(output, 1);</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>output.perf_submit(ctx, &amp;data, sizeof(data));</code></td>&#13;
<td><code>output.ringbuf_output(&amp;data, sizeof(data), 0);</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>b["output"].<br/>open_perf_buffer(print_event)</code></td>&#13;
<td><code>b["output"].<br/>open_ring_buffer(print_event)</code></td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>b.perf_buffer_poll()</code></td>&#13;
<td><code>b.ring_buffer_poll()</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p>As you’d expect, since these changes relate only to the <code>output</code> buffer, the syscalls related to loading the program and the <code>config</code> map and attaching the program to the kprobe event all remain unchanged.</p>&#13;
<p>The <code>bpf()</code> syscall that creates the <code>output</code> ring buffer map looks like this:</p>&#13;
<pre data-type="programlisting">bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_RINGBUF, key_size=0, value_size=0,&#13;
max_entries=4096, ... map_name="output", ...}, 128) = 4</pre>&#13;
<p>The major difference in the <code>strace</code> output is that there is no sign of the series of four different <code>perf_event_open()</code>, <code>ioctl()</code>, and <code>bpf(BPF_MAP_UPDATE_ELEM)</code> system calls that you observed during the setup of a perf buffer. For a ring buffer, there’s just the one file descriptor shared across all CPU cores.</p>&#13;
<p>At the time of this writing, BCC is using the <code>ppoll</code> mechanism I showed earlier for perf buffers, but it uses the newer <code>epoll</code> mechanism to wait for data from the ring buffer. Let’s use this as an opportunity to understand the difference between <code>ppoll</code> and <code>epoll</code>.</p>&#13;
<p>In the perf buffer example, I showed <em>hello-buffer-config.py</em> generating a <code>ppoll()</code> syscall, like this:</p>&#13;
<pre data-type="programlisting">ppoll([{fd=8, events=POLLIN}, {fd=9, events=POLLIN}, {fd=10, events=POLLIN},&#13;
{fd=11, events=POLLIN}], 4, NULL, NULL, 0) = 1 ([{fd=8, revents=POLLIN}])</pre>&#13;
<p>Notice that this passes in the set of file descriptors <code>8</code>, <code>9</code>, <code>10</code>, and <code>11</code> from which the user space process wants to retrieve data. Every time this poll event returns data, another call has to be made to <code>ppoll()</code> to set up the same set of file descriptors all over again. When using <code>epoll</code>, the file descriptor set is managed in a kernel object.</p>&#13;
<p>You can see this in the following sequence of <code>epoll</code>-related system calls made when <em>hello-ring-buffer-config.py</em> is setting up access to the <code>output</code> ring buffer.</p>&#13;
<p>First, the user space program asks for a new <code>epoll</code> instance to be created in the <span class="keep-together">kernel</span>:</p>&#13;
<pre data-type="programlisting">epoll_create1(EPOLL_CLOEXEC) = 8</pre>&#13;
<p>This returns file descriptor <code>8</code>. Then there is a call to <code>epoll_ctl()</code>, which tells the kernel to add file descriptor <code>4</code> (the <code>output</code> buffer) to the set of file descriptors in that <code>epoll</code> instance:</p>&#13;
<pre data-type="programlisting">epoll_ctl(8, EPOLL_CTL_ADD, 4, {events=EPOLLIN, data={u32=0, u64=0}}) = 0</pre>&#13;
<p>The user space program uses <code>epoll_pwait()</code> to wait until data is available in the ring buffer. This call only returns when data is available:</p>&#13;
<pre data-type="programlisting">epoll_pwait(8,  [{events=EPOLLIN, data={u32=0, u64=0}}], 1, -1, NULL, 8) = 1</pre>&#13;
<p>Of course, if you’re writing code using a framework like BCC (or <em>libbpf</em> or any of the other libraries I’ll describe later in this book), you really don’t need to know these underlying details about how your user space application gets information from the kernel via perf or ring buffers. I hope you’ve found it interesting to get a peek under the covers to see how these things work.</p>&#13;
<p>However, you might well find yourself writing code that accesses a map from user space, and it might be helpful to see an example of how this is achieved. Earlier in this chapter, I used <code>bpftool</code> to examine the contents of the <code>config</code> map. Since it’s a utility that runs in user space, let’s use <code>strace</code> to see what syscalls it’s making to retrieve this information.<a contenteditable="false" data-primary="" data-startref="ch04.html10" data-type="indexterm" id="idm46123199524624"/><a contenteditable="false" data-primary="" data-startref="ch04.html9" data-type="indexterm" id="idm46123199523168"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Reading Information from a Map" data-type="sect1"><div class="sect1" id="reading_information_from_a_map">&#13;
<h1>Reading Information from a Map</h1>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="reading information from a map" data-type="indexterm" id="ch04.html11"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="reading information from" data-type="indexterm" id="ch04.html12"/><a contenteditable="false" data-primary="bpftool" data-secondary="reading map information" data-type="indexterm" id="readingMapInformation"/>The following command shows an extract of the <code>bpf()</code> syscalls that <code>bpftool</code> makes while reading the contents of the <code>config</code> map:</p>&#13;
<pre data-type="programlisting">$ strace -e bpf bpftool map dump name config</pre>&#13;
<p>As you’ll see, the sequence consists of two main steps:</p>&#13;
<ul>&#13;
<li><p>Iterate through all the maps, looking for any with the name <code>config</code>.</p></li>&#13;
<li><p>If a matching map is found, iterate through all the elements in that map.</p></li>&#13;
</ul>&#13;
<section data-pdf-bookmark="Finding a Map" data-type="sect2"><div class="sect2" id="finding_a_map">&#13;
<h2>Finding a Map</h2>&#13;
<p><a contenteditable="false" data-primary="maps, BPF" data-secondary="finding" data-type="indexterm" id="idm46123199508624"/>The output starts with a repeated sequence of similar calls, as <code>bpftool</code> walks through all the maps looking for any with the name <code>config</code>:</p>&#13;
<pre data-type="programlisting">bpf(BPF_MAP_GET_NEXT_ID, {start_id=0,...}, 12) = 0             <a class="co" href="#list_id_4_7" id="code_id_4_7"><img alt="1" src="assets/1.png"/></a>&#13;
bpf(BPF_MAP_GET_FD_BY_ID, {map_id=48...}, 12) = 3              <a class="co" href="#list_id_4_8" id="code_id_4_8"><img alt="2" src="assets/2.png"/></a>&#13;
bpf(BPF_OBJ_GET_INFO_BY_FD, {info={bpf_fd=3, ...}}, 16) = 0    <a class="co" href="#list_id_4_9" id="code_id_4_9"><img alt="3" src="assets/3.png"/></a>&#13;
  &#13;
bpf(BPF_MAP_GET_NEXT_ID, {start_id=48, ...}, 12) = 0           <a class="co" href="#list_id_4_10" id="code_id_4_10"><img alt="4" src="assets/4.png"/></a>&#13;
bpf(BPF_MAP_GET_FD_BY_ID, {map_id=116, ...}, 12) = 3&#13;
bpf(BPF_OBJ_GET_INFO_BY_FD, {info={bpf_fd=3...}}, 16) = 0</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_4_7" id="list_id_4_7"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><a contenteditable="false" data-primary="BPF_MAP_GET_NEXT_ID" data-type="indexterm" id="idm46123199494992"/><code>BPF_MAP_GET_NEXT_ID</code> gets the ID of the next map after the value specified in <code>start_id</code>.</dd>&#13;
<dt><a class="co" href="#code_id_4_8" id="list_id_4_8"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><a contenteditable="false" data-primary="BPF_MAP_GET_FD_BY_ID" data-type="indexterm" id="idm46123199490752"/><code>BPF_MAP_GET_FD_BY_ID</code> returns the file descriptor for the specified map ID.</dd>&#13;
<dt><a class="co" href="#code_id_4_9" id="list_id_4_9"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><a contenteditable="false" data-primary="BPF_OBJ_GET_INFO_BY_FD" data-type="indexterm" id="idm46123199486976"/><code>BPF_OBJ_GET_INFO_BY_FD</code> retrieves information about the object (in this case, the map) referred to by the file descriptor. This information includes its name so <code>bpftool</code> can check whether this is the map it is looking for.</dd>&#13;
<dt><a class="co" href="#code_id_4_10" id="list_id_4_10"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>The sequence repeats, getting the ID of the next map after the one in step 1.</dd>&#13;
</dl>&#13;
<p>There’s a group of these three syscalls for each map loaded into the kernel, and you should also see that the values used for <code>start_id</code> and <code>map_id</code> match the IDs of those maps. The repeated pattern ends when there are no more maps left to look at, which results in <code>BPF_MAP_GET_NEXT_ID</code> returning a value of <code>ENOENT</code>, like this:</p>&#13;
<pre data-type="programlisting">bpf(BPF_MAP_GET_NEXT_ID, {start_id=133,...}, 12) = -1 ENOENT (No such file or&#13;
directory)</pre>&#13;
<p>If a matching map has been found, <code>bpftool</code> holds its file descriptor so that it can read the elements out of that map.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Reading Map Elements" data-type="sect2"><div class="sect2" id="reading_map_elements">&#13;
<h2>Reading Map Elements</h2>&#13;
<p><a contenteditable="false" data-primary="maps, BPF" data-secondary="reading map elements" data-type="indexterm" id="idm46123199476672"/><a contenteditable="false" data-startref="readingMapInformation" data-type="indexterm" id="idm46123199475200"/>At this point <code>bpftool</code> has a file descriptor reference to the map(s) it’s going to read from. Let’s look at the syscall sequence for reading that information:</p>&#13;
<pre data-type="programlisting">bpf(BPF_MAP_GET_NEXT_KEY, {map_fd=3, key=NULL,                    <a class="co" href="#list_id_4_11" id="code_id_4_11"><img alt="1" src="assets/1.png"/></a>&#13;
next_key=0xaaaaf7a63960}, 24) = 0&#13;
bpf(BPF_MAP_LOOKUP_ELEM, {map_fd=3, key=0xaaaaf7a63960,           <a class="co" href="#list_id_4_12" id="code_id_4_12"><img alt="2" src="assets/2.png"/></a>&#13;
value=0xaaaaf7a63980, flags=BPF_ANY}, 32) = 0&#13;
[{                                                                <a class="co" href="#list_id_4_13" id="code_id_4_13"><img alt="3" src="assets/3.png"/></a>&#13;
        "key": 0,&#13;
        "value": {&#13;
            "message": "Hey root!"&#13;
        }&#13;
bpf(BPF_MAP_GET_NEXT_KEY, {map_fd=3, key=0xaaaaf7a63960,          <a class="co" href="#list_id_4_14" id="code_id_4_14"><img alt="4" src="assets/4.png"/></a>&#13;
next_key=0xaaaaf7a63960}, 24) = 0&#13;
bpf(BPF_MAP_LOOKUP_ELEM, {map_fd=3, key=0xaaaaf7a63960, &#13;
value=0xaaaaf7a63980, flags=BPF_ANY}, 32) = 0&#13;
    },{                                                   &#13;
        "key": 501,&#13;
        "value": {&#13;
            "message": "Hi user 501!"&#13;
        }&#13;
bpf(BPF_MAP_GET_NEXT_KEY, {map_fd=3, key=0xaaaaf7a63960,          <a class="co" href="#list_id_4_15" id="code_id_4_15"><img alt="5" src="assets/5.png"/></a>&#13;
next_key=0xaaaaf7a63960}, 24) = -1 ENOENT (No such file or directory)&#13;
    }                                                             <a class="co" href="#list_id_4_16" id="code_id_4_16"><img alt="6" src="assets/6.png"/></a>&#13;
]&#13;
+++ exited with 0 +++</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_4_11" id="list_id_4_11"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>First, the application needs to find a valid key that is present in the map. It does this with the <code>BPF_MAP_GET_NEXT_KEY</code> flavor of the <code>bpf()</code> syscall. The <code>key</code> argument is a pointer to a key, and the syscall will return the next valid key <em>after</em> this one. By passing in a NULL pointer, the application is requesting the first valid key in the map. The kernel writes the key into the location specified by the <code>next_key</code> pointer.</dd>&#13;
<dt><a class="co" href="#code_id_4_12" id="list_id_4_12"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Given a key, the application requests the associated value, which gets written to the memory location specified by <code>value</code>.</dd>&#13;
<dt><a class="co" href="#code_id_4_13" id="list_id_4_13"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>At this point, <code>bpftool</code> has the contents of the first key–value pair, and it writes this information to the screen.</dd>&#13;
<dt><a class="co" href="#code_id_4_14" id="list_id_4_14"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>Here, <code>bpftool</code> moves on to the next key in the map, retrieves its value, and writes out this key–value pair to the screen.</dd>&#13;
<dt><a class="co" href="#code_id_4_15" id="list_id_4_15"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd>The next call to <code>BPF_MAP_GET_NEXT_KEY</code> returns <code>ENOENT</code> to indicate that there are no more entries in the map.</dd>&#13;
<dt><a class="co" href="#code_id_4_16" id="list_id_4_16"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd>Here, <code>bpftool</code> finalizes the output written to screen and exits.</dd>&#13;
</dl>&#13;
<p>Notice that here, <code>bpftool</code> has been assigned file descriptor <code>3</code> to correspond to the <code>config</code> map. This is the same map that <em>hello-buffer-config.py</em> refers to with file descriptor <code>4</code>. As I’ve mentioned already, file descriptors are process specific.</p>&#13;
<p>This analysis of how <code>bpftool</code> behaves shows how a user space program can iterate through the available maps and through the key–value pairs stored in a map.<a contenteditable="false" data-primary="" data-startref="ch04.html12" data-type="indexterm" id="idm46123199436960"/><a contenteditable="false" data-primary="" data-startref="ch04.html11" data-type="indexterm" id="idm46123199435584"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000013">&#13;
<h1>Summary</h1>&#13;
<p>In this chapter you saw how user space code uses the <code>bpf()</code> syscall to load eBPF programs and maps. You saw programs and maps being created using the <code>BPF_PROG_LOAD</code> and <code>BPF_MAP_CREATE</code> commands.</p>&#13;
<p>You learned that the kernel keeps track of the number of references to eBPF programs and maps, releasing them when the reference count drops to zero. You were also introduced to the concepts of pinning BPF objects to a filesystem and using BPF links to create additional references.</p>&#13;
<p>You saw an example of <code>BPF_MAP_UPDATE_ELEM</code> being used to create entries in a map from user space. There are similar commands—<code>BPF_MAP_LOOKUP_ELEM</code> and <code>BPF_MAP_DELETE_ELEM</code>—for retrieving and deleting values from a map. There is also the command <code>BPF_MAP_GET_NEXT_KEY</code> for finding the next key that’s present in a map. You can use this to iterate through all the valid entries.</p>&#13;
<p>You saw examples of user space programs making use of <code>perf_event_open()</code> and <code>ioctl()</code> for attaching eBPF programs to kprobe events. The attachment method can be very different for other types of eBPF programs, and some of them even use the <code>bpf()</code> system call. <a contenteditable="false" data-primary="BPF_PROG_ATTACH" data-type="indexterm" id="idm46123199425520"/>For example, there’s a <code>bpf(BPF_PROG_ATTACH)</code> syscall that can be used to attach cgroup programs, <a contenteditable="false" data-primary="BPF_RAW_TRACEPOINT_OPEN" data-type="indexterm" id="idm46123199423776"/>and <code>bpf(BPF_RAW_TRACEPOINT_OPEN)</code> for raw tracepoints (see Exercise 5 at the end of this chapter).</p>&#13;
<p>I also showed how you can use <code>BPF_MAP_GET_NEXT_ID</code>, <code>BPF_MAP_GET_FD_BY_ID</code>, and <code>BPF_OBJ_GET_INFO_BY_FD</code> to locate map (and other) objects held by the kernel.</p>&#13;
<p>There are some other <code>bpf()</code> commands that I haven’t covered in this chapter, but what you have seen here is enough to get a good overview.</p>&#13;
<p>You also saw some BTF data being loaded into the kernel, and I mentioned that <code>bpftool</code> uses this information to understand the format of data structures so that it can print them out nicely. I didn’t explain yet what BTF data looks like or how it’s used to make eBPF programs portable across kernel versions. That’s coming up in the next chapter.<a contenteditable="false" data-primary="" data-startref="ch04.html0" data-type="indexterm" id="idm46123199418336"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="exercises_id000003">&#13;
<h1>Exercises</h1>&#13;
<p>Here are a few things you can try if you’d like to explore the <code>bpf()</code> syscall further:</p>&#13;
<ol>&#13;
<li><p><a contenteditable="false" data-primary="BPF_PROG_LOAD" data-type="indexterm" id="idm46123199413648"/>Confirm that the <code>insn_cnt</code> field from a <code>BPF_PROG_LOAD</code> system call corresponds to the number of instructions that are output if you dump the translated eBPF bytecode for that program using <code>bpftool</code>. (This is as documented on the <a href="https://oreil.ly/NJdIM">manpage for the <code>bpf()</code> system call</a>.)</p></li>&#13;
<li><p>Run two instances of the example program so that there are two maps called <code>config</code>. If you run <code>bpftool map dump name config</code>, the output will include information about the two different maps as well as their contents. Run this under <code>strace</code>, and follow the use of different file descriptors through the syscall output. Can you see where it’s retrieving information about a map and where it’s retrieving the key–value pairs stored within it?</p></li>&#13;
<li><p>Use <code>bpftool map update</code> to modify the <code>config</code> map while one of the example programs is running. Use <code>sudo -u username</code> to check that these configuration changes are picked up by the eBPF program.</p></li>&#13;
<li><p>While <em>hello-buffer-config.py</em> is running, use <code>bpftool</code> to pin the program to the BPF filesystem, like this:</p>&#13;
<pre data-type="programlisting">bpftool prog pin name hello /sys/fs/bpf/hi</pre>&#13;
<p>Quit the running program, and check that the <em>hello</em> program is still loaded in the kernel using <code>bpftool prog list</code>. You can clean up the link by removing the pin with <code>rm /sys/fs/bpf/hi</code>.</p></li>&#13;
<li><p>Attaching to a raw tracepoint is considerably more straightforward at the syscall level than attaching to a kprobe, as it simply involves a <code>bpf()</code> syscall. Try converting <em>hello-buffer-config.py</em> to attach to the raw tracepoint for <code>sys_enter</code>, using BCC’s <code>RAW_TRACEPOINT_PROBE</code> macro (if you did the exercises in <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>, you’ll already have a suitable program you can use). You won’t need to explicitly attach the program in the Python code, as BCC will take care of it for you. Running this under <code>strace</code>, you should see a syscall similar to this:</p>&#13;
<pre data-type="programlisting">bpf(BPF_RAW_TRACEPOINT_OPEN, {raw_tracepoint={name="sys_enter",&#13;
prog_fd=6}}, 128) = 7</pre>&#13;
<p>The tracepoint in the kernel has the name <code>sys_enter</code>, and the eBPF program with file descriptor <code>6</code> is being attached to it. From now on, whenever execution in the kernel reaches that tracepoint, it will trigger the eBPF program.</p></li>&#13;
<li><p>Run the opensnoop application from <a href="https://oreil.ly/D31R4">BCC’s set of <em>libbpf tools</em></a>. This tool sets up some BPF links that you can see with <code>bpftool</code>, like this:</p>&#13;
<pre data-type="programlisting">$ bpftool link list&#13;
116: perf_event  prog 1849  &#13;
        bpf_cookie 0&#13;
        pids opensnoop(17711)&#13;
117: perf_event  prog 1851  &#13;
        bpf_cookie 0&#13;
        pids opensnoop(17711)</pre>&#13;
<p>Confirm that the program IDs (1849 and 1851 in my example output here) match the output from listing the loaded eBPF programs:</p>&#13;
<pre data-type="programlisting">$ bpftool prog list&#13;
...&#13;
1849: tracepoint  name tracepoint__syscalls__sys_enter_openat&#13;
        tag 8ee3432dcd98ffc3  gpl run_time_ns 95875 run_cnt 121&#13;
        loaded_at 2023-01-08T15:49:54+0000  uid 0&#13;
        xlated 240B  jited 264B  memlock 4096B  map_ids 571,568&#13;
        btf_id 710&#13;
        pids opensnoop(17711)&#13;
1851: tracepoint  name tracepoint__syscalls__sys_exit_openat&#13;
        tag 387291c2fb839ac6  gpl run_time_ns 8515669 run_cnt 120&#13;
        loaded_at 2023-01-08T15:49:54+0000  uid 0&#13;
        xlated 696B  jited 744B  memlock 4096B  map_ids 568,571,569&#13;
        btf_id 710&#13;
        pids opensnoop(17711)</pre></li>&#13;
<li><p>While opensnoop is running, try pinning one of these links with <code>bpftool link pin id 116 /sys/fs/bpf/mylink</code> (using one of the link IDs you see output from <code>bpftool link list</code>). You should see that even after you terminate opensnoop, both the link and the corresponding program remain loaded in the kernel.</p></li>&#13;
<li><p>If you skip ahead to the example code for <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, you’ll find a version of <em>hello-buffer-config.py</em> written using the <em>libbpf</em> library. This library automatically sets up a BPF link to the program that it loads into the kernel. Use <code>strace</code> to inspect the <code>bpf()</code> system calls that it makes, and see <code>bpf(BPF_LINK_CREATE)</code> system calls.</p></li>&#13;
</ol>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch04fn1"><sup><a href="ch04.html#ch04fn1-marker">1</a></sup> If you want to see the full set of BPF commands, they’re documented in the <a href="https://oreil.ly/Pyy7U"><em>linux/bpf.h</em></a> header file.</p><p data-type="footnote" id="ch04fn2"><sup><a href="ch04.html#ch04fn2-marker">2</a></sup> BTF was introduced upstream in the 5.1 kernel, but it has been back-ported on some Linux distributions, as you can see from <a href="https://oreil.ly/LjcPN">this discussion</a>.</p><p data-type="footnote" id="ch04fn3"><sup><a href="ch04.html#ch04fn3-marker">3</a></sup> These are defined in the <code>bpf_attach_type</code> enumerator in <a href="https://oreil.ly/AO1rc"><em>linux/bpf.h</em></a><em>.</em></p><p data-type="footnote" id="ch04fn4"><sup><a href="ch04.html#ch04fn4-marker">4</a></sup> A reminder that for more information on the difference, read Andrii Nakryiko’s <a href="https://oreil.ly/XkpUF">“BPF ring buffer”</a> blog post.</p></div></div></section></body></html>