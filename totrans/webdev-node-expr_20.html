<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 20. Debugging"><div class="chapter" id="ch_debugging">
<h1><span class="label">Chapter 20. </span>Debugging</h1>


<p><a data-type="indexterm" data-primary="debugging" id="ix_ch-20-debugging-asciidoc0"/>“Debugging” is perhaps an unfortunate term, what with its association with defects.  The fact is, what we refer to as “debugging” is an activity you will find yourself doing all the time, whether you’re implementing a new feature, learning how something works, or actually fixing a bug.  A better term might be “exploring,” but we’ll stick with “debugging,” since the activity it refers to is unambiguous, regardless of the motivation.</p>

<p>Debugging is an oft-neglected skill: it seems that most programmers are expected to be born knowing how to do it.  Perhaps computer science professors and book authors see debugging as such an obvious skill that they overlook it.</p>

<p>The fact is, debugging is a skill that can be taught, and it is an important way by which programmers come to understand not just the framework they are working in, but also their own code and that of their team. In this chapter, we’ll discuss some of the tools and techniques you can use for debugging Node and Express applications effectively.</p>






<section data-type="sect1" data-pdf-bookmark="The First Principle of Debugging"><div class="sect1" id="idm45053572513320">
<h1>The First Principle of Debugging</h1>

<p><a data-type="indexterm" data-primary="debugging" data-secondary="general principles" id="idm45053572511912"/>As the name implies, “debugging” often refers to the process of finding and eliminating defects.  Before we talk about tools, let’s consider some general debugging principles.</p>
<blockquote>
<p>How often have I said to you that when you have eliminated the impossible, whatever remains, however improbable, must be the truth?</p>
<p data-type="attribution">Sir Arthur Conan Doyle</p>
</blockquote>

<p><a data-type="indexterm" data-primary="debugging" data-secondary="elimination technique" id="idm45053572508632"/><a data-type="indexterm" data-primary="elimination, process of" id="idm45053572507496"/><a data-type="indexterm" data-primary="process of elimination" id="idm45053572506824"/>The first and most important principle of debugging is the process of <em>elimination</em>.  Modern computer systems are incredibly complicated, and if you had to hold the <em>whole system</em> in your head, and pluck the source of a single problem out of that vast space, you probably wouldn’t even know where to start.  Whenever you’re confronted with a problem that isn’t immediately obvious, your <em>very first thought</em> should be, “What can I <em>eliminate</em> as the source of the problem?”  The more you can eliminate, the fewer places you have to look.</p>

<p>Elimination can take many forms.  Here are some common examples:</p>

<ul>
<li>
<p>Systematically commenting out or disabling blocks of code.</p>
</li>
<li>
<p>Writing code that can be covered by unit tests; the unit tests themselves provide a framework for elimination.</p>
</li>
<li>
<p>Analyzing network traffic to determine if the problem is on the client or server side.</p>
</li>
<li>
<p>Testing a different part of the system that has similarities to the first.</p>
</li>
<li>
<p>Using input that has worked before, and changing that input one piece at a time until the problem exhibits.</p>
</li>
<li>
<p>Using version control to go back and forth in time until the problem disappears, and you can isolate it to a particular change (see <a href="http://bit.ly/34TOufp"><code>git bisect</code></a> for more information about this).</p>
</li>
<li>
<p>“Mocking” functionality to eliminate complex subsystems.</p>
</li>
</ul>

<p>Elimination is not a silver bullet, though.  Often, problems are due to complex <span class="keep-together">interactions</span> between two or more components: eliminate (or mock) any one of the components, and the problem could go away, but the problem can’t be isolated to any single component.  Even in this situation, though, elimination can help narrow down the problem, even if it doesn’t light up a neon sign over the exact location.</p>

<p>Elimination is most successful when it’s careful and methodical.  It’s very easy to miss things when you just wantonly eliminate components without considering how those components affect the whole.  Play a game with yourself: when you consider a component to eliminate, walk through how the removal of that component will affect the system.  This will inform you about what to expect and whether or not removing the component tells you anything useful.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Take Advantage of REPL and the Console"><div class="sect1" id="idm45053572493400">
<h1>Take Advantage of REPL and the Console</h1>

<p><a data-type="indexterm" data-primary="debugging" data-secondary="REPL" id="idm45053572492296"/><a data-type="indexterm" data-primary="read-eval-print loop (REPL)" id="idm45053572491320"/><a data-type="indexterm" data-primary="REPL (read-eval-print loop)" id="idm45053572490584"/>Both Node and your browser offer you a <em>read-eval-print loop</em> (REPL); this is basically just a way to write JavaScript interactively.  You type in some JavaScript, press Enter, and immediately see the output.  It’s a great way to play around, and is often the quickest and most intuitive way to locate an error in small bits of code.</p>

<p>In a browser, all you have to do is pull up your JavaScript console, and you have a REPL.  In Node, all you have to do is type <code>node</code> without any arguments, and you enter REPL mode; you can require packages, create variables and functions, or do anything else you could normally do in your code (except create packages: there’s no meaningful way to do that in the REPL).</p>

<p><a data-type="indexterm" data-primary="console logging" id="idm45053572487576"/><a data-type="indexterm" data-primary="debugging" data-secondary="console logging" id="idm45053572486872"/>Console logging is also your friend.  It’s a crude debugging technique, perhaps, but an easy one (both easy to understand and easy to implement).  Calling <code>console.log</code> in Node will output the contents of an object in an easy-to-read format, so you can easily spot problems.  Keep in mind that some objects are so large that logging them to the console will produce so much output that you’ll have a hard time finding any useful information.  For example, try <code>console.log(req)</code> in one of your path handlers.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Using Node’s Built-in Debugger"><div class="sect1" id="idm45053572484216">
<h1>Using Node’s Built-in Debugger</h1>

<p><a data-type="indexterm" data-primary="debugging" data-secondary="Node's built-in debugger" id="idm45053572482760"/><a data-type="indexterm" data-primary="Node" data-secondary="debugger" id="idm45053572481720"/>Node has a built-in debugger that allows you to step through your application, as if you were going on a ride-along with the JavaScript interpreter.  All you have to do to start debugging your app is use the <code>inspect</code> argument:</p>

<pre data-type="programlisting">node inspect meadowlark.js</pre>

<p>When you do, you’ll immediately notice a couple of things.  First, on your console you will see a URL; this is because the Node debugger works by creating its own web server, which allows you to control the execution of the application being debugged.  This may not be impressive right now, but the usefulness of this approach will be clear when we discuss inspector clients.</p>

<p>When you’re in the console debugger, you can type <code>help</code> to get a list of commands.  The commands you will use most often are <code>n</code> (next), <code>s</code> (step in), and <code>o</code> (step out).  <code>n</code> will step “over” the current line: it will execute it, but if that instruction calls other functions, they will be executed before control is returned to you.  <code>s</code>, in contrast, will step <em>into</em> the current line: if that line invokes other functions, you will be able to step through them.  <code>o</code> allows you to step out of the currently executing function.  (Note that “stepping in” and “stepping out” refer only to <em>functions</em>; they do not step into or out of <code>if</code> or <code>for</code> blocks or other flow-control statements.)</p>

<p>The command-line debugger has more functionality, but chances are, you won’t want to use it that often.  The command line is great for many things, but debugging isn’t one of them.  It’s good that it’s available in a pinch (for example, if all you have is SSH access to the server, or if your server doesn’t even have a GUI installed).  More often, you’ll want to use a graphical inspector client.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Node Inspector Clients"><div class="sect1" id="idm45053572471832">
<h1>Node Inspector Clients</h1>

<p><a data-type="indexterm" data-primary="debugging" data-secondary="Node inspector clients" id="ix_ch-20-debugging-asciidoc1"/><a data-type="indexterm" data-primary="inspector clients" id="ix_ch-20-debugging-asciidoc2"/><a data-type="indexterm" data-primary="Node" data-secondary="inspector clients" id="ix_ch-20-debugging-asciidoc3"/>While you probably won’t want to use the command-line debugger except in a pinch, the fact that Node exposes its debugging controls through a web service gives you other options.</p>

<p><a data-type="indexterm" data-primary="Chrome" data-secondary="debugging with" id="idm45053572698360"/>The most straightforward debugger is to use Chrome, which uses the same debugging interface as it does for debugging frontend code.  So if you’ve ever used that interface, you should feel right at home.  Getting started is easy.  Start your application with the <code>--inspect</code> option (which is distinct from the <code>inspect</code> argument mentioned previously):</p>

<pre data-type="programlisting">node --inspect meadowlark.js</pre>

<p>Now the fun begins: in your browser’s URL bar, enter <code><em>chrome://inspect</em></code>.
You’ll see a DevTools page, and in the Devices section, click “Open
dedicated DevTools for Node.”  This will open a new window, which is your
debugger:</p>

<figure><div class="figure">
<img src="Images/bwne_2001.png" alt="Staring Chrome Debugger" width="1440" height="1023"/>
<h6/>
</div></figure>

<p>Click the Sources tab, and then, in the leftmost pane, click
Node.js to expand it, and then click “file://”.  You’ll see the folder that
your application is in; expand that, and you’ll see all of your JavaScript
source (you’ll only see JavaScript and sometimes JSON files if you’ve
required them somewhere).  From here, you can click any file to see its
source, and set breakpoints:</p>

<figure><div class="figure">
<img src="Images/bwne_2002.png" alt="Using Chrome Debugger" width="1440" height="1081"/>
<h6/>
</div></figure>

<p>Unlike our previous experience with the command-line debugger, your application is already running: all of the middleware has been linked in, and the app is listening.  So how do we step through our code?  <a data-type="indexterm" data-primary="breakpoints" id="idm45053572689640"/>The easiest way (and the method you’ll probably use the most often) is to set a <em>breakpoint</em>.  This just tells the debugger to stop execution on a specific line so you can step through the code.</p>

<p>All you have to do to set a breakpoint is to open a source file from the “file://” browser in the debugger, and click the line number (in the left column); a little blue arrow will appear, indicating there’s a breakpoint on that line (click again to turn it off).  Go ahead and set a breakpoint inside one of your route handlers.  Then, in another browser window, visit that route.  If you’re using Chrome, the browser will automatically switch to the debugger window, while the original browser just spins (because the server has been paused and isn’t responding to the request).</p>

<p>In the debugger window, you can step through the program in a much more visual manner than we did with the command-line debugger.  You’ll see that the line you set a breakpoint on is highlighted in blue.  That means that’s the current execution line (which is actually the next line that will execute).  From here, you have access to the same commands as we did in the command-line debugger.  Similar to the command-line debugger, we have the following actions available to us:</p>
<dl>
<dt>Resume script execution (F8)</dt>
<dd>
<p>This will simply “let it fly”; you will no longer be stepping through the code, unless you stop on another breakpoint.  You usually use this when you’ve seen what you need to see, or you want to skip ahead to another breakpoint.</p>
</dd>
<dt>Step over next function call (F10)</dt>
<dd>
<p>If the current line invokes a function, the debugger will not descend into that function.  That is, the function will be executed, and the debugger will advance to the next line after the function invocation.  You’ll use this when you’re on a function call that you’re not interested in the details of.</p>
</dd>
<dt>Step into next function call (F11)</dt>
<dd>
<p>This will descend into the function call, hiding nothing from you.  If this is the only action you ever used, you would eventually see everything that gets executed—which sounds fun at first, but after you’ve been at it for an hour, you’ll have a newfound respect for what Node and Express are doing for you!</p>
</dd>
<dt>Step out of current function (Shift-F11)</dt>
<dd>
<p>Will execute the rest of the function you’re currently in and resume debugging on the next line of the <em>caller</em> of this function.  Most commonly, you’ll use this when you either accidentally step into a function or have seen as much as you need of the function.</p>
</dd>
</dl>

<p>In addition to all of the control actions, you have access to a console: that console is executing in the <em>current context of your application</em>.  So you can inspect variables and even change them, or invoke functions.  This can be incredibly handy for trying out really simple things, but it can quickly get confusing, so I don’t encourage you to dynamically modify your running application too much in this manner; it’s too easy to <span class="keep-together">get lost.</span></p>

<p>On the right, you have some useful data.  <a data-type="indexterm" data-primary="watch expressions" id="idm45053572676648"/>Starting at the top are <em>watch expressions</em>; these are JavaScript expressions you can define that will be updated in real time as you step through the application.  For example, if there was a specific variable you wanted to keep track of, you could enter it here.</p>

<p><a data-type="indexterm" data-primary="call stack" id="idm45053572674856"/>Below watch expressions is the <em>call stack</em>; this shows you how you got where you are.  That is, the function you’re in was called by some function, and that function was called by some function; the call stack lists all of those functions.  In the highly asynchronous world of Node, the call stack can be very difficult to unravel and understand, especially when anonymous functions are involved.  The topmost entry in that list is where you are now.  The one right below it is the function that called the function that you’re in now, and so on.  If you click any entry in this list, you will be magically transported to that context: all of your watches and your console context will now be in that context.</p>

<p><a data-type="indexterm" data-primary="scope variables" id="idm45053572672616"/>Below the call stack are the scope variables.  As the name implies, these are the variables that are currently in scope (which includes variables in the parent scope that are visible to us).  This section can often provide you a lot of information about the key variables you’re interested in at a glance.  If you have a lot of variables, this list will become unwieldy, and you might be better off defining just the variables you’re interested in as watch expressions.</p>

<p>Next, there is a list of all breakpoints, which is really just bookkeeping: it’s handy to have if you’re debugging a hairy problem and you have a lot of breakpoints set.  Clicking one will take you directly there (but it won’t change the context, like clicking something in the call stack; this makes sense because not every breakpoint will represent an active context, whereas everything in the call stack does).</p>

<p>Sometimes, what you need to debug is your application setup (when you’re linking middleware into Express, for example).  Running the debugger as we have been, that will all happen in the blink of an eye before we can even set a breakpoint.  Fortunately, there’s a way around that.  All we have to do is specify <code>--inspect-brk</code> instead of simply <code>--inspect</code>:</p>

<pre data-type="programlisting">node --inspect-brk meadowlark.js</pre>

<p>The debugger will break on the very first line of your application, and then you can step through or set breakpoints as you see fit.</p>

<p>Chrome isn’t your only option for an inspect client.  <a data-type="indexterm" data-primary="Visual Studio Code" id="idm45053572667112"/>In particular, if you use Visual Studio Code, its built-in debugger works very well.  Instead of starting your application with the <code>--inspect</code> or <code>--inspect-brk</code> options, click the Debug icon in the Visual Studio Code side menu (a bug with a line through it).  At the top of the sidebar, you’ll see a little gear icon; click that, and that will open some debugging configuration settings.  The only setting you need to worry about is “program”; make sure it’s pointing to your entry point (<em>meadowlark.js</em>, for example).</p>
<div data-type="tip"><h6>Tip</h6>
<p><a data-type="indexterm" data-primary="current working directory (cwd)" id="idm45053572663624"/>You may have to also set the current working directory, or <code>"cwd"</code>.  For example, if you’ve opened Visual Studio Code in a parent directory of where <em>meadowlark.js</em> lives, you may need to set <code>"cwd"</code> (which is the same as having to <code>cd</code> into the right directory before running <code>node meadowlark.js</code>.</p>
</div>

<p>Once you’re all set up, just click the green Play arrow in the debug bar, and your debugger is running.  The interface is slightly different from Chrome’s, but if you’re using Visual Studio Code, you will probably feel right at home.  For more information, see <a href="http://bit.ly/2pb7JBV">Debugging in Visual Studio Code</a>.<a data-type="indexterm" data-startref="ix_ch-20-debugging-asciidoc3" id="idm45053572658968"/><a data-type="indexterm" data-startref="ix_ch-20-debugging-asciidoc2" id="idm45053572658200"/><a data-type="indexterm" data-startref="ix_ch-20-debugging-asciidoc1" id="idm45053572657512"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Debugging Asynchronous Functions"><div class="sect1" id="idm45053572470888">
<h1>Debugging Asynchronous Functions</h1>

<p><a data-type="indexterm" data-primary="asynchronous functions, debugging" id="idm45053572655800"/><a data-type="indexterm" data-primary="debugging" data-secondary="asynchronous functions" id="idm45053572655080"/>One of the most common frustrations people have when being exposed to asynchronous programming for the first time is in debugging.  Consider the following code, for <span class="keep-together">example:</span></p>

<pre data-type="programlisting" data-code-language="js"><code class="mi">1</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Baa, baa, black sheep,'</code><code class="p">);</code>
<code class="mi">2</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s1">'yes_sir_yes_sir.txt'</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
<code class="mi">3</code>	  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Have you any wool?'</code><code class="p">);</code>
<code class="mi">4</code>	  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code>
<code class="mi">5</code> <code class="p">})</code>
<code class="mi">6</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Three bags full.'</code><code class="p">)</code></pre>

<p>If you’re new to asynchronous programming, you might expect to see the following:</p>

<pre data-type="programlisting">Baa, baa, black sheep,
Have you any wool?
Yes, sir, yes, sir,
Three bags full.</pre>

<p>But you won’t; instead you’ll see this:</p>

<pre data-type="programlisting">Baa, baa, black sheep,
Three bags full.
Have you any wool?
Yes, sir, yes, sir,</pre>

<p>If you’re confused about this, debugging probably won’t help. You’ll start on line 1, then step over it, which puts you on line 2.  You then step in, expecting to enter the function, ending up on line 3, but you actually end up on line 5!  That’s because <code>fs.readFile</code> executes the function only <em>when it’s done reading the file</em>, which won’t happen until your application is idle.  So you step over line 5, and you land on line 6…you then keep trying to step, but never get to line 3 (you eventually will, but it could take a while).</p>

<p>If you want to debug lines 3 or 4, all you have to do is set a breakpoint on line 3, and then let the debugger run.  When the file is read and the function is invoked, you’ll break on that line, and hopefully all will be clear.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Debugging Express"><div class="sect1" id="idm45053572606776">
<h1>Debugging Express</h1>

<p><a data-type="indexterm" data-primary="debugging" data-secondary="Express" id="ix_ch-20-debugging-asciidoc4"/><a data-type="indexterm" data-primary="Express" data-secondary="debugging" id="ix_ch-20-debugging-asciidoc5"/>If, like me, you’ve seen a lot of overengineered frameworks in your career, the idea of stepping through the framework source code might sound like madness (or torture) to you.  And exploring the Express source code is not child’s play, but it <em>is</em> well within the grasp of anyone with a good understanding of JavaScript and Node.  And sometimes, when you are having problems with your code, debugging those problems can best be solved by stepping through the Express source code itself (or third-party middleware).</p>

<p>This section will be a brief tour of the Express source code so that you can be more effective in debugging your Express applications.  For each part of the tour, I will give you the filename with respect to the Express root (which you can find in your <em>node_modules/express</em> directory), and the name of the function.  I’m not using line numbers, because of course they may differ depending on what exact version of Express you’re using:</p>
<dl>
<dt>Express app creation (<em>lib/express.js</em>, <code>function createApplication</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="createApplication() function (Express source code)" id="idm45053572408936"/><a data-type="indexterm" data-primary="lib/express.js (Express source code)" id="idm45053572408200"/>This is where your Express app begins its life.  This is the function that’s being invoked when you call <code>const app = express()</code> in your code.</p>
</dd>
<dt>Express app initialization (<em>lib/application.js</em>, <code>app.defaultConfiguration</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="app.defaultConfiguration (Express source code)" id="idm45053572404776"/><a data-type="indexterm" data-primary="lib/application.js (Express source code)" id="idm45053572404040"/>This is where Express gets initialized: it’s a good place to see all the defaults Express starts out with.  It’s rarely necessary to set a breakpoint here, but it is useful to step through it at least once to get a feel for the default Express settings.</p>
</dd>
<dt>Add middleware (<em>lib/application.js</em>, <code>app.use</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="app.use() method" id="idm45053572400888"/>Every time Express links middleware in (whether you do it explicitly, or it’s explicitly done by Express or any third parties), this function gets called.  It’s deceptively simple, but really understanding it takes some effort.  It’s sometimes useful to put a breakpoint in here (you’ll want to use <code>--debug-brk</code> when you run your app; otherwise, all the middleware will be added before you can set a breakpoint), but it can be overwhelming: you’ll be surprised at how much middleware is linked in in a typical application.</p>
</dd>
<dt>Render view (<em>lib/application.js</em>, <code>app.render</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="app.render() method" id="idm45053572397048"/>This is another pretty meaty function, but a useful one if you need to debug tricky view-related issues.  If you step through this function, you’ll see how the view engine is selected and invoked.</p>
</dd>
<dt>Request extensions (<em>lib/request.js</em>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="lib/request.js (Express source code)" id="idm45053572394408"/>You will probably be surprised at how sparse and easy to understand this file is.  Most of the methods Express adds to the request objects are very simple convenience functions.  It’s rarely necessary to step through this code or set breakpoints because of the simplicity of the code.  It is, however, often helpful to look at this code to understand how some of the Express convenience methods work.</p>
</dd>
<dt>Send response (<em>lib/response.js</em>, <code>res.send</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="lib/response.js (Express source code)" id="idm45053572391048"/><a data-type="indexterm" data-primary="res.send()" id="idm45053572390184"/>It almost doesn’t matter how you construct a response—<code>.send</code>, <code>.render</code>, <code>.json</code>, or <code>.jsonp</code>—it will eventually get to this function (the exception is <code>.sendFile</code>).  So this is a handy place to set a breakpoint, because it should be called for every response.  You can then use the call stack to see how you got there, which can be helpful in figuring out where there might be a problem.</p>
</dd>
<dt>Response extensions (<em>lib/response.js</em>)</dt>
<dd>
<p>While there is some meat in <code>res.send</code>, most of the other methods in the response object are pretty straightforward.  It’s occasionally useful to put breakpoints in these functions to see exactly how your app is responding to the request.</p>
</dd>
<dt>Static middleware (<em>node_modules/serve-static/index.js</em>, <code>function staticMiddleware</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="node_modules/serve-static/index.js (Express source code)" id="idm45053572382664"/><a data-type="indexterm" data-primary="static middleware" id="idm45053572381992"/><a data-type="indexterm" data-primary="staticMiddleware() function" id="idm45053572381320"/>Generally, if static files aren’t being served as you expect, the problem is with your routing, not with the static middleware: routing takes precedence over the static middleware.  So if you have a file <em>public/test.jpg</em>, and a route <em>/test.jpg</em>, the static middleware will never even get called in deference to the route.  However, if you need specifics about how headers are set differently for static files, it can be useful to step through the static middleware.</p>
</dd>
</dl>

<p>If you’re scratching your head wondering where all the middleware is, that’s because there is very little middleware in Express (the static middleware and the router being the notable exceptions).</p>

<p>Just as it’s helpful to dive into the Express source code when you’re trying to unravel a difficult problem, you may have to look into the source code of your middleware.  There’s really too much to go through, but there are three I want to mention as being pretty fundamental to understanding what’s going on in an Express application:</p>
<dl>
<dt>Session middleware (<em>node_modules/express-session/index.js</em>, <code>function session</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="modules/express-session/index.js (middleware source code)" id="idm45053572352184"/><a data-type="indexterm" data-primary="session middleware" id="idm45053572351512"/>A lot goes into making sessions work, but the code is pretty straightforward.  You may want to set a breakpoint in this function if you’re having issues that are related to sessions.  Keep in mind that it is up to you to provide the storage engine for the session middleware.</p>
</dd>
<dt>Logger middleware (<em>node_modules/morgan/index.js</em>, <code>function logger</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="logger middleware source" id="idm45053572348408"/><a data-type="indexterm" data-primary="modules/morgan/index.js" id="idm45053572347688"/>The logger middleware is really there for you as a debugging aid, not to be debugged itself.  However, there’s some subtlety to the way logging works that you’ll get only by stepping through the logger middleware once or twice.  The first time I did it, I had a lot of “aha” moments, and found myself using logging more effectively in my applications, so I recommend taking a tour of this middleware at least once.</p>
</dd>
<dt>URL-encoded body parsing (<em>node_modules/body-parser/lib/types/urlencoded.js</em>, <code>function</code> <code class="keep-together">urlencoded</code>)</dt>
<dd>
<p><a data-type="indexterm" data-primary="body-parser middleware" id="idm45053572343752"/><a data-type="indexterm" data-primary="node_modules/body-parser/lib/types/urlencoded.js" id="idm45053572343048"/><a data-type="indexterm" data-primary="request body" data-secondary="middleware code" id="idm45053572342280"/>The manner in which request bodies are parsed is often a mystery to people.  It’s not really that complicated, and stepping through this middleware will help you understand the way HTTP requests work.  Aside from a learning experience, you won’t find that you need to step into this middleware for debugging very often.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45053572340616">
<h1>Conclusion</h1>

<p>We’ve discussed a <em>lot</em> of middleware in this book.  I can’t reasonably list every landmark you might want to look at on your tour of Express internals, but hopefully these highlights take away some of the mystery of Express, and embolden you to explore the framework source code whenever needed.  Middleware varies greatly not just in quality but in accessibility: some middleware is wickedly difficult to understand, while some is as clear as a pool of water.  Whatever the case, don’t be afraid to look: if it’s too complicated, you can move on (unless you really need to understand it, of course), and if not, you might learn something<a data-type="indexterm" data-startref="ix_ch-20-debugging-asciidoc5" id="idm45053572338264"/><a data-type="indexterm" data-startref="ix_ch-20-debugging-asciidoc4" id="idm45053572337544"/>.<a data-type="indexterm" data-startref="ix_ch-20-debugging-asciidoc0" id="idm45053572336728"/></p>
</div></section>







</div></section></div>



  </body></html>