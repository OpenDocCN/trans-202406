- en: 'Chapter 2\. TypeScript: A 10_000 Foot View'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the next few chapters, I’ll introduce the TypeScript language, give you
    an overview of how the TypeScript Compiler (TSC) works, and take you on a tour
    of TypeScript’s features and the patterns you can develop with them. We’ll start
    with the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on what programming languages you worked with in the past (that is,
    before you decided to buy this book and commit to a life of type safety), you’ll
    have a different understanding of how programs work. The way TypeScript works
    is unusual compared to other mainstream languages like JavaScript or Java, so
    it’s important that we’re on the same page before we go any further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start broad: programs are files that contain a bunch of text written
    by you, the programmer. That text is parsed by a special program called a *compiler*,
    which transforms it into an *abstract syntax tree (AST)*, a data structure that
    ignores things like whitespace, comments, and where you stand on the tabs versus
    spaces debate. The compiler then converts that AST to a lower-level representation
    called *bytecode*. You can feed that bytecode into another program called a *runtime*
    to evaluate it and get a result. So when you run a program, what you’re really
    doing is telling the runtime to evaluate the bytecode generated by the compiler
    from the AST parsed from your source code. The details vary, but for most languages
    this is an accurate high-level view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Program is parsed into an AST.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AST is compiled to bytecode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bytecode is evaluated by the runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where TypeScript is special is that instead of compiling straight to bytecode,
    TypeScript compiles to… JavaScript code! You then run that JavaScript code like
    you normally would—in your browser, or with NodeJS, or by hand with a paper and
    pen (for anyone reading this after the machine uprising has begun).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point you may be thinking: “Wait! In the last chapter you said TypeScript
    makes my code safer! When does that happen?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great question. I actually skipped over a crucial step: after the TypeScript
    Compiler generates an AST for your program—but before it emits code—it *typechecks*
    your code.'
  prefs: []
  type: TYPE_NORMAL
- en: This typechecking is the magic behind TypeScript. It’s how TypeScript makes
    sure that your program works as you expect, that there aren’t obvious mistakes,
    and that the cute barista across the street really will call you back when they
    said they would. (Don’t worry, they’re probably just busy.)
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we include typechecking and JavaScript emission, the process of compiling
    TypeScript now looks roughly like [Figure 2-1](#ch02-compilation-pipeline):'
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0201](assets/prts_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Compiling and running TypeScript
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Steps 1–3 are done by TSC, and steps 4–6 are done by the JavaScript runtime
    that lives in your browser, NodeJS, or whatever JavaScript engine you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JavaScript compilers and runtimes tend to be smushed into a single program called
    an *engine*; as a programmer, this is what you’ll normally interact with. It’s
    how V8 (the engine powering NodeJS, Chrome, and Opera), SpiderMonkey (Firefox),
    JSCore (Safari), and Chakra (Edge) work, and it’s what gives JavaScript the appearance
    of being an *interpreted* language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this process, steps 1–2 use your program’s types; step 3 does not. That’s
    worth reiterating: *when TSC compiles your code from TypeScript to JavaScript,
    it won’t look at your types*. That means your program’s types will never affect
    your program’s generated output, and are only used for typechecking. This feature
    makes it foolproof to play around with, update, and improve your program’s types,
    without risking breaking your application.'
  prefs: []
  type: TYPE_NORMAL
- en: The Type System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern languages have all sorts of different *type systems*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are generally two kinds of type systems: type systems in which you have
    to tell the compiler what type everything is with explicit syntax, and type systems
    that infer the types of things for you automatically. Both approaches have trade-offs.^([1](ch02.html#idm46304995709880))'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is inspired by both kinds of type systems: you can explicitly annotate
    your types, or you can let TypeScript infer most of them for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explicitly signal to TypeScript what your types are, use annotations. Annotations
    take the form *value: type* and tell the typechecker, “Hey! You see this *value*
    here? Its type is *type*.” Let’s look at a few examples (the comments following
    each line are the actual types inferred by TypeScript):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you want TypeScript to infer your types for you, just leave them off
    and let TypeScript get to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Right away, you’ll notice how good TypeScript is at inferring types for you.
    If you leave off the annotations, the types are the same! Throughout this book,
    we will use annotations only when necessary, and let TypeScript work its inference
    magic for us whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In general, it is good style to let TypeScript infer as many types as it can
    for you, keeping explicitly typed code to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript Versus JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a deeper look at TypeScript’s type system, and how it compares to
    JavaScript’s type system. [Table 2-1](#comparing-type-systems) presents an overview.
    A good understanding of the differences is key to building a mental model of how
    TypeScript works.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Comparing JavaScript’s and TypeScript’s type systems
  prefs: []
  type: TYPE_NORMAL
- en: '| Type system feature | JavaScript | TypeScript |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **How are types bound?** | Dynamically | Statically |'
  prefs: []
  type: TYPE_TB
- en: '| **Are types automatically converted?** | Yes | No (mostly) |'
  prefs: []
  type: TYPE_TB
- en: '| **When are types checked?** | At runtime | At compile time |'
  prefs: []
  type: TYPE_TB
- en: '| **When are errors surfaced?** | At runtime (mostly) | At compile time (mostly)
    |'
  prefs: []
  type: TYPE_TB
- en: How are types bound?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dynamic type binding means that JavaScript needs to actually run your program
    to know the types of things in it. JavaScript doesn’t know your types before running
    your program.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is a *gradually typed* language. That means that TypeScript works
    best when it knows the types of everything in your program at compile time, but
    it doesn’t have to know every type in order to compile your program. Even in an
    untyped program TypeScript can infer some types for you and catch some mistakes,
    but without knowing the types for everything, it will let a lot of mistakes slip
    through to your users.
  prefs: []
  type: TYPE_NORMAL
- en: This gradual typing is really useful for migrating legacy codebases from untyped
    JavaScript to typed TypeScript (more on that in [“Gradually Migrating from JavaScript
    to TypeScript”](ch11.html#migrating-to-typescript)), but unless you’re in the
    middle of migrating your codebase, you should aim for 100% type coverage. That
    is the approach this book takes, except where explicitly noted.
  prefs: []
  type: TYPE_NORMAL
- en: Are types automatically converted?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript is weakly typed, meaning if you do something invalid like add a
    number and an array (like we did in [Chapter 1](ch01.html#intro)), it will apply
    a bunch of rules to figure out what you really meant so it can do the best it
    can with what you gave it. Let’s walk through the specific example of how JavaScript
    evaluates `3 + [1]`:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript notices that `3` is a number and `[1]` is an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we’re using `+`, it assumes we want to concatenate the two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It implicitly converts `3` to a string, yielding `"3"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It implicitly converts `[1]` to a string, yielding `"1"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It concatenates the results, yielding `"31"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We could do this more explicitly too (so JavaScript avoids doing steps 1, 3,
    and 4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While JavaScript tries to be helpful by doing clever type conversions for you,
    TypeScript complains as soon as you do something invalid. When you run that same
    JavaScript code through TSC, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do something that doesn’t seem right, TypeScript complains, and if you’re
    explicit about your intentions, TypeScript gets out of your way. This behavior
    makes sense: who in their right mind would try to add a number and an array, expecting
    the result to be a string (of course, besides Bavmorda the JavaScript witch who
    spends her time coding by candlelight in your startup’s basement)?'
  prefs: []
  type: TYPE_NORMAL
- en: The kind of implicit conversion that JavaScript does can be a really hard-to-track-down
    source of errors, and is the bane of many JavaScript programmers. It makes it
    hard for individual engineers to get their jobs done, and it makes it even harder
    to scale code across a large team, since every engineer needs to understand the
    implicit assumptions your code makes.
  prefs: []
  type: TYPE_NORMAL
- en: In short, if you must convert types, do it explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: When are types checked?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most places JavaScript doesn’t care what types you give it, and it instead
    tries to do its best to convert what you gave it to what it expects.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript, on the other hand, typechecks your code at compile time (remember
    step 2 in the list at the beginning of this chapter?), so you don’t need to actually
    run your code to see the `Error` from the previous example. TypeScript *statically
    analyzes* your code for errors like these, and shows them to you before you run
    it. If your code doesn’t compile, that’s a really good sign that you made a mistake
    and you should fix it before you try to run the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-2](#ch02-ide-error) shows what happens when I type the last code
    example into VSCode (my code editor of choice).'
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0202](assets/prts_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. TypeError reported by VSCode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With a good TypeScript extension for your preferred code editor, the error will
    show up as a red squiggly line under your code *as you type it*. This dramatically
    speeds up the feedback loop between writing code, realizing that you made a mistake,
    and updating the code to fix that mistake.
  prefs: []
  type: TYPE_NORMAL
- en: When are errors surfaced?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When JavaScript throws exceptions or performs implicit type conversions, it
    does so at runtime.^([2](ch02.html#idm46304990806104)) This means you have to
    actually run your program to get a useful signal back that you did something invalid.
    In the best case, that means as part of a unit test; in the worst case, it means
    an angry email from a user.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript throws both syntax-related errors and type-related errors at compile
    time. In practice, that means those kinds of errors will show up in your code
    editor, right as you type—it’s an amazing experience if you’ve never worked with
    an incrementally compiled statically typed language before.^([3](ch02.html#idm46304990802632))
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are lots of errors that TypeScript can’t catch for you at compile
    time—things like stack overflows, broken network connections, and malformed user
    inputs—that will still result in runtime exceptions. What TypeScript does is make
    compile-time errors out of most errors that would have otherwise been runtime
    errors in a pure JavaScript world.
  prefs: []
  type: TYPE_NORMAL
- en: Code Editor Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have some intuition for how the TypeScript Compiler and type system
    work, let’s get your code editor set up so we can start diving into some real
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Start by downloading a code editor to write your code in. I like VSCode because
    it provides a particularly nice TypeScript editing experience, but you can also
    use Sublime Text, Atom, Vim, WebStorm, or whatever editor you like. Engineers
    tend to be really picky about IDEs, so I’ll leave it to you to decide. If you
    do want to use VSCode, follow the instructions on the [website](https://code.visualstudio.com/)
    to get it set up.
  prefs: []
  type: TYPE_NORMAL
- en: TSC is itself a command-line application written in TypeScript,^([4](ch02.html#idm46304990765000))
    which means you need NodeJS to run it. Follow the instructions on the official
    NodeJS [website](https://nodejs.org) to get NodeJS up and running on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'NodeJS comes with NPM, a package manager that you will use to manage your project’s
    dependencies and orchestrate your build. We’ll start by using it to install TSC
    and TSLint (a linter for TypeScript). Start by opening your terminal and creating
    a new folder, then initializing a new NPM project in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: tsconfig.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every TypeScript project should include a file called *tsconfig.json* in its
    root directory. This *tsconfig.json* is where TypeScript projects define things
    like which files should be compiled, which directory to compile them to, and which
    version of JavaScript to emit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called *tsconfig.json* in your root folder (`touch tsconfig.json`),^([5](ch02.html#idm46304990750392))
    then pop it open in your code editor and give it the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s briefly go over some of those options and what they mean ([Table 2-2](#tsconfig-json-table)):'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. *tsconfig.json* options
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `include` | Which folders should TSC look in to find your TypeScript files?
    |'
  prefs: []
  type: TYPE_TB
- en: '| `lib` | Which APIs should TSC assume exist in the environment you’ll be running
    your code in? This includes things like ES5’s `Function.prototype.bind`, ES2015’s
    `Object.assign`, and the DOM’s `document.querySelector`. |'
  prefs: []
  type: TYPE_TB
- en: '| `module` | Which module system should TSC compile your code to (CommonJS,
    SystemJS, ES2015, etc.)? |'
  prefs: []
  type: TYPE_TB
- en: '| `outDir` | Which folder should TSC put your generated JavaScript code in?
    |'
  prefs: []
  type: TYPE_TB
- en: '| `strict` | Be as strict as possible when checking for invalid code. This
    option enforces that all of your code is properly typed. We’ll be using it for
    all of the examples in the book, and you should use it for your TypeScript project
    too. |'
  prefs: []
  type: TYPE_TB
- en: '| `target` | Which JavaScript version should TSC compile your code to (ES3,
    ES5, ES2015, ES2016, etc.)? |'
  prefs: []
  type: TYPE_TB
- en: These are just a few of the available options—*tsconfig.json* supports dozens
    of options, and new ones are added all the time. You won’t find yourself changing
    these much in practice, besides dialing in the `module` and `target` settings
    when switching to a new module bundler, adding `"dom"` to `lib` when writing TypeScript
    for the browser (you’ll learn more about this in [Chapter 12](ch12.html#typescript-in-production)),
    or adjusting your level of `strict`ness when migrating your existing JavaScript
    code to TypeScript (see [“Gradually Migrating from JavaScript to TypeScript”](ch11.html#migrating-to-typescript)).
    For a complete and up-to-date list of supported options, head over to the official
    documentation on the [TypeScript website](http://bit.ly/2JWfsgY).
  prefs: []
  type: TYPE_NORMAL
- en: Note that while using a *tsconfig.json* file to configure TSC is handy because
    it lets us check that configuration into source control, you can set most of TSC’s
    options from the command line too. Run `./node_modules/.bin/tsc --help` for a
    list of available command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: tslint.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your project should also have a *tslint.json* file containing your TSLint configuration,
    codifying whatever stylistic conventions you want for your code (tabs versus spaces,
    etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using TSLint is optional, but it’s strongly recommend for all TypeScript projects
    to enforce a consistent coding style. Most importantly, it will save you from
    arguing over code style with coworkers during code reviews.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will generate a *tslint.json* file with a default TSLint
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add overrides to this to conform with your own coding style. For
    example, my *tslint.json* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For the full list of available rules, head over to the [TSLint documentation](https://palantir.github.io/tslint/rules/).
    You can also add custom rules, or install extra presets (like for [ReactJS](https://www.npmjs.com/package/tslint-react)).
  prefs: []
  type: TYPE_NORMAL
- en: index.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’ve set up your *tsconfig.json* and *tslint.json*, create a *src*
    folder containing your first TypeScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Your project’s folder structure should now look this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Pop open *src/index.ts* in your code editor, and enter the following TypeScript
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, compile and run your TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’ve followed all the steps here, your code should run and you should
    see a single log in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That’s it—you just set up and ran your first TypeScript project from scratch.
    Nice work!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since this might have been your first time setting up a TypeScript project
    from scratch, I wanted to walk through each step so you have a sense for all the
    moving pieces. There are a couple of shortcuts you can take to do this faster
    next time:'
  prefs: []
  type: TYPE_NORMAL
- en: Install [`ts-node`](https://npmjs.org/package/ts-node), and use it to compile
    and run your TypeScript with a single command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a scaffolding tool like [`typescript-node-starter`](https://github.com/Microsoft/TypeScript-Node-Starter)
    to quickly generate your folder structure for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that your environment is set up, open up *src/index.ts* in your code editor.
    Enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now hover over `a`, `b`, `c`, and `d`, and notice how TypeScript infers the
    types of all your variables for you: `a` is a `number`, `b` is a `number`, `c`
    is an object with a specific shape, and `d` is also a `number` ([Figure 2-3](#ch02-ide-example)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![prts 0203](assets/prts_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. TypeScript inferring types for you
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Play around with your code a bit. See if you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Get TypeScript to show a red squiggly when you do something invalid (we call
    this “throwing a `TypeError`“).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read the `TypeError`, and try to understand what it means.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix the `TypeError` and see the red squiggly disappear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ambitious, try to write a piece of code that TypeScript is unable
    to infer the type for.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch02.html#idm46304995709880-marker)) There are languages all over this
    spectrum: JavaScript, Python, and Ruby infer types at runtime; Haskell and OCaml
    infer and check missing types at compile time; Scala and TypeScript require some
    explicit types and infer and check the rest at compile time; and Java and C need
    explicit annotations for almost everything, which they check at compile time.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm46304990806104-marker)) To be sure, JavaScript surfaces syntax
    errors and a few select bugs (like multiple `const` declarations with the same
    name in the same scope) after it parses your program, but before it runs it. If
    you parse your JavaScript as part of your build process (e.g., with Babel), you
    can surface these errors at build time.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#idm46304990802632-marker)) Incrementally compiled languages
    can be quickly recompiled when you make a small change, rather than having to
    recompile your whole program (including the parts you didn’t touch).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#idm46304990765000-marker)) This puts TSC in the mystical class
    of compilers known as *self-hosting compilers*, or compilers that compile themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch02.html#idm46304990750392-marker)) For this exercise, we’re creating
    a *tsconfig.json* manually. When you set up TypeScript projects in the future,
    you can use TSC’s built-in initialize command to generate one for you: `./node_modules/.bin/tsc
    --init`.'
  prefs: []
  type: TYPE_NORMAL
