- en: Chapter 8\. The Finished App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the components of the new app are done and testable in the discovery tool
    (*http://localhost:3000/discovery*). Now it’s time to put them all together into
    a working application (available in the browser as *http://localhost:3000/*).
    [Figure 8-1](#FIG0801) shows the desired result when the user loads the app for
    the first time. There is a single row of default data coming from schema’s samples
    to demonstrate the purpose of the app to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0801](Images/rur2_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Loading the finished app for the first time
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 8-2](#FIG0802) shows the dialog that pops up when the user clicks the
    + ADD WHINE button.'
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0802](Images/rur2_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Adding a new record
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 8-3](#FIG0803) shows the state of the app after the user has added
    one more row.'
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0803](Images/rur2_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Two records in the table
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since you already have the header, body, the table component `Excel`, and the
    dialog component, the rendering is merely a question of assembling them, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then the main task is providing the correct props to these components and taking
    care of the data flow between them. Let’s create a component called `DataFlow`
    to take care of all this. `DataFlow` should have all the data and can pass it
    to `<Excel>` and to `<Header>` (which needs to know the number of records for
    the search field’s placeholder). When the user changes the data in the table,
    `Excel` notifies the parent `DataFlow` via the `onDataChange` prop. When the user
    adds a new record using the `Dialog` in `DataFlow`, then the updated data is passed
    to `Excel` thanks to the `onAction` callback. [Figure 8-4](#FIG0804) shows this
    flow of data as a diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0804](Images/rur2_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. Flow of data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another bit of information to be passed around by `DataFlow` is the search (filter)
    string typed in the header’s search box. `DataFlow` takes it from the `Header`’s
    `onSearch` callback and passes it to `Excel` as the `filter` property, which is
    shown in [Figure 8-5](#FIG0805).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0805](Images/rur2_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. Passing the search (filter) string
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, `DataFlow` is also responsible for updating the `localStorage`, which
    should always have the latest data.
  prefs: []
  type: TYPE_NORMAL
- en: Updated App.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<App>` component needs a bit of an update. It imports the `schema`, then
    looks for data in `localStorage`. If there is none, it takes the first sample
    from the `schema` and uses it as initial data. Then it renders the new component-to-be
    `DataFlow` passing the data and the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: DataFlow Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the goals of the `<DataFlow>` component are clear and you see how it’s
    been used in the `<App>` component, let’s see how to go about implementing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall structure, as you’d expect, is about import/export and prop types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s see about these `TODO` comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is a just a one-liner that takes whatever is passed to it (the
    latest `data`, the whole point of the app) and writes it to `localStorage` to
    be used in the next session in case the user closes the browser tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the reducer. It’s responsible for only two types of events (actions):'
  prefs: []
  type: TYPE_NORMAL
- en: '`save`'
  prefs: []
  type: TYPE_NORMAL
- en: This will create a new record in `data` when the user clicks the + ADD WHINE
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '`excelchange`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This handles any data change coming from `Excel`. This action doesn’t modify
    the data, just commits it to storage and returns it as-is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Why is it necessary to clone the data before adding to it (via array’s `unshift()`)?
    It’s because the reducer is called twice in development (see [Chapter 7](ch07.xhtml#ch7))
    and the same record would be added twice otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With such a simple reducer, is it really a good idea to opt for a reducer as
    opposed to state when it comes to `data` management? Probably not. In fact, an
    alternative implementation using only state is available in the book’s code repo
    as *DataFlow1.js* and it’s a bit shorter in terms of lines of code. The potential
    benefit of using a reducer is that it’s simpler to expand on if future new actions
    are expected.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the body of the function that defines the `DataFlow` component.
  prefs: []
  type: TYPE_NORMAL
- en: DataFlow Body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly to how `Excel` manages its state, let’s try a combination of `useState()`
    and `useReducer()`. Let’s have a reducer for `data` since it’s potentially more
    involved and for everything else, stick with state. The `addNew` state is a toggle
    whether or not to show an Add dialog, and `filter` is for the string the user
    types in the search box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `form` ref is used similarly to `Excel` in [Chapter 7](ch07.xhtml#ch7) to
    harvest the data from the form shown in the Add dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s address the rendering `TODO`. Its task is to combine all the main
    components (`<Header>`, `<Excel>`, etc.) and pass around the `data` and callbacks.
    Conditionally, if the user clicks the Add button, a `<Dialog>` is constructed
    too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The other three `TODO` comments are about the inline helper function, none of
    which should look complicated at this point.
  prefs: []
  type: TYPE_NORMAL
- en: '`onSearch()` takes the search string from the header and updates the `filter`
    state, which (by way of rerendering) is passed to `Excel`, where it’s used to
    show only matching data records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`onExcelDataChange()` is another one-liner. It’s a callback that takes any
    data updates from `Excel` and dispatches an action to be handled by the reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `saveNew()` helper that handles dialog actions. It closes the dialog
    unconditionally (by setting the `addNew` state) and if the dialog wasn’t simply
    dismissed, it collects the form data from the dialog and dispatches the appropriate
    `save` action for the reducer to handle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Job Done
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And with that, the app is complete. You can build it, deploy it to a server
    near you, and make it available to the world.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the task was to create all necessary components ([Chapter 7](ch07.xhtml#ch7)),
    keeping them as small and general-purpose as possible and then making them all
    work together by rendering the top-level ones (`Header`, `Body`, `Excel`) and
    making sure the data flows between children and parents.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far you’ve learned about one way of passing data around using props and
    callbacks. This is a valid way but it can reach a point of becoming difficult
    to maintain for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Children can become deeply nested, resulting in long, clumsy chains of passing
    props and callbacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you pass several callbacks to a component (when a lot happens in this component),
    defining all these callbacks soon loses its elegance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Props and callbacks were the original way of communication between components
    in earlier React applications and it’s still a valid way for many cases. As React
    matured, developers started thinking of ways to fix the resulting complexity.
    One popular approach is using a more global storage of data and then providing
    an API for components to read and write the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example (from earlier ways of understanding how we build apps
    with React) of a deeply nested child using callback for communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with some sort of `Storage` module, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can agree that the second option looks much cleaner and more succinct.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, this idea of global storage was called *Flux* and a lot of implementations
    appeared in the open-source world. One of the implementations, a library called
    *Redux*, won a significant developer mind-share. A different implementation was
    part of the first edition of this book. Today, the same idea is part of React’s
    core, implemented as *context*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the Whinepad app can transition to its version 2 and move away
    from callbacks in favor of context.
  prefs: []
  type: TYPE_NORMAL
- en: Whinepad v2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with v2, you need a copy of the *whinepad* directory without the *node_​mod⁠ules/*
    directory (where all npm-downloaded dependencies are stored) and without the *package-lock.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These two are artifacts of installing your app, so when you distribute the app
    (e.g., sharing with others on GitHub or just putting it in source control) you
    don’t need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the *whinepad* (v1) and you’re ready for v2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the dependencies in the new location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the CRA for development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s rewrite the app so it uses contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to create a context. That’s best done in a separate module
    so it can be shared between components. And since chances are you may have more
    than one context, you can store them in a separate directory, sibling to */components*
    and */modules*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Not much is happening in *DataContext.js*, just a call to create the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `createContext()` accepts a default value. Its purpose is mostly
    for testing, documentation, and type safety. Let’s provide the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have any value stored in a context, but a common pattern is to have
    an object with two properties: a piece of data and a function that can update
    the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that a context is created, the next steps are to use the context where required
    in the components. The `data` is used in `Excel` and in `Header`, so these two
    components need an update. Also passing the data around was done in `DataFlow`
    and that’s where the most changes are to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, an update and simplification to *App.js* is in order. In v1, that’s
    where the initial (or default) data was being figured out and then passed as props
    to `<DataFlow>`. In v2, let’s have any and all data management happen in `<DataFlow>`.
    The updated *App.js* looks a little bare-bones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The job of `DataFlow` is to figure out the initial data when the app is loaded,
    update that data in the context, and make sure the children `<Excel>` and `<Header>`
    can get the data from the context. The children should also be able to update
    the data. That’s surprisingly uncomplicated as you’ll see shortly, but first,
    a word on how the data flow in v2 is going to be different than v1.
  prefs: []
  type: TYPE_NORMAL
- en: Circular Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In v1 (also see [Figure 8-4](#FIG0804)), `Excel` manages the `data` in its state.
    This is a great way to build standalone components that can be dropped anywhere
    in any app. But the parent `DataFlow` also keeps the data in its state because
    the data needs to be shared between `Header` and `Excel`. So there are two “sources
    of truth” that need to be synchronized. This was done by passing the `data` prop
    from `DataFlow` to `Excel` and by using the `onDataChange` callback to communicate
    from the child `Excel` to the parent `DataFlow`. That creates a circular flow
    of data, which may lead to an infinite rendering loop. The `data` changes in `Excel`,
    which means it’s rerendered. `DataFlow` receives the new data via `onDataChange`
    and updates its state, which means it’s rerendered, which causes a new render
    of `Excel` (it’s a child).
  prefs: []
  type: TYPE_NORMAL
- en: 'React prevents this by refusing to update state during a rendering phase. That’s
    why the `setTimeout` hack was required in `Excel` when invoking the `onDataChange`
    callback in the reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This works just fine. The timeout allows React to finish rendering before updating
    the state again. This hack is the price paid to have a completely standalone `Excel`
    that manages its own data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s change this in v2 and have a single source of truth (`data` in `DataFlow`).
    This avoids the hack but comes with the drawback that `Excel` now needs someone
    else to manage the data. That’s not difficult, but it is a change and it requires
    the test area `<Discovery>` to be a bit more involved.
  prefs: []
  type: TYPE_NORMAL
- en: Providing Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see how the context `DataContext` created by `React.createContext()` can
    be used. The heavy lifting enabling this happens in `DataFlow`, so let’s examine
    its v2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Requiring the context in *DataFlow.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Figuring out the initial state of the world, either from the storage or from
    `schema` samples, can happen at the top of the module, not even in the body of
    the `DataFlow` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` is kept in the state just like before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` is going to be a part of the context. The context also needs a function
    to update the data. This function is defined inline in `DataFlow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The three steps of updating the data are:'
  prefs: []
  type: TYPE_NORMAL
- en: Clone the data so it’s always immutable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save it to `localStorage` for the next time the app is loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Armed with `data` and `updateData`, the last step is to wrap any children (`Excel`
    and `Header`) that require the context in a *provider* component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The provider component `<DataContext.Provider>` is available thanks to the
    call to `createContext()`, which created the `DataContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The provider must set a `value` prop, which could be anything. Here the value
    is the common pattern: “data plus a way to change the data.”'
  prefs: []
  type: TYPE_NORMAL
- en: Now any child of `<DataContext.Provider>` such as `<Excel>` or `<Header>` can
    be a *consumer* of the context value set by the *provider*. The way to consume
    is either via a `<DataContext.Consumer>` component or via a `useContext()` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Before taking a look at consuming the context, the following is a complete listing
    of the new *DataFlow.js*. For the complete code of the v2 of Whinepad, consult
    the *whinepad2* directory in the book’s repo.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `filter` is still passed as a prop to `<Excel>`. Even though
    you’re using a context, prop passing is still an option. It could be the preferred
    approach for many scenarios when components need to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you consult the v1 of `DataFlow` from earlier in this chapter, you may notice
    that the `reducer()` is gone in v2\. The reducer’s job was to handle data changes
    from `Excel` and adding new records from the header. These tasks can now be performed
    in each responsible child. `Excel` can handle any changes and then update the
    context using the provided `updateData()`. And `Header` can handle adding new
    records and use the same function to update the data in the context. Let’s see
    how.
  prefs: []
  type: TYPE_NORMAL
- en: Context in the Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new header is going to be responsible for more of the UI, namely the `Form`
    in a `Dialog` to add new records, so the list of imports is a little longer. Note
    that the new `DataContext` is imported too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The pieces of data needed to render the header are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` coming from the context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addNew` flag whether or not the Add dialog is shown (when the user clicks
    the Add button)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `addNew` state is copied verbatim from v1 of `DataFlow`. The new code is
    the consumption of the `DataContext`. You can see how using the hook `useContext()`
    you get access to the `value` prop passed by the `<DataContext.Provider>`. It’s
    an object that has a `data` property and a function `updateData()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In v1 there was a `count` prop passed to the `<Header>`. Now the header can
    access all of the data and get the count from there (`data.length`). Now that
    all the pieces required for rendering are available, it’s time to work on the
    rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The main difference from the previous version is that now the `Dialog` and the
    `Form` it contains are implemented here in the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two things to take a look at are the helper functions `onAdd()` and
    `saveNew()`. The first one merely updates the `addNew` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The job of `saveNew()` is to gather the new record from the form and add it
    to `data`. Then comes the key moment: invoking `updateData()` with the updated
    `data`. This is the function that comes from the `<DataContext.Provider>` and
    was defined in `DataFlow` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What happens here is the parent `DataFlow` receives the new data and updates
    the state (with `setData()`), and this causes React to rerender. This means `Excel`
    and `Header` are going rerender but this time with the latest data. So the new
    record appears in the `Excel` table and the search box in the header has an accurate
    count of the records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the *Header.js* file in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Context in the Data Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last thing before v2 is fully operational is to update `Excel` so it doesn’t
    maintain its own state but uses the data from the `<DataContext.Provider>`. There
    are no rendering changes required, only the data management.
  prefs: []
  type: TYPE_NORMAL
- en: Since there’s no need for a `data` state in `Excel` anymore, the `reducer()`
    is no longer required. However, the idea of all data manipulation happening in
    a central place is too appealing not to adopt. So let’s just rename `reducer()`
    to `dataMangler()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the before state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is after the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `dataMangler()` doesn’t need to follow the reducer API, so
    the `action` can now be a string and the payload can be a separate argument to
    the function. This is just a little less typing and also hopefully avoids any
    confusion: `dataMangler()` is *not* a reducer, just a convenient helper function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete `dataMangler()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note the missing `setTimeout(() => action.payload.onDataChange(data)` at the
    end of the function. There’s no need for `onDataChange` prop anymore, nor for
    the `setTimeout` hack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a reducer, returning `data` was enough to cause a rerendering of
    `Excel`. Now you need the `updateData()` from the provider, so the parent `DataFlow`
    can be responsible for rerendering. Additionally, there are no more calls to `dispatch()`
    which magically call the reducer. All the `dispatch()` callsites now have two
    tasks: call the `dataMangler()` and then pass its return value to `updateData()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the updated version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Replace the 4 `dispatch()` callsites, and v2 of Whinepad is complete and operational.
    For a full code listing, consult the book’s code repo.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point the changes to `Excel` and `Header` have affected the discovery
    tool too. While not technically broken, it’s a little muddled. For example, the
    data table is empty and the search input doesn’t show a count. To use `Discovery`
    to its full potential, you need to set up the environment where `Excel` and `Header`
    live. Here, “environment” means a `<DataConsumer.Provider>` wrapper around the
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code before (inline example and sample data coming from the schema
    and passed as a prop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is after the transformation (into a whole new example component):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The example component gets the sample data from the `schema` too and uses it
    to maintain state. A simpler `updateData()` is created and passed as part of the
    context in the context provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `Excel` example is fully operational in the discovery tool. Without
    this update, when `Excel` tries to use the context, it gets the default `data`
    and `updateData()` as defined in `createContext()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Updating the `<Header>` example in `<Discovery>` can be simpler since you know
    that `Header` only worries about the `data.length` count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here it is before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And here it is for v2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Wrapping the `Header` in a provider now causes the `value` to be used in the
    context and not the defaults from `createContext()`. As a result, if you test
    the “Add” button in the header, you’ll get an error because `updateData()` doesn’t
    exist. To fix the error and make the button testable, a no-op `updateData()` is
    sufficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now you have a working v2 of Whinepad as well as a working discovery area for
    playing with the components individually.
  prefs: []
  type: TYPE_NORMAL
- en: Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to wrap up the chapter and the book by implementing one more feature—bookmarkable
    URLs—and along the way learn about multiple contexts and the `useCallback()` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Single-page applications (SPAs) such as Whinepad do not refresh the page, so
    the URLs to different states of the app don’t need to change. But it’s nice when
    they do, as this allows users to share links and have the app already in a certain
    state. For example, it’s friendlier to send your coworker a URL such as *https://whinepad.com/filter/merlot*
    rather than instructions like “Go to *https://whinepad.com/* and type *merlot*
    in the search box at the top.”
  prefs: []
  type: TYPE_NORMAL
- en: The ability of an app to recreate a state from a URL is often called *routing*
    and there are a number of third-party libraries that can offer you routing in
    one way or another. But let’s take a do-it-yourself approach one more time and
    come up with a custom solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s offer 4 types of bookmarkable URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/filter/merlot* to bookmark searches for “merlot”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/add* to have an open “Add” dialog for adding records'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/info/1* to show the info (non-editable) dialog for record with ID 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/edit/1* for an editable version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first URL is to be handled in `DataFlow` since this is where the filtering
    is passed around; the second in `Header`; and the last two in `Excel`. Since various
    components need to know the URL, a new context seems appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Route Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new context lives in *contexts/RouteContext.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Again you see a familiar pattern—the context consists of a piece of data (`route`)
    and a way to update it (`updateRoute`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the job of replacing the context defaults with working values falls
    to the parent component `DataFlow`. It requires the new context and attempts to
    read the routing information from the URL (`window.location.pathname`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if the app is loaded with the URL */filter/merlot*, then `route` becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If the app is loaded with the URL */edit/1*, `route` becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also up to `DataFlow` to define a function that updates the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the [`History` API](https://developer.mozilla.org/en-US/docs/Web/API/History),
    using `replaceState()` is an alternative to `pushState()` that doesn’t create
    history entries (for the use with the browser’s Back button). This is preferable
    in this case as the URL is going to be updated frequently and has the potential
    to pollute the history stack. For example, having six history entries (/filter/m,
    /filter/me, /filter/mer, etc.) as the user types “merlot” renders the Back button
    unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Filter URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to wrap any consumers of the new context in a provider component
    (`<RouteContext.Provider>` in this case). But for the purposes of the filtering,
    it’s not yet necessary, because all filtering happens in `DataFlow`.
  prefs: []
  type: TYPE_NORMAL
- en: To use the new routing functionality, only two changes are necessary. One is
    in the `onSearch` callback, which is invoked whenever the user types in the search
    box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now when the user types “m” in the search box, the URL changes to */filter/m*.
    When the user deletes the search string, the URL goes back to */*.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the URL is half the job. The other half is prefilling the search box
    *and* doing the searching when the app is loaded. Doing the searching means making
    sure the correct `filter` prop is passed to `Excel`. Luckily, this is trivial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is sufficient. Now, whenever `DataFlow` renders, it’s passing `<Excel filter=​{fil⁠ter}>`
    where the filter value comes from the `route`. And as a result, `Excel` shows
    only the matching rows. If there’s no filter in the `route` object then the `filter`
    prop is `null` and `Excel` shows everything.
  prefs: []
  type: TYPE_NORMAL
- en: To also prefill the search box (which is found in the `Header`), you need to
    wrap the header in a route context provider. This happens in the `DataFlow` rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it’s OK to have as many context provider wrappers as you need.
    They can be nested as you see above, or they can wrap different components, only
    where they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the Route Context in the Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Header` component can gain access to the route via the `RouteContext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note how passing `route.add` as a default to the `addNew` state makes the */add*
    URL work automatically. Setting `addNew` to `true` makes the rendering part of
    the component show a `Dialog`.
  prefs: []
  type: TYPE_NORMAL
- en: Making sure the search box has a prefilled value coming from the route is also
    a one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The other thing the header needs to do is update the routing context whenever
    a user makes an appropriate action. When the user clicks the “Add” button, the
    URL should change to */add*. This is done by calling the `updateRoute()` from
    the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And when the user dismisses the dialog (or submits the form and the dialog disappears),
    the */add* should be removed from the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Consuming the Route Context in the Data Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the routing context in `Excel` looks familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: A lot in this component happens in the `handleAction()` helper (see [Chapter 7](ch07.xhtml#ch7)).
    It’s responsible for opening and closing dialogs as well as for the content of
    the dialogs. This helper can be used for the purposes of routing as long as it’s
    invoked with the correct arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the help of `useEffect()`, this helper can be called when the data table
    renders and the result is opening a dialog whenever the URL is */edit/[ID]* or
    */info/[ID]*. The following code shows how to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Here `route`, `handleAction`, and `data` are the effect’s dependencies, so it’s
    not invoked too often. A quick check for `data.length` prevents opening the dialog
    with IDs that are out of range (e.g., you cannot edit ID 5 when only 3 records
    exist). Then `handleAction()` is invoked, for example `handleAction(2, 'info')`
    when the URL is */info/2*.
  prefs: []
  type: TYPE_NORMAL
- en: So `handleAction()` is responsible for reading the routing info and creating
    the correct dialog. But it’s also responsible for updating the URL on user actions.
    This part is simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closing the dialog before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening the dialog before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With that, the functionality is complete; there’s just one more step.
  prefs: []
  type: TYPE_NORMAL
- en: useCallback()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When setting up `useEffect`, `handleAction()` was passed as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: But since `handleAction()` is an inline function inside `Excel()`, this means
    every time `Excel()` is invoked to rerender, a new `handleAction()` is created.
    And `useEffect()` sees the updated dependency. This is not efficient. There’s
    no point in having a function dependency that changes every time even though the
    function does the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: React provides a `useCallback()` hook to help with just that. It *memoizes*
    a callback function with its dependencies. So if a new `handleAction()` is created
    on a rerender of `Excel`, but its dependencies have not changed, then there’s
    no need for `use​Ef⁠fect()` to see a new dependency. The old memoized `handleAction`
    should do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapping the `handleAction` with a `useCallback()` should look somewhat familiar
    to `useEffect()` where the pattern is: first argument is a function, the second
    is an array of dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependencies `data`, `updateData`, and `updateRoute` are the only external
    pieces of info that `handleAction` requires to work properly. So if these do not
    change between rerenders, an older memoized `handleAction` is sufficient. Here’s
    the complete and final version of `handleAction()` after all the routing changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The End
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m happy you got this far, dear reader. I hope you’re a more confident programmer
    now, someone who knows how to get a new React project off the ground or join an
    existing one and take it into the future.
  prefs: []
  type: TYPE_NORMAL
- en: A programming book is like a snapshot in time. Technologies change and evolve
    while the book remains the same. I did my best to focus on evergreen content and
    let the evolution take its place. But it is my goal to attempt to bring new additions
    to this book (in the form of PDF appendixes) before a new edition is due. If you’d
    like to keep up with the new content, please join the [mailing list](https://react.stoyanstefanov.com).
  prefs: []
  type: TYPE_NORMAL
