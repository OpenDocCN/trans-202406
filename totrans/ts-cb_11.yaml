- en: Chapter 10\. TypeScript and React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is arguably one of the most popular JavaScript libraries in recent years.
    Its simple approach to the composition of components has changed the way we write
    frontend (and, to an extent, backend) applications, allowing you to declaratively
    write UI code using a JavaScript syntax extension called JSX. Not only was this
    simple principle easy to pick up and understand, but it also influenced dozens
    of other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: JSX is undoubtedly a game changer in the JavaScript world, and with TypeScript’s
    goal to cater to all JavaScript developers, JSX found its way into TypeScript.
    In fact, TypeScript is a full-fledged JSX compiler. If you have no need for additional
    bundling or extra tooling, TypeScript is all you need to get your React app going.
    TypeScript is also immensely popular. At the time of writing, the React typings
    on NPM clocked 20 million downloads per week. The fantastic tooling with VS Code
    and the excellent types made TypeScript the first choice for React developers
    around the globe.
  prefs: []
  type: TYPE_NORMAL
- en: 'While TypeScript’s popularity among React developers continues unabated, one
    circumstance makes the use of TypeScript with React a bit difficult: TypeScript
    isn’t the React team’s first choice. While other JSX-based libraries are now mostly
    written *in* TypeScript and therefore provide excellent types out of the box,
    the React team works with their own static type-checker called [Flow](https://flow.org),
    which is similar to, but ultimately incompatible with, TypeScript. This means
    the React types millions of developers rely on are made subsequently by a group
    of community contributors and published on Definitely Typed. While `@types/react`
    are considered to be excellent, they are still just the best effort to type a
    library as complex as React. This inevitably leads to gaps. For the places where
    those gaps become visible, this chapter will be your guide.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we look at situations where React is supposed to be easy, but
    TypeScript gives you a hard time by throwing complex error messages. We are going
    to figure out what those messages mean, how you can work around them, and what
    solutions help you in the long run. You will also learn about various development
    patterns and their benefits, and how to use TypeScript’s built-in JSX support.
  prefs: []
  type: TYPE_NORMAL
- en: What you won’t get is a basic setup guide for React and TypeScript. The ecosystem
    is so vast and rich, many roads lead to Rome. Pick your framework’s documentation
    pages and look out for TypeScript. Also note that I assume some React experience
    up front. In this chapter, we deal mostly with typing React.
  prefs: []
  type: TYPE_NORMAL
- en: While there is a strong inclination toward React in this chapter, you will be
    able to use certain learnings and apply them to other JSX-based frameworks and
    libraries as well.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Writing Proxy Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You write a lot of standard HTML components, but you don’t want to set all necessary
    properties all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create proxy components and apply a few patterns to make them usable for your
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most web applications use buttons. Buttons have a `type` property that defaults
    to `submit`. This is a sensible default for forms where you perform an action
    over HTTP, where you POST the contents to a server-side API. But when you just
    want to have interactive elements on your site, the correct type for buttons is
    `button`. This is not only an aesthetic choice but also important for accessibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When you write React, chances are you rarely submit a form to a server with
    a `submit` type, but you interact with lots of `button`-type buttons. A good way
    to deal with situations like these is to write proxy components. They mimic HTML
    elements but preset a couple of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The idea is that `Button` takes the same properties as the HTML `button`, and
    the attributes are spread out to the HTML element. Spreading attributes to HTML
    elements is a nice feature where you can make sure that you are able to set all
    the HTML properties that an element has without knowing up front which you want
    to set. But how do we type them?
  prefs: []
  type: TYPE_NORMAL
- en: All HTML elements that can be used in JSX are defined through intrinsic elements
    in the `JSX` namespace. When you load React, the `JSX` namespace appears as a
    global namespace in your file, and you can access all elements via index access.
    So the correct prop types for `Button` are defined in `JSX.IntrinsicElements`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An alternative to `JSX.IntrinsicElements` is `React.ElementType`, a generic
    type within the React package, which also includes class and function components.
    For proxy components, `JSX⁠.Int⁠rin⁠sic​Ele⁠ments` is sufficient and comes with
    an extra benefit: your components stay compatible with other React-like frameworks
    like Preact.'
  prefs: []
  type: TYPE_NORMAL
- en: '`JSX.IntrinsicElements` is a type within the global `JSX` namespace. Once this
    namespace is in scope, TypeScript is able to pick up basic elements that are compatible
    with your JSX-based framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This includes children: we spread them along! As you see, we set a button’s
    type to `button`. Since props are just JavaScript objects, it’s possible to override
    `type` by setting it as an attribute in props. If two keys with the same name
    are defined, the last one wins. This may be desired behavior, but you alternatively
    may want to prevent you and your colleagues from overriding `type`. With the `Omit<T,
    K>` helper type, you can take all properties from a JSX `button` but drop keys
    you don’t want to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need `type` to be `submit`, you can create another proxy component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can extend this idea of omitting properties if you want to preset even
    more properties. Perhaps you adhere to a design system and don’t want class names
    to be set arbitrarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This even allows you to reuse the `type` property name.
  prefs: []
  type: TYPE_NORMAL
- en: We dropped some props from the type definition and preset them to sensible defaults.
    Now we want to make sure our users don’t forget to set some props, such as the
    `alt` attribute of an image or the `src` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we create a `MakeRequired` helper type that removes the optional
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And build our own props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With just a few changes to the original intrinsic element’s type and a proxy
    component, we can ensure that our code becomes more robust, more accessible, and
    less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Writing Controlled Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Form elements like inputs add another complexity as we need to decide where
    to manage state: in the browser or in React.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a proxy component that uses discriminated unions and the optional never
    technique to ensure you won’t switch from uncontrolled to controlled at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React differentiates form elements between *controlled components* and *uncontrolled
    components*. When you use regular form elements like `input`, `textarea`, or `select`,
    you need to keep in mind that the underlying HTML elements control their own state.
    Whereas in React, the state of an element is also defined *through* React.
  prefs: []
  type: TYPE_NORMAL
- en: If you set the `value` attribute, React assumes that the element’s value is
    also controlled by React’s state management, which means you are not able to modifiy
    this value unless you maintain the element’s state using `useState` and the associated
    setter function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to deal with this. First, you can choose `defaultValue`
    as a property instead of `value`. This will set the `value` of the input only
    in the first rendering, and subsequently leaves everything in the hands of the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you manage `value` interally via React’s state management. Usually, it’s
    enough just to intersect the original input element’s props with our own type.
    We drop `value` from the intrinsic elements and add it as a required `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we wrap the `input` element in a proxy component. It is not best practice
    to keep state internally in a proxy component; rather, you should manage it from
    the outside with `useState`. We also forward the `onChange` handler we pass from
    the original input props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'React raises an interesting warning when dealing with a switch from uncontrolled
    to controlled at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: A component is changing an uncontrolled input to be controlled. This is likely
    caused by the value changing from undefined to a defined value, which should not
    happen. Decide between using a controlled or uncontrolled input element for the
    lifetime of the component.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can prevent this warning by making sure at compile time that we either always
    provide a defined string `value` or provide a `defaultValue` instead, but not
    both. This can be solved by using a discriminated union type using the optional
    never technique (as seen in [Recipe 3.8](ch03.html#ch03_item_optional_never)),
    and using the `OnlyRequired` helper type from [Recipe 8.1](ch08.html#ch08_one_optional)
    to derive possible properties from `JSX.IntrinsicElements["input"]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In all other cases, having an optional `value` or having a `defaultValue` and
    trying to control values will be prohibited by the type system.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Typing Custom Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define custom hooks and get proper types.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use tuple types or *const context*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a custom hook in React and stick to the naming convention as regular
    React hooks do: returning an array (or tuple) that can be destructured. For example,
    `useState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Why do we even use arrays? Because the array’s fields have no name, and you
    can set names of your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So naturally, if you have a similar pattern, you also want to return an array.
    A custom toggle hook might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing out of the ordinary. The only types we have to set are the types of
    the input parameters. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So why does this fail? The error message might be cryptic, but what we should
    look out for is the first type, which is declared incompatible: `boolean | (()
    => void)''`. This comes from returning an array: a list of any length that can
    hold as many elements as virtually possible. From the return value in `useToggle`,
    TypeScript infers an array type. Since the type of `value` is `boolean` (great!)
    and the type of `toggleValue` is `(() => void)` (a function expected to return
    nothing), TypeScript tells us that both types are possible in this array.'
  prefs: []
  type: TYPE_NORMAL
- en: This is what breaks the compatibility with `onClick`. `onClick` expects a function.
    That’s fine, but `toggleValue` (or `toggleVisible`) is a function. According to
    TypeScript, however, it can also be a Boolean! TypeScript tells you to be explicit,
    or at least to do type-checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we shouldn’t need to do extra type-checks. Our code is very clear. It’s
    the types that are wrong. Because we’re not dealing with an array, let’s go for
    a different name: tuple. While an array is a list of values that can be of any
    length, we know exactly how many values we get in a tuple. Usually, we also know
    the type of each element in a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we shouldn’t return an array but a tuple at `useToggle`. The problem: in
    JavaScript an array and a tuple are indistinguishable. In TypeScript’s type system,
    we can distinguish them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First option: let’s be intentional with our return type. Since TypeScript—correctly!—infers
    an array, we have to tell TypeScript that we are expecting a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With `[boolean, () => void]` as a return type, TypeScript checks that we are
    returning a tuple in this function. TypeScript does not infer, but rather makes
    sure that your intended return type is matched by the actual values. And voilà,
    your code doesn’t throw errors anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second option: use *const context*. With a tuple, we know how many elements
    we are expecting, and we know the type of these elements. This sounds like a job
    for freezing the type with a `const` assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The return type is now `readonly [boolean, () => void]`, because `as const`
    makes sure that your values are constant and not changeable. This type is a little
    bit different semantically, but in reality you wouldn’t be able to change the
    values you return outside of `useToggle`. So being `readonly` would be slightly
    more correct.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Typing Generic forwardRef Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use `forwardRef` for your components, but you need them to be generic.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several solutions to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are creating component libraries and design systems in React, you might
    already have fowarded `ref`s to the DOM elements inside your components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially useful if you wrap basic components or leaves in *proxy
    components* (see [Recipe 10.1](#ch10_proxy_components)), but want to use the `ref`
    property just like you’re used to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Providing types for `React.forwardRef` is usually pretty straightforward. The
    types shipped by `@types/react` have generic type variables that you can set upon
    calling `React.forwardRef`. In that case, explicitly annotating your types is
    the way to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. But things get a bit hairy if you have a component that accepts
    generic properties. The following component produces a list of list items, where
    you can select each row with a `button` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You want the extra type safety so you can work with a type-safe `item` in your
    `on​Sel⁠ect` callback. Say you want to create a `ref` to the inner `ul` element:
    how do you proceed? Let’s change the `ClickableList` component to an inner function
    component that takes a `ForwardRef` and use it as an argument in the `React.forwardRef`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This compiles but has one downside: we can’t assign a generic type variable
    for `Cl⁠ick⁠ab⁠le​Li⁠st⁠Prop⁠s`. It becomes `unknown` by default. This is good
    compared to `any` but also slightly annoying. When we use `ClickableList`, we
    know which items to pass along, and we want to have them typed accordingly! So
    how can we achieve this? The answer is tricky …​ and you have a couple of options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first option is to do a type assertion that restores the original function
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Type assertions work great if you happen to have only a few situations where
    you need generic `forwardRef` components, but they might be too clumsy when you
    work with lots of them. Also, you introduce an unsafe operator for something that
    should be default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to create custom references with wrapper components. While
    `ref` is a reserved word for React components, you can use your own custom props
    to mimic a similar behavior. This works just as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You introduce a new API, however. For the record, there is also the possibility
    of using a wrapper component that allows you to use `forwardRef` inside an *inner*
    component and expose a custom `ref` property to the outside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Both are valid solutions if the only thing you want to achieve is passing that
    ref. If you want to have a consistent API, you might look for something else.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final option is to augment `forwardRef` with your own type definitions.
    TypeScript has a feature called [*higher-order function type inference*](https://oreil.ly/rVsq9)
    that allows propagating free type parameters to the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds a lot like what we want with `forwardRef` to begin with, but it
    doesn’t work with our current typings. The reason is that higher-order function
    type inference works only on plain function types. The function declarations inside
    `forwardRef` also add properties for `defaultProps` and so on. These are relics
    from the class component days, things you might not want to use anyway.
  prefs: []
  type: TYPE_NORMAL
- en: So without the additional properties, it should be possible to use higher-order
    function type inference!
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using TypeScript, so we have the ability to redeclare and redefine global
    `module`, `namespace`, and `interface` declarations on our own. Declaration merging
    is a powerful tool, and we’re going to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The nice thing about this solution is that you write regular JavaScript again
    and work exclusively on a type level. Also, redeclarations are module scoped:
    no interference with any `forwardRef` calls from other modules!'
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Providing Types for the Context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the context API for globals in your app, but you don’t know
    the best way to deal with type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Either set default properties for context and let the type be inferred or create
    a partial of your context’s properties and instantiate the generic type parameter
    explicitly. If you don’t want to provide default values, but want to make sure
    that all properties are provided, create a helper function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React’s context API allows you to share data on a global level. To use it,
    you need two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs: []
  type: TYPE_NORMAL
- en: Providers pass data to a subtree.
  prefs: []
  type: TYPE_NORMAL
- en: Consumers
  prefs: []
  type: TYPE_NORMAL
- en: Consumers are components that *consume* the passed data inside render props.
  prefs: []
  type: TYPE_NORMAL
- en: With React’s typings, you can use context without doing anything else most of
    the time. Everything is done using type inference and generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a context. Here, we want to store global application settings,
    like a theme and the app’s language, along with the global state. When creating
    a React context, we want to pass default properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, everything you need to do in terms of types is done for you.
    We have three properties: `authenticated`, `lang`, and `theme`; they are of types
    `boolean` and `string`. React’s typings take this information to provide you with
    the correct types when you use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, a component high up in your component tree needs to provide context—for
    example, the application’s root component. This provider trickles down the values
    you’ve set to every consumer below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every component inside this tree can consume this context. You already
    get type errors when you forget a property or use the wrong type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s consume our global state. Consuming context can be done via render
    props. You can destructure your render props as deep as you like, to get only
    the props you want to deal with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way of using context is via the respective `useContext` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Because we defined our properties earlier with the right types, `authenticated`
    is of type boolean at this point. Again, we didn’t have to do anything to get
    this extra type safety.
  prefs: []
  type: TYPE_NORMAL
- en: The whole previous example works best if we have default properties and values.
    Sometimes you don’t have default values or you need to be more flexible in which
    properties you want to set.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of inferring everything from default values, we annotate the generic
    type parameter explicitly, not with the full type, but with a `Partial`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a type for the context’s props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And initialize the new context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the semantics of the context’s default properties has some side effects
    on your components as well. Now you don’t need to provide every value; an empty
    context object can do the same! All your properties are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means you need to check for every property if it’s defined. This
    doesn’t change the code where you rely on `boolean` values, but every other property
    needs to have another `undefined` check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you can’t provide default values and want to make sure that all properties
    are provided by a context provider, you can help yourself with a helper function.
    Here, we want explicit generic instantiation to supply a type but give the right
    type guards so that when consuming context, all possibly undefined values are
    correctly set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What’s going on in `createContext`?
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_typescript_and_react_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a function that has no function arguments but generic type parameters.
    Without the connection to function parameters, we can’t instantiate `Props` via
    inference. This means that for `createContext` to provide proper types, we need
    to explicitly instantiate it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_typescript_and_react_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a context that allows for `Props` or `undefined`. With `undefined`
    added to the type, we can pass `undefined` as value. No default values!
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_typescript_and_react_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Inside `createContext`, we create a custom hook. This hook wraps `useContext`
    using the newly created context `ctx`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_typescript_and_react_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Then we do a type guard where we check if the returned `Props` includes `undefined`.
    Remember, when calling `createContext`, we instantiate the generic type parameter
    with `Props | undefined`. This line removes `undefined` from the union type again.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_typescript_and_react_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Which means that here, `c` is `Props`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_typescript_and_react_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: We assert that `ctx.Provider` doesn’t take `undefined` values. We call `as const`
    to return `[useInnerContext, ctx.Provider]` as a tuple type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `createContext` similar to `React.createContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `AppContextProvider`, we need to provide all values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your use case, you have exact types without too much overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Typing Higher-Order Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are writing *higher-order components* to preset certain properties for other
    components but don’t know how to type them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `React.ComponentType<P>` type from `@types/react` to define a component
    that extends your preset attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React is influenced by functional programming, which we see in the way components
    are designed (via functions), assembled (via composition), and updated (stateless,
    unidirectional data flow). It didn’t take long for functional programming techniques
    and paradigms to find their way into React development. One such technique is
    higher-order components, which draw inspiration from *higher-order functions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Higher-order functions accept one or more parameters to return a new function.
    Sometimes those parameters are here to prefill certain other parameters, as we
    see, for example, in all currying recipes from [Chapter 7](ch07.html#ch07). Higher-order
    components are similar: they take one or more components and return themselves
    another component. Usually, you create them to prefill certain properties where
    you want to make sure they won’t be changed later on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about a general-purpose `Card` component, which takes `title` and `content`
    as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You use this card to present certain events, like warnings, information bubbles,
    and error messages. The most basic information card has `"Info"` as its title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You could subset the properties of `Card` to allow for only a certain subset
    of strings for `title`, but on the other hand, you want to be able to reuse `Card`
    as much as possible. So you create a new component that already sets `title` to
    `"Info"` and only allows for other properties to be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, you *inject* a subset of properties and set the remaining ones
    with the newly created component. A function `withInjectedProps` is easily written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It takes the `injected` props and a `Component` as parameters, returns a new
    function component that takes the remaining props as parameters, and instantiates
    the original component with merged properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we type `withInjectedProps`? Let’s look at the result and see what’s
    inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what’s going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_typescript_and_react_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We need to define two generic type parameters. `T` is for the props we already
    inject; it extends from `{}` to make sure we only pass objects. `U` is a generic
    type parameter for all props of `Component`. `U` *extends* `T`, which means that
    `U` is a subset of `T`. This says that `U` has more properties than `T` but needs
    to include what `T` already has defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_typescript_and_react_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We define `Component` to be of type `React.ComponentType<U>`. This includes
    class components as well as function components and says that props will be set
    to `U`. With the relationship of `T` and `U` and the way we defined the parameters
    of `withInjectedProps`, we ensure that everything that will be passed for `Component`
    defines a subset of properties for `Component` with `injected`. If we make a typo,
    we quickly get the first error message!
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_typescript_and_react_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The function component that will be returned takes the remaining props. With
    `Omit<U, keyof T>` we make sure that we don’t allow prefilled attributes to be
    set again.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_typescript_and_react_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Merging `T` and `Omit<U, keyof T>` should result in `U` again, but since generic
    type parameters can be explicitly instantiated with something different, they
    might not fit `Component` again. A type assertion helps ensure that the props
    are actually what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s it! With those new types, we get proper autocomplete and errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`withInjectedProps` is so flexible that we can derive higher-order functions
    that create higher-order components for various situations, like `withTitle`,
    which is here to prefill `title` attributes of type `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Your functional programming goodness knows no limits.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Typing Callbacks in React’s Synthetic Event System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get the best possible typings for all browser events in React and
    use the type system to restrict your callbacks to compatible elements.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the event types of `@types/react` and specialize on components using generic
    type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web applications become alive through user interaction. Every user interaction
    triggers an event. Events are key, and TypeScript’s React typings have great support
    for events, but they require you not to use the native events from *lib.dom.d.ts*.
    If you do, React throws errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'React uses its own event system, which we refer to as *synthetic events*. Synthetic
    events are cross-browser wrappers around the browser’s native event, with the
    same interface as its native counterpart but aligned for compatibility. A change
    to the type from `@types/react` makes your callbacks compatible again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The browser’s `MouseEvent` and `React.MouseEvent` are different enough for TypeScript’s
    *structural* type system, meaning that there are some missing properties in the
    synthetic counterparts. You can see in the preceding error message that the original
    `MouseEvent` has 18 properties more than `React.MouseEvent`, some of them arguably
    important, like coordinates and offsets, which come in handy if, for example,
    you want to draw on a canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to access properties from the original event, you can use the `nativeEvent`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Events supported are: `AnimationEvent`, `ChangeEvent`, `ClipboardEvent`, `Com⁠pos⁠iti⁠on​Ev⁠ent`,
    `DragEvent`, `FocusEvent`, `FormEvent`, `KeyboardEvent`, `MouseEvent`, `Poi⁠nt⁠er​Ev⁠ent`,
    `TouchEvent`, `TransitionEvent`, and `WheelEvent`, as well as `SyntheticEvent`
    for all other events.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we applied the correct types to make sure we don’t have any compiler
    errors. Easy enough. But we’re using TypeScript not only to fulfill the ceremony
    of applying types to keep the compiler from complaining but also to prevent situations
    that might be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s think about a button again. Or a link (the `a` element). Those elements
    are supposed to be clicked; that’s their purpose. But in the browser, click events
    can be received by every element. Nothing keeps you from adding `onClick` to a
    `div` element, the element that has the least semantic meaning of all elements,
    and no assistive technology will tell you that a `div` can receive a `MouseEvent`
    unless you add lots of attributes to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wouldn’t it be great if we could keep our colleagues (and ourselves) from using
    the defined event handlers on the *wrong* elements? `React.MouseEvent` is a generic
    type that takes compatible elements as its first type. This is set to `Element`,
    which is the base type for all elements in the browser. But you are able to define
    a smaller set of compatible elements by subtyping this generic parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Although React’s types give you more flexibility in some areas, it lacks features
    in others. For example, the browser native `InputEvent` is not supported in `@types/react`.
    The synthetic event system is meant to be a cross-browser solution, and some of
    React’s compatible browsers still lack implementation of `InputEvent`. Until they
    catch up, it’s safe for you to use the base event `SyntheticEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now you get at least *some* type safety.
  prefs: []
  type: TYPE_NORMAL
- en: 10.8 Typing Polymorphic Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You create a proxy component (see [Recipe 10.1](#ch10_proxy_components)) that
    needs to behave as one of many different HTML elements. It’s hard to get the right
    typings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assert forwarded properties as `any` or use the JSX factory `React.createElement`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common pattern in React is to define polymorphic (or `as`) components, which
    pre-define behavior but can act as different elements. Think of a call-to-action
    button, or CTA, which can be a link to a website or an actual HTML button. If
    you want to style them similarly, they should behave alike, but depending on the
    context they should have the right HTML element for the right action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Selecting the right element is an important accessibility factor. `a` and `button`
    elements represent something users can click, but the semantics of `a` are fundamentally
    different from the semantics of a `button`. `a` is short for anchor and needs
    to have a reference (`href`) to a destination. A `button` can be clicked, but
    the action is usually scripted via JavaScript. Both elements can look the same,
    but they act differently. Not only do they act differently, but they also are
    announced differently using assistive technologies, like screen readers. Think
    about your users and select the right element for the right purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that you have an `as` prop in your component that selects the element
    type. Depending on the element type of `as`, you can forward properties that fit
    the element type. Of course, you can combine this pattern with everything that
    you have seen in [Recipe 10.1](#ch10_proxy_components):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When throwing TypeScript into the mix, you want to make sure that you get autocomplete
    for the right props and errors for the wrong properties. If you add an `href`
    to a `button`, TypeScript should give you the correct squiggly lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try to type `Cta`. First, we develop the component without types at all.
    In JavaScript, things don’t look too complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We extract the `as` prop and rename it as `Component`. This is a destructuring
    mechanism from JavaScript that is syntactically similar to a TypeScript annotation
    but works on destructured properties and not on the object itself (where you’d
    need a type annotation). We rename it to an uppercase component so we can instantiate
    it via JSX. The remaining props will be collected in `...props` and spread out
    when creating the component. Note that you can also spread out children with `...props`,
    a nice little side effect of JSX.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to type `Cta`, we create a `CtaProps` type that works on either
    `"a"` elements or `"button"` elements and takes the remaining props from `JS⁠X.I⁠ntr⁠ins⁠ic​Ele⁠me⁠nts`,
    similar to what we’ve seen in [Recipe 10.1](#ch10_proxy_components):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When we wire up our types to `Cta`, we see that the function signature works
    very well with just a few extra annotations. But when instantiating the component,
    we get quite an elaborate error that tells us how much is going wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: So where does this message come from? For TypeScript to work correctly with
    JSX, we need to resort to type definitions in a global namespace called `JSX`.
    If this namespace is in scope, TypeScript knows which elements that aren’t components
    can be instantiated and which attributes they can accept. These are the `JS⁠X.I⁠ntr⁠ins⁠ic​Ele⁠men⁠ts`
    we use in this example and in [Recipe 10.1](#ch10_proxy_components).
  prefs: []
  type: TYPE_NORMAL
- en: 'One type that also needs to be defined is `LibraryManagedAttributes`. This
    type is used to provide attributes that are defined either by the framework itself
    (like `key`) or via means like `defaultProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: React’s typings solve `LibraryManagedAttributes` by using a conditional type.
    And as we see in [Recipe 12.7](ch12.html#ch12_overloads_vs_conditionals), conditional
    types won’t be expanded with all possible variants of a union type when being
    evaluated. This means that TypeScript won’t be able to check that your typings
    fit the components because it won’t be able to evaluate `Lib⁠rary​Man⁠age⁠dAt⁠trib⁠utes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One workaround for this is to assert props to `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: That works, but it is a sign of an *unsafe* operation that shouldn’t be unsafe.
    Another way is to not use JSX in this case but use the JSX factory `React.createElement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every JSX call is syntactic sugar to a JSX factory call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If you use nested components, the third parameter of `createElement` will contain
    nested factory function calls. `React.createElement` is much easier to call than
    JSX, and TypeScript won’t resort to the global `JSX` namespace when creating new
    elements. Sounds like a perfect workaround for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.createElement` needs three arguments: the component, the props, and
    the children. Right now, we’ve smuggled all child components with `props`, but
    for `React.createElement` we need to be explicit. This also means that we need
    to explicitly define `children`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we create a `WithChildren<T>` helper type. It takes an existing type
    and adds optional children in the form of `React.ReactNode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`WithChildren` is highly flexible. We can wrap the type of our props with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can create a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `T` is set to `{}` by default, the type becomes universally usable. This
    makes it a lot easier for you to attach `children` whenever you need them. As
    a next step, we destructure `children` out of `props` and pass all arguments into
    `React.createElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And with that, your polymorphic component accepts the right parameters without
    any errors.
  prefs: []
  type: TYPE_NORMAL
