<html><head></head><body><section data-pdf-bookmark="Chapter 11. Monitoring and Logging" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_mon_log">&#13;
<h1><span class="label">Chapter 11. </span>Monitoring and Logging</h1>&#13;
&#13;
&#13;
<p>In this chapter we focus on recipes around monitoring and logging, both on the infrastructure and on the application level.<a data-primary="monitoring and logging" data-type="indexterm" id="ix_monlog"/><a data-primary="logging" data-seealso="monitoring and logging" data-type="indexterm" id="id1061"/> In the context of Kubernetes, different roles typically have different scopes:</p>&#13;
<dl>&#13;
<dt>Administrator roles</dt>&#13;
<dd>&#13;
<p>Administrators, such as cluster admins, networking operations folks, or namespace-level admins, focus on the cluster control plane.<a data-primary="control plane" data-secondary="admin roles focus on cluster control plane" data-type="indexterm" id="id1062"/><a data-primary="administrator roles" data-type="indexterm" id="id1063"/> Example questions they might ask themselves are: Are nodes healthy? Shall we add a worker node? What is the cluster-wide utilization? Are users close to their usage quotas?</p>&#13;
</dd>&#13;
<dt>Developer roles</dt>&#13;
<dd>&#13;
<p>Developers mainly think  and act in the context of the application or data plane, which may well be—in the age of microservices—a handful to a dozen pods.<a data-primary="microservices" data-type="indexterm" id="id1064"/><a data-primary="developer roles" data-type="indexterm" id="id1065"/> For example, a person in a developer role might ask: Do I have enough resources allocated to run my app? How many replicas should I scale my app to? Do I have access to the right volumes, and how full are they? Is one of my apps failing and, if so, why?</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>We will first cover recipes focused on cluster-internal monitoring by leveraging Kubernetes liveness and readiness probes, then focus on monitoring with the <a href="https://oreil.ly/agm34">Metrics Server</a> and <a href="https://prometheus.io">Prometheus</a>, and finally cover logging-related recipes.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="11.1 Accessing the Logs of a Container" data-type="sect1"><div class="sect1" id="kubectllogs">&#13;
<h1>11.1 Accessing the Logs of a Container</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id239">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to access the logs of the application running inside a container that is running in a specific pod.<a data-primary="containers" data-secondary="accessing logs of" data-type="indexterm" id="ix_cntnrlogs"/><a data-primary="monitoring and logging" data-secondary="accessing logs of a container" data-type="indexterm" id="ix_monlogctnrlog"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id99">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>kubectl logs</code> command. <a data-primary="kubectl" data-secondary="logs command" data-type="indexterm" id="id1066"/><a data-primary="logs command (kubectl)" data-type="indexterm" id="id1067"/>To see the various options, check the usage, like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl logs --help | more</strong>&#13;
Print the logs for a container in a pod or specified resource. If the pod has&#13;
only one container, the container name is optional.&#13;
&#13;
Examples:&#13;
  # Return snapshot logs from pod nginx with only one container&#13;
  kubectl logs nginx&#13;
...&#13;
</pre>&#13;
&#13;
<p>For example, given a pod started by a deployment (see <a data-type="xref" href="ch04.html#kubectl_run">Recipe 4.1</a>), you can check the logs like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                             READY   STATUS    RESTARTS   AGE&#13;
nginx-with-pv-7d6877b8cf-mjx5m   1/1     Running   0          140m&#13;
&#13;
$ <strong>kubectl logs nginx-with-pv-7d6877b8cf-mjx5m</strong>&#13;
...&#13;
2023/03/31 11:03:24 [notice] 1#1: using the "epoll" event method&#13;
2023/03/31 11:03:24 [notice] 1#1: nginx/1.23.4&#13;
2023/03/31 11:03:24 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)&#13;
2023/03/31 11:03:24 [notice] 1#1: OS: Linux 5.15.49-linuxkit&#13;
2023/03/31 11:03:24 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576&#13;
2023/03/31 11:03:24 [notice] 1#1: start worker processes&#13;
...&#13;
</pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If a pod has multiple containers, you can get the logs of any of them by specifying the name of the container using the <code>-c</code> option of <code>kubectl logs</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id100">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a href="https://oreil.ly/o4dxI">Stern</a> is a useful alternative for viewing pod logs on Kubernetes. It makes it easy to get logs from across namespaces and requires only that you provide a partial pod name in the query (as opposed to using selectors, which can be more cumbersome at times).<a data-primary="stern tool" data-type="indexterm" id="id1068"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.2 Recovering from a Broken State with a &#10;Liveness Probe" data-type="sect1"><div class="sect1" id="liveness">&#13;
<h1>11.2 Recovering from a Broken State with a &#13;
<span class="keep-together">Liveness Probe</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id101">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to make sure that if the applications running inside some of your pods get into a broken state, Kubernetes restarts the pods automatically.<a data-primary="monitoring and logging" data-secondary="recovering from broken state with liveness probe" data-type="indexterm" id="id1069"/><a data-primary="liveness probes" data-type="indexterm" id="id1070"/><a data-primary="pods" data-secondary="restarting automatically after app fails liveness probe" data-type="indexterm" id="id1071"/><a data-primary="probes" data-secondary="liveness probe" data-type="indexterm" id="id1072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id102">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a liveness probe. If the probe fails, the <code>kubelet</code> will restart the pod automatically. <a data-primary="kubelet" data-secondary="restarting pod automatically after failing liveness probe" data-type="indexterm" id="id1073"/>The probe is part of the pod specification and is added to the <code>containers</code> section. <a data-primary="containers" data-secondary="liveness probes" data-type="indexterm" id="id1074"/>Each container in a pod can have a liveness probe.</p>&#13;
&#13;
<p>A probe can be of three different types: it can be a command that is executed inside the container, an HTTP or gRPC request to a specific route served by an HTTP server inside the container, or a more generic TCP probe.<a data-primary="probes" data-secondary="types of" data-type="indexterm" id="id1075"/><a data-primary="HTTP probes" data-type="indexterm" id="id1076"/></p>&#13;
&#13;
<p>In the following example, we show a basic HTTP probe:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">liveness-nginx</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">livenessProbe</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">httpGet</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre>&#13;
&#13;
<p>See <a data-type="xref" href="#liveness_readiness_probes">Recipe 11.5</a> for a complete example.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1077">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/nrqEP">container probes documentation</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.3 Controlling Traffic Flow to a Pod Using a &#10;Readiness Probe" data-type="sect1"><div class="sect1" id="readiness">&#13;
<h1>11.3 Controlling Traffic Flow to a Pod Using a &#13;
<span class="keep-together">Readiness Probe</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id103">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Your pods are up and running according to the liveness probes (see <a data-type="xref" href="#liveness">Recipe 11.2</a>), but you want to send traffic to them only if the application is ready to serve the requests.<a data-primary="monitoring and logging" data-secondary="controlling traffic flow to a pod using readiness probe" data-type="indexterm" id="id1078"/><a data-primary="pods" data-secondary="controlling traffic flow to using readiness probe" data-type="indexterm" id="id1079"/><a data-primary="readiness probes" data-type="indexterm" id="id1080"/><a data-primary="probes" data-secondary="readiness probe" data-type="indexterm" id="id1081"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id104">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Add <a href="https://oreil.ly/oU3wa">readiness probes</a> to your pod specifications. The following is a straightforward example of running a single pod with the <code>nginx</code> container image. <a data-primary="HTTP probes" data-type="indexterm" id="id1082"/>The readiness probe makes an HTTP request to port 80:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">readiness-nginx</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">readiness</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">readinessProbe</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">httpGet</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id240">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>While the readiness probe shown in this recipe is the same as the liveness probe in <a data-type="xref" href="#liveness">Recipe 11.2</a>, they typically should be different as the two probes aim to give information about different aspects of the application. The liveness probe checks that the application process is alive, but it may not be ready to accept requests.<a data-primary="liveness probes" data-secondary="readiness probes versus" data-type="indexterm" id="id1083"/><a data-primary="readiness probes" data-secondary="liveness probes versus" data-type="indexterm" id="id1084"/> The readiness probe checks that the application is serving requests properly. As such, only when a readiness probe passes does the pod become part of a service (see <a data-type="xref" href="ch05.html#simple_service">Recipe 5.1</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1085">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/nrqEP">container probes documentation</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.4 Protecting Slow-Starting Containers Using &#10;a Start-up Probe" data-type="sect1"><div class="sect1" id="startup_probes">&#13;
<h1>11.4 Protecting Slow-Starting Containers Using &#13;
<span class="keep-together">a Start-up Probe</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id105">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Your pod contains a container that needs additional start-up time on first initialization, but you don’t want to use liveness probes (see <a data-type="xref" href="#liveness">Recipe 11.2</a>) since this is a requirement only for the first time the pod is launched.<a data-primary="containers" data-secondary="slow-starting, protecting with start-up probe" data-type="indexterm" id="id1086"/><a data-primary="probes" data-secondary="start-up probe" data-type="indexterm" id="id1087"/><a data-primary="start-up probes" data-type="indexterm" id="id1088"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id106">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Add a start-up probe to your pod specification with <code>failureThreshold</code> and <code>periodSeconds</code> set high enough to cover the start-up time for the pod. <a data-primary="periodSeconds field" data-type="indexterm" id="id1089"/><a data-primary="failureThreshold field" data-type="indexterm" id="id1090"/><a data-primary="pods" data-secondary="start-up probe in pod specification" data-type="indexterm" id="id1091"/>Similar to liveness probes, start-up probes can be of three types. The following is a straightforward example of running a single pod with the <code>nginx</code> container image. The start-up probe makes an HTTP request to port 80:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">startup-nginx</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">startup</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">startupProbe</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">httpGet</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">failureThreshold</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">30</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id241">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Sometimes you have to deal with applications that need a long time to start up. For example, an application may need to perform some database migrations that take a long time to complete. In such cases setting up a liveness probe, without compromising the fast response to deadlocks that motivates such a probe, can be tricky. To work around this, in addition to your liveness probe you can set up a start-up probe with the same command, HTTP check, or TCP check, but with a <code>failureThreshold * periodSeconds</code> long enough to cover the worse-case start-up time.</p>&#13;
&#13;
<p>If a start-up probe is configured, liveness and readiness probes do not start until it succeeds, making sure those probes don’t interfere with the application start-up. <a data-primary="liveness probes" data-secondary="following successful start-up probe" data-type="indexterm" id="id1092"/><a data-primary="readiness probes" data-secondary="following successful start-up probe" data-type="indexterm" id="id1093"/>This technique can be used to safely implement liveness checks on slow-starting containers, avoiding them getting killed by the <code>kubelet</code> before they are up and running.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1094">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kubernetes <a href="https://oreil.ly/nrqEP">container probes documentation</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/CoMlg">“Configure Liveness, Readiness and Startup Probes”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.5 Adding Liveness and Readiness Probes to &#10;Your Deployments" data-type="sect1"><div class="sect1" id="liveness_readiness_probes">&#13;
<h1>11.5 Adding Liveness and Readiness Probes to &#13;
<span class="keep-together">Your Deployments</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id242">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to be able to automatically check if your app is healthy and let Kubernetes take action if this is not the case.<a data-primary="probes" data-secondary="liveness and readiness probes, adding to deployments" data-type="indexterm" id="ix_prblivereadi"/><a data-primary="monitoring and logging" data-secondary="adding liveness and readiness probes to deployments" data-type="indexterm" id="ix_monlogprbdply"/><a data-primary="deployments" data-secondary="adding liveness and readiness probes to" data-type="indexterm" id="ix_dplyprobe"/><a data-primary="liveness probes" data-secondary="adding to your deployments" data-type="indexterm" id="iv_liveprb"/><a data-primary="readiness probes" data-secondary="adding to your deployments" data-type="indexterm" id="ix_readiprb"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1095">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>To signal to Kubernetes how your app is doing, add liveness and readiness probes as described here.</p>&#13;
&#13;
<p>The starting point is a deployment manifest, <em>webserver.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">webserver</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.25.2</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre>&#13;
&#13;
<p>Liveness and readiness probes are defined in the <code>containers</code> section of the pod specification. See the introductory examples (Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="#liveness">11.2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#readiness">11.3</a>) and add the following to the container spec in your deployment’s pod template:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">livenessProbe</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">httpGet</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">initialDelaySeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">readinessProbe</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">httpGet</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">initialDelaySeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>Now you can launch it and check the probes:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f webserver.yaml</strong>&#13;
deployment.apps/webserver created&#13;
&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                         READY     STATUS    RESTARTS   AGE&#13;
webserver-4288715076-dk9c7   1/1       Running   0          2m&#13;
&#13;
$ <strong>kubectl describe pod/webserver-4288715076-dk9c7</strong>&#13;
Name:           webserver-4288715076-dk9c7&#13;
Namespace:      default&#13;
Priority:       0&#13;
&#13;
...&#13;
Status:         Running&#13;
IP:             10.32.0.2&#13;
...&#13;
Containers:&#13;
  nginx:&#13;
    ...&#13;
    Ready:           True&#13;
    Restart Count:   0&#13;
    Liveness:       http-get http://:80/ delay=2s timeout=1s period=10s #succe...&#13;
    Readiness:      http-get http://:80/ delay=2s timeout=1s period=10s #succe...&#13;
    ...&#13;
...&#13;
</pre>&#13;
&#13;
<p>Note that the output of the <code>kubectl describe</code> command has been edited down to the important bits; there’s much more information available, but it’s not pertinent to our problem here.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id107">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>To verify whether a container in a pod is healthy and ready to serve traffic, Kubernetes provides a range of health-checking mechanisms.<a data-primary="health checks" data-seealso="probes" data-type="indexterm" id="id1096"/>&#13;
Health checks, or <em>probes</em> as they are called in Kubernetes, are defined on the container level, not on the pod level, and are carried out by two different components:</p>&#13;
&#13;
<ul class="less_space pagebreak-before">&#13;
<li>&#13;
<p>The  <code>kubelet</code> on each worker node uses the <code>livenessProbe</code> directive in the spec to determine when to restart a container. These liveness probes can help overcome ramp-up issues or deadlocks.<a data-primary="kubelet" data-secondary="livenessProbe directive" data-type="indexterm" id="id1097"/></p>&#13;
</li>&#13;
<li>&#13;
<p>A service load balancing a set of pods uses the <code>readinessProbe</code> directive to determine <a data-primary="services" data-secondary="load balancing pods using readinessProbe directive" data-type="indexterm" id="id1098"/>if a pod is ready and hence should receive traffic. If this is not the case, it is excluded from the service’s pool of endpoints. Note that a pod is considered ready when all of its containers are ready.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>When should you use which probe? That depends on the behavior of the container, really.&#13;
Use a liveness probe and a <code>restartPolicy</code> of either <code>Always</code> or <code>OnFailure</code> if your container <a data-primary="restartPolicy" data-type="indexterm" id="id1099"/>can and should be killed and restarted if the probe fails.&#13;
If you want to send traffic to a pod only when it’s ready, use a readiness probe. Note that in this latter case, the readiness probe can be configured to use the same probing declaration endpoint (e.g., URL) as the liveness probe.</p>&#13;
&#13;
<p>Start-up probes are used to determine if the application in a pod is up and running correctly.<a data-primary="start-up probes" data-type="indexterm" id="id1100"/> They can be used to delay the initialization of liveness and readiness probes, which are likely to fail if the application hasn’t correctly started yet.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1101">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/CoMlg">“Configure Liveness, Readiness and Startup Probes”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/vEOdP">Kubernetes pod lifecycle documentation</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/NWpRM">Kubernetes init containers documentation</a> (stable in v1.6 and above)</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.6 Accessing Kubernetes Metrics in the CLI" data-type="sect1"><div class="sect1" id="cli_metrics">&#13;
<h1>11.6 Accessing Kubernetes Metrics in the CLI</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id108">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You have installed the Kubernetes Metrics Server (see <a data-type="xref" href="ch02.html#metrics_server">Recipe 2.7</a>), and you want to access the metrics using the Kubernetes CLI.<a data-primary="probes" data-secondary="liveness and readiness probes, adding to deployments" data-startref="ix_prblivereadi" data-type="indexterm" id="id1102"/><a data-primary="readiness probes" data-secondary="adding to your deployments" data-startref="ix_readiprb" data-type="indexterm" id="id1103"/><a data-primary="liveness probes" data-secondary="adding to your deployments" data-startref="iv_liveprb" data-type="indexterm" id="id1104"/><a data-primary="monitoring and logging" data-secondary="adding liveness and readiness probes to deployments" data-startref="ix_monlogprbdply" data-type="indexterm" id="id1105"/><a data-primary="deployments" data-secondary="adding liveness and readiness probes to" data-startref="ix_dplyprobe" data-type="indexterm" id="id1106"/><a data-primary="metrics" data-secondary="accessing Kubernetes metrics in CLI" data-type="indexterm" id="id1107"/><a data-primary="monitoring and logging" data-secondary="accessing Kubernetes metrics in CLI" data-type="indexterm" id="id1108"/><a data-primary="kubectl" data-secondary="top command" data-type="indexterm" id="id1109"/><a data-primary="top command  (kubectl)" data-type="indexterm" id="id1110"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1111">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>The Kubernetes CLI has the <code>top</code> command that displays the resource usage of nodes and pods:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl top node</strong>&#13;
NAME       CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%&#13;
minikube   338m         8%     1410Mi          17%&#13;
&#13;
$ <strong>kubectl top pods --all-namespaces</strong>&#13;
NAMESPACE     NAME                               CPU(cores)   MEMORY(bytes)&#13;
default       db                                 15m          440Mi&#13;
default       liveness-nginx                     1m           5Mi&#13;
default       nginx-with-pv-7d6877b8cf-mjx5m     0m           3Mi&#13;
default       readiness-nginx                    1m           3Mi&#13;
default       webserver-f4f7cb455-rhxwt          1m           4Mi&#13;
kube-system   coredns-787d4945fb-jrp8j           4m           12Mi&#13;
kube-system   etcd-minikube                      48m          52Mi&#13;
kube-system   kube-apiserver-minikube            78m          266Mi&#13;
...&#13;
</pre>&#13;
&#13;
<p>These metrics can also be viewed in a graphical user interface, the Kubernetes &#13;
<span class="keep-together">dashboard</span> (see <a data-type="xref" href="ch02.html#kubernetes_dashboard">Recipe 2.5</a>).</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>I can take several minutes for the Metrics Server to become available after having started it. If it is not yet in the ready state, then the <code>top</code> command might produce errors.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="11.7 Using Prometheus and Grafana on Minikube" data-type="sect1"><div class="sect1" id="prom_minikube">&#13;
<h1>11.7 Using Prometheus and Grafana on Minikube</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id243">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to view and query the system and application metrics of your cluster from a central place.<a data-primary="monitoring and logging" data-secondary="using Prometheus and Grafana on Minikube" data-type="indexterm" id="ix_monlogPrmGrf"/><a data-primary="metrics" data-secondary="viewing and querying system and application metrics of your cluster" data-type="indexterm" id="ix_mtrcs"/><a data-primary="Minikube" data-secondary="using Prometheus and Grafana on" data-type="indexterm" id="ix_MiniKPrmGrf"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id109">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Deploy Prometheus and Grafana on Minikube.<a data-primary="Prometheus, deploying and using on Minikube" data-type="indexterm" id="ix_Prom"/><a data-primary="Grafana, deploying and using on Minikube" data-type="indexterm" id="ix_Graf"/> We’ll leverage the <a href="https://oreil.ly/3oyNd">kube-prometheus project</a>, an independent project that makes it easy to install Prometheus and Grafana on any Kubernetes cluster.<a data-primary="Kube-Prometheus project" data-type="indexterm" id="id1112"/></p>&#13;
&#13;
<p class="pagebreak-before">Run the following command to start a new Minikube instance that is correctly configured to run kube-prometheus:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube delete &amp;&amp; minikube start --kubernetes-version=v1.27.0 \&#13;
    --memory=6g --bootstrapper=kubeadm \&#13;
    --extra-config=kubelet.authentication-token-webhook=true \&#13;
    --extra-config=kubelet.authorization-mode=Webhook \&#13;
    --extra-config=scheduler.bind-address=0.0.0.0 \&#13;
    --extra-config=controller-manager.bind-address=0.0.0.0</strong>&#13;
</pre>&#13;
&#13;
<p>Ensure the <code>metrics-server</code> add-on is disabled on Minikube:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube addons disable metrics-server</strong>&#13;
</pre>&#13;
&#13;
<p>Clone the kube-prometheus project:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>git clone https://github.com/prometheus-operator/kube-prometheus.git</strong>&#13;
</pre>&#13;
&#13;
<p>Change into the cloned repository, and then run the following command that will create a dedicated namespace called <code>monitoring</code> and create the necessary custom resource definitions:<a data-primary="custom resource definitions" data-type="indexterm" id="id1113"/></p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply --server-side -f manifests/setup</strong>&#13;
$ <strong>kubectl wait \&#13;
    --for condition=Established \&#13;
    --all CustomResourceDefinition \&#13;
    --namespace=monitoring</strong>&#13;
$ <strong>kubectl apply -f manifests/</strong>&#13;
</pre>&#13;
&#13;
<p>To open the Prometheus dashboard, you can use a port forward as shown here, or you can use ingress as defined in <a data-type="xref" href="ch05.html#ingress">Recipe 5.5</a>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl --namespace monitoring port-forward svc/prometheus-k8s 9090</strong>&#13;
</pre>&#13;
&#13;
<p>You can then open Prometheus on <em>localhost:9090</em> in your browser.</p>&#13;
&#13;
<p>You can do something similar to access the Grafana dashboard:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl --namespace monitoring port-forward svc/grafana 3000</strong>&#13;
</pre>&#13;
&#13;
<p>Then open the Grafana dashboard at <em>localhost:3000</em> in your browser.</p>&#13;
&#13;
<p>Use the default credentials to log in: username <code>admin</code> and password <code>admin</code>. You can skip changing the password if you’re just running this recipe on your local Minikube instance.</p>&#13;
&#13;
<p>There is a built-in dashboard for the Kubernetes API server. To find it, open the URL <em><a class="bare" href="http://localhost:3000/dashboards"><em class="hyperlink">http://localhost:3000/dashboards</em></a></em> or navigate to the Dashboards using the left menu bar. Find the dashboard called “Kubernetes / API server”; open it, and you should see a page like the one shown in <a data-type="xref" href="#grafana-screenshot">Figure 11-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="grafana-screenshot">&#13;
<img alt="Grafana screenshot" src="assets/kcb2_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>The Kubernetes/API server dashboard in Grafana</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id110">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This recipe provides a great way to start experimenting with Grafana and Prometheus and shows how to use an example built-in dashboard to get up and running quickly. Once you start deploying your own custom workloads and applications, you can create your own custom queries and dashboards that will provide metrics that are more specific to your workloads. You can learn more about Prometheus queries in the <a href="https://oreil.ly/23dQ9">Prometheus querying reference documentation</a>, and more about Grafana dashboards in the <a href="https://oreil.ly/nf6jI">Grafana documentation</a>.<a data-primary="monitoring and logging" data-secondary="using Prometheus and Grafana on Minikube" data-startref="ix_monlogPrmGrf" data-type="indexterm" id="id1114"/><a data-primary="Grafana, deploying and using on Minikube" data-startref="ix_Graf" data-type="indexterm" id="id1115"/><a data-primary="Prometheus, deploying and using on Minikube" data-startref="ix_Prom" data-type="indexterm" id="id1116"/><a data-primary="Minikube" data-secondary="using Prometheus and Grafana on" data-startref="ix_MiniKPrmGrf" data-type="indexterm" id="id1117"/><a data-primary="metrics" data-secondary="viewing and querying system and application metrics of your cluster" data-startref="ix_mtrcs" data-type="indexterm" id="id1118"/><a data-primary="monitoring and logging" data-startref="ix_monlog" data-type="indexterm" id="id1119"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1120">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/3oyNd">kube-prometheus on GitHub</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/q6pdv">Prometheus Operator on GitHub</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://prometheus-operator.dev">Prometheus Operator</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://prometheus.io">Prometheus</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://grafana.com">Grafana</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>