<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Cruising the Filesystem"><div class="chapter" id="ch_files">
<h1><span class="label">Chapter 4. </span>Cruising the Filesystem</h1>


<p><a data-type="indexterm" data-primary="filesystem" data-secondary="navigation" id="idm46586641942224"/><a data-type="indexterm" data-primary="Linux" data-secondary="filesystem" data-tertiary="navigation" id="idm46586641941248"/></p>

<p>In the movie <em>The Adventures of Buckaroo Banzai Across the 8th
Dimension</em>, a classic cult comedy from 1984, the swashbuckling title
character offers the following Zen-like words of wisdom: “Remember, no
matter where you go…there you are.”  Buckaroo could very well have
been talking about the Linux filesystem:</p>

<pre data-type="programlisting">$ <strong>cd /usr/share/lib/etc/bin</strong>              <em>No matter where you go...</em>
$ <strong>pwd</strong>
/usr/share/lib/etc/bin                   <em>...there you are.</em></pre>

<p>It’s also the case that wherever you are in the Linux filesystem—your
current directory—you will eventually go somewhere
else (to another directory). The faster and more efficiently you can
perform this navigation, the more productive you can be.</p>

<p>The techniques in this chapter will help you navigate the filesystem
more quickly with less typing. They look deceptively
simple but have <em>enormous</em> bang for the buck, with small
learning curves and big payoffs. These techniques fall into two broad
categories:</p>

<ul>
<li>
<p>Moving quickly to a specific directory</p>
</li>
<li>
<p>Returning rapidly to a directory you’ve visited before</p>
</li>
</ul>

<p>For a quick refresher on Linux directories, see <a data-type="xref" href="app01.xhtml#appendix_linux">Appendix A</a>.
If you use a shell other than <code>bash</code>, see <a data-type="xref" href="app02.xhtml#appendix_shells">Appendix B</a> for
additional notes.</p>






<section data-type="sect1" data-pdf-bookmark="Visiting Specific Directories Efficiently"><div class="sect1" id="idm46586641930160">
<h1>Visiting Specific Directories Efficiently</h1>

<p><a data-type="indexterm" data-primary="visiting a directory" id="idm46586641928752"/><a data-type="indexterm" data-primary="directory" data-secondary="visiting efficiently" id="idm46586641927824"/>
If you ask 10 Linux experts what is the most tedious aspect of the
command line, seven of them will say, “Typing long directory
paths.”<sup><a data-type="noteref" id="idm46586641926592-marker" href="ch04.xhtml#idm46586641926592">1</a></sup> After all, if
your work files are in
<em>/home/smith/Work/Projects/Apps/Neutron-Star/src/include</em>, your
financial documents are in
<em>/home/smith/Finances/Bank/Checking/Statements</em>, and your videos are
in <em>/data/Arts/Video/Collection</em>, it’s no fun to retype these
paths over and over. In this section, you’ll learn techniques to
navigate to a given directory efficiently.</p>








<section data-type="sect2" data-pdf-bookmark="Jump to Your Home Directory"><div class="sect2" id="idm46586641924304">
<h2>Jump to Your Home Directory</h2>

<p><a data-type="indexterm" data-primary="home directory" data-secondary="changing directory to" id="idm46586641922784"/><a data-type="indexterm" data-primary="directory" data-secondary="home directory" data-tertiary="changing directory to" id="idm46586641921808"/><a data-type="indexterm" data-primary="changing" data-secondary="directory" id="idm46586641920592"/><a data-type="indexterm" data-primary="path" data-secondary="home directory" id="idm46586641919648"/>
Let’s begin with the basics. No matter where you go in the
filesystem, you can return to your home directory by running <code>cd</code> with
no arguments:<a data-type="indexterm" data-primary="cd command" data-secondary="without arguments" id="idm46586641918048"/></p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/etc                              <em>Start somewhere else</em>
$ <strong>cd</strong>                              <em>Run cd with no arguments...</em>
$ <strong>pwd</strong>
/home/smith                       <em>...and you're home again</em></pre>

<p>To jump to subdirectories within your home directory from anywhere in
the filesystem, refer to your home directory with a shorthand rather
than an absolute path such as <em>/home/smith</em>. One shorthand is the shell
variable <code>HOME</code>:<a data-type="indexterm" data-primary="home directory" data-secondary="HOME variable" id="idm46586641912304"/><a data-type="indexterm" data-primary="variables" data-secondary="HOME" id="idm46586641911296"/><a data-type="indexterm" data-primary="directory" data-secondary="home directory" data-tertiary="HOME variable" id="idm46586641910352"/></p>

<pre data-type="programlisting">$ <strong>cd $HOME/Work</strong></pre>

<p>Another is a tilde:<a data-type="indexterm" data-primary="tilde (~)" data-secondary="home directory" id="idm46586641907744"/><a data-type="indexterm" data-primary="home directory" data-secondary="tilde shortcut" id="idm46586641906736"/><a data-type="indexterm" data-primary="directory" data-secondary="home directory" data-tertiary="tilde shortcut" id="idm46586641905792"/><a data-type="indexterm" data-primary="~ (tilde)" data-secondary="home directory" id="idm46586641904576"/></p>

<pre data-type="programlisting">$ <strong>cd ~/Work</strong></pre>

<p>Both <code>$HOME</code> and <code>~</code> are expressions expanded by the shell, a fact
that you can verify by echoing them to stdout:</p>

<pre data-type="programlisting">$ <strong>echo $HOME ~</strong>
/home/smith /home/smith</pre>

<p>The tilde can also refer to another user’s home directory if you place
it immediately in front of their
username:<a data-type="indexterm" data-primary="tilde (~)" data-secondary="preceding a username" id="idm46586641899504"/><a data-type="indexterm" data-primary="~ (tilde)" data-secondary="preceding a username" id="idm46586641898528"/></p>

<pre data-type="programlisting">$ <strong>echo ~jones</strong>
/home/jones</pre>
</div></section>













<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Move Faster with Tab Completion"><div class="sect2" id="idm46586641923712">
<h2>Move Faster with Tab Completion</h2>

<p><a data-type="indexterm" data-primary="tab completion" id="tabcompletion"/><a data-type="indexterm" data-primary="filenames" data-secondary="completion" id="idm46586641893712"/><a data-type="indexterm" data-primary="cd command" data-secondary="tab completion" id="idm46586641892768"/><a data-type="indexterm" data-primary="directory" data-secondary="changing" data-tertiary="tab completion" id="idm46586641891824"/><a data-type="indexterm" data-primary="changing" data-secondary="directory" data-tertiary="tab completion" id="idm46586641890608"/>
When you’re entering <code>cd</code> commands, save typing by pressing the Tab
key to produce directory names automatically. As a demonstration,
visit a directory that contains subdirectories, such as <em>/usr</em>:</p>

<pre data-type="programlisting">$ <strong>cd /usr</strong>
$ <strong>ls</strong>
bin  games  include  lib  local  sbin  share  src</pre>

<p>Suppose you want to visit the subdirectory <em>share</em>. Type <code>sha</code> and
press the Tab key once:</p>
<pre data-type="programlisting">$ <strong>cd sha</strong><em>&lt;Tab&gt;</em></pre>

<p>The shell completes the directory name for you:</p>

<pre data-type="programlisting">$ <strong>cd share/</strong></pre>

<p>This handy shortcut is called <em>tab completion</em>. It works immediately
when the text that you’ve typed matches a single directory name.
When the text matches multiple directory names, your shell needs
more information to complete the desired name. Suppose you had typed
only <code>s</code> and pressed Tab:</p>
<pre data-type="programlisting">$ <strong>cd s</strong><em>&lt;Tab&gt;</em></pre>

<p>The shell cannot complete the name <em>share</em> (yet) because
other directory names begin with <code>s</code> too: <em>sbin</em> and <em>src</em>. Press
Tab a second time and the shell prints all possible completions to
guide you:</p>
<pre data-type="programlisting">$ <strong>cd s</strong><em>&lt;Tab&gt;&lt;Tab&gt;</em>
sbin/  share/  src/</pre>

<p>and waits for your next action. To resolve the ambiguity, type another
character, <code>h</code>, and press Tab once:</p>
<pre data-type="programlisting">$ <strong>cd sh</strong><em>&lt;Tab&gt;</em></pre>

<p>The shell completes the name of the directory for you, from <em>sh</em> to <em>share</em>:</p>

<pre data-type="programlisting">$ <strong>cd share/</strong></pre>

<p>In general, press Tab once to perform as much completion as possible,
or press twice to print all possible completions. The more characters
you type, the less ambiguity and the better the match.</p>

<p>Tab completion is great for speeding up navigation. Instead of typing
a lengthy path like <em>/home/smith/Projects/Web/src/include</em>, type
as little as you want and keep pressing the Tab key. You’ll get the
hang of it quickly with practice.</p>
<div data-type="note" epub:type="note"><h1>Tab Completion Varies by Program</h1>
<p>Tab completion isn’t just for <code>cd</code> commands.<a data-type="indexterm" data-primary="tab completion" data-secondary="varies by program" id="idm46586641868128"/> It works for most
commands, though its behavior may differ. When the command is
<code>cd</code>, the Tab key completes directory names.  For other commands that
operate on files, such as <code>cat</code>, <code>grep</code>, and <code>sort</code>, tab completion
expands filenames too. If the command is <code>ssh</code><a data-type="indexterm" data-primary="SSH" data-secondary="ssh command" data-tertiary="tab completion" id="idm46586641864720"/> (secure shell), it
completes hostnames. If the command is <code>chown</code><a data-type="indexterm" data-primary="chown command" data-secondary="tab completion" id="idm46586641863008"/> (change the owner of a
file), it completes usernames. You can even create your own completion
rules for speed, as we’ll see in <a data-type="xref" href="#ex_qcd">Example 4-1</a>. Also see <code>man bash</code> and
read its topic “programmable completion.”<a data-type="indexterm" data-startref="tabcompletion" id="idm46586641860480"/></p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Hop to Frequently Visited Directories Using Aliases or Variables"><div class="sect2" id="idm46586641895888">
<h2>Hop to Frequently Visited Directories Using Aliases or Variables</h2>

<p><a data-type="indexterm" data-primary="aliases" data-secondary="changing directory with" id="idm46586641858464"/><a data-type="indexterm" data-primary="variables" data-secondary="directory paths held by" id="idm46586641857488"/><a data-type="indexterm" data-primary="cd command" data-secondary="alias for" id="idm46586641856544"/><a data-type="indexterm" data-primary="directory" data-secondary="changing" data-tertiary="alias for" id="idm46586641855600"/><a data-type="indexterm" data-primary="directory" data-secondary="variable for" id="idm46586641854384"/>
If you visit a faraway directory frequently, such as
<em>/home/smith/Work/⁠Projects​/Web/src/include</em>, create an alias that
performs the <code>cd</code> operation:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># In a shell configuration file:</code>
<code class="nb">alias</code> <code class="nv">work</code><code class="o">=</code><code class="s2">"cd </code><code class="nv">$HOME</code><code class="s2">/Work/Projects/Web/src/include"</code></pre>

<p>Simply run the alias anytime to reach your destination:</p>

<pre data-type="programlisting">$ <strong>work</strong>
$ <strong>pwd</strong>
/home/smith/Work/Projects/Web/src/include</pre>

<p>Alternatively, create a variable to hold the directory path:<a data-type="indexterm" data-primary="path" data-secondary="variable for" id="idm46586641847056"/><a data-type="indexterm" data-primary="variables" data-secondary="path as value" id="idm46586641846144"/></p>

<pre data-type="programlisting">$ <strong>work=$HOME/Work/Projects/Web/src/include</strong>
$ <strong>cd $work</strong>
$ <strong>pwd</strong>
/home/smith/Work/Projects/Web/src/include
$ <strong>ls $work/css</strong>                                <em>Use the variable in other ways</em>
main.css  mobile.css</pre>
<div data-type="tip" class="pagebreak-after" id="tip_edit_alias"><h1>Edit Frequently Edited Files with an Alias</h1>
<p>Sometimes, the reason for visiting a directory frequently is to edit a
particular file.<a data-type="indexterm" data-primary="aliases" data-secondary="frequently edited files" id="idm46586641828160"/><a data-type="indexterm" data-primary="editing files" data-secondary="alias for" id="idm46586641827184"/> If that’s the case, consider defining an alias to
edit that file by absolute path without changing directory. The
following alias definition lets you edit <em>$HOME/.bashrc</em>, no matter
where you are in the filesystem, by running <code>rcedit</code>. No <code>cd</code> is required:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Place in a shell configuration file and source it:</code>
<code class="nb">alias</code> <code class="nv">rcedit</code><code class="o">=</code><code class="s1">'$EDITOR $HOME/.bashrc'</code></pre>
</div>

<p>If you regularly visit lots of directories with long paths, you can
create aliases or variables for each of them. This approach has some
disadvantages, however:</p>

<ul>
<li>
<p>It’s hard to remember all those aliases/variables.</p>
</li>
<li>
<p>You might accidentally create an alias with the same name as an
existing command, causing a conflict.</p>
</li>
</ul>

<p>An alternative is to create a shell function like the one in<a data-type="indexterm" data-primary="cd command" data-secondary="shell function for quick cd" id="idm46586641800560"/><a data-type="indexterm" data-primary="function for quick cd" id="idm46586641799712"/><a data-type="indexterm" data-primary="shell" data-secondary="functions" id="idm46586641799072"/>
<a data-type="xref" href="#ex_qcd">Example 4-1</a>, which I’ve named <code>qcd</code><a data-type="indexterm" data-primary="qcd example" id="idm46586641796880"/> (“quick cd”). This function accepts
a string key as an argument, such as <code>work</code> or <code>recipes</code>, and runs
<code>cd</code> to a selected directory path.</p>
<div id="ex_qcd" data-type="example">
<h5><span class="label">Example 4-1. </span>A function for <code>cd</code>-ing to faraway directories</h5>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Define the qcd function</code>
qcd <code class="o">()</code> <code class="o">{</code>
  <code class="c1"># Accept 1 argument that's a string key, and perform a different</code>
  <code class="c1"># "cd" operation for each key.</code>
  <code class="k">case</code> <code class="s2">"</code><code class="nv">$1</code><code class="s2">"</code> <code class="k">in</code>
    work<code class="o">)</code>
      <code class="nb">cd</code> <code class="nv">$HOME</code>/Work/Projects/Web/src/include
      <code class="p">;;</code>
    recipes<code class="o">)</code>
      <code class="nb">cd</code> <code class="nv">$HOME</code>/Family/Cooking/Recipes
      <code class="p">;;</code>
    video<code class="o">)</code>
      <code class="nb">cd</code> /data/Arts/Video/Collection
      <code class="p">;;</code>
    beatles<code class="o">)</code>
      <code class="nb">cd</code> <code class="nv">$HOME</code>/Music/mp3/Artists/B/Beatles
      <code class="p">;;</code>
    *<code class="o">)</code>
      <code class="c1"># The supplied argument was not one of the supported keys</code>
      <code class="nb">echo</code> <code class="s2">"qcd: unknown key '</code><code class="nv">$1</code><code class="s2">'"</code>
      <code class="k">return</code> <code class="m">1</code>
      <code class="p">;;</code>
  <code class="k">esac</code>
  <code class="c1"># Helpfully print the current directory name to indicate where you are</code>
  <code class="nb">pwd</code>
<code class="o">}</code>
<code class="c1"># Set up tab completion</code>
<code class="nb">complete</code> -W <code class="s2">"work recipes video beatles"</code> qcd</pre></div>

<p>Store the function in a shell configuration file such as
<em>$HOME/.bashrc</em> (see <a data-type="xref" href="ch02.xhtml#section_environments1">“Environments and Initialization Files, the Short Version”</a>), source it, and it’s
ready to run. Type <code>qcd</code> followed by one of the supported keys to
quickly visit the associated directory:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>qcd beatles</strong>
/home/smith/Music/mp3/Artists/B/Beatles</pre>

<p>As a bonus, the script’s final line runs the command <code>complete</code>,<a data-type="indexterm" data-primary="complete command" id="idm46586641726832"/><a data-type="indexterm" data-primary="builtins" data-secondary="complete" id="idm46586641726096"/><a data-type="indexterm" data-primary="tab completion" data-secondary="customized" id="idm46586641725152"/> a
shell builtin that sets up customized tab completion for <code>qcd</code>, so it
completes the four supported keys. Now you don’t have to remember
<code>qcd</code>’s arguments!  Just type <code>qcd</code> followed by a space and press the
Tab key twice, and the shell will print all the keys for your
reference, and you can complete any of them in the usual way:</p>
<pre data-type="programlisting">$ <strong>qcd </strong><em>&lt;Tab&gt;&lt;Tab&gt;</em>
beatles  recipes  video    work
$ <strong>qcd v</strong><em>&lt;Tab&gt;&lt;Enter&gt;</em>                       <em>Completes 'v' to 'video'</em>
/data/Arts/Video/Collection</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Make a Big Filesystem Feel Smaller with CDPATH"><div class="sect2" id="idm46586641859312">
<h2>Make a Big Filesystem Feel Smaller with CDPATH</h2>

<p><a data-type="indexterm" data-primary="cd command" data-secondary="CDPATH variable" id="idm46586641679632"/><a data-type="indexterm" data-primary="variables" data-secondary="CDPATH" id="idm46586641678432"/><a data-type="indexterm" data-primary="cd command" data-secondary="search path" id="idm46586641677488"/><a data-type="indexterm" data-primary="CDPATH variable" id="idm46586641676544"/><a data-type="indexterm" data-primary="search path" data-secondary="CDPATH variable" id="idm46586641675872"/>
The <code>qcd</code> function handles only the directories that you specify. The
shell provides a more general <code>cd</code>-ing solution without this
shortcoming, called a <em>cd search path</em>. This shell feature transformed
how I navigate the Linux filesystem.</p>

<p>Suppose you have an important subdirectory that you visit often, named
<em>Photos</em>. It’s located at <em>/home/smith/Family/Memories/Photos</em>.  As
you cruise around the filesystem, anytime you want to get to the
<em>Photos</em> directory, you may have to type a long path, such as:</p>

<pre data-type="programlisting">$ <strong>cd ~/Family/Memories/Photos</strong></pre>

<p>Wouldn’t it be great if you could shorten this path to just <em>Photos</em>,
no matter where you are in the filesystem, and reach your
subdirectory?</p>

<pre data-type="programlisting">$ <strong>cd Photos</strong></pre>

<p>Normally, this command would fail:</p>

<pre data-type="programlisting">bash: cd: Photos: No such file or directory</pre>

<p>unless you happen to be in the correct parent directory
(<em>~/Family/Memories</em>) or some other directory with a <em>Photos</em>
subdirectory by coincidence. Well, with a little setup, you can
instruct <code>cd</code> to search for your <em>Photos</em> subdirectory in locations
other than your current directory. The search is lightning fast and
looks only in parent directories that you specify. For example, you
could instruct <code>cd</code> to search <em>$HOME/Family/Memories</em> in addition to
the current directory. Then, when you type <code>cd Photos</code> from elsewhere
in the filesystem, <code>cd</code> will succeed:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>pwd</strong>
/etc
$ <strong>cd Photos</strong>
/home/smith/Family/Memories/Photos</pre>

<p>A cd search path works like your command search path, <code>$PATH</code>, but
instead of finding commands, it finds subdirectories. Configure it
with the shell variable <code>CDPATH</code>, which has the same format as <code>PATH</code>:
a list of directories separated by colons.<a data-type="indexterm" data-primary=": (colon)" data-secondary="CDPATH separator" id="idm46586641659824"/><a data-type="indexterm" data-primary="colon (:)" data-secondary="CDPATH separator" id="idm46586641658848"/><a data-type="indexterm" data-primary="separator" data-secondary="colon" data-tertiary="CDPATH" id="idm46586641657904"/>
If your <code>CDPATH</code> consists of these four directories, for example:</p>

<pre data-type="programlisting">$HOME:$HOME/Projects:$HOME/Family/Memories:/usr/local</pre>

<p>and you type:</p>

<pre data-type="programlisting">$ <strong>cd Photos</strong></pre>

<p>then <code>cd</code> will check the existence of the following directories in
order, until it finds one or it fails entirely:</p>
<ol>
<li>
<p><em>Photos</em> in the current directory</p>
</li>
<li>
<p><em>$HOME/Photos</em></p>
</li>
<li>
<p><em>$HOME/Projects/Photos</em></p>
</li>
<li>
<p><em>$HOME/Family/Memories/Photos</em></p>
</li>
<li>
<p><em>/usr/local/Photos</em></p>
</li>

</ol>

<p>In this case, <code>cd</code> succeeds on its fourth try and changes directory to
<em>$HOME/Family/Memories/Photos</em>. If two directories in <code>$CDPATH</code> have a
subdirectory named <em>Photos</em>, the earlier parent wins.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Ordinarily, a successful <code>cd</code> prints no output.  When <code>cd</code> locates a
directory using your <code>CDPATH</code>, however, it prints<a data-type="indexterm" data-primary="cd command" data-secondary="printing absolute path" id="idm46586641642560"/> the absolute path on
stdout to inform you of your new current directory:</p>

<pre data-type="programlisting">$ <strong>CDPATH=/usr</strong>     <em>Set a CDPATH</em>
$ <strong>cd /tmp</strong>         <em>No output: CDPATH wasn't consulted</em>
$ <strong>cd bin</strong>          <em>cd consults CDPATH...</em>
/usr/bin          <em>...and prints the new working directory</em></pre>
</div>

<p>Fill <code>CDPATH</code> with your most important or frequently used parent
directories, and you can <code>cd</code> into any of their subdirectories from
anywhere in the filesystem, no matter how deep they are, without
typing most of the path. Trust me, this is <em>awesome</em>, and the following
case study should prove it.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Organize Your Home Directory for Fast Navigation"><div class="sect2" id="cs_homedir">
<h2>Organize Your Home Directory for Fast Navigation</h2>

<p><a data-type="indexterm" data-primary="home directory" data-secondary="organizing" id="idm46586641633392"/><a data-type="indexterm" data-primary="directory" data-secondary="home directory" data-tertiary="organizing" id="idm46586641632416"/>
Let’s use <code>CDPATH</code><a data-type="indexterm" data-primary="cd command" data-secondary="CDPATH variable" data-tertiary="organizing home directory" id="idm46586641630784"/><a data-type="indexterm" data-primary="CDPATH variable" data-secondary="organizing home directory" id="idm46586641629568"/> to simplify the way you navigate your home
directory. With a little configuration, you can make many directories
within your home directory easily accessible with minimal typing, no
matter where you are in the filesystem. This technique works best if
your home directory is well organized with at least two levels of
subdirectories. <a data-type="xref" href="#fig_cs_cdpath">Figure 4-1</a> shows an example of a well-organized
directory layout.</p>

<figure><div id="fig_cs_cdpath" class="figure">
<img src="Images/elcl_0401.png" alt="Two levels of subdirectories in the directory /home/smith" width="600" height="428"/>
<h6><span class="label">Figure 4-1. </span>Two levels of subdirectories in the directory <em>/home/smith</em></h6>
</div></figure>

<p>The trick is to set up your <code>CDPATH</code> to include, in order:</p>
<ol>
<li>
<p><code>$HOME</code></p>
</li>
<li>
<p>Your choice of subdirectories of <code>$HOME</code></p>
</li>
<li>
<p>The relative path for a parent directory, indicated by two dots (<code>..</code>)<a data-type="indexterm" data-primary=".. (dot dot)" data-secondary="parent directory" data-tertiary="CDPATH" id="idm46586641620448"/><a data-type="indexterm" data-primary="dot (.)" data-secondary="dot dot (..)" data-tertiary="parent directory" id="idm46586641619168"/><a data-type="indexterm" data-primary="directory" data-secondary="parent directory" id="idm46586641617952"/><a data-type="indexterm" data-primary="parent directory" id="idm46586641617008"/></p>
</li>

</ol>

<p>By including <code>$HOME</code>, you can jump immediately to any of its
subdirectories (<em>Family</em>, <em>Finances</em>, <em>Linux</em>, <em>Music</em>, and <em>Work</em>)
from anywhere else in the filesystem without typing a leading path:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/etc                                   <em>Begin outside your home directory</em>
$ <strong>cd Work</strong>
/home/smith/Work
$ <strong>cd Family/School</strong>                     <em>You jumped 1 level below $HOME</em>
/home/smith/Family/School</pre>

<p>By including subdirectories of <code>$HOME</code> in your <code>CDPATH</code>, you can jump into
<em>their</em> 
<span class="keep-together">subdirectories</span> in one shot:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/etc                                   <em>Anywhere outside your home directory</em>
$ <strong>cd School</strong>
/home/smith/Family/School              <em>You jumped 2 levels below $HOME</em></pre>

<p>All the directories in your <code>CDPATH</code> so far are absolute paths in
<code>$HOME</code> and its subdirectories. By including the relative path
<code>..</code> however, you empower new <code>cd</code> behavior in <em>every</em> directory. No matter
where you are in the filesystem, you can jump to any 
<span class="keep-together"><em>sibling</em></span>
directory (<em>../<code>sibling</code></em>) by name without typing the two dots,
because <code>cd</code> will search your current parent. For example, if you’re in
<em>/usr/bin</em> and want to move to <em>/usr/lib</em>, all you need is <code>cd lib</code>:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/usr/bin                              <em>Your current directory</em>
$ <strong>ls ..</strong>
bin   include   lib   src             <em>Your siblings</em>
$ <strong>cd lib</strong>
/usr/lib                              <em>You jumped to a sibling</em></pre>

<p>Or, if you’re a programmer working on code that has subdirectories
<em>src</em>, <em>include</em>, and <em>docs</em>:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/usr/src/myproject
$ <strong>ls</strong>
docs   include   src</pre>

<p>you can jump between the subdirectories concisely:</p>

<pre data-type="programlisting">$ <strong>cd docs</strong>                            <em>Change your current directory</em>
$ <strong>cd include</strong>
/usr/src/myproject/include           <em>You jumped to a sibling</em>
$ <strong>cd src</strong>
/usr/src/myproject/src               <em>Again</em></pre>

<p>A <code>CDPATH</code> for the tree in <a data-type="xref" href="#fig_cs_cdpath">Figure 4-1</a> might contain six items:
your home directory, four of its subdirectories, and the relative path
for a parent directory:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Place in a shell configuration file and source it:</code>
<code class="nb">export</code> <code class="nv">CDPATH</code><code class="o">=</code><code class="nv">$HOME</code>:<code class="nv">$HOME</code>/Work:<code class="nv">$HOME</code>/Family:<code class="nv">$HOME</code>/Linux:<code class="nv">$HOME</code>/Music:..</pre>

<p>After sourcing the configuration file, you can <code>cd</code> to a large number
of important directories without typing long directory paths, just
short directory names. Hooray!</p>

<p>This technique works best if all subdirectories beneath the
<code>CDPATH</code> directories have unique names. If you have duplicate names,
such as <em>$HOME/Music</em> and <em>$HOME/Linux/Music</em>, you might not get the
behavior you want. The command <code>cd Music</code> will always check <em>$HOME</em>
before <em>$HOME/Linux</em> and consequently will not locate
<em>$HOME/Linux/Music</em> by search.</p>

<p>To check for duplicate subdirectory names<a data-type="indexterm" data-primary="duplicate detection" data-secondary="subdirectory names" id="idm46586641563968"/> in the first two levels of
<code>$HOME</code>, try this brash one-liner<a data-type="indexterm" data-primary="brash one-liner" id="idm46586641562480"/>.  It lists all
subdirectories and sub-subdirectories of <code>$HOME</code>, isolates the
sub-subdirectory names with <code>cut</code>, sorts the list, and counts
occurrences with <code>uniq</code>:<a data-type="indexterm" data-primary="uniq command" data-secondary="examples" id="idm46586641560304"/><a data-type="indexterm" data-primary="cut command" data-secondary="examples" id="idm46586641559296"/><a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586641558352"/></p>
<pre data-type="programlisting">$ <strong>cd</strong>
$ <strong>ls -d */ &amp;&amp; (ls -d */*/ | cut -d/ -f2-) | sort | uniq -c | sort -nr | less</strong></pre>

<p>You may recognize this duplicate-checking technique from
<a data-type="xref" href="ch01.xhtml#sec_duplicate_files">“Detecting Duplicate Files”</a>. If the output displays any counts greater
than 1, you have duplicates. I realize this command includes a few features
I haven’t covered yet. You’ll learn double ampersand (<code>&amp;&amp;</code>)<a data-type="indexterm" data-primary="&amp;&amp; for conditional list" id="idm46586641554096"/><a data-type="indexterm" data-primary="ampersand (&amp;)" data-secondary="&amp;&amp; for conditional list" id="idm46586641553360"/> in <a data-type="xref" href="ch07.xhtml#section_conditional_lists">“Technique #1: Conditional Lists”</a>
and the parentheses<a data-type="indexterm" data-primary="() (parentheses)" data-secondary="subshell" data-tertiary="examples" id="idm46586641551488"/><a data-type="indexterm" data-primary="parentheses ()" data-secondary="subshell" data-tertiary="examples" id="idm46586641550240"/>
in <a data-type="xref" href="ch07.xhtml#section_explicit_subshells">“Technique #10: Explicit Subshells”</a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Returning to Directories Efficiently"><div class="sect1" id="idm46586641634624">
<h1>Returning to Directories Efficiently</h1>

<p><a data-type="indexterm" data-primary="returning to a directory" id="idm46586641529744"/><a data-type="indexterm" data-primary="directory" data-secondary="returning efficiently" id="idm46586641529136"/><a data-type="indexterm" data-primary="changing" data-secondary="directory" data-tertiary="returning efficiently" id="idm46586641528288"/>
You’ve just seen how to visit a directory efficiently. Now I’ll show
you how to revisit a directory quickly when you need to go back.</p>








<section data-type="sect2" data-pdf-bookmark="Toggle Between Two Directories with “cd -”"><div class="sect2" id="idm46586641526784">
<h2>Toggle Between Two Directories with “cd -”</h2>

<p><a data-type="indexterm" data-primary="cd command" data-secondary="dash argument (-)" id="idm46586641525312"/><a data-type="indexterm" data-primary="- (dash)" data-secondary="cd command" id="idm46586641524336"/><a data-type="indexterm" data-primary="dash (-)" data-secondary="cd command" id="idm46586641523392"/><a data-type="indexterm" data-primary="directory" data-secondary="toggling" id="idm46586641522448"/><a data-type="indexterm" data-primary="swapping directories" data-secondary="cd - (dash)" id="idm46586641521504"/>
Suppose you’re working in a deep directory and you run <code>cd</code> to go
somewhere else:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/home/smith/Finances/Bank/Checking/Statements
$ <strong>cd /etc</strong></pre>

<p>and then think, “No, wait, I want to go back to the <em>Statements</em>
directory where I just was.” Don’t retype the long directory
path. Just run <code>cd</code> with a dash as an argument:</p>

<pre data-type="programlisting">$ <strong>cd -</strong>
/home/smith/Finances/Bank/Checking/Statements</pre>

<p>This command returns your shell to its previous directory and
helpfully prints its absolute path so you know where you are.</p>

<p>To jump back and forth between a pair of directories, run <code>cd -</code>
repeatedly. This is a time-saver when you’re doing focused work in two
directories in a single shell. There’s a catch, however: the shell
remembers just one previous directory at a time. For example, if you
are toggling between <em>/usr/local/bin</em> and <em>/etc</em>:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/usr/local/bin
$ <strong>cd /etc</strong>                 <em>The shell remembers /usr/local/bin</em>
$ <strong>cd -</strong>                    <em>The shell remembers /etc</em>
/usr/local/bin
$ <strong>cd -</strong>                    <em>The shell remembers /usr/local/bin</em>
/etc</pre>

<p>and you run <code>cd</code> without arguments to jump to your home directory:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>cd</strong>                      <em>The shell remembers /etc</em></pre>

<p>the shell has now forgotten <em>/usr/local/bin</em> as a previous directory:</p>

<pre data-type="programlisting">$ <strong>cd -</strong>                    <em>The shell remembers your home directory</em>
/etc
$ <strong>cd -</strong>                    <em>The shell remembers /etc</em>
/home/smith</pre>

<p>The next technique overcomes this limitation.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Toggle Among Many Directories with pushd and popd"><div class="sect2" id="idm46586641526192">
<h2>Toggle Among Many Directories with pushd and popd</h2>

<p><a data-type="indexterm" data-primary="pushd command" id="idm46586641501952"/><a data-type="indexterm" data-primary="builtins" data-secondary="pushd" id="idm46586641501248"/><a data-type="indexterm" data-primary="popd command" id="idm46586641500304"/><a data-type="indexterm" data-primary="builtins" data-secondary="popd" id="idm46586641499632"/><a data-type="indexterm" data-primary="swapping directories" data-secondary="pushd and popd" id="idm46586641498688"/><a data-type="indexterm" data-primary="directory" data-secondary="swapping" id="idm46586641497744"/><a data-type="indexterm" data-primary="cd command" data-secondary="directory stack" id="idm46586641496800"/>
The <code>cd -</code> command toggles between two directories,
but what if you have three or more to keep track of? Suppose you’re
creating a local website on your Linux computer. This task often
involves four or more directories:</p>

<ul>
<li>
<p>The location of live, deployed web pages, such as <em>/var/www/html</em></p>
</li>
<li>
<p>The web-server configuration directory, often <em>/etc/apache2</em></p>
</li>
<li>
<p>The location of SSL certificates<a data-type="indexterm" data-primary="SSL certificates" id="idm46586641491728"/>, often <em>/etc/ssl/certs</em></p>
</li>
<li>
<p>Your work directory, such as <em>~/Work/Projects/Web/src</em></p>
</li>
</ul>

<p>Believe me, it’s tedious to keep typing:</p>
<pre data-type="programlisting">$ <strong>cd ~/Work/Projects/Web/src</strong>
$ <strong>cd /var/www/html</strong>
$ <strong>cd /etc/apache2</strong>
$ <strong>cd ~/Work/Projects/Web/src</strong>
$ <strong>cd /etc/ssl/certs</strong></pre>

<p>If you have a large, windowing display, you can ease the burden by
opening a separate shell window for each directory. But if you’re
working in a single shell (say, over an<a data-type="indexterm" data-primary="SSH" data-secondary="directory stack" id="idm46586641484992"/> SSH connection), take
advantage of a shell feature called a <em>directory stack</em>.<a data-type="indexterm" data-primary="directory" data-secondary="stack" data-seealso="pushd command" id="idm46586641483424"/> It lets you
quickly travel among multiple directories with ease, using the
built-in shell commands <code>pushd</code>, <code>popd</code>, and <code>dirs</code>.<a data-type="indexterm" data-primary="dirs command" id="idm46586641480624"/><a data-type="indexterm" data-primary="builtins" data-secondary="dirs" id="idm46586641479888"/> The learning
curve is maybe 15 minutes, and the huge payoff in speed lasts a
lifetime.<sup><a data-type="noteref" id="idm46586641478816-marker" href="ch04.xhtml#idm46586641478816">2</a></sup></p>

<p>A <em>directory stack</em> is a list of directories that you’ve visited in the
current shell and decided to keep track of. You manipulate the stack
by performing two operations called <em>pushing</em> and <em>popping</em>. Pushing<a data-type="indexterm" data-primary="directory" data-secondary="pushing" id="idm46586641472992"/> a
directory adds it to the beginning of the list, which is traditionally
called the <em>top</em> of the stack. Popping<a data-type="indexterm" data-primary="directory" data-secondary="popping" id="idm46586641471376"/> removes the topmost directory
from the stack.<sup><a data-type="noteref" id="idm46586641470176-marker" href="ch04.xhtml#idm46586641470176">3</a></sup><a data-type="indexterm" data-primary="stack of directories" id="idm46586641469536"/> Initially, the stack contains only your current directory, but
you can add (push) and remove (pop) directories and rapidly <code>cd</code> among
them.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Every running shell maintains its own directory stack.</p>
</div>

<p>I’ll begin with the basic operations (pushing, popping, viewing) and
then get to the good stuff.</p>










<section data-type="sect3" data-pdf-bookmark="Push a directory onto the stack"><div class="sect3" id="idm46586641466368">
<h3>Push a directory onto the stack</h3>

<p><a data-type="indexterm" data-primary="pushd command" data-secondary="pushing a directory" id="idm46586641465024"/>
The command <code>pushd</code> (short for “push directory”) does all of the
following:</p>
<ol>
<li>
<p>Adds a given directory to the top of the stack</p>
</li>
<li>
<p>Performs a <code>cd</code> to that directory</p>
</li>
<li>
<p>Prints the stack from top to bottom for your reference</p>
</li>

</ol>

<p>I’ll build a directory stack of four directories, pushing them onto
the stack one at a time:</p>
<pre data-type="programlisting">$ <strong>pwd</strong>
/home/smith/Work/Projects/Web/src
$ <strong>pushd /var/www/html</strong>
/var/www/html ~/Work/Projects/Web/src
$ <strong>pushd /etc/apache2</strong>
/etc/apache2 /var/www/html ~/Work/Projects/Web/src
$ <strong>pushd /etc/ssl/certs</strong>
/etc/ssl/certs /etc/apache2 /var/www/html ~/Work/Projects/Web/src
$ <strong>pwd</strong>
/etc/ssl/certs</pre>

<p>The shell prints the stack after each <code>pushd</code> operation. The current
directory is the leftmost (top) directory.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="View a directory stack"><div class="sect3" id="sec_viewing_directory_stack">
<h3>View a directory stack</h3>

<p><a data-type="indexterm" data-primary="directory" data-secondary="stack" data-tertiary="viewing" id="idm46586641453184"/>
Print a shell’s directory stack with the <code>dirs</code><a data-type="indexterm" data-primary="dirs command" id="idm46586641451488"/> command. It does not
modify the stack:</p>

<pre data-type="programlisting">$ <strong>dirs</strong>
/etc/ssl/certs /etc/apache2 /var/www/html ~/Work/Projects/Web/src</pre>

<p>If you prefer to print the stack from top to bottom, use the <code>-p</code><a data-type="indexterm" data-primary="dirs command" data-secondary="printing vertically (-p option)" id="idm46586641448688"/> option:</p>

<pre data-type="programlisting">$ <strong>dirs -p</strong>
/etc/ssl/certs
/etc/apache2
/var/www/html
~/Work/Projects/Web/src</pre>

<p>and even pipe the output to the command <code>nl</code><a data-type="indexterm" data-primary="nl command" id="idm46586641445584"/><a data-type="indexterm" data-primary="numbering lines of text" id="idm46586641444880"/> to number the lines from
zero onward:</p>

<pre data-type="programlisting">$ <strong>dirs -p | nl -v0</strong>
     0  /etc/ssl/certs
     1  /etc/apache2
     2  /var/www/html
     3  ~/Work/Projects/Web/src</pre>

<p>Even simpler, run <code>dirs -v</code> to print the stack with numbered lines:<a data-type="indexterm" data-primary="dirs command" data-secondary="numbering lines (-v option)" id="idm46586641441936"/></p>

<pre data-type="programlisting">$ <strong>dirs -v</strong>
 0  /etc/ssl/certs
 1  /etc/apache2
 2  /var/www/html
 3  ~/Work/Projects/Web/src</pre>

<p>If you prefer this top-down format, consider making an alias:<a data-type="indexterm" data-primary="dirs command" data-secondary="alias" id="idm46586641439376"/></p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Place in a shell configuration file and source it:</code>
<code class="nb">alias</code> <code class="nv">dirs</code><code class="o">=</code><code class="s1">'dirs -v'</code></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Pop a directory from the stack"><div class="sect3" id="idm46586641454464">
<h3>Pop a directory from the stack</h3>

<p><a data-type="indexterm" data-primary="popd command" data-secondary="single directory" id="idm46586641434112"/>
The <code>popd</code> command (“pop directory”) is the reverse of <code>pushd</code>. It does
all of the 
<span class="keep-together">following:</span></p>
<ol>
<li>
<p>Removes one directory from the top of the stack</p>
</li>
<li>
<p>Performs a <code>cd</code> to the new top directory</p>
</li>
<li>
<p>Prints the stack from top to bottom for your reference</p>
</li>

</ol>

<p>For example, if your stack has four directories:</p>

<pre data-type="programlisting">$ <strong>dirs</strong>
/etc/ssl/certs /etc/apache2 /var/www/html ~/Work/Projects/Web/src</pre>

<p>then repeatedly running <code>popd</code> will traverse these directories from top
to bottom:</p>
<pre data-type="programlisting">$ <strong>popd</strong>
/etc/apache2 /var/www/html ~/Work/Projects/Web/src
$ <strong>popd</strong>
/var/www/html ~/Work/Projects/Web/src
$ <strong>popd</strong>
~/Work/Projects/Web/src
$ <strong>popd</strong>
bash: popd: directory stack empty
$ <strong>pwd</strong>
~/Work/Projects/Web/src</pre>
<div data-type="tip"><h6>Tip</h6>
<p>The <code>pushd</code><a data-type="indexterm" data-primary="pushd command" data-secondary="alias" id="idm46586641410000"/> and <code>popd</code><a data-type="indexterm" data-primary="popd command" data-secondary="alias" id="idm46586641408608"/> commands are such time-savers that I recommend
creating two-character aliases that are as quick to type as <code>cd</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Place in a shell configuration file and source it:</code>
<code class="nb">alias</code> <code class="nv">gd</code><code class="o">=</code><code class="nb">pushd</code>
<code class="nb">alias</code> <code class="nv">pd</code><code class="o">=</code><code class="nb">popd</code></pre>
</div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Swap directories on the stack"><div class="sect3" id="idm46586641378960">
<h3>Swap directories on the stack</h3>

<p><a data-type="indexterm" data-primary="pushd command" data-secondary="swapping directories" id="idm46586641377952"/><a data-type="indexterm" data-primary="swapping directories" data-secondary="pushd and popd" id="idm46586641374608"/>
Now that you can build and empty the directory stack, let’s focus on
practical use cases. <code>pushd</code> with no arguments swaps the top two
directories in the stack and 
<span class="keep-together">navigates</span> to the new top directory. Let’s
jump between <em>/etc/apache2</em> and your work directory several times by
simply running <code>pushd</code>. See how the third directory <em>/var/www/html</em>
remains in the stack as the first two directories swap positions:</p>
<pre data-type="programlisting">$ <strong>dirs</strong>
/etc/apache2 ~/Work/Projects/Web/src /var/www/html
$ <strong>pushd</strong>
~/Work/Projects/Web/src /etc/apache2 /var/www/html
$ <strong>pushd</strong>
/etc/apache2 ~/Work/Projects/Web/src /var/www/html
$ <strong>pushd</strong>
~/Work/Projects/Web/src /etc/apache2 /var/www/html</pre>

<p>Notice that <code>pushd</code> behaves similarly to the <code>cd -</code> command, toggling
between two directories, but it does not have the limitation of
remembering just one directory.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Turn a mistaken cd into a pushd"><div class="sect3" id="idm46586641367184">
<h3>Turn a mistaken cd into a pushd</h3>

<p><a data-type="indexterm" data-primary="pushd command" data-secondary="correcting for cd" id="idm46586641365776"/><a data-type="indexterm" data-primary="cd command" data-secondary="pushd versus" id="idm46586641364800"/>
Suppose you are jumping among several directories with <code>pushd</code> and
you accidentally run <code>cd</code> instead and lose a directory:</p>
<pre data-type="programlisting">$ <strong>dirs</strong>
~/Work/Projects/Web/src /var/www/html /etc/apache2
$ <strong>cd /etc/ssl/certs</strong>
$ <strong>dirs</strong>
/etc/ssl/certs /var/www/html /etc/apache2</pre>

<p>Oops, the accidental <code>cd</code> command replaced <em>~/Work/Projects/Web/src</em>
in the stack with <em>/etc/ssl/certs</em>. But don’t worry.  You can add the
missing directory back to the stack without typing its long path. Just
run <code>pushd</code> twice, once with a dash argument and once without:</p>
<pre data-type="programlisting" class="pagebreak-after">$ <strong>pushd -</strong>
~/Work/Projects/Web/src /etc/ssl/certs /var/www/html /etc/apache2
$ <strong>pushd</strong>
/etc/ssl/certs ~/Work/Projects/Web/src /var/www/html /etc/apache2</pre>

<p>Let’s dissect why this works:</p>

<ul>
<li>
<p>The first <code>pushd</code> returns to your shell’s previous directory,
<em>~/Work/Projects/Web/src</em>, and pushes it onto the
stack. <code>pushd</code>, like <code>cd</code>, accepts a dash as an argument to mean “go
back to my previous directory.”</p>
</li>
<li>
<p>The second <code>pushd</code> command swaps the top two directories, bringing
you back to <em>/etc/ssl/certs</em>. The end result is that you’ve restored
<em>~/Work/Projects/Web/src</em> to the second position in the stack,
exactly where it would have been if you hadn’t made your mistake.</p>
</li>
</ul>

<p>This “oops, I forgot a pushd” command is useful enough that it’s worth
an alias. I call it <code>slurp</code><a data-type="indexterm" data-primary="slurp alias" id="idm46586641336512"/> because in my mind, it “slurps back” a
directory that I lost by mistake:<a data-type="indexterm" data-primary="conditional lists" data-secondary="examples" id="idm46586641335680"/></p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># Place in a shell configuration file and source it:</code>
<code class="nb">alias</code> <code class="nv">slurp</code><code class="o">=</code><code class="s1">'pushd - &amp;&amp; pushd'</code></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Go deeper into the stack"><div class="sect3" id="idm46586641320576">
<h3>Go deeper into the stack</h3>

<p><a data-type="indexterm" data-primary="pushd command" data-secondary="integer argument" id="idm46586641331040"/><a data-type="indexterm" data-primary="popd command" data-secondary="integer argument" id="idm46586641329968"/><a data-type="indexterm" data-primary="directory" data-secondary="stack" data-tertiary="shifting" id="idm46586641329056"/><a data-type="indexterm" data-primary="pushd command" data-secondary="shifting the stack" id="idm46586641327840"/>
What if you want to <code>cd</code> between directories in the stack other than
the top two? <code>pushd</code> and <code>popd</code> accept a positive or negative integer
argument to operate further into the stack. The command:</p>

<pre data-type="programlisting">$ <strong>pushd +<em>N</em></strong></pre>

<p>shifts <em><code>N</code></em> directories from the top of the stack to the bottom
and then performs a <code>cd</code> to the new top directory. A negative argument
(<em><code>-N</code></em>) shifts directories in the opposite direction, from the
bottom to the top, before performing the <code>cd</code>.<sup><a data-type="noteref" id="idm46586641309520-marker" href="ch04.xhtml#idm46586641309520">4</a></sup></p>
<pre data-type="programlisting">$ <strong>dirs</strong>
/etc/ssl/certs ~/Work/Projects/Web/src /var/www/html /etc/apache2
$ <strong>pushd +1</strong>
~/Work/Projects/Web/src /var/www/html /etc/apache2 /etc/ssl/certs
$ <strong>pushd +2</strong>
/etc/apache2 /etc/ssl/certs ~/Work/Projects/Web/src /var/www/html</pre>

<p>In this manner, you can jump to any other directory in the stack with
a simple command. If your stack is long, however, it may be difficult
to judge a directory’s numeric position by eye. So, print the numeric
position of each directory with <code>dirs -v</code>,<a data-type="indexterm" data-primary="dirs command" data-secondary="numbering lines (-v option)" id="idm46586641305904"/> as you did in
<a data-type="xref" href="#sec_viewing_directory_stack">“View a directory stack”</a>:</p>

<pre data-type="programlisting">$ <strong>dirs -v</strong>
 0  /etc/apache2
 1  /etc/ssl/certs
 2  ~/Work/Projects/Web/src
 3  /var/www/html</pre>

<p>To shift <em>/var/www/html</em> to the top of the stack (and make it your current
directory), run <code>pushd +3</code>.</p>

<p>To jump to the directory at the bottom of the stack,<a data-type="indexterm" data-primary="pushd command" data-secondary="jumping to bottom of stack" id="idm46586641301136"/> run <code>pushd -0</code>
(dash zero):</p>
<pre data-type="programlisting">$ <strong>dirs</strong>
/etc/apache2 /etc/ssl/certs ~/Work/Projects/Web/src /var/www/html
$ <strong>pushd -0</strong>
/var/www/html /etc/apache2 /etc/ssl/certs ~/Work/Projects/Web/src</pre>

<p>You also can remove directories from the stack beyond the top
directory,<a data-type="indexterm" data-primary="popd command" data-secondary="removing deeper directories" id="idm46586641283696"/> using <code>popd</code> with a numeric argument. The command:</p>

<pre data-type="programlisting">$ <strong>popd +<em>N</em></strong></pre>

<p>removes the directory in position <em>N</em> from the stack, counting down
from the top. A negative argument (<em><code>-N</code></em>) counts up from the bottom
of the stack instead. Counting begins at zero, so <code>popd +1</code>
removes the second directory from the top:</p>
<pre data-type="programlisting">$ <strong>dirs</strong>
/var/www/html /etc/apache2 /etc/ssl/certs ~/Work/Projects/Web/src
$ <strong>popd +1</strong>
/var/www/html /etc/ssl/certs ~/Work/Projects/Web/src
$ <strong>popd +2</strong>
/var/www/html /etc/ssl/certs</pre>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586641502896">
<h1>Summary</h1>

<p>All of the techniques in this chapter are easy to grasp with a bit of
practice and will save you lots of time and typing. The techniques
I’ve found particularly life changing are:</p>

<ul>
<li>
<p><code>CDPATH</code> for rapid navigation</p>
</li>
<li>
<p><code>pushd</code> and <code>popd</code> for rapid returns</p>
</li>
<li>
<p>The occasional <code>cd -</code> command</p>
</li>
</ul>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586641926592"><sup><a href="ch04.xhtml#idm46586641926592-marker">1</a></sup> I made this up, but it’s surely true.</p><p data-type="footnote" id="idm46586641478816"><sup><a href="ch04.xhtml#idm46586641478816-marker">2</a></sup> An alternative is to open multiple virtual displays using command-line programs like <code>screen</code><a data-type="indexterm" data-primary="screen command" id="idm46586641477824"/> and <code>tmux</code>,<a data-type="indexterm" data-primary="tmux command" id="idm46586641476576"/> which are called <em>terminal multiplexers</em><a data-type="indexterm" data-primary="terminal multiplexer" id="idm46586641475424"/>. They’re more effort to learn than directory stacks but worth a look.</p><p data-type="footnote" id="idm46586641470176"><sup><a href="ch04.xhtml#idm46586641470176-marker">3</a></sup> If you know stacks from computer science, a directory stack is precisely a stack of directory names.</p><p data-type="footnote" id="idm46586641309520"><sup><a href="ch04.xhtml#idm46586641309520-marker">4</a></sup> Programmers may recognize these operations as rotating the stack.</p></div></div></section></div></body></html>