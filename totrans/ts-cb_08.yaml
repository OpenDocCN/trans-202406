- en: Chapter 7\. Variadic Tuple Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuple types are arrays with a fixed length and where every type of each element
    is defined. Tuples are heavily used in libraries like React as it’s easy to destructure
    and name elements, but outside of React they also have gained recognition as a
    nice alternative to objects.
  prefs: []
  type: TYPE_NORMAL
- en: A *variadic tuple type* is a tuple type that has the same properties—defined
    length and the type of each element is known—but where the *exact shape* is yet
    to be defined. They basically tell the type system that there will be some elements,
    but we don’t know yet which ones they will be. They are generic and meant to be
    substituted with real types.
  prefs: []
  type: TYPE_NORMAL
- en: What sounds like a fairly boring feature is much more exciting when we understand
    that tuple types can also be used to describe function signatures, as tuples can
    be spread out to function calls as arguments. This means we can use variadic tuple
    types to get the most information out of functions and function calls, and functions
    that accept functions as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a lot of use cases on how we can use variadic tuple types
    to describe several scenarios where we use functions as parameters and need to
    get the most information from them. Without variadic tuple types, these scenarios
    would be hard to develop or outright impossible. After reading through, you will
    see variadic tuple types as a key feature for functional programming patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Typing a concat Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a `concat` function that takes two arrays and concatenates them. You
    want to have exact types, but using function overloads is too cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use variadic tuple types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`concat` is a lovely helper function that takes two arrays and combines them.
    It uses array spreading and is short, nice, and readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating types for this function can be hard, especially if you have certain
    expectations from your types. Passing in two arrays is easy, but what should the
    return type look like? Are you happy with a single array type in return, or do
    you want to know the types of each element in this array?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go for the latter: we want tuples so we know the type of each element
    we pass to this function. To correctly type a function like this so that it takes
    all possible edge cases into account, we would end up in a sea of overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And this only takes into account arrays that have up to six elements. The combinations
    for typing a function like this with overloads is exhausting. But there is an
    easier way: variadic tuple types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple type in TypeScript is an array with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: The length of the array is defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of each element is known (and does not have to be the same).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, this is a tuple type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A *variadic* tuple type is a tuple type that has the same properties—defined
    length and the type of each element is known—but where the *exact shape* is yet
    to be defined. Since we don’t know the type and length yet, we can only use variadic
    tuple types in generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to rest elements in functions, but the big difference is that
    variadic tuple types can happen anywhere in the tuple, and multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we apply this to the `concat` function, we have to introduce two generic
    parameters, one for each array. Both need to be constrained to arrays. Then, we
    can create a return type that combines both array types in a newly created tuple
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is beautiful; it’s very similar to the actual concatenation in JavaScript.
    The result is also really good: we get a `(string | number)[]`, which is already
    something we can work with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But we work with tuple types. If we want to know *exactly* which elements we
    are concatenating, we have to transform the array types into tuple types, by spreading
    out the generic array type into a tuple type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we also get a tuple type in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The good news is that we don’t lose anything. If we pass arrays where we don’t
    know each element up front, we still get array types in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Being able to describe this behavior in a single type is definitely much more
    flexible and readable than writing every possible combination in a function overload.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Typing a promisify Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert callback-style functions to Promises and have them perfectly
    typed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function arguments are tuple types. Make them generic using variadic tuple types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before Promises were a thing in JavaScript it was very common to do asynchronous
    programming using callbacks. Functions would usually take a list of arguments,
    followed by a callback function that would be executed once the results were there,
    such as functions to load a file or do a very simplified HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Both follow the same pattern: arguments first, a callback with the result last.
    This works but can be clumsy if you have lots of asynchronous calls that result
    in callbacks within callbacks, also known as the [“the pyramid of doom”](https://oreil.ly/Ye3Qr):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Promises take care of that. Not only do they find a way to chain asynchronous
    calls instead of nesting them, they also are the gateway for `async`/`await`,
    allowing us to write asynchronous code in a synchronous form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Much nicer! Thankfully, it is possible to convert every function that adheres
    to the callback pattern to a `Promise`. We want to create a `promisify` function
    to do that for us automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But how do we type this? Variadic tuple types to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: 'Every function head can be described as a tuple type. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can be very flexible in defining it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is also known as a *rest element*, something we have in JavaScript that
    allows you to define functions with an almost limitless argument list, where the
    last element, the rest element, sucks all excess arguments in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this generic tuple function takes an argument list of any type
    and creates a tuple out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The thing is, rest elements always have to be last. In JavaScript, it’s not
    possible to define an almost endless argument list somewhere in between. With
    variadic tuple types, however, we can do this in TypeScript!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look again at the `loadFile` and `request` functions again. If we described
    the parameters of both functions as tuples, they would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look for similarities. Both end with a callback with a varying result
    type. We can align the types for both callbacks by substituting the variations
    with a generic one. Later, in usage, we substitute generics for actual types.
    So `JSON` and `File` become the generic type parameter `Res`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the parameters *before* `Res`. They are arguably totally different,
    but even they have something in common: they are elements within a tuple. This
    calls for a variadic tuple. We know they will have a concrete length and concrete
    types, but right now we just take a placeholder for them. Let’s call them `Args`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So a function type describing both function signatures could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Take your new type for a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we need for the `promisify` function. We are able to extract
    all relevant parameters—the ones before the callback and the result type—and bring
    them into a new order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by inlining the newly created function type directly into the function
    signature of `promisify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`promisify` now reads:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two generic type parameters: `Args`, which needs to be an array (or
    tuple), and `Res`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameter of `promisify` is a function where the first arguments are the
    elements of `Args` and the last argument is a function with a parameter of type
    `Res`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`promisify` returns a function that takes `Args` for parameters and returns
    a `Promise` of `Res`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try out the new typings for `promisify`, you can see that we get exactly
    the type we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it gets even better. If you look at the function signature, it’s absolutely
    clear which arguments we expect, even if they are variadic and will be substituted
    with real types. We can use the same types for the implementation of `promisify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So what does it do?
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_variadic_tuple_types_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We return a function that accepts all parameters except for the callback.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_variadic_tuple_types_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This function returns a newly created `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_variadic_tuple_types_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t have a callback yet, we need to construct it. What does it do?
    It calls the `resolve` function from the `Promise`, producing a result.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_variadic_tuple_types_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: What has been split needs to be brought back together! We add the callback to
    the arguments and call the original function.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. A working `promisify` function for functions that adhere to the
    callback pattern. Perfectly typed. And we even keep the parameter names.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Typing a curry Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You write a `curry` function. *Currying* is a technique that converts a function
    that takes several arguments into a sequence of functions that each takes a single
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: You want to provide excellent types.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combine conditional types with variadic tuple types, always shaving off the
    first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currying is a very well-known technique in functional programming. Currying
    converts a function that takes several arguments into a sequence of functions
    that each takes a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The underlying concept is called “partial application of function arguments.”
    We use it to maximize the reuse of functions. The “Hello, World!” of currying
    implements an `add` function that can partially apply the second argument later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What feels arbitrary at first is useful when you work with long argument lists.
    The following generalized function either adds or removes classes to an `HTMLElement`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prepare everything except for the final event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can reuse `removeToggle` for several events on several elements.
    We can also use `applyClass` for many other situations.
  prefs: []
  type: TYPE_NORMAL
- en: Currying is a fundamental concept of the programming language Haskell and gives
    a nod to the mathematician Haskell Brooks Curry, the namesake for both the programming
    language and the technique. In Haskell, every operation is curried, and programmers
    make good use of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript borrows heavily from functional programming languages, and it is
    possible to implement partial application with its built-in functionality of binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since functions are first-class citizens in JavaScript, we can create a `curry`
    function that takes a function as an argument and collects all arguments before
    executing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The trick is that every function stores the number of defined arguments in its
    `length` property. That’s how we can recursively collect all necessary arguments
    before applying them to the function passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what’s missing? Types! Let’s create a type that works for a currying pattern
    where every sequenced function can take exactly one argument. We do this by creating
    a conditional type that does the inverse of what the `curried` function inside
    the `curry` function does: removing arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s create a `Curried<F>` type. The first thing is to check if the type
    is indeed a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also infer the arguments as `A` and the return type as `R`. Next step, we
    shave off the first parameter as `F`, and store all remaining parameters in `L`
    (for *last*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Should there be no arguments, we return a function that takes no arguments.
    Last check: we check if the remaining parameters are empty. This means we reached
    the end of removing arguments from the argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Should some parameters remain, we call the `Curried` type again, but with the
    remaining parameters. This way, we shave off a parameter step by step, and if
    you take a good look, you can see that the process is almost identical to what
    we do in the `curried` function. Where we deconstruct parameters in `Curried<F>`,
    we collect them again in `curried(fn)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the type done, let’s add it to `curry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We need a few assertions and some `any` because of the flexible nature of the
    type. But with `as` and `any` as keywords, we mark which portions are considered
    unsafe types.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it! We can get curried away!
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Typing a Flexible curry Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `curry` function from [Recipe 7.3](#ch07_currying) allows for an arbitrary
    number of arguments to be passed, but your typings allow you to take only one
    argument at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extend your typings to create function overloads for all possible tuple combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Recipe 7.3](#ch07_currying) we ended up with function types that allow
    us to apply function arguments one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `curry` function itself can take an arbitrary list of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to work on the same use cases but with a lot fewer function invocations.
    So let’s adapt our types to take advantage of the full `curry` experience.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This example illustrates really well how the type system works as just a thin
    layer on top of JavaScript. By adding assertions and `any` at the right positions,
    we effectively define how `curry` should work, whereas the function itself is
    much more flexible. Be aware that when you define complex types on top of complex
    functionality, you might cheat your way to the goal, and it’s in your hands how
    the types work in the end. Test accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to create a type that can produce all possible function signatures
    for every partial application. For the `addThree` function, all possible types
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: See also [Figure 7-1](#img-curry-illustration) for a visualization of all possible
    call graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0701](assets/tscb_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. A graph showing all possible function call combinations of `addThree`
    when curried; there are three branches to start, with a possible fourth branch
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first thing we do is to slightly adapt the way we call the `Curried` helper
    type. In the original type, we do the inference of function arguments and return
    types *in* the helper type. Now we need to carry along the return value over multiple
    type invocations, so we extract the return type and arguments directly in the
    `curry` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we redefine the `Curried` type. It now features two generic type parameters:
    `A` for arguments, `R` for the return type. As a first step, we check if the arguments
    contain tuple elements. We extract the first element `F` and all remaining elements
    `L`. If there are no elements left, we return the return type `R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It’s not possible to extract multiple tuples via the rest operator. That’s why
    we still need to shave off the first element and collect the remaining elements
    in `L`. But that’s OK; we need at least *one* parameter to effectively do partial
    application.
  prefs: []
  type: TYPE_NORMAL
- en: When we are in the `true` branch, we create the function definitions. In the
    previous example, we returned a function that returns a recursive call; now we
    need to provide all possible partial applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since function arguments are nothing but tuple types (see [Recipe 7.2](#ch07_promisify)),
    arguments of function overloads can be described as a union of tuple types. A
    type `Overloads` takes a tuple of function arguments and creates all partial applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass a tuple, we get a union starting from the empty tuple and then growing
    to one argument, then to two arguments, etc., and up to a tuple that includes
    all arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can define all overloads, we take the remaining arguments of the
    original functions’ argument list and create all possible function calls that
    also include the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Applied to the `addThree` example from before, this part would create the first
    argument `F` as `number` and then combine it with `[]`, `[number]`, and `[number,
    number]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the return type. This is again a recursive call to `Curried`, just like
    in [Recipe 7.2](#ch07_promisify). Remember, we chain functions in a sequence.
    We pass in the same return type—we need to get there eventually—but also need
    to pass all remaining arguments that we haven’t spread out in the function overloads.
    So if we call `addThree` only with `number`, the two remaining numbers need to
    be arguments of the next iteration of `Curried`. This is how we create a tree
    of possible invocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get to the possible combinations, we need to remove the arguments we already
    described in the function signature from the remaining arguments. A helper type
    `Remove<T, U>` goes through both tuples and shaves off one element each, until
    one of the two tuples runs out of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Wiring that up to `Curried`, and we get the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`Curried<A, R>` now produces the same call graph as described in [Figure 7-1](#img-curry-illustration)
    but is flexible for all possible functions that we pass in `curry`. Proper type
    safety for maximum flexibility (shout-out to GitHub user Akira Matsuzaki who provided
    the missing piece in their Type Challenges solution).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Typing the Simplest curry function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `curry` functions and their typings are impressive but come with a lot of
    caveats. Are there any simpler solutions?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `curry` function with only a single sequential step. TypeScript can
    figure out the proper types on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the last piece of the `curry` trilogy, I want you to sit back and think
    a bit about what we saw in Recipes [7.3](#ch07_currying) and [7.4](#ch07_flexible_currying).
    We created very complex types that work almost like the actual implementation
    through TypeScript’s metaprogramming features. And while the results are impressive,
    there are some caveats we have to think about:'
  prefs: []
  type: TYPE_NORMAL
- en: The way the types are implemented for both Recipes [7.3](#ch07_currying) and
    [7.4](#ch07_flexible_currying) is a bit different, but the results vary a lot!
    Still, the `curry` function underneath stays the same. The only way this works
    is by using `any` in arguments and type assertions for the return type. What this
    means is that we effectively disable type-checking by forcing TypeScript to adhere
    to our view of the world. It’s great that TypeScript can do that, and at times
    it’s also necessary (such as the creation of new objects), but it can backfire,
    especially when both implementation and types get very complex. Tests for both
    types and implementation are a must. We talk about testing types in [Recipe 12.4](ch12.html#ch12_testing_types).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You lose information. Especially when currying, keeping argument names is essential
    to know which arguments already have applied. The solutions in the earlier recipes
    couldn’t keep argument names but defaulted to a generic-sounding `a` or `args`.
    If your argument types are, for example, all strings, you can’t say which string
    you are currently writing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the result in [Recipe 7.4](#ch07_flexible_currying) gives you proper type-checking,
    autocomplete is limited because of the nature of the type. You know only that
    a second argument is needed the moment you type it. One of TypeScript’s main features
    is giving you the right tooling and information to make you more productive. The
    flexible `Curried` type reduces your productivity to guesswork again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, while those types are impressive, there is no denying that they come
    with some huge trade-offs. This raises the question: should we even go for it?
    I think it really depends on what you try to achieve.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of currying and partial application, there are two camps. The first
    camp loves functional programming patterns and tries to leverage JavaScript’s
    functional capabilities to the max. They want to reuse partial applications as
    much as possible and need advanced currying functionalities. The other camp sees
    the benefit of functional programming patterns in certain situations—for example,
    waiting for the final parameter to give the same function to multiple events.
    They often are happy with applying as much as possible, but then provide the rest
    in a second step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have dealt with only the first camp until now. If you’re in the second camp,
    you most likely only need a currying function that applies a few parameters partially,
    so you can pass in the rest in a second step: no sequence of parameters of one
    argument, and no flexible application of as many arguments as you like. An ideal
    interface would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`curry` is a function that takes another function `f` as an argument and then
    a sequence `t` of parameters of `f`. It returns a function that takes the remaining
    parameters `u` of `f`, which calls `f` with all possible parameters. The function
    could look like this in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the rest and spread operator, `curry` becomes a one-liner. Now let’s
    type this! We will have to use generics, as we deal with parameters that we don’t
    know yet. There’s the return type `R`, as well as both parts of the function’s
    arguments, `T` and `U`. The latter are variadic tuple types and need to be defined
    as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a generic type parameter `T` and `U` comprising the arguments of `f`,
    a type for `f` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Function arguments can be described as tuples, and here we say those function
    arguments should be split into two parts. Let’s inline this type to `curry` and
    use another generic type parameter for the return type `R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s all the types we need: simple, straightforward, and the types look
    very similar to the actual implementation. With a few variadic tuple types, TypeScript
    gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: 100% type safety. TypeScript directly infers the generic types from your usage,
    and they are correct. No laboriously crafted types through conditional types and
    recursion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get autocomplete for all possible solutions. The moment you add a `,` to
    announce the next step of your arguments, TypeScript will adapt types and give
    you a hint about what to expect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t lose any information. Since we don’t construct new types, TypeScript
    keeps the labels from the original type, and we know which arguments to expect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, `curry` is not as flexible as the original version, but for a lot of use
    cases, this might be the right choice. It’s all about the trade-offs we accept
    for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you work with tuples a lot, you can name the elements of your tuple types:
    `type Person = [name: string, age: number];`. Those labels are just annotations
    and are removed after transpilation.'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the `curry` function and its many different implementations stand
    for the many ways you can use TypeScript to solve a particular problem. You can
    go all out with the type system and use it for very complex and elaborate types,
    or you can reduce the scope a bit and let the compiler do the work for you. Your
    choice depends on your goals and what you try to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Creating an Enum from a Tuple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You like how enums make it easy to select valid values, but after reading [Recipe
    3.12](ch03.html#ch03_item_enums) you don’t want to deal with all their caveats.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create your enums from a tuple. Use conditional types, variadic tuple types,
    and the `"length"` property to type the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Recipe 3.12](ch03.html#ch03_item_enums) we discussed all possible caveats
    when using number and string enums. We ended up with a pattern that is much closer
    to the type system but gives you the same developer experience as regular enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a very straightforward pattern with no surprises, but it can result in
    a lot of work for you if you are dealing with lots of entries, especially if you
    want to have string enums:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There is duplication, which may result in typos, which may lead to undefined
    behavior. A helper function that creates an enum like this for you helps deal
    with redundancy and duplication. Let’s say you have a collection of items like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'A helper function `createEnum` iterates through every item, creating an object
    with capitalized keys that point either to a string value or to a number value,
    depending on your input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create types for this! We need to take care of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an object from a tuple. The keys are capitalized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the values of each property key to either a string value or a number value.
    The number values should start at 0 and increase by one with each step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create object keys, we need a union type we can map out. To get all object
    keys, we need to convert our tuple to a union type. A helper type `TupleToUnion`
    takes a string tuple and converts it to a union type. Why only string tuples?
    Because we need object keys, and string keys are the easiest to use.
  prefs: []
  type: TYPE_NORMAL
- en: '`TupleToUnion<T>` is a recursive type. Like we did in other lessons, we are
    shaving off single elements—this time at the end of the tuple—and then calling
    the type again with the remaining elements. We put each call in a union, effectively
    getting a union type of tuple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'With a map type and a string manipulation type, we can create the string enum
    version of `Enum<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For the number enum version, we need to get a numerical representation of each
    value. If we think about it, we have already stored it somewhere in our original
    data. Let’s look at how `TupleToUnion` deals with a four-element tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look closely, you can see that the length of the tuple is decreasing
    with each call. First, it’s three elements, then two, then one, and ultimately
    there are no elements left. Tuples are defined by the length of the array and
    the type at each position in the array. TypeScript stores the length as a number
    for tuples, accessible via the `"length"` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'So with each recursive call, we can get the length of the remaining elements
    and use this as a value for the enum. Instead of just returning the enum keys,
    we return an object with the key and its possible number value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this newly created object to decide whether we want to have number values
    or string values in our enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s it! We wire up our new `Enum<T, N>` type to the `createEnum` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Being able to access the length of a tuple within the type system is one of
    the hidden gems in TypeScript. This allows for many things, as shown in this example,
    but also fun stuff like implementing calculators in the type system. As with all
    advanced features in TypeScript, use them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Splitting All Elements of a Function Signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know how to grab argument types and return types from functions within a
    function, but you want to use the same types outside as well.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the built-in `Parameters<F>` and `ReturnType<F>` helper types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we have dealt with helper functions and how they can grab
    information from functions that are arguments. For example, this `defer` function
    takes a function and all its arguments and returns another function that will
    execute it. With some generic types, we can capture everything we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This works great if we pass functions as arguments because we can easily pick
    the details and reuse them. But certain scenarios need a function’s arguments
    and its return type outside of a generic function. Thankfully, we can leverage
    some built-in TypeScript helper types. With `Parameters<F>` we get a function’s
    arguments as a tuple; with `ReturnType<F>` we get the return type of a function.
    So the `defer` function from before could be written like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `Parameters<F>` and `ReturnType<F>` are conditional types that rely on
    function/tuple types and are very similar. In `Parameters<F>` we infer the arguments,
    and in `ReturnType<F>` we infer the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use those helper types, for example, to prepare function arguments outside
    of functions. Take this `search` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With `Parameters<typeof search>` we get an idea of which parameters to expect.
    We define them outside of the function call and spread them as arguments when
    calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Both helpers come in handy when you generate new types as well; see [Recipe
    4.8](ch04.html#ch04_this_type) for an example.
  prefs: []
  type: TYPE_NORMAL
