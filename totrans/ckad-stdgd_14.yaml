- en: Chapter 14\. Container Probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications running in containers do not operate under the premise of “fire
    and forget.” Once Kubernetes starts the container, you’ll want to know if the
    application is ready for consumption and is still working as expected in an hour,
    a week, or a month. A health probe is a periodically running mini-process that
    asks the application for its status and takes action upon certain conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss container health probes—more specifically, readiness,
    liveness, and startup probes. You’ll learn about the different health verification
    methods and how to define them for the proper use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Probes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with the best testing strategy, it’s nearly impossible to find all bugs
    before deploying software to a production environment. That’s especially true
    for failure situations that occur only after operating the software for an extended
    period of time. It’s not uncommon to see memory leaks, deadlocks, infinite loops,
    and similar conditions crop up once end users put the application under load.
  prefs: []
  type: TYPE_NORMAL
- en: Proper monitoring can help with identifying those issues; however, you still
    need to act to mitigate the situation. First, you’ll likely want to restart the
    application to prevent further outages. Second, the development team needs to
    identify the underlying root cause and fix the application’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Probe Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes provides a concept called *health probing* to automate the detection
    and correction of such issues. You can configure a container to execute a periodic
    mini-process that checks for certain conditions. These processes are defined as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Readiness probe
  prefs: []
  type: TYPE_NORMAL
- en: Even after an application has started up, it may still need to execute configuration
    procedures—for example, connecting to a database and preparing data. This probe
    checks if the application is ready to serve incoming requests. [Figure 14-1](#readiness_probe)
    shows the readiness probe.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1401](Images/ckd2_1401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1\. A readiness probe checks if the application is ready to accept
    traffic
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Liveness probe
  prefs: []
  type: TYPE_NORMAL
- en: Once the application is running, you want to make sure that it still works as
    expected without issues. This probe periodically checks for the application’s
    responsiveness. Kubernetes restarts the container automatically if the probe considers
    the application be in an unhealthy state, as shown in [Figure 14-2](#liveness_probe).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1402](Images/ckd2_1402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2\. A liveness probe checks if the application is healthy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Startup probe
  prefs: []
  type: TYPE_NORMAL
- en: Legacy applications in particular can take a long time to start up—possibly
    several minutes. A startup probe can be instantiated to wait for a predefined
    amount of time before a liveness probe is allowed to start probing. By setting
    up a startup probe, you can prevent the application process from being overwhelmed
    with probing requests. Startup probes kill the container if the application can’t
    start within the set time frame. [Figure 14-3](#startup_probe) illustrates the
    behavior of a startup probe.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1403](Images/ckd2_1403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-3\. A startup probe holds off on starting the liveness probe
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From an operational perspective, the most important probe to implement is the
    readiness probe. Without defining liveness and startup probes, the Kubernetes
    control plane components will handle the majority of the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Each probe offers distinct methods to verify the health of a container, discussed
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Health Verification Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define one or many of the health verification methods for a container.
    [Table 14-1](#available_health_verification_methods) describes the available health
    verification methods, their corresponding YAML attribute, and their runtime behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-1\. Available health verification methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Custom command | `exec.command` | Executes a command inside the container
    (e.g., a `cat` command) and checks its exit code. Kubernetes considers a zero
    exit code to be successful. A non-zero exit code indicates an error. |'
  prefs: []
  type: TYPE_TB
- en: '| HTTP GET request | `httpGet` | Sends an HTTP GET request to an endpoint exposed
    by the application. An HTTP response code in the range of 200 to 399 indicates
    success. Any other response code is regarded as an error. |'
  prefs: []
  type: TYPE_TB
- en: '| TCP socket connection | `tcpSocket` | Tries to open a TCP socket connection
    to a port. If the connection could be established, the probing attempt was successful.
    The inability to connect is accounted for as an error. |'
  prefs: []
  type: TYPE_TB
- en: '| gRPC | `grpc` | The application implements the [GRPC Health Checking Protocol](https://github.com/grpc/grpc/blob/master/doc/health-checking.md),
    which verifies whether the server is able to handle a Remote Procedure Call (RPC).
    |'
  prefs: []
  type: TYPE_TB
- en: Remember that you can combine any probe with any health check method. The health
    verification method you choose highly depends on the type of application you are
    running in the container. For example, the obvious choice for a web-based application
    is to use the HTTP GET request verification method.
  prefs: []
  type: TYPE_NORMAL
- en: Health Check Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every probe offers a set of attributes that can further configure the runtime
    behavior, as shown in [Table 14-2](#attributes_for_fine_tuning_the_health_check_runtime_behavior).
    For more information, see the API of the [Probe v1 core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#probe-v1-core)
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-2\. Attributes for fine-tuning the health check runtime behavior
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Default value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `initialDelaySeconds` | 0 | Delay in seconds until first check is executed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `periodSeconds` | 10 | Interval for executing a check (e.g., every 20 seconds).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `timeoutSeconds` | 1 | Maximum number of seconds until check operation times
    out. |'
  prefs: []
  type: TYPE_TB
- en: '| `successThreshold` | 1 | Number of successful check attempts until probe
    is considered successful after a failure. |'
  prefs: []
  type: TYPE_TB
- en: '| `failureThreshold` | 3 | Number of failures for check attempts before probe
    is marked failed and action taken. |'
  prefs: []
  type: TYPE_TB
- en: '| `terminationGracePeriodSeconds` | 30 | Grace period before forcing a container
    to stop upon failure. |'
  prefs: []
  type: TYPE_TB
- en: The following sections will demonstrate the usage of most verification methods
    for different probe types.
  prefs: []
  type: TYPE_NORMAL
- en: The Readiness Probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this scenario, we’ll want to define a readiness probe for a Node.js application.
    The Node.js application exposes an HTTP endpoint on the root context path and
    runs on port 3000\. Dealing with a web-based application makes an HTTP GET request
    a perfect fit for probing its readiness. You can find the source code of the application
    in the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: In the YAML manifest shown in [Example 14-1](#readiness_probe_example), the
    readiness probe executes its first check after two seconds and repeats checking
    every eight seconds thereafter. All other attributes use the default values. A
    readiness probe will continue to periodically check, even after the application
    has been successfully started.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1\. A readiness probe that uses an HTTP GET request
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_container_probes_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: You can assign a name to a port so that it can be referenced in a probe.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_container_probes_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of assigning port 3000 again, we simply use the port name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Pod by pointing the `apply` command to the YAML manifest. During the
    Pod’s startup process, it’s possible that the status shows `Running` but the container
    isn’t ready to accept incoming requests, as indicated by `0/1` in the `READY`
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Liveness Probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A liveness probe checks if the application is still working as expected. To
    demonstrate a liveness probe, we’ll use a custom command. A custom command is
    the most flexible way to verify the health of a container, as it allows for calling
    any command available to the container. This can be either a command-line tool
    that comes with the base image or a tool that you install as part of the containerization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 14-2](#liveness_probe_example), we’ll have the application create
    and update a file, */tmp/heartbeat.txt*, to show that it’s still alive. We’ll
    do this by making it run the Unix `touch` command every five seconds. The probe
    will periodically check if the modification timestamp of the file is older than
    one minute. If it is, then Kubernetes can assume that the application isn’t functioning
    as expected and will restart the container.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-2\. A liveness probe that uses a custom command
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next command uses the YAML manifest shown in [Example 14-2](#liveness_probe_example),
    stored in the file *liveness-probe.yaml*, to create the Pod. Describing the Pod
    renders information on the liveness probe. We can not only inspect the custom
    command and its configuration, but also see how many times the container has been
    restarted upon a probing failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Startup Probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of a startup probe is to figure out when an application is fully
    started. Defining the probe is useful for an application that takes a long time
    to start up. The kubelet puts the readiness and liveness probes on hold while
    the startup probe is running. A startup probe finishes its operation under one
    of the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If it can verify that the application has been started
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the application doesn’t respond within the timeout period
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To demonstrate the functionality of the startup probe, [Example 14-3](#startup_probe_example)
    defines a Pod that runs the [Apache HTTP server](https://hub.docker.com/_/httpd)
    in a container. By default, the image exposes the container port 80, and that’s
    what we’re probing for using a TCP socket connection.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-3\. A startup probe that uses a TCP socket connection
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following terminal output, the `describe` command can
    retrieve the configuration of a startup probe as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at all available health probe types you can define
    for a Pod. A health probe is a periodically running mini-process that asks the
    application running in a container for its status. Think of it as taking the pulse
    of your system.
  prefs: []
  type: TYPE_NORMAL
- en: The readiness probe ensures that the container accepts incoming traffic only
    if the application runs properly. The liveness probe makes sure that the application
    is functioning as expected and will restart the container if necessary. The startup
    probe pauses a liveness probe until application startup has been completed. In
    practice, you’ll often find that a container defines all three probes.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the purpose of all probes
  prefs: []
  type: TYPE_NORMAL
- en: To prepare for this section of the exam, focus on understanding and using health
    probes. You should understand the purpose of startup, readiness, and liveness
    probes and practice how to configure them. In your Kubernetes cluster, try to
    emulate success and failure conditions to see the effects of probes and the actions
    they take.
  prefs: []
  type: TYPE_NORMAL
- en: Practice the use of different verification methods
  prefs: []
  type: TYPE_NORMAL
- en: You can choose from a variety of verification methods applicable to probes.
    Gain a high-level understanding when to apply which verification method, and how
    to configure each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_010.xhtml#appendix_a_container_probes).
  prefs: []
  type: TYPE_NORMAL
- en: Define a new Pod named `web-server` with the image `nginx:1.23.0` in a YAML
    manifest. Expose the container port 80\. Do not create the Pod yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the container, declare a startup probe of type `httpGet`. Verify that the
    kubelet can make a request to the root context endpoint. Use the default configuration
    for the probe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the container, declare a readiness probe of type `httpGet`.Verify that the
    kubelet can make a request to the root context endpoint. Wait five seconds before
    checking for the first time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the container, declare a liveness probe of type `httpGet`. Verify that the
    kubelet can make a request to the root context endpoint. Wait 10 seconds before
    checking for the first time. The probe should run the check every 30 seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the Pod and follow the life cycle phases of the Pod during the process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inspect the runtime details of the Pod’s probes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
