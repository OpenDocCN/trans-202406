["```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: nginx\n  name: nginx\nspec:\n  replicas: {{ .Values.replicaCount }}\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - image: nginx\n        name: nginx\n```", "```\n$ helm repo add hashicorp https://helm.releases.hashicorp.com\n\"hashicorp\" has been added to your repositories\n\n$ helm install vault hashicorp/vault\n```", "```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-config\ndata:\n  debug: \"false\"\n```", "```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app\nspec:\n  containers:\n  - image: my-app\n    name: my-app:v0.1.0\n    volumeMounts:\n    - name: my-config\n      mountPath: /etc/my-app/config.json\n  volumes:\n  - name: my-config\n    configMap:\n      name: my-config\n```", "```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app\nspec:\n  containers:\n    - name: my-app\n      image: my-app:v0.1.0\n      env:\n        - name: DEBUG\n          valueFrom:\n            configMapKeyRef:\n              name: my-config\n              key: debug\n```", "```\n# <... snip ...>\n    spec:\n      containers:\n      - command:\n        - /bin/contour\n        args:\n          - envoy\n          - shutdown-manager\n        image: docker.io/projectcontour/contour:main\n        lifecycle:\n          preStop:\n            exec:\n              command:\n                - /bin/contour\n                - envoy\n                - shutdown\n# <... snip ...>\n```", "```\nfunc main() {\n\t// App initialization code here...\n\thttpServer := app.NewHTTPServer()\n\n\t// Make a channel to listen for an interrupt or terminate signal\n\t// from the OS.\n\n\t// Use a buffered channel because the signal package requires it.\n\tshutdown := make(chan os.Signal, 1)\n\tsignal.Notify(shutdown, os.Interrupt, syscall.SIGTERM)\n\n\t// Start the application and listen for errors\n\terrors := make(chan error, 1)\n\tgo httpServer.ListenAndServe(errors)\n\n\t// Block main and waiting for shutdown.\n\tselect {\n\tcase err := <-errors:\n\t\tlog.Fatalf(\"http server error: %v\", err)\n\n\tcase <-shutdown:\n        log.Printf(\"shutting down http server\")\n\t\thttpServer.Shutdown()\n\t}\n}\n```", "```\n# ... <snip> ...\n      affinity:\n        PodAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n            - labelSelector:\n                matchExpressions:\n                  - key: \"app\"\n                    operator: In\n                    values:\n                    - my-web-server\n              topologyKey: \"zone\"\n# ... <snip> ...\n```", "```\n# ... <snip> ...\nspec:\n  topologySpreadConstraints:\n  - maxSkew: 1\n    topologyKey: zone\n    whenUnsatisfiable: DoNotSchedule\n    labelSelector:\n      matchLabels:\n        foo: bar\n# ... <snip> ...\n```", "```\nfunc main() {\n  // app code...\n\n  http.Handle(\"/metrics\",\n    promhttp.HandlerFor(\n      prometheus.DefaultGatherer,\n      promhttp.HandlerOpts{},\n  ))\n\n  log.Fatal(http.ListenAndServe(\"localhost:8080\", nil))\n}\n```", "```\n// create the counter\nvar totalItemsHandled = prometheus.NewCounter(\n  prometheus.CounterOpts{\n    Name: \"items_handled_total\",\n    Help: \"Total number of queue items handled.\",\n  },\n)\n\n// register the counter\nprometheus.MustRegister(totalItemsHandled)\n```", "```\nfunc handleItem(item Item) {\n\n  // item handling code...\n\n  // increment the counter as we handle items\n  totalItemsHandled.Inc()\n}\n```", "```\npackage main\n\nimport (\n\t\"log\"\n\n\tjaeger \"github.com/uber/jaeger-client-go\"\n\t\"github.com/uber/jaeger-client-go/config\"\n\t\"github.com/uber/jaeger-lib/metrics/prometheus\"\n)\n\nfunc main() {\n  // app initialization code... \n  metricsFactory := prometheus.New() ![1](assets/1.png)\n\n  cfg := config.Configuration{} ![2](assets/2.png)\n  tracer, closer, err := cfg.NewTracer( ![3](assets/3.png)\n    config.Metrics(metricsFactory),\n    config.Logger(jaeger.StdLogger),\n  )\n  if err != nil {\n    log.Fatalf(\"error initializing tracer: %v\", err)\n  }\n\n  defer closer.Close()\n\n  // continue main()... }\n```", "```\npackage main\n\nimport (\n\t\"github.com/opentracing/opentracing-go\"\n\t\"github.com/opentracing/opentracing-go/ext\"\n\t\"net/http\"\n)\n\nfunc (s server) handleListPayments(w http.ResponseWriter, req *http.Request) {\n\tspanCtx, err := s.tracer.Extract( ![1](assets/1.png)\n\t\topentracing.HTTPHeaders,\n\t\topentracing.HTTPHeadersCarrier(req.Header),\n\t)\n\tif err != nil {\n\t\t// handle the error \t}\n\n\tspan := opentracing.StartSpan( ![2](assets/2.png)\n\t\t\"listPayments\",\n\t\text.RPCServerOption(spanCtx),\n\t)\n\tdefer span.Finish()\n}\n```", "```\nfunc listPayments(ctx context.Context) ([]Payment, error) {\n  span, ctx := opentracing.StartSpanFromContext(ctx, \"listPayments\")\n  defer span.Finish()\n\n  // run sql query\n}\n```", "```\nimport (\n    \"github.com/opentracing/opentracing-go\"\n  \t\"github.com/opentracing/opentracing-go/ext\"\n\n\t  \"net/http\"\n)\n\n// create an HTTP request req, err := http.NewRequest(\"GET\", serviceURL, nil)\nif err != nil {\n  // handle error }\n\n// inject context into the request's HTTP headers ext.SpanKindRPCClient.Set(span) ![1](assets/1.png)\next.HTTPUrl.Set(span, url)\next.HTTPMethod.Set(span, \"GET\")\nspan.Tracer().Inject( ![2](assets/2.png)\n  span.Context(),\n  opentracing.HTTPHeaders,\n  opentracing.HTTPHeadersCarrier(req.Header),\n)\n\n// send the request resp, err := http.DefaultClient.Do(req)\n```"]