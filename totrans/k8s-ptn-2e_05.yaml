- en: Chapter 3\. Declarative Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of the *Declarative Deployment* pattern is the Kubernetes Deployment
    resource. This abstraction encapsulates the upgrade and rollback processes of
    a group of containers and makes its execution a repeatable and automated activity.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can provision isolated environments as namespaces in a self-service manner
    and place the applications in these environments with minimal human intervention
    through the scheduler. But with a growing number of microservices, continually
    updating and replacing them with newer versions becomes an increasing burden too.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading a service to a next version involves activities such as starting the
    new version of the Pod, stopping the old version of a Pod gracefully, waiting
    and verifying that it has launched successfully, and sometimes rolling it all
    back to the previous version in the case of failure. These activities are performed
    either by allowing some downtime but not running concurrent service versions,
    or with no downtime but increased resource usage due to both versions of the service
    running during the update process. Performing these steps manually can lead to
    human errors, and scripting properly can require a significant amount of effort,
    both of which quickly turn the release process into a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Luckily, Kubernetes has automated application upgrades as well. Using the concept
    of *Deployment*, we can describe how our application should be updated, using
    different strategies and tuning the various aspects of the update process. If
    you consider that you do multiple Deployments for every microservice instance
    per release cycle (which, depending on the team and project, can span from minutes
    to several months), this is another effort-saving automation by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2, “Predictable Demands”](ch02.html#PredictableDemands), we saw
    that, to do its job effectively, the scheduler requires sufficient resources on
    the host system, appropriate placement policies, and containers with adequately
    defined resource profiles. Similarly, for a Deployment to do its job correctly,
    it expects the containers to be good cloud native citizens. At the very core of
    a Deployment is the ability to start and stop a set of Pods predictably. For this
    to work as expected, the containers themselves usually listen and honor lifecycle
    events (such as SIGTERM; see [Chapter 5, “Managed Lifecycle”](ch05.html#ManagedLifecycle))
    and also provide health-check endpoints as described in [Chapter 4, “Health Probe”](ch04.html#HealthProbe),
    which indicate whether they started successfully.
  prefs: []
  type: TYPE_NORMAL
- en: If a container covers these two areas accurately, the platform can cleanly shut
    down old containers and replace them by starting updated instances. Then all the
    remaining aspects of an update process can be defined in a declarative way and
    executed as one atomic action with predefined steps and an expected outcome. Let’s
    see the options for a container update behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The declarative way of updating applications in Kubernetes is through the concept
    of Deployment. Behind the scenes, the Deployment creates a ReplicaSet that supports
    set-based label selectors. Also, the Deployment abstraction allows you to shape
    the update process behavior with strategies such as `RollingUpdate` (default)
    and `Recreate`. [Example 3-1](#ex-rolling-update) shows the important bits for
    configuring a Deployment for a rolling update strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. Deployment for a rolling update
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_declarative_deployment_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of three replicas. You need more than one replica for a rolling
    update to make sense.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_declarative_deployment_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Number of Pods that can be run temporarily in addition to the replicas specified
    during an update. In this example, it could be a maximum of four replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_declarative_deployment_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Number of Pods that may be unavailable during the update. Here it could be that
    only two Pods are available at a time during the update.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_declarative_deployment_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Duration in seconds of all readiness probes for a rolled-out Pod needs to be
    healthy until the rollout continues.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_declarative_deployment_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Readiness probes that are very important for a rolling deployment to ensure
    zero downtime—don’t forget them (see [Chapter 4, “Health Probe”](ch04.html#HealthProbe)).
  prefs: []
  type: TYPE_NORMAL
- en: '`RollingUpdate` strategy behavior ensures there is no downtime during the update
    process. Behind the scenes, the Deployment implementation performs similar moves
    by creating new ReplicaSets and replacing old containers with new ones. One enhancement
    here is that with Deployment, it is possible to control the rate of a new container
    rollout. The Deployment object allows you to control the range of available and
    excess Pods through `maxSurge` and `maxUnavailable` fields.'
  prefs: []
  type: TYPE_NORMAL
- en: These two fields can be either absolute numbers of Pods or relative percentages
    that are applied to the configured number of replicas for the Deployment and are
    rounded up (`maxSurge`) or down (`maxUnavailable`) to the next integer value.
    By default, `maxSurge` and `maxUnavailable` are both set to 25%.
  prefs: []
  type: TYPE_NORMAL
- en: Another important parameter that influences the rollout behavior is `minReadySeconds`.
    This field specifies the duration in seconds that the readiness probes of a Pod
    need to be successful until the Pod itself is considered to be available in a
    rollout. Increasing this value guarantees that your application Pod is successfully
    running for some time before continuing with the rollout. Also, a larger `minReadySeconds`
    interval helps in debugging and exploring the new version. A `kubectl rollout
    pause` might be easier to leverage when the intervals between the update steps
    are larger.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](#img-deploy-rolling) shows the rolling update process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rolling deployment](assets/kup2_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Rolling deployment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To trigger a declarative update, you have three options:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the whole Deployment with the new version’s Deployment with `kubectl
    replace`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patch (`kubectl patch`) or interactively edit (`kubectl edit`) the Deployment
    to set the new container image of the new version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `kubectl set image` to set the new image in the Deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also the [full example](https://oreil.ly/xSsID) in our repository, which
    demonstrates the usage of these commands and shows you how to monitor or roll
    back an upgrade with `kubectl rollout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to addressing the drawbacks of the imperative way of deploying
    services, the Deployment has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment is a Kubernetes resource object whose status is entirely managed
    by Kubernetes internally. The whole update process is performed on the server
    side without client interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The declarative nature of Deployment specifies how the deployed state should
    look rather than the steps necessary to get there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Deployment definition is an executable object and more than just documentation.
    It can be tried and tested on multiple environments before reaching production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The update process is also wholly recorded and versioned with options to pause,
    continue, and roll back to previous versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `RollingUpdate` strategy is useful for ensuring zero downtime during the update
    process. However, the side effect of this approach is that during the update process,
    two versions of the container are running at the same time. That may cause issues
    for the service consumers, especially when the update process has introduced backward-incompatible
    changes in the service APIs and the client is not capable of dealing with them.
    For this kind of scenario, you can use the `Recreate` strategy, which is illustrated
    in [Figure 3-2](#img-deploy-fixed).
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixed deployment using a Recreate strategy](assets/kup2_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Fixed deployment using a `Recreate` strategy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Recreate` strategy has the effect of setting `maxUnavailable` to the number
    of declared replicas. This means it first kills all containers from the current
    version and then starts all new containers simultaneously when the old containers
    are evicted. The result of this sequence is that downtime occurs while all containers
    with old versions are stopped, and no new containers are ready to handle incoming
    requests. On the positive side, two different versions of the containers won’t
    be running at the same time, so service consumers can connect only one version
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-Green Release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Blue-Green deployment* is a release strategy used for deploying software
    in a production environment by minimizing downtime and reducing risk. The Kubernetes
    Deployment abstraction is a fundamental concept that lets you define how Kubernetes
    transitions immutable containers from one version to another. We can use the Deployment
    primitive as a building block, together with other Kubernetes primitives, to implement
    this more advanced release strategy.
  prefs: []
  type: TYPE_NORMAL
- en: A Blue-Green deployment needs to be done manually if no extensions like a service
    mesh or Knative are used, though. Technically, it works by creating a second Deployment,
    with the latest version of the containers (let’s call it *green*) not serving
    any requests yet. At this stage, the old Pod replicas from the original Deployment
    (called *blue*) are still running and serving live requests.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are confident that the new version of the Pods is healthy and ready
    to handle live requests, we switch the traffic from old Pod replicas to the new
    replicas. You can do this in Kubernetes by updating the Service selector to match
    the new containers (labeled with green). As demonstrated in [Figure 3-3](#img-deploy-blue-green),
    once the green (v1.1) containers handle all the traffic, the blue (v1.0) containers
    can be deleted and the resources freed for future Blue-Green deployments.
  prefs: []
  type: TYPE_NORMAL
- en: '![Blue-Green release](assets/kup2_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Blue-Green release
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A benefit of the Blue-Green approach is that only one version of the application
    is serving requests at a time, which reduces the complexity of handling multiple
    concurrent versions by the Service consumers. The downside is that it requires
    twice the application capacity while both blue and green containers are up and
    running. Also, significant complications can occur with long-running processes
    and database state drifts during the transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Canary Release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Canary release* is a way to softly deploy a new version of an application
    into production by replacing only a small subset of old instances with new ones.
    This technique reduces the risk of introducing a new version into production by
    letting only some of the consumers reach the updated version. When we’re happy
    with the new version of our service and how it performed with a small sample of
    users, we can replace all the old instances with the new version in an additional
    step after this canary release. [Figure 3-4](#img-deploy-canary) shows a canary
    release in action.'
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, this technique can be implemented by creating a new Deployment
    with a small replica count that can be used as the canary instance. At this stage,
    the Service should direct some of the consumers to the updated Pod instances.
    After the canary release and once we are confident that everything with the new
    ReplicaSet works as expected, we scale the new ReplicaSet up, and the old ReplicaSet
    down to zero. In a way, we’re performing a controlled and user-tested incremental
    rollout.
  prefs: []
  type: TYPE_NORMAL
- en: '![Canary release](assets/kup2_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Canary release
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Deployment primitive is an example of Kubernetes turning the tedious process
    of manually updating applications into a declarative activity that can be repeated
    and automated. The out-of-the-box deployment strategies (rolling and recreate)
    control the replacement of old containers by new ones, and the advanced release
    strategies (Blue-Green and canary) control how the new version becomes available
    to service consumers. The latter two release strategies are based on a human decision
    for the transition trigger and as a consequence are not fully automated by Kubernetes
    but require human interaction. [Figure 3-5](#img-deploy-overview) summarizes of
    the deployment and release strategies, showing instance counts during transitions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment and release strategies](assets/kup2_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Deployment and release strategies
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All software is different, and deploying complex systems usually requires additional
    steps and checks. The techniques discussed in this chapter cover the Pod update
    process, but do not include updating and rolling back other Pod dependencies such
    as ConfigMaps, Secrets, or other dependent services.
  prefs: []
  type: TYPE_NORMAL
- en: One approach that works today is to create a script to manage the update process
    of services and their dependencies using the Deployment and other primitives discussed
    in this book. However, this imperative approach that describes the individual
    update steps does not match the declarative nature of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, higher-level declarative approaches have emerged on top of
    Kubernetes. The most important platforms are described in the sidebar that follows.
    Those techniques work with operators (see [Chapter 28, “Operator”](ch28.html#Operator))
    that take a declarative description of the rollout process and perform the necessary
    actions on the server side, some of them also including automatic rollbacks in
    case of an update error. For advanced, production-ready rollout scenarios, it
    is recommended to look at one of those extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the deployment strategy you are using, it is essential for Kubernetes
    to know when your application Pods are up and running to perform the required
    sequence of steps to reach the defined target deployment state. The next pattern,
    *Health Probe*, in [Chapter 4](ch04.html#HealthProbe) describes how your application
    can communicate its health state to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Declarative Deployment Example](https://oreil.ly/xSsID)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Performing a Rolling Update](https://oreil.ly/paEA0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deployments](https://oreil.ly/NKEnH)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Run a Stateless Application Using a Deployment](https://oreil.ly/wb7D5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Blue-Green Deployment](https://oreil.ly/sbN9T)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Canary Release](https://oreil.ly/Z-vFT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Flagger: Deployment Strategies](https://oreil.ly/JGL4C)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Argo Rollouts](https://oreil.ly/0lzcD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Knative: Traffic Management](https://oreil.ly/PAwMQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
