<html><head></head><body><section data-pdf-bookmark="Chapter 10. Configuration and Secrets" data-type="chapter" epub:type="chapter"><div class="chapter" id="config">&#13;
<h1><span class="label">Chapter 10. </span>Configuration and Secrets</h1>&#13;
&#13;
<blockquote class="epigraph">&#13;
<p>If you want to keep a secret, you must also hide it from yourself.</p>&#13;
<p data-type="attribution">George Orwell, <cite><em>1984</em></cite></p>&#13;
</blockquote>&#13;
&#13;
<p><a data-primary="Kubernetes" data-secondary="configuration" data-type="indexterm" id="ix_10-config-adoc0"/>It’s very useful to be able to separate the <em>logic</em> of your Kubernetes application from its <em>configuration</em>: that is, any values or settings that might change over the life of the application. Configuration values commonly include things like environment-specific settings, DNS addresses of third-party services, and authentication credentials.</p>&#13;
&#13;
<p>While you could simply put these values directly into your code, that’s not a very flexible approach. For one thing, changing a configuration value would require a complete rebuild and redeploy of the application. It’s much better to separate these values out from the code and read them in from a file, or from environment variables.</p>&#13;
&#13;
<p>Kubernetes provides a few different ways to help you manage configuration. One is to pass values to the application via environment variables in the Pod spec (see <a data-type="xref" href="ch08.html#envvars">“Environment Variables”</a>). Another is to store configuration data directly in Kubernetes, using the ConfigMap and Secret objects.</p>&#13;
&#13;
<p>In this chapter we’ll explore ConfigMaps and Secrets in detail, and look at some practical techniques for managing configuration and secrets in applications, using the demo application as an example.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ConfigMaps" data-type="sect1"><div class="sect1" id="configmaps">&#13;
<h1>ConfigMaps</h1>&#13;
&#13;
<p><a data-primary="ConfigMap" data-secondary="purpose of" data-type="indexterm" id="idm45979381342592"/>The ConfigMap is the primary object for storing configuration data in Kubernetes. You can think of it as being a named set of key-value pairs that stores configuration data. Once you have a ConfigMap, you can supply that data to an application either by creating a file in the Pod, or by injecting it into the Pod’s environment.</p>&#13;
&#13;
<p>In this section, we’ll look at some different ways to get data into a ConfigMap, and then explore the various ways you can extract that data and feed it into your Kubernetes application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating ConfigMaps" data-type="sect2"><div class="sect2" id="idm45979381340976">&#13;
<h2>Creating ConfigMaps</h2>&#13;
&#13;
<p>Suppose you want to create a YAML configuration file in your Pod’s filesystem named <em>config.yaml</em>, with the following contents:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">autoSaveInterval</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">60</code><code class="w"/>&#13;
<code class="nt">batchSize</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">128</code><code class="w"/>&#13;
<code class="nt">protocols</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">http</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">https</code><code class="w"/></pre>&#13;
&#13;
<p>Given this set of values, how do you turn them into a ConfigMap resource that you can apply to Kubernetes?</p>&#13;
&#13;
<p>One way is to specify that data as literal YAML values in the ConfigMap manifest. This is what the manifest for a ConfigMap object looks like:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">config.yaml</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">autoSaveInterval: 60</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">batchSize: 128</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">protocols:</code><code class="w"/>&#13;
<code class="w">      </code><code class="no">- http</code><code class="w"/>&#13;
<code class="w">      </code><code class="no">- https</code><code class="w"/></pre>&#13;
&#13;
<p>You could create a ConfigMap by writing the manifest from scratch, and adding the values from <em>config.yaml</em> into the <code>data</code> section, as we’ve done in this example.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="create" data-type="indexterm" id="idm45979381217040"/>An easier way, though, is to let <code>kubectl</code> do some of the work for you. You can create a ConfigMap directly from a YAML file as follows:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl create configmap demo-config --from-file=config.yaml</code></strong><code class="go">&#13;
</code><code class="go">configmap "demo-config" created</code></pre>&#13;
&#13;
<p>To export the manifest file that corresponds to this ConfigMap, run:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get configmap/demo-config -o yaml&#13;
</code><code class="go">    &gt;demo-config.yaml</code></strong></pre>&#13;
&#13;
<p>This writes a YAML manifest representation of the cluster’s ConfigMap resource to the file <em>demo-config.yaml</em>, however it will contain extra info like the <code>status</code> section that you may want to remove before applying again (see <a data-type="xref" href="ch07.html#exportflag">“Exporting Resources”</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Environment Variables from ConfigMaps" data-type="sect2"><div class="sect2" id="envconfig">&#13;
<h2>Setting Environment Variables from ConfigMaps</h2>&#13;
&#13;
<p><a data-primary="ConfigMap" data-secondary="setting environment variables from" data-type="indexterm" id="idm45979381182816"/><a data-primary="environment variables" data-secondary="setting from ConfigMap" data-type="indexterm" id="idm45979381181984"/>Now that we have the required configuration data in a ConfigMap object, how do we then get that data into a container? Let’s look at a complete example using our demo application. You’ll find the code in the <em>hello-config-env</em> directory of the demo repo.</p>&#13;
&#13;
<p>It’s the same demo application we’ve used in previous chapters that listens for HTTP requests and responds with a greeting (see <a data-type="xref" href="ch02.html#demo-source">“Looking at the Source Code”</a>).</p>&#13;
&#13;
<p>This time, though, instead of hard coding the string <code>Hello</code> into the application, we’d like to make the greeting configurable. So there’s a slight modification to the <code>handler</code> function to read this value from the environment variable <code>GREETING</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">handler</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">  </code><strong><code class="nx">greeting</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Getenv</code><code class="p">(</code><code class="s">"GREETING"</code><code class="p">)</code></strong><code class="w">&#13;
</code><code class="w">  </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintf</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code><code class="w"> </code><code class="s">"%s, 世界\n"</code><code class="p">,</code><code class="w"> </code><code class="nx">greeting</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>Don’t worry about the exact details of the Go code; it’s just a demo. Suffice it to say that if the <code>GREETING</code> environment variable is present when the program runs, it will use that value when responding to requests. Whatever language you’re using to write applications, it’s a good bet that you’ll be able to read environment variables with it.</p>&#13;
&#13;
<p>Now, let’s create the ConfigMap object to hold the greeting value. You’ll find the manifest file for the ConfigMap, along with the modified Go application, in the <em>hello-config-env</em> directory of the demo repo.</p>&#13;
&#13;
<p>It looks like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">greeting</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Hola</code><code class="w"/></pre>&#13;
&#13;
<p>In order to make this data visible in the container’s environment, we need to modify the Deployment slightly. Here’s the relevant part of the demo Deployment:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w">&#13;
</code><code class="w">      </code><strong><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo:hello-config-env</code></strong><code class="w">&#13;
</code><code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w">&#13;
</code><code class="w">      </code><strong><code class="nt">env</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">GREETING</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">greeting</code></strong></pre>&#13;
&#13;
<p>Note that we’re using a different container image tag to that in previous examples (see <a data-type="xref" href="ch08.html#image-identifiers">“Image Identifiers”</a>). The <code>:hello-config-env</code> tag gets us the modified version of the demo application that reads the <code>GREETING</code> variable: <span class="keep-together"><code>cloudnatived/demo:hello-config-env</code></span>.</p>&#13;
&#13;
<p>The second point of interest is the <code>env</code> section. Remember from <a data-type="xref" href="ch08.html#envvars">“Environment Variables”</a> that you can create environment variables with literal values by adding a <code>name</code>/<code>value</code> pair.</p>&#13;
&#13;
<p>We still have <code>name</code> here, but instead of <code>value</code>, we’ve specified <code>valueFrom</code>. This tells Kubernetes that, rather than taking a literal value for the variable, it should look elsewhere to find the value.</p>&#13;
&#13;
<p><a data-primary="configMapKeyRef" data-type="indexterm" id="idm45979380980320"/><code>configMapKeyRef</code> tells it to reference a specific key in a specific ConfigMap. The name of the ConfigMap to look at is <code>demo-config</code>, and the key we want to look up is <code>greeting</code>. We created this data with the ConfigMap manifest, so it should now be available to read into the container’s environment.</p>&#13;
&#13;
<p>If the ConfigMap doesn’t exist, the Deployment won’t be able to run (its Pod will show a status of <code>CreateContainerConfigError</code>).</p>&#13;
&#13;
<p>That’s everything you need to make the updated application work, so go ahead and deploy the manifests to your Kubernetes cluster. From the demo repo directory, run the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl apply -f hello-config-env/k8s/</code></strong><code class="go">&#13;
</code><code class="go">configmap/demo-config created&#13;
</code><code class="go">deployment.apps/demo created</code></pre>&#13;
&#13;
<p>As before, to see the application in your web browser, you’ll need to forward a local port to the Pod’s port 8888:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl port-forward deploy/demo 9999:8888</code></strong><code class="go">&#13;
</code><code class="go">Forwarding from 127.0.0.1:9999 -&gt; 8888&#13;
</code><code class="go">Forwarding from [::1]:9999 -&gt; 8888</code></pre>&#13;
&#13;
<p>(We didn’t bother creating a Service this time; while you’d use a Service with a real production app, for this example we’ve just used <code>kubectl</code> to forward the local port directly to the <code>demo</code> Deployment.)</p>&#13;
&#13;
<p>If you point your web browser to http://localhost:9999/, you should see, if all is well:</p>&#13;
&#13;
<p><code>Hola, 世界</code></p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45979380907632">&#13;
<h5>Exercise</h5>&#13;
<p>In another terminal (you’ll need to leave the <code>kubectl port-forward</code> command running), edit the <em>configmap.yaml</em> file to change the greeting. Reapply the file with <code>kubectl</code>. Refresh the web browser. Does the greeting change? If not, why not? What do you need to do to get the application to read the updated value? (<a data-type="xref" href="#configchange">“Updating Pods on a Config Change”</a> may help.)</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting the Whole Environment from a ConfigMap" data-type="sect2"><div class="sect2" id="idm45979381184080">&#13;
<h2>Setting the Whole Environment from a ConfigMap</h2>&#13;
&#13;
<p>While you can set one or two environment variables from individual ConfigMap keys, as we saw in the previous example, that could get tedious for a large number of variables.</p>&#13;
&#13;
<p><a data-primary="envFrom" data-type="indexterm" id="idm45979380902064"/>Fortunately, there’s an easy way to take all the keys from a ConfigMap and turn them into environment variables, using <code>envFrom</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo:hello-config-env</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w">&#13;
</code><code class="w">      </code><strong><code class="nt">envFrom</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">configMapRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config</code></strong></pre>&#13;
&#13;
<p>Now every setting in the <code>demo-config</code> ConfigMap will be a variable in the container’s environment. Because in our example ConfigMap the key is called <code>greeting</code>, the environment variable will also be named <code>greeting</code> (in lowercase). To make your environment variable names uppercase when you’re using <code>envFrom</code>, change them in the ConfigMap.</p>&#13;
&#13;
<p>You can also set other environment variables for the container in the normal way, using <code>env</code>, either by putting the literal values in the manifest file or using a <code>ConfigMapKeyRef</code>, as in our previous example. Kubernetes allows you to use either <code>env</code>, <code>envFrom</code>, or both at once to set environment variables.</p>&#13;
&#13;
<p>If a variable set in <code>env</code> has the same name as one set in <code>envFrom</code>, it will take precedence. For example, if you set the variable <code>GREETING</code> in both <code>env</code> and a ConfigMap referenced in <code>envFrom</code>, the value specified in <code>env</code> will override the one from the ConfigMap.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Environment Variables in Command Arguments" data-type="sect2"><div class="sect2" id="idm45979380838192">&#13;
<h2>Using Environment Variables in Command Arguments</h2>&#13;
&#13;
<p><a data-primary="ConfigMap" data-secondary="setting command-line arguments from" data-type="indexterm" id="idm45979380836624"/><a data-primary="containers" data-secondary="arguments" data-type="indexterm" id="idm45979380803184"/><a data-primary="environment variables" data-secondary="command arguments and" data-type="indexterm" id="idm45979380802240"/>While it’s useful to be able to put configuration data into a container’s environment, sometimes you need to supply it as command-line arguments for the container’s entrypoint instead.</p>&#13;
&#13;
<p>You can do this by sourcing the environment variables from the ConfigMap, as in the previous example, but using the special Kubernetes syntax <code>$(VARIABLE)</code> to reference them in the command-line arguments.</p>&#13;
&#13;
<p>In the <em>hello-config-args</em> directory of the demo repo, you’ll find this example in the <em>deployment.yaml</em> file:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo:hello-config-args</code><code class="w">&#13;
</code><code class="w">      </code><strong><code class="nt">args</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">-greeting</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">$(GREETING)</code><code class="s">"</code></strong><code class="w">&#13;
</code><code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">env</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">GREETING</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">greeting</code></pre>&#13;
&#13;
<p>Here we’ve added an <code>args</code> field for the container spec, which will pass our custom arguments to the container’s default entrypoint (<code>/bin/demo</code>).</p>&#13;
&#13;
<p>Kubernetes replaces anything of the form <code>$(VARIABLE)</code> in a manifest with the value of the environment variable <code>VARIABLE</code>. Since we’ve created the <code>GREETING</code> variable and set its value from the ConfigMap, it’s available for use in the container’s command line.</p>&#13;
&#13;
<p>When you apply these manifests, the value of <code>GREETING</code> will be passed to the demo app in this way:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl apply -f hello-config-args/k8s/</code></strong><code class="go">&#13;
</code><code class="go">configmap/demo-config created&#13;
</code><code class="go">deployment.apps/demo created</code></pre>&#13;
&#13;
<p>You should see the effect in your web browser:</p>&#13;
&#13;
<p><code>Salut, 世界</code></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Creating Config Files from ConfigMaps" data-type="sect2"><div class="sect2" id="hello-config-file">&#13;
<h2>Creating Config Files from ConfigMaps</h2>&#13;
&#13;
<p><a data-primary="ConfigMap" data-secondary="creating config file from" data-type="indexterm" id="idm45979380677680"/>We’ve seen a couple of different ways of getting data from Kubernetes ConfigMaps into applications: via the environment and via the container command line. More complex applications, however, often expect to read their configuration from files on disk.</p>&#13;
&#13;
<p>Fortunately, Kubernetes gives us a way to create such files directly from a ConfigMap. First, let’s change our ConfigMap so that instead of a single key, it stores a complete YAML file (which happens to only contain one key, but it could be a hundred, if you like):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">config</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">greeting: Buongiorno</code><code class="w"/></pre>&#13;
&#13;
<p>Instead of setting the key <code>greeting</code>, as we did in the previous example, we’re creating a new key called <code>config</code>, and assigning it a <em>block</em> of data (the pipe symbol <code>|</code> in YAML indicates that what follows is a block of raw data). This is the data:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">greeting</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Buongiorno</code><code class="w"/></pre>&#13;
&#13;
<p>It happens to be valid YAML, but don’t be confused by that; it could be JSON, TOML, plain text, or any other format. Whatever it is, Kubernetes will eventually write the whole block of data, as is, to a file on our container.</p>&#13;
&#13;
<p>Now that we’ve stored the necessary data, let’s deploy it to Kubernetes. In the <em>hello-config-file</em> directory of the demo repo, you’ll find the Deployment template, containing:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo:hello-config-file</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w">&#13;
</code><code class="w">      </code><strong><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/config/</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config-volume</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config-volume</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">configMap</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-config</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">items</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo.yaml</code></strong></pre>&#13;
&#13;
<p>Looking at the <code>volumes</code> section, you can see that we create a Volume named <code>demo-config-volume</code>, from the existing <code>demo-config</code> ConfigMap.</p>&#13;
&#13;
<p>In the container’s <code>volumeMounts</code> section, we mount this volume on the <code>mountPath: /config/</code>, select the key <code>config</code>, and write it to the path <em>demo.yaml</em>. The result of this will be that Kubernetes will create a file in the container at <em>/config/demo.yaml</em>, containing the <code>demo-config</code> data in YAML format:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">greeting</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Buongiorno</code><code class="w"/></pre>&#13;
&#13;
<p>The demo application will read its config from this file on startup. As before, apply the manifests using this command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl apply -f hello-config-file/k8s/</code></strong><code class="go">&#13;
</code><code class="go">configmap/demo-config created&#13;
</code><code class="go">deployment.apps/demo created</code></pre>&#13;
&#13;
<p>You should see the results in your web browser:</p>&#13;
&#13;
<p><code>Buongiorno, 世界</code></p>&#13;
&#13;
<p>If you want to see what the ConfigMap data looks like in the cluster, run the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl describe configmap/demo-config</code></strong><code class="go">&#13;
</code><code class="go">Name:         demo-config&#13;
</code><code class="go">Namespace:    default&#13;
</code><code class="go">Labels:       &lt;none&gt;&#13;
</code><code class="go">&#13;
</code><code class="go">Data&#13;
</code><code class="go">====&#13;
</code><code class="go">config:&#13;
</code><code class="go">greeting: Buongiorno&#13;
</code><code class="go">&#13;
</code><code class="go">Events:  &lt;none&gt;</code></pre>&#13;
&#13;
<p>If you update a ConfigMap and change its values, the corresponding file (<em>/config/demo.yaml</em> in our example) will be updated automatically. Some applications may autodetect that their config file has changed and reread it; others may not.</p>&#13;
&#13;
<p>One option is to redeploy the application to pick up the changes (see <a data-type="xref" href="#configchange">“Updating Pods on a Config Change”</a>), but this may not be necessary if the application has a way to trigger a live reload, such as a Unix signal (for example <code>SIGHUP</code>), or run a command in the container.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Updating Pods on a Config Change" data-type="sect2"><div class="sect2" id="configchange">&#13;
<h2>Updating Pods on a Config Change</h2>&#13;
&#13;
<p><a data-primary="ConfigMap" data-secondary="updating Deployment on changes to" data-type="indexterm" id="idm45979380384688"/>Suppose you have a Deployment running in your cluster, and you want to change some values in its ConfigMap. <a data-primary="checksum/config" data-type="indexterm" id="idm45979380383392"/>If you’re using a Helm chart (see <a data-type="xref" href="ch04.html#helm-intro">“Helm: A Kubernetes Package Manager”</a>), there’s a neat trick to have it automatically detect a config change and reload your Pods. Add this annotation to your Deployment spec:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><strong><code class="nt">checksum/config</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="w"> </code><code class="nv">include</code><code class="nv"> </code><code class="nv">(print</code><code class="nv"> </code><code class="nv">$.Template.BasePath</code><code class="nv"> </code><code class="nv">"/configmap.yaml")</code><code class="nv"> </code><code class="nv">.</code><code class="w">&#13;
</code><code class="w">    </code><code class="nv">|</code><code class="nv"> </code><code class="nv">sha256sum</code><code class="w"> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code></strong></pre>&#13;
&#13;
<p>Because the Deployment template now includes a hash sum of the config settings, if these settings change, then so will the hash. When you run <code>helm upgrade</code>, Helm will detect that the Deployment spec has changed, and restart all the Pods.<a data-startref="ix_10-config-adoc0" data-type="indexterm" id="idm45979380339648"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes Secrets" data-type="sect1"><div class="sect1" id="secrets">&#13;
<h1>Kubernetes Secrets</h1>&#13;
&#13;
<p><a data-primary="Kubernetes" data-secondary="Secrets" data-type="indexterm" id="ix_10-config-adoc1"/><a data-primary="Secrets" data-type="indexterm" id="ix_10-config-adoc2"/>We’ve seen that the Kubernetes ConfigMap object provides a flexible way of storing and accessing configuration data in the cluster. <a data-primary="Secrets" data-secondary="purpose of" data-type="indexterm" id="idm45979380334960"/>However, most applications have some config data that is secret and sensitive, such as passwords or API keys. While we could use ConfigMaps to store these, that’s not an ideal solution.</p>&#13;
&#13;
<p>Instead, Kubernetes provides a special type of object intended to store secret data: the Secret. Let’s see an example of how to use it with the demo application.</p>&#13;
&#13;
<p>First, here’s the Kubernetes manifest for the Secret (see <em>hello-secret-env/k8s/secret.yaml</em>):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-secret</code><code class="w"/>&#13;
<code class="nt">stringData</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">magicWord</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">xyzzy</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the secret key is <code>magicWord</code>, and the secret value is the word <a href="https://oreil.ly/Ww0ME"><code>xyzzy</code></a> (a very useful word in computing). As with a ConfigMap, you can put multiple keys and values into a Secret. Here, just to keep things simple, we’re only using one key-value pair.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Secrets as Environment Variables" data-type="sect2"><div class="sect2" id="idm45979380304608">&#13;
<h2>Using Secrets as Environment Variables</h2>&#13;
&#13;
<p><a data-primary="environment variables" data-secondary="creating from Secret" data-type="indexterm" id="idm45979380303072"/><a data-primary="Secrets" data-secondary="setting environment variables from" data-type="indexterm" id="idm45979380302096"/>Just like ConfigMaps, Secrets can be made visible to containers by putting them into environment variables, or mounting them as a file on the container’s filesystem. In this example, we’ll set an environment variable to the value of the Secret:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo:hello-secret-env</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">env</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MAGIC_WORD</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><strong><code class="nt">secretKeyRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-secret</code><code class="w">&#13;
</code><code class="w">              </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">magicWord</code></strong></pre>&#13;
&#13;
<p><a data-primary="secretKeyRef" data-type="indexterm" id="idm45979380185824"/>We set the environment variable <code>MAGIC_WORD</code> exactly as we did when using a ConfigMap, except that now it’s a <code>secretKeyRef</code> instead of a <code>configMapKeyRef</code> (see <a data-type="xref" href="#envconfig">“Setting Environment Variables from ConfigMaps”</a>).</p>&#13;
&#13;
<p>Run the following command in the demo repo directory to apply these manifests:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl apply -f hello-secret-env/k8s/</code></strong><code class="go">&#13;
</code><code class="go">deployment.apps/demo created&#13;
</code><code class="go">secret/demo-secret created</code></pre>&#13;
&#13;
<p>As before, forward a local port to the Deployment so you can see the results in your web browser:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl port-forward deploy/demo 9999:8888</code></strong><code class="go">&#13;
</code><code class="go">Forwarding from 127.0.0.1:9999 -&gt; 8888&#13;
</code><code class="go">Forwarding from [::1]:9999 -&gt; 8888</code></pre>&#13;
&#13;
<p>Browse to <em>http://localhost:9999/</em> and you should see:</p>&#13;
&#13;
<p><code>The magic word is "xyzzy"</code></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing Secrets to Files" data-type="sect2"><div class="sect2" id="idm45979380304016">&#13;
<h2>Writing Secrets to Files</h2>&#13;
&#13;
<p><a data-primary="Secrets" data-secondary="writing to files" data-type="indexterm" id="idm45979380124736"/>In this example, we’ll mount the Secret on the container as a file. You’ll find the code for this example in the <em>hello-secret-file</em> folder of the demo repo.</p>&#13;
&#13;
<p>In order to mount the Secret in a file on the container, we use a Deployment like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo:hello-secret-file</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w">&#13;
</code><code class="w">      </code><strong><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-secret-volume</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">/secrets/</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-secret-volume</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">secret</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo-secret</code></strong></pre>&#13;
&#13;
<p>Just as we did in <a data-type="xref" href="#hello-config-file">“Creating Config Files from ConfigMaps”</a>, we create a Volume (<code>demo-secret-volume</code> in this example), and mount it on the container in the <code>volumeMounts</code> section of the spec. The <code>mountPath</code> is <code>/secrets</code>, and Kubernetes will create one file in this directory for each of the key-value pairs defined in the Secret.</p>&#13;
&#13;
<p>We’ve only defined one key-value pair in the example Secret, named <code>magicWord</code>, so this manifest will create the read-only file <em>/secrets/magicWord</em> on the container, and the contents of the file will be the secret data.</p>&#13;
&#13;
<p>If you apply this manifest in the same way as for the previous example, you should see the same results:</p>&#13;
&#13;
<p><code>The magic word is "xyzzy"</code></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading Secrets" data-type="sect2"><div class="sect2" id="idm45979380038816">&#13;
<h2>Reading Secrets</h2>&#13;
&#13;
<p><a data-primary="Secrets" data-secondary="reading" data-type="indexterm" id="idm45979380037408"/>In the previous section, we were able to use <code>kubectl describe</code> to see the data inside the ConfigMap. Can we do the same with a Secret?</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl describe secret/demo-secret</code></strong><code class="go">&#13;
</code><code class="go">Name:         demo-secret&#13;
</code><code class="go">Namespace:    default&#13;
</code><code class="go">Labels:       &lt;none&gt;&#13;
</code><code class="go">Annotations:&#13;
</code><code class="go">Type:         Opaque&#13;
</code><code class="go">&#13;
</code><code class="go">Data&#13;
</code><code class="go">====&#13;
</code><code class="go">magicWord:  5 bytes</code></pre>&#13;
&#13;
<p><a data-primary="Secrets" data-secondary="opaque representation" data-type="indexterm" id="idm45979379986048"/>Notice that this time, the actual data is not shown. Kubernetes Secrets are <code>Opaque</code>, which means they’re not shown in <code>kubectl describe</code> output, in log messages, or in the terminal. This prevents secret data being exposed accidentally.</p>&#13;
&#13;
<p>You can see an obfuscated version of the secret data by using <code>kubectl get</code> with YAML output format:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get secret/demo-secret -o yaml</code></strong><code class="go">&#13;
</code><code class="go">apiVersion: v1&#13;
</code><code class="go">data:&#13;
</code><code class="go">  </code><strong><code class="go">magicWord: eHl6enk=</code></strong><code class="go">&#13;
</code><code class="go">kind: Secret&#13;
</code><code class="go">metadata:&#13;
</code><code class="go">...&#13;
</code><code class="go">type: Opaque</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="base64" data-type="sect3"><div class="sect3" id="base64">&#13;
<h3>base64</h3>&#13;
&#13;
<p><a data-primary="base64" data-secondary="encoding and decoding" data-type="indexterm" id="idm45979379949664"/>What’s that <code>eHl6enk=</code>? That doesn’t look much like our original secret data. In fact, it’s a <em>base64</em> representation of the Secret. Base64 is a scheme for encoding arbitrary binary data as a character string.</p>&#13;
&#13;
<p>Because the secret data could be nonprintable binary data (for example, a Transport Layer Security [TLS] encryption key), Kubernetes Secrets are always stored in base64 format.</p>&#13;
&#13;
<p>The text <code>eHl6enk=</code> is the base64-encoded version of our secret word <code>xyzzy</code>. You can verify this using the <code>base64 --decode</code> command in the terminal:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">echo "eHl6enk=" | base64 --decode</code></strong><code class="go">&#13;
</code><code class="go">xyzzy</code></pre>&#13;
&#13;
<p>So although Kubernetes protects you from accidentally printing secret data to the terminal, or in log files, if you have permission to read the Secrets in a particular namespace, you can get the data in base64 format and then decode it.</p>&#13;
&#13;
<p>If you need to base64-encode some text (for instance, to add it to a Secret), use the <code>base64</code> tool with the <code>-n</code> flag to avoid including a newline character:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">echo -n xyzzy | base64</code></strong><code class="go">&#13;
</code><code class="go">eHl6enk=</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Access to Secrets" data-type="sect2"><div class="sect2" id="idm45979379913248">&#13;
<h2>Access to Secrets</h2>&#13;
&#13;
<p>Who can read or edit Secrets? That’s controlled by the Kubernetes access control mechanism, RBAC, which we’ll talk about in much more detail in <a data-type="xref" href="ch11.html#rbac">“Introducing Role-Based Access Control (RBAC)”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Encryption at Rest" data-type="sect2"><div class="sect2" id="idm45979379892304">&#13;
<h2>Encryption at Rest</h2>&#13;
&#13;
<p><a data-primary="encryption at rest" data-type="indexterm" id="idm45979379891104"/>What about someone with access to the <code>etcd</code> database where all Kubernetes information is stored? Could they access the secret data, even without API permissions to read the Secret object?</p>&#13;
&#13;
<p>From Kubernetes version 1.7 onward, <em>encryption at rest</em> is supported. That means that the secret data in the <code>etcd</code> database is actually stored encrypted on disk, and unreadable even to someone who can access the database directly. Only the Kubernetes API server has the key to decrypt this data. In a properly configured cluster, encryption at rest should be enabled.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Keeping Secrets and ConfigMaps" data-type="sect2"><div class="sect2" id="idm45979379887952">&#13;
<h2>Keeping Secrets and ConfigMaps</h2>&#13;
&#13;
<p><a data-primary="ConfigMap" data-secondary="immutable" data-type="indexterm" id="idm45979379886784"/>As of version 1.21, Kubernetes supports <a href="https://oreil.ly/5797O">Immutable Secrets</a> and <a href="https://oreil.ly/baz5W">Immutable ConfigMaps</a>. Adding <code>immutable: true</code> to the Secret or ConfigMap manifest will prevent it from being modified. The only way to change an Immutable Secret or ConfigMap is to delete and re-create a new one.</p>&#13;
&#13;
<p><a data-primary="helm.sh/resource-policy" data-type="indexterm" id="idm45979379867104"/>Sometimes you’ll have Kubernetes resources that you never want to be deleted from the cluster. If you are using Helm, then you can use a Helm-specific annotation to prevent a resource from being removed:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="s">"helm.sh/resource-policy"</code><code class="p-Indicator">:</code><code class="w"> </code><code class="l-Scalar-Plain">keep</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Secrets Management Strategies" data-type="sect1"><div class="sect1" id="idm45979379852128">&#13;
<h1>Secrets Management Strategies</h1>&#13;
&#13;
<p><a data-primary="Secrets" data-secondary="management strategies" data-type="indexterm" id="ix_10-config-adoc3"/>In the example in the previous section, our secret data was protected against unauthorized access once it was stored in the cluster. But the secret data was represented in plain text in our manifest files.</p>&#13;
&#13;
<p>You should never expose secret data like this in files that are committed to source control. So how do you manage and store secret data securely before it’s applied to the Kubernetes cluster?</p>&#13;
&#13;
<p>Whatever tool or strategy you choose for managing secrets in your applications, you’ll need it to answer at least the following questions:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Where do you store secrets so that they are highly available?</p>&#13;
</li>&#13;
<li>&#13;
<p>How do you make secrets available to your running applications?</p>&#13;
</li>&#13;
<li>&#13;
<p>What needs to happen to your running applications when you rotate or change secrets?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>In this section we’ll look at some of the popular secrets management strategies, and examine how each of them tackles these questions.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Encrypt Secrets in Version Control" data-type="sect2"><div class="sect2" id="idm45979379841712">&#13;
<h2>Encrypt Secrets in Version Control</h2>&#13;
&#13;
<p><a data-primary="Secrets" data-secondary="encrypting in version control" data-type="indexterm" id="idm45979379840304"/>The first and perhaps simplest option for secrets management is to store your secrets directly in your version control repos alongside your source code, but in encrypted form. Secrets that are stored in source code repos should never be saved in plain text. Instead, they are encrypted in a form that can only be decrypted with a certain trusted key, either at deploy time or at startup time. The application can then read and use the decrypted secrets just like any other configuration data.</p>&#13;
&#13;
<p>Encrypting secrets in version control lets you review and track changes to secrets, just as you would do for changes to application code. And so long as your version control repositories are highly available, your secrets will be highly available as well.</p>&#13;
&#13;
<p>To change or rotate secrets, just decrypt them in your local copy of the source, update them, re-encrypt, and commit the change to version control.</p>&#13;
&#13;
<p>While this strategy is simple to implement and has no dependencies except the key and the encryption/decryption tool, there are a few potential drawbacks. If the same secret is used by multiple applications, they all need a copy of it in their source code. This means rotating the secret is more work, because you have to make sure you’ve found and changed all instances of it.</p>&#13;
&#13;
<p>There is also a serious risk of accidentally committing plain-text secrets to version control. Mistakes do happen, and even with private version control repositories, any secret so committed should be considered compromised, and you should rotate it as soon as possible. Reconciling merge conflicts in source control with encrypted secrets can also be tricky.</p>&#13;
&#13;
<p>Nonetheless, this strategy could be a good starting point for smaller teams or for noncritical secrets. It’s relatively low-touch and easy to set up, while still being flexible enough to handle multiple apps and different types of secret data. In the final section of this chapter, we’ll outline some options for encryption/decryption tools you can use to do this, but first, let’s briefly describe the other secrets management strategies.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use a Dedicated Secrets Management Tool" data-type="sect2"><div class="sect2" id="idm45979379836624">&#13;
<h2>Use a Dedicated Secrets Management Tool</h2>&#13;
&#13;
<p><a data-primary="Secrets" data-secondary="dedicated management tool" data-type="indexterm" id="idm45979379835376"/>While encrypting secrets in source code is a relatively easy way to get started, you may want to evaluate using a dedicated secrets management tool, such as <a href="https://www.vaultproject.io">HashiCorp’s Vault</a> or <a href="https://square.github.io/keywhiz">Square’s Keywhiz</a>. You could also consider using a managed cloud service such as <a href="https://oreil.ly/IVAhS">AWS Secrets Manager</a>, <a href="https://oreil.ly/4WaXg">Azure’s Key Vault</a>, or <a href="https://oreil.ly/257Ue">Google’s Secret Manager</a>. These tools handle the secure storing of all of your application secrets in one central place in a highly available way, and can also control which users and service accounts have permissions to add, remove, change, or view secrets.</p>&#13;
&#13;
<p>In a secrets management system, all actions are audited and reviewable, making it easier to analyze security breaches and prove regulatory compliance. Some of these tools also provide the ability to automatically rotate secrets on a regular basis, which is not only a good idea in any case, but is also required by many corporate security policies. Developers can have their own individual credentials, with permission to read or write secrets for only the applications that they’re responsible for.</p>&#13;
&#13;
<p>How do applications get their data from a secrets management tool? One common way is to use a service account with read-only access to the secrets vault so that each application can only read the secrets it needs. Often an Init container (see <a data-type="xref" href="ch08.html#init-containers">“Init Containers”</a>) is used to first pull and decrypt the secrets and then mount them into the Pod using a Volume.</p>&#13;
&#13;
<p>While a central secrets management system is the most powerful and flexible option available, it also adds significant complexity to your infrastructure, especially if you decide to host the tooling yourself. Using a managed solution would free you up from running this infrastructure, but they come with added cost to your cloud bill. You will also need to implement a process or some middleware to your applications to consume secrets securely. While applications could be built to access a particular secrets vault directly, this may be more expensive and time-consuming than simply adding a layer in front of them that gets secrets and puts them in the application’s environment or config file at startup time.<a data-startref="ix_10-config-adoc3" data-type="indexterm" id="idm45979379803456"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Encrypting Secrets with Sops" data-type="sect1"><div class="sect1" id="sops">&#13;
<h1>Encrypting Secrets with Sops</h1>&#13;
&#13;
<p><a data-primary="Secrets" data-secondary="encrypting with Sops" data-type="indexterm" id="ix_10-config-adoc4"/><a data-primary="Sops" data-secondary="encrypting secrets with" data-type="indexterm" id="ix_10-config-adoc5"/>Let’s now look at a popular encryption tool that you can use for storing your secrets securely in source control. Sops (short for <em>secrets operations</em>), from the Mozilla project, is an encryption/decryption tool that is compatible with YAML, JSON, or binary files, and supports multiple encryption backends, including <a href="https://oreil.ly/d6jtA"><code>age</code></a>, <a href="https://oreil.ly/4WaXg">Azure Key Vault</a>, <a href="https://oreil.ly/pyDJT">AWS’s Key Management Service (KMS)</a>, and <a href="https://oreil.ly/N7Bo4">Google’s Cloud KMS</a>. Visit the <a href="https://oreil.ly/7oGbC">Sops project home page</a> for installation and usage instructions.</p>&#13;
&#13;
<p>Rather than encrypting the whole file, Sops encrypts only the individual secret values in key-value pairs. For example, if your plain-text file contains:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">password</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">foo</code><code class="w"/></pre>&#13;
&#13;
<p>when you encrypt it with Sops, the resulting file will look like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">password</code><code class="p">:</code><code class="w"> </code><strong><code class="l-Scalar-Plain">ENC[AES256_GCM,data:p673w==,iv:YY=,aad:UQ=,tag:A=]</code></strong></pre>&#13;
&#13;
<p>This makes it easy to review the code without needing to decrypt the value in order to understand which key is being used.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Encrypting a File with Sops" data-type="sect2"><div class="sect2" id="idm45979379760480">&#13;
<h2>Encrypting a File with Sops</h2>&#13;
&#13;
<p>Let’s try out Sops by encrypting a file. As we mentioned, Sops doesn’t actually handle encryption itself; it delegates that to a different backend tool. We’ll use Sops with a tool called <code>age</code> in this example to encrypt a file containing a secret. The end result will be a file that you could safely commit to version control.</p>&#13;
&#13;
<p>We won’t get into the details of how exactly encryption with <code>age</code> works, but just know that, like SSH and TLS, it’s a <em>public key</em> cryptosystem. Instead of encrypting data with a single key, it actually uses a pair of keys: one public, one private. You can safely share your public key with others, but you should never give out your private key.</p>&#13;
&#13;
<p>Let’s generate your key pair now. First, <a href="https://oreil.ly/CPGhH">install age</a>, if you haven’t already.</p>&#13;
&#13;
<p>Once that’s installed, run this command to generate a new key pair:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">age-keygen -o key.txt</code></strong><code class="go">&#13;
</code><code class="go">Public key: age1fea...</code></pre>&#13;
&#13;
<p>Once your key has been successfully generated, make a note of the <code>Public key</code>. It will be unique to you and identifies the key you just created. The <em>key.txt</em> file also contains your private key, so it should be stored securely and never committed into source control.</p>&#13;
&#13;
<p>Now let’s encrypt a file using Sops and <code>age</code>. You will also need to have Sops installed on your machine, if you haven’t already.</p>&#13;
&#13;
<p>First let’s create a test secret YAML file to encrypt:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">echo "password: secret123" &gt; test.yaml</code></strong><code class="go">&#13;
</code><strong><code class="go">cat test.yaml</code></strong><code class="go">&#13;
</code><code class="go">password: secret123</code></pre>&#13;
&#13;
<p>And now, use Sops to encrypt it. Pass your key fingerprint to the <code>--age</code> switch and your <code>Public key</code> from above, like this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">sops --age age1fea... --encrypt --in-place test.yaml</code></strong><code class="go">&#13;
</code><strong><code class="go">cat test.yaml</code></strong><code class="go">&#13;
</code><code class="go">password: ENC[AES256_GCM,data:6U6tZpn/TCTG,iv:yfO6...&#13;
</code><code class="go">...&#13;
</code><code class="go">sops:&#13;
</code><code class="go">  ...&#13;
</code><code class="go">  age:&#13;
</code><code class="go">    - recipient: age1fea...</code></pre>&#13;
&#13;
<p>Success! The <em>test.yaml</em> file is encrypted securely, and the value of <code>password</code> is scrambled and can only be decrypted with your private key. You will also notice that Sops added some metadata to the bottom of the file so that it will know how to decrypt it in the future.</p>&#13;
&#13;
<p>A nice feature of Sops is that because only the <em>value</em> of <code>password</code> is encrypted, the YAML format of the file is preserved and you can still view the names of the keys.</p>&#13;
&#13;
<p>To make sure that we can get the encrypted data back, and to check that it matches what we put in, run:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">SOPS_AGE_KEY_FILE=$(pwd)/key.txt sops --decrypt test.yaml</code></strong><code class="go">&#13;
</code><code class="go">password: secret123</code></pre>&#13;
&#13;
<p>The <code>SOPS_AGE_KEY_FILE</code> part of the command points to the location of the key file you originally generated with <code>age</code>. You could consider storing that file in the default location that Sops expects, which is your <em>$HOME/sops/</em> directory.</p>&#13;
&#13;
<p>When it comes time to deploy the application, you can use Sops in decrypt mode to produce the plain-text secrets that your application uses—but remember to delete the plain-text files afterward, and don’t ever check them in to version control!</p>&#13;
&#13;
<p>When using Sops as part of a centralized CI/CD pipeline, your deploy server infrastructure would also need an <code>age</code> key and to be a <a href="https://oreil.ly/zjPJs">trusted recipient</a> in order to decrypt the file.</p>&#13;
&#13;
<p>Now that you know how to use Sops, you can encrypt any sensitive data in your source code, whether that’s application config files, Kubernetes YAML resources, or anything else. Later on, we’ll show you how to use Sops this way with Helm charts. You can not only decrypt secrets when deploying your application with Helm, but also use different sets of secrets, depending on the deployment environment: for example, <code>staging</code> versus <code>production</code> (see <a data-type="xref" href="ch12.html#helmsops">“Managing Helm Chart Secrets with Sops”</a>).</p>&#13;
&#13;
<p>It is also worth mentioning that if you need to manage encrypted secrets inside of a Helm chart, you can do that with a plugin called <code>helm-secrets</code>. When you run <code>helm upgrade...</code> or <code>helm install...</code>, <code>helm-secrets</code> will decrypt your secrets for deployment. For more information about <code>helm-secrets</code>, including installation and usage instructions, consult the <a href="https://oreil.ly/p3KBj">GitHub repo</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using a KMS Backend" data-type="sect2"><div class="sect2" id="kms">&#13;
<h2>Using a KMS Backend</h2>&#13;
&#13;
<p><a data-primary="KMS (Key Management Service)" data-type="indexterm" id="idm45979379620880"/>If you are using Amazon KMS or Google Cloud KMS for key management in the cloud, you can also use them with Sops. Using a KMS key works exactly the same as in our <code>age</code> example, but the metadata in the file will be different. Instead, the <code>sops:</code> section at the bottom might look something like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">sops</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">kms</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">created_at</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1441570389.775376</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">enc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CiC....Pm1Hm</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">arn</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">arn:aws:kms:us-east-1:656532957310:key/920aff2e...</code><code class="w"/></pre>&#13;
&#13;
<p>Just like with <code>age</code>, the key ID (<code>arn:aws:kms...</code>) is embedded in the file so that Sops knows how to decrypt it later.<a data-startref="ix_10-config-adoc5" data-type="indexterm" id="idm45979379596048"/><a data-startref="ix_10-config-adoc4" data-type="indexterm" id="idm45979379595376"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sealed Secrets" data-type="sect1"><div class="sect1" id="sealed-secrets">&#13;
<h1>Sealed Secrets</h1>&#13;
&#13;
<p><a data-primary="Sealed Secrets" data-type="indexterm" id="idm45979379593136"/><a data-primary="Secrets" data-secondary="Sealed Secrets" data-type="indexterm" id="idm45979379592432"/>Another good option for storing encrypted secrets in source control is an open source tool maintained by the folks at Bitnami called <a href="https://oreil.ly/Lq6Zo">Sealed Secrets</a>. Unlike with Sops, in this case the encryption keys are actually generated, installed, and stored inside of your Kubernetes clusters, making the deployment and decryption process straightforward.</p>&#13;
&#13;
<p>Once Sealed Secrets is installed, you can use the <code>kubeseal</code> client tool to encrypt a Kubernetes Secret. This generates a new <code>SealedSecret</code> that can then be safely committed into your source control repo, much like the encrypted YAML files with Sops. When applied to the cluster, the Sealed Secret tooling will decrypt the <code>SealedSecret</code> object from inside Kubernetes and securely pass it to your application Pods.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45979379588784">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Configuration and secrets is one of the topics that people ask us about the most in relation to Kubernetes. We’re glad to be able to devote a chapter to it, and to outline some ways you can connect your applications with the settings and data they need.</p>&#13;
&#13;
<p>The most important things we’ve learned:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Separate your configuration data from application code and deploy it using Kubernetes ConfigMaps and Secrets. That way, you don’t need to redeploy your app every time you change a password.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can get data into ConfigMaps by writing it directly in your Kubernetes manifest file, or use <code>kubectl</code> to convert an existing YAML file into a ConfigMap spec.</p>&#13;
</li>&#13;
<li>&#13;
<p>Once data is in a ConfigMap, you can insert it into a container’s environment, or into the command-line arguments of its entrypoint. Alternatively, you can write the data to a file that is mounted on the container.</p>&#13;
</li>&#13;
<li>&#13;
<p>Secrets work just like ConfigMaps, except that the data is encrypted at rest, and obfuscated in <code>kubectl</code> output.</p>&#13;
</li>&#13;
<li>&#13;
<p>A simple way to manage secrets is to store them directly in your source code repo, but encrypt them using Sops or another text-based encryption tool.</p>&#13;
</li>&#13;
<li>&#13;
<p>Don’t overlook secrets management, especially at first. Start with something your team understands and that provides a secure process for managing secrets on your team.</p>&#13;
</li>&#13;
<li>&#13;
<p>Dedicated secret management tools like Vault, or hosted cloud KMS tools, add cost and complexity to your stack, but offer better auditing and flexibility for securing your secrets.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sops is an encryption tool that works with key-value files like YAML and JSON. It can get its encryption key from a local keyring, or cloud key management services like Amazon KMS and Google Cloud KMS.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sealed Secrets makes it easy to store encrypted secrets in source control and securely pass them to your applications from within a Kubernetes cluster.<a data-startref="ix_10-config-adoc2" data-type="indexterm" id="idm45979379546640"/><a data-startref="ix_10-config-adoc1" data-type="indexterm" id="idm45979379546032"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>