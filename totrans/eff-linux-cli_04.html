<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Rerunning Commands"><div class="chapter" id="ch_history">
<h1><span class="label">Chapter 3. </span>Rerunning Commands</h1>


<p>Suppose you’ve just executed a lengthy command with a detailed
pipeline, like this one from <a data-type="xref" href="ch01.xhtml#sec_duplicate_files">“Detecting Duplicate Files”</a>:</p>

<pre data-type="programlisting">$ <strong>md5sum *.jpg | cut -c1-32 | sort | uniq -c | sort -nr</strong></pre>

<p>and you want to run it a second time. Don’t retype it!  Instead, ask
the shell to reach back into history and rerun the command. Behind the
scenes, the shell keeps a record of the commands you invoke so you can
easily recall and rerun them with a few keystrokes. This shell feature
is called <em>command history</em>.<a data-type="indexterm" data-primary="command history" id="idm46586642339264"/> Expert Linux users make heavy use of
command history to speed up their work and avoid wasting time.</p>

<p>Similarly, suppose you make a mistake typing the preceding command
before you run it, such as misspelling “jpg” as “jg”:</p>
<pre data-type="programlisting">$ <strong>md5sum <mark class="box">*.jg</mark> | cut -c1-32 | sort | uniq -c | sort -nr</strong></pre>

<p>To fix the mistake, don’t press the Backspace key dozens of times and
retype everything. Instead, change the command in place. The shell
supports <em>command-line editing</em> <a data-type="indexterm" data-primary="command-line editing" id="idm46586642335168"/> for fixing typos and performing all
sorts of modifications like a text editor can.</p>

<p>This chapter will show you how to save lots of time and typing by
leveraging command history and command-line editing. As
usual, I won’t attempt to be comprehensive—I’ll focus on the most
practical and useful parts of these shell features. (If you use a
shell other than <code>bash</code>, see <a data-type="xref" href="app02.xhtml#appendix_shells">Appendix B</a> for additional notes.)</p>
<div data-type="tip"><h1>Learn to Touch-Type</h1>
<p>All the advice in this book will serve you better if you can type
quickly.<a data-type="indexterm" data-primary="touch typing" id="idm46586642331344"/><a data-type="indexterm" data-primary="typing speed" id="idm46586642330640"/> No matter how knowledgeable you are, if you type 40 words per
minute and your equally knowledgeable friend types 120, they’re set up
to work three times as fast as you. Search the web for “typing speed
test” to measure your speed, then search for “typing tutor”<a data-type="indexterm" data-primary="tutorials" data-secondary="typing" id="idm46586642329840"/> and build
a lifelong skill. Try to reach 100 words per minute. It’s worth the
effort.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Viewing the Command History"><div class="sect1" id="idm46586642328400">
<h1>Viewing the Command History</h1>

<p><a data-type="indexterm" data-primary="command history" id="commandhistory"/>
A <em>command history</em> is simply a list of previous commands that you’ve
executed in an interactive shell. To see a shell’s history, run the
<code>history</code><a data-type="indexterm" data-primary="history command" id="idm46586642324976"/><a data-type="indexterm" data-primary="builtins" data-secondary="history" id="idm46586642324272"/> command, which is a shell builtin. The commands appear in
chronological order with ID numbers for easy reference. The output
looks something like this:</p>

<pre data-type="programlisting">$ <strong>history</strong>
 1000  cd $HOME/Music
 1001  ls
 1002  mv jazz.mp3 jazzy-song.mp3
 1003  play jazzy-song.mp3
 ⋮                                      <em>Omitting 479 lines</em>
 1481  cd
 1482  firefox https://google.com
 1483  history                         <em>Includes the command you just ran</em></pre>

<p>The output of <code>history</code> can be hundreds of lines long (or more).
Limit it to the most recent commands by adding an integer
argument, which specifies the number of lines to print:<a data-type="indexterm" data-primary="command history" data-secondary="number of lines of output" id="idm46586642320304"/></p>

<pre data-type="programlisting">$ <strong>history 3</strong>                            <em>Print the 3 most recent commands</em>
 1482  firefox https://google.com
 1483  history
 1484  history 3</pre>

<p>Since <code>history</code> writes to stdout, you also can process the output with
pipes.<a data-type="indexterm" data-primary="command history" data-secondary="piping" id="idm46586642316864"/> For example, view your history a screenful at a time:</p>

<pre data-type="programlisting">$ <strong>history | less</strong>                      <em>Earliest to latest entry</em>
$ <strong>history | sort -nr | less</strong>           <em>Latest to earliest entry</em></pre>

<p>or print only the historical commands containing the word <code>cd</code>:</p>

<pre data-type="programlisting">$ <strong>history | grep -w cd</strong>
 1000  cd $HOME/Music
 1092  cd ..
 1123  cd Finances
 1375  cd Checking
 1481  cd
 1485  history | grep -w cd</pre>

<p>To clear (delete) the history for the current shell, use the <code>-c</code> option:<a data-type="indexterm" data-primary="history command" data-secondary="clearing (-c option)" id="idm46586642310368"/><a data-type="indexterm" data-primary="command history" data-secondary="deleting" id="idm46586642309360"/></p>

<pre data-type="programlisting">$ <strong>history -c</strong></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Recalling Commands from the History"><div class="sect1" id="idm46586642327808">
<h1>Recalling Commands from the History</h1>

<p>I’ll show you three time-saving ways to recall commands from a shell’s
history:</p>
<dl>
<dt>Cursoring</dt>
<dd>
<p>Extremely simple to learn but often slow in practice</p>
</dd>
<dt>History expansion</dt>
<dd>
<p>Harder to learn (frankly, it’s cryptic) but can be very fast</p>
</dd>
<dt>Incremental search</dt>
<dd>
<p>Both simple and fast</p>
</dd>
</dl>

<p>Each method is best in particular situations, so I recommend learning
all three. The more techniques you know, the better you can choose the
right one in any situation.</p>








<section data-type="sect2" data-pdf-bookmark="Cursoring Through History"><div class="sect2" id="idm46586642300496">
<h2>Cursoring Through History</h2>

<p><a data-type="indexterm" data-primary="cursoring (cursor keys)" data-secondary="command history" id="idm46586642299120"/><a data-type="indexterm" data-primary="command history" data-secondary="cursoring" id="idm46586642298144"/><a data-type="indexterm" data-primary="command history" data-secondary="up/down arrow keys" id="idm46586642297200"/><a data-type="indexterm" data-primary="arrow keys" data-secondary="command history" id="idm46586642296256"/>
To recall your previous command in a given shell, press the up arrow
key. It’s that simple. Keep pressing the up arrow to recall earlier
commands in reverse chronological order. Press the down arrow to head
in the other direction (toward more recent commands).  When you reach
the desired command, press Enter to run it.</p>

<p>Cursoring through the command history is one of the two most common
speedups that Linux users learn. (The other is pattern matching
filenames with <code>*</code>,<a data-type="indexterm" data-primary="* (asterisk)" data-secondary="filename pattern matching" id="idm46586642294224"/><a data-type="indexterm" data-primary="asterisk (*)" data-secondary="filename pattern matching" id="idm46586642293152"/>
which you saw in <a data-type="xref" href="ch02.xhtml#ch_shell">Chapter 2</a>.) Cursoring is
efficient if your desired command is nearby in the history—no more
than two or three commands in the past—but it’s tedious to reach
commands that are further away. Whacking the up arrow 137 times gets
old quickly.</p>

<p>The best use case for cursoring is recalling and running the
immediately previous command. On many keyboards, the up arrow key is
near the Enter key, so you can press the two keys in sequence with a
quick flick of the fingers. On a full-sized American QWERTY keyboard,
I place my right ring finger on the up arrow and my right index finger
on Enter to tap both keys efficiently. (Try it.)</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sb_history_faq">
<h5>Frequently Asked Questions About Command History</h5><dl>
<dt>How many commands are stored in a shell’s history?</dt>
<dd>
<p>The maximum is five hundred or whatever number is stored in the
shell variable <code>HISTSIZE</code>,<a data-type="indexterm" data-primary="HISTSIZE variable" id="idm46586642286752"/><a data-type="indexterm" data-primary="variables" data-secondary="HISTSIZE" id="idm46586642286016"/><a data-type="indexterm" data-primary="command history" data-secondary="size" id="idm46586642285072"/> which you can change:</p>

<pre data-type="programlisting">$ <strong>echo $HISTSIZE</strong>
500
$ <strong>HISTSIZE=10000</strong></pre>

<p>Computer memory is so cheap and plentiful that it makes sense to set
<code>HISTSIZE</code> to a large number so you can recall and rerun commands
from the distant past. (A history of 10,000 commands occupies only
about 200K of memory.) Or be daring and store unlimited
commands by setting the value to <code>-1</code>.</p>
</dd>
<dt>What text is appended to the history?</dt>
<dd>
<p>  The shell appends exactly what you type, unevaluated.<a data-type="indexterm" data-primary="command history" data-secondary="appending to" id="idm46586642279920"/> If you run <code>ls
$HOME</code>, the history will contain “ls $HOME”, not “ls /home/smith”.
(There’s one exception: see <a data-type="xref" href="#note_bang_notation">“History Expressions Don’t Appear in the Command History”</a>.)</p>
</dd>
<dt>Are repeated commands appended to the history?</dt>
<dd>
<p>   The answer depends on the value of the variable <code>HISTCONTROL</code>.<a data-type="indexterm" data-primary="command history" data-secondary="repeated commands" id="idm46586642275408"/><a data-type="indexterm" data-primary="HISTCONTROL variable" id="idm46586642274400"/><a data-type="indexterm" data-primary="variables" data-secondary="HISTCONTROL" id="idm46586642273728"/> By
default, if this variable is unset, then every command is appended.
If the value is <code>ignoredups</code><a data-type="indexterm" data-primary="command history" data-secondary="ignoring duplicates" id="idm46586642272288"/> (which I recommend), then repeated
commands are not appended if they are consecutive (see <code>man bash</code> for
other values):</p>

<pre data-type="programlisting">$ <strong>HISTCONTROL=ignoredups</strong></pre>
</dd>
<dt>Does each shell have a separate history, or do all shells share a single history?</dt>
<dd>
<p>Each interactive shell has a separate history.<a data-type="indexterm" data-primary="command history" data-secondary="separate versus shared" id="idm46586642268432"/></p>
</dd>
<dt>I launched a new interactive shell and it already has a history. Why?</dt>
<dd>
<p>  Whenever an interactive shell exits, it writes its history to
the file <em>$HOME/.bash_history</em> or whatever path is stored in the
shell variable <code>HISTFILE</code>:<a data-type="indexterm" data-primary="command history" data-secondary="storage location" id="idm46586642265024"/><a data-type="indexterm" data-primary="HISTFILE variable" id="idm46586642264016"/><a data-type="indexterm" data-primary="variables" data-secondary="HISTFILE" id="idm46586642263344"/></p>

<pre data-type="programlisting">$ <strong>echo $HISTFILE</strong>
/home/smith/.bash_history</pre>

<p>New interactive shells load this file on startup, so they immediately
have a history.  It’s a quirky system if you’re running many shells
because they <em>all</em> write <code>$HISTFILE</code> on exit, so it’s a bit
unpredictable which history a new shell will load.</p>

<p>The variable <code>HISTFILESIZE</code><a data-type="indexterm" data-primary="command history" data-secondary="size" data-tertiary="storage size" id="idm46586642259152"/><a data-type="indexterm" data-primary="HISTFILESIZE variable" id="idm46586642257904"/><a data-type="indexterm" data-primary="variables" data-secondary="HISTFILESIZE" id="idm46586642257232"/> controls how many lines of history are
written to the file. If you change <code>HISTSIZE</code> to control the size of
the history in memory, consider updating <code>HISTFILESIZE</code> as well:</p>

<pre data-type="programlisting">$ <strong>echo $HISTFILESIZE</strong>
500
$ <strong>HISTFILESIZE=10000</strong></pre>
</dd>
</dl>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="History Expansion"><div class="sect2" id="idm46586642253520">
<h2>History Expansion</h2>

<p><a data-type="indexterm" data-primary="history expansion" id="historyexpansion"/><a data-type="indexterm" data-primary="command history" data-secondary="expansion" data-see="history expansion" id="idm46586642250560"/>
History expansion is a shell feature that accesses the command history
using special expressions. The expressions begin with an exclamation
point,<a data-type="indexterm" data-primary="! (exclamation point) for history expansion" data-seealso="history expansion" id="idm46586642249056"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="! for history expansion" data-seealso="history expansion" id="idm46586642248016"/><a data-type="indexterm" data-primary="bang (!)" id="idm46586642246800"/> which traditionally is pronounced “bang.” For example, two
exclamation points in a row (“bang bang”) evaluates to the immediately
previous command<a data-type="indexterm" data-primary="previous command" id="idm46586642246000"/>:<a data-type="indexterm" data-primary="!! for previous command" id="idm46586642245200"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="!! for previous command" id="idm46586642244496"/></p>

<pre data-type="programlisting">$ <strong>echo Efficient Linux</strong>
Efficient Linux
$ <strong>!!</strong>                            <em>"Bang bang" = previous command</em>
echo Efficient Linux            <em>The shell helpfully prints the command being run</em>
Efficient Linux</pre>

<p>To refer to the most recent command that began with a certain string,
place an exclamation point in front of that string. So, to rerun the
most recent <code>grep</code> command, run “bang grep”:</p>

<pre data-type="programlisting">$ <strong>!grep</strong>
grep Perl animals.txt
alpaca	Intermediate Perl	2012	Schwartz, Randal</pre>

<p>To refer to the most recent command that contained a given string
<em>somewhere</em>, not just at the beginning of the command, surround the
string with question marks as well:<sup><a data-type="noteref" id="idm46586642237936-marker" href="ch03.xhtml#idm46586642237936">1</a></sup><a data-type="indexterm" data-primary="!? for command history search" id="idm46586642236064"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="!? for command history search" id="idm46586642235328"/><a data-type="indexterm" data-primary="history expansion" data-secondary="search" id="idm46586642234368"/></p>

<pre data-type="programlisting">$ <strong>!?grep?</strong>
history | grep -w cd
 1000  cd $HOME/Music
 1092  cd ..
⋮</pre>

<p>You can also retrieve a particular command from a shell’s history by
its absolute position—the ID number to its left in the output of
<code>history</code>. For example, the expression <code>!1203</code> (“bang 1023”) means
“the command at position 1023 in the history”:<a data-type="indexterm" data-primary="command history" data-secondary="absolute position" id="idm46586642230832"/><a data-type="indexterm" data-primary="/etc/hosts file" id="idm46586642229856"/><a data-type="indexterm" data-primary="/etc/hosts file" data-primary-sortas="etc hosts" id="idm46586642229184"/></p>

<pre data-type="programlisting">$ <strong>history | grep hosts</strong>
 1203  cat /etc/hosts
$ <strong>!1203</strong>                         <em>The command at position 1023</em>
cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       example.oreilly.com
::1             example.oreilly.com</pre>

<p>A negative value retrieves a command by its relative position<a data-type="indexterm" data-primary="command history" data-secondary="relative position" id="idm46586642225552"/> in the
history, rather than absolute position. For example, <code>!-3</code> (“bang
minus three”) means “the command you executed three commands ago”:</p>

<pre data-type="programlisting">$ <strong>history</strong>
 4197  cd /tmp/junk
 4198  rm *
 4199  head -n2 /etc/hosts
 4199  cd
 4200  history
$ <strong>!-3</strong>                         <em>The command you executed three commands ago</em>
head -n2 /etc/hosts
127.0.0.1       localhost
127.0.1.1       example.oreilly.com</pre>

<p>History expansion is quick and convenient, if a bit cryptic. It can be
risky, however, if you provide a wrong value and execute it
blindly. Look carefully at the preceding example. If you miscounted
and typed <code>!-4</code> instead of <code>!-3</code>, you’d run <code>rm *</code> instead of the
intended <code>head</code> command and delete files in your home directory by
mistake! To mitigate this risk, append the modifier <code>:p</code><a data-type="indexterm" data-primary="history expansion" data-secondary="printing only (:p modifier)" id="idm46586642218880"/><a data-type="indexterm" data-primary=": (colon)" data-secondary="history expansion" id="idm46586642217840"/><a data-type="indexterm" data-primary="colon (:)" data-secondary="history expansion" id="idm46586642216896"/>
to print the command from your history but not execute it:</p>

<pre data-type="programlisting">$ <strong>!-3:p</strong>
head -n2 /etc/hosts              <em>Printed, not executed</em></pre>

<p>The shell appends the unexecuted command (<code>head</code>) to the history, so
if it looks good, you can run it conveniently with a quick “bang bang”:</p>

<pre data-type="programlisting">$ <strong>!-3:p</strong>
head -n2 /etc/hosts              <em>Printed, not executed, and appended to history</em>
$ <strong>!!</strong>                             <em>Run the command for real</em>
head -n2 /etc/hosts              <em>Printed and then executed</em>
127.0.0.1       localhost
127.0.1.1       example.oreilly.com</pre>

<p>Some people refer to history expansion as “bang commands,”<a data-type="indexterm" data-primary="bang commands" data-see="history expansion" id="idm46586642209600"/><a data-type="indexterm" data-primary="!! for previous command" id="idm46586642208544"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="!! for previous command" id="idm46586642207872"/> but
expressions like <code>!!</code> and <code>!grep</code> are not commands. They are string
expressions<a data-type="indexterm" data-primary="history expansion" data-secondary="strings versus commands" id="idm46586642205872"/> that you can place <em>anywhere</em> in a command. As a
demonstration, use <code>echo</code> to print the value of <code>!!</code> on stdout without
executing it, and count the number of words with <code>wc</code>:</p>

<pre data-type="programlisting">$ <strong>ls -l /etc | head -n3</strong>       <em>Run any command</em>
total 1584
drwxr-xr-x  2 root     root       4096 Jun 16 06:14 ImageMagick-6/
drwxr-xr-x  7 root     root       4096 Mar 19  2020 NetworkManager/

$ <strong>echo "!!" | wc -w</strong>           <em>Count the words in the previous command</em>
echo "ls -l /etc | head -n3" | wc -w
6</pre>

<p>This toy example demonstrates that history expansions have more uses
than executing commands. You’ll see a more practical, powerful
technique in the next section.</p>

<p>I’ve covered only a few features of command history here.  For full
information, run <code>man history</code>.</p>
<div data-type="note" epub:type="note" id="note_bang_notation"><h1>History Expressions Don’t Appear in the Command History</h1>
<p>The shell appends commands to the history verbatim—unevaluated—as I mentioned in <a data-type="xref" href="#sb_history_faq">“Frequently Asked Questions About Command History”</a>. The one exception<a data-type="indexterm" data-primary="command history" data-secondary="appending to" data-tertiary="exception for history expansion" id="idm46586642196592"/><a data-type="indexterm" data-primary="history expansion" data-secondary="appending to command history" id="idm46586642195280"/> to this rule
is history expansion. Its expressions are always evaluated before
they’re added to the command history:</p>

<pre data-type="programlisting">$ <strong>ls</strong>               <em>Run any command</em>
hello.txt
$ <strong>cd Music</strong>         <em>Run some other command</em>
$ <strong>!-2</strong>              <em>Use history expansion</em>
ls
song.mp3
$ <strong>history</strong>          <em>View the history</em>
 1000  ls
 1001  cd Music
 1002  ls          <em>"ls" appears in the history, not "!-2"</em>
 1003  history</pre>

<p>This exception makes sense. Imagine trying to understand a command
history full of expressions like <code>!-15</code> and <code>!-92</code> that refer to other
history entries. You might have to trace a path through the whole
history by eye to understand a single command.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Never Delete the Wrong File Again (Thanks to History Expansion)"><div class="sect2" id="cs_never_delete">
<h2>Never Delete the Wrong File Again (Thanks to History Expansion)</h2>

<p><a data-type="indexterm" data-primary="file" data-secondary="removing" data-tertiary="accident prevention" id="idm46586642185904"/><a data-type="indexterm" data-primary="deleting files" data-secondary="accident prevention" id="idm46586642184656"/><a data-type="indexterm" data-primary="removing files" data-secondary="accident prevention" id="idm46586642183712"/>
Have you ever meant to delete files using a pattern, such as <code>*.txt</code>,
but accidentally mistyped the pattern and wiped out the wrong files?
Here’s an example with an accidental space character after the
asterisk:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
123  a.txt   b.txt   c.txt  dont-delete-me  important-file  passwords
$ <strong>rm * .txt</strong>       <em>DANGER!! Don't run this! Deletes the wrong files!</em></pre>

<p>The most common solution to this hazard is to alias <code>rm</code> to run <code>rm -i</code><a data-type="indexterm" data-primary="rm command" data-secondary="interactive (-i option)" id="idm46586642178896"/>
so it prompts for confirmation before each deletion:</p>
<pre data-type="programlisting">$ <strong>alias rm='rm -i'</strong>                  <em>Often found in a shell configuration file</em>
$ <strong>rm *.txt</strong>
/bin/rm: remove regular file 'a.txt'? <strong>y</strong>
/bin/rm: remove regular file 'b.txt'? <strong>y</strong>
/bin/rm: remove regular file 'c.txt'? <strong>y</strong></pre>

<p>As a result, an extra space character needn’t be fatal, because the
prompts from <code>rm -i</code> will warn that you’re removing the wrong files:</p>

<pre data-type="programlisting">$ <strong>rm * .txt</strong>
/bin/rm: remove regular file '123'?      <em>Something is wrong: kill the command</em></pre>

<p>The alias solution is cumbersome, however, because most of the time
you might not want or need <code>rm</code> to prompt you. It also doesn’t work if
you’re logged into another Linux machine without your aliases. I’ll
show you a better way to avoid matching the wrong filenames with
a pattern. The technique has two steps and relies on history expansion:</p>
<ol>
<li>
<p><em>Verify</em>. Before running <code>rm</code>, run <code>ls</code> with the desired pattern to see
which files match.</p>

<pre data-type="programlisting">$ <strong>ls *.txt</strong>
a.txt   b.txt   c.txt</pre>
</li>
<li>
<p><em>Delete</em>. If the output of <code>ls</code> looks correct, run <code>rm !$</code> to delete
the same files that were matched.<sup><a data-type="noteref" id="idm46586642165264-marker" href="ch03.xhtml#idm46586642165264">2</a></sup></p>

<pre data-type="programlisting">$ <strong>rm !$</strong>
rm *.txt</pre>
</li>

</ol>

<p>The history expansion <code>!$</code><a data-type="indexterm" data-primary="!$ for final word of previous command" id="idm46586642161696"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="!$ for final word of previous command" id="idm46586642160944"/><a data-type="indexterm" data-primary="final word on a line" data-secondary="matching, history expansion" id="idm46586642159984"/><a data-type="indexterm" data-primary="last word on a line" data-see="final word on a line" id="idm46586642159088"/> (“bang dollar”) means “the final word that
you typed in the previous command.” Therefore, <code>rm !$</code> here is
shorthand for “delete whatever I just listed with <code>ls</code>,” namely,
<code>*.txt</code>. If you accidentally add a space after the asterisk, the
output of <code>ls</code> will make it obvious—safely—that something is
wrong:</p>

<pre data-type="programlisting">$ <strong>ls * .txt</strong>
/bin/ls: cannot access '.txt': No such file or directory
123  a.txt   b.txt   c.txt  dont-delete-me  important-file  passwords</pre>

<p>It’s a good thing you ran <code>ls</code> first instead of <code>rm</code>! You can now
modify the command to remove the extra space and proceed safely. This
two-command sequence—<code>ls</code> followed by <code>rm !$</code>—is a great safety
feature to incorporate into your Linux toolbox.</p>

<p>A related technique is peeking at a file’s contents with <code>head</code> before
you delete it, to make sure you’re targeting the right file, and then
running <code>rm !$</code>:</p>

<pre data-type="programlisting">$ <strong>head myfile.txt</strong>
<em>(first 10 lines of the file appear)</em>
$ <strong>rm !$</strong>
rm myfile.txt</pre>

<p>The shell also provides a history expansion <code>!*</code><a data-type="indexterm" data-primary="!* for arguments of previous command" id="idm46586642148256"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="!* for arguments of previous command" id="idm46586642147488"/> (“bang star”), which
matches all arguments you typed in the previous command, rather than
just the final argument:</p>

<pre data-type="programlisting">$ <strong>ls *.txt *.o *.log</strong>
a.txt   b.txt   c.txt   main.o   output.log   parser.o
$ <strong>rm !* </strong>
rm *.txt *.o *.log</pre>

<p>In practice, I use <code>!*</code> much less often than <code>!$</code>. Its asterisk
carries the same risk of being interpreted as a pattern-matching
character for filenames (if you mistype something), so it’s not much
safer than typing a pattern like <code>*.txt</code> by hand.<a data-type="indexterm" data-startref="historyexpansion" id="idm46586642142912"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Incremental Search of Command History"><div class="sect2" id="idm46586642187104">
<h2>Incremental Search of Command History</h2>

<p><a data-type="indexterm" data-primary="command history" data-secondary="incremental search" id="idm46586642140352"/><a data-type="indexterm" data-primary="incremental history search" id="idm46586642139472"/><a data-type="indexterm" data-primary="search, incremental" id="idm46586642138736"/>
Wouldn’t it be great if you could type a few characters of a command
and the rest would appear instantly, ready to run?  Well,
you can. This speedy feature of the shell, called <em>incremental
search</em>, is similar to the interactive suggestions provided by web
search engines. In most cases, incremental search is the easiest and
fastest technique to recall commands from history, even commands you
ran long ago. I highly recommend adding it to your toolbox:</p>
<ol>
<li>
<p>At the shell prompt, press Ctrl-R (the <em>R</em> stands for reverse incremental search).</p>
</li>
<li>
<p>Start typing <em>any part</em> of a previous command—beginning, middle, or end.</p>
</li>
<li>
<p>With each character you type, the shell displays the most recent
historical command that matches your typing so far.</p>
</li>
<li>
<p>When you see the command you want, press Enter to run it.</p>
</li>

</ol>

<p>Suppose you typed the command <code>cd $HOME/Finances/Bank</code> a while ago
and you want to rerun it. Press Ctrl-R at the shell prompt. The prompt
changes to indicate an incremental search:</p>

<pre data-type="programlisting">(reverse-i-search)`':</pre>

<p>Start typing the desired command. For example, type <code>c</code>:</p>

<pre data-type="programlisting">(reverse-i-search)`': <strong>c</strong></pre>

<p>The shell displays its most recent command that contains the string <code>c</code>,
highlighting what you’ve typed:</p>

<pre data-type="programlisting">(reverse-i-search)`': less /et<strong>c</strong>/hosts</pre>

<p>Type the next letter, <code>d</code>:</p>

<pre data-type="programlisting">(reverse-i-search)`': <strong>cd</strong></pre>

<p>The shell displays its most recent command that contains the string <code>cd</code>,
again highlighting what you’ve typed:</p>

<pre data-type="programlisting">(reverse-i-search)`': <strong>cd</strong> /usr/local</pre>

<p>Continue typing the command, adding a space and a dollar sign:</p>

<pre data-type="programlisting" class="pagebreak-after">(reverse-i-search)`': <strong>cd $</strong></pre>

<p>The command line becomes:</p>

<pre data-type="programlisting">(reverse-i-search)`': <strong>cd $</strong>HOME/Finances/Bank</pre>

<p>This is the command you want. Press Enter to run it, and you’re done
in five quick keystrokes.</p>

<p>I’ve assumed here that <code>cd $HOME/Finances/Bank</code> was the most recent
matching command in the history. What if it’s not? What if you typed a
whole bunch of commands that contain the same string? If so, the
preceding incremental search would have displayed a different match,
such as:</p>

<pre data-type="programlisting">(reverse-i-search)`': <strong>cd $</strong>HOME/Music</pre>

<p>What now? You could type more characters to hone in on your desired
command, but instead, press Ctrl-R a second time. This keystroke
causes the shell to jump to the <em>next</em> matching command in the history:</p>

<pre data-type="programlisting">(reverse-i-search)`': <strong>cd $</strong>HOME/Linux/Books</pre>

<p>Keep pressing Ctrl-R until you reach the desired command:</p>

<pre data-type="programlisting">(reverse-i-search)`': <strong>cd $</strong>HOME/Finances/Bank</pre>

<p>and press Enter to run it.</p>

<p>Here are a few more tricks with incremental search:</p>

<ul class="nobreakinside">
<li>
<p>To recall the most recent string that you searched for and executed,
begin by pressing Ctrl-R twice in a row.</p>
</li>
<li>
<p>To stop an incremental search and continue working on the current
command, press the Escape key, or Ctrl-J, or any key for command-line
editing (the next topic in this chapter), such as the left or right
arrow key.</p>
</li>
<li>
<p>To quit an incremental search and clear the command line, press
Ctrl-G or 
<span class="keep-together">Ctrl-C.</span></p>
</li>
</ul>

<p>Take the time to become expert with incremental search. You’ll soon be
locating commands with incredible speed.<sup><a data-type="noteref" id="idm46586642107296-marker" href="ch03.xhtml#idm46586642107296">3</a></sup><a data-type="indexterm" data-startref="commandhistory" id="idm46586642105424"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Command-Line Editing"><div class="sect1" id="idm46586642141136">
<h1>Command-Line Editing</h1>

<p><a data-type="indexterm" data-primary="command-line editing" id="commandlineediting"/><a data-type="indexterm" data-primary="editing a command line" data-see="command-line editing" id="idm46586642102624"/><a data-type="indexterm" data-primary="changing" data-secondary="command line text" data-see="command-line editing" id="idm46586642101680"/><a data-type="indexterm" data-primary="modifying a command line" data-see="command-line editing" id="idm46586642100464"/><a data-type="indexterm" data-primary="fixing a command line" data-see="command-line editing" id="idm46586642099456"/><a data-type="indexterm" data-primary="correcting a command line" data-see="command-line editing" id="idm46586642098512"/>
There are all sorts of reasons to edit a command, either while you
type it or after you’ve run it:</p>

<ul>
<li>
<p>To fix mistakes</p>
</li>
<li>
<p>To create a command piece by piece, such as by typing the end of the command
first, then moving to the start of the line and typing the beginning</p>
</li>
<li>
<p>To construct a new command based on a previous one from your command
history (a key skill for building up complex pipelines, as you’ll see
in <a data-type="xref" href="ch08.xhtml#ch_one_liner">Chapter 8</a>)</p>
</li>
</ul>

<p>In this section, I’ll show you three ways to edit a command to build
your skill and speed:</p>
<dl>
<dt>Cursoring</dt>
<dd>
<p>Again, the slowest and least powerful method
but simple to learn</p>
</dd>
<dt>Caret notation</dt>
<dd>
<p>A form of history expansion</p>
</dd>
<dt>Emacs- or Vim-style keystrokes</dt>
<dd>
<p>To edit the command line in powerful ways</p>
</dd>
</dl>

<p>As before, I recommend that you learn all three techniques for
flexibility.</p>








<section data-type="sect2" data-pdf-bookmark="Cursoring Within a Command"><div class="sect2" id="idm46586642087488">
<h2>Cursoring Within a Command</h2>

<p><a data-type="indexterm" data-primary="cursoring (cursor keys)" data-secondary="command-line editing" id="idm46586642086288"/><a data-type="indexterm" data-primary="command-line editing" data-secondary="cursoring" id="idm46586642085312"/><a data-type="indexterm" data-primary="command-line editing" data-secondary="left/right arrow keys" id="idm46586642084368"/><a data-type="indexterm" data-primary="arrow keys" data-secondary="command-line editing" id="idm46586642083424"/>
Simply press the left arrow and right arrow keys to move back and
forth on the command line, one character at a time. Use the Backspace
or Delete key to remove text, and then type any corrections you
need. <a data-type="xref" href="#table_edit_cursor">Table 3-1</a> summarizes these and other standard
keystrokes for editing the command line.</p>

<p>Cursoring back and forth is easy but inefficient. It’s best when the
changes are small and simple.<a data-type="indexterm" data-primary="command-line editing" data-secondary="keystrokes" data-tertiary="cursor keys" id="idm46586642080960"/></p>
<table id="table_edit_cursor" class="pagebreak-after">
<caption><span class="label">Table 3-1. </span>Cursor keys for simple command-line editing</caption>
<thead>
<tr>
<th>Keystroke</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Left arrow</p></td>
<td><p>Move left by one character</p></td>
</tr>
<tr>
<td><p>Right arrow</p></td>
<td><p>Move right by one character</p></td>
</tr>
<tr>
<td><p>Ctrl + left arrow</p></td>
<td><p>Move left by one word</p></td>
</tr>
<tr>
<td><p>Ctrl + right arrow</p></td>
<td><p>Move right by one word</p></td>
</tr>
<tr>
<td><p>Home</p></td>
<td><p>Move to beginning of command line</p></td>
</tr>
<tr>
<td><p>End</p></td>
<td><p>Move to end of command line</p></td>
</tr>
<tr>
<td><p>Backspace</p></td>
<td><p>Delete one character before the cursor</p></td>
</tr>
<tr>
<td><p>Delete</p></td>
<td><p>Delete one character beneath the cursor</p></td>
</tr>
</tbody>
</table>
</div></section>













<section data-type="sect2" class="less_space" data-pdf-bookmark="History Expansion with Carets"><div class="sect2" id="idm46586642062512">
<h2>History Expansion with Carets</h2>

<p><a data-type="indexterm" data-primary="history expansion" data-secondary="caret substitution" id="idm46586642060752"/><a data-type="indexterm" data-primary="^ (caret)" data-secondary="history expansion" id="idm46586642059776"/><a data-type="indexterm" data-primary="caret (^)" data-secondary="history expansion" id="idm46586642058832"/>
Suppose you’ve mistakenly run the following command by typing <code>jg</code>
instead of <code>jpg</code>:</p>

<pre data-type="programlisting">$ <strong>md5sum *.jg | cut -c1-32 | sort | uniq -c | sort -nr</strong>
md5sum: '*.jg': No such file or directory</pre>

<p>To run the command properly, you could recall it from the command
history, cursor over to the mistake and fix it, but there’s a quicker
way to accomplish your goal. Just type the old (wrong) text, the new
(corrected) text, and a pair of carets (<code>^</code>), like this:</p>

<pre data-type="programlisting">$ <strong>^jg^jpg</strong></pre>

<p>Press Enter, and the correct command will appear and run:</p>

<pre data-type="programlisting">$ <strong>^jg^jpg</strong>
md5sum *.jpg | cut -c1-32 | sort | uniq -c | sort -nr
⋮</pre>

<p>The <em>caret syntax</em>, which is a type of history expansion, means, “In the
previous command, instead of <code>jg</code>, substitute <code>jpg</code>.” Notice that the
shell helpfully prints the new command before executing it, which is
standard behavior for history expansion.</p>

<p>This technique changes only the first occurrence of the source string
(<code>jg</code>) in the command. If your original command contained <code>jg</code> more
than once, only the first instance would change to <code>jpg</code>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_sed_syntax">
<h5>More Powerful Substitution with History Expansion</h5>
<p>You<a data-type="indexterm" data-primary="history expansion" data-secondary="sed substitution" id="idm46586642046272"/> may be familiar with using the commands <code>sed</code> or <code>ed</code> to change a
source string into a target string:</p>

<pre data-type="programlisting">s/<em>source</em>/<em>target</em>/</pre>

<p>The shell also supports a similar syntax.  Begin with an expression for
history expansion to recall a command, such as <code>!!</code>. Then add a
colon,<a data-type="indexterm" data-primary=": (colon)" data-secondary="history expansion" id="idm46586642041600"/><a data-type="indexterm" data-primary="colon (:)" data-secondary="history expansion" id="idm46586642040592"/>
and end with a sed-style substitution. For example, to recall the
previous command and replace <code>jg</code> by <code>jpg</code> (first occurrence only),
just as caret notation does, run:</p>

<pre data-type="programlisting">$ <strong>!!:s/jg/jpg/</strong></pre>

<p>You may begin with any history expansion you like, such as <code>!md5sum</code>,
which recalls the most recent command beginning with <code>md5sum</code>, and perform
the same replacement of <code>jg</code> by <code>jpg</code>:</p>

<pre data-type="programlisting">$ <strong>!md5sum:s/jg/jpg/</strong></pre>

<p>This notation may look complicated, but sometimes it’s quicker
for achieving your goal than other command-line editing techniques.
Run <code>man history</code> for full details.</p>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Emacs- or Vim-Style Command-Line Editing"><div class="sect2" id="idm46586642061920">
<h2>Emacs- or Vim-Style Command-Line Editing</h2>

<p><a data-type="indexterm" data-primary="command-line editing" data-secondary="emacs style" id="idm46586642031744"/>
<a data-type="indexterm" data-primary="command-line editing" data-secondary="vim style" id="idm46586642030640"/>
The most powerful way to edit a command line is with familiar
keystrokes inspired by the text editors Emacs and Vim. If you’re
already skilled with one of these editors, you can jump into this
style of command-line editing right away. If not,
<a data-type="xref" href="#table_edit_emacs_vim">Table 3-2</a> will get you started with the most common
keystrokes for movement and editing. Note that the Emacs “Meta” key is
usually Escape (pressed and released) or Alt (pressed and held).</p>

<p>The shell default is Emacs-style editing, and I recommend it as easier
to learn and use. If you prefer Vim-style editing, run the following
command (or add it to your <em>$HOME/.bashrc</em> file and source it):<a data-type="indexterm" data-primary="set command" id="idm46586642027744"/><a data-type="indexterm" data-primary="builtins" data-secondary="set" id="idm46586642027008"/></p>

<pre data-type="programlisting">$ <strong>set -o vi</strong></pre>

<p>To edit a command using Vim keystrokes, press the Escape key to enter
command-editing mode, and then use keystrokes from the “Vim” column in
<a data-type="xref" href="#table_edit_emacs_vim">Table 3-2</a>. To switch back to Emacs-style editing, run:</p>

<pre data-type="programlisting">$ <strong>set -o emacs</strong></pre>

<p>Now practice, practice, practice until the keystrokes (either Emacs’s
or Vim’s) are second nature. Trust me, you’ll quickly be paid back in
saved time.</p>
<table id="table_edit_emacs_vim">
<caption><span class="label">Table 3-2. </span>Keystrokes for Emacs- or Vim-style editing<a data-type="indexterm" data-primary="command-line editing" data-secondary="keystrokes" data-tertiary="emacs and vim" id="idm46586642021248"/><sup><a data-type="noteref" id="idm46586642020000-marker" href="ch03.xhtml#idm46586642020000">a</a></sup></caption>
<thead>
<tr>
<th>Action</th>
<th>Emacs</th>
<th>Vim</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Move forward by one character</p></td>
<td><p>Ctrl-f</p></td>
<td><p>h</p></td>
</tr>
<tr>
<td><p>Move backward by one character</p></td>
<td><p>Ctrl-b</p></td>
<td><p>l</p></td>
</tr>
<tr>
<td><p>Move forward by one word</p></td>
<td><p>Meta-f</p></td>
<td><p>w</p></td>
</tr>
<tr>
<td><p>Move backward by one word</p></td>
<td><p>Meta-b</p></td>
<td><p>b</p></td>
</tr>
<tr>
<td><p>Move to beginning of line</p></td>
<td><p>Ctrl-a</p></td>
<td><p>0</p></td>
</tr>
<tr>
<td><p>Move to end of line</p></td>
<td><p>Ctrl-e</p></td>
<td><p>$</p></td>
</tr>
<tr>
<td><p>Transpose (swap) two characters</p></td>
<td><p>Ctrl-t</p></td>
<td><p>xp</p></td>
</tr>
<tr>
<td><p>Transpose (swap) two words</p></td>
<td><p>Meta-t</p></td>
<td><p><em>n/a</em></p></td>
</tr>
<tr>
<td><p>Capitalize first letter of next word</p></td>
<td><p>Meta-c</p></td>
<td><p>w~</p></td>
</tr>
<tr>
<td><p>Uppercase entire next word</p></td>
<td><p>Meta-u</p></td>
<td><p><em>n/a</em></p></td>
</tr>
<tr>
<td><p>Lowercase entire next word</p></td>
<td><p>Meta-l</p></td>
<td><p><em>n/a</em></p></td>
</tr>
<tr>
<td><p>Change case of the current character</p></td>
<td><p><em>n/a</em></p></td>
<td><p>~</p></td>
</tr>
<tr>
<td><p>Insert the next character verbatim, including control characters</p></td>
<td><p>Ctrl-v</p></td>
<td><p>Ctrl-v</p></td>
</tr>
<tr>
<td><p>Delete forward by one character</p></td>
<td><p>Ctrl-d</p></td>
<td><p>x</p></td>
</tr>
<tr>
<td><p>Delete backward by one character</p></td>
<td><p>Backspace <em>or</em> Ctrl-h</p></td>
<td><p>X</p></td>
</tr>
<tr>
<td><p>Cut forward by one word</p></td>
<td><p>Meta-d</p></td>
<td><p>dw</p></td>
</tr>
<tr>
<td><p>Cut backward by one word</p></td>
<td><p>Meta-Backspace <em>or</em> Ctrl-w</p></td>
<td><p>db</p></td>
</tr>
<tr>
<td><p>Cut from cursor to beginning of line</p></td>
<td><p>Ctrl-u</p></td>
<td><p>d^</p></td>
</tr>
<tr>
<td><p>Cut from cursor to end of line</p></td>
<td><p>Ctrl-k</p></td>
<td><p>D</p></td>
</tr>
<tr>
<td><p>Delete the entire line</p></td>
<td><p>Ctrl-e Ctrl-u</p></td>
<td><p>dd</p></td>
</tr>
<tr>
<td><p>Paste (yank) the most recently deleted text</p></td>
<td><p>Ctrl-y</p></td>
<td><p>p</p></td>
</tr>
<tr>
<td><p>Paste (yank) the next deleted text (after a previous yank)</p></td>
<td><p>Meta-y</p></td>
<td><p><em>n/a</em></p></td>
</tr>
<tr>
<td><p>Undo the previous editing operation</p></td>
<td><p>Ctrl-_</p></td>
<td><p>u</p></td>
</tr>
<tr>
<td><p>Undo all edits made so far</p></td>
<td><p>Meta-r</p></td>
<td><p>U</p></td>
</tr>
<tr>
<td><p>Switch from insertion mode to command mode</p></td>
<td><p><em>n/a</em></p></td>
<td><p>Escape</p></td>
</tr>
<tr>
<td><p>Switch from command mode to insertion mode</p></td>
<td><p><em>n/a</em></p></td>
<td><p>i</p></td>
</tr>
<tr>
<td><p>Abort an edit operation in progress</p></td>
<td><p>Ctrl-g</p></td>
<td><p><em>n/a</em></p></td>
</tr>
<tr>
<td><p>Clear the display</p></td>
<td><p>Ctrl-l</p></td>
<td><p>Ctrl-l</p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="3"><p data-type="footnote" id="idm46586642020000"><sup><a href="ch03.xhtml#idm46586642020000-marker">a</a></sup> Actions marked <em>n/a</em> have no simple keystroke but may be possible with longer sequences of keystrokes.</p></td></tr></tbody></table>

<p>For more details on Emacs-style editing, see <a data-type="indexterm" data-startref="commandlineediting" id="idm46586641952176"/>the section <a href="https://oreil.ly/rAQ9g">“Bindable Readline Commands”</a> in GNU’s <code>bash</code> manual. For Vim-style editing, see the document <a href="https://oreil.ly/Zv0ba">“Readline VI Editing Mode Cheat Sheet”</a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586641949040">
<h1>Summary</h1>

<p>Practice the techniques in this chapter and you’ll speed up your
command-line use immensely. Three of the techniques in particular
transformed the way I use Linux, and I hope they will for you too:</p>

<ul>
<li>
<p>Deleting files with <code>!$</code> for safety</p>
</li>
<li>
<p>Incremental search with Ctrl-R</p>
</li>
<li>
<p>Emacs-style command-line editing</p>
</li>
</ul>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586642237936"><sup><a href="ch03.xhtml#idm46586642237936-marker">1</a></sup> You can omit the trailing question mark here—<code>!?grep</code>—but in some cases it’s required, such as sed-style history expansion (see <a data-type="xref" href="#sidebar_sed_syntax">“More Powerful Substitution with History Expansion”</a>).</p><p data-type="footnote" id="idm46586642165264"><sup><a href="ch03.xhtml#idm46586642165264-marker">2</a></sup> I’m assuming that no matching files were added or removed behind your back after the <code>ls</code> step. Don’t rely on this technique in rapidly changing directories.</p><p data-type="footnote" id="idm46586642107296"><sup><a href="ch03.xhtml#idm46586642107296-marker">3</a></sup> While writing this book, I frequently reran version-control commands such as <code>git add</code>, <code>git commit</code>, and <code>git push</code>. Incremental search made rerunning these commands a breeze.</p></div></div></section></div></body></html>