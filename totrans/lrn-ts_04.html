<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Unions and Literals"><div class="chapter" id="unions_and_literals">
<h1><span class="label">Chapter 3. </span>Unions and Literals</h1>

<blockquote>
<p>Nothing is constant</p>

<p>Values may change over time</p>

<p>(well, except constants)</p></blockquote>

<p><a data-type="xref" data-xrefstyle="chap-num-title" href="ch02.xhtml#the_type_system">Chapter 2, “The Type System”</a> covered the concept of the “type system” and how it can read values to understand the types of variables.
Now I’d like to introduce two key concepts that TypeScript works with to make inferences on top of those values:</p>
<dl>
<dt>Unions</dt>
<dd>
<p>Expanding <a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="described" id="type-union-describe"/><a data-type="indexterm" data-primary="unions" data-secondary="described" id="union-describe"/>a value’s allowed type to be two or more possible types</p>
</dd>
<dt>Narrowing</dt>
<dd>
<p>Reducing<a data-type="indexterm" data-primary="types" data-secondary="narrowing" data-tertiary="described" id="idm45584692766544"/><a data-type="indexterm" data-primary="narrowing" data-secondary="described" id="idm45584692765264"/> a value’s allowed type to <em>not</em> be one or more possible types</p>
</dd>
</dl>

<p>Put together, unions and narrowing are powerful concepts that allow TypeScript to make informed inferences on your code many other mainstream languages cannot.</p>






<section data-type="sect1" data-pdf-bookmark="Union Types"><div class="sect1" id="idm45584692763008">
<h1>Union Types</h1>

<p>Take this <code>mathematician</code> variable:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">mathematician</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="kc">undefined</code>
    <code class="o">:</code> <code class="s2">"Mark Goldberg"</code><code class="p">;</code></pre>

<p>What type is <code>mathematician</code>?</p>

<p>It’s neither only <code>undefined</code> nor only <code>string</code>, even though those are both potential types.
<code>mathematician</code> can be <em>either</em> <code>undefined</code> or <code>string</code>.
This kind of “either or” type is called a <em>union</em>.
Union types are a wonderful concept that let us handle code cases where we don’t know exactly which type a value is, but do know it’s one of two or more options.</p>

<p class="less_space pagebreak-before">TypeScript represents<a data-type="indexterm" data-primary="constituents" id="idm45584692746080"/><a data-type="indexterm" data-primary="pipe (|) operator" id="idm45584692745344"/><a data-type="indexterm" data-primary="| (pipe) operator" id="idm45584692744672"/> union types using the <code>|</code> (pipe) operator between the possible values, or <em>constituents</em>.
The previous <code>mathematician</code> type is thought of as <code>string | undefined</code>.
Hovering over the mathematician variable would show its type <a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="described" data-startref="type-union-describe" id="idm45584692712528"/><a data-type="indexterm" data-primary="unions" data-secondary="described" data-startref="union-describe" id="idm45584692711008"/>as <code>string | undefined</code> (<a data-type="xref" href="#hovering_union_type">Figure 3-1</a>).</p>

<figure><div id="hovering_union_type" class="figure">
<img src="Images/lets_0301.png" alt="TypeScript reporting the 'mathematician' variable as being type 'string | undefined'." width="480" height="123"/>
<h6><span class="label">Figure 3-1. </span>TypeScript reporting the <code>mathematician</code> variable as being type <code>string | undefined</code></h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="Declaring Union Types"><div class="sect2" id="idm45584692705936">
<h2>Declaring Union Types</h2>

<p>Union types <a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="declaring" id="idm45584692704208"/><a data-type="indexterm" data-primary="unions" data-secondary="declaring" id="idm45584692702960"/><a data-type="indexterm" data-primary="declaring" data-secondary="unions" id="idm45584692701984"/>are an example of a situation when it might be useful to give an explicit type annotation for a variable even though it has an initial value.
In this example, <code>thinker</code> starts off <code>null</code> but is known to potentially contain a <code>string</code> instead.
Giving it an explicit <code>string | null</code> type annotation means TypeScript will allow it to be assigned values of type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">thinker</code>: <code class="nx">string</code> <code class="o">|</code> <code class="nx">null</code><code class="o"> = </code><code class="kc">null</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">thinker</code> <code class="o">=</code> <code class="s2">"Susanne Langer"</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="p">}</code></pre>

<p>Union type declarations can be placed anywhere you might declare a type with a type annotation.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The order of a union type declaration does not matter.
You can write <code>boolean | number</code> or <code>number | boolean</code> and TypeScript will treat both the exact same.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Union Properties"><div class="sect2" id="idm45584692673824">
<h2>Union Properties</h2>

<p>When <a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="properties" id="type-union-property"/><a data-type="indexterm" data-primary="unions" data-secondary="properties" id="union-property"/><a data-type="indexterm" data-primary="properties" data-secondary="of unions" data-secondary-sortas="unions" id="property-union"/>a value is known to be a union type, TypeScript will only allow you to access member properties that exist on all possible types in the union.
It will give you a type-checking error if you try to access a type that doesn’t exist on all possible types.</p>

<p class="less_space pagebreak-before">In the following snippet, <code>physicist</code> is of type <code>number | string</code>.
While <code>.toString()</code> exists in both types and is allowed to be used, <code>.toUpperCase()</code> and <code>.toFixed()</code> are not because <code>.toUpperCase()</code> is missing on the <code>number</code> type and <code>.toFixed()</code> is missing on the <code>string</code> type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">physicist</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="s2">"Marie Curie"</code>
    <code class="o">:</code> <code class="mi">84</code><code class="p">;</code>

<code class="nx">physicist</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code> <code class="c1">// Ok</code>

<code class="nx">physicist</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
<code class="c1">//        ~~~~~~~~~~~</code>
<code class="c1">// Error: Property 'toUpperCase' does not exist on type 'string | number'.</code>
<code class="c1">//   Property 'toUpperCase' does not exist on type 'number'.</code>

<code class="nx">physicist</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">();</code>
<code class="c1">//        ~~~~~~~</code>
<code class="c1">// Error: Property 'toFixed' does not exist on type 'string | number'.</code>
<code class="c1">//   Property 'toFixed' does not exist on type 'string'.</code></pre>

<p>Restricting access to properties that don’t exist on all union types is a safety measure.
If an object is not known to definitely be a type that contains a property, TypeScript will believe it unsafe to try to use that property.
The property might not exist!</p>

<p>To use a property of a union typed value that only exists on a subset of the potential types, your code will need to indicate to TypeScript that the value at that location in code is one of those more specific types: a process<a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="properties" data-startref="type-union-property" id="idm45584692609280"/><a data-type="indexterm" data-primary="unions" data-secondary="properties" data-startref="union-property" id="idm45584692607888"/><a data-type="indexterm" data-primary="properties" data-secondary="of unions" data-secondary-sortas="unions" data-startref="property-union" id="idm45584692606672"/> called <em>narrowing</em>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Narrowing"><div class="sect1" id="idm45584692604512">
<h1>Narrowing</h1>

<p>Narrowing is<a data-type="indexterm" data-primary="types" data-secondary="narrowing" data-tertiary="described" id="idm45584692602912"/><a data-type="indexterm" data-primary="narrowing" data-secondary="described" id="idm45584692601632"/> when TypeScript infers from your code that a value is of a more specific type than what it was defined, declared, or previously inferred as.
Once TypeScript knows that a value’s type is more narrow than previously known, it will allow you to treat the value like that more specific type.
A logical check that can be used to narrow types is called <a data-type="indexterm" data-primary="type guards" id="idm45584692600560"/>a <em>type guard</em>.</p>

<p>Let’s cover two of the common type guards TypeScript can use to deduce type narrowing from your code.</p>








<section data-type="sect2" data-pdf-bookmark="Assignment Narrowing"><div class="sect2" id="idm45584692553856">
<h2>Assignment Narrowing</h2>

<p>If <a data-type="indexterm" data-primary="types" data-secondary="narrowing" data-tertiary="with assignment narrowing" data-tertiary-sortas="assignment narrowing" id="type-narrow-assign"/><a data-type="indexterm" data-primary="narrowing" data-secondary="with assignment narrowing" data-secondary-sortas="assignment narrowing" id="narrow-assign"/><a data-type="indexterm" data-primary="assignment narrowing" id="assign-narrow"/>you directly assign a value to a variable, TypeScript will narrow the variable’s type to that value’s type.</p>

<p>Here, the <code>admiral</code> variable is declared initially as a <code>number | string</code>, but after being assigned the value <code>"Grace Hopper"</code>, TypeScript knows it must be a <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">admiral</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code>

<code class="nx">admiral</code> <code class="o">=</code> <code class="s2">"Grace Hopper"</code><code class="p">;</code>

<code class="nx">admiral</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok: string</code>

<code class="nx">admiral</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">();</code>
<code class="c1">//      ~~~~~~~</code>
<code class="c1">// Error: Property 'toFixed' does not exist on type 'string'.</code></pre>

<p>Assignment narrowing comes into play when a variable is given an explicit union type annotation and an initial value too.
TypeScript will understand that while the variable may later receive a value of any of the union typed values, it starts off as only the type of its initial value.</p>

<p>In the following snippet, <code>inventor</code> is declared as type <code>number | string</code>, but TypeScript knows it’s immediately narrowed to a <code>string</code> from its <a data-type="indexterm" data-primary="types" data-secondary="narrowing" data-tertiary="with assignment narrowing" data-tertiary-sortas="assignment narrowing" data-startref="type-narrow-assign" id="idm45584692525760"/><a data-type="indexterm" data-primary="narrowing" data-secondary="with assignment narrowing" data-secondary-sortas="assignment narrowing" data-startref="narrow-assign" id="idm45584692523568"/><a data-type="indexterm" data-primary="assignment narrowing" data-startref="assign-narrow" id="idm45584692522112"/>initial value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">inventor</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">=</code> <code class="s2">"Hedy Lamarr"</code><code class="p">;</code>

<code class="nx">inventor</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok: string</code>

<code class="nx">inventor</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">();</code>
<code class="c1">//       ~~~~~~~</code>
<code class="c1">// Error: Property 'toFixed' does not exist on type 'string'.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Conditional Checks"><div class="sect2" id="idm45584692520192">
<h2>Conditional Checks</h2>

<p>A <a data-type="indexterm" data-primary="types" data-secondary="narrowing" data-tertiary="with conditional checks" data-tertiary-sortas="conditional checks" id="idm45584692475296"/><a data-type="indexterm" data-primary="narrowing" data-secondary="with conditional checks" data-secondary-sortas="conditional checks" id="idm45584692473744"/><a data-type="indexterm" data-primary="conditional checks, narrowing with" id="idm45584692472528"/><a data-type="indexterm" data-primary="if statements, narrowing with" id="idm45584692471888"/>common way to get TypeScript to narrow a variable’s value is to write an <code>if</code> statement checking the variable for being equal to a known value.
TypeScript is smart enough to understand that inside the body of that <code>if</code> statement, the variable must be the same type as the known value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type of scientist: number | string</code>
<code class="kd">let</code> <code class="nx">scientist</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="s2">"Rosalind Franklin"</code>
    <code class="o">:</code> <code class="mi">51</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="nx">scientist</code> <code class="o">===</code> <code class="s2">"Rosalind Franklin"</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Type of scientist: string</code>
    <code class="nx">scientist</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok</code>
<code class="p">}</code>

<code class="c1">// Type of scientist: number | string</code>
<code class="nx">scientist</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
<code class="c1">//        ~~~~~~~~~~~</code>
<code class="c1">// Error: Property 'toUpperCase' does not exist on type 'string | number'.</code>
<code class="c1">//   Property 'toUpperCase' does not exist on type 'number'.</code></pre>

<p class="less_space pagebreak-before">Narrowing with conditional logic shows TypeScript’s type-checking logic mirroring good JavaScript coding patterns.
If a variable might be one of several types, you’ll generally want to check its type for being what you need.
TypeScript is forcing us to play it safe with our code.
Thanks, TypeScript!</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Typeof Checks"><div class="sect2" id="idm45584692418928">
<h2>Typeof Checks</h2>

<p>In <a data-type="indexterm" data-primary="types" data-secondary="narrowing" data-tertiary="with typeof operator" data-tertiary-sortas="typeof operator" id="type-narrow-typeof"/><a data-type="indexterm" data-primary="narrowing" data-secondary="with typeof operator" data-secondary-sortas="typeof operator" id="narrow-typeof"/><a data-type="indexterm" data-primary="typeof operator" data-secondary="narrowing with" id="typeof-narrow"/>addition to direct value checking, TypeScript also recognizes the <code>typeof</code> operator in narrowing down variable types.</p>

<p>Similar to the <code>scientist</code> example, checking if <code>typeof researcher</code> is <code>"string"</code> indicates to TypeScript that the type of <code>researcher</code> must be <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">researcher</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="s2">"Rosalind Franklin"</code>
    <code class="o">:</code> <code class="mi">51</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">researcher</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">researcher</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok: string</code>
<code class="p">}</code></pre>

<p>Logical negations from <code>!</code> and <code>else</code> statements work as well:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">researcher</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">researcher</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">();</code> <code class="c1">// Ok: number</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="nx">researcher</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok: string</code>
<code class="p">}</code></pre>

<p>Those code snippets can be rewritten with a <a data-type="indexterm" data-primary="ternary statement, narrowing with" id="idm45584692286848"/>ternary statement, which is also supported for type narrowing:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">typeof</code> <code class="nx">researcher</code> <code class="o">===</code> <code class="s2">"string"</code>
    <code class="o">?</code> <code class="nx">researcher</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="c1">// Ok: string</code>
    <code class="o">:</code> <code class="nx">researcher</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">();</code> <code class="c1">// Ok: number</code></pre>

<p>Whichever way you write them, <code>typeof</code> checks are a practical and often used way to narrow types.</p>

<p>TypeScript’s type checker recognizes several more forms of narrowing that we’ll see in later chapters.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Literal Types"><div class="sect1" id="idm45584692418336">
<h1>Literal Types</h1>

<p>Now <a data-type="indexterm" data-primary="types" data-secondary="literals" data-tertiary="described" id="type-literal-describe"/><a data-type="indexterm" data-primary="literals" data-secondary="described" id="literal-describe"/><a data-type="indexterm" data-primary="primitives" data-secondary="literals" data-tertiary="described" id="primitive-literal-describe"/>that I’ve shown union types and narrowing for working with values that may be two or more potential types, I’d like go the opposite direction by introducing <em>literal types</em>: more specific versions of primitive types.</p>

<p class="less_space pagebreak-before">Take this <code>philosopher</code> variable:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">philosopher</code> <code class="o">=</code> <code class="s2">"Hypatia"</code><code class="p">;</code></pre>

<p>What type is <code>philosopher</code>?</p>

<p>At first glance, you might say <code>string</code>—and you’d be correct.
<code>philosopher</code> is indeed a <code>string</code>.</p>

<p>But!
<code>philosopher</code> is not just any old <code>string</code>.
It’s specifically the value <code>"Hypatia"</code>.
Therefore, the <code>philosopher</code> variable’s type is technically the more specific <code>"Hypatia"</code>.</p>

<p>Such is the concept of a <em>literal type</em>: the type of a value that is known to be a specific value of a primitive, rather than any of those primitive’s values at all.
The primitive type <code>string</code> represents the set of all possible strings that could ever exist; the literal type <code>"Hypatia"</code> represents just that one string.</p>

<p>If you declare a <a data-type="indexterm" data-primary="const variables" id="idm45584692178304"/><a data-type="indexterm" data-primary="variables" data-secondary="const" id="idm45584692177568"/>variable as <code>const</code> and directly give it a literal value, TypeScript will infer the variable to be that literal value as a type.
This is why, when you hover a mouse over a <code>const</code> variable with an initial literal value in an IDE such as VS Code, it will show you the variable’s type as that literal (<a data-type="xref" href="#hovering_const_string_literal">Figure 3-2</a>) instead of the more general primitive (<a data-type="xref" href="#hovering_let_string_literal">Figure 3-3</a>).</p>

<figure class="width-70"><div id="hovering_const_string_literal" class="figure">
<img src="Images/lets_0302.png" alt="TypeScript reporting a 'const' variable as being its string literal type." width="600" height="85"/>
<h6><span class="label">Figure 3-2. </span>TypeScript reporting a <code>const</code> variable as being specifically its literal type</h6>
</div></figure>

<figure><div id="hovering_let_string_literal" class="figure">
<img src="Images/lets_0303.png" alt="TypeScript reporting a 'let' variable as being type 'string'." width="600" height="105"/>
<h6><span class="label">Figure 3-3. </span>TypeScript reporting a <code>let</code> variable as being generally its primitive type</h6>
</div></figure>

<p>You can think of each <em>primitive</em> type as a <em>union</em> of every possible matching <em>literal</em> value.
In other words, a primitive type is the set of all possible literal values of that type.</p>

<p>Other <a data-type="indexterm" data-primary="boolean primitive" id="idm45584692150576"/><a data-type="indexterm" data-primary="null type" data-secondary="as primitive" data-secondary-sortas="primitive" id="idm45584692149872"/><a data-type="indexterm" data-primary="undefined primitive" id="idm45584692148624"/><a data-type="indexterm" data-primary="number primitive" id="idm45584692147952"/><a data-type="indexterm" data-primary="string primitive" id="idm45584692147280"/>than the <code>boolean</code>, <code>null</code>, and <code>undefined</code> types, all other primitives such as <code>number</code> and <code>string</code> have a infinite number of literal types.
The common types you’ll find in typical TypeScript code are just those:</p>

<ul>
<li>
<p><code>boolean</code>: just <code>true | false</code></p>
</li>
<li>
<p><code>null</code> and <code>undefined</code>: both just have one literal value, themselves</p>
</li>
<li>
<p><code>number</code>: <code>0 | 1 | 2 | ... | 0.1 | 0.2 | ...</code></p>
</li>
<li>
<p><code>string</code>: <code>"" | "a" | "b" | "c" | ... | "aa" | "ab" | "ac" | ...</code></p>
</li>
</ul>

<p>Union type annotations <a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="type annotations" id="idm45584692137136"/><a data-type="indexterm" data-primary="unions" data-secondary="type annotations" id="idm45584692135888"/><a data-type="indexterm" data-primary="type annotations" data-secondary="for unions" data-secondary-sortas="unions" id="idm45584692134912"/>can mix and match between literals and primitives.
A representation of a lifespan, for example, might be represented by any <code>number</code> <em>or</em> one of a couple known edge <a data-type="indexterm" data-primary="types" data-secondary="literals" data-tertiary="described" data-startref="type-literal-describe" id="idm45584692132736"/><a data-type="indexterm" data-primary="literals" data-secondary="described" data-startref="literal-describe" id="idm45584692131216"/><a data-type="indexterm" data-primary="primitives" data-secondary="literals" data-tertiary="described" data-startref="primitive-literal-describe" id="idm45584692130000"/>cases:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">lifespan</code>: <code class="nx">number</code> <code class="o">|</code> <code class="s2">"ongoing"</code> <code class="o">|</code> <code class="s2">"uncertain"</code><code class="p">;</code>

<code class="nx">lifespan</code> <code class="o">=</code> <code class="mi">89</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="nx">lifespan</code> <code class="o">=</code> <code class="s2">"ongoing"</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">lifespan</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
<code class="c1">// Error: Type 'true' is not assignable to</code>
<code class="c1">// type 'number | "ongoing" | "uncertain"'</code></pre>








<section data-type="sect2" data-pdf-bookmark="Literal Assignability"><div class="sect2" id="idm45584692111488">
<h2>Literal Assignability</h2>

<p>You’ve seen how different primitive types such as <code>number</code> and <code>string</code> are not assignable to each other.
Similarly, <a data-type="indexterm" data-primary="types" data-secondary="literals" data-tertiary="assignability" id="idm45584692103264"/><a data-type="indexterm" data-primary="primitives" data-secondary="literals" data-tertiary="assignability" id="idm45584692102016"/><a data-type="indexterm" data-primary="literals" data-secondary="assignability" id="idm45584692100800"/><a data-type="indexterm" data-primary="assignability" data-secondary="of literals" id="idm45584692099856"/>different literal types within the same primitive type—e.g., <code>0</code> and <code>1</code>—are not assignable to each other.</p>

<p>In this example, <code>specificallyAda</code> is declared as being of the literal type <code>"Ada"</code>, so while the value <code>"Ada"</code> may be given to it, the types <code>"Byron"</code> and <code>string</code> are not assignable to it:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">specificallyAda</code><code class="o">:</code> <code class="s2">"Ada"</code><code class="p">;</code>

<code class="nx">specificallyAda</code> <code class="o">=</code> <code class="s2">"Ada"</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">specificallyAda</code> <code class="o">=</code> <code class="s2">"Byron"</code><code class="p">;</code>
<code class="c1">// Error: Type '"Byron"' is not assignable to type '"Ada"'.</code>

<code class="kd">let</code> <code class="nx">someString</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code> <code class="c1">// Type: string</code>

<code class="nx">specificallyAda</code> <code class="o">=</code> <code class="nx">someString</code><code class="p">;</code>
<code class="c1">// Error: Type 'string' is not assignable to type '"Ada"'.</code></pre>

<p>Literal types are, however, allowed to be assigned to their corresponding primitive types.
Any specific literal string is still a <code>string</code>.</p>

<p>In this code example, the value <code>":)"</code>, which is of type <code>":)"</code>, is being assigned to the <code>someString</code> variable previously inferred to be of type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">someString</code> <code class="o">=</code> <code class="s2">":)"</code><code class="p">;</code></pre>

<p>Who would have thought a simple variable assignment would be so theoretically intense?</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Strict Null Checking"><div class="sect1" id="idm45584692223968">
<h1>Strict Null Checking</h1>

<p>The <a data-type="indexterm" data-primary="types" data-secondary="strict null checking" data-tertiary="billion-dollar mistake" id="type-strictnull-billion"/><a data-type="indexterm" data-primary="strict null checking" data-secondary="billion-dollar mistake" id="strictnull-billion"/><a data-type="indexterm" data-primary="billion-dollar mistake" id="billion"/>power of narrowed unions with literals is particularly visible when working with potentially undefined values, an area of type systems TypeScript refers to as <em>strict null checking</em>.
TypeScript is part of a surge of modern programming languages that utilize strict null checking to fix the dreaded “billion-dollar mistake.”</p>








<section data-type="sect2" data-pdf-bookmark="The Billion-Dollar Mistake"><div class="sect2" id="idm45584691990192">
<h2>The Billion-Dollar Mistake</h2>
<blockquote>
<p>I call it my billion-dollar mistake.
It was the invention of the null reference in 1965…
This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the <a data-type="indexterm" data-primary="Hoare, Tony" id="idm45584691988176"/>last 40 years.</p>
<p data-type="attribution">Tony Hoare, <cite>2009</cite></p>
</blockquote>

<p>The “billion-dollar mistake” is a catchy industry term for many type systems allowing null values to be used in places that require a different type.
In languages without strict null checking, code like this example that assign <code>null</code> to a <code>string</code> is allowed:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">firstName</code>: <code class="nx">string</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code></pre>

<p>If you’ve previously worked in a typed language such as C++ or Java that suffers from the billion-dollar mistake, it may be surprising to you that some languages don’t allow such a thing.
If you’ve never worked in a language with the strict null checking before, it may be surprising that some languages allowed the billion-dollar mistake in the first place!</p>

<p>The TypeScript compiler contains a multitude of options that allow changing how it runs.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> will cover TypeScript compiler options in depth.
One of the most useful opt-in options, <code>strictNullChecks</code>, toggles whether strict null checking is enabled.
Roughly speaking, disabling <code>strictNullChecks</code> adds <code>| null | undefined</code> to every type in your code, thereby allowing any variable to receive <code>null</code> or <code>undefined</code>.</p>

<p>With the <code>strictNullChecks</code> option set to <code>false</code>, the following code is considered totally type safe.
That’s wrong, though; <code>nameMaybe</code> might be <code>undefined</code> when 
<span class="keep-together"><code>.toLowerCase</code></span> is accessed from it:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">nameMaybe</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="s2">"Tony Hoare"</code>
    <code class="o">:</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="nx">nameMaybe</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">();</code>
<code class="c1">// Potential runtime error: Cannot read property 'toLowerCase' of undefined.</code></pre>

<p class="less_space pagebreak-before">With strict null checking enabled, TypeScript sees the potential crash in the code snippet:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">nameMaybe</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="s2">"Tony Hoare"</code>
    <code class="o">:</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="nx">nameMaybe</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">();</code>
<code class="c1">// Error: Object is possibly 'undefined'.</code></pre>

<p>Without strict null checking enabled, it’s much harder to know whether your code is safe from errors due to <a data-type="indexterm" data-primary="types" data-secondary="strict null checking" data-tertiary="billion-dollar mistake" data-startref="type-strictnull-billion" id="idm45584691839744"/><a data-type="indexterm" data-primary="strict null checking" data-secondary="billion-dollar mistake" data-startref="strictnull-billion" id="idm45584691838384"/><a data-type="indexterm" data-primary="billion-dollar mistake" data-startref="billion" id="idm45584691864512"/>accidentally <code>null</code> or <code>undefined</code> values.</p>

<p>TypeScript best practice is generally to enable strict null checking.
Doing so helps prevent crashes and eliminates the billion-dollar mistake.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Truthiness Narrowing"><div class="sect2" id="idm45584691989568">
<h2>Truthiness Narrowing</h2>

<p>Recall <a data-type="indexterm" data-primary="types" data-secondary="strict null checking" data-tertiary="with truthiness narrowing" data-tertiary-sortas="truthiness narrowing" id="idm45584691860592"/><a data-type="indexterm" data-primary="strict null checking" data-secondary="with truthiness narrowing" data-secondary-sortas="truthiness narrowing" id="idm45584691858688"/><a data-type="indexterm" data-primary="narrowing" data-secondary="with truthiness narrowing" data-secondary-sortas="truthiness narrowing" id="idm45584691857504"/><a data-type="indexterm" data-primary="truthiness narrowing" id="idm45584691856320"/><a data-type="indexterm" data-primary="falsiness" id="idm45584691855648"/>from JavaScript that <em>truthiness</em>, or being <em>truthy</em>, is whether a value would be considered <code>true</code> when evaluated in a <code>Boolean</code> context, such as an <code>&amp;&amp;</code> operator or <code>if</code> statement.
All values in JavaScript are truthy except for those defined as <em>falsy</em>: <code>false</code>, <code>0</code>, <code>-0</code>, <code>0n</code>, <code>""</code>, <code>null</code>, <code>undefined</code>, and <code>NaN</code>.<sup><a data-type="noteref" id="idm45584691848224-marker" href="ch03.xhtml#idm45584691848224">1</a></sup></p>

<p>TypeScript can also narrow a variable’s type from a truthiness check if only some of its potential values may be truthy.
In the following snippet, <code>geneticist</code> is of type <code>string | undefined</code>, and because <code>undefined</code> is always falsy, TypeScript can deduce that it must be of type <code>string</code> within the <code>if</code> statement’s body:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">geneticist</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="s2">"Barbara McClintock"</code>
    <code class="o">:</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="nx">geneticist</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">geneticist</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok: string</code>
<code class="p">}</code>

<code class="nx">geneticist</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
<code class="c1">// Error: Object is possibly 'undefined'.</code></pre>

<p>Logical operators that perform truthiness checking work as well, namely <code>&amp;&amp;</code> and <code>?.</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">geneticist</code> <code class="o">&amp;&amp;</code> <code class="nx">geneticist</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok: string | undefined</code>
<code class="nx">geneticist</code><code class="o">?</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok: string | undefined</code></pre>

<p>Unfortunately, truthiness checking doesn’t go the other way.
If all we know about a <code>string | undefined</code> value is that it’s falsy, that doesn’t tell us whether it’s an empty string or <code>undefined</code>.</p>

<p>Here, <code>biologist</code> is of type <code>false | string</code>, and while it can be narrowed down to just <code>string</code> in the <code>if</code> statement body, the <code>else</code> statement body knows it can still be a string if it’s <code>""</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">biologist</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code> <code class="o">&amp;&amp;</code> <code class="s2">"Rachel Carson"</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="nx">biologist</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">biologist</code><code class="p">;</code> <code class="c1">// Type: string</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="nx">biologist</code><code class="p">;</code> <code class="c1">// Type: false | string</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Variables Without Initial Values"><div class="sect2" id="idm45584691701616">
<h2>Variables Without Initial Values</h2>

<p>Variables <a data-type="indexterm" data-primary="types" data-secondary="strict null checking" data-tertiary="with no initial values" data-tertiary-sortas="no initial values" id="idm45584691692752"/><a data-type="indexterm" data-primary="strict null checking" data-secondary="with no initial values" data-secondary-sortas="no initial values" id="idm45584691691232"/><a data-type="indexterm" data-primary="variables" data-secondary="lacking initial values" id="idm45584691690016"/><a data-type="indexterm" data-primary="initial values, lacking" id="idm45584691689072"/><a data-type="indexterm" data-primary="undefined primitive" data-secondary="lacking initial values and" id="idm45584691688400"/>declared without an initial value default to <code>undefined</code> in JavaScript.
That presents an edge case in the type system: what if you declare a variable to be a type that doesn’t include <code>undefined</code>, then try to use it before assigning a value?</p>

<p>TypeScript is smart enough to understand that the variable is <code>undefined</code> until a value is assigned.
It will report a specialized error message if you try to use that variable, such as by accessing one of its properties, before assigning a value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">mathematician</code>: <code class="nx">string</code><code class="p">;</code>

<code class="nx">mathematician</code><code class="o">?</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="c1">// Error: Variable 'mathematician' is used before being assigned.</code>

<code class="nx">mathematician</code> <code class="o">=</code> <code class="s2">"Mark Goldberg"</code><code class="p">;</code>
<code class="nx">mathematician</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code></pre>

<p>Note that this reporting doesn’t apply if the variable’s type includes <code>undefined</code>.
Adding <code>| undefined</code> to a variable’s type indicates to TypeScript that it doesn’t need to be defined before use, as <code>undefined</code> is a valid type for its value.</p>

<p>The previous code snippet wouldn’t emit any errors if the type of <code>mathematician</code> is <code>string | undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">mathematician</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="nx">mathematician</code><code class="o">?</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">mathematician</code> <code class="o">=</code> <code class="s2">"Mark Goldberg"</code><code class="p">;</code>
<code class="nx">mathematician</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Aliases"><div class="sect1" id="idm45584691618992">
<h1>Type Aliases</h1>

<p>Most <a data-type="indexterm" data-primary="type aliases" data-secondary="described" id="type-alias-describe"/><a data-type="indexterm" data-primary="unions" data-secondary="type aliases" data-tertiary="described" id="union-typealias-describe"/><a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="type aliases" id="type-union-alias"/>union types you’ll see in code will generally only have two or three constituents.
However, you may sometimes find a use for longer union types that are inconvenient to type out repeatedly.</p>

<p>Each of these variables can be one of four possible types:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">rawDataFirst</code>: <code class="nx">boolean</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">null</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">rawDataSecond</code>: <code class="nx">boolean</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">null</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">rawDataThird</code>: <code class="nx">boolean</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">null</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code></pre>

<p>TypeScript includes <em>type aliases</em> for assigning easier names to reused types.
A type alias starts with the <code>type</code> keyword, a new name, <code>=</code>, and then any type.
By convention, type aliases are given names in PascalCase:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">MyName</code> <code class="o">=</code> <code class="p">...;</code></pre>

<p>Type aliases act as a copy-and-paste in the type system.
When TypeScript sees a type alias, it acts as if you’d typed out the actual type the alias was referring to.
The previous variables’ type annotations could be rewritten to use a type alias for the long union type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">RawData</code> <code class="o">=</code> <code class="kr">boolean</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">null</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>

<code class="kd">let</code> <code class="nx">rawDataFirst</code>: <code class="nx">RawData</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">rawDataSecond</code>: <code class="nx">RawData</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">rawDataThird</code>: <code class="nx">RawData</code><code class="p">;</code></pre>

<p>That’s a lot easier to read!</p>

<p>Type aliases are a handy feature to use in TypeScript whenever your types start getting complex.
For now, that just includes long union types; later on it will include array, function, and object types.</p>








<section data-type="sect2" data-pdf-bookmark="Type Aliases Are Not JavaScript"><div class="sect2" id="idm45584691465392">
<h2>Type Aliases Are Not JavaScript</h2>

<p>Type aliases, <a data-type="indexterm" data-primary="unions" data-secondary="type aliases" data-tertiary="JavaScript and" id="idm45584691428496"/><a data-type="indexterm" data-primary="type aliases" data-secondary="JavaScript and" id="idm45584691427216"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="type aliases and" id="idm45584691426272"/>like type annotations, are not compiled to the output JavaScript.
They exist purely in the TypeScript type system.</p>

<p>The previous code snippet would compile to roughly this JavaScript:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">rawDataFirst</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">rawDataSecond</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">rawDataThird</code><code class="p">;</code></pre>

<p>Because type aliases are purely in the type system, you cannot reference them in runtime code.
TypeScript will let you know with a type error if you are trying to access something that won’t exist at runtime:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">type</code> <code class="nx">SomeType</code> <code class="o">=</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">SomeType</code><code class="p">);</code>
<code class="c1">//          ~~~~~~~~</code>
<code class="c1">// Error: 'SomeType' only refers to a type, but is being used as a value here.</code></pre>

<p>Type aliases exist purely as a development-time construct.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Combining Type Aliases"><div class="sect2" id="idm45584691351760">
<h2>Combining Type Aliases</h2>

<p>Type aliases<a data-type="indexterm" data-primary="unions" data-secondary="type aliases" data-tertiary="combining" id="union-typealias-combine"/><a data-type="indexterm" data-primary="type aliases" data-secondary="combining" id="type-alias-combine"/><a data-type="indexterm" data-primary="combining type aliases" id="combine-typealias"/> may reference other type aliases.
It can sometimes be useful to have type aliases refer to each other, such as when one type alias is a union of types that includes (is a superset of) the union types within another type alias.</p>

<p>This <code>IdMaybe</code> type is a union of the types within <code>Id</code> as well as <code>undefined</code> and <code>null</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Id</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code>

<code class="c1">// Equivalent to: number | string | undefined | null</code>
<code class="kr">type</code> <code class="nx">IdMaybe</code> <code class="o">=</code> <code class="nx">Id</code><code class="o"> | </code><code class="nx">undefined</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code></pre>

<p>Type aliases don’t have to be declared in order of usage.
You can have a type alias declared earlier in a file reference an alias declared later in the file.</p>

<p>The previous code snippet could be rewritten to have <code>IdMaybe</code> come <a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="type aliases" data-startref="type-union-alias" id="idm45584691277232"/>before <code>Id</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">IdMaybe</code> <code class="o">=</code> <code class="nx">Id</code><code class="o"> | </code><code class="nx">undefined</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="kr">type</code> <code class="nx">Id</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584691582752">
<h1>Summary</h1>

<p>In this chapter, you went over union and literal types in TypeScript, along with how its type system can deduce more specific (narrower) types from how our code is structured:</p>

<ul>
<li>
<p>How union types represent values that could be one of two or more types</p>
</li>
<li>
<p>Explicitly indicating union types with type annotations</p>
</li>
<li>
<p>How type narrowing reduces the possible types of a value</p>
</li>
<li>
<p>The difference between <code>const</code> variables with literal types and <code>let</code> variables with primitive types</p>
</li>
<li>
<p>The “billion-dollar mistake” and how TypeScript handles strict null checking</p>
</li>
<li>
<p>Using explicit <code>| undefined</code> to represent values that might not exist</p>
</li>
<li>
<p>Implicit <code>| undefined</code> for unassigned variables</p>
</li>
<li>
<p>Using type aliases to save typing long type unions repeatedly</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/unions-and-literals"><em class="hyperlink">https://learningtypescript.com/unions-and-literals</em></a>.</p>
</div>
<blockquote class="joke">
<p>Why are <code>const</code> variables so serious?</p>

<p>They take themselves too literally.</p></blockquote>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45584691848224"><sup><a href="ch03.xhtml#idm45584691848224-marker">1</a></sup> The deprecated <code>document.all</code> object in browsers is also defined as falsy in an old quirk of legacy browser compatibility. For the purposes of this book—and your own happiness as a developer—don’t worry about <code>document.all</code>.</p></div></div></section></div></body></html>