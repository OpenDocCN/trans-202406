<html><head></head><body><section data-pdf-bookmark="Chapter 7. Batch Job" data-type="chapter" epub:type="chapter"><div class="chapter" id="BatchJob">&#13;
<h1><span class="label">Chapter 7. </span>Batch Job</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="Batch Job" data-type="indexterm" id="bjob07"/> <em>Batch Job</em> pattern is suited for managing isolated atomic units of work. It is based on the Job resource, which runs short-lived Pods<a data-primary="Pods" data-secondary="short-lived" data-type="indexterm" id="idm45902103124048"/> reliably until completion on a distributed environment.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902103122816">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>The<a data-primary="problems" data-secondary="Pods, short-lived" data-type="indexterm" id="idm45902103121520"/><a data-primary="Pods" data-secondary="creating and managing" data-type="indexterm" id="idm45902103120512"/> main primitive in Kubernetes for managing and running containers is the Pod. There are different ways of creating Pods with varying characteristics:</p>&#13;
<dl>&#13;
<dt>Bare Pod</dt>&#13;
<dd>&#13;
<p>It<a data-primary="Pods" data-secondary="bare" data-type="indexterm" id="idm45902103117360"/><a data-primary="bare Pods" data-type="indexterm" id="idm45902103116352"/> is possible to create a Pod manually to run containers. However, when the node such a Pod is running on fails, the Pod is not restarted. Running Pods this way is discouraged except for development or testing purposes. This mechanism is also known as<a data-primary="unmanaged Pod" data-type="indexterm" id="idm45902103115552"/><a data-primary="Pods" data-secondary="unmanaged" data-type="indexterm" id="idm45902103114880"/> <em>unmanaged</em> or<a data-primary="naked Pods" data-type="indexterm" id="idm45902103113392"/><a data-primary="Pods" data-secondary="naked" data-type="indexterm" id="idm45902103112656"/> <em>naked Pods</em>.</p>&#13;
</dd>&#13;
<dt>ReplicaSet</dt>&#13;
<dd>&#13;
<p>This<a data-primary="ReplicaSet" data-secondary="creating and managing Pods" data-type="indexterm" id="idm45902103109952"/> controller is used for creating and managing the lifecycle of Pods expected to run continuously (e.g., to run a web server container). It maintains a stable set of replica Pods running at any given time and guarantees the availability of a specified number of identical Pods. ReplicaSets are described in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch11.html#StatelessService">Chapter 11, “Stateless Service”</a>.</p>&#13;
</dd>&#13;
<dt>DaemonSet</dt>&#13;
<dd>&#13;
<p>This<a data-primary="Daemon Service" data-type="indexterm" id="idm45902103106304"/><a data-primary="Daemon Service" data-secondary="Batch Job" data-type="indexterm" id="idm45902103105568"/> controller runs a single Pod on every node and is used for managing platform capabilities such as monitoring, log aggregation, storage containers, and others. See <a data-type="xref" data-xrefstyle="chap-num-title" href="ch09.html#DaemonService">Chapter 9, “Daemon Service”</a>, for a more detailed discussion.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before">A common aspect of these Pods is that they represent<a data-primary="Pods" data-secondary="long-running" data-type="indexterm" id="idm45902103102352"/> long-running processes that are not meant to stop after a certain time. However, in some cases there is a need to perform a predefined finite unit of work reliably and then shut down the container. For this task, Kubernetes provides the Job resource.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902103100992">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>A<a data-primary="Kubernetes Job" data-type="indexterm" id="idm45902103099024"/> Kubernetes Job is similar to a ReplicaSet as it creates one or more Pods and ensures they run successfully. However, the difference is that, once the expected number of Pods terminate successfully, the Job is considered complete, and no additional Pods are started. A<a data-primary="Jobs" data-secondary="defining" data-type="indexterm" id="idm45902103098160"/> Job definition looks like <a data-type="xref" href="#ex-job">Example 7-1</a>.</p>&#13;
<div data-type="example" id="ex-job">&#13;
<h5><span class="label">Example 7-1. </span>A Job specification</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">batch/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Job</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">completions</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w">                 </code><a class="co" href="#callout_batch_job_CO1-1" id="co_batch_job_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">parallelism</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w">                 </code><a class="co" href="#callout_batch_job_CO1-2" id="co_batch_job_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">ttlSecondsAfterFinished</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">300</code><code class="w">   </code><a class="co" href="#callout_batch_job_CO1-3" id="co_batch_job_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">OnFailure</code><code class="w">   </code><a class="co" href="#callout_batch_job_CO1-4" id="co_batch_job_CO1-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">java</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">RandomRunner</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">/numbers.txt</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">10000</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_batch_job_CO1-1" id="callout_batch_job_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Job should run five Pods to completion, which all must succeed.</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO1-2" id="callout_batch_job_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Two Pods can run in parallel.</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO1-3" id="callout_batch_job_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Keep Pods for five minutes (300 seconds) before garbage-collecting them.</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO1-4" id="callout_batch_job_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Specifying the <code>restartPolicy</code> is mandatory for a Job. The possible values are &#13;
<span class="keep-together"><code>OnFailure</code></span> or <code>Never</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>One crucial difference between the Job and the<a data-primary="Jobs" data-secondary="versus ReplicaSet" data-secondary-sortas="ReplicaSet" data-type="indexterm" id="idm45902104918976"/> ReplicaSet definition is the <code>.spec.template.spec.restartPolicy</code>. The<a data-primary="restartPolicy" data-type="indexterm" id="resart07"/> default value for a ReplicaSet is <code>Always</code>, which makes sense for long-running processes that must always be kept running. The value <code>Always</code> is not allowed for a Job, and the only possible options are <code>OnFailure</code> or <code>Never</code>.</p>&#13;
&#13;
<p>So why bother creating a Job to run a Pod only once instead of using<a data-primary="bare Pods" data-type="indexterm" id="idm45902104914016"/><a data-primary="Pods" data-secondary="bare" data-type="indexterm" id="idm45902104913312"/><a data-primary="Jobs" data-secondary="versus bare Pods" data-secondary-sortas="bare Pods" data-type="indexterm" id="idm45902104912368"/> bare Pods? Using Jobs provides many reliability and scalability benefits that make them the preferred option:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A Job is not an ephemeral in-memory task but a persisted one that survives cluster restarts.</p>&#13;
</li>&#13;
<li>&#13;
<p>When a Job is completed, it is not deleted but is kept for tracking purposes. The Pods that are created as part of the Job are also not deleted but are available for examination (e.g., to check the container logs). This is also true for bare Pods but only for <code>restartPolicy: OnFailure</code>. You can still remove the Pods of a Job after a certain time by specifying <code>.spec.ttlSecondsAfterFinished</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A Job may need to be performed multiple times. Using the <code>.spec.completions</code> field, it is possible to specify how many times a Pod should complete successfully before the Job itself is done.</p>&#13;
</li>&#13;
<li>&#13;
<p>When a Job has to be completed multiple times, it can also be scaled and executed by starting multiple Pods at the same time. That can be done by specifying the &#13;
<span class="keep-together"><code>.spec.parallelism</code></span> field.</p>&#13;
</li>&#13;
<li>&#13;
<p>A Job can be suspended by setting the field <code>.spec.suspend</code> to <code>true</code>. In this case, all active Pods are deleted and restarted if the Job is resumed (i.e., <code>.spec.suspend</code> set to <code>false</code> by the user).</p>&#13;
</li>&#13;
<li>&#13;
<p>If the node fails or when the Pod is evicted for some reason while still running, the<a data-primary="scheduler" data-secondary="Batch Job" data-type="indexterm" id="idm45902104901200"/> scheduler places the Pod on a new healthy node and reruns it. Bare Pods would remain in a failed state as existing Pods are never moved to other nodes.<a data-primary="" data-startref="resart07" data-type="indexterm" id="idm45902104900096"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All of this makes the Job primitive attractive for scenarios requiring some guarantees for the completion of a unit of work.</p>&#13;
&#13;
<p>The<a data-primary="Jobs" data-secondary=".spec.completions and .spec.parallelism" data-secondary-sortas="spec.completions and .spec.parallelism" data-type="indexterm" id="idm45902104898096"/> following two fields play major roles in the behavior of a Job:</p>&#13;
<dl>&#13;
<dt><code>.spec.completions</code></dt>&#13;
<dd>&#13;
<p>Specifies how many Pods should run to complete a Job.</p>&#13;
</dd>&#13;
<dt><code>.spec.parallelism</code></dt>&#13;
<dd>&#13;
<p>Specifies how many Pod replicas could run in parallel. Setting a high number does not guarantee a high level of parallelism, and the actual number of Pods may still be fewer (and in some corner cases, more) than the desired number (e.g., because of throttling, resource quotas, not enough completions left, and other reasons). Setting this field to 0 effectively pauses the Job.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#img-job">Figure 7-1</a> shows how the Job defined in <a data-type="xref" href="#ex-job">Example 7-1</a> with a completion count of 5 and a parallelism of 2 is processed.</p>&#13;
&#13;
<figure class="width-90"><div class="figure" id="img-job">&#13;
<img alt="Parallel Batch Job with a fixed completion count" src="assets/kup2_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Parallel Batch Job with a fixed completion count</h6>&#13;
</div></figure>&#13;
&#13;
<p>Based on these two parameters, there are the following<a data-primary="Jobs" data-secondary="types of" data-type="indexterm" id="idm45902104888192"/> types of Jobs:</p>&#13;
<dl>&#13;
<dt>Single Pod Jobs</dt>&#13;
<dd>&#13;
<p>This type is selected when you leave out both <code>.spec.completions</code> and <code>.spec.parallelism</code> or set them to their default values of 1. Such a Job starts only one Pod and is completed as soon as the single Pod terminates successfully (with exit code 0).</p>&#13;
</dd>&#13;
<dt>Fixed completion count Jobs</dt>&#13;
<dd>&#13;
<p>For a fixed completion count Job, you should set <code>.spec.completions</code> to the number of completions needed. You can set <code>.spec.parallelism</code>, or leave it unset and it will default to 1. Such a Job is considered completed  after the <code>.spec.completions</code> number of Pods has completed successfully. <a data-type="xref" href="#ex-job">Example 7-1</a> shows this mode in action and is the best choice when we know the number of work items in advance and the processing cost of a single work item justifies the use of a dedicated Pod.</p>&#13;
</dd>&#13;
<dt>Work queue Jobs</dt>&#13;
<dd>&#13;
<p>For<a data-primary="Work queue Jobs" data-type="indexterm" id="idm45902104879312"/> a work queue Job, you need to leave <code>.spec.completions</code> unset, and set <code>.spec.parallelism</code> to a number greater than one. A work queue Job is considered completed when at least one Pod has terminated successfully and all other Pods have terminated too. This setup requires the Pods to coordinate among themselves and determine what each one is working on so that they can finish in a coordinated fashion. For example, when a fixed but unknown number of work items is stored in a queue, parallel Pods can pick these up one by one to work on them. The first Pod that detects that the queue is empty and exits with success indicates the completion of the Job. The Job controller waits for all other Pods to terminate too. Since one Pod processes multiple work items, this Job type is an excellent choice for granular work items—when the overhead for one Pod per work item is not justified.</p>&#13;
</dd>&#13;
<dt>Indexed Jobs</dt>&#13;
<dd>&#13;
<p>Similar<a data-primary="Indexed Jobs" data-type="indexterm" id="idm45902104875904"/><a data-primary="Job completions" data-type="indexterm" id="idm45902104875168"/> to <em>Work queue Jobs</em>, you can distribute work items to individual Jobs without needing an external work queue. When using a fixed completion count and setting the completion mode <code>.spec.completionMode</code> to <code>Indexed</code>, every Pod of the Job gets an associated index ranging from 0 to <code>.spec.completions</code> - 1. The assigned index is available to the containers through the Pod annotation <code>batch.kubernetes.io/job-completion-index</code> (see <a data-type="xref" data-xrefstyle="chap-num-title" href="ch14.html#SelfAwareness">Chapter 14, “Self Awareness”</a>, to learn how this annotation can be accessed from your code) or directly via the environment variable <code>JOB_COMPLETION_INDEX</code> that is set to the index associated with this Pod. With this index at hand, the application can pick the associated work item without any external synchronization. <a data-type="xref" href="#ex-job-indexed">Example 7-2</a> shows a Job that processes the lines of a single file individually by separate Pods. A more realistic example would be an indexed Job used for video processing, where parallel Pods are processing a certain frame range calculated from the index.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="example" id="ex-job-indexed">&#13;
<h5><span class="label">Example 7-2. </span>An indexed Job selecting its work items based on a job index</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">batch/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Job</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">file-split</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">completionMode</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Indexed</code><code class="w">     </code><a class="co" href="#callout_batch_job_CO2-1" id="co_batch_job_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">completions</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w">              </code><a class="co" href="#callout_batch_job_CO2-2" id="co_batch_job_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">parallelism</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">file-split</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">split</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w">              </code><a class="co" href="#callout_batch_job_CO2-3" id="co_batch_job_CO2-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">sh</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">-c</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w">&#13;
</code><code class="w">          </code><code class="no">start=$(expr $JOB_COMPLETION_INDEX \* 10000)      </code><a class="co" href="#callout_batch_job_CO2-4" id="co_batch_job_CO2-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="no">end=$(expr $JOB_COMPLETION_INDEX \* 10000 + 10000)</code><code class="w">&#13;
</code><code class="w">          </code><code class="no">awk "NR&gt;=$start &amp;&amp; NR&lt;$end" /logs/random.log \    </code><a class="co" href="#callout_batch_job_CO2-5" id="co_batch_job_CO2-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">              </code><code class="no">&gt; /logs/random-$JOB_COMPLETION_INDEX.txt</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/logs</code><code class="w">    </code><a class="co" href="#callout_batch_job_CO2-6" id="co_batch_job_CO2-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">log-volume</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">OnFailure</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_batch_job_CO2-1" id="callout_batch_job_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Enable an indexed completion mode.</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO2-2" id="callout_batch_job_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Run five Pods in parallel to completion.</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO2-3" id="callout_batch_job_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Execute a shell script that prints out a range of lines from a given file <em>/logs/random.log</em>. This file is expected to have 50,000 lines of data.</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO2-4" id="callout_batch_job_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Calculate start and end line numbers.</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO2-5" id="callout_batch_job_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Use <code>awk</code> to print out a range of line numbers (<code>NR</code> is the <code>awk</code>-internal line number when iterating over the file).</p></dd>&#13;
<dt><a class="co" href="#co_batch_job_CO2-6" id="callout_batch_job_CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Mount the input data from an external volume. The volume is not shown here; you can find the full working definition in the <a href="https://oreil.ly/PkVF0">example repository</a>.</p></dd>&#13;
</dl></div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902100865024">&#13;
<h1>Partitioning the Work</h1>&#13;
<p>As<a data-primary="Jobs" data-secondary="partitioning work" data-type="indexterm" id="idm45902100806144"/> you have seen, we have multiple options for processing many work items by fewer worker Pods. While <em>Work queue Jobs</em> can operate on an unknown but finite set of work items, they need support from an external system that provides the work items. In that case, the external system has already divided the work into appropriately sized work items, so the worker Pods have to process those and stop when there is nothing left to do. The alternative is to use <em>Indexed Jobs</em>, which do not rely on an external work queue but have to split up the work on their own so that each Pod can separately work on a portion of the overall task. Each Pod needs to know its own identity (provided by the environment variable <code>JOB_COMPLETION_INDEX</code>), the total number of workers, and maybe the overall size of the work (like the size of a movie file to process). Unfortunately, the Job’s application code cannot discover the total number of workers (i.e., the value specified in <code>.spec.completions</code>) for an Indexed Job. Therefore, something like a <code>JOB_COMPLETION_TOTAL</code> environment variable would be helpful to partition the work dynamically, but this is not supported as of 2023. However, there are two solutions to overcome this:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Hardcode the knowledge of the total number of Pods working on a Job into the application code. While this might work for simple examples like <a data-type="xref" href="#ex-job-indexed">Example 7-2</a>, it’s generally an imperfect solution as it couples the code in your container to the Kubernetes declaration. That is, if you want to change the number of completions in your Job definition, you would also have to create a new container image for your Job logic with an updated value.</p>&#13;
</li>&#13;
<li>&#13;
<p>To access the value of <code>.spec.completions</code> in your application code, you can copy it to an environment variable or pass it as an argument to the container command in the Job’s template specification. But if you plan to change the number of completions, you will need to update two places in the Job declaration.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There has been some <a href="https://oreil.ly/z7XV7">discussion within the Kubernetes community</a> about whether Kubernetes should provide the value of the <code>.spec.completions</code> field as an environment variable by default. The main concern with this approach is that environment variables cannot be modified at runtime, which could complicate support for resizable Jobs in the future. As a result, a <code>JOB_COMPLETION_TOTAL</code> environment variable is not provided by Kubernetes as of version 1.26.</p>&#13;
</div></aside>&#13;
&#13;
<p>If you have an unlimited stream of work items to process, other controllers like ReplicaSet are the better choice for managing the Pods processing these work items.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902103100400">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>The<a data-primary="Jobs" data-secondary="benefits and drawbacks of" data-type="indexterm" id="idm45902100794704"/> Job abstraction is a pretty basic but also fundamental primitive that other primitives such as<a data-primary="CronJobs" data-secondary="Job abstraction" data-type="indexterm" id="idm45902100793488"/> CronJobs are based on. Jobs help turn isolated work units into a reliable and scalable unit of execution. However, a Job doesn’t dictate how you should map individually processable work items into Jobs or Pods. That is something you have to determine after considering the pros and cons of each option:</p>&#13;
<dl>&#13;
<dt>One Job per work item</dt>&#13;
<dd>&#13;
<p>This option has the overhead of creating Kubernetes Jobs and also means the platform has to manage a large number of Jobs that are consuming resources. This option is useful when each work item is a complex task that has to be recorded, tracked, or scaled independently.</p>&#13;
</dd>&#13;
<dt>One Job for all work items</dt>&#13;
<dd>&#13;
<p>This option is right for a large number of work items that do not have to be independently tracked and managed by the platform. In this scenario, the work items have to be managed from within the application via a batch framework.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The Job primitive provides only the very minimum basics for scheduling work items. Any complex implementation has to combine the Job primitive with a batch application framework (e.g., in the Java ecosystem, we have<a data-primary="Spring Batch" data-type="indexterm" id="idm45902100788992"/> Spring Batch and<a data-primary="JBeret" data-type="indexterm" id="idm45902100788160"/> JBeret as standard implementations) to achieve the desired outcome.</p>&#13;
&#13;
<p>Not all services must run all the time. Some services must run on demand, some at a specific time, and some periodically. Using Jobs can run Pods only when needed and only for the duration of the task execution. Jobs are scheduled on nodes that have the required capacity, satisfy Pod placement policies, and take into account other container dependency considerations. Using Jobs for short-lived tasks rather than using long-running abstractions (such as<a data-primary="ReplicaSet" data-secondary="benefits of" data-type="indexterm" id="idm45902100786944"/> ReplicaSet) saves resources for other workloads on the platform. All of that makes Jobs a unique primitive, and Kubernetes a platform supporting diverse workloads.<a data-primary="" data-startref="bjob07" data-type="indexterm" id="idm45902100785840"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902100784640">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/PkVF0">Batch Job Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/I2Xum">Jobs</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/mNmhN">Parallel Processing Using Expansions</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/W5aqH">Coarse Parallel Processing Using a Work Queue</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/-8FBt">Fine Parallel Processing Using a Work Queue</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2B2Nn">Indexed Job for Parallel Processing with Static Work Assignment</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/8dLDo">Spring Batch on Kubernetes: Efficient Batch Processing at Scale</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/YyYxy">JBeret Introduction</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>