<html><head></head><body><section data-pdf-bookmark="Chapter 7. eBPF Program and Attachment Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="ebpf_program_and_attachment_types">&#13;
<h1><span class="label">Chapter 7. </span>eBPF Program and Attachment Types</h1>&#13;
<p><a contenteditable="false" data-primary="attachment types" data-secondary="eBPF programs and" data-type="indexterm" id="ch07.html0"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="attachment types" data-type="indexterm" id="ch07.html1"/>In the preceding chapters you saw lots of examples of eBPF programs, and you probably spotted the fact that they are attached to different types of events. Some of the examples I’ve shown attach to kprobes, but in other examples I’ve demonstrated XDP programs that handle a newly arrived network packet. These are just two of the many attachment points within the kernel. In this chapter we’ll take a deeper look at different program types and how they can be attached to different events.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You can build and run the examples from this chapter using the code and instructions at <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a>. The code for this chapter is in the <em>chapter7</em> directory.</p>&#13;
<p>At the time of this writing, some of the examples are not supported on ARM processors. Check out the <em>README</em> file in the <em>chapter7</em> directory for more details and advice.</p>&#13;
</div>&#13;
<p>There are currently around 30 program types enumerated in <a href="https://oreil.ly/6dNIW"><em>uapi/linux/bpf.h</em></a>, and more than 40 attachment types. The attachment type defines more specifically where the program gets attached; for lots of program types, the attachment type can be inferred from the program type, but some program types can be attached to multiple different points in the kernel, so an attachment type has to be specified as well.</p>&#13;
<p>As you know, this book isn’t intended to be a reference manual, so I won’t cover every single eBPF program type. There’s a good chance that new types will have been added by the time you read this book anyway!</p>&#13;
<section data-pdf-bookmark="Program Context Arguments" data-type="sect1"><div class="sect1" id="program_context_arguments">&#13;
<h1>Program Context Arguments</h1>&#13;
<p><a contenteditable="false" data-primary="context arguments" data-type="indexterm" id="idm46123195469968"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="context arguments" data-type="indexterm" id="idm46123195468864"/>All eBPF programs take a context argument that is a pointer, but the structure it points to depends on the type of event that triggered it. eBPF programmers need to write programs that accept the appropriate type of context; there is no point in pretending that the context argument points to a network packet if the event is, say, a tracepoint. Defining different types of programs allows the verifier to ensure that the contextual information is handled appropriately and to enforce rules about what helper functions are permissible.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To dive into the details of the context data passed to different BPF program types, check out <a href="https://oreil.ly/6dNIW">this post by Alan Maguire on Oracle’s blog</a>.</p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Helper Functions and Return Codes" data-type="sect1"><div class="sect1" id="helper_functions_and_return_codes">&#13;
<h1>Helper Functions and Return Codes</h1>&#13;
<p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="helper functions" data-type="indexterm" id="idm46123195463424"/><a contenteditable="false" data-primary="helper functions" data-type="indexterm" id="idm46123195462048"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="helper functions and return codes" data-type="indexterm" id="idm46123195433392"/>As you saw in the previous chapter, the verifier checks that all helper functions used by a program are compatible with its program type. The example in the previous chapter demonstrated that the <code>bpf_get_current_pid_tgid()</code> helper function isn’t permitted in an XDP program. There is no user space process or thread involved at the point where a packet is received and the XDP hook is triggered, so a call to discover the current process and thread ID doesn’t make sense in that context.</p>&#13;
<p><a contenteditable="false" data-primary="return code" data-secondary="program types and" data-type="indexterm" id="idm46123195431408"/>The program type also determines the meaning of the return code from the program. <a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="return codes" data-type="indexterm" id="idm46123195430064"/>Again using XDP as an example, the return code value tells the kernel what to do with the packet once the eBPF program has finished processing it—which could involve passing it to the network stack, dropping it, or redirecting it to a different interface. These return codes wouldn’t make any sense when an eBPF program is triggered by, say, hitting a particular tracepoint, where there is no network packet involved.</p>&#13;
<p>There is a <a href="https://oreil.ly/e8K73">manpage for helper functions</a> (with, quite reasonably, disclaimers that it might not be complete due to the ongoing development of the BPF subsystem).</p>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="and helper functions" data-secondary-sortas="helper functions" data-type="indexterm" id="idm46123195427216"/>You can get a list of which helper functions are available for each program type in your version of the kernel with the <code>bpftool feature</code> command. This shows the system configuration and lists all the available program types and map types, and even lists all the helper functions that are supported for each program type.</p>&#13;
<p>Helper functions are considered part of the <em>UAPI</em>, the Linux kernel’s external, stable interface. As such, once a helper function has been defined in the kernel, it shouldn’t change in the future, even though the kernel’s internal functions and data structures can change.</p>&#13;
<p>Despite the risk of changes between kernel versions, there was demand from eBPF programmers to be able to access some internal functions from eBPF programs. This can be achieved using the mechanism called <em>BPF kernel functions</em>, or <a href="https://oreil.ly/gKSEx"><em>kfuncs</em></a><em>.</em></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Kfuncs" data-type="sect1"><div class="sect1" id="kfuncs">&#13;
<h1>Kfuncs</h1>&#13;
<p><a contenteditable="false" data-primary="kfuncs" data-type="indexterm" id="idm46123195420576"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="kfuncs and" data-type="indexterm" id="idm46123195419472"/>Kfuncs allow internal kernel functions to be registered with the BPF subsystem so that the verifier will allow them to be called from eBPF programs. There is a registration for each eBPF program type that is permitted to call a given kfunc.</p>&#13;
<p>Unlike helper functions, kfuncs don’t provide compatibility guarantees, so an eBPF programmer has to consider the possibility of changes between kernel versions.</p>&#13;
<p>There is a set of <a href="https://oreil.ly/06qoi">“core” BPF kfuncs</a>, which at the time of this writing consists of functions that allow eBPF programs to obtain and release kernel references to tasks and cgroups.</p>&#13;
<p>To recap, the type of an eBPF program determines what events it can be attached to, which in turn defines the type of context information it receives. The program type also defines the set of helper functions and kfuncs it can call.</p>&#13;
<p>Program types are broadly considered to fall into two categories: tracing (or perf) program types and networking-related program types. Let’s look at some examples.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Tracing" data-type="sect1"><div class="sect1" id="tracing">&#13;
<h1>Tracing</h1>&#13;
<p><a contenteditable="false" data-primary="programs, eBPF" data-secondary="tracing" data-type="indexterm" id="ch07.html2"/>Programs that attach to kprobes, tracepoints, raw tracepoints, fentry/fexit probes, and perf events were all designed to provide an efficient way for eBPF programs in the kernel to report tracing information about events into user space. These tracing-related types weren’t expected to influence the way the kernel behaves in response to the events they are attached to (although, as you’ll see in <a data-type="xref" href="ch09.html#ebpf_for_security">Chapter 9</a>, there have been some innovations in this area!).</p>&#13;
<p><a contenteditable="false" data-primary="perf-related programs" data-type="indexterm" id="idm46123195410496"/><a contenteditable="false" data-primary="tracing" data-secondary="eBPF programs, perf-related" data-type="indexterm" id="ch07.html3"/>These are sometimes referred to as “perf-related” programs. <a contenteditable="false" data-primary="bpftool" data-secondary="perf subcommand" data-type="indexterm" id="idm46123195407600"/>For example, the <code>bpftool perf</code> subcommand lets you view programs attached to perf-related events like this:</p>&#13;
<pre data-type="programlisting">$ sudo bpftool perf show&#13;
pid 232272  fd 16: prog_id 392  kprobe  func __x64_sys_execve  offset 0&#13;
pid 232272  fd 17: prog_id 394  kprobe  func do_execve  offset 0&#13;
pid 232272  fd 19: prog_id 396  tracepoint  sys_enter_execve&#13;
pid 232272  fd 20: prog_id 397  raw_tracepoint  sched_process_exec&#13;
pid 232272  fd 21: prog_id 398  raw_tracepoint  sched_process_exec</pre>&#13;
<p>The preceding output is what I see when running example code from the <em>hello.bpf.c</em> file in the <em>chapter7</em> directory, which attaches different programs to a variety of events that are all related to <code>execve()</code>. I’ll discuss all of these types in this section, but as an overview, these programs are:</p>&#13;
<ul>&#13;
<li><p>A kprobe attached to the entry point to the <code>execve()</code> system call.</p></li>&#13;
<li><p>A kprobe attached to a kernel function, <code>do_execve()</code>.</p></li>&#13;
<li><p>A tracepoint placed at the entry to the <code>execve()</code> syscall.</p></li>&#13;
<li><p>Two versions of a raw tracepoint called during the processing of <code>execve()</code>. One of these, as you’ll see in this section, is a BTF-enabled version.</p></li>&#13;
</ul>&#13;
<p>You’ll need <code>CAP_PERFMON</code> and <code>CAP_BPF</code> or <code>CAP_SYS_ADMIN</code> capabilities to use any of the tracing-related eBPF program types.</p>&#13;
<section data-pdf-bookmark="Kprobes and Kretprobes" data-type="sect2"><div class="sect2" id="kprobes_and_kretprobes">&#13;
<h2>Kprobes and Kretprobes</h2>&#13;
<p><a contenteditable="false" data-primary="kprobes" data-type="indexterm" id="ch07.html4"/><a contenteditable="false" data-primary="tracing" data-secondary="kprobes and kretprobes" data-type="indexterm" id="ch07.html5"/>I discussed the concept of kprobes in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>. You can attach kprobe programs almost anywhere in the kernel.<sup><a data-type="noteref" href="ch07.html#ch07fn1" id="ch07fn1-marker">1</a></sup> Commonly, they are attached using kprobes to the entry to a function and kretprobes to the exit of a function, but you can use kprobes to attach to an instruction that is some specified offset after the entry to the function. If you choose to do this,<sup><a data-type="noteref" href="ch07.html#ch07fn2" id="ch07fn2-marker">2</a></sup> you’d need to be confident that the kernel version you’re running on has the instruction you want to attach to where you think it is! Attaching to kernel function entry and exit points can be relatively stable, but arbitrary lines of code might easily be modified from one release to the next.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the example output from <code>bpftool perf list</code>, you can see that there is an offset of 0 for both of the kprobes.</p>&#13;
</div>&#13;
<p>When the kernel is compiled, there’s also the possibility that the compiler chooses to “inline” any given kernel function; that is, rather than jump from where the function is called, the compiler might emit the machine code to implement whatever the function does within the calling functions. If a function happens to get inlined, there won’t be a kprobe entry point for your eBPF program to attach to.</p>&#13;
<section data-pdf-bookmark="Attaching kprobes to syscall entry points" data-type="sect3"><div class="sect3" id="attaching_kprobes_to_syscall_entry_poin">&#13;
<h3>Attaching kprobes to syscall entry points</h3>&#13;
<p><a contenteditable="false" data-primary="kprobes" data-secondary="attaching to syscall entry points" data-type="indexterm" id="idm46123195383520"/><a contenteditable="false" data-primary="system calls" data-secondary="attaching kprobes to entry points" data-type="indexterm" id="idm46123195382128"/>The first example eBPF program for this chapter is called <code>kprobe_sys_execve</code>, and it is a kprobe attached to the <code>execve()</code> syscall. The function and its section definition look like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"ksyscall/execve"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">BPF_KPROBE_SYSCALL</code><code class="p">(</code><code class="n">kprobe_sys_execve</code><code class="p">,</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="o">*</code><code class="n">pathname</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>This is the same as what you saw in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>.</p>&#13;
<p>One reason to attach to syscalls is that they are stable interfaces that won’t change between kernel versions (the same is true of tracepoints, which we’ll come to shortly). However, syscall kprobes shouldn’t be relied on for security tooling, for reasons I’ll cover in detail in <a data-type="xref" href="ch09.html#ebpf_for_security">Chapter 9</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Attaching kprobes to other kernel functions" data-type="sect3"><div class="sect3" id="attaching_kprobes_to_other_kernel_funct">&#13;
<h3>Attaching kprobes to other kernel functions</h3>&#13;
<p><a contenteditable="false" data-primary="kprobes" data-secondary="attaching to various kernel functions" data-type="indexterm" id="idm46123195352064"/>You can find lots of examples where eBPF-based tools use kprobes to attach to system calls, but, as mentioned earlier, kprobes can also be attached to any noninlined function in the kernel. I’ve provided an example in <em>hello.bpf.c</em> that attaches a kprobe to the function <code>do_execve()</code>, and it’s defined like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"kprobe/do_execve"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">BPF_KPROBE</code><code class="p">(</code><code class="n">kprobe_do_execve</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">filename</code><code class="w"> </code><code class="o">*</code><code class="n">filename</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>Because <code>do_execve()</code> isn’t a system call, there are a few differences between this and the previous example:</p>&#13;
<ul>&#13;
<li><p>The format of the SEC name is identical to the previous version attached to the syscall entry point, but there is no need to define platform-specific variants because <code>do_execve()</code>, like most kernel functions, is common to all platforms.</p></li>&#13;
<li><p>I used the <code>BPF_KPROBE</code> macro rather than <code>BPF_KPROBE_SYSCALL</code>. The intent is exactly the same, just that the latter handles syscall parameters.</p></li>&#13;
<li><p>There is another important difference: the <code>pathname</code> parameter to the syscall is a pointer to a string <code>(char *)</code>, but for this function the parameter is called <code>filename</code>, and it’s a pointer to a <code>struct filename</code>, which is a data structure used within the kernel.</p></li>&#13;
</ul>&#13;
<p>You might well be wondering how I knew to use this type for this parameter. I’ll show you. The <code>do_execve()</code> function in the kernel has the following signature:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v4.4/C/ident/do_execve"><code class="n">do_execve</code></a><code class="p">(</code><code class="k">struct</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v4.4/C/ident/filename"><code class="nc">filename</code></a><code class="w"> </code><code class="o">*</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v4.4/C/ident/filename"><code class="n">filename</code></a><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v4.4/C/ident/__user"><code class="n">__user</code></a><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v4.4/C/ident/__user"><code class="n">__user</code></a><code class="w"> </code><code class="o">*</code><code class="n">__argv</code><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v4.4/C/ident/__user"><code class="n">__user</code></a><code class="w"> </code><code class="o">*</code><code class="k">const</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v4.4/C/ident/__user"><code class="n">__user</code></a><code class="w"> </code><code class="o">*</code><code class="n">__envp</code><code class="p">)</code></pre>&#13;
<p>I chose to ignore the <code>do_execve()</code> parameters <code>__argv</code> and <code>__envp</code>, and only declare the <code>filename</code> argument, using the type <code>struct filename *</code> to match the kernel <span class="keep-together">function’s</span> definition. Given the way arguments are laid out sequentially in memory, it’s OK to ignore the last <em>n</em> parameters, but you can’t ignore an earlier argument in the list if you want to use a later one.</p>&#13;
<p>This <code>filename</code> structure is defined internal to the kernel, and it’s an illustration of how eBPF programming is kernel programming: I had to look up the definition of <code>do_execve()</code> to find its arguments, and the definition of <code>struct filename</code>. The name of the executable that is about to be run is pointed to by <code>filename-&gt;name</code>. I’m retrieving this name in the example code with the following lines:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="o">*</code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BPF_CORE_READ</code><code class="p">(</code><code class="n">filename</code><code class="p">,</code><code class="w"> </code><code class="n">name</code><code class="p">);</code><code class="w"/>&#13;
<code class="n">bpf_probe_read_kernel</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">),</code><code class="w"> </code><code class="n">name</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>So to recap: the context parameter to a syscall kprobe is a structure representing the values passed by user space into the syscall. The context parameter to a “regular” (nonsyscall) kprobe is a structure representing the parameters passed to the called function by whatever kernel code is calling it, so the structure depends on the function definition.</p>&#13;
<p>Kretprobes are very similar to kprobes, except that they are triggered when a function returns and can access the return value instead of the arguments.</p>&#13;
<p>Kprobes and kretprobes are a reasonable way to hook into kernel functions, but there’s a newer option you should consider if you’re running on recent kernels.<a contenteditable="false" data-primary="" data-startref="ch07.html5" data-type="indexterm" id="idm46123195130864"/><a contenteditable="false" data-primary="" data-startref="ch07.html4" data-type="indexterm" id="idm46123195129552"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Fentry/Fexit" data-type="sect2"><div class="sect2" id="fentrysolidusfexit">&#13;
<h2>Fentry/Fexit</h2>&#13;
<p><a contenteditable="false" data-primary="BPF trampoline" data-type="indexterm" id="idm46123195126176"/><a contenteditable="false" data-primary="fentry programs" data-type="indexterm" id="idm46123195125072"/><a contenteditable="false" data-primary="fexit programs" data-type="indexterm" id="idm46123195123968"/><a contenteditable="false" data-primary="tracing" data-secondary="fentry/fexit" data-type="indexterm" id="idm46123195122864"/>A more efficient mechanism for tracing the entry to and exit from kernel functions was introduced along with the idea of <em>BPF trampoline</em> in kernel version 5.5 (on x86 processors; BPF trampoline support doesn’t arrive for <a href="https://oreil.ly/ccuz1">ARM processors until Linux 6.0</a>). If you’re using a recent enough kernel, fentry/fexit is now the preferred method for tracing the entry to or exit from a kernel function. You can write the same code inside a kprobe or fentry type program.</p>&#13;
<p>There’s an example fentry program called <code>fentry_execve()</code> in <em>chapter7/hello.bpf.c</em>. I declared the eBPF program for this kprobe using <em>libbpf</em>’s macro <code>BPF_PROG</code>, which is another convenient wrapper giving access to typed parameters rather than the generic context pointer, but this version is used for fentry, fexit, and tracepoint program types. The definition looks like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"fentry/do_execve"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">BPF_PROG</code><code class="p">(</code><code class="n">fentry_execve</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">filename</code><code class="w"> </code><code class="o">*</code><code class="n">filename</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>The section name tells <em>libbpf</em> to attach to the fentry hook at the start of the <code>d⁠o⁠_​e⁠x⁠e⁠c⁠v⁠e⁠(⁠)</code> kernel function. Just as in the kprobe example, the context parameters reflect the parameters passed to the kernel function where you want to attach this eBPF <span class="keep-together">program</span>.</p>&#13;
<p>Fentry and fexit attachment points were designed to be more efficient than kprobes, but there’s another advantage when you want to generate an event at the end of a function: the fexit hook has access to the input parameters to the function, which kretprobe does not. You can see an example of this in <a href="https://oreil.ly/6HDh_"><em>libbpf-bootstrap</em>’s examples</a>. Both <em>kprobe.bpf.c</em> and <em>fentry.bpf.c</em> are equivalent examples that hook into the <code>do_unlinkat()</code> kernel function. The eBPF program attached to the kretprobe has the following signature:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"kretprobe/do_unlinkat"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">BPF_KRETPROBE</code><code class="p">(</code><code class="n">do_unlinkat_exit</code><code class="p">,</code><code class="w"> </code><code class="kt">long</code><code class="w"> </code><code class="n">ret</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>The <code>BPF_KRETPROBE</code> macro expands to make this a kretprobe program on exit from <code>do_unlinkat()</code>. The only parameter the eBPF program receives is <code>ret</code>, which holds the return value from <code>do_unlinkat()</code>. Compare this to the fexit version:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"fexit/do_unlinkat"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">BPF_PROG</code><code class="p">(</code><code class="n">do_unlinkat_exit</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">dfd</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">filename</code><code class="w"> </code><code class="o">*</code><code class="n">name</code><code class="p">,</code><code class="w"> </code><code class="kt">long</code><code class="w"> </code><code class="n">ret</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>In this version the program gets access not just to the return value <code>ret</code>, but also to the input parameters to <code>do_unlinkat()</code>, which are <code>dfd</code> and <code>name</code>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Tracepoints" data-type="sect2"><div class="sect2" id="tracepoints">&#13;
<h2>Tracepoints</h2>&#13;
<p><a contenteditable="false" data-primary="tracepoints" data-type="indexterm" id="ch07.html6"/><a contenteditable="false" data-primary="tracing" data-secondary="tracepoints" data-type="indexterm" id="ch07.html7"/><a href="https://oreil.ly/yXk_L">Tracepoints</a> are marked locations in the kernel code (we’ll come to user space tracepoints later in this chapter). They’re not by any means exclusive to eBPF and have long been used to generate kernel trace output and by tools like <a href="https://oreil.ly/bLmQL">SystemTap</a>. Unlike attaching to arbitrary instructions using kprobes, tracepoints are stable between kernel releases (although an older kernel might not have the full set of tracepoints that have been added into a newer one).</p>&#13;
<p>You can see the available set of tracing subsystems on your kernel by looking at <em>/sys/kernel/tracing/available_events</em>, as follows:</p>&#13;
<pre data-type="programlisting">$ cat /sys/kernel/tracing/available_events &#13;
tls:tls_device_offload_set&#13;
tls:tls_device_decrypted&#13;
...&#13;
syscalls:sys_exit_execveat&#13;
syscalls:sys_enter_execveat&#13;
syscalls:sys_exit_execve&#13;
syscalls:sys_enter_execve&#13;
...</pre>&#13;
<p>My 5.15 version of the kernel has more than 1,400 tracepoints defined in this list. The section definition for a tracepoint eBPF program should match one of these items so that <em>libbpf</em> can automatically attach it to the tracepoint. The definition is in the form <code>SEC("tp/tracing subsystem/tracepoint name")</code>.</p>&#13;
<p>You’ll find an example in the <em>chapter7/hello.bpf.c</em>files that matches the <code>syscalls:sys_enter_execve</code> tracepoint that gets hit when the kernel starts processing an <code>execve()</code> call. The section definition tells <em>libbpf</em> that this is a tracepoint program, and where it should be attached, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"tp/syscalls/sys_enter_execve"</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>What about the context parameter to a tracepoint? As I’ll come to shortly, BTF can help us here, but first let’s consider what is needed when BTF isn’t available. Each tracepoint has a format describing the fields that get traced out from it. As an example, here’s the format for the tracepoint at the entry to the <code>execve()</code> syscall:</p>&#13;
<pre data-type="programlisting">$ cat /sys/kernel/tracing/events/syscalls/sys_enter_execve/format&#13;
name: sys_enter_execve&#13;
ID: 622&#13;
format:&#13;
  field:unsigned short common_type;         offset:0;  size:2; signed:0;&#13;
  field:unsigned char common_flags;         offset:2;  size:1; signed:0;&#13;
  field:unsigned char common_preempt_count; offset:3;  size:1; signed:0;&#13;
  field:int common_pid;                     offset:4;  size:4; signed:1;&#13;
&#13;
  field:int __syscall_nr;                   offset:8;  size:4; signed:1;&#13;
  field:const char * filename;              offset:16; size:8; signed:0;&#13;
  field:const char *const * argv;           offset:24; size:8; signed:0;&#13;
  field:const char *const * envp;           offset:32; size:8; signed:0;&#13;
&#13;
print fmt: "filename: 0x%08lx, argv: 0x%08lx, envp: 0x%08lx", &#13;
((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;argv)), &#13;
((unsigned long)(REC-&gt;envp))</pre>&#13;
<p>I used this information to define a matching structure called <code>m⁠y⁠_⁠s⁠y⁠s⁠c⁠a⁠l⁠l⁠s⁠_⁠e⁠n⁠t⁠e⁠r⁠_​e⁠x⁠e⁠c⁠v⁠e</code> in <em>chapter7/hello.bpf.c</em>:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">my_syscalls_enter_execve</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">unsigned</code><code class="w"> </code><code class="kt">short</code><code class="w"> </code><code class="n">common_type</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">unsigned</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">common_flags</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">unsigned</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">common_preempt_count</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">common_pid</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">   </code><code class="kt">long</code><code class="w"> </code><code class="n">syscall_nr</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">long</code><code class="w"> </code><code class="n">filename_ptr</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">long</code><code class="w"> </code><code class="n">argv_ptr</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">long</code><code class="w"> </code><code class="n">envp_ptr</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
<p>eBPF programs aren’t allowed to access the first four of these fields. If you try to access them, the program will fail verification with an <code>invalid bpf_context access</code> error.</p>&#13;
<p>My example eBPF program that attaches to this tracepoint can use a pointer to this type as its context parameter, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">tp_sys_enter_execve</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">my_syscalls_enter_execve</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/></pre>&#13;
<p>Then you can access the contents of this structure. For example, you can get the filename pointer as follows:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">bpf_probe_read_user_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">),</code><code class="w"> </code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">filename_ptr</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>When you use a tracepoint program type, the structure passed to the eBPF program has already been mapped from a set of raw arguments. For better performance, you can directly access these raw arguments with a raw tracepoint eBPF program type. The section definition should start with <code>raw_tp</code> (or <code>raw_tracepoint</code>) instead of <code>tp</code>. You’ll need to convert the arguments from <code>__u64</code> to whatever type the tracepoint structure uses (when the tracepoint is the entry to a system call, these arguments are dependent on the chip architecture).</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BTF-Enabled Tracepoints" data-type="sect2"><div class="sect2" id="btf_enabled_tracepoints">&#13;
<h2>BTF-Enabled Tracepoints</h2>&#13;
<p><a contenteditable="false" data-primary="BTF-enabled tracepoints" data-type="indexterm" id="idm46123194773168"/>In the previous example I wrote a structure called <code>my_syscalls_enter_execve</code> to define the context parameter for my eBPF program. But when you define a structure in your eBPF code or parse the raw arguments, there’s a risk that your code might not match the kernel it’s running on. The good news is that BTF, which you met in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, also solves this problem.</p>&#13;
<p>With BTF support, there will be a structure defined in <em>vmlinux.h</em> that matches the context structure passed to a tracepoint eBPF program. Your eBPF program should use the section definition <code>SEC("tp_btf/<em>tracepoint name</em>")</code> where the tracepoint name is one of the available events listed in <em>/sys/kernel/tracing/available_events</em>. The example program in <em>chapter7/hello.bpf.c</em> looks like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"tp_btf/sched_process_exec"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">handle_exec</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">trace_event_raw_sched_process_exec</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>As you can see, the structure name matches the tracepoint name, prefixed with <code>trace_event_raw_</code>.<a contenteditable="false" data-primary="" data-startref="ch07.html7" data-type="indexterm" id="idm46123194763280"/><a contenteditable="false" data-primary="" data-startref="ch07.html6" data-type="indexterm" id="idm46123194762000"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="User Space Attachments" data-type="sect2"><div class="sect2" id="user_space_attachments">&#13;
<h2>User Space Attachments</h2>&#13;
<p><a contenteditable="false" data-primary="attachment" data-secondary="user space" data-type="indexterm" id="ch07.html9"/><a contenteditable="false" data-primary="tracing" data-secondary="user space attachments" data-type="indexterm" id="ch07.html10"/><a contenteditable="false" data-primary="user space" data-secondary="events" data-type="indexterm" id="ch07.html11"/>So far I have shown examples of eBPF programs attaching to events defined within the kernel’s source code. <a contenteditable="false" data-primary="user statically defined tracepoints (USDTs)" data-type="indexterm" id="idm46123194717168"/>There are similar attachment points within user space code: uprobes and uretprobes for attaching to the entry and exit of user space functions, and user statically defined tracepoints (USDTs) for attaching to specified tracepoints within application code or user space libraries. These all use the <code>BPF_PROG_TYPE_KPROBE</code> program type.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There are lots of public examples of programs attached to user space events. Here are a few from the BCC project:</p>&#13;
<ul>&#13;
<li><p>The <a href="https://oreil.ly/gDkaQ">bashreadline</a> and <a href="https://oreil.ly/zLT54">funclatency tools</a> attach to u(ret)probe.</p></li>&#13;
<li><p><a href="https://oreil.ly/o894f">USDT sample</a> in BCC.</p></li>&#13;
</ul>&#13;
</div>&#13;
<p>If you’re using <em>libbpf</em>, the <code>SEC()</code> macro lets you define the auto-attachment point for these user space probes. You’ll find the format required for the section name in the <a href="https://oreil.ly/o0CBQ"><em>libbpf</em> documentation</a>. For example, to attach a uprobe to the start of the <code>SSL_write()</code> function in OpenSSL, you would define the section for the eBPF program with the following:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"uprobe/usr/lib/aarch64-linux-gnu/libssl.so.3/SSL_write"</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>There are a few gotchas to be aware of when instrumenting user space code:</p>&#13;
<ul>&#13;
<li><p>Notice that the path to this shared library in this example is architecture specific, so you may need corresponding architecture-specific definitions.</p></li>&#13;
<li><p>Unless you control the machine you’re running the code on, you can’t know what user space libraries and applications will be installed.</p></li>&#13;
<li><p>An application might be built as a standalone binary, so it won’t hit any probes you might attach within shared libraries.</p></li>&#13;
<li><p>Containers typically run with their own copy of a filesystem, with their own set of dependencies installed in it. The path to a shared library used by a container won’t be the same as the path to a shared library on the host machine.</p></li>&#13;
<li><p>Your eBPF program might need to be aware of the language in which an application was written. For example, in C the arguments to a function are generally passed using registers, but in Go they are passed using the stack,<sup><a data-type="noteref" href="ch07.html#ch07fn3" id="ch07fn3-marker">3</a></sup> so the <code>pt_args</code> structure holding register information may be of less use.</p></li>&#13;
</ul>&#13;
<p>That said, there are lots of useful tools that instrument user space applications with eBPF. For example, you can hook into the SSL library to trace out decrypted versions of encrypted information—we’ll explore this in more detail in the next chapter. Another example is continuous profiling of your applications, using tools such as <a href="https://www.parca.dev">Parca</a>.<a contenteditable="false" data-primary="" data-startref="ch07.html11" data-type="indexterm" id="idm46123194679520"/><a contenteditable="false" data-primary="" data-startref="ch07.html10" data-type="indexterm" id="idm46123194678112"/><a contenteditable="false" data-primary="" data-startref="ch07.html9" data-type="indexterm" id="idm46123194676736"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="LSM" data-type="sect2"><div class="sect2" id="lsm">&#13;
<h2>LSM</h2>&#13;
<p><a contenteditable="false" data-primary="LSM (Linux Security Module)" data-secondary="programs attached to" data-type="indexterm" id="idm46123194655568"/><a contenteditable="false" data-primary="tracing" data-secondary="LSM" data-type="indexterm" id="idm46123194654464"/><code>BPF_PROG_TYPE_LSM</code> programs are attached to the <em>Linux Security Module (LSM) API</em>, which is a stable interface within the kernel originally intended for kernel modules to use to enforce security policies. As you’ll see in <a data-type="xref" href="ch09.html#ebpf_for_security">Chapter 9</a>, where I’ll discuss this in more detail, eBPF security tooling can now use this interface too.</p>&#13;
<p><code>BPF_PROG_TYPE_LSM</code> programs are attached using <code>bpf(BPF_RAW_TRACEPOINT_OPEN)</code>, and in many ways they are treated like tracing programs. One interesting characteristic of <code>BPF_PROG_TYPE_LSM</code> programs is that the return value affects the way the kernel behaves. A nonzero return code indicates that the security check wasn’t passed, so the kernel won’t proceed with whatever operation it was asked to complete. This is a significant difference from perf-related program types where the return code is ignored.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The Linux kernel documentation covers <a href="https://oreil.ly/vcPHY">LSM BPF programs</a>.</p>&#13;
</div>&#13;
<p>The LSM program type isn’t the only one with a role to play in security. Many of the networking-related program types that you’ll see in the next section can be used for network security to permit or deny networking traffic or networking-related operations. You’ll also see more about eBPF being used for security purposes in <a data-type="xref" href="ch09.html#ebpf_for_security">Chapter 9</a>.</p>&#13;
<p>So far in this chapter you have seen how a set of kernel and user space tracing program types enable visibility over the whole system. The next set of eBPF program types to consider are those that let us hook into the network stack, with the option not merely to observe but also to affect how it handles data being sent and received.<a contenteditable="false" data-primary="" data-startref="ch07.html3" data-type="indexterm" id="idm46123194646048"/><a contenteditable="false" data-primary="" data-startref="ch07.html2" data-type="indexterm" id="idm46123194644672"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Networking" data-type="sect1"><div class="sect1" id="networking">&#13;
<h1>Networking</h1>&#13;
<p><a contenteditable="false" data-primary="networking" data-secondary="eBPF program types" data-type="indexterm" id="ch07.html12"/><a contenteditable="false" data-primary="networking program types" data-type="indexterm" id="ch07.html13"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="networking types" data-type="indexterm" id="ch07.html14"/>There are lots of different eBPF program types intended to process network messages as they pass through various points in the network stack. <a data-type="xref" href="#bpf_program_types_hook_into_various_poi">Figure 7-1</a> shows where some of the commonly used program types attach. These program types all require <code>CAP_NET_ADMIN</code> and <code>CAP_BPF</code>, or <code>CAP_SYS_ADMIN</code>, capabilities to be permitted.</p>&#13;
<p>The context passed to these types of programs is the network message in question, although the type of structure depends on the data the kernel has at the relevant point in the network stack. At the bottom of the stack, data is held in the form of Layer 2 network packets, which are essentially a series of bytes that have been or are ready to be transmitted “on the wire.” At the top of the stack, applications use sockets, and the kernel creates socket buffers to handle data being sent and received from these <span class="keep-together">sockets</span>.</p>&#13;
<figure><div class="figure" id="bpf_program_types_hook_into_various_poi">&#13;
<img alt="BPF program types hook into various points in the network stack" src="assets/lebp_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>BPF program types hook into various points in the network stack</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The network layer model is beyond the scope of this book, but it’s covered in many other books, posts, and training courses. I discussed it in <a data-type="xref" href="ch10.html#ebpf_programming">Chapter 10</a> of <a class="orm:hideurl" href="https://www.oreilly.com/library/view/container-security/9781492056690/"><em>Container Security</em></a> (O’Reilly). For the purposes of this book, it’s sufficient to know that Layer 7 covers formats intended for applications to use, such as HTTP, DNS, or gRPC; TCP is at Layer 4; IP is at Layer 3; and Ethernet and WiFi are at Layer 2. One of the roles of the networking stack is to convert messages between these different formats.</p>&#13;
</div>&#13;
<p><a contenteditable="false" data-primary="networking program types" data-secondary="tracing-related types versus" data-type="indexterm" id="idm46123194627216"/>One big difference between the networking program types and the tracing-related types you saw earlier in this chapter is that they are generally intended to allow for the customization of networking behaviors. That involves two main characteristics:</p>&#13;
<ol>&#13;
<li><p>Using a return code from the eBPF program to tell the kernel what to do with a network packet—which could involve processing it as usual, dropping it, or redirecting it to a different destination</p></li>&#13;
<li><p>Allowing the eBPF program to modify network packets, socket configuration parameters, and so on</p></li>&#13;
</ol>&#13;
<p>You’ll see some examples of how these characteristics are used to build powerful networking capabilities in the next chapter, but for now, here’s an overview of the eBPF program types.</p>&#13;
<section data-pdf-bookmark="Sockets" data-type="sect2"><div class="sect2" id="sockets">&#13;
<h2>Sockets</h2>&#13;
<p><a contenteditable="false" data-primary="networking program types" data-secondary="sockets" data-type="indexterm" id="idm46123194622112"/><a contenteditable="false" data-primary="sockets" data-type="indexterm" id="idm46123194620768"/>At the top of the stack, a subset of these network-related program types relates to sockets and socket operations:</p>&#13;
<ul>&#13;
<li><p><code>BPF_PROG_TYPE_SOCKET_FILTER</code> was the first program type to be added to the kernel. You probably guessed from the name that this is used for socket filtering, but what’s less obvious is that this doesn’t mean filtering data being sent to or from an application. It’s used to filter a <em>copy</em> of socket data that can be sent to an observability tool such as tcpdump.</p></li>&#13;
<li><p>A socket is specific to a Layer 4 (TCP) connection. <code>BPF_PROG_TYPE_SOCK_OPS</code> allows eBPF programs to intercept various operations and actions that take place on a socket, and to set for that socket parameters such as TCP timeout values. Sockets only exist at the endpoints for a connection, and not on any middleboxes that they might pass through.</p></li>&#13;
<li><p><code>BPF_PROG_TYPE_SK_SKB</code> programs are used in conjunction with a special map type that holds a set of references to sockets to provide what’s known as <a href="https://oreil.ly/0Enuo"><em>sockmap</em> operations</a>: redirecting traffic to different destinations at the socket layer.</p></li>&#13;
</ul>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Traffic Control" data-type="sect2"><div class="sect2" id="traffic_control">&#13;
<h2>Traffic Control</h2>&#13;
<p><a contenteditable="false" data-primary="networking program types" data-secondary="traffic control" data-type="indexterm" id="idm46123194613152"/><a contenteditable="false" data-primary="traffic control (TC)" data-type="indexterm" id="idm46123194611808"/>Further down the network stack comes “TC” or traffic control. There is a whole subsystem in the Linux kernel related to TC, and a glance at the <a href="https://oreil.ly/kfyg5">manpage for the <code>tc</code> command</a> will give you an idea of how complex it is and how important it is to computing in general to have deep levels of flexibility and configuration over the way network packets are handled.</p>&#13;
<p>eBPF programs can be attached to provide custom filters and classifiers for network packets for both ingress and egress traffic. This is one of the building blocks of the Cilium project, and I’ll cover some examples in the next chapter. If you can’t wait until then, there are some good examples on <a href="https://oreil.ly/heQ2D">Quentin Monnet’s blog</a>. This can be done programmatically, but you also have the option to use the <code>tc</code> command to manipulate these kinds of eBPF programs.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="XDP" data-type="sect2"><div class="sect2" id="xdp">&#13;
<h2>XDP</h2>&#13;
<p><a contenteditable="false" data-primary="networking program types" data-secondary="XDP" data-type="indexterm" id="idm46123194605632"/><a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="program types" data-type="indexterm" id="idm46123194604240"/>You briefly met XDP (eXpress Data Path) eBPF programs in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>. In that example I loaded the eBPF program and attached it to the <code>eth0</code> interface using the following commands:</p>&#13;
<pre data-type="programlisting">bpftool prog load hello.bpf.o /sys/fs/bpf/hello&#13;
bpftool net attach xdp id 540 dev eth0</pre>&#13;
<p>It’s worth noting that XDP programs attach to a specific interface (or virtual interface), and you may very well have different XDP programs attached to different <span class="keep-together">interfaces</span>. In <a data-type="xref" href="ch08.html#ebpf_for_networking">Chapter 8</a> you’ll learn more about how XDP programs can be offloaded to network cards or executed by network drivers.</p>&#13;
<p>XDP programs are another example of  programs that can be managed using Linux network utilities—in this case, the <code>link</code> subcommand of <a href="https://oreil.ly/8Isau">iproute2’s ip</a>. The roughly equivalent command for loading and attaching the program to <code>eth0</code> would be this:</p>&#13;
<pre data-type="programlisting">$ ip link set dev eth0 xdp obj hello.bpf.o sec xdp</pre>&#13;
<p>This command reads the eBPF program marked as section <code>xdp</code> from the <code>hello.bpf.o</code> object and attaches it to the <code>eth0</code> network interface. The <code>ip link show</code> command for this interface now includes some information about the XDP program that’s attached to it:</p>&#13;
<pre data-type="programlisting">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdpgeneric qdisc fq_codel&#13;
state UP mode DEFAULT group default qlen 1000&#13;
    link/ether 52:55:55:3a:1b:a2 brd ff:ff:ff:ff:ff:ff&#13;
    prog/xdp id 1255 tag 9d0e949f89f1a82c jited</pre>&#13;
<p>Removing the XDP program with <code>ip link</code> can be done like this:</p>&#13;
<pre data-type="programlisting">$ ip link set dev eth0 xdp off</pre>&#13;
<p>You’ll see a lot more about XDP programs and their applications in the next chapter.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Flow Dissector" data-type="sect2"><div class="sect2" id="flow_dissector">&#13;
<h2>Flow Dissector</h2>&#13;
<p><a contenteditable="false" data-primary="flow dissector" data-type="indexterm" id="idm46123194588880"/><a contenteditable="false" data-primary="networking program types" data-secondary="flow dissector" data-type="indexterm" id="idm46123194587680"/>A flow dissector is used at various points in the network stack to extract details from a packet’s headers. eBPF programs of type <code>BPF_PROG_TYPE_FLOW_DISSECTOR</code> can implement custom packet dissection. There’s a nice write-up in this LWN article on <a href="https://oreil.ly/nFKLV">writing network flow dissectors in BPF</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Lightweight Tunnels" data-type="sect2"><div class="sect2" id="lightweight_tunnels">&#13;
<h2>Lightweight Tunnels</h2>&#13;
<p><a contenteditable="false" data-primary="encapsulation, lightweight tunnels and" data-type="indexterm" id="idm46123194582800"/><a contenteditable="false" data-primary="lightweight tunnels" data-type="indexterm" id="idm46123194581632"/><a contenteditable="false" data-primary="networking program types" data-secondary="lightweight tunnels" data-type="indexterm" id="idm46123194580528"/><a contenteditable="false" data-primary="tunnels, lightweight" data-type="indexterm" id="idm46123194579136"/>The family of <code>BPF_PROG_TYPE_LWT_*</code> program types can be used to implement network encapsulation in eBPF programs. <a contenteditable="false" data-primary="ip route" data-type="indexterm" id="idm46123194577456"/>These program types can also be manipulated using the <code>ip</code> command, but this time it’s the <code>route</code> subcommand that’s involved. In practice, these are used infrequently.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Cgroups" data-type="sect2"><div class="sect2" id="cgroups">&#13;
<h2>Cgroups</h2>&#13;
<p><a contenteditable="false" data-primary="cgroups (control groups)" data-type="indexterm" id="idm46123194573552"/><a contenteditable="false" data-primary="containers, cgroups and" data-type="indexterm" id="idm46123194572336"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="cgroups and" data-type="indexterm" id="idm46123194571232"/><a contenteditable="false" data-primary="networking program types" data-secondary="cgroups" data-type="indexterm" id="idm46123194569856"/>eBPF programs can be attached to cgroups (short for “control groups”). <em>Cgroups</em> are a concept in the Linux kernel that restricts the set of resources a given process or group of processes can have access to. Cgroups are one of the mechanisms that isolate one container (or one Kubernetes pod) from another. Attaching eBPF programs to a cgroup allows for custom behavior that only applies to that cgroup’s processes. All processes are associated with a cgroup, including processes that are not running inside a container.</p>&#13;
<p>There are several cgroup-related program types, and even more hooks where they can be attached. At least at the time of this writing, they are nearly all networking related, although there is also a <code>BPF_CGROUP_SYSCTL</code> program type that can be attached to sysctl commands affecting a particular cgroup.</p>&#13;
<p>As an example, there are socket-related program types specific to cgroups <code>BPF_PROG_TYPE_CGROUP_SOCK</code> and <code>BPF_PROG_TYPE_CGROUP_SKB</code>. eBPF programs can determine whether a given cgroup is permitted to perform a requested socket operation or data transmission. This is useful for network security policy enforcement (which I’ll cover in the next chapter). Socket programs can also trick the calling process into thinking they are connecting to a particular destination address.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Infrared Controllers" data-type="sect2"><div class="sect2" id="infrared_controllers">&#13;
<h2>Infrared Controllers</h2>&#13;
<p><a contenteditable="false" data-primary="infrared controllers" data-type="indexterm" id="idm46123194563968"/><a contenteditable="false" data-primary="networking program types" data-secondary="infrared controllers" data-type="indexterm" id="idm46123194562768"/>Programs of type <a href="https://oreil.ly/AwG1C">BPF_PROG_TYPE_LIRC_MODE2</a> can be attached to the file descriptor for an infrared controller device to provide decoding for infrared protocols. At the time of this writing, this program type requires <code>CAP_NET_ADMIN</code>, but I think this illustrates that the division of program types into tracing related and networking related doesn’t fully express the range of different applications that eBPF can address.<a contenteditable="false" data-primary="" data-startref="ch07.html14" data-type="indexterm" id="idm46123194560096"/><a contenteditable="false" data-primary="" data-startref="ch07.html13" data-type="indexterm" id="idm46123194558720"/><a contenteditable="false" data-primary="" data-startref="ch07.html12" data-type="indexterm" id="idm46123194557344"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BPF Attachment Types" data-type="sect1"><div class="sect1" id="bpf_attachment_types">&#13;
<h1>BPF Attachment Types</h1>&#13;
<p><a contenteditable="false" data-primary="attachment types" data-secondary="BPF" data-type="indexterm" id="idm46123194554256"/><a contenteditable="false" data-primary="BPF attachment types" data-type="indexterm" id="idm46123194552880"/>The attachment type offers more fine-grained control over where a program can be attached in the system. For some program types there is a one-to-one correlation to the type of hook that it can be attached to, so the attachment type is implicitly defined by the program type. For example, XDP programs are attached to XDP hooks in the network stack. For a few program types, an attachment type also has to be specified.</p>&#13;
<p>The attachment type is involved in deciding which helper functions are valid, and it also restricts access to parts of the context information in some cases. There was an example of this earlier in this chapter where the verifier gives an <code>invalid bpf_context access</code> error.</p>&#13;
<p>You can also see which program types need an attachment type to be specified, and which attachment types are valid, in the kernel function <a href="https://oreil.ly/0LqCQ">bpf_prog_load_check_attach</a> (defined in <a href="https://oreil.ly/7OrYS"><em>bpf/syscall.c</em></a>).</p>&#13;
&#13;
<p class="pagebreak-before">For example, here is the code that checks the attachment type for a program of type <code>CGROUP_SOCK</code>:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">case</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/BPF_PROG_TYPE_CGROUP_SOCK"><code class="no">BPF_PROG_TYPE_CGROUP_SOCK</code></a><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/switch"><code class="k">switch</code></a><code class="w"> </code><code class="p">(</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/expected_attach_type"><code class="n">expected_attach_type</code></a><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">case</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/BPF_CGROUP_INET_SOCK_CREATE"><code class="no">BPF_CGROUP_INET_SOCK_CREATE</code></a><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">case</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/BPF_CGROUP_INET_SOCK_RELEASE"><code class="no">BPF_CGROUP_INET_SOCK_RELEASE</code></a><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">case</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/BPF_CGROUP_INET4_POST_BIND"><code class="no">BPF_CGROUP_INET4_POST_BIND</code></a><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">case</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/BPF_CGROUP_INET6_POST_BIND"><code class="no">BPF_CGROUP_INET6_POST_BIND</code></a><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">default</code><code class="o">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="o">-</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/EINVAL"><code class="n">EINVAL</code></a><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code></pre>&#13;
<p>This program type can be attached in multiple places: at socket creation, at socket release, or after a bind is completed in IPv4 or IPv6.</p>&#13;
<p>Another place to find a listing of the valid attachment types for programs is the <a href="https://oreil.ly/jraLh"><em>libbpf</em> documentation</a>, where you’ll also find the section names that <em>libbpf</em> understands for each program and attachment type.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000016">&#13;
<h1>Summary</h1>&#13;
<p>In this chapter you saw that various eBPF program types are used to attach into different hook points in the kernel. If you want to write code that responds to a particular event, you’ll need to determine the program type(s) that are appropriate for hooking onto that event. The context passed into the program depends on the program type, and the kernel may also respond differently to the return code from your program, depending on its type.</p>&#13;
<p>The example code for this chapter mostly focused on perf-related (tracing) events. In the next two chapters you’ll see more details on different eBPF program types used for networking and security applications.<a contenteditable="false" data-primary="" data-startref="ch07.html1" data-type="indexterm" id="idm46123194486144"/><a contenteditable="false" data-primary="" data-startref="ch07.html0" data-type="indexterm" id="idm46123194484768"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="exercises_id000006">&#13;
<h1>Exercises</h1>&#13;
<p>The example code for this chapter includes kprobe, fentry, tracepoint, raw tracepoint, and BTF-enabled tracepoint programs that are all attached to the entry to the same system call. As you know, eBPF tracing programs can be attached to many other places besides syscalls.</p>&#13;
<ol>&#13;
<li><p>Run the example code using <code>strace</code> to capture the <code>bpf()</code> system calls, like this:</p>&#13;
<pre data-type="programlisting">strace -e bpf -o outfile ./hello</pre>&#13;
<p>This will record information about each <code>bpf()</code> syscall into a file called <em>outfile</em>. Look for the <code>BPF_PROG_LOAD</code> instructions in that file, and see how the <code>prog_type</code> file varies for different programs. You can identify which program is which by the <code>prog_name</code> field in the trace, and match them to the source code in <em>chapter7/hello.bpf.c</em>.</p></li>&#13;
<li><p>The example user space code in <em>hello.c</em> loads all the program objects defined in <code>hello.bpf.o</code>. As an exercise in writing <em>libbpf</em> user space code, modify the example code load and attach just one of the eBPF programs (pick whichever one you like), without removing those programs from <em>hello.bpf.c</em>.</p></li>&#13;
<li><p>Write a kprobe and/or fentry program that is triggered when some other kernel function is called. You can find the available functions in your kernel version by looking at <em>/proc/kallsyms</em>.</p></li>&#13;
<li><p>Write a regular, raw or BTF-enabled tracepoint program that attaches to some other kernel tracepoint. You can find the available tracepoints in <code>/sys/kernel/tracing/available_events</code>.</p></li>&#13;
<li><p>Try to attach more than one XDP program to a given interface, and confirm that you can’t! You should see an error that looks something like this:</p>&#13;
<pre data-type="programlisting">libbpf: Kernel error message: XDP program already attached&#13;
Error: interface xdpgeneric attach failed: Device or resource busy</pre></li>&#13;
</ol>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch07fn1"><sup><a href="ch07.html#ch07fn1-marker">1</a></sup> Except for a few parts of the kernel where kprobes aren’t permitted for security reasons. These are listed in <code>/sys/kernel/debug/kprobes/blacklist</code>.</p><p data-type="footnote" id="ch07fn2"><sup><a href="ch07.html#ch07fn2-marker">2</a></sup> The only example I have seen so far is in the <a href="https://oreil.ly/rL5E8">cilium/ebpf test suite</a>.</p><p data-type="footnote" id="ch07fn3"><sup><a href="ch07.html#ch07fn3-marker">3</a></sup> Up to Go version 1.17, when a new register-based calling convention was introduced. Nevertheless, I think there will be Go executables built with older versions circulating for some time to come.</p></div></div></section></body></html>