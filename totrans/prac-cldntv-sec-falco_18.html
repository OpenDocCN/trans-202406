<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Falco Development"><div class="chapter" id="falco_development">
<h1><span class="label">Chapter 14. </span>Falco Development</h1>
<p><a contenteditable="false" data-primary="extending Falco" data-type="indexterm" id="ch14.html0"/>Extending Falco is the best way to ensure that it perfectly fits your unique requirements. This chapter will show you three approaches to Falco development. We’ll begin with an overview of Falco’s codebase and a quick guide to building Falco from the source, which allows you to work with Falco’s code directly. This first approach gives you more freedom but is more difficult and perhaps less convenient than the other two. The second approach lets you build an application that processes Falco notifications in the desired way by interfacing with the gRPC API. The third is the standard and easiest way of extending Falco: writing your own plugin.</p>
<p>For the last two approaches, we will teach you by using examples. We use the Go programming language in these code snippets, so some familiarity with it will be helpful, but it’s not strictly required. This chapter also assumes that you have read <a data-type="xref" href="part02.xhtml#ii_the_architecture_of_falco">Part II</a> of this book. If you are concerned that this material may be too difficult, don’t be scared: we think you’ll find it understandable and interesting even if you are not a developer.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="programming_languages_for_falco_develop">
<h5>Programming Languages for Falco Development</h5>
<p><a contenteditable="false" data-primary="extending Falco" data-secondary="programming languages for" data-type="indexterm" id="idm45324222383920"/>Falco’s core is written mainly in C++, with some low-level components in C (like <em>libscap</em> and the drivers). To fully understand the codebase or work with the core components, a good knowledge of C/C++ is required. However, Falco also exposes the gRPC and Plugin APIs, which you can use to develop components for Falco in virtually any programming language you like. Using these APIs is our preferred way of extending Falco and does not require you to stick with C/C++.</p>
<p><a contenteditable="false" data-primary="Go" data-secondary="Falco APIs" data-type="indexterm" id="idm45324222381696"/>Go is the most common language for interfacing with Falco’s APIs, because it’s been so widely adopted in cloud native software. You will notice that most Falcosecurity libraries, SDKs, and tools use Go. For the same reason, we use Go in the code snippets included in this chapter, and you’ll need to install Go if you want to run them.</p>
<p>If you want to use another programming language, the general concepts described in this chapter still apply, so we recommend reading on.</p>
</div></aside>
<section data-type="sect1" data-pdf-bookmark="Working with the Codebase"><div class="sect1" id="working_with_the_codebase">
<h1>Working with the Codebase</h1>
<p><a contenteditable="false" data-primary="codebase" data-secondary="working with" data-type="indexterm" id="ch14.html1"/><a contenteditable="false" data-primary="extending Falco" data-secondary="working with codebase" data-type="indexterm" id="ch14.html2"/>Falco is open source, and all its source code lives in GitHub under the Falcosecuriy organization. All you need to start navigating the codebase is a browser. If you want to store the source code locally and open it with your preferred editor, you will need to use Git.</p>
<p>The Falcosecurity organization hosts Falco and many other related projects. The community is very active, so you will also find many experimental projects. The <span class="keep-together">core of The</span> Falco Project lives in two main repositories: <em>falcosecurity/falco</em> and <em><span class="keep-together">falcosecurity/libs</span></em>.</p>
<section data-type="sect2" data-pdf-bookmark="The falcosecurity/falco Repository"><div class="sect2" id="the_falcosecuritysolidusfalco_repositor">
<h2>The falcosecurity/falco Repository</h2>
<p><a contenteditable="false" data-primary="codebase" data-secondary="falcosecurity/falco repository" data-type="indexterm" id="idm45324222369472"/><a contenteditable="false" data-primary="falcosecurity/falco repository" data-type="indexterm" id="idm45324222368032"/>The <a href="https://oreil.ly/lqnL4"><em>falcosecurity/falco</em> repository</a> contains the source code of the <em>falco</em> user-space program (the one you usually interact with). It’s the main and most important repository. The project is organized as follows:</p>
<dl>
<dt><em>/cmake</em></dt>
<dd><p>Here you can find cmake modules that the Falco build system uses to pull dependencies and implement specific functionalities, including cmake files to pull the <em>falcosecurity/libs</em> source code during the build process.</p></dd>
<dt><em>/docker</em></dt>
<dd><p>This folder is organized into various subdirectories, each containing the source code of a Falco container image. Some are not published because they are for development use only. See the <a href="https://oreil.ly/oiGQQ">README file</a> for details.</p></dd>
<dt><em>/proposals</em></dt>
<dd><p>This folder includes design proposals made by the community and approved by maintainers. You may find useful information here that helps you understand how the Falco authors made certain architectural decisions and the rationale behind them.</p></dd>
<dt><em>/rules</em></dt>
<dd><p>The default rules files live here.</p></dd>
<dt><em>/scripts</em></dt>
<dd><p>Various script files live inside this folder. For example, this is where you’ll find the <em>falco-driver-loader</em> script’s source code.</p></dd>
<dt><em>/test</em> and <em>/tests</em></dt>
<dd><p>These two folders contain regression tests and unit tests for Falco, respectively.</p></dd>
<dt><em>/userspace</em></dt>
<dd><p>The actual C++ source code of Falco lives inside this folder. Its contents are organized into two subdirectories: <em>engine</em>, which contains the rule engine implementation, and <em>falco</em>, which contains the implementations of high-level features like the output channels, the gRPC server, and the CLI application.</p></dd>
</dl>
<p>Although this is the main Falco repository, not all of the project’s source code lives here. Most is actually in the <em>falcosecurity/libs</em> repository<em>,</em> which contains the implementations of Falco’s core low-level logic.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="The falcosecurity/libs Repository"><div class="sect2" id="the_falcosecuritysoliduslibs_repository">
<h2>The falcosecurity/libs Repository</h2>
<p><a contenteditable="false" data-primary="codebase" data-secondary="falcosecurity/libs repository" data-type="indexterm" id="idm45324222349792"/><a contenteditable="false" data-primary="falcosecurity/libs repository" data-type="indexterm" id="idm45324222348352"/>Throughout this book, we have mentioned <em>libscap</em>, <em>libsinsp</em>, and the drivers many times. The <a href="https://oreil.ly/HSLDT"><em>falcosecurity/libs</em> repository</a> hosts the source code of those components. It is organized as follows:</p>
<dl>
<dt><em>/cmake/modules</em></dt>
<dd><p>This folder contains cmake modules to pull external dependencies and module definitions for <em>libscap</em> and <em>libsinsp</em> that consumer applications (like Falco) can use.</p></dd>
<dt><em>/driver</em></dt>
<dd><p>This folder includes the source code for the kernel module and eBPF probe (mainly in C).</p></dd>
<dt><em>/proposals</em></dt>
<dd><p>Similar to the one in the Falco repository, this folder contains the design proposal documents.</p></dd>
<dt><em>/userspace</em></dt>
<dd><p>Organized into several subdirectories, here you can find the source code (in C and C++) of <em>libsinsp</em> and <em>libscap</em> along with other shared code.</p></dd>
</dl>
<p>This repository contains all the low-level logic required for kernel instrumentation and data enrichment. The filtering grammar, plugin framework implementation, and many other functionalities are hosted here. The <em>libs</em> codebase is vast, but don’t let that frighten you: all you need to understand it is a good knowledge of C/C++.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Building Falco from Source"><div class="sect2" id="building_falco_from_source">
<h2>Building Falco from Source</h2>
<p><a contenteditable="false" data-primary="codebase" data-secondary="building Falco from source" data-type="indexterm" id="idm45324222334928"/>Compiling Falco from its source is similar to compiling any other C++ project that uses cmake. The build system requires a handful of dependencies: cmake, make, gcc, wget, and of course git. (You also need Git to get a local copy of the Falco repository.) You can find instructions on how to install those dependencies in the <a href="https://oreil.ly/UMJI2">documentation</a>.</p>
<p>Once you have ensured that the required dependencies are installed on your system, use the following command to get a local copy of the repository:</p>
<pre data-type="programlisting">$ <strong>git clone git@github.com:falcosecurity/falco.git</strong></pre>
<p>Git will clone the repository into a newly created folder called <em>falco</em>. Enter that directory:</p>
<pre data-type="programlisting">$ <strong>cd falco</strong></pre>
<p>Prepare a directory to contain the build files, then enter it:</p>
<pre data-type="programlisting">$ <strong>mkdir -p build</strong>
$ <strong>cd build</strong></pre>
<p>Finally, inside the build directory, run:</p>
<pre data-type="programlisting">$ <strong>cmake -DUSE_BUNDLED_DEPS=On ..</strong>
$ <strong>make falco</strong></pre>
<p>This command will likely take a substantial amount of time the first time you run it, as cmake downloads and builds all the dependencies. This is because we configured it with <code>-DUSE_BUNDLED_DEPS=On</code>; alternatively, you can set <code>-DUSE_BUNDLED_DEPS=Off</code> to use system dependencies, but if you do this, you will need to manually install all the required dependencies on your system before building Falco. You can find an updated list of dependencies and other useful cmake options in the documentation.</p>
<p>After the <code>make</code> command completes, if there were no errors, you should find the newly created Falco executable in <em>./userspace/falco/falco</em> (the path is relative to the build directory).</p>
<p>Now, if you also want to build the driver from the source and you already have the kernel headers installed in your system, run:</p>
<pre data-type="programlisting">$ <strong>make driver</strong></pre>
<p>This command only builds the kernel module, by default. If you want to build the eBPF probe instead, use:</p>
<pre data-type="programlisting">$ <strong>cmake -DBUILD_BPF=True ..</strong>
$ <strong>make bpf</strong></pre>
<p>In both cases, you will find the newly built driver under <em>./driver</em> (the path is relative to the build directory).<a contenteditable="false" data-primary="" data-startref="ch14.html2" data-type="indexterm" id="idm45324222317440"/><a contenteditable="false" data-primary="" data-startref="ch14.html1" data-type="indexterm" id="idm45324222316064"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Extending Falco Using the gRPC API"><div class="sect1" id="extending_falco_using_the_grpc_api">
<h1>Extending Falco Using the gRPC API</h1>
<p><a contenteditable="false" data-primary="extending Falco" data-secondary="gRPC API and" data-type="indexterm" id="ch14.html3"/><a contenteditable="false" data-primary="gRPC API" data-type="indexterm" id="ch14.html4"/>Although you might be tempted to introduce a new feature directly into the codebase, there are more convenient ways. For example, if you want to extend Falco’s output mechanism, you can create a program that works on top of Falco and implements your business logic. In particular, the gRPC API allows your program to consume Falco notifications and receive metadata easily.</p>
<p>This section will use an example program to show you how to start developing with the Falco gRPC API. To follow along, you’ll need a running Falco instance with the gRCP server and gRPC output channel enabled (see <a data-type="xref" href="ch08.xhtml#the_output_framework">Chapter 8</a>). You will use gRPC via a Unix socket, so make sure you have installed and configured Falco accordingly.</p>
<p>We use the <a href="https://oreil.ly/1bSay"><em>client-go</em> library</a> in the following example, which makes using the gRPC API straightforward:</p>
<pre data-type="programlisting" data-code-language="golang"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w">
</code><code class="w">  
</code><code class="kn">import</code><code class="w"> </code><code class="p">(</code><code class="w">
</code><code class="w">   </code><code class="s">"context"</code><code class="w">
</code><code class="w">   </code><code class="s">"fmt"</code><code class="w">
</code><code class="w">   </code><code class="s">"time"</code><code class="w">
</code><code class="w">  
   </code><code class="s">"github.com/falcosecurity/client-go/pkg/api/outputs"</code><code class="w"> </code><a class="co" id="code_id_14_1" href="#list_id_14_1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code class="w">
   </code><code class="s">"github.com/falcosecurity/client-go/pkg/client"</code><code class="w">  </code><a class="co" href="#list_id_14_1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code class="w">
</code><code class="p">)</code><code class="w">
</code><code class="w">  
</code><code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">  
   </code><code class="c1">// Set up a connection to Falco via a Unix socket</code><code class="w">
</code><code class="w">   </code><code class="nx">c</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">client</code><code class="p">.</code><code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">client</code><code class="p">.</code><code class="nx">Config</code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="nx">UnixSocketPath</code><code class="p">:</code><code class="w"> </code><code class="s">"unix:///var/run/falco.sock"</code><code class="p">,</code><code class="w"> </code><a class="co" id="code_id_14_2" href="#list_id_14_2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code class="w">
   </code><code class="p">}</code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="w">   </code><code class="k">defer</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">Close</code><code class="p">(</code><code class="p">)</code><code class="w">
</code><code class="w">  
   </code><code class="c1">// Subscribe to a stream of Falco notifications</code><code class="w">
</code><code class="w">   </code><code class="nx">err</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">OutputsWatch</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">Background</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><a class="co" id="code_id_14_3" href="#list_id_14_3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code class="w">
      </code><code class="kd">func</code><code class="p">(</code><code class="nx">res</code><code class="w"> </code><code class="o">*</code><code class="nx">outputs</code><code class="p">.</code><code class="nx">Response</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">         </code><code class="c1">// Put your business logic here</code><code class="w">
</code><code class="w">         </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">res</code><code class="p">.</code><code class="nx">Output</code><code class="p">,</code><code class="w"> </code><code class="nx">res</code><code class="p">.</code><code class="nx">OutputFields</code><code class="p">)</code><code class="w"> </code><a class="co" id="code_id_14_4" href="#list_id_14_4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code class="w">
         </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w">
</code><code class="w">      </code><code class="p">}</code><code class="p">,</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">Second</code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w">
</code><code class="w">      </code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w">
</code><code class="w">   </code><code class="p">}</code><code class="w">
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="list_id_14_1" href="#code_id_14_1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>We start by importing the <a href="https://oreil.ly/iQD2m"><em>client-go</em> library</a>.</p></dd>
<dt><a class="co" id="list_id_14_2" href="#code_id_14_2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>main</code> function sets up a connection (represented by the variable <code>c</code>) to Falco’s gRPC server via the Unix socket using the default path.</p></dd>
<dt><a class="co" id="list_id_14_3" href="#code_id_14_3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The connection <code>c</code> allows it to call the <code>OutputsWatch</code> function, which subscribes to a stream of notifications and processes any incoming notification using a callback function.</p></dd>
<dt><a class="co" id="list_id_14_4" href="#code_id_14_4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>This example uses an <a href="https://oreil.ly/f4htn">anonymous function</a> that prints the notification to standard output. In a real-world application, you would implement your own business logic to consume Falco notifications.</p></dd>
</dl>
<p>Using the gRPC API to implement programs that interact with Falco is convenient and straightforward. If, instead, you need to make Falco work with other data sources, the plugin system is likely what you are looking for.<a contenteditable="false" data-primary="" data-startref="ch14.html4" data-type="indexterm" id="idm45324222024304"/><a contenteditable="false" data-primary="" data-startref="ch14.html3" data-type="indexterm" id="idm45324222023088"/></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Extending Falco with Plugins"><div class="sect1" id="extending_falco_with_plugins">
<h1>Extending Falco with Plugins</h1>
<p><a contenteditable="false" data-primary="extending Falco" data-secondary="plugins for" data-type="indexterm" id="ch14.html5"/><a contenteditable="false" data-primary="plugins" data-secondary="extending Falco with" data-type="indexterm" id="ch14.html6"/>Plugins are the main way to extend Falco, and we’ve mentioned them many times throughout the book. To recap briefly, plugins are <a href="https://oreil.ly/EkUs3">shared libraries</a> that conform to specific APIs. In the Falco plugin framework, the primary responsibilities of plugins are adding new data sources by connecting Falco to external sources and producing events, and extracting data from events by exporting lists of fields and decoding event data to produce field values when Falco requires them.</p>
<p>Plugins contain the logic to produce and interpret data. This is powerful because it means that Falco is only concerned with gathering field values from plugins and composing them into rule conditions. In other words, Falco only knows which fields can be used and how to get their values; everything else is delegated to the plugins. Thanks to this system, you can connect Falco to any domain.</p>
<p>There are a few important aspects to consider when designing a plugin. First, a plugin with event sourcing capability implicitly defines the event payload format (the serialized raw event data that the plugin returns to the framework). The same plugin, or other plugins with field extraction capability compatible with that data source, will be able to access the payload later, when extracting fields. Second, a plugin with field extraction capability explicitly defines fields that are bound to a data source. Finally, rules rely on data source specifications to consume the events in the format they expect.</p>
<p>Since describing every single technical aspect of plugin development would require a dedicated book, in this section we’ll just offer an educational example of how to implement a plugin that can both generate events and extract fields. For more extensive coverage, refer to the <a href="https://oreil.ly/004ur">documentation</a>.</p>
<p>Our example will implement a plugin that reads from the bash history file (by default located at <em>~/.bash_history</em>). Each time a user enters a command in the shell, bash stores that command line. When the shell session ends, bash appends the entered command lines in the history file. It’s basically a log file. Although it has no <span class="keep-together">compelling</span> use cases, it’s a simple way to learn how to create a plugin that generates events from a log file. So, let’s start having fun with a bit of Go code.</p>
<section data-type="sect2" data-pdf-bookmark="Preparing a Plugin in Go"><div class="sect2" id="preparing_a_plugin_in_go">
<h2>Preparing a Plugin in Go</h2>
<p><a contenteditable="false" data-primary="Go" data-secondary="preparing plugins in" data-type="indexterm" id="idm45324222009552"/><a contenteditable="false" data-primary="plugins" data-secondary="preparing in Go" data-type="indexterm" id="idm45324222008176"/>First, create a file (we called ours <em>myplugin.go</em>) and import a bunch of Go packages to simplify development. You’ll also import <a href="https://oreil.ly/BdIXO"><em>tail</em></a>, a library that emulates the <a href="https://oreil.ly/OWco5"><code>tail</code> command</a> (our example uses it to read from the log file), and a set of packages from Falcosecurity’s <a href="https://oreil.ly/lnyhl">Plugin SDK for Go</a> <a contenteditable="false" data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="preparing a plugin in Go" id="idm45324222003664"/>that let you implement a source plugin with that extractor capability. You must use the <code>main</code> package, or Go won’t allow you to compile it as a shared object:</p>
<pre data-type="programlisting" data-code-language="golang"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w"/>
<code class="w">  </code>
<code class="kn">import</code><code class="w"> </code><code class="p">(</code><code class="w"/>
<code class="w">   </code><code class="s">"encoding/json"</code><code class="w"/>
<code class="w">   </code><code class="s">"fmt"</code><code class="w"/>
<code class="w">   </code><code class="s">"io"</code><code class="w"/>
<code class="w">   </code><code class="s">"os"</code><code class="w"/>
<code class="w">   </code><code class="s">"time"</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="s">"github.com/hpcloud/tail"</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="s">"github.com/falcosecurity/plugin-sdk-go/pkg/sdk"</code><code class="w"/>
<code class="w">   </code><code class="s">"github.com/falcosecurity/plugin-sdk-go/pkg/sdk/plugins"</code><code class="w"/>
<code class="w">   </code><code class="s">"github.com/falcosecurity/plugin-sdk-go/pkg/sdk/plugins/extractor"</code><code class="w"/>
<code class="w">   </code><code class="s">"github.com/falcosecurity/plugin-sdk-go/pkg/sdk/plugins/source"</code><code class="w"/>
<code class="p">)</code><code class="w"/></pre>
<p>The SDK defines a set of interfaces that help you implement a plugin by following a simplified, well-defined pattern. As you will see in a moment, you have to satisfy those interfaces by adding methods—also called <a href="https://oreil.ly/t5aAZ">functions with receivers</a> in Go—to a couple of data structures that represent your plugin. Under the hood, the SDK exports those methods as the calling convention functions (or simply C symbols) required by the plugin framework. (See <a data-type="xref" href="ch04.xhtml#falco_plugins">“Falco Plugins”</a> if you need a refresher on this.)</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Plugin State and Initialization"><div class="sect2" id="plugin_state_and_initialization">
<h2>Plugin State and Initialization</h2>
<p><a contenteditable="false" data-primary="plugins" data-secondary="state and initialization" data-type="indexterm" id="ch14.html7"/><a contenteditable="false" data-primary="state" data-type="indexterm" id="ch14.html8"/><a contenteditable="false" data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="plugin state and initialization" id="idm45324221956880"/>The SDK requires a data structure that represents the plugin and its state. It can implement various composable interfaces, but all types of plugins must implement, at minimum, <code>Info</code> to expose general information about the plugin and <code>Init</code> to initialize the plugin with a given configuration string.</p>
<p>The example calls this data structure <code>bashPlugin</code>. You’ll also define another data structure (called <code>bashPluginCfg</code>) that represents the plugin’s configuration, to store options inside it. This isn’t mandatory, but it’s usually convenient:</p>
<pre data-type="programlisting" data-code-language="golang"><code class="c1">// bashPluginCfg represents the plugin configuration.</code><code class="w"/>
<code class="kd">type</code><code class="w"> </code><code class="nx">bashPluginCfg</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="nx">Path</code><code class="w"> </code><code class="kt">string</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="c1">// bashPlugin holds the state of the plugin.</code><code class="w"/>
<code class="kd">type</code><code class="w"> </code><code class="nx">bashPlugin</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="nx">plugins</code><code class="p">.</code><code class="nx">BasePlugin</code><code class="w"/>
<code class="w">   </code><code class="nx">config</code><code class="w"> </code><code class="nx">bashPluginCfg</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Now you’ll implement the first required method that exposes general information about the plugin:</p>
<pre data-type="programlisting" data-code-language="golang"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">bashPlugin</code><code class="p">)</code><code class="w"> </code><code class="nx">Info</code><code class="p">()</code><code class="w"> </code><code class="o">*</code><code class="nx">plugins</code><code class="p">.</code><code class="nx">Info</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">plugins</code><code class="p">.</code><code class="nx">Info</code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="nx">ID</code><code class="p">:</code><code class="w">          </code><code class="mi">999</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="nx">Name</code><code class="p">:</code><code class="w">        </code><code class="s">"bash"</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="nx">Description</code><code class="p">:</code><code class="w"> </code><code class="s">"A Plugin that reads from ~/.bash_history"</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="nx">Version</code><code class="p">:</code><code class="w">     </code><code class="s">"0.1.0"</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="nx">EventSource</code><code class="p">:</code><code class="w"> </code><code class="s">"bash"</code><code class="p">,</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<div data-type="tip"><h6>Tip</h6>
<p>The <code>ID</code> field is required for all source plugins and must be unique across them to ensure interoperability. The special value <code>999</code> is reserved for development purposes only; if you intend to distribute your plugin, you should register it in the <a href="https://oreil.ly/7C9n1">plugins registry</a> to get a unique ID.</p>
</div>
<p>Another important field for interoperability is <code>EventSource</code>, where you can declare the name of the data source. Extractor plugins can use that value to determine whether they are compatible with the data source.</p>
<p>The other required method is <code>Init</code>. Falco calls this method only once, when loading the plugin, and passes the configuration string (the one defined in the Falco configuration for the plugin). Commonly, the configuration string is JSON-formatted. Our example first sets a default value for a member of <code>b.config</code> (an instance of the data structure for the plugin configuration that we declared earlier). Then, if the given <code>config</code> string is not empty, the function decodes the JSON value into <code>b.config</code>:<a contenteditable="false" data-primary="" data-startref="ch14.html8" data-type="indexterm" id="idm45324221799280"/><a contenteditable="false" data-primary="" data-startref="ch14.html7" data-type="indexterm" id="idm45324221797872"/></p>
<pre data-type="programlisting" data-code-language="golang"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">bashPlugin</code><code class="p">)</code><code class="w"> </code><code class="nx">Init</code><code class="p">(</code><code class="nx">config</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="c1">// default value</code><code class="w"/>
<code class="w">   </code><code class="nx">homeDir</code><code class="p">,</code><code class="w"> </code><code class="nx">_</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">UserHomeDir</code><code class="p">()</code><code class="w"/>
<code class="w">   </code><code class="nx">b</code><code class="p">.</code><code class="nx">config</code><code class="p">.</code><code class="nx">Path</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="nx">homeDir</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">"/.bash_history"</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="c1">// skip empty config</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="nx">config</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="s">""</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">       </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="c1">// else parse the provided config</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="nx">json</code><code class="p">.</code><code class="nx">Unmarshal</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">config</code><code class="p">),</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">b</code><code class="p">.</code><code class="nx">config</code><code class="p">)</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Adding Event Sourcing Capability"><div class="sect2" id="adding_event_sourcing_capability">
<h2>Adding Event Sourcing Capability</h2>
<p><a contenteditable="false" data-primary="event sourcing capability" data-type="indexterm" id="ch14.html9"/><a contenteditable="false" data-primary="plugins" data-secondary="event sourcing capability and" data-type="indexterm" id="ch14.html10"/><a contenteditable="false" data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="adding event sourcing capability" id="idm45324221680288"/>Specifically for plugins with event sourcing capability, the <a contenteditable="false" data-primary="capture session" data-type="indexterm" id="idm45324221678848"/>SDK requires another data structure that represents a <em>capture session</em> (a stream of events). It also requires the following methods:</p>
<ul>
<li><p><code>Open</code> to start and initialize a capture session</p></li>
<li><p><code>NextBatch</code> to produce events</p></li>
</ul>
<p>Falco calls <code>Open</code> immediately after initialization. That represents the beginning of a capture session. The method’s main responsibility is instantiating the data structure that holds the session state (<code>bashInstance</code> in our example). Specifically, here we make a <code>*tail.Tail</code> instance (that mimics the behavior of <code>tail -f -n 0</code>) and store <span class="keep-together">it in <code>t</code>.</span> Then we create a <code>bashInstance</code> instance (to which we can assign <code>t</code>) and <span class="keep-together">return it:</span></p>
<pre data-type="programlisting" data-code-language="golang"><code class="c1">// bashInstance holds the state of the current session.</code><code class="w"/>
<code class="kd">type</code><code class="w"> </code><code class="nx">bashInstance</code><code class="w"> </code><code class="kd">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="nx">source</code><code class="p">.</code><code class="nx">BaseInstance</code><code class="w"/>
<code class="w">   </code><code class="nx">t</code><code class="w">      </code><code class="o">*</code><code class="nx">tail</code><code class="p">.</code><code class="nx">Tail</code><code class="w"/>
<code class="w">   </code><code class="nx">ticker</code><code class="w"> </code><code class="o">*</code><code class="nx">time</code><code class="p">.</code><code class="nx">Ticker</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">bashPlugin</code><code class="p">)</code><code class="w"> </code><code class="nx">Open</code><code class="p">(</code><code class="nx">params</code><code class="w"> </code><code class="kt">string</code><code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="nx">source</code><code class="p">.</code><code class="nx">Instance</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="nx">t</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">tail</code><code class="p">.</code><code class="nx">TailFile</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">config</code><code class="p">.</code><code class="nx">Path</code><code class="p">,</code><code class="w"> </code><code class="nx">tail</code><code class="p">.</code><code class="nx">Config</code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="nx">Follow</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="nx">Location</code><code class="p">:</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">tail</code><code class="p">.</code><code class="nx">SeekInfo</code><code class="p">{</code><code class="w"/>
<code class="w">         </code><code class="nx">Offset</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>
<code class="w">         </code><code class="nx">Whence</code><code class="p">:</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">SEEK_END</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="p">},</code><code class="w"/>
<code class="w">   </code><code class="p">})</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">bashInstance</code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="nx">t</code><code class="p">:</code><code class="w">      </code><code class="nx">t</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="nx">ticker</code><code class="p">:</code><code class="w"> </code><code class="nx">time</code><code class="p">.</code><code class="nx">NewTicker</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Millisecond</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">30</code><code class="p">),</code><code class="w"/>
<code class="w">   </code><code class="p">},</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>The plugin system stores the value returned by <code>Open</code> and passes it as an argument to the most important method for a source plugin: <code>NextBatch</code>. Unlike the other methods, this belongs to the session data structure (<code>bashInstance</code>) and not to the plugin data structure (<code>bashPlugin</code>). During the capture session, Falco repeatedly calls <code>NextBatch</code>, which in turn produces a batch of new events. A batch’s maximum size depends on the size of its underlying reusable memory buffer. However, a batch can have fewer events than its maximum capacity; it can contain just one event or even be empty. This method usually implements the core business logic of a source plugin, but this example just implements some simple logic: it tries to receive lines from the <code>b.t.Lines</code> channel and add them to the batch. If there are none, it will time out after a while:</p>
<pre data-type="programlisting" data-code-language="golang"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">bashInstance</code><code class="p">)</code><code class="w"> </code><code class="nx">NextBatch</code><code class="p">(</code><code class="w"/>
<code class="w">	</code><code class="nx">bp</code><code class="w"> </code><code class="nx">sdk</code><code class="p">.</code><code class="nx">PluginState</code><code class="p">,</code><code class="w"/>
<code class="w">	</code><code class="nx">evts</code><code class="w"> </code><code class="nx">sdk</code><code class="p">.</code><code class="nx">EventWriters</code><code class="p">,</code><code class="w"/>
<code class="p">)</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="p">,</code><code class="w"> </code><code class="kt">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="mi">0</code><code class="w"/>
<code class="w">   </code><code class="nx">b</code><code class="p">.</code><code class="nx">ticker</code><code class="p">.</code><code class="nx">Reset</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Millisecond</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mi">30</code><code class="p">)</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="k">for</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="p">&lt;</code><code class="w"> </code><code class="nx">evts</code><code class="p">.</code><code class="nx">Len</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">select</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">case</code><code class="w"> </code><code class="nx">line</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">b</code><code class="p">.</code><code class="nx">t</code><code class="p">.</code><code class="nx">Lines</code><code class="p">:</code><code class="w"/>
<code class="w">         </code><code class="k">if</code><code class="w"> </code><code class="nx">line</code><code class="p">.</code><code class="nx">Err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">line</code><code class="p">.</code><code class="nx">Err</code><code class="w"/>
<code class="w">         </code><code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="w">         </code><code class="c1">// Add an event to the batch</code><code class="w"/>
<code class="w">         </code><code class="nx">evt</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">evts</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code><code class="w"/>
<code class="w">         </code><code class="k">if</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">evt</code><code class="p">.</code><code class="nx">Writer</code><code class="p">().</code><code class="nx">Write</code><code class="p">([]</code><code class="nb">byte</code><code class="p">(</code><code class="nx">line</code><code class="p">.</code><code class="nx">Text</code><code class="p">));</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">            </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">         </code><code class="p">}</code><code class="w"/>
<code class="w">         </code><code class="nx">i</code><code class="o">++</code><code class="w"/>
<code class="w">      </code><code class="k">case</code><code class="w"> </code><code class="o">&lt;-</code><code class="nx">b</code><code class="p">.</code><code class="nx">ticker</code><code class="p">.</code><code class="nx">C</code><code class="p">:</code><code class="w"/>
<code class="w">         </code><code class="c1">// Timeout occurred, return early</code><code class="w"/>
<code class="w">         </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="nx">sdk</code><code class="p">.</code><code class="nx">ErrTimeout</code><code class="w"/>
<code class="w">      </code><code class="p">}</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="c1">// The batch is full</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="nx">i</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>As you can see, the SDK provides an <code>sdk.EventWriters</code> interface. This automatically manages the reusable memory buffer for the batch and allows the implementer to write the raw event payload as a sequence of bytes. The function <code>evts.Len</code> returns the maximum number of events allowed in a batch.</p>
<p>The choice of the format of the event payload is up to the plugin author, because the Plugin API allows both the encoding (in our example, for simplicity, we store the whole line as plain text in the payload) and the decoding of the data (as we will see in a moment). This permits you to create fields that you can use in rules. Choosing the correct format is essential because it has implications both for performance and for compatibility with other plugins (other authors may want to implement an extractor plugin that works with your events).</p>
<p>So far, you have seen the minimum set of methods required to implement a source plugin. However, the plugin would not really be useful at this point if we did not add a way to export fields to use in rule conditions and output.<a contenteditable="false" data-primary="" data-startref="ch14.html10" data-type="indexterm" id="idm45324221059072"/><a contenteditable="false" data-primary="" data-startref="ch14.html9" data-type="indexterm" id="idm45324221094464"/></p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Adding Field Extraction Capability"><div class="sect2" id="adding_field_extraction_capability">
<h2>Adding Field Extraction Capability</h2>
<p><a contenteditable="false" data-primary="field extraction, plugins and" data-type="indexterm" id="idm45324221091472"/><a contenteditable="false" data-primary="plugins" data-secondary="field extraction capability" data-type="indexterm" id="idm45324221090400"/>Plugins with field extraction capability can extract values from the event data and export fields that Falco can use. A plugin can have only event sourcing capability (described in the previous section), only field extraction capability, or both (like our example plugin). A plugin with field extraction capability will work on data sources provided by other plugins, while a plugin with both capabilities usually works only on its own data source. However, the mechanism is the same, regardless of the data source. <a contenteditable="false" data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="adding field extraction capability" id="idm45324221088928"/>The SDK lets you define the following methods, which apply in both cases:</p>
<ul>
<li><p><code>Fields</code> to declare which fields the plugin is able to extract</p></li>
<li><p><code>Extract</code> to extract the value of a given field from the event data</p></li>
</ul>
<p>Let’s implement those methods in our example plugin. The first method, <code>Fields</code>, returns a slice of <code>sdk.FieldEntry</code>. Each entry contains the specification of a single field. The following code tells Falco that the plugin can extract a field called <code>shell.command</code> (this example adds just one field):</p>
<pre data-type="programlisting" data-code-language="golang"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">b</code><code class="w"> </code><code class="o">*</code><code class="nx">bashPlugin</code><code class="p">)</code><code class="w"> </code><code class="nx">Fields</code><code class="p">()</code><code class="w"> </code><code class="p">[]</code><code class="nx">sdk</code><code class="p">.</code><code class="nx">FieldEntry</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="p">[]</code><code class="nx">sdk</code><code class="p">.</code><code class="nx">FieldEntry</code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="p">{</code><code class="nx">Type</code><code class="p">:</code><code class="w"> </code><code class="s">"string"</code><code class="p">,</code><code class="w"> </code><code class="nx">Name</code><code class="p">:</code><code class="w"> </code><code class="s">"shell.command"</code><code class="p">,</code><code class="w"> </code><code class="nx">Display</code><code class="p">:</code><code class="w"> </code><code class="s">"Shell command line"</code><code class="p">,</code><code class="w"> </code>
<code class="w">       </code><code class="nx">Desc</code><code class="p">:</code><code class="w"> </code><code class="s">"The command line typed by user in the shell"</code><code class="p">},</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>Now, to make the extraction work, we need to implement the <code>Extract</code> method, which provides the actual business logic to extract the field. The method receives as arguments an extraction request (which contains the identifier of the requested field) and a reader (to access the event payload). Implementing it is straightforward since this example has just one field and will simply return all the content of the event payload. In a real-world scenario, you would usually have more fields and specific logic to extract each of them:</p>
<pre data-type="programlisting" data-code-language="golang"><code class="kd">func</code><code class="w"> </code><code class="p">(</code><code class="nx">m</code><code class="w"> </code><code class="o">*</code><code class="nx">bashPlugin</code><code class="p">)</code><code class="w"> </code><code class="nx">Extract</code><code class="p">(</code><code class="nx">req</code><code class="w"> </code><code class="nx">sdk</code><code class="p">.</code><code class="nx">ExtractRequest</code><code class="p">,</code><code class="w"> </code><code class="nx">evt</code><code class="w"> </code><code class="nx">sdk</code><code class="p">.</code><code class="nx">EventReader</code><code class="p">)</code><code class="w"> </code><code class="kt">error</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="nx">bb</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">io</code><code class="p">.</code><code class="nx">ReadAll</code><code class="p">(</code><code class="nx">evt</code><code class="p">.</code><code class="nx">Reader</code><code class="p">())</code><code class="w"/>
<code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nx">err</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="w">   </code><code class="k">switch</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">FieldID</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="k">case</code><code class="w"> </code><code class="mi">0</code><code class="p">:</code><code class="w"> </code><code class="c1">// shell.command</code><code class="w"/>
<code class="w">      </code><code class="nx">req</code><code class="p">.</code><code class="nx">SetValue</code><code class="p">(</code><code class="nb">string</code><code class="p">(</code><code class="nx">bb</code><code class="p">))</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="kc">nil</code><code class="w"/>
<code class="w">   </code><code class="k">default</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"unsupported field: %s"</code><code class="p">,</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">Field</code><code class="p">())</code><code class="w"/>
<code class="w">   </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>With the field extraction capability in place, our example plugin is nearly ready. Let’s see how to complete and use it.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Finalizing the Plugin"><div class="sect2" id="finalizing_the_plugin">
<h2>Finalizing the Plugin</h2>
<p><a contenteditable="false" data-primary="plugins" data-secondary="finalizing" data-type="indexterm" id="idm45324220793392"/>You’re almost there. <a contenteditable="false" data-type="indexterm" data-primary="SDK (software development kit)" data-secondary="finalizing the plugin" id="idm45324220791888"/>Next, you’ll create an instance of the plugin and register its capabilities with the SDK. You can do that during the Go initialization phase by using the special <a href="https://oreil.ly/LDPaK"><code>init</code> function</a>. (Do not confuse this with the <code>Init</code> method!) Since our example plugin has both source and extractor capabilities, we have to inform the SDK of both using the provided functions:</p>
<pre data-type="programlisting" data-code-language="golang"><code class="kd">func</code><code class="w"> </code><code class="nx">init</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">   </code><code class="nx">plugins</code><code class="p">.</code><code class="nx">SetFactory</code><code class="p">(</code><code class="kd">func</code><code class="p">()</code><code class="w"> </code><code class="nx">plugins</code><code class="p">.</code><code class="nx">Plugin</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="nx">p</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">bashPlugin</code><code class="p">{}</code><code class="w"/>
<code class="w">      </code><code class="nx">extractor</code><code class="p">.</code><code class="nx">Register</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="nx">source</code><code class="p">.</code><code class="nx">Register</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code><code class="w"/>
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nx">p</code><code class="w"/>
<code class="w">   </code><code class="p">})</code><code class="w"/>
<code class="p">}</code><code class="w"/>
<code class="w">  </code>
<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{}</code><code class="w"/></pre>
<p>Note the empty <code>main</code> function. As you will see in a moment, the Go building system requires this to build the plugin correctly, but it will never call <code>main</code>, so you can always leave it empty.</p>
<p>The last step to make your code a real Go project is to initialize the Go module and download the dependencies:</p>
<pre data-type="programlisting">$ <strong>go mod init</strong> <strong><em>example.com/my/plugin</em></strong>
$ <strong>go mod tidy</strong></pre>
<p>These commands create the <em>go.mod</em> and <em>go.sum</em> files, respectively. The code for your plugin is now ready. It’s time to compile it so that you can use it with Falco!</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Building a Plugin Written in Go"><div class="sect2" id="building_a_plugin_written_in_go">
<h2>Building a Plugin Written in Go</h2>
<p><a contenteditable="false" data-primary="Go" data-secondary="building a plugin written in" data-type="indexterm" id="idm45324220721568"/><a contenteditable="false" data-primary="plugins" data-secondary="building a plugin written in Go" data-type="indexterm" id="idm45324220720224"/>A plugin is a shared library (also called a <em>shared object</em>)—specifically, a compiled file—that exports a set of C symbols required by the plugin framework. (The SDK we used in the example hides those C symbols by using high-level interfaces, but they are still present underneath.)</p>
<p>The Go compiler has a specific command called <a href="https://oreil.ly/sD0aW"><code>cgo</code></a> for creating Go packages that interface with C code. It allows you to compile your plugin and get a shared library file (a .<em>so</em> or <em>.dll</em> file). The command is pretty straightforward. From the same folder where the source code lives, run:</p>
<pre data-type="programlisting">$ <strong>go build -buildmode=c-shared -o libmyplugin.so</strong></pre>
<p>This command creates <em>libmyplugin.so</em>, which you can use with Falco. (By convention, shared object files in Unix-like systems start with <em>lib</em> and have <em>.so</em> as their extension.) You learned about plugin configuration in <a data-type="xref" href="ch10.xhtml#configuring_and_running">Chapter 10</a>, but the following section will give you some hints about using plugins while developing.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Using Plugins While Developing"><div class="sect2" id="using_plugins_while_developing">
<h2>Using Plugins While Developing</h2>
<p><a contenteditable="false" data-primary="plugins" data-secondary="using while developing" data-type="indexterm" id="idm45324220655184"/>By default, Falco looks for installed plugins at <em>/usr/share/falco/plugins</em>. However, you can specify an absolute path in the configuration and place your plugin wherever you want. (That’s convenient while developing, since you won’t need to install the plugin in the default path.) We suggest building the plugin (using the command in the previous section) in the same folder you are using to develop it. Then, in the same folder, create a copy of <em>falco.yaml</em>, add your plugin configuration accordingly, and set the <code>library_path</code> option to the absolute path of your plugin. For example:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">plugins</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bash</code><code class="w"/>
<code class="w">    </code><code class="nt">library_path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/path/to/your/plugin/libmyplugin.so</code><code class="w"/>
<code class="w">    </code><code class="nt">init_config</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">  </code>
<code class="nt">load_plugins</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">bash</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Now, before using your plugin, you need a rules file that matches the data source provided by the plugin. (Falco would load the plugin even without the rules file, but you wouldn’t get any notifications.) You can create a rules file in the same folder—for instance, <em>myplugin_rules.yaml</em>—and add a rule like the following to it:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Cat in the shell</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Match command lines starting with "cat".</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell.command startswith "cat "</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Cat in shell detected (command=%shell.command)</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DEBUG</code><code class="w"/>
<code class="w">  </code><code class="nt">source</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bash</code><code class="w"/></pre>
<p>Once you have prepared both your customized <em>falco.yaml</em> and <em>myplugin_rules.yaml,</em> the very last step is to run Falco and pass those files in the respective options:</p>
<pre data-type="programlisting">$ <strong>falco -c falco.yaml -r myplugin_rules.yaml</strong></pre>
<p>Done! This way of running a plugin in Falco is very convenient during development, since it does not require you to install any files or mess with your local Falco installation.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you built the plugin in our example, to trigger the rule, you can run:<a contenteditable="false" data-primary="" data-startref="ch14.html6" data-type="indexterm" id="idm45324220554768"/><a contenteditable="false" data-primary="" data-startref="ch14.html5" data-type="indexterm" id="idm45324220553392"/></p>
<pre data-type="programlisting">$ <strong>bash</strong>
$ <strong>cat --version</strong>
$ <strong>exit</strong></pre>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000013">
<h1>Conclusion</h1>
<p>There are several ways of extending Falco. Writing a plugin is generally the best option, especially if you want Falco to work with a new data source to enable new use cases. The gRPC API may help you if you need to interface with outputs. On rare occasions, you may need to modify the Falco core and its components directly.</p>
<p>Whatever the case, you will need to read the documentation. You may sometimes need to study and understand advanced topics. Since Falco is open source and a collaborative project, you always have the opportunity to get in touch with its vibrant community. Sharing ideas and knowledge with others will help you find answers faster.</p>
<p>You may also discover that other people have your exact needs and are willing to help you improve or extend Falco. That would be a perfect opportunity to contribute to the Falco project. Everyone can contribute to Falco. Not only is it a rewarding experience, but contributing is a great help to the project and all of its users, including you. Want to know how? Read the next chapter!<a contenteditable="false" data-primary="" data-startref="ch14.html0" data-type="indexterm" id="idm45324220546832"/></p>
</div></section>
</div></section></div></body></html>