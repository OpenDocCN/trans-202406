- en: Chapter 18\. Ambassador
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Ambassador* pattern is a specialized sidecar responsible for hiding external
    complexities and providing a unified interface for accessing services outside
    the Pod. In this chapter, you will see how the *Ambassador* pattern can act as
    a proxy and decouple the main container from directly accessing external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerized services don’t exist in isolation and very often have to access
    other services that may be difficult to reach in a reliable way. The difficulty
    in accessing other services may be due to dynamic and changing addresses, the
    need for load balancing of clustered service instances, an unreliable protocol,
    or difficult data formats. Ideally, containers should be single-purposed and reusable
    in different contexts. But if we have a container that provides some business
    functionality and consumes an external service in a specialized way, the container
    will have more than one responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the external service may require a special service discovery library
    that we do not want to put in our container. Or we may want to swap different
    kinds of services by using different kinds of service-discovery libraries and
    methods. This technique of abstracting and isolating the logic for accessing other
    services in the outside world is the goal of this *Ambassador* pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate the pattern, we will use a cache for an application. Accessing
    a local cache in the development environment may be a simple configuration, but
    in the production environment, we may need a client configuration that can connect
    to the different shards of the cache. Another example is consuming a service by
    looking it up in a registry and performing client-side service discovery. A third
    example is consuming a service over a nonreliable protocol such as HTTP, so to
    protect our application, we have to use circuit-breaker logic, configure timeouts,
    perform retries, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In all of these cases, we can use an ambassador container that hides the complexity
    of accessing the external services and provides a simplified view and access to
    the main application container over localhost. Figures [18-1](#img-ambassador-distributed-cache)
    and [18-2](#img-ambassador-local-cache) show how an ambassador Pod can decouple
    access to a key-value store by connecting to an ambassador container listening
    on a local port. In [Figure 18-1](#img-ambassador-distributed-cache), we see how
    data access can be delegated to a fully distributed remote store like etcd.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ambassador for accessing a remote distributed cache](assets/kup2_1801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. Ambassador for accessing a remote distributed cache
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For development purposes, this ambassador container can be easily exchanged
    with a locally running in-memory key-value store like memcached (as shown in [Figure 18-2](#img-ambassador-local-cache)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Ambassador for using a local cache](assets/kup2_1802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2\. Ambassador for accessing a local cache
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Example 18-1](#ex-ambassador) shows an ambassador that runs parallel to a
    REST service. Before returning its response, the REST service logs the generated
    data by sending it to a fixed URL: *[*http://localhost:9009*](http://localhost:9009)*.
    The ambassador process listens in on this port and processes the data. In this
    example, it prints the data out just to the console, but it could also do something
    more sophisticated like forward the data to a full logging infrastructure. For
    the REST service, it doesn’t matter what happens to the log data, and you can
    easily exchange the ambassador by reconfiguring the Pod without touching the main
    container.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1\. Ambassador processing log output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_ambassador_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Main application container providing a REST service for generating random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_ambassador_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Connection URL for communicating with the ambassador via localhost.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_ambassador_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Ambassador running in parallel and listening on port 9009 (which is not exposed
    to the outside of the Pod).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a higher level, the *Ambassador* pattern is a *Sidecar* pattern. The main
    difference between ambassador and sidecar is that an ambassador does not enhance
    the main application with additional capability. Instead, it acts merely as a
    smart proxy to the outside world (this pattern is sometimes referred to as the
    *Proxy* pattern). This pattern can be useful for legacy applications that are
    difficult to modify and extend with modern networking concepts such as monitoring,
    logging, routing, and resiliency patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of the *Ambassador* pattern are similar to those of the *Sidecar*
    pattern—both allow you to keep containers single-purposed and reusable. With such
    a pattern, our application container can focus on its business logic and delegate
    the responsibility and specifics of consuming the external service to another
    specialized container. This also allows you to create specialized and reusable
    ambassador containers that can be combined with other application containers.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Ambassador Example](https://oreil.ly/m0KTi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How to Use the Ambassador Pattern to Dynamically Configure Services on CoreOS](https://oreil.ly/TPQX5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Modifications to the CoreOS Ambassador Pattern](https://oreil.ly/6bszq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
