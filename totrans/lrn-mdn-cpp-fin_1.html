<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Some Mechanics of C++"><div class="chapter" id="some_mechanics_of_c">
<h1><span class="label">Chapter 2. </span>Some Mechanics of C++</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45807805620128">
<h5>A Note for Early Release Readers</h5>

<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 2nd chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <em>learnmodcppfinance@gmail.com</em>.</p>
</div></aside>

<p>Just about any programming language will have some form of an array structure for storing collections of like types. In C++, there are a handful of options for this purpose, but it is the Standard Library `vector` container that is by far the most-used type. In this chapter, we will see how a `vector` can conveniently represent a vector of real numbers in the mathematical sense. We will also go through the basics of creating and using a `vector` and its key member functions, as it will tie in well with iterative statements, such as counted loops and `while` statements, also to be covered in this chapter.</p>

<p>Control structures, include both iterative statements and conditional. Conditional branching in C++ can be implemented in `if` statements, similar to other languages, as well as in what are called `switch` statements. A good complementary topic related to the `switch` statement is that of enumerated types (enums), particularly the more modern <em>enum classes</em> that were added in C++11. Enum classes are also well-suited for facilitating data input to and output from financial models.</p>

<p>Finally, we will wrap up with a summary of aliases that can be used in C++, and why they are important. This includes type aliases that can add clarity to the code, in place of longer and sometimes more cryptic templated types. References and pointers allow you to access and modify objects without the overhead of object copy, although pointers have wider-ranging uses as well.</p>

<section data-type="sect1" data-pdf-bookmark="The `vector` Container"><div class="sect1" id="the_vector_container">
<h1><span>The `vector` Container</span></h1>

<p>The `vector` container in the C++ Standard Library is the go-to choice for storing and managing an indexed array of like types. It is particularly useful for managing vectors of real numbers that are ubiquitous in quantitative work, with `double` types representing the numerical values.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>Historical Note</strong>: A `vector` is more specifically part of what is called the Standard Template Library (STL). The STL was developed independently of Bjarne Stroupstrup’s early efforts in the 1980’s and 90’s to design and produce C++, by researcher Alexander Stepanov. The history behind acceptance the STL and its acceptance into the C++ Standard is a very interesting one [[see Kalb/Azman]], but the upshot is the STL – based on generic programming – was accepted into the theretofore object-oriented focused C++ for its first ISO standard release in 1998.</p>
</div>

<p>Being a generic container, `std::vector` can hold elements of a common arbitrary type, ranging from plain old data (POD) types such as `double` and `int`, to objects of user-defined and library classes.</p>

<div data-type="example">
<pre data-type="programlisting">
<strong>
#include &lt;vector&gt;
using std::vector;
//. . .
vector &lt;double&gt; x;		// Vector of real numbers
vector &lt;BondTrade&gt; bond_trades;	// Vector of user-defined BondTrade objects</strong></pre>
</div>

<p>The type to be held is indicated inside the angle brackets.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The angle brackets indicate the <em>template parameter</em>. Templates are the means by which C++ implements generic programming. This topic will be discussed in further detail in Chapter 7.</p>
</div>

<section data-type="sect2" data-pdf-bookmark="Setting and Accessing Elements of a `vector`"><div class="sect2" id="setting_and_accessing_elements_of_a_vector">
<h2><span>Setting and Accessing Elements of a `vector`</span></h2>

<p>An STL `vector` essentially encapsulates and manages a dynamic array, meaning that elements can be appended to it or removed from it after it is constructed. The `vector` also supports random access, meaning an element can be accessed, and moreover modified, by the index of the element. Like everything else in C++, a `vector` is zero-indexed, meaning that the index of its first position is index 0, and its last position is index <em>n</em> - 1, if it holds <em>n</em> elements.</p>

<section data-type="sect3" data-pdf-bookmark="Creating a `vector` and Using its Index"><div class="sect3" id="creating_a_vector_and_using_its_index">
<h3><span>Creating a `vector` and Using its Index</span></h3>

<p>The following instruction will create a vector holding three real numbers.</p>

<div data-type="example">
<pre data-type="programlisting">
vector &lt;double&gt; v(3);	// Will hold three elements</pre>
</div>

<p>The `vector` can be populated element by element as shown here. Note that indexing starts with zero rather than one.</p>

<div data-type="example">
<pre data-type="programlisting">
v[0] = 10.6;		// Set the first element (index 0) and assign to 10.6
v[1] = 58.63;		// Set the second element (index 1) and assign to 58.63
v[2] = 0.874;		// Set the first element (index 2) and assign to 0.874</pre>
</div>

<p>The index is indicated by square brackets. We can also change the values by simply reassigning an element to a new value; viz,</p>

<div data-type="example">
<pre data-type="programlisting">
v[1] = 13.68;</pre>
</div>

<p>It is also possible to initialize vectors using <em>uniform initialization</em> introduced in C++11. Also known <em>as braced initialization</em>, use of the assignment operator is optional:</p>

<div data-type="example">
<pre data-type="programlisting">
vector &lt;double&gt; w{9.8, 36.8, 91.3, 104.7}; // No assignment operator
vector &lt;int&gt; q = {4, 12, 15};	 // With assignment operator </pre>
</div>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The addition of uniform initialization to C++11 has had a significant impact on the language, beyond simply initializing a vector. It has some interesting and convenient properties that will be discussed in Chapter 4.</p>
</div>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Member Functions"><div class="sect3" id="member_functions">
<h3><span>Member Functions</span></h3>

<p>As `vector` is a class, it holds a number of public member functions, including three: `at`, `size`, and `push_back`.</p>

<section data-type="sect4" data-pdf-bookmark="The `at` Function"><div class="sect4" id="the_at_function">
<h4><span>The `at` Function</span></h4>

<p>The `at` function essentially performs the same roles as the square bracket operator, namely access of an element for a given index, or to modify the element.</p>

<div data-type="example">
<pre data-type="programlisting">
double val = v.at(2);	// val = 0.874
w.at(1) = val;			// 36.8 in w[1] is replaced with 0.874</pre>
</div>

<p>The difference between using the square bracket operator and the `at` function is the latter performs bound checking. Two examples are</p>

<ul>
	<li>
	<p>Attempting to access an element that exceeds the maximum index; eg,</p>

	<pre data-type="programlisting">
double out_of_range = v.at(100);	// 2 is the max index for v</pre>
	</li>
</ul>

<ul>
	<li>
	<p>Attempting to use a negative index value</p>

	<pre data-type="programlisting">
w.at(-3) = 19.28;</pre>
	</li>
</ul>

<p>In each case, an exception will be thrown that can be used in error handling. Otherwise, you can just think of `at` and `[.]` as the same.</p>
</div></section>

<section data-type="sect4" data-pdf-bookmark="The `size` Function"><div class="sect4" id="the_size_function">
<h4><span>The `size` Function</span></h4>

<p>The name of this member function makes it fairly obvious what it does: it returns the number of elements held by a `vector`:</p>

<div data-type="example">
<pre data-type="programlisting">
auto num_elems_w = w.size();	// Returns 5
auto num_elems_q = q.size();	// Returns 3</pre>
</div>

<p>You may notice this is the first time we have used the `auto` keyword. What this does is automatically deduce the type returned from the `size` function. We will see in future cases how useful `auto` can be, but here, it helps us get around the fact that the maximum size of a `std::vector` container will vary depending upon compiler settings and the platform you are using. The type will be some form of an unsigned (non-negative) integer, of which there are multiple sizes.</p>

<p>So as to not get into the weeds here, we don’t need to be concerned with the specific unsigned type here, so we can mostly just use `auto` for the return type of the `size` member function.</p>
</div></section>

<section data-type="sect4" data-pdf-bookmark="The `push_back` Function"><div class="sect4" id="the_push_back_function">
<h4><span>The `push_back` Function</span></h4>

<p>This function will append elements to a `vector`; that is, new elements are “pushed onto the back” of the container.</p>

<p>For example, we can append a new element to the `vector v` above, say 47.44:</p>

<div data-type="example">
<pre data-type="programlisting">
v.push_back(47.44);</pre>
</div>

<p>Now, `v` contains four values: 10.6, 58.63, 0.84, 47.44, with `v[3]` (fourth element, using 0-indexing) equal to the new value.</p>

<p>We can also append values to an empty vector. At the outset, we defined</p>

<div data-type="example">
<pre data-type="programlisting">
vector &lt;double&gt; x;		// x.size() = 0</pre>
</div>

<p>Now, if we append a value,</p>

<div data-type="example">
<pre data-type="programlisting">
x.push_back(3.08);	// x.size() = 1</pre>
</div>

<p>`x` now contains the value 3.08 in its index 0 position and contains one element. This can be repeated arbitrarily many times:</p>

<div data-type="example">
<pre data-type="programlisting">
x.push_back(5.12);	// x.size() = 2
x.push_back(7.32);	// x.size() = 3
//. . . etc</pre>
</div>

<p>To close the discussion on `push_back`, there is one potential gotcha to be aware of,</p>

<p>Suppose we create a `vector` of integers with three elements:</p>

<p>`vector &lt;int&gt; ints(3);`</p>

<p>Now, each element will hold the default value of an `int` type: 0.</p>

<p>If we then apply the `push_back` function to append, say, 5:</p>

<p>`ints.push_back(5);`</p>

<p>this value will be appended as a <em>new element</em> following the third zero; ie, the vector now contains four elements.</p>

<p><code>0 0 0 5</code></p>

<p>To put a value into any of the first three positions, you will need to use the index explicitly; eg</p>

<div data-type="example">
<pre data-type="programlisting">
ints[0] = 2;
ints.at(2) = 4;</pre>
</div>
</div></section>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Concluding Remarks on STL `vector`s"><div class="sect2" id="concluding_remarks_on_stl_vector_s">
<h2><span>Concluding Remarks on STL `vector`s</span></h2>

<p>In the examples above, we only used plain old numerical types `double` and `int`. Vectors of real numbers are of course fundamental for computational work, but keep in mind an STL `vector` is generic, in that it can hold elements of any valid type, including objects rather than just numerical data types, as we shall see in more advanced contexts.</p>

<p>Also, as mentioned earlier, in real-world production level programming, inputs are taken from function arguments that come from market and product data, and user input, not hard-coded values as seen in the previous examples. One might find vectors set with fixed numerical values in test functions, but they should be avoided in production code.</p>

<p>The Standard Library contains additional STL containers, plus a large set of STL <em>algorithms</em><em> </em>that are now a core component of modern C++ programming. These will be discussed in greater detail in Chapter 7, and becoming familiar with the basics of the `vector` container now will make this material more accessible when we get to it.</p>

<p>Finally, to reiterate, prefer using an STL `vector` over a dynamic C-style array using `new` and `delete`. There is no performance benefit to using the latter, and memory management is all encapsulated inside the `vector` class, freeing the developer from risks due to memory leaks.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Enum Constants and Classes"><div class="sect1" id="enum_constants_and_classes">
<h1><span>Enum Constants and Classes</span></h1>

<p><em>Enumerated constants</em>, more commonly called <span>enums</span> for short, map text to integers. Prior to C++11, enums were a great means of making it clearer for us mere mortals to comprehend integer codes by representing them in (contiguous) words. It was also far more efficient for the machine to process integers rather than bulkier `std::string` objects that take up more memory. And finally, errors caused by typos in quoted characters and stray strings could be avoided.</p>

<p>The C++11 Standard improved on this further with <em>enum classes</em>. These remove ambiguities that can occur with overlapping integer values when using regular enum constants, while preserving the advantages.</p>

<p>We will discuss the motivation for preferring the more modern enum classes over integer-based enums. In the next section we will see how they can be used to our advantage in conditional statements. Later on, they will prove useful in making data input and output with financial models more robust.</p>

<section data-type="sect2" data-pdf-bookmark="Enum Constants"><div class="sect2" id="enum_constants">
<h2><span>Enum Constants</span></h2>

<p>Enums allow us to pass around identifiers, classifications, indicators etc in text representation, while behind the scenes, the compiler recognizes them as integers.</p>

<p>As an example, we can create an enum called `OptionType` that will indicate the types of option deals that are allowed in a simple trading system, eg European, American, Bermudan, and Asian. The `enum` type is declared; then, inside the braces, the allowable types are defined, separated by commas. By default, each will be assigned an integer value starting at zero and incremented by one (remember that indexing in C++ is zero-based). The closing brace must be followed by a semicolon. In code, we would write:</p>

<div data-type="example">
<pre data-type="programlisting">
enum OptionType
{
    European,     	// default integer value = 0
    American,     	// default integer value = 1
    Bermudan,     	// default integer value = 2
    Asian	      	// default integer value = 3
};  </pre>
</div>

<p>We can then verify that in place of each option type, its corresponding integer value is given:</p>

<div data-type="example">
<pre data-type="programlisting">
cout &lt;&lt; " European = " &lt;&lt; European &lt;&lt; endl;
cout &lt;&lt; " American = " &lt;&lt; American &lt;&lt; endl;
cout &lt;&lt; " Bermudan = " &lt;&lt; Bermudan &lt;&lt; endl;
cout &lt;&lt; " Asian = " &lt;&lt; Asian &lt;&lt; endl;
cout &lt;&lt; endl;</pre>
</div>

<p>Checking the output, we get:</p>

<pre data-type="programlisting">
European
American
Bermudan
Asian</pre>

<p>So, we can see how the program treats the text representations as integers. Note that these text labels are <em>not</em> enclosed in quotation marks, as they ultimately represent integer types, not strings.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Potential Conflicts with Enums"><div class="sect2" id="potential_conflicts_with_enums">
<h2><span>Potential Conflicts with Enums</span></h2>

<p>As discussed at the outset, for any `enum` type, the default integer assignments start at zero and then are incremented by one for each type member. Therefore, it is possible that two enumerated constants from two different types could be numerically equal. For example, suppose we define two different `enum` types, called `Football` and `Baseball`, representing the defensive positions in each sport. By default, the baseball positions start with 0 for the pitcher and are incremented by one for each in the list. The same goes for the football positions, starting with defensive tackle. The integer constants are provided in the comments.</p>

<div data-type="example">
<pre data-type="programlisting">
enum Baseball
{
	Pitcher,		// 0
	Catcher,		// 1
	First_Baseman,	// 2
	Second_Baseman,	// 3
	Third_Baseman,	// 4
	Shortstop,		// 5
	Left_Field,    // 6
	Center_Field,	// 7
	Right_Field	// 8
};</pre>
</div>

<div data-type="example">
<pre data-type="programlisting">
enum Football
{
	Defensive_Tackle,	// 0
	Edge_Rusher,		// 1
	Defensive_End,		// 2
	Linebacker,		// 3
	Cornerback,		// 4
	Strong_Safety,		// 5
	Weak_Safety		// 6
};</pre>
</div>

<p>Then, we could compare `Defensive_End` and `First_Baseman`:</p>

<div data-type="example">
<pre data-type="programlisting">
	if (Defensive_End == First_Baseman)
	{
		cout &lt;&lt; " Defensive_End == First_Baseman is true" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; " Defensive_End != First_Baseman is true" &lt;&lt; endl;
	}</pre>
</div>

<p>Our result would be nonsense:</p>

<pre data-type="programlisting">
Defensive_End == First_Baseman is true</pre>

<p>This is because both positions map to an integer value of 2.</p>

<p>A quick fix, and one that was often employed prior to C++11, would be to reindex each set of enums; eg,</p>

<div data-type="example">
<pre data-type="programlisting">
enum Baseball
{
	Pitcher = 100,	
	Catcher,		// 101
	First_Baseman,	// 102
	. . .
};</pre>
</div>

<div data-type="example">
<pre data-type="programlisting">
enum Football
{
	Defensive_Tackle = 200,
	Edge_Rusher,		// 201
	Defensive_End,		// 202
	. . .
};</pre>
</div>

<p>Now, if we compare `Defensive_End` and `First_Baseman`, they will no longer be equal, because 202 ≠ 102. Still, in large code bases there might be hundreds of enum definitions, so it would not be out of the question for an overlap to slip in and cause errors. Enum classes, introduced in C++11, eliminate this risk.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Enum Classes"><div class="sect2" id="enum_classes">
<h2><span>Enum Classes</span></h2>

<p>A new and more robust way to avoid `enum` overlaps was introduced in C++11 that eliminates the integer representation altogether. The other benefits of enums, such as avoiding cryptic numerical codes and larger string objects, still remain, but the conflicts are avoided by using what is called an <em>enum class</em>. As an example, we can define bond and futures contract categories within enum classes, as shown here:</p>

<div data-type="example">
<pre data-type="programlisting">
enum class Bond
{
	Government,
	Corporate,		      
	Municipal,
	Convertible
};
enum class Futures_Contract
{
	Gold,
	Silver,
	Oil,
	Natural_Gas,
	Wheat,
	Corn
	};
enum class Options_Contract
{
    European,     	
    American,     	
    Bermudan,     
    Asian	      
};</pre>
</div>

<p>Notice that we no longer need to manually set integer values to avoid conflicts as we did with regular enums.</p>

<p>Attempting to compare members of two different enum classes -- such as a `Bond` and a `Futures_Contract` position, will now result in a compiler error. For example, the following will not even compile:</p>

<div data-type="example">
<pre data-type="programlisting">
if(Bond::Corporate == Futures_Contract::Gold)
{
	// . . .
}</pre>
</div>

<p>This works to our advantage, as it is much better to catch an error at compile time rather than runtime. Modern best practices now maintain that we should prefer using enum classes rather than enumerated constants [[refer to ISO Guidelines]].</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Control  Structures"><div class="sect1" id="control_structures">
<h1><span>Control </span> <span>Structures</span></h1>

<p>Control structures consist of two categories:</p>

<ul>
	<li>
	<p>Conditional branching, such as `if` statements</p>
	</li>
	<li>
	<p>Iterative controls that repeat a set of commands in a loop</p>
	</li>
</ul>

<p>In C++, the code that pertains to a given condition or sequence is contained in a block defined by braces. Similar to a function, variables declared within a block will go out of scope when the block terminates. These structures can also be nested within one another.</p>

<p>It was assumed in the previous section on enums and enum classes that you are familiar with the basics of `if` conditions, but here you can read through a more comprehensive review of conditional and iterative constructs that will be utilized heavily from here on out. Both depend on logical operators determining a true or false condition, so before launching into our tour of control structures, a quick review of logical operators and Boolean types are in order.</p>

<p>The C++ boolean type, represented represented by `bool`, can store a value of either `true` or `false`. Behind the scenes, a `bool` type has a size of one byte and may store only `1` for `true`, or `0` for `false`. Note that `true` and `false` are not placed in quotations, as ;ole enums they are not character types. They represent fixed integer values.</p>

<p>The C++ operators for equality and inequalities will return a `bool` type based on whether the result is true or false. They are as follows:</p>

<ul>
	<li>
	<p>`&lt;, &gt;` Strict inequality</p>
	</li>
	<li>
	<p>`&lt;=, &gt;=` Inclusive inequality</p>
	</li>
	<li>
	<p>`==` Equality</p>
	</li>
	<li>
	<p>`!=` Not equals</p>
	</li>
	<li>
	<p><em>And</em> and <em>Or</em> operations are represented by `&amp;&amp;` and `||` respectively.</p>
	</li>
</ul>

<p>Examples will follow in the next section on conditional branching.</p>

<section data-type="sect2" data-pdf-bookmark="Conditional Branching"><div class="sect2" id="conditional_branching">
<h2><span>Conditional Branching</span></h2>

<p>C++ supports both the usual `if` based logic found in most other languages, and `switch`/`case` statements that offer a cleaner alternative to multiple `else if` conditions in special cases.</p>

<section data-type="sect3" data-pdf-bookmark="`if`  and Related  Conditions"><div class="sect3" id="_if_and_related_conditions">
<h3><span>`if` </span> <span>and Related </span> <span>Conditions</span></h3>

<p>The usual conditional branching statements</p>

<ul>
	<li>
	<p>`if (condition) then (action)`</p>
	</li>
	<li>
	<p>`if (condition) then (action), else (default action)`</p>
	</li>
	<li>
	<p>`if (condition 1) then (action 1),`</p>
	</li>
	<li>
	<p>`else if (condition 2) then (action 2)`</p>
	</li>
	<li>
	<p>`...`</p>
	</li>
	<li>
	<p>`else if (condition n) then (action n)`</p>
	</li>
	<li>
	<p>`else (default action)`</p>
	</li>
</ul>

<p>are represented by the following C++ syntax. Each condition, whether it be `if`, `else if`, or `else`, the code that gets executed for a `true` condition is contained within a separate body, indicated by open and closed braces.</p>

<div data-type="example">
<pre data-type="programlisting">
// Simple if
if (condition)
{
  // action
}
// if/else
if (condition)
{
  // action
}
else
{
  // default action
}
// if/else if.../else
if (condition 1)
{
  // action 1
}
else if (condition 2)
{
  // action 2
}
// ...
else if (condition n)
{
  // action n
}
else
{
  // default action
}</pre>
</div>

<div data-type="tip"><h6>Tip</h6>
<p>In conditional statements containing `else if`, it is a best practice to include a default `else` block at the end. Without it, code may build without any complaints from the compiler and run just fine, but its execution could very easily result in unexpected behavior that can cause major headaches in larger and more realistic code bases.</p>
</div>

<p>Utilizing the inequality operators introduced above, we can then write some simple examples with all three variations on the `if` statement theme:</p>

<div data-type="example">
<pre data-type="programlisting">
	int x = 1;
	int y = 2;
	int z = 3;
	
	// Simple if
	if (x &gt; 0)
	{
		cout &lt;&lt; x &lt;&lt; " &gt; 0" &lt;&lt; endl;
	}
	// if/else
	if (x &gt;= y)
	{
		cout &lt;&lt; x &lt;&lt; " &gt;= " &lt;&lt; y &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; x &lt;&lt; " is less than " &lt;&lt; y &lt;&lt; endl;
	}
	// if/else if.../else
	if (x == z)
	{
		cout &lt;&lt; x &lt;&lt; " == " &lt;&lt; z &lt;&lt; endl;
	}
	else if (x &lt; z)
	{
		cout &lt;&lt; x &lt;&lt; " &gt; " &lt;&lt; z &lt;&lt; endl;
	}
	else if (x &gt; z)
	{
		cout &lt;&lt; x &lt;&lt; " &lt; " &lt;&lt; z &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "Default condition" &lt;&lt; endl;
	}</pre>
</div>

<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Due to the nature of floating point numerical representation and arithmetic, one should never test for exact equality between two `double` types, nor should floating point types be compared identically to zero. These cases will be covered later in a separate context.</p>
</div>

<p>The operators for logical AND and OR can also be used within conditional arguments. For example:</p>

<div data-type="example">
<pre data-type="programlisting">
	#include &lt;cmath&gt;
	using std::abs;
	using std::exp;
	
	// Simple if
	if (x &gt; 0 || y &lt; 1)
	{
		cout &lt;&lt; x &lt;&lt; " &gt; 0 OR " &lt;&lt; y &lt;&lt; " &lt; 1 " &lt;&lt; endl;
	}
	// if/else if.../else
	if (x &gt; 0 &amp;&amp; y &lt; 1)
	{
		cout &lt;&lt; x &lt;&lt; " &gt; 0 AND " &lt;&lt; y &lt;&lt; " &lt; 1 " &lt;&lt; endl;
	}
	else if (x &lt;= 0 || y &gt;= 1)
	{
		cout &lt;&lt; x &lt;&lt; " &lt;= 0 OR " &lt;&lt; y &lt;&lt; " &gt;= 1 " &lt;&lt; endl;
	}
	else if (z &lt;= 0 || (abs(x) &gt; z &amp;&amp; exp(y) &lt; z))
	{
		cout &lt;&lt; z &lt;&lt; " &lt;= 0 OR " &lt;&lt; endl;
		cout &lt;&lt; abs(x) &lt;&lt; " &gt; " &lt;&lt; z &lt;&lt; " AND " 
			      &lt;&lt; exp(y) &lt;&lt; " &lt; " &lt;&lt; z &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "Default condition" &lt;&lt; endl;
	}</pre>
</div>

<p>Note that in the last `else if` condition, we put the AND condition inside round brackets, as OR takes precedence over AND. [<a href="https://en.cppreference.com/w/cpp/language/operator_precedence"><span>cppreference.com</span></a>]</p>

<p>Finally, we can assign logical conditions to `bool` variables, and used within `if` conditions, as shown here:</p>

<div data-type="example">
<pre data-type="programlisting">
	bool cond1 = (x &gt; 0 &amp;&amp; y &lt; 1);
	bool cond2 = (z &lt;= 0 || (abs(x) &gt; z &amp;&amp; abs(y) &lt; z));
	if (cond1)
	{
		cout &lt;&lt; x &lt;&lt; " &gt; 0 AND " &lt;&lt; y &lt;&lt; " &lt; 1 " &lt;&lt; endl;
	}
	else if (!cond1)
	{
		cout &lt;&lt; x &lt;&lt; " &lt;= 0 OR " &lt;&lt; y &lt;&lt; " &gt;= 1 " &lt;&lt; endl;
	}
	else if (cond2)
	{
		cout &lt;&lt; z &lt;&lt; " &lt;= 0 OR " &lt;&lt; endl;
		cout &lt;&lt; abs(x) &lt;&lt; " &gt; " &lt;&lt; z &lt;&lt; " AND "
			&lt;&lt; abs(y) &lt;&lt; " &lt; " &lt;&lt; z &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "Default condition" &lt;&lt; endl;
	}</pre>
</div>

<p>Note that a boolean variable can be negated simply by preceding it with the `!` operator, as shown in the first `else if` condition above.</p>

<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>A common trap is to mistakenly use `=` to test equality instead of `==`. The former is the assignment operator and will cause unexpected behavior in this case. Be sure to use `==` when testing for equality.</p>
</div>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Ternary `if` Statement"><div class="sect3" id="ternary_if_statement">
<h3><span>Ternary `if` Statement</span></h3>

<p>There is also a convenient one-line shortcut for short and sweet `if-else` combinations. The syntax is as follows:</p>

<p><em>type</em> `var = ` <em>logical condition</em> `? var_val_true`(if `true`) : `var_val_false`(if `false`);</p>

<p>In English, this means if _<em>logical condition</em>_ is `true`, assign the value `var` to `var_val_true`; otherwise, assign it to `var_val_false`.</p>

<p>A code example should make this clearer:</p>

<div data-type="example">
<pre data-type="programlisting">
using std::sin;
using std::cos;
int j = 10;
int k = 20;
double theta = 3.14;
double result = j &lt; k ? sin(theta) : cos(theta);</pre>
</div>

<p>So, in this example, `result` would be assigned the value of sin(3.14), or approximately zero.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="The `switch`/`case` Statement  "><div class="sect3" id="the_switch_case_statement">
<h3><span>The `switch`/`case` Statement</span> <span> </span></h3>

<p>Also known as just a `switch` statement, this control sequence allows us to eliminate some of the clutter that comes with multiple `else if` clauses, but for the particular case of branching on the <em>state</em> of a single integer type, or alternatively, either an enum that maps to an integer, or an enum class member.</p>

<p>For each possible `case`, the command that follows the matching state is executed. As with the `else` condition above, a `default` action should be provided at the end to catch cases that do not fall into any of the given categories, or handle the error if no other possibilities are admissible.</p>

<p>As a first example, consider a case where we pretend an integer condition represents a type of option, and in place of each `cout`, the action would be to call a corresponding pricing model. This will render our code more readable and maintainable than using multiple `else if` statements.</p>

<div data-type="example">
<pre data-type="programlisting">
void switch_statement(int x)
{
	switch (x)
	{
	case 0:
		cout &lt;&lt; "European Option: Use Black-Scholes" &lt;&lt; endl;
		break;
	case 1:    
		cout &lt;&lt; "American Option: Use a lattice model" &lt;&lt; endl;
		break;
	case 2:
		cout &lt;&lt; "Bermudan Option: Use Longstaff-Schwartz Monte Carlo" &lt;&lt; endl;
		break;
	case 3:
		cout &lt;&lt; "Asian Option: Calculate average of the spot time series" &lt;&lt; endl;
		break;
	default:
		cout &lt;&lt; "Option type unknown" &lt;&lt; endl;
		break;
	}
}</pre>
</div>

<p>After each case, the `break` statement instructs the program to exit the `switch` statement once the corresponding code for a particular state is executed. So if `x` is `1`, a lattice model would be called to price an American option, and then control would pass out of the body of the `switch` statement rather than checking if `x` is `2`.</p>

<p>There are also cases where one might want to drop down to the next step if the same action is desired for multiple states. For example, in (American) football, if a drive stalls, the offense punts the ball on fourth down and no points are scored. If the team scores, however, it might have kicked a field goal for three points, or scored a touchdown with three possible outcomes:</p>

<ul>
	<li>
	<p>Miss the extra point(s) -- Result is six points</p>
	</li>
	<li>
	<p>Kick the extra point -- Result is seven points</p>
	</li>
	<li>
	<p>Score a two-point conversion -- Result is eight points</p>
	</li>
</ul>

<p>No matter how a team scores, it kicks the ball off to their opponent, so for cases 3, 6, 7, and 8, we just drop down through each case until we hit the kickoff. This quasi-Bayesian logic could then be implemented with the following code:</p>

<div data-type="example">
<pre data-type="programlisting">
void switch_football(int x)
{
	switch (x)
	{
	case 0:		// Drive stalls
		cout &lt;&lt; "Punt" &lt;&lt; endl;
		break;
	case 3:		// Kick field goal
	case 6:		// Score touchdown; miss extra point(s)
	case 7:		// Kick extra point
	case 8:		// Score two-point conversion
		cout &lt;&lt; "Kick off" &lt;&lt; endl;
		break;
	default:
		cout &lt;&lt; "Are you at a tennis match?" &lt;&lt; endl;
		break;
	}
}</pre>
</div>

<p>An obvious pre-C++11 alternative for the `switch` on option pricing `case`s would be to substitute in the corresponding enums for the integer codes, thus making the logic even easier to understand for human consumption (`cout` messages remain the same):</p>

<div data-type="example">
<pre data-type="programlisting">
void switch_statement_enum(OptionType ot)
{
	switch (ot)
	{
	case European:		// = 0
		cout &lt;&lt; "European Option: Use Black-Scholes" &lt;&lt; endl;
		break;
	case American:		// = 1    
		. . .
	case Bermudan:		// = 2
		. . .
	case Asian:		// = 3
		. . .
	default:
		cout &lt;&lt; "Option type unknown" &lt;&lt; endl;
		break;
	}
}</pre>
</div>

<p>However, modern ISO Guidelines now favor using enum classes, for the reasons demonstrated above with integer conflicts. So, we just substitute the `Options_Contract` enum class into the preceding example to get:</p>

<div data-type="example">
<pre data-type="programlisting">
void switch_enum_class_member(Options_Contract oc)
{
	switch (oc)
	{
	case Options_Contract::European:
		cout &lt;&lt; "European Option: Use Black-Scholes" &lt;&lt; endl;
		break;
	case Options_Contract::American:    
		. . .
	case Options_Contract::Bermudan:
		. . .
	case Options_Contract::Asian:
		. . .
	default:
		cout &lt;&lt; "Option type unknown" &lt;&lt; endl;
		break;
	}
}</pre>
</div>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Iterative  Statements  "><div class="sect2" id="iterative_statements">
<h2><span>Iterative </span> <span>Statements</span> <span> </span></h2>

<p>In C++, there are two built-in language features that enable looping logic and iteration:</p>

<ul>
	<li>
	<p>`while` and `do...while` loops</p>
	</li>
	<li>
	<p>`for` loops (including range-based `for` loops)</p>
	</li>
</ul>

<p>These iterative commands will execute a repeated block of code over a set of values or objects based on a fixed count, while a logical condition is true, or over a range of elements held by a `vector`.</p>

<section data-type="sect3" data-pdf-bookmark="`while` and `do...while` Loops "><div class="sect3" id="_while_and_do_while_loops">
<h3><span>`while` and `do...while` Loops </span></h3>

<p>The essential workflow behind a `while` loop is to repeat a block of code <em>while</em> a logical expression is `true` (or alternatively, whilst `false`). The following simple example demonstrates a simple `while` loop, where the incremented value of an integer is output to the screen while its value remains strictly less than some fixed maximum value:</p>

<div data-type="example">
<pre data-type="programlisting">
int i = 0;
int max = 10;
while (i &lt; max)
{
	cout &lt;&lt; i &lt;&lt; ", ";
	++i;
}</pre>
</div>

<p>Our logical condition is for `i` to be strictly less than the value `max`. As long as this condition holds, the value of `i` will be incremented</p>

<p>A `do...while` loop is similar, except that by placing the `while` condition at the end, it guarantees that at least one iteration of the loop will be executed. For example:</p>

<div data-type="example">
<pre data-type="programlisting">
int i = 0;
int max = 10;
do 
{
	cout &lt;&lt; i &lt;&lt; ", ";
	++i;
} while (i &lt; max);</pre>
</div>

<p>Note that even if `max` had been set to zero or less, there would still be one trip through the `do...while` loop, as the maximum condition is not checked until the end. This is the distinction that separates it from the simpler `while` loop.</p>

<p>In time, we will see looping examples that involve more interesting mathematics and financial applications.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="The `for` Loop"><div class="sect3" id="the_for_loop">
<h3><span>The `for` Loop</span></h3>

<p>This construct is another form of iteration over a countable range. The form that is employed in C++ can be summarized in the following pseudocode example:</p>

<pre data-type="programlisting">
for(initial expression executed only once;
exit condition executed at the beginning of every loop;
loop expression executed at the end of every loop)
{
DoSomeStuff;
}</pre>

<p>The syntax here is important, namely the semicolons separating the three expressions in the `for` argument. Breaking this down into parts a, b, and c, we would have</p>

<pre data-type="programlisting">
for(a; b; c) </pre>

<p>Each of these parts is typically dependent on some form of a counter, such as an `int i` counter as seen in the `while` statement; however, we now move this index into the argument of the `for` statement, which allows us to remove the increment from the body of the loop. The (a) part determines the starting value of the counter, (b) indicates where to stop, and (c) enforces how the counter is increased or decreased.</p>

<p>For example, we could rewrite the `while` example above using a `for` loop as follows:</p>

<div data-type="example">
<pre data-type="programlisting">
int max = 10;
for(int i = 0; i &lt; max; ++i)
{
	cout &lt;&lt; i &lt;&lt; ", ";		// we no longer need ++i in the body
}   </pre>
</div>

<p>The results will be exactly the same as the those in the `while` loop examples.</p>

<ol>
	<li>
	<p>There technically is a difference between the pre- and post- increment operator that can affect other uses, but either `++i` with `i++` in the `for` will work identically. It is generally preferred to use `++i`</p>
	</li>
	<li>
	<p>It is also legal to have a `for` loop where a decrement (`--`) is used to decrease the index value down to some minimum value.</p>
	</li>
</ol>
</div></section>

<section data-type="sect3" data-pdf-bookmark="`break` and `continue`"><div class="sect3" id="_break_and_continue">
<h3><span>`break` and `continue`</span></h3>

<p>In iterative loops, it is sometimes necessary to break out of a loop before a maximum or minimum index value is attained, or before the specified logical condition would otherwise terminate the iteration. A prime example in computational finance is barrier option pricing using Monte Carlo simulation. The simulation paths will typically have the same number of time steps; however, in the case of an up-and-out barrier option, for example, we would need to break out of the loop if the underlying asset price rose above the barrier level.</p>

<p>This is accomplished by applying the same `break` command as used in `switch` statements. A simple example is shown here, which also demonstrates nesting an `if` condition inside a `for` block:</p>

<div data-type="example">
<pre data-type="programlisting">
int max = 10;
for (int i = 0; i &lt; 100; ++i)
{
	cout &lt;&lt; i &lt;&lt; ", ";
	if (i &gt; max)
	{
	    cout &lt;&lt; "Passed i = " &lt;&lt; max &lt;&lt; "; I'm tired, so let's go home." 
	        &lt;&lt; endl;
	    break;
	}
}</pre>
</div>

<p>Once `i` is incremented to 11, the `if` statement is true, so the `break` command is called, causing the program control to exit the `for` loop.</p>

<p>There is also the `continue` keyword that can be used to continue the process of the loop, but since this is the default behavior of a loop anyway, its usefulness is limited.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Nested Loops"><div class="sect3" id="nested_loops">
<h3><span>Nested Loops</span></h3>

<p>In addition to nesting `if` conditions inside loops, it is also possible to nest iterative blocks inside other blocks, whether they be `for` or `while` loop. In quantitative programming, it is easy to find oneself writing double and sometimes even triple nested loops when implementing common numerical routines and financial models. This type of coding, however, can become complex and error prone in a hurry, so one needs to take special precautions, as well as consider alternatives we will take up later.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Range-Based `for` Loops"><div class="sect3" id="range_based_for_loops">
<h3><span>Range-Based `for` Loops</span></h3>

<p>Prior to C++11, iterating through a `vector` would involve using the index as the counter, up to the number its elements.</p>

<div data-type="example">
<pre data-type="programlisting">
vector&lt;double&gt; v;
// Populate the vector v and then use below:
for(unsigned i = 0; i &lt; v.size(); ++i)
{
	// Do something with v[i] or v.at(i). . .
}</pre>
</div>

<p>Range-based `for` loops, introduced in C++11, make this more functional and elegant. Instead of explicitly using the `vector` index, a range-based for loop simply says “for every element `elem` in `v`, do something with it”:</p>

<div data-type="example">
<pre data-type="programlisting">
for(auto elem : v)
{
	// Use elem, rather than v[i] or v.at(i)
}</pre>
</div>

<p>As a trivial example, calculate the sum of the elements:</p>

<div data-type="example">
<pre data-type="programlisting">
double sum = 0.0;
for(auto elem : v)
{
	sum += elem;
}</pre>
</div>

<p>And we are done. No worries about making a mistake with the index, there is less to type, and the code more obviously expresses what it is doing. The ISO Guidelines in fact tell us to prefer using range-based `for` loops with `vector` objects, as well as other STL containers that will be discussed in Chapter 7.</p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Aliases"><div class="sect1" id="aliases_idvyDptM">
<h1><span>Aliases</span></h1>

<p>Aliasing can take on several forms, the first being one of convenience, namely <em>type aliasing</em>, where commonly used parameterized type names can be assigned to a shorter and more descriptive alias names.</p>

<p>In addition, <em>reference aliases</em> help to avoid copies of objects being created when they are passed into functions, often resulting in significant speedup at runtime.</p>

<p><em>Pointers</em> can also be considered as aliases, particularly useful for representing an active object in class design (the `this` pointer in Chapter 4). Pointers (and now smart pointers) can also be used for allocating memory that persists, but this is a separate and deeper discussion that will be deferred until Chapter 6.</p>

<p>Both references and pointers can help facilitate the <em>object-oriented programming</em> concepts of <em>inheritance</em> and <em>composition</em> that will be presented in subsequent chapters.</p>

<section data-type="sect2" data-pdf-bookmark="Type Aliases"><div class="sect2" id="type_aliases">
<h2><span>Type Aliases</span></h2>

<p>`std::vector&lt;double&gt;` objects are ubiquitous in quantitative code for fairly obvious reasons. Because it is used so much, it is common to assign a type alias to it, such as `RealVector`. This better expresses what it is mathematically, plus we don’t need to bother with as much typing.</p>

<p>Using modern C++, we can define the alias `RealVector` by simply defining it as follows:</p>

<div data-type="example">
<pre data-type="programlisting">
using RealVector = vector&lt;double&gt;;</pre>
</div>

<p>Then, we could just write, for example:</p>

<div data-type="example">
<pre data-type="programlisting">
RealVector v = {3.19, 2.58, 1.06};
v.push_back(2.1);
v.push_back(1.7);
// etc...</pre>
</div>

<p>As long as the alias is defined before it is used in the code, then it’s fair game.</p>

<p>Prior to C++11, this application of the `using` command did not exist, so type aliasing was accomplished by using the `typedef` command; eg,</p>

<div data-type="example">
<pre data-type="programlisting">
typedef vector&lt;double&gt; RealVector;</pre>
</div>

<p>This is also valid C++ and is still found in many modern code bases, but the `using` form is preferable per the modern ISO Guidelines. The detailed reason for this is outside the scope of this book, but the upshot is `using` can be used to define aliases of generic templated types (eg, not just `double` parameters as above), while `typedef` cannot.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="References"><div class="sect2" id="referencesch2">
<h2><span>References</span></h2>

<p>A reference, put simply, provides an alias for a <em>variable</em>, rather than a type. Once a reference is defined, then accessing or modifying it is exactly the same as using the original variable. A reference is created by placing an ampersand between the type name and the reference name before assigning it to the original variable. For example:</p>

<div data-type="example">
<pre data-type="programlisting">
int original = 15;
int&amp; ref = original;	// int&amp; means "reference to an int"</pre>
</div>

<p>At this point, both `original` and `ref` would return 15 if accessed in a function or assigned to another variable. However, reassigning `original` to 12 would also mean `ref` now returns 12. Similarly, reassigning `ref` would change the value held by `original`:</p>

<div data-type="example">
<pre data-type="programlisting">
original = 12;			// ref now = 12	
ref = 4;				// original also now = 4</pre>
</div>

<p>It is important to note that a reference must be assigned at the same time it is declared. For example,</p>

<div data-type="example">
<pre data-type="programlisting">
int&amp; ozone;</pre>
</div>

<p>would be nonsense as there is nothing to which it refers, and the code would fail to compile. Also, once a reference is defined, it cannot be reassigned to another variable for the remainder of its lifetime.</p>

<p>Using a reference for a plain old numerical type is trivial, but they become important when passing large objects into a function, so as to avoid object copy that can decimate a program’s runtime performance.</p>

<p>Suppose we have a `std::vector` containing 2000 option contract objects? By passing it as a reference into a function, the original object itself can be accessed without copying it.</p>

<p>There is one caveat, however. Remember that if a reference is modified, so is the original variable to which it refers. For this reason, one can just make the reference argument `const`. Then, any attempt to modify the reference will be prevented by the compiler.</p>

<p>For example, here are two functions that take in a `std::vector&lt;int&gt;` object as a reference argument. The first one returns the sum of the elements, so there is no modification of the elements attempted. The second one, however, attempts to reset each element to twice its value and then sum the elements. This will result in a compiler error – much better than a runtime error – and prevent the operations from ever being executed:</p>

<div data-type="example">
<pre data-type="programlisting">
// This is OK
using IntVector = std::vector&lt;int&gt;;
int sum_ints(const IntVector&amp; v)
{
	int sum = 0;
	for (auto elem : v)
	{
		sum += elem;
	}
	
	return sum;
}
int sum_of_twice_the_ints(const IntVector&amp; v)
{
	// Will not compile!  const prevents modification
	// of the elements in the vector v.
	
	int sum = 0;
	for (auto elem : v)
	{
		elem = 2 * elem;
		sum += elem;
	}
	
	return sum;
}</pre>
</div>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It is also possible to pass a function argument as non-`const` reference, with the intent to modify it in place. In this case, one would typically make the return type `void`, instead of returning a modified variable. This is rarely justified anymore in modern C++ due to <em>return value optimization</em> (<em>RVO</em>). With RVO, objects by default are returned “in place” rather than as copies from functions. This is now a requirement for compilers per the ISO standards, beginning with C++11.</p>

<p>One final point about references relates to managed languages such as Java and C#, in that the default behavior is to pass objects by non-constant reference. In C++ the default is to pass by value; hence, one must specifically instruct the compiler to expect a function argument as a reference with the `&amp;`. This is an adjustment that a programmer needs to make if switching between C++ and a managed language.</p>
</div>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Pointers"><div class="sect2" id="pointers_idaVVqF1">
<h2><span>Pointers</span></h2>

<p>A <em>pointer</em> in C++ shares some similarities with a reference, in that it can also be an alias to another variable, but rather than being permanently tied to a variable throughout its lifetime, a pointer <em>points</em> to a memory address containing the variable’s contents, and it can be redirected to another memory address containing another variable.</p>

<p>This unfortunately can be confusing, as a memory address of a variable is also indicated by the `&amp;` operator, in addition to another operator `*` that is used to declare a pointer. A simple example illustrates this. First, declare and assign an integer variable:</p>

<div data-type="example">
<pre data-type="programlisting">
int x = 42;</pre>
</div>

<p>Next, declare a pointer to an integer, using the `*` operator:</p>

<div data-type="example">
<pre data-type="programlisting">
int* xp;</pre>
</div>

<p>This says to create a variable that will be a <em>pointer to an</em> `int` <em>type</em>, but don’t point to anything specific yet; this comes in the next step:</p>

<div data-type="example">
<pre data-type="programlisting">
xp = &amp;x;</pre>
</div>

<p>The `&amp;` operator in this case means <em>the address of</em> `x`. `xp` now points at the memory address that contains the contents of `x`, namely 42. Note that this usage of `&amp;` has a different meaning than declaring a reference.</p>

<p>We can now access the contents of this memory address by <em>dereferencing</em> `xp` by applying the `*` operator. If we put</p>

<div data-type="example">
<pre data-type="programlisting">
std::cout &lt;&lt; *xp &lt;&lt; std::endl;</pre>
</div>

<p>the output would be 42, just as if we had applied `std::cout` to the variable `x`. Note the `*` operator is used in a different context here, accessing the contents of memory rather than declaring a pointer.</p>

<p>We can also means we can change the value of `x`. For example, putting</p>

<div data-type="example">
<pre data-type="programlisting">
*xp = 25;</pre>
</div>

<p>then both `*xp` and `x` will return the value 25, rather than 42.</p>

<p>It is also possible to <em>reassign</em> the pointer `xp` to a different memory address; this is not possible to do with a reference. Suppose we have a different integer variable `y` and we reassign `xp` to point to the address of `y`:</p>

<div data-type="example">
<pre data-type="programlisting">
int y = 106;
xp = &amp;y;</pre>
</div>

<p>Now, `*xp` will return 106 rather than 25, but `x` is still equal to 25.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>`xp`, as opposed to `*xp`, will return the hexadecimal value that represents the address of the first byte in memory containing the contents of `y`.</p>
</div>

<p>Similar to references, pointers can be used with objects. If we have a class `SomeClass` with a member function, say `some_fcn`, then we can define a pointer to a `SomeClass` object:</p>

<div data-type="example">
<pre data-type="programlisting">
SomeClass sc;
auto SomeClass* ptr_sc = &amp;sc;</pre>
</div>

<p>As it’s obvious that `ptr_sc` will point to a `SomeClass` object, we can use the `auto` keyword without obscuring its context.</p>

<p>Suppose also that `SomeClass` has a member function `some_fcn`. This function can be invoked by dereferencing `ptr_sc` and then calling it in the usual way:</p>

<div data-type="example">
<pre data-type="programlisting">
(*ptr_sc).some_fcn();</pre>
</div>

<p>More common, however, is to use the indirection operator, indicated by an arrow:</p>

<div data-type="example">
<pre data-type="programlisting">
ptr_sc-&gt;some_fcn();</pre>
</div>

<p>This is all we will need to know about pointers for now. More specifically, these examples take place in stack memory, and they are automatically deleted when the function or control block in which they are defined terminates. More advanced usage will be presented later.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Pointers can also point to memory allocated in heap memory, which allows the value or object to persist in memory outside the scope of a function or control block. This becomes relevant in certain situations related to object-oriented programming and requires and extra care. Moreover, C++11 introduced smart pointers into the Standard Library. These topics will be presented in Chapter 5.</p>
</div>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Function and Operator Overloading  "><div class="sect1" id="function_and_operator_overloading">
<h1><span>Function and Operator Overloading</span> <span> </span></h1>

<p>A key feature of C++, as well as other modern programming languages, is implementing different versions of the same function name, distinguished by different sets of input arguments. This is known as <em>function overloading</em>. A related feature that is very convenient to us as quantitative programmers is <em>operator overloading</em>, where we can define an operation for specific types, such as vector multiplication. Operator overloading is not supported in as many languages as function overloading; for example, it exists in C++ and C#, but it is not an option in Java.</p>

<section data-type="sect2" data-pdf-bookmark="Function Overloading"><div class="sect2" id="function_overloading">
<h2><span>Function Overloading</span></h2>

<p>To illustrate function overloading, let’s look at an example of two versions of a `sum` function, one of which returns a `double` type, while the other returns a `vector&lt;double&gt;`. The first version is trivial, just summing two real numbers.</p>

<div data-type="example">
<pre data-type="programlisting">
#include &lt;vector&gt; 
// . . .
double sum(double x, double y)
{
	return x + y;
}</pre>
</div>

<p>The second version, however, will take in two `std::vector&lt;double&gt;` objects and return a vector containing the sum of its elements.</p>

<div data-type="example">
<pre data-type="programlisting">
std::vector&lt;double&gt; sum(const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y)
{
	// NOTE TO SELF: Can we do this with range-based for loops(?!)
	std::vector&lt;double&gt; vec_sum;
	if(x.size() == y.size())
	{
		for (int i = 0; i &lt; x.size(); ++i)
		{
			vec_sum.push_back(x.at(i) + y.at(i));
		}	
	}
	return vec_sum;		// Empty if size of x and y do not match
}</pre>
</div>

<p>As we can see, the two functions perform two distinct tasks, and have different return types, based on the types of arguments.</p>

<p>Overloaded functions can also be distinguished based on the <em>number of arguments</em> of the same type, as well as return the same type. For example (trivially), we could define a `sum` function that takes in three real numbers:</p>

<div data-type="example">
<pre data-type="programlisting">
double sum(double x, double y, double z)
{
	return x + y + z;
}</pre>
</div>

<p>Now, if we put in our `main()` function the following,</p>

<div data-type="example">
<pre data-type="programlisting">
sum(5.31, 92.26);
sum(4.19, 41.9, 419.0);</pre>
</div>

<p>the respective overloaded functions will be called.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Operator Overloading"><div class="sect2" id="operator_overloading">
<h2><span>Operator Overloading</span></h2>

<p>C++ provides the standard mathematical operators for integer and floating type numerical values. The Standard Library also provides the `+` operator for `std::string` types, which will concatenate them. However, there are no operators provided for `std::vector`, for example. So, if we want to compute an element-by-element sum of two vectors, or calculate a dot product, we’re on our own.</p>

<p>We could just use the `sum` overload for two vectors as shown above for vector addition, and write a new function called `dot_product` for vector multiplication. However, C++ provides us with a more naturally mathematical approach, namely <em>operator </em><em>overloading</em>.</p>

<p>For a vector sum, the addition operator replaces the `sum` overload as shown below. The body of the function remains the same:</p>

<div data-type="example">
<pre data-type="programlisting">
std::vector&lt;double&gt; operator + (const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y)
{
	std::vector&lt;double&gt; add_vec;
	if (x.size() == y.size())
	{
		for (unsigned i = 0; i &lt; x.size(); ++i)
		{
			add_vec.push_back(x.at(i) + y.at(i));
		}
	}
	return add_vec;		// Empty vector if x &amp; y sizes not identical
}</pre>
</div>

<p>Similarly, for the dot product, which returns a scalar (`double`), overload the `*` operator:</p>

<div data-type="example">
<pre data-type="programlisting">
double operator * (const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y)
{
	double dot_prod = 0.0;
	if (x.size() == y.size())
	{
		for (int i = 0; i &lt; x.size(); ++i)
		{
			dot_prod += (x[i] * y[i]);
		}
	}
	return dot_prod;	// Return 0.0 if size of x and y do not match		
}</pre>
</div>

<p>Then, for two vectors `x` and `y`, say</p>

<div data-type="example">
<pre data-type="programlisting">
std::vector&lt;double&gt; x = {1.1, 2.2, 3.3};
std::vector&lt;double&gt; y = {0.1, 0.2, 0.3};</pre>
</div>

<p>the overloaded operators would perform vector addition and multiplication:</p>

<div data-type="example">
<pre data-type="programlisting">
auto v_sum = x + y;		// ans: {1.2, 2.4, 3.6}
auto v_dot = x * y;		// ans: 1.54</pre>
</div>

<p>For `double` types, the compiler knows to apply the language-provided operators</p>

<div data-type="example">
<pre data-type="programlisting">
double s = 1.1 + 0.1;	// s = 1.2
double p = 2.2 * 0.2;	// p = 0.44</pre>
</div>

<div data-type="note" epub:type="note"><h6>Note</h6>
<ol>
	<li>
	<p>For simultaneous iteration over two `vector` objects, at this stage we need to revert to an indexed `for` loop. There are more elegant ways to do this that avoid the index but require additional background that will be presented in Chapter 7.</p>
	</li>
	<li>
	<p>For the error condition where `x.size() != y.size()`, for now we are simply returning an empty vector for the vector sum, and 0 for the dot product. Exceptions would be more appropriate for production code.</p>
	</li>
</ol>
</div>

<p>As for other examples, if we were to write a `Matrix` class, we would also want to overload operators `+`, `-`, and `*`. For a `Date` class, we could define `-` to return the number of days between two dates. Operator overloading is thus very convenient for mathematical and financial programming. We will utilize it in various contexts going forward.</p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Summary "><div class="sect1" id="summary_ideGZGdU">
<h1><span>Summary </span></h1>

<p>This chapter has covered a fairly lengthy list of topics, starting with the `std::vector` container class in the Standard Template Library (STL). `std::vector` is ubiquitous in quantitative programming, for (good) reasons that will be covered in Chapter 7, along with STL iterators and algorithms that can make C++ code more elegant, reliable, and efficient. At this point, however, the goal is to be familiar with `std::vector` as a dynamic array of real numbers.</p>

<p>Aliases come in three different varieties: type aliases (`using`), references, and pointers. `using` saves us from having to type out long type names, such as `RealVector` in place of the oft-used `std::vector&lt;double&gt;`. References in C++ are mostly used in passing `const` reference objects as function arguments, avoiding object copying that can degrade performance, while preventing the object from being modified inside the function. Pointers have several important applications beyond being mere aliases that will be presented in due course, along with smart pointers that were added to the Standard Library beginning with C++11.</p>

<p>Function overloading is a natural fit for mathematical programming, and operator overloading even more so for objects such as matrices and vectors that are ubiquitous in quantitative programming. This is another topic that will be extended in object-oriented programming in Chapter 4.</p>

<section data-type="sect2" data-pdf-bookmark="References"><div class="sect2" id="references2">
<h2><span>References</span></h2>

<p>[1] CppReference: `https://en.cppreference.com/w/cpp/language/operator_precedence]`</p>

<p>[2] Stroustrup 4E (not directly referenced)</p>
</div></section>
</div></section>
</div></section></div></body></html>