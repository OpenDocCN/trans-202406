- en: Chapter 12\. Working with HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 1995 Netscape tasked software developer Brendan Eich with creating a programming
    language designed to add interactivity to pages in the Netscape Navigator browser.
    In response, Eich infamously developed the first version of JavaScript in 10 days.
    A few years later, JavaScript became a cross-browser standard through the adoption
    of the ECMAScript standardization.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the early attempt at standardization, web developers battled for years
    with browsers that had different JavaScript engine interpretations or features.
    Popular libraries, such as jQuery, effectively allowed us to write simple cross-browser
    JavaScript. Thankfully, today’s browsers share a near uniform implementation of
    the language, allowing web developers to write “vanilla” (library-free) JavaScript
    to interact with an HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: When working with HTML, we are working with the Document Object Model (DOM),
    which is the data representation of the HTML page. The recipes in this chapter
    will review how to interact with the DOM of an HTML page by selecting, updating,
    and removing elements from the page.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a Given Element and Finding Its Parent and Child Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access a specific web page element, and then find its parent and
    child elements.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Give the element a unique identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `document.getElementById()` to get a reference to the specific element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Find its parent via the `parentNode` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Find its children via the `childNodes` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web document is organized like an upside-down tree, with the topmost element
    at the root and all other elements branching out beneath. Except for the root
    element (HTML), each element has a parent `node`, and all of the elements are
    accessible via the `document`.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different techniques available for accessing these document
    elements, or *nodes* as they’re called in the DOM. Today, we access these nodes
    through standardized versions of the DOM, such as DOM Levels 2 and 3\. Originally,
    though, a de facto technique was to access the elements through the browser object
    model, sometimes referred to as DOM Level 0\. DOM Level 0 was invented by the
    leading browser company of the time, Netscape, and its use has been supported
    (more or less) in most browsers since. The key object for accessing web page elements
    in the DOM Level 0 is the `document` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most commonly used DOM method is `document.getElementById()`. It takes
    one parameter: a case-sensitive string with the element’s identifier. It returns
    an `element` object, which is referenced to the element if it exists; otherwise,
    it returns null.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are numerous ways to get one specific web page element, including the
    use of selectors, covered later in the chapter. But you’ll always want to use
    the most restrictive method possible, and you can’t get more restrictive than
    `document.getElementById()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned `element` object has a set of methods and properties, including
    several inherited from the `node` object. The `node` methods are primarily associated
    with traversing the document tree. For instance, to find the parent node for the
    element, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find out the type of element for each node through the `nodeName` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to find out what children an element has, you can traverse a collection
    of them via a `NodeList`, obtained using the `childNodes` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the element in the solution, the output would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be surprised by what appeared as a child node. In this example, whitespace
    before and after the paragraph element is itself a child node with a `nodeName`
    of `#text`. For the following `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'the `demodiv` element (node) has five children, not two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The best way to see how messy the DOM can be is to use a debugger such as the
    Firefox or Chrome developer tools, access a web page, and then utilize whatever
    DOM inspection tool the debugger provides. I opened a simple page in Chrome and
    used the developer tools to display the element tree, as shown in [Figure 12-1](#chrome_display_page).
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 1201](assets/jsc3_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Examining the element tree of a web page using Chrome’s Developer
    Tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Traversing the Results from querySelectorAll() with forEach()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to loop over the `nodeList` returned from a call to `querySelectorAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In modern browsers, you can use `forEach()` when working with a `NodeList`
    (the collection returned by `querySelectorAll()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`forEach()` is an array method, but `querySelectorAll()` produces a `NodeList`
    which is a different type of object than an array. Thankfully, modern browsers
    have built-in support for `forEach`, allowing us to iterate over a `NodeList`
    as though it is an array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, Internet Explorer (IE) does not support using `forEach` in this
    way. If you’d like to support IE, the recommended approach is to include a polyfill
    that uses a standard `for` loop under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the polyfill, we check for the existence of `NodeList.prototype.forEach`.
    If it does not exist, a `forEach` method is added to the `NodeList` prototype
    that uses a `for` loop to iterate over the results of a DOM query. By doing so,
    you can use the `forEach` syntax freely across your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Click Functionality to an Element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to add JavaScript functionality when a user clicks a button, link,
    or element on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a `click` event listener for the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `addEventListener()` method allows our JavaScript to listen for a specific
    type of event and define a function that will be called when the event is triggered.
    In the previous example, I have added a `click` listener to a button element.
    When the button is clicked, the `clickHandler` function will be called, which
    fires an alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, you should use a `button` element for clickable event handlers,
    as it is the most accessible solution for handling click events. The `button`
    element can be styled to appear as a link if necessary for the application’s design.
    However, it is appropriate to use an element when the fallback behavior of linking
    to a page, should the JavaScript fail to load, is the desired behavior. When doing
    so, the `preventDefault` event method allows you to override the default link
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In traditional JavaScript functions, the `this` keyword would be bound to the
    item being clicked. However, when using JavaScript’s newer arrow function syntax,
    such as in this example, the value of `this` is inherited from the parent function,
    which by default is `window`. This can be confusing if you are accustomed to nonarrow
    syntax functions. If you are interested in reading more, I recommend [Joe Cardillo’s
    article on the topic](https://oreil.ly/wK7Ik).
  prefs: []
  type: TYPE_NORMAL
- en: 'On rare instances, it may be desirable to make a block element, such as a `div`
    clickable. I’d recommend doing so sparingly, in favor of the `button` element
    whenever possible. However, for these occasions, you will need to ensure that
    the functionality is accessible for those using screen readers and keyboard navigation.
    First, in your markup apply a `role` of `button` and a `tabindex` value. The `role`
    property will inform screen reader users that this is a clickable element, while
    the `tabindex` will make the element keyboard navigable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, we use a `keydown` event handler. This will allow keyboard
    users to interact with the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finding All Elements That Share an Attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find all elements in a web document that share the same attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *universal selector* (`*`) in combination with the attribute selector
    to find all elements that have an attribute, regardless of its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The universal selector can also be used to find all elements with an attribute
    that’s assigned the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution demonstrates a rather elegant query selector, the *universal selector*
    (`*`). The universal selector evaluates all elements, so it’s the one you want
    to use when you need to verify *something* about each element. In the solution,
    we want to find all of the elements with a given attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether an attribute exists, all you need to do is list the attribute
    name within square brackets (*`[attrname]`*). In the solution, we’re first testing
    whether the element contains the `class` attribute. If it does, it’s returned
    with the element collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’re getting all elements with a `class` attribute value of `red`. If
    you’re not sure of the class name, you can use the substring-matching query selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now any class name that contains the substring `red` matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also modify the syntax to find all elements that don’t have a certain
    value. For instance, to find all `div` elements that don’t have the target class
    name, use the `:not` negation operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Accessing All Elements of a Specific Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access all `img` elements in a given document.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `document.getElementsByTagName()` method, passing in `img` as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `document.getElementsByTagName()` method returns a collection of nodes
    (a `NodeList`) of a given element type, such as the `img` tag in the solution.
    The collection can be traversed like an array, and the order of nodes is based
    on the order of the elements within the document (the first `img` element in the
    page is accessible at index 0, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed in [“Traversing the Results from querySelectorAll() with forEach()”](#traversing_results_queryselect),
    a `NodeList` collection can be traversed like an array, but it isn’t an `Array`
    object. You can’t use `Array` object methods, such as `push()` and `reverse()`,
    with a `NodeList`. Its only property is `length`, and its only method is `item()`,
    returning the element at the position given by an index passed in as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`NodeList` is an intriguing object because it’s a live collection, which means
    changes made to the document after the `NodeList` is retrieved are reflected in
    the collection. [Example 12-1](#demonstrating_getelementsbytagnamecomma) demonstrates
    the `NodeList` live collection functionality, as well as `getElementsByTagName`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, three images in the web page are accessed as a `NodeList` collection
    using the `getElementsByTagName` method. The `length` property, with a value of
    `3`, is output to the console. Immediately after, a new paragraph and `img` elements
    are created, and the `img` is appended to the paragraph. To append the paragraph
    following the others in the page, `getElementsByTagName` is used again, this time
    with the paragraph tags (`p`). We’re not really interested in the paragraphs,
    but in the paragraphs’ parent elements, found via the `parentNode` property on
    each paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: The new paragraph element is appended to the paragraph’s parent element, and
    the previously accessed `NodeList` collection’s length property is again printed
    out. Now, the value is `4`, reflecting the addition of the new `img` element.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. Demonstrating `getElementsByTagName` and the `NodeList` live
    collection property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12-1](#demonstrating_getelementsbytagnamecomma) will log the following
    output to the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to using `getElementsByTagName()` with a specific element type,
    you can also pass the universal selector (`*`) as a parameter to the method to
    get all elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the code demonstrated in the discussion, the children nodes are traversed
    using a traditional `for` loop. In modern browsers, the `forEach()` method can
    be used directly with a `NodeList`, as demonstrated in [“Traversing the Results
    from querySelectorAll() with forEach()”](#traversing_results_queryselect).
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Child Elements Using the Selectors API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get a list of all instances of a child element, such as `img` elements,
    that are descendants of a parent element, such as `article` elements, without
    having to traverse an entire collection of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the Selectors API and access the `img` elements contained within `article`
    elements using CSS-style selector strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two selector query API methods. The first, `querySelectorAll()`, is
    demonstrated in the solution; the second is `querySelector()`. The difference
    between the two is that `querySelectorAll()` returns all elements that match the
    selector criteria, while `querySelector()` only returns the first found result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The selector syntax is derived from CSS selector syntax, except that rather
    than style the selected elements, they’re returned to the application. In the
    example, all `img` elements that are descendants of `article` elements are returned.
    To access all `img` elements regardless of parent element, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the solution, you’ll get all `img` elements that are direct or indirect
    descendants of an `article` element. This means that if the `img` element is contained
    within a `div` that’s within an `article`, the `img` element will be among those
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want only those `img` elements that are direct children of an `article`
    element, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re interested in accessing all `img` elements that are immediately followed
    by a paragraph, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re interested in an `img` element that has an empty `alt` attribute,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re only interested in `img` elements that don’t have an empty `alt`
    attribute, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The negation pseudoselector (`:not`) is used to find all `img` elements with
    `alt` attributes that are not empty.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the collection returned with `getElementsByTagName()` covered earlier,
    the collection of elements returned from `querySelectorAll()` is *not* a “live”
    collection. Updates to the page are not reflected in the collection if the updates
    occur after the collection is retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Though the Selectors API is a wonderful creation, it shouldn’t be used for every
    document query. To keep your applications performant, I recommend always using
    the most restrictive query possible when accessing elements. For example, it’s
    more efficient (meaning faster for the browser) to use `getElementById()` to get
    a specific element given an identifier than using `querySelectorAll()` for the
    same element.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three different CSS selector specifications, labeled as Selectors
    Level 1, Level 2, and Level 3\. [CSS Selectors Level 3](https://oreil.ly/rGfxD)
    contains links to the documents defining the other levels. These documents provide
    the definitions of, and examples for, the different types of selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Changing an Element’s Class Value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to update the CSS rules applied to an element by changing its class
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `classList` property of an element to add, remove, and toggle class
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `classList` allows you to easily manipulate the class properties of a
    selected element. This can come in handy for updating or swapping styles without
    using inline CSS. At times, it may be helpful to check if an element already has
    a class value applied, which can be accomplished with the `contains` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to add, remove, or toggle multiple classes, either by passing
    them each as individual properties or using a spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Setting an Element’s Style Attribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to directly add or replace an inline style on a specific element.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To change one CSS property as an inline style, modify the property value via
    the element’s `style` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify one or more CSS properties for a single element, you can use `setAttribute()`
    and create an entire CSS style rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These techniques set an inline style value for the HTML element, which will
    appear within the HTML itself. To demonstrate further, the following JavaScript
    sets a style attribute on an element with an ID of `card`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting HTML output includes the inline style value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An element’s CSS properties can be modified in JavaScript using one of three
    approaches. As the solution demonstrates, the simplest approach is to set the
    property’s value directly using the element’s `style` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If the CSS property contains a hyphen, such as `font-family` or `background-color`,
    use the *CamelCase notation* for the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The CamelCase notation removes the dash and capitalizes the first letter following
    the dash.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `setAttribute()` or `cssText` to set the `style` property.
    This is useful when adding multiple styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `setAttribute()` method is a way of adding an attribute or replacing the
    value of an existing attribute for a web page element. The first argument to the
    method is the attribute name (automatically lowercased if the element is an HTML
    element) and the new attribute value.
  prefs: []
  type: TYPE_NORMAL
- en: When setting the `style` attribute, all CSS properties that are changed must
    be specified at the same time, as setting the attribute erases any previously
    set values. However, setting the `style` attribute using `setAttribute()` does
    not erase any settings made in a stylesheet, or set by default by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Accessing an Existing Style Setting'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the most part, accessing existing attribute values is as easy as setting
    them. Instead of using `setAttribute()`, use `getAttribute()`. For example, to
    get the value of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting access to a style setting, though, is much trickier, because a specific
    element’s style settings at any one time is a composite of all settings merged
    into a whole. This *computed style* for an element is what you’re most likely
    interested in when you want to see specific style settings for the element at
    any point in time. Happily, there is a method for that, `window.getComputedStyle()`,
    which will return the current computed styles applied to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Advanced
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than using `setAttribute()` to add or modify the attribute, you can
    create an attribute and attach it to the element using `createAttribute()` to
    create an `Attr` node, set its value using the `nodeValue` property, and then
    use `setAttribute()` to add the attribute to the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can add any number of attributes to an element using either `createAttribute()`
    and `setAttribute()`, or `setAttribute()` directly. Both approaches are equally
    efficient, so unless there’s a real need, you’ll most likely want to use the simpler
    approach of setting the attribute name and value directly using `setAttribute()`.
  prefs: []
  type: TYPE_NORMAL
- en: When would you use `createAttribute()`? If the attribute value is going to be
    another entity reference, as is allowed with XML, you’ll need to use `createAttribute()`
    to create an `Attr` node, as `setAttribute()` only supports simple strings.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Text to a New Paragraph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a new paragraph with text and insert it into the document.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `createTextNode` method to add text to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The text within an element is, itself, an object within the DOM. Its type is
    a `Text` node, and it is created using a specialized method, `createTextNode()`.
    The method takes one parameter: the string containing the text.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 12-2](#demonstrating_various_methods_for_adding) shows a web page
    with a `div` element containing four paragraphs. The JavaScript creates a new
    paragraph from text provided by the user via a prompt. The text could just as
    easily have come from a server communication or other process.'
  prefs: []
  type: TYPE_NORMAL
- en: The provided text is used to create a text node, which is then appended as a
    child node to the new paragraph. The `paragraph` element is inserted in the web
    page before the first paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-2\. Demonstrating various methods for adding content to a web page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inserting user-supplied text directly into a web page without scrubbing the
    text first is not a good idea. When you leave a door open, all sorts of nasty
    things can crawl in. [Example 12-2](#demonstrating_various_methods_for_adding)
    is for demonstration purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a New Element in a Specific DOM Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to insert a new paragraph just before the third paragraph within a
    `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use some method to access the third paragraph, such as `getElementsByTagName()`,
    to get all of the paragraphs for a `div` element. Then use the `createElement()`
    and `insertBefore()` DOM methods to add the new paragraph just before the existing
    third paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `document.createElement()` method creates any HTML element, which then can
    be inserted or appended into the page. In the solution, the new paragraph element
    is inserted before an existing paragraph using `insertBefore()`.
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re interested in inserting the new paragraph before the existing
    third paragraph, we need to retrieve a collection of the `div` element’s paragraphs,
    check to make sure a third paragraph exists, and then use `insertBefore()` to
    insert the new paragraph before the existing one. If the third paragraph doesn’t
    exist, we can append the element to the end of the `div` element using `appendChild()`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking If a Checkbox Is Checked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to verify that a user has checked a checkbox in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Select the checkbox element and validate the status with the `checked` property.
    In this example, I am selecting an HTML `input` checkbox element with an `id`
    of `check` and listening for a click event. When the event is fired, the `validate`
    function is run, which looks at the `checked` property of the element and logs
    its status to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common pattern is for a user to be presented with a checkbox to make some
    sort of acknowledgement, such as accepting terms of service. In these instances,
    it is common to disable a button unless the user has checked the checkbox. We
    can modify the previous example to add this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Adding Up Values in an HTML Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sum all numbers in a table column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traverse the table column containing numeric string values, convert the values
    to numbers, and sum the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `:nth-of-type(n)` selector matches the specific child (`n`) of an element.
    By using `td:nth-of-type(2)` we are selecting the second `td` child element. In
    the example HTML markup, the second `td` element in the table is a numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `parseInt()` and `parseFloat()` methods convert strings to numbers, but
    `parseFloat()` is more adaptable when it comes to handling numbers in an HTML
    table. Unless you’re absolutely certain all of the numbers will be integers, `parseFloat()`
    can work with both integers and floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 12-3](#converting_table_values_to_numbers_and_s) demonstrates how
    to convert and sum up numeric values in an HTML table, and then how to insert
    a table row with this sum, at the end. The code uses `document.querySelectorAll()`,
    which uses a different variation on the CSS selector, `td + td`, to access the
    data this time. This selector finds all table cells that are preceded by another
    table cell.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-3\. Converting table values to numbers and summing the results
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Being able to provide a sum or other operation on table data is helpful if you’re
    working with dynamic updates, such as accessing rows of data from a database.
    The fetched data may not be able to provide summary values, or you may not want
    to provide summary data until a web page reader chooses to do so. The users may
    want to manipulate the table results, and then push a button to perform the summing
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding rows to a table is straightforward, as long as you remember the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new table row using `document.createElement("tr")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create each table row cell using `document.createElement("td")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create each table row cell’s data using `document.createTextNode()`, passing
    in the text of the node (including numbers, which are automatically converted
    to a string).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the text node to the table cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the table cell to the table row.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the table row to the table. Rinse, repeat.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extra: forEach and querySelectorAll'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, I’m using the `forEach()` method to iterate over
    the results of `querySelectorAll()`, which returns a `NodeList`, not an array.
    Though `forEach()` is an array method, modern browsers have implemented `NodeList.prototype.for​E⁠ach()`,
    which enables it iterating over a `NodeList` with the `forEach()` syntax, as discussed
    in [“Traversing the Results from querySelectorAll() with forEach()”](#traversing_results_queryselect).
    The alternative would be a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Extra: Modularization of Globals'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As part of a growing effort to *modularize* JavaScript, the `parseFloat()`
    and `parseInt()` methods are now attached to the `Number` object, as new *static*
    methods, as of ECMAScript 2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'These modules have reached widespread browser adoption, but can be polyfilled
    for older browser support, using a tool like Babel or on their own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Deleting Rows from an HTML Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to remove one or more rows from an HTML table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `removeChild()` method on an HTML table row, and all of the child elements,
    including the row cells, are also removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you remove an element from the web document, you’re not only removing the
    element, you’re removing all of its child elements. In this *DOM pruning* you
    get a reference to the removed element if you want to process its contents before
    it’s completely discarded. The latter is helpful if you want to provide some kind
    of *undo* method in case you accidentally select the wrong table row.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the nature of DOM pruning, in [Example 12-4](#adding_and_removing_table_rows_and_assoc),
    DOM methods `createElement()` and `createTextNode()` are used to create table
    rows and cells, as well as the text inserted into the cells. As each table row
    is created, an event handler is attached to the row’s *click* event. If any of
    the new table rows is clicked, a function is called that removes the row from
    the table. The removed table row element is then traversed, and the data in its
    cells is extracted and concatenated to a string, which is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-4\. Adding and removing table rows and associated table cells and
    data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Hiding Page Sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to hide an existing page element and its children until needed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set the CSS `visibility` property to hide and show the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the CSS `display` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the CSS `visibility` and `display` properties can be used to hide and show
    elements. There is one major difference between the two that impacts which one
    you’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: The `visibility` property controls the element’s visual rendering, but its presence
    also affects other elements. When an element is hidden, it still takes up page
    space. The `display` property, on the other hand, removes the element completely
    from the page layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `display` property can be set to several different values, but four are
    of particular interest to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none`'
  prefs: []
  type: TYPE_NORMAL
- en: When display is set to `none`, the element is removed completely from display.
  prefs: []
  type: TYPE_NORMAL
- en: '`block`'
  prefs: []
  type: TYPE_NORMAL
- en: When display is set to `block`, the element is treated like a `block` element,
    with a line break before and after.
  prefs: []
  type: TYPE_NORMAL
- en: '`inline-block`'
  prefs: []
  type: TYPE_NORMAL
- en: When display is set to `inline-block`, the contents are formatted like a `block`
    element, which is then flowed like inline content.
  prefs: []
  type: TYPE_NORMAL
- en: '`inherit`'
  prefs: []
  type: TYPE_NORMAL
- en: This is the default display, and specifies that the `display` property is inherited
    from the element’s parent.
  prefs: []
  type: TYPE_NORMAL
- en: There are other values, but these are the ones we’re most likely to use within
    JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you’re using absolute positioning with the hidden element, you’ll want
    to use the CSS `display` property. Otherwise, the element will affect the page
    layout, pushing any elements that follow down and to the right, depending on the
    type of hidden element.
  prefs: []
  type: TYPE_NORMAL
- en: There is another approach to removing an element out of page view, and that
    is to move it totally offscreen using a negative left value. This could work,
    especially if you’re creating a slider element that will slide in from the left.
    It’s also an approach that the accessibility community has suggested using when
    you have content that you want rendered by assistive technology (AT) devices,
    but not visually rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Hover-Based Pop-Up Info Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an interaction where a user mouses over a thumbnail image
    and additional information is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This interaction is based on four different functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to capture the `mouseover` and `mouseout` events for each image
    thumbnail in order to display or remove the pop-up window, respectively. In the
    following code, the cross-browser event handlers are attached to all images in
    the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, you need to access something about the item you’re hovering over in
    order to know what to use to populate the pop-up bubble. The information can be
    in the page, or you can use web server communication to get the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, you need to either show the pop-up window, if it already exists and
    is not displayed, or create the window. In the following code, the pop-up window
    is created just below the object, and just to the right when the web server call
    returns with the information about the item. The `getBoundingClientRect()` method
    is used to determine the location where the pop-up should be placed, and `createElement()`
    and `createTextNode()` are used to create the pop-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, when the `mouseover` event fires, you need to either hide the pop-up
    window or remove it—whichever makes sense in your setup. Since the application
    created a new pop-up window in the `mouseover` event, it removes the pop-up in
    the `mouseout` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a pop-up information or help window doesn’t have to be complicated
    if you keep the action simple and follow the four steps outlined in the solution.
    If the pop-up provides help for `form` elements, then you might want to cache
    the information within the page, and just show and hide pop-up elements as needed.
    However, if you have pages with hundreds of items, you’ll have better performance
    if you get the pop-up window information on demand via a web service call.
  prefs: []
  type: TYPE_NORMAL
- en: When I positioned the pop-up in the example, I didn’t place it directly over
    the object. The reason is that I’m not capturing the mouse position to have the
    pop-up follow the cursor around, ensuring that I don’t move the cursor directly
    over the pop-up. But if I statically position the pop-up partially over the object,
    the web page readers could move their mouse over the pop-up, which triggers the
    event to hide the pop-up…which then triggers the event to show the pop-up, and
    so on. This creates a flicker effect, not to mention a lot of network activity.
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, I allowed the mouse events to continue by returning `true` from
    either event handler function, when the web page readers move their mouse over
    the pop-up, the pop-up won’t go away. However, if they move the mouse from the
    image to the pop-up, and then to the rest of the page, the event to trigger the
    pop-up event removal won’t fire, and the pop-up is left on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The best approach is to place the pop-up directly under (or to the side, or
    a specific location in the page) rather than directly over the object.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Form Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your web application gathers data from the users using HTML forms. Before you
    send that data to the server, though, you want to make sure it’s well formed,
    complete, and valid while providing feedback to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the HTML5’s built-in form validation attributes, which can be extended
    with an external library for string validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a standalone library, such as [validator.js](https://github.com/validatorjs/validator.js),
    to check for validity as a user types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, we should not be writing our own forms validation routines. Not unless
    we’re dealing with some really bizarre form behavior and/or data. And by bizarre,
    I mean so far outside the ordinary that trying to incorporate a JavaScript library
    would actually be harder than doing it ourselves—a “the form field value must
    be a string except on Thursdays, when it must be a number—but reverse that in
    even months” type of validation.
  prefs: []
  type: TYPE_NORMAL
- en: You have a lot of options for libraries, and I’ve only demonstrated one. The
    *validator.js* library is a nice, simple, easy-to-use library that provides validation
    for many different types of strings. It doesn’t require that you modify the form
    fields, either, which means it’s easier to just drop it in, instead of reworking
    the form. Any and all styling and placement of error messages is developer dependent,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: In the solution, the code adds an event listener to each `input` element. When
    a user makes any change to the field, the `input` event listener is fired and
    calls the `inputValidator` function, which checks the value against the *validator.js*
    library. If the value is invalid, minimal CSS styling is used to add a red border
    to the input field. When the value is valid, no style is added.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you need a smaller library specifically for one type of data validation.
    Credit cards are tricky things, and though you can ensure a correct format, the
    values contained in them must meet specific rules in order to be considered valid
    credit card submissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the other validation libraries, you can also incorporate a credit
    card validation library, such as [Payment](https://github.com/jessepollak/payment),
    which provides a straightforward validation API. As an example, specify that a
    field is a credit card number after the form loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'And then when the form is submitted, validate the credit card number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The library doesn’t just check format; it also ensures that the value meets
    a valid card number for all of the major card companies. Depending on how you
    are processing credit cards, the payment processor may provide similar functionality
    in the client-side code. For example, the payment processor Stripe’s [Stripe.js](https://oreil.ly/GqPVh)
    includes a credit card validation API.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you can pair client and server validation, using the same library or
    different ones. In the example, we are using *validator.js* in the browser, but
    it can also be used to validate inputs on the backend in a Node application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: HTML5 Form Validation Techniques'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTML5 offers fairly extensive built-in form validation, which does not require
    JavaScript, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min` and `max`'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum and maximum values of numeric inputs
  prefs: []
  type: TYPE_NORMAL
- en: '`minlength` and `maxlength`'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum and maximum length of string inputs
  prefs: []
  type: TYPE_NORMAL
- en: '`pattern`'
  prefs: []
  type: TYPE_NORMAL
- en: A regular expression pattern that the entered input must follow
  prefs: []
  type: TYPE_NORMAL
- en: '`required`'
  prefs: []
  type: TYPE_NORMAL
- en: Required inputs must be completed before the form can be submitted
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  prefs: []
  type: TYPE_NORMAL
- en: Allows developers to specify a content type for an input, such as date, email
    address, number, password, URL, or some other specific preset type
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, CSS pseudoselectors can be used to match `:valid` and `:invalid`
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, for simple forms you may not need JavaScript at all. If you
    need finite control over the appearance and behavior of form validation, you’re
    better off using a JavaScript library than depending on the HTML5 and CSS forms
    validation specifications. If you do, though, make sure to incorporate accessibility
    features into your forms. I recommend reading [WebAIM’s “Creating Accessible Forms”](https://oreil.ly/5oL3E).
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting Form Errors and Accessibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to highlight form field entries that have incorrect data, and you want
    to ensure the highlighting is effective for all web page users.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use CSS to highlight the incorrectly entered form field, and use WAI-ARIA (Web
    Accessibility Initiative-Accessible Rich Internet Applications) markup to ensure
    the highlighting is apparent to all users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For the fields that need to be validated, assign a function to the form field’s
    `oninput` event handler that checks whether the field value is valid. If the value
    is invalid, display information to the user about the error at the same time that
    you highlight the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For the fields that need a required value, assign a function to the field’s
    `onblur` event handler that checks whether a value has been entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If any of the validation checks are performed as part of the form submission,
    make sure to cancel the submission event if the validation fails.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WAI-ARIA provides a way of marking certain fields and behaviors so that
    assistive devices do whatever is the equivalent behavior for people who need these
    devices. If a person is using a screen reader, setting the `aria-invalid` attribute
    to `true` (or adding it to the element) should trigger an audible warning in the
    screen reader—comparable to a color indicator doing the same for people who aren’t
    using assistive technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Read more on WAI-ARIA at the [Web Accessibility Initiative at the W3C](https://oreil.ly/8wGnc).
    On Windows, I recommend using [NVDA](http://www.nvaccess.org), an open source,
    freely available screen reader, for testing whether your application is responding
    as you think it should with a screen reader. For macOS, I recommend using the
    built-in VoiceOver tool with the Safari browser.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the `role` attribute can be set to several values of which one,
    “alert,” triggers a comparable behavior in screen readers (typically saying out
    the field contents).
  prefs: []
  type: TYPE_NORMAL
- en: Providing these cues are essential when you’re validating form elements. You
    can validate a form before submission and provide a text description of everything
    that’s wrong. A better approach, though, is to validate data for each field as
    the user finishes, so they’re not left with a lot of irritating error messages
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: As you validate the field, you can ensure your users know exactly which field
    has failed by using a visual indicator. It shouldn’t be the only method used to
    mark an error, but it is an extra courtesy.
  prefs: []
  type: TYPE_NORMAL
- en: If you highlight an incorrect form field entry with colors, avoid those that
    are hard to differentiate from the background. If the form background is white,
    and you use a dark yellow, gray, red, blue, green, or other color, there’s enough
    contrast that it doesn’t matter if the person viewing the page is color-blind
    or not. In the example, I used a darker pink in the form field.
  prefs: []
  type: TYPE_NORMAL
- en: I could have set the color directly, but it makes more sense to handle both
    updates—setting `aria-invalid` and changing the color—with one CSS setting. Luckily,
    CSS *attribute selectors* simplify our task in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using color, you also need to provide a text description of the
    error, so there’s no question in the user’s mind about what the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: How you display the information is also an important consideration. None of
    us really like to use alert boxes, if we can avoid them. Alert boxes can obscure
    the form, and the only way to access the form element is to dismiss the alert
    with its error message. A better approach is to embed the information in the page,
    near the form. We also want to ensure the error message is available to people
    who are using assistive technologies, such as a screen reader. This is easily
    accomplished by assigning an ARIA `alert` `role` to the element containing the
    alert for those using screen readers or other AT devices.
  prefs: []
  type: TYPE_NORMAL
- en: One final bonus to using `aria-invalid` is it can be used to discover all incorrect
    fields when the form is submitted. Just search on all elements where the attribute
    is present and if any are discovered, you know there’s still an invalid form field
    value that needs correcting.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 12-5](#providing_visual_and_other_cues_when_val) demonstrates how
    to highlight an invalid entry on one of the form elements, and highlight missing
    data in another. The example also traps the form submit, and checks whether any
    invalid form field flags are still set. Only if everything is clear is the form
    submission allowed to proceed.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-5\. Providing visual and other cues when validating form fields
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If either of the validated fields is incorrect in the application, the `aria-invalid`
    attribute is set to `true` in the field, and an ARIA `role` is set to `alert`
    on the error message, as shown in [Figure 12-2](#highlighting_an_incorrect_form_field).
    When the error is corrected, the `aria-invalid` attribute is removed, as is the
    alert message. Both have the effect of changing the background color for the form
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 1202](assets/jsc3_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Highlighting an incorrect form field
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice in the code that the element wrapping the targeted form field is set
    to its correct state when the data entered is correct, so that when a field is
    corrected it doesn’t show up as inaccurate or missing on the next go-round. I
    remove the existing message alert regardless of the previous event, as it’s no
    longer valid with the new event.
  prefs: []
  type: TYPE_NORMAL
- en: You can also disable or even hide the correctly entered form elements as a way
    to accentuate those with incorrect or missing data. However, I don’t recommend
    this approach. Your users may find as they fill in the missing information that
    their answers in other fields are incorrect. If you make it difficult for them
    to correct the fields, they’re not going to be happy with the experience—or the
    company, person, or organization providing the form.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach you can take is to only do validation when the form is submitted.
    Many built-in libraries operate this way. Rather than check each field for mandatory
    or correct values as your users tab through, you only apply the validation rules
    when the form is submitted. This allows users who want to fill out the form in
    a different order to do so without getting irritating validation messages as they
    tab through.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript to highlight a form field with incorrect and missing data is
    only one part of the form submission process. You’ll also have to account for
    JavaScript being turned off, which means you have to provide the same level of
    feedback when processing the form information on the server, and providing the
    result on a separate page.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to mark if a form field is required ahead of time. Use an
    asterisk in the form field label, with a note that all form fields with an asterisk
    are required. Use the `aria-required` and attribute to ensure this information
    is communicated to those using assistive devices. I also recommend using the HTML5
    `required` attribute when using `aria-required`, which provides built-in browser
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [“Validating Form Data”](#validating_forms) I cover form validation libraries
    and modules to simplify form validation. I also touch on using the HTML5 declarative
    form validation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Accessible Automatically Updated Region
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a section of a web page that is updated periodically, such as a section
    that lists recent updates to a file, or one that reflects recent Twitter activity
    on a subject. You want to ensure that when the page updates, those using a screen
    reader are notified of the new information.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use WAI-ARIA *region* attributes on the element being updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A section of the web page that can be updated after the page is loaded, and
    without direct user intervention, calls for WAI-ARIA Live Regions. These are probably
    the simplest ARIA functionality to implement, and they provide immediate, positive
    results. And there’s no code involved, other than the JavaScript you need to create
    the page updates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: From left to right, the `role` is set to `log`, which would be used when polling
    for log updates from a file. Other options include `status`, for a status update,
    and a more general `region` value, for an undetermined purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The `aria-live` region attribute is set to `polite`, because the update isn’t
    a critical update. The `polite` setting tells the screen reader to voice the update,
    but not interrupt a current task to do so. If I had used a value of `assertive`,
    the screen reader would interrupt whatever it is doing and voice the content.
    Always use `polite`, unless the information is critical.
  prefs: []
  type: TYPE_NORMAL
- en: The `aria-atomic` is set to `false`, so that the screen reader only voices new
    additions, based on whatever is set with `aria-relevant`. It could get very annoying
    to have the screen reader voice the entire set with each new addition, as would
    happen if this value is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `aria-relevant` is set to `additions`, as we don’t care about the
    entries being removed from the top. This setting is actually the default setting
    for this attribute, so, technically, it isn’t needed. In addition, assistive technology
    devices don’t have to support this attribute. Still, I’d rather list it than not.
    Other values are `removals`, `text`, and `all` (for all events). You can specify
    more than one, separated by a space.
  prefs: []
  type: TYPE_NORMAL
- en: This WAI-ARIA–enabled functionality was probably the one that impressed me the
    most. One of my first uses for fetching remote data, years ago, was to update
    a web page with information. It was frustrating to test the page with a screen
    reader (JAWS, at the time) and hear nothing but silence every time the page was
    updated. I can’t even imagine how frustrating it was for those who needed the
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have it, and it’s so easy to use. It’s a win-win.
  prefs: []
  type: TYPE_NORMAL
