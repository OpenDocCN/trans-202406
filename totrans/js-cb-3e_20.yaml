- en: Chapter 17\. Node Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dividing line between “old” and “new” JavaScript occurred when Node.js (referred
    to primarily as just Node) was released to the world. Yes, the ability to dynamically
    modify page elements was an essential milestone, as was the emphasis on establishing
    a path forward to new versions of ECMAScript, but it was Node that really made
    us look at JavaScript in a whole new way. And it’s a way I like—I’m a big fan
    of Node and server-side JavaScript development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the basics of Node. At a minimum, you will need
    to have Node installed, as covered in [“Installing the npm Package Manager (with
    Node.js)”](ch01.html#installing_node_npm) or [“Managing Node Versions with Node
    Version Manager”](#use-nvm).
  prefs: []
  type: TYPE_NORMAL
- en: Managing Node Versions with Node Version Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to install and manage multiple versions of Node on your development
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use [Node Version Manager (NVM)](https://github.com/nvm-sh/nvm), which allows
    you to install and use any distributed version of Node on a per-shell basis. NVM
    is compatible with Linux, macOS, and Windows Subsystem for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install NVM, run the install script using either `curl` or `wget` in your
    system’s terminal application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are developing on Windows, we recommend using [`nvm-windows`](https://github.com/coreybutler/nvm-windows),
    which is unaffiliated with the NVM project, but provides similar functionality
    for the Windows operating system. For instructions on how to use `nvm-windows`,
    consult the project’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed NVM, you will need to install a version of Node. To
    install the latest version of Node, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also install a specific version of Node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve installed Node, you’ll need to set a default version for new shell
    sessions. This can either be the latest version of Node that has been installed
    or a specific version number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch the version being used in a shell session, use the `nvm use` command
    followed by a specific installed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using NVM allows you to easily download and switch between multiple versions
    of Node on your operating system. This can be incredibly useful when working with
    libraries that support multiple versions and legacy codebases. It also simplifies
    the management of Node within your development environment. You can view the [list
    of releases and support timelines](https://oreil.ly/9IY83) for each release.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using NVM, it’s possible to list out all of the versions installed on
    your machine using the `nvm ls` command. This will show all of the installed versions,
    the default version for new shell sessions, and any LTS versions that you do not
    have installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I have several redundant patch versions of major releases installed
    on my machine. To uninstall and remove a specific version, you can use the `nvm
    uninstall` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Keeping track of which version of Node a project is designed to use can be
    a challenge. To make this easier, you can add an `.nvmrc` file to your project’s
    root directory. The contents of the file is the version of Node that the project
    is designed to use. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To use the version specified in a project’s `.nvmrc` file, run `nvm use` command
    from the root of the director.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For large projects, using a container technology, such as Docker, is an incredibly
    useful way to ensure version matching across environments, including deployment.
    The Node documentation has a helpful guide on [Dockerizing a Node.js web app](https://oreil.ly/phXQZ).
  prefs: []
  type: TYPE_NORMAL
- en: Responding to a Simple Browser Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a Node application that can respond to a very basic browser
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the built-in Node HTTP server to respond to requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A web server response to a browser request is the “Hello World” application
    for Node. It demonstrates not only how a Node application functions, but how you
    can communicate with it using a fairly traditional communication method: requesting
    a web resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the top, the first line of the solution loads the `http` module
    using Node’s `require()` function. This instructs Node’s modular system to load
    a specific library resource for use in the application. The `http` module is one
    of the many that come, by default, with a Node installation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, an HTTP server is created using `http.createServer()`, passing in an anonymous
    function, known as the `RequestListener` with two parameters. Node attaches this
    function as an event handler for every server request. The two parameters are
    *request* and *response*. The request is an instance of the `http.IncomingMessage`
    object and the response is an instance of the `http.ServerResponse` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `http.ServerResponse` is used to respond to the web request. The `http.IncomingMessage`
    object contains information about the request, such as the request URL. If you
    need to get specific pieces of information from the URL (e.g., query string parameters),
    you can use the Node `url` utility module to parse the string. [Example 17-1](#parsing_url_for_data)
    demonstrates how the query string can be used to return a more custom message
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-1\. Parsing out query string data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A URL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: results in a web page that reads “Hello, Reader!”
  prefs: []
  type: TYPE_NORMAL
- en: In the code, the `url` module object has a `parse()` method that parses out
    the URL, returning various components of it (`href`, `protocol`, `host`, etc.).
    If you pass `true` as the second argument, the string is also parsed by another
    module, `querystring`, which returns the query string as an object with each parameter
    as an object property, rather than just returning a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the solution and in [Example 17-1](#parsing_url_for_data), a text message
    is returned as page output, using the `http.ServerResponse` `end()` method. I
    could also have written the message out using `write()`, and then called `end()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The important takeaway from either approach is you *must* call the response
    `end()` method after all the headers and response body have been set.
  prefs: []
  type: TYPE_NORMAL
- en: Chained to the end of the `createServer()` function call is another function
    call, this time to `listen()`, passing in the port number for the server to listen
    in on. This port number is also an especially important component of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, port 80 is the default port for most web servers (that aren’t
    using HTTPS, which has a default port of 443). By using port 80, requests for
    the web resource don’t need to specify a port when requesting the service’s URL.
    However, port 80 is also the default port used by our more traditional web server,
    Apache. If you try to run the Node service on the same port that Apache is using,
    your application will fail. The Node application either must be standalone on
    the server, or run off a different port.
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify an IP address (host) in addition to the port. Doing this
    ensures that people make the request to a specific host, as well as port. Not
    providing the host means the application will listen for the request for any IP
    address associated with the server. You can also specify a domain name, and Node
    resolves the host.
  prefs: []
  type: TYPE_NORMAL
- en: There are other arguments for the methods demonstrated, and a host of other
    methods, but this will get you started. Refer to the [Node documentation](http://nodejs.org/api)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Interactively Trying Out Node Code Snippets with REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to easily run server-based Node code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Node’s REPL (Read-Evalute-Print-Loop), an interactive command-line version
    of Node that can run any code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use REPL, type `node` at the command line without specifying an application
    to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then specify JavaScript in a simplified Emacs (sorry, no vi) line-editing
    style. You can import libraries, create functions—whatever you can do within a
    static application. The main difference is that each line of code is interpreted
    instantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re finished, exit the program with `.exit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REPL can be started standalone or within another application if you want to
    set certain features. You type in the JavaScript as if you’re typing in the script
    in a text file. The main behavioral difference is you might see a result after
    typing in each line, such as the `undefined` that shows up in the runtime REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can import modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And you can access the global objects, which we just did when we used `require()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `undefined` that shows after typing in some code is the return value for
    the execution of the previous line of code. Setting a new variable and creating
    a function are some of the JavaScript that return `undefined`, which can get quickly
    annoying. To eliminate this behavior, as well as make some other modifications,
    you can use the `REPL.start()` function within a small Node application that triggers
    REPL (but with the options you specify).
  prefs: []
  type: TYPE_NORMAL
- en: 'The options you can use are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prompt`'
  prefs: []
  type: TYPE_NORMAL
- en: Changes the prompt that shows (default is *>*)
  prefs: []
  type: TYPE_NORMAL
- en: '`input`'
  prefs: []
  type: TYPE_NORMAL
- en: Changes the input readable stream (default is `process.stdin`, which is the
    standard input)
  prefs: []
  type: TYPE_NORMAL
- en: '`output`'
  prefs: []
  type: TYPE_NORMAL
- en: Changes the output writable stream (default is `process.stdout`, the standard
    output)
  prefs: []
  type: TYPE_NORMAL
- en: '`terminal`'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `true` if the stream should be treated like a TTY, and have ANSI/VT100
    escape codes written
  prefs: []
  type: TYPE_NORMAL
- en: '`eval`'
  prefs: []
  type: TYPE_NORMAL
- en: Function used to replace the asynchronous `eval()` function used to evaluate
    the JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: '`useColors`'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `true` to set output colors for the `writer` function (default is based
    on the terminal’s default values)
  prefs: []
  type: TYPE_NORMAL
- en: '`useGlobal`'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `true` to use the `global` object, rather than running scripts in a separate
    context
  prefs: []
  type: TYPE_NORMAL
- en: '`ignoreUndefined`'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `true` to eliminate the `undefined` return values
  prefs: []
  type: TYPE_NORMAL
- en: '`writer`'
  prefs: []
  type: TYPE_NORMAL
- en: The function that returns the formatted result from the evaluated code to the
    display (default is the `util.inspect` function)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example application that starts REPL with a new prompt,
    ignoring the undefined values, and using colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The options we want are defined in the `options` object and then passed as
    parameters to `repl.start()`. When we run the application, REPL is started but
    we no longer have to deal with undefined values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a cleaner output without all those messy `undefined`
    printouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Wait a Second, What Global Object?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caught that, did you?
  prefs: []
  type: TYPE_NORMAL
- en: 'One difference between JavaScript in Node and JavaScript in the browser is
    the global scoping. Traditionally in a browser, when you create a variable outside
    a function, using `var`, it belongs to the top-level global object, which we know
    as `window`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, when using `let` or `const` in the browser, the variables are globally
    scoped, though not attached to the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: In Node, each module operates within its own separate context, so modules can
    declare the same variables, and they won’t conflict if they’re all used in the
    same application.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are objects accessible from Node’s `global` object. We’ve used
    a few in previous examples, including `console`, the Buffer object, and `require()`.
    Others include some very familiar old friends: `setTimeout()`, `clearTimeout()`,
    `setInterval()`, and `clearInterval()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Writing File Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to read from or write to a locally stored file.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node’s filesystem management functionality is included as part of the Node
    core, via the `fs` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To read a file’s contents, use the `readFile()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To write to a file, use `writeFile()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeFile()` function overwrites the existing file. To append text to
    the file, use `appendText()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node’s filesystem support is both comprehensive and simple to use. To read
    from a file, use the `readFile()` function, which supports the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The filename, including the operating system path to the file if it isn’t local
    to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An options object, with options for `encoding`, as demonstrated in the solution,
    and `flag`, which is set to `r` by default (for reading)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback function with parameters for an error and the read data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the solution, if I didn’t specify the encoding in my application, Node would
    have returned the file contents as a raw buffer. Since I did specify the encoding,
    the file content is returned as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `writeFile()` and `appendFile()` functions for writing and appending, respectively,
    take parameters similar to `readFile()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The filename and path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string or buffer for the data to write to the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The options object, with options for `encoding` (`w` as default for `writeFile()`
    and `a` as the default for `appendFile()`) and `mode`, with a default value of
    `438` (`0666` in Octal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The callback function, with only one parameter: the error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The options value of `mode` can be used to set the file’s permissions if the
    file was created by write or append. By default, the file is created as readable
    and writable by the owner, and readable by the group and the world.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned that the data to write can be either a buffer or a string. A string
    cannot handle binary data, so Node provides the buffer, which is capable of dealing
    with either strings or binary data. Both can be used in all of the filesystem
    functions discussed in this section, but you’ll need to explicitly convert between
    the two types if you want to use them both.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of providing the *utf8* `encoding` option when you use
    `writeFile()`, you convert the string to a buffer, providing the desired encoding
    when you do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The reverse—that is, to convert the buffer to a string—is just as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The buffer `toString()` function has three optional parameters: encoding, where
    to begin the conversion, and where to end it. By default, the entire buffer is
    converted using the *utf8* encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readFile()`, `writeFile()`, and `appendFile()` functions are *asynchronous*,
    meaning they won’t wait for the operation to finish before proceeding in the code.
    This is essential when it comes to notoriously slow operations such as file access.
    There are synchronous versions of each: `readFileSync()`, `writeFileSync()`, and
    `appendFileSync()`. I can’t stress enough that you should *not* use these variations.
    I only include a reference to them to be comprehensive.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to read or write from a file is to use the `open()` function in
    combination with `read()` for reading the file contents, or `write()` for writing
    to the file. The advantages to this approach is more finite control of what happens
    during the process. The disadvantage is the added complexity associated with all
    of the functions, including only being able to use a buffer for reading from and
    writing to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters for `open()` are:'
  prefs: []
  type: TYPE_NORMAL
- en: Filename and path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same `open()` is used with all operations, with the *flag* controlling
    what happens. There are quite a few flag options, but the ones that interest us
    the most at this time are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for reading; the file must exist
  prefs: []
  type: TYPE_NORMAL
- en: '`r`+'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for reading and writing; an exception occurs if the file doesn’t
    exist
  prefs: []
  type: TYPE_NORMAL
- en: '`w`'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for writing, truncates the file, or creates it if it doesn’t
    exist
  prefs: []
  type: TYPE_NORMAL
- en: '`wx`'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for writing, but fails if the file *does* exist
  prefs: []
  type: TYPE_NORMAL
- en: '`w`+'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for reading and writing; creates the file if it doesn’t exist;
    truncates the file if it exists
  prefs: []
  type: TYPE_NORMAL
- en: '`wx+`'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `w+`, but fails if the file exists
  prefs: []
  type: TYPE_NORMAL
- en: '`a`'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for appending, creates it if it doesn’t exist
  prefs: []
  type: TYPE_NORMAL
- en: '`ax`'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for appending, fails if the file exists
  prefs: []
  type: TYPE_NORMAL
- en: '`a`+'
  prefs: []
  type: TYPE_NORMAL
- en: Opens the file for reading and appending; creates the file if it doesn’t exist
  prefs: []
  type: TYPE_NORMAL
- en: '`ax+`'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `a+`, but fails if the file exists
  prefs: []
  type: TYPE_NORMAL
- en: 'The mode is the same one mentioned earlier, a value that sets the *sticky*
    and *permission* bits on the file if created, and defaults to `0666`. The callback
    function has two parameters: an error object, if an error occurs, and a *file
    descriptor*, used by subsequent file operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `read()` and `write()` functions share the same basic types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `open()` methods callback file descriptor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buffer used to either hold data to be written or appended, or read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The offset where the input/output (I/O) operation begins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buffer length (set by read operation, controls write operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Position in the file where the operation is to take place; *null* if the position
    is the current position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The callback functions for both methods have three arguments: an error, bytes
    read (or written), and the buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: That’s a lot of parameters and options. The best way to demonstrate how it all
    works is to create a complete Node application that opens a brand new file for
    writing, writes some text to it, writes some more text to it, and then reads all
    the text back and prints it to the `console`. Since `open()` is asynchronous,
    the read and write operations have to occur within the callback function. Be ready
    for it in [Example 17-2](#testing_read_write), because you’re going to get your
    first taste of a concept known as *callback hell*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-2\. Demonstrating open, read, and write
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Taming callbacks is covered in [“Managing Callback Hell”](ch19.html#managing_callback_hell).
  prefs: []
  type: TYPE_NORMAL
- en: To find the length of the buffers, I used `length`, which returns the number
    of bytes for the buffer. This value doesn’t necessarily match the length of a
    string in the buffer, but it does work in this usage.
  prefs: []
  type: TYPE_NORMAL
- en: That many levels of indentation can make your skin crawl, but the example demonstrates
    how `open()`, `read()`, and `write()` work. These combinations of functions are
    what’s used within the `readFile()`, `writeFile()`, and `appendFile()` functions
    to manage file access. The higher-level functions just simplify the most common
    file operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See [“Managing Callback Hell”](ch19.html#managing_callback_hell) for a solution
    to all that nasty indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Input from the Terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get input from the application user via the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Node’s Readline module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get data from the standard input, use code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Readline module provides the ability to get lines of text from a readable
    stream. You start by creating an instance of the Readline interface with `createInterface()`
    passing in, at minimum, the readable and writable streams. You need both, because
    you’re writing prompts, as well as reading in text. In the solution, the input
    stream is `process.stdin`, the standard input stream, and the output stream is
    `process.stdout`. In other words, input and output are from, and to, the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: The solution uses the `question()` function to post a question, and provides
    a callback function to process the response. Within the function, `close()` is
    called, which closes the interface, releasing control of the input and output
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an application that continues to listen to the input, taking
    some action on the incoming data, until something signals the application to end.
    Typically that something is a letter sequence signaling the person is done, such
    as the word *exit*. This type of application makes use of other Readline functions,
    such as `setPrompt()` to change the prompt given the individual for each line
    of text; `prompt()`, which prepares the input area, including changing the prompt
    to the one set by `setPrompt()`; and `write()`, to write out a prompt. In addition,
    you’ll also need to use event handlers to process events, such as `line`, which
    listens for each new line of text.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 17-3](#continuous_loop_of_text) contains a complete Node application
    that continues to process input from the user until they type in `exit`. Note
    that the application makes use of `process.exit()`. This function cleanly terminates
    the Node application.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-3\. Access numbers from stdin until the user types in *exit*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the application with several numbers results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: I used `console.log()` rather than the Readline interface `write()` to write
    the prompt, followed by a new line, and to differentiate the output from the input.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 19](ch19.html#ch19) covers passing and reading command-line arguments
    in Node applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Path to the Current Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application needs to read the path of the script that is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `__dirname` or `__filename` variables, which are in the scope of the
    module executing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `__dirname` or `__filename` variables appear to be in the global scope,
    but they actually exist in the scope of the module itself. Let’s assume that you
    have a project with the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you were to read the `__dirname` in the index.js file, it would be the path
    to the project’s root directory. However, reading the `__dirname` in from a script
    in the *nested.js* file would read the path to the *dir3* directory. This allows
    you to read the path of a module as it’s executed, rather than being limited to
    the parent directory itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful example of `__dirname` in action is when creating a new file or directory
    within the current directory. In the following example, the script creates a new
    subdirectory named *cache* within the current file’s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Working with Node Timers and Understanding the Node Event Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to use a timer in a Node application, but you’re not sure which of
    Node’s three timers to use, or how accurate they are.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your timer doesn’t have to be precise, you can use `setTimeout()` to create
    a single timer event, or `setInterval()` if you want a reccurring timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Both function timers can be canceled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you need more finite control of your timer, and immediate results,
    you might want to use `setImmediate()`. You don’t specify a delay for it, as you
    want the callback to be invoked *immediately* after all I/O callbacks are processed
    but before any `setTimeout()` or `setInterval()` callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It, too, can be cleared, with `clearImmediate()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node, being JavaScript based, runs on a single thread. It is *synchronous*.
    However, input/output (I/O) and other native API access either runs *asynchronously*
    or on a separate thread. Node’s approach to managing this timing disconnect is
    the *event loop*.
  prefs: []
  type: TYPE_NORMAL
- en: In your code, when you perform an I/O operation, such as writing a chunk of
    text to a file, you specify a callback function to do any post-write activity.
    Once you’ve done so, the rest of your application code is processed. It doesn’t
    wait for the file write to finish. When the file write has finished, an event
    signaling the fact is returned to Node, and pushed on to a queue, waiting for
    processing. Node processes this event queue, and when it gets to the event signaled
    by the completed file write, it matches the event to the callback, and the callback
    is processed.
  prefs: []
  type: TYPE_NORMAL
- en: As a comparison, think of going into a deli and ordering lunch. You wait in
    line to place your order, and are given an order number. You sit down and read
    the paper, or check your Twitter account while you wait. In the meantime, the
    lunch orders go into another queue for deli workers to process the orders. But
    each lunch request isn’t always finished in the order received. Some lunch orders
    may take longer. They may need to bake or grill for a longer time. So the deli
    worker processes your order by preparing your lunch item and then placing it in
    an oven, setting a timer for when it’s finished, and goes on to other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: When the timer pings, the deli worker quickly finishes their current task, and
    pulls your lunch order from the oven. You’re then notified that your lunch is
    ready for pickup by your order number being called out. If several time-consuming
    lunch items are being processed at the same time, the deli worker processes them
    as the timer for each item pings, in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Node processes fit the pattern of the deli order queue: first in, first
    to be sent to the deli (thread) workers. However, certain operations, such as
    I/O, are like those lunch orders that need extra time to bake in an oven or grill,
    but don’t require the deli worker to stop any other effort and wait for the baking
    and grilling. The oven or grill timers are equivalent to the messages that appear
    in the Node event loop, triggering a final action based on the requested operation.'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a working blend of synchronous and asynchronous processes. But
    what happens with a timer?
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `setTimeout()` and `setInterval()` fire after the given delay, but what
    happens is a message to this effect is added to the event loop, to be processed
    in turn. So if the event loop is particularly cluttered, there is a delay before
    the the timer functions’ callbacks are called:'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that your callback will probably not be called in exactly
    (delay) milliseconds. Node.js makes no guarantees about the exact timing of when
    the callback will fire, nor of the ordering things will fire in. The callback
    will be called as close as possible to the time specified.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Node Timers documentation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the most part, whatever delay happens is beyond the kin of our human senses,
    but it can result in animations that don’t seem to run smoothly. It can also add
    an odd effect to other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Example 17-4](#feeding_scrolling_timeline), I created a scrolling timeline
    in SVG, with data fed to the client via WebSockets. To emulate real-world data,
    I used a three-second timer and randomly generated a number to act as a data value.
    In the server code, I used `setInterval()`, because the timer is reccurring:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-4\. Scrolling timeline example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: I included `console.log()` to call in the code so you can see the timer event
    in comparison to the communication responses. When the `setInterval()` function
    is called, it’s pushed into the process. When its callback is processed, the WebSocket
    communications are also pushed into the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The solution uses `setInterval()`, one of Node’s three different types of timers.
    The `setInterval()` function has the same format as the one we use in the browser.
    You specify a callback for the first function, provide a delay time (in milliseconds),
    and any potential arguments. The timer is going to fire in three seconds, but
    we already know that the callback for the timer may not be immediately processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to the callbacks passed in the WebSocket `sendText()` calls.
    These are based on Node’s Net (or TLS, if secure) sockets, and as the `socket.write()`
    (what’s used for `sendText()`) documentation notes:'
  prefs: []
  type: TYPE_NORMAL
- en: The optional callback parameter will be executed when the data is finally written
    out—this may not be immediately.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Node documentation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you set the timer to invoke immediately (giving zero as the delay value),
    you’ll see that the data sent message is interspersed with the communication sent
    message (before the browser client freezes up, overwhelmed by the socket communications—you
    don’t want to use a zero value in the application again).
  prefs: []
  type: TYPE_NORMAL
- en: However, the timelines for all the clients remain the same because the communications
    are sent within the timer’s callback function, *synchronously*, so the data is
    the same for all of the communications—it’s just the callbacks that are handled,
    seemingly out of order.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier I mentioned using `setInterval()` with a delay of zero. In actuality,
    it isn’t exactly zero—Node follows the HTML5 specification that browsers adhere
    to, and “clamps” the timer interval to a minimum value of four milliseconds. While
    this may seem to be too small of an amount to cause a problem, when it comes to
    animations and time-critical processes, the time delay can impact the overall
    appearance and/or function.
  prefs: []
  type: TYPE_NORMAL
- en: To bypass the constraints, Node developers utilize Node’s `process.nextTick()`
    instead. The callback associated with `process.nextTick()` is processed on the
    next event loop go around, usually before any I/O callbacks (though there are
    constraints, which I’ll get to in a minute). No more pesky four-millisecond throttling.
    But then, what happens if there’s an enormous number of recursively called `process.nextTick()`
    calls?
  prefs: []
  type: TYPE_NORMAL
- en: To return to our deli analogy, during a busy lunch hour, workers can be overrun
    with orders and so caught up in trying to process new orders that they don’t respond
    in a timely manner to the oven and grill pings. Things burn when this happens.
    If you’ve ever been to a well-run deli, you’ll notice the counter person taking
    the orders will assess the kitchen before taking the order, tossing in some slight
    delay, or even taking on some of the kitchen duties, letting the people wait just
    a tiny bit longer in the order queue.
  prefs: []
  type: TYPE_NORMAL
- en: The same happens with Node. If `process.nextTick()` were allowed to be the spoiled
    child, always getting its way, I/O operations would get starved out. Node uses
    another value, `process.maxTickDepth`, with a default value of 1000 to constrain
    the number of `process.next()` callbacks that are processed before the I/O callbacks
    are allowed to play. It’s the counter person in the deli.
  prefs: []
  type: TYPE_NORMAL
- en: In more recent releases of Node, the `setImmediate()` function was added. This
    function attempts to resolve all of the issues associated with the timing operations
    and create a happy medium that should work for most folks. When `setImmediate()`
    is called, its callback is added after the I/O callbacks, but before the `setTimeout()`
    and `setInterval()` callbacks. We don’t have the four-millisecond tax for the
    traditional timers, but we also don’t have the brat that is `process.nextTick()`.
  prefs: []
  type: TYPE_NORMAL
- en: To return one last time to the deli analogy, `setImmediate()` is a customer
    in the order queue who sees that the deli workers are overwhelmed with pinging
    ovens, and politely states they’ll wait to give their order.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: However, you do *not* want to use `setImmediate()` in the scrolling timeline
    example, as it will freeze your browser up faster than you can blink.
  prefs: []
  type: TYPE_NORMAL
