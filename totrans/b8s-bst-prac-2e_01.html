<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Setting Up a Basic Service" data-type="chapter" epub:type="chapter"><div class="chapter" id="setting_up_a_basic_service">&#13;
<h1><span class="label">Chapter 1. </span>Setting Up a Basic Service</h1>&#13;
&#13;
&#13;
<p>This chapter describes the procedure for setting up a simple multitier application in Kubernetes. The example we’ll walk through consists of two tiers: a simple web application and a database.&#13;
Though this might not be the most complicated application, it is a good place to start when learning to manage an application in Kubernetes.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Application Overview" data-type="sect1"><div class="sect1" id="id182">&#13;
<h1>Application Overview</h1>&#13;
&#13;
<p>The <a data-primary="application example" data-secondary="list of components" data-type="indexterm" id="id395"/><a data-primary="journal service example" data-see="application example" data-type="indexterm" id="id396"/>application that we will use for our example is fairly straightforward. It’s a simple&#13;
journal service with the following details:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It has a separate static file server using NGINX.</p>&#13;
</li>&#13;
<li>&#13;
<p>It has a RESTful application programming interface (API) https://some-host-name.io/api on the <em>/api</em> path.</p>&#13;
</li>&#13;
<li>&#13;
<p>It has a file server on the main URL, https://some-host-name.io.</p>&#13;
</li>&#13;
<li>&#13;
<p>It uses the <a href="https://oreil.ly/7XN3G">Let’s Encrypt service</a> for managing Secure Sockets Layer (SSL).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#figure-0101">Figure 1-1</a> presents a diagram of this application. Don’t be worried if you don’t understand all the pieces right away; they will be explained in greater detail throughout the chapter. We’ll walk through building this application step by step, first using YAML configuration files and then Helm charts.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="figure-0101">&#13;
<img alt="Application Diagram" src="assets/kbp2_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>A diagram of our journal service as it is deployed in Kubernetes</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing Configuration Files" data-type="sect1"><div class="sect1" id="id1">&#13;
<h1>Managing Configuration Files</h1>&#13;
&#13;
<p>Before<a data-primary="configuration files, managing" data-type="indexterm" id="config-file-manage"/><a data-primary="application example" data-secondary="configuration file management" data-type="indexterm" id="app-example-config-manage"/> we get into the details of how to construct this application in Kubernetes, it is worth discussing how we manage the configurations themselves. With Kubernetes, everything is<a data-primary="declarative approach" data-type="indexterm" id="id397"/> represented <em>declaratively</em>. This means that you write down the desired state of the application in the cluster (generally in YAML or JSON files), and these declared desired states define all the pieces of your application. This declarative approach is far preferable to<a data-primary="imperative approach" data-type="indexterm" id="id398"/> an <em>imperative</em> approach in which the state of your cluster is the sum of a series of changes to the cluster. If a cluster is configured imperatively, it is difficult to understand and replicate how the cluster came to be in that state, making it challenging to understand or recover from problems with your application.</p>&#13;
&#13;
<p>When declaring the state of your application, people typically prefer<a data-primary="JSON, syntax support" data-type="indexterm" id="id399"/><a data-primary="YAML, syntax support" data-type="indexterm" id="id400"/><a data-primary="indentation in YAML" data-type="indexterm" id="id401"/> YAML to JSON, though Kubernetes supports them both. This is because YAML is somewhat less verbose and more human editable than JSON. However, it’s worth noting that YAML is indentation sensitive; often errors in Kubernetes configurations can be traced to incorrect indentation in YAML. If things aren’t behaving as expected, checking your indentation is a good place to start troubleshooting.&#13;
Most editors have syntax highlighting support for both JSON and YAML. When working with these files it is a good idea to install such tools to make it easier to find both author and file errors in your configurations.&#13;
There is also an excellent extension for Visual Studio Code that supports richer error checking for Kubernetes files.</p>&#13;
&#13;
<p>Because the declarative state contained in these YAML files serves as the source of truth for your application, correct management of this state is critical to the success of your application. When modifying your application’s desired state, you will want to be able to manage changes, validate that they are correct, audit who made changes, and possibly roll things back if they fail. Fortunately, in the context of software engineering, we have already developed the tools necessary to manage both changes to the declarative state as well as audit and rollback. Namely, the best practices around both version control and code review <a data-primary="source control" data-see="version control" data-type="indexterm" id="id402"/><a data-primary="version control" data-secondary="declarative state" data-type="indexterm" id="id403"/><a data-primary="code review" data-type="indexterm" id="id404"/>directly apply to the task of managing the declarative state of your application.</p>&#13;
&#13;
<p>These days most people store their Kubernetes configurations in<a data-primary="Git" data-type="indexterm" id="id405"/> Git. Though the specific details of the version control system are unimportant, many tools in the Kubernetes ecosystem expect files in&#13;
a Git repository. For code review there is much more heterogeneity; though clearly<a data-primary="GitHub" data-type="indexterm" id="id406"/> GitHub is quite popular, others use on-premises code review tools or services. Regardless of how you implement code review for your application configuration, you should treat it with the same diligence and focus that you apply to source control.</p>&#13;
&#13;
<p>When it <a data-primary="filesystems, directory organization" data-type="indexterm" id="id407"/><a data-primary="directory organization" data-type="indexterm" id="id408"/>comes to laying out the filesystem for your application, it’s worthwhile to use the directory organization that comes with the filesystem to organize your components. Typically, a single directory is used to encompass an <em>Application Service</em>. The definition of what constitutes an Application Service can vary in size from team to team, but generally, it is a service developed by a team of 8–12 people. Within that directory, subdirectories are used for subcomponents of the application.</p>&#13;
&#13;
<p>For our application, we lay out the files as follows:</p>&#13;
&#13;
<pre data-type="programlisting">journal/&#13;
  frontend/&#13;
  redis/&#13;
  fileserver/</pre>&#13;
&#13;
<p>Within each directory are the concrete YAML files needed to define the service. As you’ll see later on, as we begin to deploy our application to multiple different regions or clusters, this file layout will become more <a data-primary="configuration files, managing" data-startref="config-file-manage" data-type="indexterm" id="id409"/><a data-primary="application example" data-secondary="configuration file management" data-startref="app-example-config-manage" data-type="indexterm" id="id410"/>complicated.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a Replicated Service Using Deployments" data-type="sect1"><div class="sect1" id="id2">&#13;
<h1>Creating a Replicated Service Using Deployments</h1>&#13;
&#13;
<p>To <a data-primary="application example" data-secondary="replicated service creation" data-type="indexterm" id="app-example-replicate-create"/><a data-primary="replicated services, creating with deployments" data-type="indexterm" id="replicate-create"/><a data-primary="deployments" data-secondary="replicated service creation" data-type="indexterm" id="deploy-replicate"/>describe our application, we’ll begin at the frontend and work downward. The frontend application for the journal is a Node.js application implemented in TypeScript. The <a href="https://oreil.ly/70kFT">complete application</a> is too large to include in the book, so we’ve hosted it on our GitHub. You’ll be able to find code for future examples there, too, so it’s worth bookmarking. The application exposes an HTTP service on port 8080 that serves requests to the <em>/api/*</em> path and uses the Redis backend to add, delete, or return the current journal entries. If you plan to work through the YAML examples that follow on your local machine, you’ll want to build this application into a container image using the Dockerfile and push it to your own image repository. Then, rather than using our example file name, you’ll want to include your container image name in your code.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Best Practices for Image Management" data-type="sect2"><div class="sect2" id="id3">&#13;
<h2>Best Practices for Image Management</h2>&#13;
&#13;
<p>Though in <a data-primary="image management" data-secondary="best practices" data-type="indexterm" id="id411"/><a data-primary="best practices" data-secondary="image management" data-type="indexterm" id="id412"/>general, building and maintaining container images is beyond the scope of this book, it’s worthwhile to identify some general best practices for building and naming images. In general, the image build process can be vulnerable to<a data-primary="supply-chain attacks" data-type="indexterm" id="id413"/> “supply-chain attacks.” In such attacks, a malicious user injects code or binaries into some dependency from a trusted source that is then built into your application. Because of the risk of such attacks, it is critical that when you build your images you base them on only well-known and trusted image providers. Alternatively, you can build all your images from scratch. Building from scratch is easy for some languages (e.g., Go) that can build static binaries, but it is significantly more complicated for interpreted languages like Python, JavaScript, or Ruby.</p>&#13;
&#13;
<p>The other best practices for images relate to naming. Though the version of a container image in an image registry is theoretically mutable, you should treat the version tag as immutable. In particular, some combination of the semantic version and the SHA hash of the commit where the image was built is a good practice for naming images (e.g., <em>v1.0.1-bfeda01f</em>). If you don’t specify an image version, <code>latest</code> is used by default. Although this can be convenient in development, it is a bad idea for production usage because <code>latest</code> is clearly being mutated every time a new image is built.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a Replicated Application" data-type="sect2"><div class="sect2" id="id4">&#13;
<h2>Creating a Replicated Application</h2>&#13;
&#13;
<p>Our frontend application<a data-primary="stateless" data-type="indexterm" id="id414"/> is <em>stateless</em>; it relies entirely on the Redis backend for its state. As a result, we can replicate it arbitrarily without affecting traffic. Though our application is unlikely to sustain large-scale usage, it’s still a good idea to run with at least two replicas so that you can handle an unexpected crash or roll out a new version of the application without downtime.</p>&#13;
&#13;
<p>In Kubernetes, the<a data-primary="ReplicaSet resource" data-type="indexterm" id="id415"/> ReplicaSet resource is the one that directly manages replicating a specific version&#13;
of your containerized application. Since the version of all applications changes over time as you modify the code,&#13;
it is not a best practice to use a ReplicaSet directly. Instead, you use<a data-primary="Deployment resource" data-type="indexterm" id="deploy-resource"/> the Deployment&#13;
resource. A Deployment combines the replication capabilities of ReplicaSet with versioning&#13;
and the ability to perform a staged rollout. By using a Deployment you can use Kubernetes’&#13;
built-in tooling to move from one version of the application to the next.</p>&#13;
&#13;
<p>The Kubernetes Deployment resource for our application looks as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1"># All pods in the Deployment will have this label</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1"># We should always have at least two replicas for reliability</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-repo/journal-server:v1-abcde</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">IfNotPresent</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1"># TODO: Figure out what the actual resource needs are</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">request</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1.0"</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1G"</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1.0"</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1G"</code><code class="w"/></pre>&#13;
&#13;
<p>There are several things to <a data-primary="labels" data-secondary="for deployments" data-secondary-sortas="deployments" data-type="indexterm" id="id416"/>note in this Deployment. First is that we are using Labels&#13;
to identify the Deployment as well as the ReplicaSets and the pods that the Deployment&#13;
creates. We’ve added the <code>app: frontend</code> label to all these resources so that we can&#13;
examine all resources for a particular layer in a single request. You’ll see that as we&#13;
add other resources, we’ll follow the same practice.</p>&#13;
&#13;
<p>Additionally, we’ve added <a data-primary="comments" data-type="indexterm" id="id417"/>comments in a number of places in the YAML. Although these comments&#13;
don’t make it into the Kubernetes resource stored on the server, just like comments in code,&#13;
they serve to guide people who are looking at this configuration for the first time.</p>&#13;
&#13;
<p>You should <a data-primary="resource management" data-secondary="limits" data-type="indexterm" id="resource-limit-deploy"/>also note that for the containers in the Deployment we have specified both&#13;
Request and Limit resource requests, and we’ve set Request equal to Limit. When running an&#13;
application, the Request is the reservation that is guaranteed on the host machine where&#13;
it runs. The Limit is the maximum resource usage that the container will be allowed.&#13;
When you are starting out, setting Request equal to Limit will lead to the most predictable&#13;
behavior of your application. This predictability comes at the expense of resource utilization.&#13;
Because setting Request equal to Limit prevents your applications from overscheduling or consuming&#13;
excess idle resources, you will not be able to drive maximal utilization unless you tune Request&#13;
and Limit very, very carefully. As you become more advanced in your understanding of the Kubernetes&#13;
resource model, you might consider modifying Request and Limit for your application independently,&#13;
but in general most users find that the stability from predictability is worth the reduced utilization.</p>&#13;
&#13;
<p>Often times, as our comment suggests, it is difficult to know the right values for these resource&#13;
limits. Starting by overestimating the estimates and then using monitoring to tune to the right&#13;
values is a pretty good approach. However, if you are launching a new service, remember that&#13;
the first time you see large-scale traffic, your resource needs will likely increase significantly.&#13;
Additionally, there are some languages, especially garbage-collected languages, that will happily&#13;
consume all available memory, which can make it difficult to determine the correct minimum for&#13;
memory. In this case, some form of binary search may be necessary, but remember to do this in a&#13;
test environment so that it doesn’t affect your <a data-primary="resource management" data-secondary="limits" data-startref="resource-limit-deploy" data-type="indexterm" id="id418"/>production!</p>&#13;
&#13;
<p>Now that we have the Deployment resource defined, we’ll check it into version control, and&#13;
deploy it to Kubernetes:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">git<code class="w"> </code>add<code class="w"> </code>frontend/deployment.yaml<code class="w"/>&#13;
git<code class="w"> </code>commit<code class="w"> </code>-m<code class="w"> </code><code class="s2">"Added deployment"</code><code class="w"> </code>frontend/deployment.yaml<code class="w"/>&#13;
kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>frontend/deployment.yaml<code class="w"/></pre>&#13;
&#13;
<p>It is also a best practice to ensure that the contents of your cluster exactly match the&#13;
contents of your<a data-primary="version control" data-secondary="best practices" data-type="indexterm" id="id419"/><a data-primary="best practices" data-secondary="version control" data-type="indexterm" id="id420"/><a data-primary="GitOps" data-type="indexterm" id="id421"/><a data-primary="CI/CD (continuous integration/continuous delivery)" data-type="indexterm" id="id422"/> source control. The best pattern to ensure this is to adopt a GitOps&#13;
approach and deploy to production only from a specific branch of your source control, using&#13;
continuous integration/continuous delivery (CI/CD) automation. In this way you’re guaranteed that source control and production match. Though a full CI/CD pipeline might seem excessive for a simple application, the automation by itself, independent of the reliability it provides, is usually worth the time taken to set it up. And CI/CD is extremely difficult to retrofit into an existing, imperatively deployed application.</p>&#13;
&#13;
<p>We’ll come back to this application description YAML in later sections to examine additional elements such as the ConfigMap and secret volumes as well <a data-primary="application example" data-secondary="replicated service creation" data-startref="app-example-replicate-create" data-type="indexterm" id="id423"/><a data-primary="replicated services, creating with deployments" data-startref="replicate-create" data-type="indexterm" id="id424"/><a data-primary="deployments" data-secondary="replicated service creation" data-startref="deploy-replicate" data-type="indexterm" id="id425"/><a data-primary="Deployment resource" data-startref="deploy-resource" data-type="indexterm" id="id426"/>as pod Quality of Service.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up an External Ingress for HTTP Traffic" data-type="sect1"><div class="sect1" id="id5">&#13;
<h1>Setting Up an External Ingress for HTTP Traffic</h1>&#13;
&#13;
<p>The <a data-primary="application example" data-secondary="external ingress setup" data-type="indexterm" id="app-example-external-ingress"/><a data-primary="external ingress setup for HTTP traffic" data-type="indexterm" id="external-ingress-setup"/><a data-primary="Ingress API" data-secondary="HTTP load balancing" data-type="indexterm" id="ingress-resource"/><a data-primary="HTTP requests, external ingress setup" data-type="indexterm" id="http-external-ingress"/><a data-primary="load balancing" data-type="indexterm" id="load-balance"/>containers for our application are now deployed, but it’s not currently possible for&#13;
anyone to access the application. By default, cluster resources are&#13;
available only within the cluster itself. To expose our application to the world, we&#13;
need to create a service and load balancer to provide an external IP address and to&#13;
bring traffic to our containers. For the external exposure we are going to use&#13;
two Kubernetes resources. The first is a service that load-balances Transmission Control Protocol (TCP) or User Datagram Protocol (UDP) traffic.&#13;
In our case, we’re using the TCP protocol. And the second is an Ingress resource,&#13;
which provides HTTP(S) load balancing with intelligent routing of requests based on&#13;
HTTP paths and hosts. With a simple application like this, you might wonder why we choose&#13;
to use the more complex Ingress, but as you’ll see in later sections, even this simple&#13;
application will be serving HTTP requests from two different services. Furthermore,&#13;
having an Ingress at the edge enables flexibility for future expansion of our service.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The Ingress resource is one of the older resources in Kubernetes, and over the years&#13;
numerous issues have been raised with the way that it models HTTP access to microservices.&#13;
This has led to the development of the <a data-primary="Gateway API for Kubernetes" data-type="indexterm" id="id427"/>Gateway API for Kubernetes. The Gateway API has&#13;
been designed as an extension to Kubernetes and requires additional components to be&#13;
installed in your cluster. If you find that Ingress doesn’t meet your needs, consider&#13;
moving to the Gateway API.</p>&#13;
</div>&#13;
&#13;
<p>Before the Ingress resource can be defined, there needs to be a Kubernetes Service&#13;
for <a data-primary="Service resource" data-type="indexterm" id="id428"/>the Ingress to point to. We’ll use Labels to direct the Service to the pods that&#13;
we created in the previous section. The Service is significantly simpler to define&#13;
than the Deployment and looks as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterIP</code><code class="w"/></pre>&#13;
&#13;
<p>After you’ve defined the Service, you can define an Ingress resource. Unlike Service&#13;
resources, Ingress requires an Ingress controller container to be running in&#13;
the cluster. There are a number of different implementations you can choose from,&#13;
either offered by your cloud provider, or implemented using open source servers.&#13;
If you choose to install an open source Ingress provider, it’s a good idea to&#13;
use the <a href="https://helm.sh">Helm package manager</a> to install and maintain it. The <code>nginx</code> or <code>haproxy</code> Ingress providers are popular choices:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Ingress</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend-ingress</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">http</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">paths</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/testpath</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Prefix</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">backend</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">test</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/></pre>&#13;
&#13;
<p>With our Ingress resource created, our application is ready to serve traffic from web browsers around the world. Next, we’ll look at how you can set up your application for easy configuration and <a data-primary="application example" data-secondary="external ingress setup" data-startref="app-example-external-ingress" data-type="indexterm" id="id429"/><a data-primary="external ingress setup for HTTP traffic" data-startref="external-ingress-setup" data-type="indexterm" id="id430"/><a data-primary="Ingress API" data-secondary="HTTP load balancing" data-startref="ingress-resource" data-type="indexterm" id="id431"/><a data-primary="HTTP requests, external ingress setup" data-startref="http-external-ingress" data-type="indexterm" id="id432"/><a data-primary="load balancing" data-startref="load-balance" data-type="indexterm" id="id433"/>customization.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring an Application with ConfigMaps" data-type="sect1"><div class="sect1" id="id6">&#13;
<h1>Configuring an Application with ConfigMaps</h1>&#13;
&#13;
<p>Every <a data-primary="application example" data-secondary="configuring with ConfigMaps" data-type="indexterm" id="app-example-config-configmap"/><a data-primary="configuring" data-secondary="with ConfigMaps" data-secondary-sortas="ConfigMaps" data-type="indexterm" id="config-configmap"/><a data-primary="ConfigMaps resource" data-type="indexterm" id="configmaps"/>application needs a degree of configuration. This could be the number of&#13;
journal entries to display per page, the color of a particular background,&#13;
a special holiday display, or many other types of configuration. Typically,&#13;
separating such configuration information from the application itself is a&#13;
best practice to follow.</p>&#13;
&#13;
<p>There are several reasons for this separation. The first is&#13;
that you might want to configure the same application binary with different&#13;
configurations depending on the setting. In Europe you might want to light&#13;
up an Easter special, whereas in China you might want to display a special&#13;
for Chinese New Year. In addition to this environmental specialization,&#13;
there are agility reasons for the separation. Usually a binary release&#13;
contains multiple different new features; if you turn on these features&#13;
via code, the only way to modify the active features is to build&#13;
and release a new binary, which can be an expensive and slow process.</p>&#13;
&#13;
<p>The use of configuration to activate a set of features means that you&#13;
can quickly (and even dynamically) activate and deactivate features&#13;
in response to user needs or <span class="keep-together">application</span> code failures. Features&#13;
can be rolled out and rolled back on a per-feature basis. This flexibility&#13;
ensures that you are continually making forward progress with most features&#13;
even if some need to be rolled back to address performance or correctness&#13;
problems.</p>&#13;
&#13;
<p>In Kubernetes this sort of configuration is represented by a resource&#13;
called a ConfigMap. A ConfigMap contains multiple key/value pairs&#13;
representing configuration information or a file. This configuration&#13;
information can be presented to a container in a pod via either&#13;
files or environment variables. Imagine that you want to configure your&#13;
online journal application to display a configurable number of journal&#13;
entries per page. To achieve this, you can define a ConfigMap as follows:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>configmap<code class="w"> </code>frontend-config<code class="w"> </code>--from-literal<code class="o">=</code><code class="nv">journalEntries</code><code class="o">=</code><code class="m">10</code><code class="w"/></pre>&#13;
&#13;
<p>To configure your application, you expose the configuration information as&#13;
an environment variable in the application itself. To do that, you can&#13;
add the following to the <code>container</code> resource in the Deployment that you defined earlier:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="c1"># The containers array in the PodTemplate inside the Deployment</code><code class="w"/>&#13;
<code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">...</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">JOURNAL_ENTRIES</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend-config</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">journalEntries</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>Although this demonstrates how you can use a ConfigMap to configure your application, in&#13;
the real world of Deployments, you’ll want to roll out regular changes to this&#13;
configuration at least weekly. It might be tempting&#13;
to roll this out by simply changing the ConfigMap itself, but this isn’t really&#13;
a<a data-primary="best practices" data-secondary="ConfigMaps" data-type="indexterm" id="id434"/> best practice, for reasons: the first is that changing the&#13;
configuration doesn’t actually trigger an update to existing pods. The configuration is applied only when the pod is restarted. As a result, the rollout isn’t&#13;
health based and can be ad hoc or random. Another reason is that the only versioning for the&#13;
ConfigMap is in your version control, and it can be very difficult to perform a rollback.</p>&#13;
&#13;
<p>A better approach is to put a version number in the name of the ConfigMap itself.&#13;
Instead of calling it <code>frontend-config</code>, call it <code>frontend-config-v1</code>. When you want&#13;
to make a change, instead of updating the ConfigMap in place, you create a new <code>v2</code>&#13;
ConfigMap, and then update the Deployment resource to use that configuration.&#13;
When you do this, a Deployment rollout is automatically triggered, using the appropriate&#13;
health checking and pauses between changes. Furthermore, if you ever need to roll back,&#13;
the <code>v1</code> configuration is sitting in the cluster and rollback is as simple as updating&#13;
the Deployment <a data-primary="application example" data-secondary="configuring with ConfigMaps" data-startref="app-example-config-configmap" data-type="indexterm" id="id435"/><a data-primary="configuring" data-secondary="with ConfigMaps" data-secondary-sortas="ConfigMaps" data-startref="config-configmap" data-type="indexterm" id="id436"/><a data-primary="ConfigMaps resource" data-startref="configmaps" data-type="indexterm" id="id437"/>again.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing Authentication with Secrets" data-type="sect1"><div class="sect1" id="id7">&#13;
<h1>Managing Authentication with Secrets</h1>&#13;
&#13;
<p>So far,<a data-primary="application example" data-secondary="authentication management" data-type="indexterm" id="app-example-auth-manage"/><a data-primary="authentication" data-secondary="with secrets" data-secondary-sortas="secrets" data-type="indexterm" id="auth-secret"/><a data-primary="secrets" data-secondary="authentication management with" data-type="indexterm" id="secret-auth-manage"/><a data-primary="Redis database" data-secondary="authentication management" data-type="indexterm" id="redis-auth-manage"/> we haven’t really discussed the Redis service to which our frontend is connecting. But in any real application we need to secure connections between our services.&#13;
In part, this is to ensure the security of users and their data, and in addition, it&#13;
is essential to prevent mistakes like connecting a development frontend with&#13;
a production database.</p>&#13;
&#13;
<p>The Redis database is authenticated using a simple password. It might be&#13;
convenient to think that you would store this password in the source code of&#13;
your application, or in a file in your image, but these are both bad ideas for a&#13;
variety of reasons. The first is that you have leaked your secret (the password)&#13;
into an environment where you aren’t necessarily thinking about <a data-primary="access control" data-type="indexterm" id="id438"/>access control.&#13;
If you put a password into your source control, you are aligning access to your&#13;
source with access to all secrets. This isn’t the best course of action because you will probably have a broader set of users who can access your source code than should&#13;
really have access to your Redis instance. Likewise, someone who has access to&#13;
your container image shouldn’t necessarily have access to your production database.</p>&#13;
&#13;
<p>In addition to concerns about access control, another reason to avoid binding&#13;
secrets to source control and/or images is<a data-primary="parameterization" data-type="indexterm" id="id439"/> parameterization. You want to be able&#13;
to use the same source code and images in a variety of environments (e.g., development,&#13;
canary, and production). If the secrets are tightly bound in source code or an image, you need a different image (or different code) for each environment.</p>&#13;
&#13;
<p>Having seen <a data-primary="passwords, as configurations" data-type="indexterm" id="id440"/><a data-primary="configurations, passwords as" data-type="indexterm" id="id441"/>ConfigMaps in the previous section, you might immediately think that&#13;
the password could be stored as a configuration and then populated into the&#13;
application as an application-specific configuration. You’re absolutely correct to believe&#13;
that the separation of configuration from application is the same as the separation&#13;
of secrets from application. But the truth is that a secret is an important&#13;
concept by itself. You likely want to handle access control, handling, and updates&#13;
of secrets in a different way than a configuration. More important, you&#13;
want your developers <em>thinking</em> differently when they are accessing secrets than&#13;
when they are accessing configuration. For these reasons, Kubernetes has a built-in Secret resource<a data-primary="Secret resource" data-type="indexterm" id="id442"/> for managing secret data.</p>&#13;
&#13;
<p>You can create a secret password for your Redis database as follows:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>secret<code class="w"> </code>generic<code class="w"> </code>redis-passwd<code class="w"> </code>--from-literal<code class="o">=</code><code class="nv">passwd</code><code class="o">=</code><code class="si">${</code><code class="nv">RANDOM</code><code class="si">}</code><code class="w"/></pre>&#13;
&#13;
<p>Obviously, you might want to use something other than a random number for&#13;
your password. Additionally, you likely want to use a secret/key management&#13;
service, either via your cloud provider, like Microsoft Azure Key Vault, or an open&#13;
source project, like HashiCorp’s Vault. When you are using a key management&#13;
service, they generally have tighter integration with Kubernetes secrets.</p>&#13;
&#13;
<p>After you have stored the Redis password as a secret in Kubernetes, you then need&#13;
to <em>bind</em> that<a data-primary="secrets" data-secondary="binding" data-type="indexterm" id="id443"/><a data-primary="binding" data-secondary="secrets" data-type="indexterm" id="id444"/><a data-primary="volumes" data-secondary="adding to Deployments" data-type="indexterm" id="id445"/><a data-primary="Deployment resource" data-secondary="adding Volumes to" data-type="indexterm" id="id446"/> secret to the running application when deployed to Kubernetes.&#13;
To do this, you can use a Kubernetes Volume. A Volume is effectively a file&#13;
or directory that can be mounted into a running container at a user-specified&#13;
location. In the case of secrets, the Volume is created as a tmpfs RAM-backed&#13;
filesystem and then mounted into the container. This ensures that even if&#13;
the machine is physically compromised (quite unlikely in the cloud, but&#13;
possible in the datacenter), the secrets are much more difficult for an attacker to obtain.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Secrets in <a data-primary="secrets" data-secondary="encryption" data-type="indexterm" id="id447"/><a data-primary="encryption" data-type="indexterm" id="id448"/>Kubernetes are stored unencrypted by default. If you want to store&#13;
secrets encrypted, you can integrate with a key provider to give you a key&#13;
that Kubernetes will use to encrypt all the secrets in the cluster.&#13;
Note that although this secures the keys against direct attacks to the <code>etcd</code>&#13;
database, you still need to ensure that access via the Kubernetes API server&#13;
is properly secured.</p>&#13;
</div>&#13;
&#13;
<p>To add a secret Volume to a Deployment, you need to specify two new entries&#13;
in the YAML for the Deployment. The first is a <code>volume</code> entry for the pod&#13;
that adds the Volume to the pod:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passwd-volume</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-passwd</code><code class="w"/></pre>&#13;
&#13;
<p>Container Storage Interface (CSI) drivers<a data-primary="CSI (Container Storage Interface) drivers" data-type="indexterm" id="id449"/> enable you to use key management systems (KMS) that are located outside of your Kubernetes cluster. This is often a requirement for compliance and security within large or regulated organizations. If you use one of these CSI drivers your Volume would instead&#13;
look like:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passwd-volume</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">csi</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">driver</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secrets-store.csi.k8s.io</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">volumeAttributes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">secretProviderClass</code><code class="p">:</code><code class="w"> </code><code class="s">"azure-sync"</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>Regardless of which method you use, with the Volume defined in the pod, you need to mount it into a specific container.&#13;
You do this via the <code>volumeMounts</code> field in the container description:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passwd-volume</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/etc/redis-passwd"</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>This mounts the secret Volume into the <code>redis-passwd</code> directory for access from the client code. Putting this all together, you have the complete Deployment as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-repo/journal-server:v1-abcde</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">IfNotPresent</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passwd-volume</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/etc/redis-passwd"</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1.0"</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1G"</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1.0"</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1G"</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passwd-volume</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-passwd</code><code class="w"/></pre>&#13;
&#13;
<p>At this point we have configured the client application to have a secret&#13;
available to authenticate to the Redis service. Configuring Redis to use&#13;
this password is similar; we mount it into the Redis pod and load&#13;
the password from the<a data-primary="application example" data-secondary="authentication management" data-startref="app-example-auth-manage" data-type="indexterm" id="id450"/><a data-primary="authentication" data-secondary="with secrets" data-secondary-sortas="secrets" data-startref="auth-secret" data-type="indexterm" id="id451"/><a data-primary="secrets" data-secondary="authentication management with" data-startref="secret-auth-manage" data-type="indexterm" id="id452"/><a data-primary="Redis database" data-secondary="authentication management" data-startref="redis-auth-manage" data-type="indexterm" id="id453"/> file.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploying a Simple Stateful Database" data-type="sect1"><div class="sect1" id="id8">&#13;
<h1>Deploying a Simple Stateful Database</h1>&#13;
&#13;
<p>Although<a data-primary="application example" data-secondary="stateful database deployment" data-type="indexterm" id="app-example-stateful"/><a data-primary="stateful deployment" data-type="indexterm" id="stateful-deploy"/><a data-primary="Redis database" data-secondary="stateful deployment" data-type="indexterm" id="redis-stateful"/><a data-primary="databases, stateful deployment" data-type="indexterm" id="database-stateful"/><a data-primary="deploying" data-secondary="stateful databases" data-type="indexterm" id="deploy-stateful"/><a data-primary="PersistentVolumes resource" data-type="indexterm" id="persistentvolume"/> conceptually deploying a stateful application is similar to&#13;
deploying a client like our frontend, state brings with it more complications.&#13;
The first is that in Kubernetes a pod can be rescheduled for a number&#13;
of reasons, such as node health, an upgrade, or rebalancing. When this&#13;
happens, the pod might move to a different machine. If the data associated&#13;
with the Redis instance is located on any particular machine or within&#13;
the container itself, that data will be lost when the container&#13;
migrates or restarts. To prevent this, when running stateful workloads&#13;
in Kubernetes it’s important to use remote <em>PersistentVolume</em>s to manage&#13;
the state associated with the application.</p>&#13;
&#13;
<p>There are a wide variety of implementations of PersistentVolumes in Kubernetes, but they all share common characteristics.&#13;
Like secret Volumes described earlier, they are associated with a&#13;
pod and mounted into a container at a particular location.&#13;
Unlike secrets, PersistentVolumes are generally remote storage&#13;
mounted through some sort of network protocol, either file based,&#13;
such as Network File System (NFS) or Server Message Block (SMB), or block based (iSCSI, cloud-based disks, etc.).&#13;
Generally, for applications such as databases, block-based disks are&#13;
preferable because they offer better performance, but if&#13;
performance is less of a consideration, file-based disks sometimes&#13;
offer greater flexibility.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Managing state <a data-primary="best practices" data-secondary="stateful services" data-type="indexterm" id="id454"/>in general is complicated, and Kubernetes is no exception. If you are running in an environment that supports&#13;
stateful services (e.g., MySQL as a service, Redis as a service), &#13;
<span class="keep-together">it&#13;
is generally</span> a good idea to use those stateful services. Initially, the&#13;
cost premium of a stateful software as a service (SaaS) might seem expensive, but when you factor&#13;
in all the operational requirements of state (backup, data locality,&#13;
redundancy, etc.), and the fact that the presence of state in a&#13;
Kubernetes cluster makes it difficult to move applications between&#13;
clusters, it becomes clear that, in most cases, storage SaaS is&#13;
worth the price premium. In on-premises environments where storage&#13;
SaaS isn’t available, having a dedicated team provide storage as a service&#13;
to the entire organization is definitely a better practice than allowing&#13;
each team to build it themselves.</p>&#13;
</div>&#13;
&#13;
<p>To deploy our Redis service, we use a <a data-primary="StatefulSet resource" data-type="indexterm" id="id455"/>StatefulSet resource.&#13;
Added after the initial Kubernetes release as a complement to&#13;
ReplicaSet resources, a StatefulSet gives slightly stronger guarantees&#13;
such as consistent names (no random hashes!) and a defined order for&#13;
scale-up and scale-down. When you are deploying a singleton, this is&#13;
somewhat less important, but when you want to deploy replicated state,&#13;
these attributes are very convenient.</p>&#13;
&#13;
<p>To obtain a PersistentVolume for our Redis, we use a PersistentVolumeClaim.&#13;
You can think of a claim as a “request for resources.” Our Redis declares&#13;
abstractly that it wants 50 GB of storage, and the Kubernetes cluster determines&#13;
how to provision an appropriate PersistentVolume. There are two reasons for&#13;
this. The first is so we can write a StatefulSet that is portable between&#13;
different clouds and on premises, where the details of disks might be different. The&#13;
other reason is that although many PersistentVolume types can be mounted&#13;
to only a single pod, we can use Volume claims to write a template that can be&#13;
replicated and still have each pod assigned its own specific PersistentVolume.</p>&#13;
&#13;
<p>The following example shows a Redis StatefulSet with PersistentVolumes:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">StatefulSet</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">serviceName</code><code class="p">:</code><code class="w"> </code><code class="s">"redis"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis:5-alpine</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">6379</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/data</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumeClaimTemplates</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"ReadWriteOnce"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10Gi</code><code class="w"/></pre>&#13;
&#13;
<p>This deploys a single instance of your Redis service, but suppose you want to&#13;
replicate the Redis cluster for scale-out of reads and resiliency to failures. To do this&#13;
you obviously need to increase the number of replicas to three, but you also need to ensure&#13;
that the two new replicas connect to the write master for Redis. We’ll see how to make this connection in the following section.</p>&#13;
&#13;
<p>When you create the headless Service for the Redis StatefulSet, it creates a DNS entry&#13;
<code>redis-0.redis</code>; this is the IP address of the first replica. You can use this to  create&#13;
a simple script that can launch in all the containers:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="ch">#!/bin/sh</code>&#13;
&#13;
<code class="nv">PASSWORD</code><code class="o">=</code><code class="k">$(</code>cat<code class="w"> </code>/etc/redis-passwd/passwd<code class="k">)</code><code class="w"/>&#13;
&#13;
<code class="k">if</code><code class="w"> </code><code class="o">[[</code><code class="w"> </code><code class="s2">"</code><code class="si">${</code><code class="nv">HOSTNAME</code><code class="si">}</code><code class="s2">"</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="s2">"redis-0"</code><code class="w"> </code><code class="o">]]</code><code class="p">;</code><code class="w"> </code><code class="k">then</code><code class="w"/>&#13;
<code class="w">  </code>redis-server<code class="w"> </code>--requirepass<code class="w"> </code><code class="si">${</code><code class="nv">PASSWORD</code><code class="si">}</code><code class="w"/>&#13;
<code class="k">else</code><code class="w"/>&#13;
<code class="w">  </code>redis-server<code class="w"> </code>--slaveof<code class="w"> </code>redis-0.redis<code class="w"> </code><code class="m">6379</code><code class="w"> </code>--masterauth<code class="w"> </code><code class="si">${</code><code class="nv">PASSWORD</code><code class="si">}</code><code class="w"/>&#13;
<code class="w">    </code>--requirepass<code class="w"> </code><code class="si">${</code><code class="nv">PASSWORD</code><code class="si">}</code><code class="w"/>&#13;
<code class="k">fi</code><code class="w"/></pre>&#13;
&#13;
<p>You can create this script as a ConfigMap:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>configmap<code class="w"> </code>redis-config<code class="w"> </code>--from-file<code class="o">=</code>./launch.sh<code class="w"/></pre>&#13;
&#13;
<p>You then add this ConfigMap to your StatefulSet and use it as the command for the container.&#13;
Let’s also add in the password for authentication that we created earlier in the chapter.</p>&#13;
&#13;
<p>The complete three-replica Redis looks as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">StatefulSet</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">serviceName</code><code class="p">:</code><code class="w"> </code><code class="s">"redis"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis:5-alpine</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">6379</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/data</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">script</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/script/launch.sh</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">subPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">launch.sh</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passwd-volume</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/redis-passwd</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">sh</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">-c</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/script/launch.sh</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">script</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">configMap</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-config</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">defaultMode</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">0777</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">passwd-volume</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-passwd</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumeClaimTemplates</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">data</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"ReadWriteOnce"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10Gi</code><code class="w"/></pre>&#13;
&#13;
<p>Now your Redis is clustered for fault tolerance. If any one of the three Redis replicas fails for any reason, your application can keep running with the two remaining replicas until the third replica is <a data-primary="application example" data-secondary="stateful database deployment" data-startref="app-example-stateful" data-type="indexterm" id="id456"/><a data-primary="stateful deployment" data-startref="stateful-deploy" data-type="indexterm" id="id457"/><a data-primary="Redis database" data-secondary="stateful deployment" data-startref="redis-stateful" data-type="indexterm" id="id458"/><a data-primary="databases, stateful deployment" data-startref="database-stateful" data-type="indexterm" id="id459"/><a data-primary="deploying" data-secondary="stateful databases" data-startref="deploy-stateful" data-type="indexterm" id="id460"/><a data-primary="PersistentVolumes resource" data-startref="persistentvolume" data-type="indexterm" id="id461"/>restored.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a TCP Load Balancer by Using Services" data-type="sect1"><div class="sect1" id="id9">&#13;
<h1>Creating a TCP Load Balancer by Using Services</h1>&#13;
&#13;
<p>Now <a data-primary="application example" data-secondary="TCP load balancer creation" data-type="indexterm" id="app-example-load-balance"/><a data-primary="TCP load balancers, creating with Services" data-type="indexterm" id="tcp-load-balance-create"/><a data-primary="load balancers" data-secondary="creating with Services" data-type="indexterm" id="load-balance-create"/><a data-primary="Service resource" data-secondary="TCP load balancer creation" data-type="indexterm" id="service-load-balance"/>that we’ve deployed the stateful Redis service, we need to make it available&#13;
to our frontend. To do this, we create two different Kubernetes&#13;
Services. The first is the Service for reading data from Redis. Because Redis&#13;
is replicating the data to all three members of the StatefulSet, we don’t care&#13;
which read our request goes to. Consequently, we use a basic Service for&#13;
the reads:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">6379</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">6379</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">sessionAffinity</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">None</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterIP</code><code class="w"/></pre>&#13;
&#13;
<p>To enable writes, you need to target the Redis master (replica #0). To do this, create a <em>headless</em> Service. A <a data-primary="headless Services" data-type="indexterm" id="id462"/>headless Service doesn’t have a cluster IP address; instead, it programs a DNS entry for every pod in the StatefulSet. This means that we can access our master via the <code>redis-0.redis</code> DNS name:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-write</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-write</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">clusterIP</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">None</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">6379</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/></pre>&#13;
&#13;
<p>Thus, when we want to connect to Redis for writes or transactional read/write pairs, we can build a separate write client connected to<a data-primary="application example" data-secondary="TCP load balancer creation" data-startref="app-example-load-balance" data-type="indexterm" id="id463"/><a data-primary="TCP load balancers, creating with Services" data-startref="tcp-load-balance-create" data-type="indexterm" id="id464"/><a data-primary="load balancers" data-secondary="creating with Services" data-startref="load-balance-create" data-type="indexterm" id="id465"/><a data-primary="Service resource" data-secondary="TCP load balancer creation" data-startref="service-load-balance" data-type="indexterm" id="id466"/> the <code>redis-0.redis-write</code> server.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Ingress to Route Traffic to a Static File Server" data-type="sect1"><div class="sect1" id="id10">&#13;
<h1>Using Ingress to Route Traffic to a Static File Server</h1>&#13;
&#13;
<p>The <a data-primary="application example" data-secondary="static file server setup" data-type="indexterm" id="app-example-static-file"/><a data-primary="static file server setup" data-type="indexterm" id="static-file-server"/><a data-primary="Ingress API" data-secondary="static file server setup" data-type="indexterm" id="ingress-static-file-server"/>final component in our application is a <em>static file server</em>.&#13;
The static file server is responsible for serving HTML, CSS,&#13;
JavaScript, and image files. It’s both more <span class="keep-together">efficient</span> and more&#13;
focused for us to separate static file serving from our API&#13;
serving frontend described earlier. We can easily use a&#13;
high-performance static off-the-shelf file server like NGINX&#13;
to serve files while we allow our development teams to focus&#13;
on the code needed to implement our API.</p>&#13;
&#13;
<p>Fortunately, the Ingress resource makes this sort of mini-microservice architecture very easy. Just like the frontend,&#13;
we can use a Deployment resource to describe a replicated&#13;
NGINX server. Let’s build the static images into the NGINX&#13;
container and deploy them to each replica. The <a data-primary="Deployment resource" data-secondary="static file server setup" data-type="indexterm" id="id467"/>Deployment&#13;
resource looks as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1"># This image is intended as an example, replace it with your own</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1"># static files image.</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-repo/static-files:v1-abcde</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Always</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">terminationMessagePath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/dev/termination-log</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">terminationMessagePolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">File</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1.0"</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1G"</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1.0"</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1G"</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">dnsPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterFirst</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Always</code><code class="w"/></pre>&#13;
&#13;
<p>Now that there is a replicated static web server up and&#13;
running, you will likewise create a<a data-primary="Service resource" data-secondary="static file server setup" data-type="indexterm" id="id468"/> Service resource&#13;
to act as a load balancer:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">sessionAffinity</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">None</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterIP</code><code class="w"/></pre>&#13;
&#13;
<p>Now that you have a Service for your static file server, extend&#13;
the Ingress resource to contain the new path. It’s important to note&#13;
that you must place the <code>/</code> path <em>after</em> the <code>/api</code> path, or else it would&#13;
subsume <code>/api</code> and direct API requests to the static file server. The&#13;
new Ingress looks like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Ingress</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend-ingress</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">http</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">paths</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/api</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Prefix</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">backend</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1"># NOTE: this should come after /api or else it will hijack requests</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Prefix</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">backend</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fileserver</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre>&#13;
&#13;
<p>Now that you have set up an Ingress resource for your file server, in addition to the Ingress for the API you set up earlier, the application’s user interface is ready to use. Most modern applications combine static files, typically HTML and JavaScript, with a dynamic API server implemented in a server-side programming language <a data-primary="application example" data-secondary="static file server setup" data-startref="app-example-static-file" data-type="indexterm" id="id469"/><a data-primary="static file server setup" data-startref="static-file-server" data-type="indexterm" id="id470"/><a data-primary="Ingress API" data-secondary="static file server setup" data-startref="ingress-static-file-server" data-type="indexterm" id="id471"/>like Java, .NET, or Go.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parameterizing Your Application by Using Helm" data-type="sect1"><div class="sect1" id="id11">&#13;
<h1>Parameterizing Your Application by Using Helm</h1>&#13;
&#13;
<p>Everything <a data-primary="application example" data-secondary="parameterization with Helm" data-type="indexterm" id="app-example-parameter"/><a data-primary="parameterization" data-secondary="with Helm" data-secondary-sortas="Helm" data-type="indexterm" id="parameter-helm"/><a data-primary="Helm" data-type="indexterm" id="helm"/><a data-primary="deploying" data-secondary="parameterization with Helm" data-type="indexterm" id="deploy-parameter-helm"/>that we have discussed so far focuses on deploying a single&#13;
instance of our service to a single cluster.&#13;
However, in reality, nearly every service and every service team&#13;
is going to need to deploy to multiple environments (even&#13;
if they share a cluster). Even if you are a single developer working&#13;
on a single application, you likely want to have at least a development&#13;
version and a production version of your application&#13;
so that you can iterate and develop without breaking production users.&#13;
After you factor in integration testing and CI/CD, it’s likely that even&#13;
with a single service and a handful of developers, you’ll want to deploy&#13;
to at least three different environments, and possibly more if you&#13;
consider handling datacenter-level failures. Let’s explore a few options for deployment.</p>&#13;
&#13;
<p>An initial failure mode for many teams is to simply copy the files&#13;
from one cluster to another. Instead of having a single <em>frontend/</em>&#13;
directory, have a <em>frontend-production/</em> and <em>frontend-development/</em>&#13;
pair of directories. While this is a viable option, it’s also dangerous because&#13;
you are now in charge of ensuring that these files remain synchronized&#13;
with one another. If they were intended to be entirely identical,&#13;
this might be easy, but some skew between development and production&#13;
is expected because you will be developing new features. It’s&#13;
critical that the skew is both intentional and easily <span class="keep-together">managed.</span></p>&#13;
&#13;
<p>Another option to achieve this would be to use branches and version&#13;
control, with the production and development branches leading&#13;
off from a central repository and the differences between the&#13;
branches clearly visible. This can be a viable option for some&#13;
teams, but the mechanics of moving between branches are&#13;
challenging when you want to simultaneously deploy software to&#13;
different environments (e.g., a CI/CD system that deploys to a&#13;
number of different cloud regions).</p>&#13;
&#13;
<p>Consequently, most people end up <a data-primary="templating systems" data-type="indexterm" id="template-system"/>with a <em>templating system</em>.&#13;
A templating system combines templates, which form the centralized&#13;
backbone of the application configuration, with parameters that&#13;
<em>specialize</em> the template to a specific environment configuration.&#13;
In this way, you can have a generally shared configuration, with&#13;
intentional (and easily understood) customization as needed.&#13;
There are a variety of template systems for Kubernetes,&#13;
but the most popular by far is <a href="https://helm.sh">Helm</a>.</p>&#13;
&#13;
<p>In Helm, an application is packaged in a collection of files&#13;
called a <em>chart</em> (nautical jokes abound in the world of&#13;
containers and Kubernetes).</p>&#13;
&#13;
<p>A chart begins with a <em>chart.yaml</em> file, which defines the&#13;
metadata for the chart itself:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">appVersion</code><code class="p">:</code><code class="w"> </code><code class="s">"1.0"</code><code class="w"/>&#13;
<code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">A Helm chart for our frontend journal server.</code><code class="w"/>&#13;
<code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">0.1.0</code><code class="w"/></pre>&#13;
&#13;
<p>This file is placed in the root of the chart directory (e.g., <em>frontend/</em>).&#13;
Within this directory, there is a <em>templates</em> directory, which is where&#13;
the templates are placed. A template is basically a YAML file from the&#13;
previous examples, with some of the values in the file replaced with&#13;
parameter references. For example, imagine that you want to parameterize&#13;
the number of replicas in your frontend. Previously, here’s what the Deployment had:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>In the template file (<em>frontend-deployment.tmpl</em>), it instead looks like the following:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p">...</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.replicaCount</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
&#13;
<p>This means that when you deploy the chart, you’ll substitute the value for&#13;
replicas with the appropriate parameter. The parameters themselves are&#13;
defined in a <em>values.yaml</em> file. There will be one values file per environment&#13;
where the application should be deployed. The values file for this&#13;
simple chart would look like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">replicaCount</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w"/></pre>&#13;
&#13;
<p>Putting this all together, you can deploy this chart using the <code>helm</code> tool,&#13;
as follows:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">helm<code class="w"> </code>install<code class="w"> </code>path/to/chart<code class="w"> </code>--values<code class="w"> </code>path/to/environment/values.yaml<code class="w"/></pre>&#13;
&#13;
<p>This parameterizes your application and deploys it to Kubernetes. Over&#13;
time these parameterizations will grow to encompass the variety of environments for your<a data-primary="application example" data-secondary="parameterization with Helm" data-startref="app-example-parameter" data-type="indexterm" id="id472"/><a data-primary="parameterization" data-secondary="with Helm" data-secondary-sortas="Helm" data-startref="parameter-helm" data-type="indexterm" id="id473"/><a data-primary="Helm" data-startref="helm" data-type="indexterm" id="id474"/><a data-primary="deploying" data-secondary="parameterization with Helm" data-startref="deploy-parameter-helm" data-type="indexterm" id="id475"/> application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploying Services Best Practices" data-type="sect1"><div class="sect1" id="id183">&#13;
<h1>Deploying Services Best Practices</h1>&#13;
&#13;
<p>Kubernetes <a data-primary="deploying" data-secondary="best practices" data-type="indexterm" id="id476"/><a data-primary="best practices" data-secondary="deployments" data-type="indexterm" id="id477"/>is a powerful system that can seem complex. But setting up a basic application for success can be straightforward if you use the following best practices:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Most services should be deployed as Deployment resources. Deployments create identical replicas for redundancy and scale.</p>&#13;
</li>&#13;
<li>&#13;
<p>Deployments can be exposed using a Service, which is effectively a load&#13;
balancer. A Service can be exposed either within a cluster (the&#13;
default) or externally. If you want to expose an HTTP application, you can&#13;
use an Ingress controller to add things like request routing and SSL.</p>&#13;
</li>&#13;
<li>&#13;
<p>Eventually you will want to parameterize your application to make its&#13;
configuration more reusable in different environments. Packaging tools&#13;
like <a href="https://helm.sh">Helm</a> are the best choice for this kind of&#13;
parameterization.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id344">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>The application built in this chapter is a simple one, but it contains nearly all the concepts you’ll need to build larger, more complicated applications. Understanding how the pieces fit together and how to use foundational Kubernetes components is key to successfully working with Kubernetes.</p>&#13;
&#13;
<p>Laying the correct foundation via version control, code review, and continuous delivery of your&#13;
service ensures that no matter what you build, it is built solidly. As we go through&#13;
the more advanced topics in subsequent chapters, keep this foundational information in mind.</p>&#13;
</div></section>&#13;
</div></section></body></html>