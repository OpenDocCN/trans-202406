- en: Chapter 5\. Conditional Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a good look at a feature that is unique to TypeScript:
    *conditional types*. Conditional types allow us to select types based on subtype
    checks, allowing us to move around in the type space and get even more flexibility
    in how we want to design interfaces and function signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional types are a powerful tool that allows you to make up types on the
    fly. It makes TypeScript’s type system turing complete, as shown in [this GitHub
    issue](https://oreil.ly/igPhB), which is both outstanding but also a bit frightening.
    With so much power in your hands, it’s easy to lose focus on which types you actually
    need, leading you into dead ends or crafting types that are too hard to read.
    Throughout this book, we will discuss the usage of conditional types thoroughly,
    always reassessing that what we do actually leads to our desired goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this chapter is much shorter than others. This is not because there’s
    not a lot to say about conditional types: quite the contrary. It’s more because
    we will see good use of conditional types in the subsequent chapters. Here, we
    want to focus on the fundamentals and establish terminology that you can use and
    refer to whenever you need some type magic.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Managing Complex Function Signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are creating a function with varying parameters and return types. Managing
    all variations using function overloads gets increasingly complex.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use conditional types to define a set of rules for parameter and return types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You create software that presents certain attributes as labels based on user-defined
    input. You distinguish between `StringLabel` and `NumberLabel` to allow for different
    kinds of filter operations and searches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'User input is either a string or a number. The `createLabel` function takes
    the input as a primitive type and produces either a `StringLabel` or `NumberLabel`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the basic functionality done, you see that your types are way too broad.
    If you enter a `number`, the return type of `createLabel` is still `NumberLabel
    | StringLabel`, when it can only be `NumberLabel`. The solution? Adding function
    overloads to explicitly define type relationships, like we learned in [Recipe
    2.6](ch02.html#ch02_item_function_overloads):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The way function overloads work is that the overloads themselves define types
    for usage, whereas the last function declaration defines the types for the implementation
    of the function body. With `createLabel`, we are able to pass in a `string` and
    get a `StringLabel` or pass in a `number` and get a `NumberLabel`, as those are
    the types available to the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is problematic in cases where we couldn’t narrow the input type beforehand.
    We lack a function type to the outside that allows us to pass in input that is
    either `number` or `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To circumvent this, we add another overload that mirrors the implementation
    function signature for very broad input types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What we see here is that we already need three overloads and four function signature
    declarations total to describe the most basic behavior for this functionality.
    And from there on, it just gets worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to extend our function to be able to copy existing `StringLabel` and
    `NumberLabel` objects. This ultimately means more overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Truth be told, depending on how expressive we want our type hints to be, we
    can write fewer but also a lot more function overloads. The problem is still apparent:
    more variety results in more complex function signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One tool in TypeScript’s toolbelt can help with situations like this: conditional
    types. Conditional types allow us to select a type based on certain subtype checks.
    We ask if a generic type parameter is of a certain subtype and, if so, return
    the type from the `true` branch, or otherwise return the type from the `false`
    branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following type returns the input parameter if `T` is a subtype
    of `string` (which means all strings or very specific ones). Otherwise, it returns
    `never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript borrows this syntax from JavaScript’s ternary operator. And just
    like JavaScript’s ternary operator, it checks if certain conditions are valid.
    But instead of having the typical set of conditions you know from a programming
    language, TypeScript’s type system checks only if the values of the input type
    are included in the set of values we check against.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that tool, we are able to write a conditional type called `GetLabel<T>`.
    We check if the input is either of `string` or `StringLabel`. If so, we return
    `StringLabel`; else, we know that it must be a `NumberLabel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This type only checks if the inputs `string`, `StringLabel`, `number`, and
    `NumberLabel` are in the `else` branch. If we want to be on the safe side, we
    would also include a check against possible inputs that produce a `NumberLabel`
    by nesting conditional types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s time to wire up our generics. We add a new generic type parameter
    `T` to `cr⁠ea⁠te​Lab⁠el` that is constrained to all possible input types. This
    `T` parameter serves as input for `GetLabel<T>`, where it will produce the respective
    return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to handle all possible type combinations and will still get
    the correct return type from `getLabel`, all in just one line of code.
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely, you will see that we needed to work around type-checks
    for the return type. Unfortunately, TypeScript is not able to do proper control
    flow analysis when working with generics and conditional types. A little type
    assertion tells TypeScript that we are dealing with the right return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another workaround would be to think of the function signature with conditional
    types as an overload to the original broadly typed function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This way, we have a flexible type for the outside world that tells exactly what
    output we get based on our input. And for implementation, you have the full flexibility
    you know from a broad set of types.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean you should prefer conditional types over function overloads in
    all scenarios? Not necessarily. In [Recipe 12.7](ch12.html#ch12_overloads_vs_conditionals)
    we look at situations where function overloads are the better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Filtering with never
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a union of various types but you just want to have all subtypes of
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a distributive conditional type to filter for the right type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say you have some legacy code in your application where you tried to re-create
    frameworks like *jQuery*. You have your own kind of `ElementList` that has helper
    functions to add and remove class names to objects of type `HTMLElement`, or to
    bind event listeners to events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can access each element of your list through index access.
    A type for such an `ElementList` can be described using an index access type for
    number index access, together with regular string property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This data structure has been designed to have a fluent interface. Meaning that
    if you call methods like `addClass` or `removeClass`, you get the same object
    back so you can chain your method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample implementation of these methods could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As an extension of a built-in collection like `Array` or `NodeList`, changing
    things on a set of `HTMLElement` objects becomes really convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say you need to maintain your *jQuery* substitute and figure out that
    direct element access has proven to be somewhat unsafe. When parts of your application
    can change things directly, it becomes harder for you to figure out where changes
    come from, if not from your carefully designed `ElementList` data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since you can’t change the original library code (too many departments depend
    on it), you decide to wrap the original `ElementList` in a `Proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Proxy` objects take an original target object and a handler object that defines
    how to handle access. The following implementation shows a `Proxy` that allows
    only read access, and only if the property key is of type `string` and not a string
    that is a string representation of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Handler objects in `Proxy` objects receive only string or symbol properties.
    If you do index access with a number—for example, `0`—JavaScript converts this
    to the string `"0"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works great in JavaScript, but our types don’t match anymore. The return
    type of the `Proxy` constructor is `ElementList` again, which means that the number
    index access is still intact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We need to tell TypeScript that we are now dealing with an object with no number
    index access by defining a new type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the keys of `ElementList`. If we use the `keyof` operator, we
    get a union type of all possible access methods for objects of type `ElementList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains four strings as well as all possible numbers. Now that we have
    this union, we can create a conditional type that gets rid of everything that
    isn’t a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`JustStrings<T>` is what we call a *distributive conditional type*. Since `T`
    is on its own in the condition—not wrapped in an object or array—TypeScript will
    treat a conditional type of a union as a union of conditional types. Effectively,
    TypeScript does the same conditional check for every member of the union `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, it goes through all members of `keyof ElementList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The only condition that hops into the `false` branch is the last one, where
    we check if `number` is a subtype of `string`, which it isn’t. If we resolve every
    condition, we end up with a new union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A union with `never` effectively drops `never`. If you have a set with no possible
    value and you join it with a set of values, the values remain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the list of keys we consider safe to access! By using the `Pick`
    helper type, we can create a type that is effectively a supertype of `ElementList`
    by picking all keys that are of type `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we hover over it, we see that the resulting type is exactly what we were
    looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the type as an annotation to `safeAccessCollection`. Since it’s possible
    to assign to a supertype, TypeScript will treat `safeAccessCollection` as a type
    with no number index access from that moment on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we now try to access elements from `safeAccessCollection`, TypeScript
    will greet us with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And that’s exactly what we need. The power of distributive conditional types
    is that we change members of a union. We will see another example in [Recipe 5.3](#ch05_grouping_elements),
    where we work with built-in helper types.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Grouping Elements by Kind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your `Group` type from [Recipe 4.5](ch04.html#ch04_new_object_types) works fine,
    but the type for each entry of the group is too broad.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Extract` helper type to pick the right member from a union type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go back to the toy shop example from Recipes [3.1](ch03.html#ch03_item_modelling_data)
    and [4.5](ch04.html#ch04_new_object_types). We started with a thoughtfully crafted
    model, with discriminated union types allowing us to get exact information about
    every possible value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We then found a way to *derive* another type called `GroupedToys` from `Toy`,
    where we take the union type members of the `kind` property as property keys for
    a mapped type, where each property is of type `Toy[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to generics, we were able to define a helper type `Group<Collection,
    Selector>` to reuse the same pattern for different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper type works great, but there’s one caveat. If we hover over the generated
    type, we see that while `Group<Collection, Selector>` is able to pick the discriminant
    of the `Toy` union type correctly, all properties point to a very broad `Toy[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But shouldn’t we know more? For example, why does `boardgame` point to a `Toy[]`
    when the only realistic type should be `BoardGame[]`. Same for puzzles and dolls,
    and all the subsequent toys we want to add to our collection. The type we are
    expecting should look more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve this type by *extracting* the respective member from the `Collection`
    union type. Thankfully, there is a helper type for that: `Extract<T, U>`, where
    `T` is the collection, `U` is part of `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Extract<T, U>` is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As `T` in the condition is a naked type, `T` is a *distributive conditional
    type*, which means TypeScript checks if each member of `T` is a subtype of `U`,
    and if this is the case, it keeps this member in the union type. How would this
    work for picking the right group of toys from `Toy`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to pick `Doll` from `Toy`. `Doll` has a couple of properties,
    but the `kind` property separates distinctly from the rest. So for a type to look
    only for `Doll` would mean that we extract *from* `Toy` every type where `{ kind:
    "doll" }`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With distributive conditional types, a conditional type of a union is a union
    of conditional types, so each member of `T` is checked against `U`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `BoardGame` and `Puzzle` are not subtypes of `{ kind: "doll" }`, so they
    resolve to `never`. But `Doll` *is* a subtype of `{ kind: "doll" }`, so it resolves
    to `Doll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In a union with `never`, `never` just disappears. So the resulting type is
    `Doll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we are looking for. Let’s get that check into our `Group`
    helper type. Thankfully, we have all parts available to extract a specific type
    from a group’s collection:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Collection` itself, a placeholder that eventually is substituted with `Toy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The discriminant property in `Selector`, which eventually is substituted with
    `"kind"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The discriminant type we want to extract, which is a string type and coincidentally
    also the property key we map out in `Group`: `K`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So the generic version of `Extract<Toy, { kind: "doll" }>` within `Group<Collection,
    Selector>` is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we substitute `Collection` with `Toy` and `Selector` with `"kind"`, the
    type reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[K in Collection[Selector]]`'
  prefs: []
  type: TYPE_NORMAL
- en: Take each member of `Toy["kind"]`—in that case, `"boardgame"`, `"puzzle"`, and
    `"doll"`—as a property key for a new object type.
  prefs: []
  type: TYPE_NORMAL
- en: '`Extract<Collection, …​>`'
  prefs: []
  type: TYPE_NORMAL
- en: Extract from the `Collection`, the union type `Toy`, each member that is a subtype
    of…​
  prefs: []
  type: TYPE_NORMAL
- en: '`{ [P in Selector]: K }`'
  prefs: []
  type: TYPE_NORMAL
- en: Go through each member of `Selector`—in our case, it’s just `"kind"`—and create
    an object type that points to `"boardgame"` when the property key is `"boardgame"`,
    `"puzzle"` when the property key is `"puzzle"`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s how we pick for each property key the right member of `Toy`. The result
    is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! The type is now a lot clearer, and we can make sure that we don’t
    need to deal with puzzles when we selected board games. But some new problems
    have popped up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the types of each property are much more refined and don’t point to the
    very broad `Toy` type, TypeScript struggles a bit with resolving each collection
    in our group correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that TypeScript still thinks of `toy` as potentially being all
    toys, whereas each property of `group` points to some very specific ones. There
    are three ways to solve this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we could again check for each member individually. Since TypeScript
    thinks of `toy` as a very broad type, narrowing makes the relationship clear again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: That works, but there’s lots of duplication and repetition we want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we can use a type assertion to widen the type of `groups[toy.kind]`
    so TypeScript can ensure index access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This effectively works like before our change to `GroupedToys`, and the type
    assertion tells us that we intentionally changed the type here to get rid of type
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, we can work with a little indirection. Instead of adding `toy` directly
    to a group, we use a helper function `assign` where we work with generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we narrow the right member of the `Toy` union by using TypeScript’s generic
    substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groups` is `T`, a `Record<string, K[]`>. `K[]` can be potentially broad.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`key` is in relation to `T`: a property key of `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is of type `K`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three function parameters are in relation to one another, and the way we
    designed the type relations allows us to safely access `groups[key]` and push
    `value` to the array.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the types of each parameter when we call `assign` fulfill the generic
    type constraints we just set. If you want to know more about this technique, check
    out [Recipe 12.6](ch12.html#ch12_unexpected_intersections).
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Removing Specific Object Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a generic helper type for objects, where you select properties
    based on their type rather than the property’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filter with conditional types and type assertions when mapping property keys.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript allows you to create types based on other types, so you can keep
    them up to date without maintaining every one of their derivates. We’ve seen examples
    in earlier items, like [Recipe 4.5](ch04.html#ch04_new_object_types). In the following
    scenario, we want to adapt an existing object type based on the types of its properties.
    Let’s look at a type for `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It consists of two strings—`profession` and `name`—and a number: `age`. We
    want to create a type that consists only of string type properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript already has certain helper types to deal with filtering property
    names. For example, the mapped type `Pick<T>` takes a subset of an object’s keys
    to create a new object that contains only those keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to remove certain properties, we can use `Omit<T>`, which works
    just like `Pick<T>` with the small difference that we map through a slightly altered
    set of properties, one where we remove property names that we don’t want to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: To select the right properties based on their type, rather than their name,
    we would need to create a similar helper type, one where we map a dynamically
    generated set of property names that point only to the types we are looking for.
    We know from [Recipe 5.2](#ch05_filtering_never) that when using conditional types
    over a union type, we can use `never` to filter elements from this union.
  prefs: []
  type: TYPE_NORMAL
- en: 'So a first possibility could be that we map all property keys of `Person` and
    check if `Person[K]` is a subset of our desired type. If so, we return the type;
    otherwise, we return `never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is good, but it comes with a caveat: the types we are checking are not
    in a union but are types from a mapped type. So instead of filtering property
    keys, we would get properties that point to type `never`, meaning that we would
    forbid certain properties to be set at all.'
  prefs: []
  type: TYPE_NORMAL
- en: Another idea would be to set the type to `undefined`, treating the property
    as sort of optional but, as we learned in [Recipe 3.11](ch03.html#ch03_item_missing_vs_undefined),
    missing properties and undefined values are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: What we actually want to do is drop the property keys that point to a certain
    type. This can be achieved by putting the condition not on the righthand side
    of the object but on the lefthand side, where the properties are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with the `Omit` type, we need to make sure that we map over a specific
    set of properties. When mapping `keyof Person`, it is possible to change the type
    of the property key with a type assertion. Just like with regular type assertions,
    there is a sort of fail-safe mechanism, meaning you just can’t assert it to be
    anything: it has to be within the boundaries of a property key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to assert that `K` part of the set if `Person[K]` is of type `string`.
    If this is true, we keep `K`; otherwise, we filter the element of the set with
    `never`. With `never` being on the lefthand side of the object, the property gets
    dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And with that, we select only property keys that point to string values. There
    is one catch: optional string properties have a broader type than regular strings,
    as `undefined` is also included as a possible value. Using a union type ensures
    that optional properties are also kept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is making this type generic. We create a type `Select<O, T>`
    by replacing `Person` with `O` and `string` with `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This new helper type is versatile. We can use it to select properties of a
    certain type from our own object types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can also figure out, for example, which functions in the string prototype
    return a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'An inverse helper type `Remove<O, T>`, where we want to remove property keys
    of a certain type, is very similar to `Select<O, T>`. The only difference is to
    switch the condition and return `never` in the `true` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is especially helpful if you create a serializable version of your object
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By knowing that you can do conditional types while mapping out keys, you suddenly
    have access to a wide range of potential helper types. More about that in [Chapter 8](ch08.html#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Inferring Types in Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a class for object serialization, which removes all unserializable
    properties of an object like functions. If your object has a `serialize` function,
    the serializer takes the return value of the function instead of serializing the
    object on its own. How can you type that?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a recursive conditional type to modify the existing object type. For objects
    that implement `serialize`, use the `infer` keyword to pin the generic return
    type to a concrete type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serialization is the process of converting data structures and objects into
    a format that can be stored or transferred. Think of taking a JavaScript object
    and storing its data on disk, just to pick it up later by deserializing it again
    into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript objects can hold any type of data: primitive types like strings
    or numbers, as well as compound types like objects, and even functions. Functions
    are interesting as they don’t contain data but behavior: something that can’t
    be serialized well. One approach to serializing JavaScript objects is to get rid
    of functions entirely. And this is what we want to implement in this lesson.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a simple object type `Person`, which contains the usual subjects
    of data we want to store: a person’s name and age. It also has a `hello` method,
    which produces a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to serialize objects of this type. A `Serializer` class contains an
    empty constructor and a generic function `serialize`. Note that we add the generic
    type parameter to `serialize` and not to the class. That way, we can reuse `serialize`
    for different object types. The return type points to a generic type `Serialize<T>`,
    which will be the result of the serialization process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take care of the implementation later. For now let’s focus on the `Serialize<T>`
    type. The first idea that comes to mind is to just drop properties that are functions.
    We already defined a `Remove<O, T>` type in [Recipe 5.4](#ch05_removing_object_properties)
    that comes in handy, as it does exactly that—removes properties that are of a
    certain type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The first iteration is done, and it works for simple, one-level-deep objects.
    Objects can be complex, however. For example, `Person` could nest other objects,
    which in turn also could have functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this, we need to check each property if it is another object, and
    if so, use the `Serialize<T>` type again. A mapped type called `NestSerialization`
    checks in a conditional type if each property is of type `object` and returns
    a serialized version of that type in the `true` branch and the type itself in
    the `false` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We redefine `Serialize<T>` by wrapping the original `Remove<T, Function>` type
    of `Serialize<T>` in `NestSerialization`, effectively creating a *recursive type*:
    `Serialize<T>` uses `NestSerialization<T>` uses `Serialize<T>`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript can handle type recursion to a certain degree. In this case, it can
    see that there is literally a condition to break out of type recursion in `NestSerialization`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s serialization type! Now for the implementation of the function,
    which is curiously a straight translation of our type declaration in JavaScript.
    We check for every property if it’s an object. If so, we call `serialize` again.
    If not, we carry over the property only if it isn’t a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that since we are generating a new object within `serialize`, we start
    out with a very broad `Record<string, any>`, which allows us to set any string
    property key to basically anything, and assert at the end that we created an object
    that fits our return type. This pattern is common when you create new objects,
    but it ultimately requires you to be 100% sure that you did everything right.
    Please test this function extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the first implementation done, we can create a new object of type `Person`
    and pass it to our newly generated serializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as expected: the type of `serializedPerson` lacks all information
    on methods and functions. And if we log `serializedPerson`, we also see that all
    methods and functions are gone. The type matches the implementation result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'But we are not done yet. The serializer has a special feature. Objects can
    implement a `serialize` method, and if they do, the serializer takes the output
    of this method instead of serializing the object on its own. Let’s extend the
    `Person` type to feature a `serialize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We need to adapt the `Serialize<T>` type. Before running `NestSerialization`,
    we check in a conditional type if the object implements a `serialize` method.
    We do so by asking if `T` is a subtype of a type that contains a `serialize` method.
    If so, we need to get to the return type, because that’s the result of serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `infer` keyword comes into play. It allows us to take a type
    from a condition and use it as a type parameter in the `true` branch. We tell
    TypeScript, if this condition is true, take the type that you found there and
    make it available to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Think of `R` as being `any` at first. If we check `Person` against `{ serialize():
    any }` we hop into the `true` branch, as `Person` has a `serialize` function,
    making it a valid sub-type. But `any` is broad, and we are interested in the specific
    type at the position of `any`. The `infer` keyword can pick that exact type. So
    `Serialize<T>` now reads:'
  prefs: []
  type: TYPE_NORMAL
- en: If `T` contains a `serialize` method, get its return type and return it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, start serialization by deeply removing all properties that are of
    type `Function`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We want to mirror that type’s behavior in our JavaScript implementation as
    well. We do a couple of type-checks (checking if `serialize` is available and
    if it’s a function) and ultimately call it. TypeScript requires us to be explicit
    with type guards, to be absolutely sure that this function exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, the type of `serializedPerson` is `string`, and the result
    is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This powerful tool helps greatly with object generation. And there’s beauty
    in the fact that we create a type using a declarative metalanguage that is TypeScript’s
    type system, to ultimately see the same process imperatively written in JavaScript.
  prefs: []
  type: TYPE_NORMAL
