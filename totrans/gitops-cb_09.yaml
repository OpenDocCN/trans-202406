- en: Chapter 8\. Advanced Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you had an overview of implementing GitOps workflows
    using Argo CD recipes. Argo CD is a famous and influential open source project
    that helps with both simple use cases and more advanced ones. In this chapter,
    we will discuss topics needed when you move forward in your GitOps journey, and
    you need to manage security, automation, and advanced deployment models for multicluster
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Security is a critical aspect of automation and DevOps. DevSecOps is a new definition
    of an approach where security is a shared responsibility throughout the entire
    IT lifecycle. Furthermore, the [DevSecOps Manifesto](https://www.devsecops.org)
    specifies security as code to operate and contribute value with less friction.
    And this goes in the same direction as GitOps principles, where everything is
    declarative.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, this also poses the question of avoiding storing unencrypted
    plain-text credentials in Git. As stated in the book *Path to GitOps* by Christian
    Hernandez, Argo CD luckily currently provides two patterns to manage security
    in GitOps workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing encrypted secrets in Git, such as with a Sealed Secret (see [Recipe
    8.1](#recipe_8_1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing secrets in external services or vaults, then storing only the reference
    to such secrets in Git (see [Recipe 8.2](#recipe_8_2))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter then moves to advanced deployment techniques, showing how to manage
    webhooks with Argo CD (see [Recipe 8.3](#recipe_8_3)) and with ApplicationSets
    (see [Recipe 8.4](#recipe_8_4)). ApplicationSets is a component of Argo CD that
    allows management deployments of many applications, repositories, or clusters
    from a single Kubernetes resource. In essence, a templating system for the GitOps
    application is ready to be deployed and synced in multiple Kubernetes clusters
    (see [Recipe 8.5](#recipe_8_5)).
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, the book ends with a recipe on Progressive Delivery for
    Kubernetes with Argo Rollouts ([Recipe 8.6](#recipe_8_6)), useful for deploying
    the application using an advanced deployment technique such as blue-green or canary.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Encrypt Sensitive Data (Sealed Secrets)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to manage Kubernetes Secrets and encrypted objects in Git.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Sealed Secrets](https://oreil.ly/MWTNB) is an open source project by Bitnami
    used to encrypt a Kubernetes Secrets into a `SealedSecret` Kubernetes Custom Resource,
    representing an encrypted object safe to store in Git.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed Secrets uses public-key cryptography and consists of two main components:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes controller that has knowledge about the private and public key
    used to decrypt and encrypt encrypted secrets and is responsible for reconciliation.
    The controller also supports automatic secret rotation for the private key and
    key expiration management in order to enforce the re-encryption of secrets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubeseal`, a CLI used by developers to encrypt their secrets before committing
    them to a Git repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SealedSecret` object is encrypted and decrypted only by the `SealedSecret`
    controller running in the target Kubernetes cluster. This operation is exclusive
    only to this component, thus nobody else can decrypt the object. The `kubeseal`
    CLI allows the developer to take a normal Kubernetes Secret resource and convert
    it to a `SealedSecret` resource definition as shown in [Figure 8-1](#fig8-1).
  prefs: []
  type: TYPE_NORMAL
- en: In your Kubernetes cluster with Argo CD, you can install the `kubeseal` CLI
    for your operating system from the [GitHub project’s releases](https://oreil.ly/zmEh3).
    At the time of writing this book, we are using version 0.18.2.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'On macOS, `kubeseal` is available through [Homebrew](https://brew.sh) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![Sealed Secrets with GitOps](assets/gocb_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Sealed Secrets with GitOps
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After you install the CLI, you can install the controller as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, let’s create a Secret for the Pac-Man game deployed in [Chapter 5](ch05.xhtml#ch_Helm):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And here you can see the YAML representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can convert the Secret into a `SealedSecret` in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you find the data encrypted by the Sealed Secrets controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can safely push your `SealedSecret` to your Kubernetes manifests repo
    and create the Argo CD application. Here’s an example from [this book’s repository](https://oreil.ly/TXHRa):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if the app is running and healthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 8.2 Encrypt Secrets with ArgoCD (ArgoCD + HashiCorp Vault + External Secret)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to avoid storing credentials in Git and you want to manage them in
    external services or vaults.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Recipe 8.1](#recipe_8_1) you saw how to manage encrypted data in Git following
    the GitOps declarative way, but how do you avoid storing even encrypted credentials
    with GitOps?
  prefs: []
  type: TYPE_NORMAL
- en: One solution is [External Secrets](https://oreil.ly/ytBeU), an open source project
    initially created by GoDaddy, which aims at storing secrets in external services
    or vaults from different vendors, then storing only the reference to such secrets
    in Git.
  prefs: []
  type: TYPE_NORMAL
- en: Today, External Secrets supports systems such as AWS Secrets Manager, HashiCorp
    Vault, Google Secrets Manager, Azure Key Vault, and more. The idea is to provide
    a user-friendly abstraction for the external API that stores and manages the lifecycles
    of the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: In depth, ExternalSecrets is a Kubernetes controller that reconciles Secrets
    into the cluster from a Custom Resource that includes a reference to a secret
    in an external key management system. The Custom Resource `SecretStore` specifies
    the backend containing the confidential data, and how it should be transformed
    into a Secret by defining a template, as you can see in [Figure 8-2](#fig8-2).
    The SecretStore has the configuration to connect to the external secret manager.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the `ExternalSecrets` objects can be safely stored in Git, as they do
    not contain any confidential information, but just the references to the external
    services managing credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '![External Secrets with Argo CD](assets/gocb_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. External Secrets with Argo CD
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can install External Secrets with a Helm Chart as follows. At the time
    of writing this book, we are using version 0.5.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In order to begin using ExternalSecrets, you will need to set up a SecretStore
    or ClusterSecretStore resource (for example, by creating a *vault* SecretStore).
  prefs: []
  type: TYPE_NORMAL
- en: More information on the different types of SecretStores and how to configure
    them can be found in our [GitHub page](https://oreil.ly/LQzEh).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also install the External Secrets Operator with OLM from [OperatorHub.io](https://oreil.ly/w3x71).
  prefs: []
  type: TYPE_NORMAL
- en: As an example with one of the providers supported, such as [HashiCorp Vault](https://oreil.ly/sg7yS),
    you can do the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'First download and install [HashiCorp Vault](https://oreil.ly/vjGSq) for your
    operating system and get your [Vault Token](https://oreil.ly/6Y5cS). Then create
    a Kubernetes Secret as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a `SecretStore` as a reference to this external system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Hostname where your Vault is running
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Kubernetes Secret containing the vault token
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_topics_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key to address the value in the Kubernetes Secret containing the vault token
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create a Secret in your Vault as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And then reference it from the `ExternalSecret` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can deploy the Pac-Man game with Argo CD using External Secrets as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 8.3 Trigger the Deployment of an Application Automatically (Argo CD Webhooks)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t want to wait for Argo CD syncs and you want to immediately deploy
    an application when a change occurs in Git.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Argo CD polls Git repositories every three minutes to detect changes to
    the monitored Kubernetes manifests, it also supports an event-driven approach
    with webhooks notifications from popular Git servers such as GitHub, GitLab, or
    Bitbucket.
  prefs: []
  type: TYPE_NORMAL
- en: '[Argo CD Webhooks](https://oreil.ly/3Ab46) are enabled in your Argo CD installation
    and available at the endpoint `/api/webhooks`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test webhooks with Argo CD using Minikube you can use Helm to install a
    local Git server such as [Gitea](https://docs.gitea.io), an open source lightweight
    server written in Go, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Log in to the Gitea server with the default credentials you find the in the
    *values.yaml* file from the Helm Chart [here](https://oreil.ly/Nkaeu) or define
    new ones via overriding them.
  prefs: []
  type: TYPE_NORMAL
- en: Import the [Pac-Man](https://oreil.ly/LwTaC) manifests repo into Gitea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the Argo app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a webhook to Gitea, navigate to the top-right corner and click Settings.
    Select the Webhooks tab and configure it as shown in [Figure 8-3](#fig8-3):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Payload URL: `http://localhost:9090/api/webhooks`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Content type: `application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Gitea Webhooks](assets/gocb_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Gitea Webhooks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can omit the Secret for this example; however, it’s best practice to configure
    secrets for your webhooks. Read more from the [docs](https://oreil.ly/udDkS).
  prefs: []
  type: TYPE_NORMAL
- en: Save it and push your change to the repo on Gitea. You will see a new sync from
    Argo CD immediately after your push.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Deploy to Multiple Clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy an application to different clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Argo CD supports the `ApplicationSet` resource to “templetarize” an Argo CD
    `Application` resource. It covers different use cases, but the most important
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a Kubernetes manifest to target multiple Kubernetes clusters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy multiple applications from one or multiple Git repositories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the `ApplicationSet` is a template file with placeholders to substitute
    at runtime, we need to feed these with some values. For this purpose, `ApplicationSet`
    has the concept of *generators*.
  prefs: []
  type: TYPE_NORMAL
- en: A generator is responsible for generating the parameters, which will finally
    be replaced in the template placeholders to generate a valid Argo CD `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `ApplicationSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a generator
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the value of the parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_topics_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the `Application` resource as a template
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_topics_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`cluster` placeholder'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_topics_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: '`url` placeholder'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the previous file by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When this `ApplicationSet` is applied to the cluster, Argo CD generates and
    automatically registers two `Application` resources. The first one is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the creation of both `Application` resources by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output should be similar to (trunked):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete both applications by deleting the `ApplicationSet` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen the simplest generator, but there are eight generators in total
    at the time of writing this book:'
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs: []
  type: TYPE_NORMAL
- en: Generates `Application` definitions through a fixed list of clusters. (It’s
    the one we’ve seen previously).
  prefs: []
  type: TYPE_NORMAL
- en: Cluster
  prefs: []
  type: TYPE_NORMAL
- en: Similar to *List* but based on the list of clusters defined in Argo CD.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs: []
  type: TYPE_NORMAL
- en: Generates `Application` definitions based on a JSON/YAML properties file within
    a Git repository or based on the directory layout of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: SCM Provider
  prefs: []
  type: TYPE_NORMAL
- en: Generates `Application` definitions from repositories within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Pull Request
  prefs: []
  type: TYPE_NORMAL
- en: Generates `Application` definitions from open pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Decision Resource
  prefs: []
  type: TYPE_NORMAL
- en: Generates `Application` definitions using [duck-typing](https://oreil.ly/kpRkV).
  prefs: []
  type: TYPE_NORMAL
- en: Matrix
  prefs: []
  type: TYPE_NORMAL
- en: Combines values of two separate generators.
  prefs: []
  type: TYPE_NORMAL
- en: Merge
  prefs: []
  type: TYPE_NORMAL
- en: Merges values from two or more generators.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we created the `Application` objects from a fixed list
    of elements. This is fine when the number of configurable environments is small;
    in the example, two clusters refer to two Git folders (`ch08/bgd-gen/staging`
    and `ch08/bgd-gen/prod`). In the case of multiple environments (which means various
    folders), we can dynamically use the *Git* generator to generate one `Application`
    per directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s migrate the previous example to use the Git generator. As a reminder,
    the Git directory layout used was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file of type `ApplicationSet` generating an `Application` for
    each directory of the configured Git repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Configures the Git repository to read layout
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Initial path to start scanning directories
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_topics_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Application` definition'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_topics_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The directory paths within the Git repository matching the path wildcard (`staging`
    or `prod`)
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_topics_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Directory path (full path)
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_advanced_topics_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The rightmost pathname
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Argo CD creates two applications as there are two directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, this generator is handy when your application is composed of different
    components (service, database, distributed cache, email server, etc.), and deployment
    files for each element are placed in other directories. Or, for example, a repository
    with all operators required to be installed in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Instead of reacting to directories, Git generator can create `Application` objects
    with parameters specified in JSON/YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an example JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an excerpt of the `ApplicationSet` to react to these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Finds all *config.json* files placed in all subdirectories of the `app`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects the value set in *config.json*
  prefs: []
  type: TYPE_NORMAL
- en: This `ApplicationSet` will generate one `Application` for each *config.json*
    file in the folders matching the `path` expression.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Argo CD Generators](https://oreil.ly/EnOfl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Duck Types](https://oreil.ly/tEFQW)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5 Deploy a Pull Request to a Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy a preview of the application when a pull request is created.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the *pull request* generator to automatically discover open pull requests
    within a repository and create an `Application` object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an `ApplicationSet` reacting to any GitHub pull request annotated
    with the `preview` label created on the configured repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named *bgd-pr-application-set.yaml* with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub pull request generator
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Organization/user
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_topics_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_topics_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Select the target PRs
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_topics_CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Polling time in seconds to check if there is a new PR (60 seconds)
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_advanced_topics_CO6-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the name with branch name and number
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_advanced_topics_CO6-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the Git SHA number
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the previous file by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you list the Argo CD applications, you’ll see that none are registered.
    The reason is there is no pull request yet in the repository labeled with `preview`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Create a pull request against the repository and label it with `preview`.
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub, the pull request window should be similar to [Figure 8-4](#fig-851).
  prefs: []
  type: TYPE_NORMAL
- en: '![Pull request in GitHub](assets/gocb_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. Pull request in GitHub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Wait for one minute until the `ApplicationSet` detects the change and creates
    the `Application` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to inspect that the change has been detected and
    registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the registration of the `Application` to the pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `Application` object is automatically removed when the pull request is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the following pull request providers are
    supported:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitbucket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gitea
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ApplicationSet controller polls every `requeueAfterSeconds` interval to
    detect changes but also supports using webhook events.
  prefs: []
  type: TYPE_NORMAL
- en: To configure it, follow [Recipe 8.3](#recipe_8_3), but also enable sending pull
    requests events too in the Git provider.
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Use Advanced Deployment Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy the application using an advanced deployment technique such
    as blue-green or canary.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the [Argo Rollouts](https://oreil.ly/g4mlf) project to roll out updates
    to an application.
  prefs: []
  type: TYPE_NORMAL
- en: Argo Rollouts is a Kubernetes controller providing advanced deployment techniques
    such as blue-green, canary, mirroring, dark canaries, traffic analysis, etc. to
    Kubernetes. It integrates with many Kubernetes projects like Ambassador, Istio,
    AWS Load Balancer Controller, NGNI, SMI, or Traefik for traffic management, and
    projects like Prometheus, Datadog, and New Relic to perform analysis to drive
    progressive delivery.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Argo Rollouts to the cluster, run the following command in a terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Although it’s not mandatory, we recommend you install the Argo Rollouts Kubectl
    Plugin to visualize rollouts. Follow the [instructions](https://oreil.ly/1GWsz)
    to install it. With everything in place, let’s deploy the initial version of the
    BGD application.
  prefs: []
  type: TYPE_NORMAL
- en: Argo Rollouts doesn’t use the standard Kubernetes `Deployment` file, but a specific
    new Kubernetes resource named `Rollout`. It’s like a `Deployment` object, hence
    all its options are supported, but it adds some fields to configure the rolling
    update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s deploy the first version of the application. We’ll define the canary
    release process when Kubernetes executes a rolling update, which in this case
    follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Forward 20% of traffic to the new version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until a human decides to proceed with the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Forward 40%, 60%, 80% of the traffic to the new version automatically, waiting
    30 seconds between every increase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new file named *bgd-rollout.yaml* with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Canary release
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: List of steps to execute
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_topics_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the ratio of canary
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_topics_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Rollout is paused
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_topics_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Pauses the rollout for 30 seconds
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_advanced_topics_CO7-6)'
  prefs: []
  type: TYPE_NORMAL
- en: '`template` Deployment definition'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the resource to deploy the application. Since there is no previous deployment,
    the canary part is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, there are five pods as specified in the `replicas` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And using the Argo Rollout Kubectl Plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s deploy a new version to trigger a canary rolling update. Create a new
    file named *bgd-rollout-v2.yaml* with exactly the same content as the previous
    one, but change the environment variable `COLOR` value to `green`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the previous resource and check how Argo Rollouts executes the rolling
    update. List the pods again to check that 20% of the pods are new while the other
    80% are the old version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New version pod
  prefs: []
  type: TYPE_NORMAL
- en: 'And do the same using the Argo Rollout Kubectl Plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the rolling update process is paused until the operator executes
    a manual step to let the process continue. In a terminal window, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The rollout is promoted and continues with the following steps, which is substituting
    the old version pods with new versions every 30 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The rolling update finishes with the new version progressively deployed to the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes doesn’t implement advanced deployment techniques natively. For this
    reason, Argo Rollouts uses the number of deployed pods to implement the canary
    release.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, Argo Rollouts integrates with Kubernetes products that
    offer advanced traffic management capabilities like [Istio](https://istio.io).
  prefs: []
  type: TYPE_NORMAL
- en: Using Istio, the traffic splitting is done correctly at the infrastructure level
    instead of playing with replica numbers like in the first example. Argo Rollouts
    integrates with Istio to execute a canary release, automatically updating the
    Istio `VirtualService` object.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you already know Istio and have a Kubernetes cluster with Istio installed,
    you can perform integration between Argo Rollouts and Istio by setting the `trafficRouting`
    from `Rollout` resource to `Istio`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `Rollout` file with Istio configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Canary section
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to a Kubernetes Service pointing to the new service version
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_topics_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to a Kubernetes Service pointing to the old service version
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_advanced_topics_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Configures Istio
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_advanced_topics_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to the `VirtualService` where weight is updated
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_advanced_topics_CO9-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the `VirtualService`
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_advanced_topics_CO9-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Route name within `VirtualService`
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_advanced_topics_CO9-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Deploys the Istio sidecar container
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create two Kubernetes Services pointing to the same deployment used
    to redirect traffic to the old or the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Kubernetes Service is used in the `stableService` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And the Canary one is the same but with a different name. It’s the one used
    in the `canaryService` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create the Istio Virtual Service to be updated by Argo Rollouts to
    update the canary traffic for each service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_advanced_topics_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Stable Kubernetes Service
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_advanced_topics_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Canary Kubernetes Service
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_advanced_topics_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Route name
  prefs: []
  type: TYPE_NORMAL
- en: 'After applying these resources, we’ll get the first version of the application
    up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When any update occurs on the `Rollout` object, the canary release will start
    as described in the Solution. Now, Argo Rollouts updates the *bgd virtual service*
    weights automatically instead of playing with pod numbers.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Argo Rollouts - Kubernetes Progressive Delivery Controller](https://oreil.ly/XQ64b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Istio - Argo Rollouts](https://oreil.ly/lKDYH)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Istio](https://istio.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Istio Tutorial from Red Hat](https://oreil.ly/Vzk9G)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
