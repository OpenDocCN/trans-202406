- en: Chapter 7\. Kubernetes Power Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My mechanic told me, “I couldn’t repair your brakes, so I made your horn louder.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Steven Wright
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: People always ask us, “What about all these Kubernetes tools? Do I need them?
    If so, which ones? And what do they all do?”
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore a small part of the landscape of tools and utilities
    that help you work with Kubernetes. We’ll show you some advanced techniques with
    `kubectl`, and a few useful utilities such as `jq`, `kubectx`/`kubens`, `kube-ps1`,
    Click, `kubed-sh`, Stern, and BusyBox.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already met `kubectl`, starting in [Chapter 2](ch02.html#firststeps),
    and as it’s the primary tool for interacting with Kubernetes, you may already
    be comfortable with the basics. Let’s look at some more advanced features of `kubectl`
    now, including some tips and tricks that may be new to you.
  prefs: []
  type: TYPE_NORMAL
- en: Shell Aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the first things that most Kubernetes users do to make their lives easier
    is to create a shell alias for the `kubectl` command. For example, we have the
    following alias set up in our *.bash_profile* or *.zshrc* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of having to type out `kubectl` in full for every command, we can just
    use `k`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are some `kubectl` commands that you use a lot, you might like to
    create aliases for them too. Here are some possible examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Google engineer Ahmet Alp Balkan has worked out a logical [system of aliases](https://oreil.ly/KoGV0)
    like these, and created a script to generate them all for you (currently around
    eight hundred aliases).
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to use those, though; we suggest you start with `k`, and add
    aliases that are memorable to you, for the commands you use most frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Using Short Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like most command-line tools, `kubectl` supports abbreviated forms of many of
    its flags and switches. This can save you a lot of typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can abbreviate the `--namespace` flag to just `-n` (see [“Using
    Namespaces”](ch05.html#namespaces)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s very common to have `kubectl` operate on resources matching a set of labels,
    with the `--selector` flag (see [“Labels”](ch09.html#labels)). Fortunately, this
    can be shortened to `-l` (`labels`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Abbreviating Resource Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common use for `kubectl` is to list resources of various types, such as Pods,
    Deployments, Services, and namespaces. The usual way to do this is to use `kubectl
    get` followed by, for example, `deployments`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To speed this up, `kubectl` supports short forms of these resource types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Other useful abbreviations include `no` for `nodes`, `cm` for `configmaps`,
    `sa` for `serviceaccounts`, `ds` for `daemonsets`, and `pv` for `persistentvolumes`.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Completing kubectl Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re using the `bash` or `zsh` shells, you can have them auto-complete
    `kubectl` commands. Run this command to see instructions on how to enable auto-completion
    for your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the instructions, and you should be able to press Tab to complete partial
    `kubectl` commands. Try it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The command should complete to `kubectl cluster-info`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type just `kubectl` and hit Tab twice, you’ll see all the commands available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the same technique to list all the flags that you can use with
    the current command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Usefully, `kubectl` will also auto-complete the names of Pods, Deployments,
    namespaces, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Getting Help
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best command-line tools include thorough documentation, and `kubectl` is
    no exception. You can get a complete overview of the available commands with `kubectl
    -h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can go further and get detailed documentation on each command, with all
    the available options, and a set of examples, by typing `kubectl COMMAND -h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Getting Help on Kubernetes Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as documenting itself, `kubectl` can also give you help on Kubernetes
    objects, such as Deployments or Pods. The `kubectl explain` command will show
    documentation on the specified type of resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get further information on a specific field of a resource, with `kubectl
    explain RESOURCE.FIELD`. In fact, you can drill down as far as you like with `explain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Showing More Detailed Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know that `kubectl get` will list resources of various types, such
    as Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see extra information, such as the node each Pod is running on, by
    using the `-o wide` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (We’ve omitted the information that you see without `-o wide`, just for reasons
    of space.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the resource type, `-o wide` will show you different information.
    For example, with nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Working with JSON Data and jq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default output format for `kubectl get` is plain text, but it can also
    print information in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Not surprisingly, this produces a lot of output (about five thousand lines on
    our cluster). Fortunately, because the output is in the widely used JSON format,
    you can use other tools to filter it, such as the invaluable `jq`.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have [`jq`](https://stedolan.github.io/jq) already, you can [install
    it](https://stedolan.github.io/jq/download) in the usual way for your system (`brew
    install jq` for macOS, `apt install jq` for Debian/Ubuntu, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve got `jq` installed, you can use it to query and filter `kubectl
    output`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`jq` is a very powerful tool for querying and transforming JSON data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to list your busiest nodes by the number of Pods running on each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There’s a handy [online playground](https://jqplay.org) for `jq` where you can
    paste in JSON data and try out different `jq` queries to get the exact result
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t have access to `jq`, `kubectl` also supports [JSONPath queries](https://oreil.ly/s7xIv).
    JSONPath is a JSON query language that isn’t quite as powerful as `jq`, but useful
    for quick one-liners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Watching Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re waiting for a bunch of Pods to start up, it can be annoying to have
    to keep typing `kubectl get pods...` every few seconds to see if anything’s happened.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` provides the `--watch` flag (`-w` for short) to save you having to
    do this. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Every time the status of one of the matching Pods changes, you’ll see an update
    in your terminal. (See [“Watching Kubernetes Resources with kubespy”](#kubespy)
    for a neat way to watch any kind of resource.)
  prefs: []
  type: TYPE_NORMAL
- en: Describing Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For really detailed information about Kubernetes objects, you can use the `kubectl
    describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Events` section can be particularly useful for troubleshooting containers
    that aren’t working properly, as it records each stage of the container’s life
    cycle, along with any errors that occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you’ve used `kubectl` mostly for querying or listing things, as well
    as applying declarative YAML manifests with `kubectl apply`. However, `kubectl`
    also has a complete set of *imperative* commands: operations that create or modify
    resources directly.'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative kubectl Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We showed one example of this in [“Running the Demo App”](ch02.html#runningdemo),
    using the `kubectl run` command, which implicitly creates a Pod to run the specified
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also explicitly create most resources using `kubectl create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, `kubectl delete` will delete a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kubectl edit` command gives you the power to view and modify any resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will open your default editor with a YAML manifest file representing the
    specified resource.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good way to get a detailed look at the configuration of any resource,
    but you can also make any changes you like in the editor. When you save the file
    and quit the editor, `kubectl` will update the resource, exactly as though you
    had run `kubectl apply` on the manifest file for the resource.
  prefs: []
  type: TYPE_NORMAL
- en: If you introduced any errors, such as invalid YAML, `kubectl` will tell you
    and reopen the file for you to fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Use Imperative Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book we’ve emphasized the importance of using *declarative*
    infrastructure as code. So it shouldn’t come as a surprise that we don’t recommend
    you use imperative `kubectl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Although they can be very useful for quickly testing things or trying out ideas,
    the major problem with imperative commands is that you have no single *source
    of truth*. There’s no way to know who ran what imperative commands on the cluster
    at what time, and what the effect was. As soon as you run any imperative command,
    the state of the cluster becomes out of sync with the manifest files stored in
    version control.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next time someone applies the YAML manifests, whatever changes you made
    imperatively will be overwritten and lost. This can lead to surprising results,
    and potentially adverse effects on critical services:'
  prefs: []
  type: TYPE_NORMAL
- en: Alice is on-call, when suddenly there is a large increase in load on the service
    she is managing. Alice uses the `kubectl scale` command to increase the number
    of replicas from 5 to 10\. Several days later, Bob edits the YAML manifests in
    version control to use a new container image, but he doesn’t notice that the number
    of replicas in the file is currently 5, not the 10 that are active in production.
    Bob proceeds with the rollout, which cuts the number of replicas by half, causing
    an immediate overload or outage.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kelsey Hightower et al., *Kubernetes Up & Running*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alice forgot to update the files in version control after she made her imperative
    change, but that’s easy to do, especially under the stress of an incident (see
    [“On-Call Should Not Be Hell”](ch16.html#on-call)). Real life doesn’t always follow
    best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, before reapplying the manifest files, Bob should have checked the
    diff using `kubectl diff` (see [“Diffing Resources”](#diffing)) to see what would
    change. But if you’re not expecting something to be different, it’s easy to overlook
    it. And maybe Bob hasn’t read this book.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to avoid this kind of problem is to always make changes by editing
    and applying the resource files under version control. We will cover this more
    in [“GitOps”](ch14.html#gitops) later on.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don’t use `kubectl` imperative commands such as `create` or `edit` on production
    clusters. Instead, always manage resources with version-controlled YAML manifests,
    applied with `kubectl apply` (or Helm charts).
  prefs: []
  type: TYPE_NORMAL
- en: Generating Resource Manifests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though we don’t recommend using `kubectl` in imperative mode to make changes
    to your cluster, imperative commands can be a great time-saver when creating Kubernetes
    YAML files from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than typing a lot of boilerplate into an empty file, you can use `kubectl`
    to give you a head start by generating the YAML manifest for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `--dry-run=client` flag tells `kubectl` not to actually create the resource,
    but merely to print out what it would have created. The `-o yaml` flag gives you
    the resource manifest in YAML format. The `>` character writes the output of the
    command to a file that you can then use to make any edits, and finally apply it
    to create the resource in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as helping you create new resource manifests, `kubectl` can also produce
    manifest files for resources that already exist in the cluster. For example, maybe
    you created a Deployment using imperative commands (`kubectl create`), edited
    and adjusted it to get the settings just right, and now you want to write a declarative
    YAML manifest for it that you can add to version control.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, use the `-o` flag with `kubectl get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This output will contain some extra information, like the `status` section that
    you can remove (before saving with your other manifests), update, and apply with
    `kubectl apply -f`.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been using imperative `kubectl` commands to manage your cluster up
    to now, and you’d like to switch to the declarative style that we recommend in
    this book, this is a great way to do it. Export all the resources in your cluster
    to manifest files using `kubectl` with the `-o` flag, as shown in the example,
    and you’ll be all set.
  prefs: []
  type: TYPE_NORMAL
- en: Diffing Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you apply Kubernetes manifests using `kubectl apply`, it’s very useful
    to be able to see exactly what would change on the cluster. The `kubectl diff`
    command will do this for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can use this `diff` output to check whether the changes you made will actually
    have the effect you expected. Also, it will warn you if the state of the live
    resource is out of sync with the YAML manifest, perhaps because someone edited
    it imperatively since you last applied it.
  prefs: []
  type: TYPE_NORMAL
- en: Best Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use `kubectl diff` to check what would change before applying any updates to
    your production cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of what goes on in a Kubernetes cluster happens inside containers, so when
    things go wrong, it can be hard to see what’s happening. Here are a few useful
    ways to work with running containers using `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing a Container’s Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re trying to get a container working and it’s not behaving as it should,
    one of the most useful sources of information is the container’s *logs*. In Kubernetes,
    logs are considered to be whatever a container writes to the *standard output*
    and *standard error* streams; if you were running the program in a terminal, these
    are what you would see printed in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: In production applications, especially distributed ones, you’ll need to be able
    to aggregate logs from multiple services, store them in a persistent database,
    and query and graph them. This is a big topic, and one we’ll treat in much more
    detail in [Chapter 15](ch15.html#observability).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the log messages from specific containers is still a very useful
    troubleshooting technique, though, and you can do this directly with `kubectl
    logs`, followed by the name of a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Most long-running containers will generate a *lot* of log output, so you’ll
    usually want to restrict it to just the most recent lines, using the `--tail`
    flag, as in this example. (The container logs will be shown with timestamps, but
    we’ve trimmed those here to fit the messages on the page.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To watch a container as it’s running, and stream its log output to your terminal,
    use the `--follow` flag (`-f` for short):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As long as you leave the `kubectl logs` command running with the `--follow`
    flag, you’ll continue to see any new output from the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: It can be particularly useful to view the Kubernetes API server’s logs; for
    example, if you have RBAC permission errors (see [“Introducing Role-Based Access
    Control (RBAC)”](ch11.html#rbac)), they’ll show up here. If you have access to
    your control plane nodes, you can find the `kube-apiserver` Pod in the `kube-system`
    namespace and use `kubectl logs` to see its output.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a managed service, where the control plane nodes are not visible
    to you, check your provider’s documentation to see how to find the control plane
    logs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When there are multiple containers in a Pod, you can specify which one you
    want to see the logs for using the `--container` flag (`-c` for short):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For more sophisticated log watching, you may want to use a dedicated tool like
    Stern instead (see [“Stern”](#stern)).
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to a Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When looking at the logs of a container isn’t enough, you might need to attach
    your local terminal to the container instead. This lets you see the container’s
    output directly. To do this, use `kubectl attach`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Watching Kubernetes Resources with kubespy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you deploy changes to your Kubernetes manifests, there’s often an anxious
    period of waiting to see what happens next.
  prefs: []
  type: TYPE_NORMAL
- en: Often when you deploy an application, lots of things need to happen behind the
    scenes, as Kubernetes creates your resources, spins up Pods, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Because this happens *automagically*, as engineers like to say, it can be difficult
    to tell what’s going on. `kubectl get` and `kubectl describe` can give you snapshots
    of individual resources, but what we’d really like is a way to see the state of
    Kubernetes resources changing in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Enter [kubespy](https://oreil.ly/YqyBk), a neat tool from the Pulumi project.^([1](ch07.html#idm45979385899936))
    kubespy can watch an individual resource in the cluster and show you what’s happening
    to it over time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you point kubespy at a Service resource, it will show you when
    the Service is created, when it’s allocated an IP address, when its endpoints
    are connected, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Forwarding a Container Port
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve used `kubectl port-forward` before, in [“Running the Demo App”](ch02.html#runningdemo),
    to forward a Kubernetes Service to a port on your local machine. But you can also
    use it to forward a container port, if you want to connect directly to a specific
    Pod. Just specify the Pod name and the local and remote ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now port 9999 on your local machine will be forwarded to port 8888 on the container,
    and you can connect to it with a web browser, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Executing Commands on Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The isolated nature of containers is great when you want to run reliable, secure
    workloads. But it can be a little inconvenient when something’s not working right,
    and you can’t see why.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re running a program on your local machine and it misbehaves, you
    have the power of the command line at your disposal to troubleshoot it: you can
    look at the running processes with `ps`, list and display files with `ls` and
    `cat`, and even edit the files directly with a text editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Very often, with a malfunctioning container, it would be useful to have a shell
    running in the container so that we can do this kind of interactive debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `kubectl exec` command, you can run a specified command in any container,
    including a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If the Pod has more than one container in it, `kubectl exec` will run the command
    in the first container by default. Alternatively, you can specify the container
    with the `-c` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: (If the container doesn’t have a shell, see [“Adding BusyBox to Your Containers”](#addingbusybox).)
  prefs: []
  type: TYPE_NORMAL
- en: Running Containers for Troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to running commands on an existing container, sometimes it’s handy
    to be able to run commands like `wget` or `nslookup` in the cluster, to see the
    results that your application would get. You’ve already learned how to run containers
    in the cluster with `kubectl run`, but here are a few useful examples of running
    one-off container commands for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s run an instance of the demo application to test against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `demo` service should have been allocated an IP address and a DNS name
    of `demo` that is accessible from inside the cluster. Let’s check that, using
    the `nslookup` command running inside a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Good news: the DNS name works, so we should be able to make an HTTP request
    to it using `wget` and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that this pattern of `kubectl run` commands uses a common set of
    flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What do these do?
  prefs: []
  type: TYPE_NORMAL
- en: '`--rm`'
  prefs: []
  type: TYPE_NORMAL
- en: This tells Kubernetes to delete the resources created in this command for attached
    containers so that it doesn’t clutter up your nodes’ local storage.
  prefs: []
  type: TYPE_NORMAL
- en: '`-it`'
  prefs: []
  type: TYPE_NORMAL
- en: This runs the container interactively (`i`), via a terminal (`t`), so that you
    see the output from the container in your own terminal, and can send keystrokes
    to it if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: '`--restart=Never`'
  prefs: []
  type: TYPE_NORMAL
- en: This tells Kubernetes to skip its usual helpful behavior of restarting a container
    whenever it exits. Since we only want to run the container one time, we can disable
    the default restart policy.
  prefs: []
  type: TYPE_NORMAL
- en: '`--command --`'
  prefs: []
  type: TYPE_NORMAL
- en: This specifies a command to run, instead of the container’s default entrypoint.
    Everything following the `--` will be passed to the container as a command line,
    complete with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using BusyBox Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you can run any container available to you, the `busybox` image is
    particularly useful because it contains a wealth of the most commonly used Unix
    commands, such as `cat`, `echo`, `find`, `grep`, and `kill`. You can see a complete
    list of [BusyBox commands](https://oreil.ly/KiiEE) on their website.
  prefs: []
  type: TYPE_NORMAL
- en: 'BusyBox also includes a lightweight bash-like shell, called `ash`, which is
    compatible with standard `/bin/sh` shell scripts. So to get an interactive shell
    in your cluster, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the pattern for running commands from the BusyBox image is always the
    same, you could even make a shell alias for it (see [“Shell Aliases”](#shellaliases)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Adding BusyBox to Your Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your container already has a shell in it (for example, if it’s built from
    a Linux base image, such as `alpine`), then you can get shell access on the container
    by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: But what if there’s no */bin/sh* in the container? For example, if you’re using
    a minimal, scratch image as described in [“Understanding Dockerfiles”](ch02.html#multistagedockerfile).
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to make your containers easily debuggable, while keeping the
    images very small, is to copy the `busybox` executable into them at build time.
    It’s only 1 MiB, which is a small price to pay for having a usable shell and a
    set of Unix utilities.
  prefs: []
  type: TYPE_NORMAL
- en: You learned in the earlier discussion of multistage builds that you can copy
    a file from a previously built container into a new container using the Dockerfile
    `COPY --from` command. A lesser-known feature of this command is that you can
    also copy a file from any public image, not just one that you built locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Dockerfile shows how to do this with the demo image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `--from=busybox:1.28` references the public BusyBox library image.^([2](ch07.html#idm45979385568432))
    You could copy a file from any image you like (such as `alpine`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you still have a very small container, but you can also get a shell on
    it, by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Instead of executing `/bin/sh` directly, you execute `/bin/busybox` followed
    by the name of the command you want; in this case, `sh`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Programs on a Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need some programs that aren’t included in BusyBox, or aren’t available
    in a public container image, you can run a Linux image such as `alpine` or `ubuntu`
    instead, and install whatever you need on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that these temporary debugging containers would likely need to
    run as the root user in order to install new packages, and, once the container
    exits, any changes inside the container would be lost. This process would only
    be for one-off troubleshooting sessions, not something you should rely on for
    long-running applications that you want to stick around on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts and Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book we’ve been working with a single Kubernetes cluster, and
    all the `kubectl` commands you’ve run have naturally applied to that cluster.
  prefs: []
  type: TYPE_NORMAL
- en: So what happens when you have more than one cluster? For example, maybe you
    have a Kubernetes cluster on your machine for local testing and a production cluster
    in the cloud, and perhaps another remote cluster for staging and development.
    How does `kubectl` know which one you mean?
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, `kubectl` has *contexts*. A context is a combination
    of a cluster, a user, and a namespace (see [“Using Namespaces”](ch05.html#namespaces)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run `kubectl` commands, they’re always executed in the *current context*.
    Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These are the contexts `kubectl` currently knows about. Each context has a name,
    and refers to a particular cluster, a username that authenticates to the cluster,
    and a namespace within the cluster. The `docker-for-desktop` context, as you might
    expect, refers to my local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current context is shown with a `*` in the first column (in the example,
    it’s `docker-for-desktop`). If I run a `kubectl` command now, it will operate
    on the Docker Desktop cluster, in the default namespace (because the `NAMESPACE`
    column is blank, indicating that the context refers to the default namespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can switch to another context using the `kubectl config use-context` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You could think of contexts as being like bookmarks: they let you switch easily
    to a particular cluster and a particular namespace. To create a new context, use
    `kubectl config set-context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever you switch to the `myapp` context, your current context will be
    the `myapp` namespace on the Docker Desktop cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget what your current context is, `kubectl config current-context`
    will tell you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: kubeconfig files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These contexts for different Kubernetes clusters are stored by default in a
    file (or multiple files) typically located at *~/.kube/config* on your machine.
    This can be customized using the `KUBECONFIG` environment variable if you wish
    to use a different path per the docs on managing kubeconfig files found [here](https://oreil.ly/lZ0Lc).
  prefs: []
  type: TYPE_NORMAL
- en: kubectx and kubens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If, like us, you type for a living, you probably don’t like typing any more
    keystrokes than you have to. For faster switching of `kubectl` contexts, you can
    use the `kubectx` and `kubens` tools. Follow the [instructions](https://oreil.ly/CAGwf)
    on GitHub to install both `kubectx` and `kubens`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use the `kubectx` command to switch contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'One nice feature of `kubectx` is that `kubectx -` will switch to your previous
    context, so you can quickly toggle between two contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Just `kubectx` on its own will list all the contexts you have stored, with the
    current context highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switching namespaces is something you’ll probably do more often than switching
    contexts, so the `kubens` tool is ideal for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can also install these using the [`krew`](https://oreil.ly/JOhBN) package
    manager tool, which opens up an entire ecosystem of helpful plugins that make
    working with Kubernetes easier.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `kubectx` and `kubens` tools do one thing well, and they’re very useful
    additions to your Kubernetes toolbox. `krew` makes it easy to install similar
    helper tools.
  prefs: []
  type: TYPE_NORMAL
- en: kube-ps1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use the `bash` or `zsh` shells, there’s a little [utility](https://oreil.ly/Pfgnm)
    that will add the current Kubernetes context to your prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `kube-ps1` installed, you can’t forget which context you’re in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes Shells and Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using `kubectl` in an ordinary shell is perfectly sufficient for most
    things you’ll want to do with a Kubernetes cluster, there are other options.
  prefs: []
  type: TYPE_NORMAL
- en: kube-shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If `kubectl` auto-completion isn’t fancy enough for you, there’s always [`kube-shell`](https://oreil.ly/klA3D),
    a wrapper for `kubectl` that provides a pop-up menu of possible completions for
    each command (see [Figure 7-1](#img-kube-shell)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of kube-shell](assets/cnd2_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. `kube-shell` is an interactive Kubernetes client
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more sophisticated Kubernetes terminal experience is provided by [*Click*](https://oreil.ly/ilnpq).
  prefs: []
  type: TYPE_NORMAL
- en: Click is like an interactive version of `kubectl`, which *remembers* the current
    object you’re working with. For example, when you want to find and describe a
    Pod in `kubectl`, you usually have to list all the matching Pods first, then copy
    and paste the unique name of the Pod you’re interested in into a new command.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, with Click you can select any resource from a list by typing its number
    (for example, `1` for the first item). That’s now the current resource, and the
    next Click command will operate on that resource by default. To make finding the
    object you want easier, Click supports searching by regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: kubed-sh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `kube-shell` and Click provide local shells that know a little about
    Kubernetes, [`kubed-sh`](https://kubed.sh) (pronounced *kube-dash*) is a more
    intriguing idea: a shell that runs, in some sense, *on* the cluster itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubed-sh` will pull and run the necessary containers to execute JavaScript,
    Ruby, or Python programs on your current cluster. You can create, for example,
    a Ruby script on your local machine, and use `kubed-sh` to execute the script
    as a Kubernetes Deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Stern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `kubectl logs` is a useful command (see [“Viewing a Container’s Logs”](#containerlogs)),
    it’s not as convenient as it could be. For example, before you can use it, you
    first have to find out the unique name of the Pod and container whose logs you
    want to see, and specify these on the command line, which generally means at least
    one copy and paste.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you’re using `-f` to follow logs from a particular container, whenever
    the container is restarted, your log stream will stop. You’ll have to find out
    the new name of the container and run `kubectl logs` again to follow it. And you
    can only follow logs from one Pod at a time.
  prefs: []
  type: TYPE_NORMAL
- en: A more sophisticated log-streaming tool would allow you to specify a group of
    Pods with a regular expression matching their names or labels, and it would be
    able to keep on streaming logs even if individual containers are restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, that’s exactly what the [Stern](https://oreil.ly/5fNnO) tool does.
    Stern tails the logs from all Pods matching a regular expression (for example
    `demo.*`). If there are multiple containers within the Pod, Stern will show you
    log messages from each, prefixed by its name.
  prefs: []
  type: TYPE_NORMAL
- en: The `--since` flag lets you limit the output to recent messages (within the
    last 10 minutes, in the example).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of matching specific Pod names with a regular expression, you can use
    any Kubernetes label selector expression, just as with `kubectl`. Combined with
    the `--all-namespaces` flag, this is ideal for watching logs from multiple containers.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you use Kubernetes more and more, you will quickly find that you need ways
    to efficiently find, view, and edit all of the YAML manifests involved. You will
    be jumping around between different applications across different namespaces and
    clusters. Your favorite text editor and `kubectl` may be all that you need, but
    there are also some great tools that are worth trying out that add nice features
    and visualizations for interacting with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Lens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Lens](https://oreil.ly/5JwOQ) is a GUI application that works like an advanced
    visualizer and IDE specifically made for interacting with Kubernetes clusters.
    You can use it as a dashboard explorer to see what is happening inside of your
    cluster. Lens makes it easy to jump between contexts and namespaces to get an
    overview of what is running and includes an integrated Terminal you can use for
    `kubectl`.'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code Kubernetes Extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VS Code is a popular text editor with a huge ecosystem of extensions for just
    about anything. Like Lens, you can use the [Kubernetes extension](https://oreil.ly/4sQU3)
    as a dashboard tool for your cluster. It also includes special integration with
    Azure for creating AKS clusters and directly deploying applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building Your Own Kubernetes Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combined with query tools like `jq` and the standard set of Unix utilities (`cut`,
    `grep`, `xargs`, and friends), `kubectl` can be used for some fairly sophisticated
    scripting of Kubernetes resources. As we’ve seen in this chapter, there are also
    many third-party tools available that you can use as part of automated scripts.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has its limits, however. It’s fine to cook up ingenious one-liners
    and ad hoc shell scripts for interactive debugging and exploration, but they can
    be hard to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: For real systems programs automating your production workflows, we strongly
    recommend you use a real systems programming language. Go is the logical choice,
    since it was good enough for the Kubernetes authors—and naturally, Kubernetes
    includes a [full-featured client library](https://oreil.ly/XYJYq) for use in Go
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `client-go` library gives you complete access to the Kubernetes
    API, you can do anything with it that `kubectl` can do, and more. The following
    snippet shows how to list all the Pods in your cluster, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You can also create or delete Pods, Deployments, or any other resources. You
    can even implement your own custom resource types.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a feature that’s missing from Kubernetes, you can implement it yourself,
    using the client library.
  prefs: []
  type: TYPE_NORMAL
- en: Other programming languages, such as Python, Java, and dotnet, also have official
    [Kubernetes client libraries](https://oreil.ly/vRTPf) you can use in the same
    way. There are also community-maintained libraries for other programming languages
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a bewildering profusion of Kubernetes tools available, and more are
    released every week. You could be forgiven for feeling a little weary when reading
    about yet another tool you apparently can’t do without.
  prefs: []
  type: TYPE_NORMAL
- en: The fact is, you don’t need most of these tools. Kubernetes itself, via `kubectl`,
    can do most everything you want it to. The rest is just for fun and convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Nobody knows everything, but everybody knows something. In writing this chapter,
    we’ve incorporated tips and tricks from lots of experienced Kubernetes engineers,
    from books, blog posts, and documentation, and one or two little discoveries of
    our own. Everybody we’ve shown it to, no matter how expert, learned at least one
    useful thing. That makes us happy.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth taking a little time to get familiar with `kubectl` and explore its
    possibilities; it’s the most important Kubernetes tool you have, and you’ll be
    using it a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few of the most important things to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` includes complete and exhaustive documentation on itself, available
    with `kubectl -h`, and on every Kubernetes resource, field, or feature, using
    `kubectl explain`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to do complicated filtering and transformations on `kubectl` output,
    for example in scripts, select JSON format with `-o json`. Once you have JSON
    data, you can use power tools like `jq` to query it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--dry-run=client` option to `kubectl`, combined with `-o YAML` to get YAML
    output, lets you use imperative commands to generate Kubernetes manifests. This
    is a big time-saver when creating manifest files for new applications, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can turn existing resources into YAML manifests, too, using the `-o` flag
    to `kubectl get`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl diff` will tell you what *would* change if you applied a manifest,
    without actually changing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see the output and error messages from any container with `kubectl logs`,
    stream them continuously with the `--follow` flag, or do more sophisticated multi-Pod
    log tailing with Stern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To troubleshoot problem containers, you can attach to them with `kubectl attach`
    or get a shell on the container with `kubectl exec -it ... -- /bin/sh`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run any public container image with `kubectl run` to help solve problems,
    including the multitalented BusyBox tool, which contains all your favorite Unix
    commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes contexts are like bookmarks, marking your place in a particular cluster
    and namespace. You can switch conveniently between contexts and namespaces using
    the `kubectx` and `kubens` tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click is a powerful Kubernetes shell that gives you all the functionality of
    `kubectl`, but with added state: it remembers the currently selected object from
    one command to the next, so you don’t have to specify it every time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lens is a great standalone application you can use to manage Kubernetes clusters.
    VS Code also has a Kubernetes extension, allowing you to interact with your clusters
    alongside of your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes is designed to be automated and controlled by code. When you need
    to go beyond what `kubectl` provides, the Kubernetes `client-go` library gives
    you complete control over every aspect of your cluster using Go code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch07.html#idm45979385899936-marker)) [Pulumi](https://www.pulumi.com)
    is a cloud native IaC framework.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.html#idm45979385568432-marker)) Versions of the BusyBox image later
    than 1.28 have [a problem doing DNS lookups](https://oreil.ly/XxKDS) in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
