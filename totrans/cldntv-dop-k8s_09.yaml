- en: Chapter 7\. Kubernetes Power Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章 Kubernetes 强大工具
- en: My mechanic told me, “I couldn’t repair your brakes, so I made your horn louder.”
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我的机械师告诉我，“我修不好你的刹车，所以我把你的喇叭声音调得更大了。”
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Steven Wright
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Steven Wright
- en: People always ask us, “What about all these Kubernetes tools? Do I need them?
    If so, which ones? And what do they all do?”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常问我们，“关于所有这些 Kubernetes 工具怎么办？我需要它们吗？如果需要，具体是哪些？它们都做什么？”
- en: In this chapter, we’ll explore a small part of the landscape of tools and utilities
    that help you work with Kubernetes. We’ll show you some advanced techniques with
    `kubectl`, and a few useful utilities such as `jq`, `kubectx`/`kubens`, `kube-ps1`,
    Click, `kubed-sh`, Stern, and BusyBox.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索帮助你使用 Kubernetes 工作的工具和实用程序的一小部分。我们将向你展示一些与 `kubectl` 相关的高级技术，以及一些实用工具，如
    `jq`、`kubectx`/`kubens`、`kube-ps1`、Click、`kubed-sh`、Stern 和 BusyBox。
- en: Mastering kubectl
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通 `kubectl`
- en: We’ve already met `kubectl`, starting in [Chapter 2](ch02.html#firststeps),
    and as it’s the primary tool for interacting with Kubernetes, you may already
    be comfortable with the basics. Let’s look at some more advanced features of `kubectl`
    now, including some tips and tricks that may be new to you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第 2 章](ch02.html#firststeps)遇到了 `kubectl`，由于它是与 Kubernetes 交互的主要工具，你可能已经对基础知识感到很舒服。现在让我们看看
    `kubectl` 的一些更高级特性，包括一些对你来说可能是新的技巧和窍门。
- en: Shell Aliases
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell 别名
- en: 'One of the first things that most Kubernetes users do to make their lives easier
    is to create a shell alias for the `kubectl` command. For example, we have the
    following alias set up in our *.bash_profile* or *.zshrc* files:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Kubernetes 用户为了简化操作，首先做的事情之一就是为 `kubectl` 命令创建一个 shell 别名。例如，在我们的 *.bash_profile*
    或 *.zshrc* 文件中设置了以下别名：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead of having to type out `kubectl` in full for every command, we can just
    use `k`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不必为每个命令都完整输入 `kubectl`，我们可以简单地使用 `k`：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If there are some `kubectl` commands that you use a lot, you might like to
    create aliases for them too. Here are some possible examples:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一些你经常使用的 `kubectl` 命令，你可能也喜欢为它们创建别名。这里有一些可能的例子：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Google engineer Ahmet Alp Balkan has worked out a logical [system of aliases](https://oreil.ly/KoGV0)
    like these, and created a script to generate them all for you (currently around
    eight hundred aliases).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌工程师 Ahmet Alp Balkan 想出了一个逻辑的[别名系统](https://oreil.ly/KoGV0)，并创建了一个脚本为你生成所有这些别名（目前大约有八百个别名）。
- en: You don’t have to use those, though; we suggest you start with `k`, and add
    aliases that are memorable to you, for the commands you use most frequently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然你不一定非得用它们；我们建议你从 `k` 开始，并为你经常使用的命令添加易记的别名。
- en: Using Short Flags
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用短标志
- en: Like most command-line tools, `kubectl` supports abbreviated forms of many of
    its flags and switches. This can save you a lot of typing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数命令行工具一样，`kubectl` 支持许多标志和开关的缩写形式。这可以节省很多输入时间。
- en: 'For example, you can abbreviate the `--namespace` flag to just `-n` (see [“Using
    Namespaces”](ch05.html#namespaces)):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将 `--namespace` 标志缩写为 `-n`（见[“使用命名空间”](ch05.html#namespaces)）：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It’s very common to have `kubectl` operate on resources matching a set of labels,
    with the `--selector` flag (see [“Labels”](ch09.html#labels)). Fortunately, this
    can be shortened to `-l` (`labels`):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 常见的一种方式是使用 `--selector` 标志来操作符合一组标签的资源（见[“标签”](ch09.html#labels)）。幸运的是，这可以缩短为
    `-l`（`labels`）：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Abbreviating Resource Types
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩写资源类型
- en: A common use for `kubectl` is to list resources of various types, such as Pods,
    Deployments, Services, and namespaces. The usual way to do this is to use `kubectl
    get` followed by, for example, `deployments`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 的常见方式是列出各种类型的资源，例如 Pods、Deployments、Services 和命名空间。通常的方法是使用 `kubectl
    get` 后跟，例如 `deployments`。
- en: 'To speed this up, `kubectl` supports short forms of these resource types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快速度，`kubectl` 支持这些资源类型的简写形式：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Other useful abbreviations include `no` for `nodes`, `cm` for `configmaps`,
    `sa` for `serviceaccounts`, `ds` for `daemonsets`, and `pv` for `persistentvolumes`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的缩写包括 `no` 代表 `nodes`，`cm` 代表 `configmaps`，`sa` 代表 `serviceaccounts`，`ds`
    代表 `daemonsets`，`pv` 代表 `persistentvolumes`。
- en: Auto-Completing kubectl Commands
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动完成 `kubectl` 命令
- en: 'If you’re using the `bash` or `zsh` shells, you can have them auto-complete
    `kubectl` commands. Run this command to see instructions on how to enable auto-completion
    for your shell:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `bash` 或 `zsh` shell，你可以让它们自动完成 `kubectl` 命令。运行以下命令查看如何为你的 shell 启用自动完成：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Follow the instructions, and you should be able to press Tab to complete partial
    `kubectl` commands. Try it now:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明操作，你应该可以按 Tab 键来完成部分 `kubectl` 命令。现在试试吧：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The command should complete to `kubectl cluster-info`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应该完成到 `kubectl cluster-info`。
- en: 'If you type just `kubectl` and hit Tab twice, you’ll see all the commands available:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只键入 `kubectl` 并按两次 Tab 键，您将看到所有可用的命令：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use the same technique to list all the flags that you can use with
    the current command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的技术列出可以与当前命令一起使用的所有标志：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Usefully, `kubectl` will also auto-complete the names of Pods, Deployments,
    namespaces, and so on:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实用地，`kubectl` 也会自动完成 Pod、Deployment、命名空间等名称：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Getting Help
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'The best command-line tools include thorough documentation, and `kubectl` is
    no exception. You can get a complete overview of the available commands with `kubectl
    -h`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的命令行工具包括详尽的文档，`kubectl` 也不例外。您可以通过 `kubectl -h` 获得所有可用命令的完整概述：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can go further and get detailed documentation on each command, with all
    the available options, and a set of examples, by typing `kubectl COMMAND -h`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以进一步获取每个命令的详细文档，包括所有可用选项和一组示例，只需键入 `kubectl COMMAND -h`：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting Help on Kubernetes Resources
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 Kubernetes 资源的帮助
- en: 'As well as documenting itself, `kubectl` can also give you help on Kubernetes
    objects, such as Deployments or Pods. The `kubectl explain` command will show
    documentation on the specified type of resource:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自身文档，`kubectl` 还可以为 Kubernetes 对象（如 Deployments 或 Pods）提供帮助。`kubectl explain`
    命令将显示指定类型资源的文档：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can get further information on a specific field of a resource, with `kubectl
    explain RESOURCE.FIELD`. In fact, you can drill down as far as you like with `explain`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `kubectl explain RESOURCE.FIELD` 获取资源特定字段的更多信息。实际上，您可以通过 `explain` 深入到任何您想要的程度：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Showing More Detailed Output
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示更详细的输出
- en: 'You already know that `kubectl get` will list resources of various types, such
    as Pods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道 `kubectl get` 将列出各种类型的资源，如 Pods：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see extra information, such as the node each Pod is running on, by
    using the `-o wide` flag:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `-o wide` 标志，您可以查看每个 Pod 运行在哪个节点上的额外信息：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (We’ve omitted the information that you see without `-o wide`, just for reasons
    of space.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: （为了节省空间，我们已经省略了您在没有 `-o wide` 的情况下看到的信息。）
- en: 'Depending on the resource type, `-o wide` will show you different information.
    For example, with nodes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据资源类型的不同，`-o wide` 将显示不同的信息。例如，使用节点时：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Working with JSON Data and jq
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JSON 数据和 jq 工作
- en: 'The default output format for `kubectl get` is plain text, but it can also
    print information in JSON format:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get` 的默认输出格式是纯文本，但它也可以以 JSON 格式打印信息：'
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Not surprisingly, this produces a lot of output (about five thousand lines on
    our cluster). Fortunately, because the output is in the widely used JSON format,
    you can use other tools to filter it, such as the invaluable `jq`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，这会产生大量输出（在我们的集群上大约五千行）。幸运的是，由于输出是广泛使用的 JSON 格式，您可以使用其他工具来过滤它，如非常有用的 `jq`。
- en: If you don’t have [`jq`](https://stedolan.github.io/jq) already, you can [install
    it](https://stedolan.github.io/jq/download) in the usual way for your system (`brew
    install jq` for macOS, `apt install jq` for Debian/Ubuntu, and so on).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装 [`jq`](https://stedolan.github.io/jq)，可以按照您系统的惯例方式（macOS 上 `brew install
    jq`，Debian/Ubuntu 上 `apt install jq` 等）进行[安装](https://stedolan.github.io/jq/download)。
- en: 'Once you’ve got `jq` installed, you can use it to query and filter `kubectl
    output`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 `jq`，您可以使用它来查询和过滤 `kubectl output`：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`jq` is a very powerful tool for querying and transforming JSON data.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`jq` 是一个非常强大的工具，用于查询和转换 JSON 数据。'
- en: 'For example, to list your busiest nodes by the number of Pods running on each:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，按每个节点上运行的 Pod 数列出最繁忙的节点：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There’s a handy [online playground](https://jqplay.org) for `jq` where you can
    paste in JSON data and try out different `jq` queries to get the exact result
    you want.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个方便的 [在线 playground](https://jqplay.org)，您可以在其中粘贴 JSON 数据并尝试不同的 `jq` 查询，以获得您想要的确切结果。
- en: 'If you don’t have access to `jq`, `kubectl` also supports [JSONPath queries](https://oreil.ly/s7xIv).
    JSONPath is a JSON query language that isn’t quite as powerful as `jq`, but useful
    for quick one-liners:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有 `jq`，`kubectl` 也支持 [JSONPath 查询](https://oreil.ly/s7xIv)。JSONPath 是一种
    JSON 查询语言，虽然不如 `jq` 强大，但用于快速的一行命令很有用：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Watching Objects
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察对象
- en: When you’re waiting for a bunch of Pods to start up, it can be annoying to have
    to keep typing `kubectl get pods...` every few seconds to see if anything’s happened.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当您等待一堆 Pod 启动时，每隔几秒钟就需要不停地输入 `kubectl get pods...` 来查看是否有任何进展，这可能很烦人。
- en: '`kubectl` provides the `--watch` flag (`-w` for short) to save you having to
    do this. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 提供了 `--watch` 标志（简称 `-w`），以免您不得不这样做。例如：'
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Every time the status of one of the matching Pods changes, you’ll see an update
    in your terminal. (See [“Watching Kubernetes Resources with kubespy”](#kubespy)
    for a neat way to watch any kind of resource.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每当匹配的 Pod 的状态发生变化时，你将在终端上看到更新。（查看 [“使用 kubespy 监视 Kubernetes 资源”](#kubespy)
    以了解一种优雅的观察资源的方法。）
- en: Describing Objects
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述对象
- en: 'For really detailed information about Kubernetes objects, you can use the `kubectl
    describe` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想要获取有关 Kubernetes 对象的详细信息，你可以使用 `kubectl describe` 命令：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Events` section can be particularly useful for troubleshooting containers
    that aren’t working properly, as it records each stage of the container’s life
    cycle, along with any errors that occurred.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Events` 部分特别适用于排查工作不正常的容器问题，因为它记录了容器生命周期的每个阶段，以及发生的任何错误。'
- en: Working with Resources
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资源
- en: 'So far, you’ve used `kubectl` mostly for querying or listing things, as well
    as applying declarative YAML manifests with `kubectl apply`. However, `kubectl`
    also has a complete set of *imperative* commands: operations that create or modify
    resources directly.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要使用 `kubectl` 进行查询或列出事物，以及使用 `kubectl apply` 应用声明性 YAML 文件。然而，`kubectl`
    也有一整套 *命令式* 命令：直接创建或修改资源的操作。
- en: Imperative kubectl Commands
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式的 kubectl 命令
- en: We showed one example of this in [“Running the Demo App”](ch02.html#runningdemo),
    using the `kubectl run` command, which implicitly creates a Pod to run the specified
    container.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [“运行演示应用”](ch02.html#runningdemo) 中展示了一个例子，使用 `kubectl run` 命令，该命令隐式创建一个
    Pod 来运行指定的容器。
- en: 'You can also explicitly create most resources using `kubectl create`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `kubectl create` 明确地创建大多数资源：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, `kubectl delete` will delete a resource:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`kubectl delete` 将删除一个资源：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `kubectl edit` command gives you the power to view and modify any resource:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl edit` 命令赋予你查看和修改任何资源的权力：'
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This will open your default editor with a YAML manifest file representing the
    specified resource.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用默认编辑器打开一个 YAML 清单文件，代表指定的资源。
- en: This is a good way to get a detailed look at the configuration of any resource,
    but you can also make any changes you like in the editor. When you save the file
    and quit the editor, `kubectl` will update the resource, exactly as though you
    had run `kubectl apply` on the manifest file for the resource.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查看任何资源配置的详细方法，但你也可以在编辑器中进行任何喜欢的更改。当你保存文件并退出编辑器时，`kubectl` 将更新资源，就像你对资源的清单文件运行了
    `kubectl apply` 一样。
- en: If you introduced any errors, such as invalid YAML, `kubectl` will tell you
    and reopen the file for you to fix the problem.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引入了任何错误，比如无效的 YAML，`kubectl` 将告诉你，并重新打开文件让你修复问题。
- en: When Not to Use Imperative Commands
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不适用命令式命令的时机
- en: Throughout this book we’ve emphasized the importance of using *declarative*
    infrastructure as code. So it shouldn’t come as a surprise that we don’t recommend
    you use imperative `kubectl` commands.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们强调了使用 *声明性* 基础设施即代码的重要性。因此，我们不建议使用命令式的 `kubectl` 命令并不足为奇。
- en: Although they can be very useful for quickly testing things or trying out ideas,
    the major problem with imperative commands is that you have no single *source
    of truth*. There’s no way to know who ran what imperative commands on the cluster
    at what time, and what the effect was. As soon as you run any imperative command,
    the state of the cluster becomes out of sync with the manifest files stored in
    version control.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们对于快速测试或尝试想法可能非常有用，但是命令式命令的主要问题在于没有一个单一的 *真实来源*。无法知道谁在集群上什么时候运行了哪些命令，以及效果如何。一旦运行任何命令式命令，集群的状态就会与存储在版本控制中的清单文件不同步。
- en: 'The next time someone applies the YAML manifests, whatever changes you made
    imperatively will be overwritten and lost. This can lead to surprising results,
    and potentially adverse effects on critical services:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下次有人应用 YAML 清单时，无论你以命令方式做了哪些更改，它们都将被覆盖和丢失。这可能导致意外的结果，对关键服务可能造成不利影响：
- en: Alice is on-call, when suddenly there is a large increase in load on the service
    she is managing. Alice uses the `kubectl scale` command to increase the number
    of replicas from 5 to 10\. Several days later, Bob edits the YAML manifests in
    version control to use a new container image, but he doesn’t notice that the number
    of replicas in the file is currently 5, not the 10 that are active in production.
    Bob proceeds with the rollout, which cuts the number of replicas by half, causing
    an immediate overload or outage.
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当服务负载突然增加时，Alice 作为值班人员。 Alice 使用 `kubectl scale` 命令将副本数从 5 增加到 10。 几天后，Bob
    在版本控制中编辑 YAML 清单以使用新的容器镜像，但他没有注意到文件中的副本数目前是 5，而不是生产中的 10。 Bob 继续进行部署，这使得副本数量减少了一半，导致立即的过载或故障。
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kelsey Hightower et al., *Kubernetes Up & Running*
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Kelsey Hightower 等人，《Kubernetes 上手指南》
- en: Alice forgot to update the files in version control after she made her imperative
    change, but that’s easy to do, especially under the stress of an incident (see
    [“On-Call Should Not Be Hell”](ch16.html#on-call)). Real life doesn’t always follow
    best practices.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 在她进行命令式更改后忘记更新版本控制中的文件，但这很容易做到，尤其是在事故的压力下（参见 [“On-Call Should Not Be Hell”](ch16.html#on-call)）。
    现实生活并不总是遵循最佳实践。
- en: Similarly, before reapplying the manifest files, Bob should have checked the
    diff using `kubectl diff` (see [“Diffing Resources”](#diffing)) to see what would
    change. But if you’re not expecting something to be different, it’s easy to overlook
    it. And maybe Bob hasn’t read this book.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在重新应用清单文件之前，Bob 应该使用 `kubectl diff` 检查差异（参见 [“Diffing Resources”](#diffing)）以查看将发生的更改。
    但如果你没有预料到会有不同的东西，很容易忽视它。 也许 Bob 没有读过这本书。
- en: The best way to avoid this kind of problem is to always make changes by editing
    and applying the resource files under version control. We will cover this more
    in [“GitOps”](ch14.html#gitops) later on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种问题的最佳方法是始终通过编辑和应用版本控制下的资源文件进行更改。 我们稍后会在 [“GitOps”](ch14.html#gitops) 中详细介绍。
- en: Best Practice
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Don’t use `kubectl` imperative commands such as `create` or `edit` on production
    clusters. Instead, always manage resources with version-controlled YAML manifests,
    applied with `kubectl apply` (or Helm charts).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产集群上使用 `kubectl` 命令式命令，如 `create` 或 `edit`。 相反，始终使用带有 `kubectl apply`（或
    Helm charts）的版本控制的 YAML 清单管理资源。
- en: Generating Resource Manifests
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成资源清单
- en: Even though we don’t recommend using `kubectl` in imperative mode to make changes
    to your cluster, imperative commands can be a great time-saver when creating Kubernetes
    YAML files from scratch.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不建议使用命令式模式的 `kubectl` 对集群进行更改，但当从头开始创建 Kubernetes YAML 文件时，命令式命令可以节省大量时间。
- en: 'Rather than typing a lot of boilerplate into an empty file, you can use `kubectl`
    to give you a head start by generating the YAML manifest for you:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在空文件中键入大量样板代码，您可以使用 `kubectl` 为您生成 YAML 清单，为您提供一个起点：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `--dry-run=client` flag tells `kubectl` not to actually create the resource,
    but merely to print out what it would have created. The `-o yaml` flag gives you
    the resource manifest in YAML format. The `>` character writes the output of the
    command to a file that you can then use to make any edits, and finally apply it
    to create the resource in the cluster.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`--dry-run=client` 标志告诉 `kubectl` 不实际创建资源，而只是打印出它将要创建的内容。 `-o yaml` 标志以 YAML
    格式给出资源清单。 `>` 字符将命令的输出写入文件，然后您可以使用该文件进行任何编辑，最后应用它以在集群中创建资源。'
- en: Exporting Resources
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出资源
- en: As well as helping you create new resource manifests, `kubectl` can also produce
    manifest files for resources that already exist in the cluster. For example, maybe
    you created a Deployment using imperative commands (`kubectl create`), edited
    and adjusted it to get the settings just right, and now you want to write a declarative
    YAML manifest for it that you can add to version control.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助您创建新的资源清单外，`kubectl` 还可以为已经存在于集群中的资源生成清单文件。 例如，也许您使用命令式命令 (`kubectl create`)
    创建了一个 Deployment，编辑并调整它以获得正确的设置，现在您想要编写一个声明性 YAML 清单以添加到版本控制中。
- en: 'To do this, use the `-o` flag with `kubectl get`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此操作，请使用 `kubectl get` 命令的 `-o` 标志：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This output will contain some extra information, like the `status` section that
    you can remove (before saving with your other manifests), update, and apply with
    `kubectl apply -f`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出将包含一些额外信息，例如可以删除的 `status` 部分（在保存到其他清单文件之前），更新并应用于 `kubectl apply -f`。
- en: If you’ve been using imperative `kubectl` commands to manage your cluster up
    to now, and you’d like to switch to the declarative style that we recommend in
    this book, this is a great way to do it. Export all the resources in your cluster
    to manifest files using `kubectl` with the `-o` flag, as shown in the example,
    and you’ll be all set.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您到目前为止一直在使用命令式 `kubectl` 命令来管理您的集群，并且希望切换到我们在本书中推荐的声明式风格，这是一个很好的方法。使用 `kubectl`
    带有 `-o` 标志导出集群中的所有资源到清单文件中，如示例所示，您就可以做好准备了。
- en: Diffing Resources
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源差异比较
- en: 'Before you apply Kubernetes manifests using `kubectl apply`, it’s very useful
    to be able to see exactly what would change on the cluster. The `kubectl diff`
    command will do this for you:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `kubectl apply` 应用 Kubernetes 清单之前，查看集群上确切会发生什么变化非常有用。`kubectl diff` 命令将为您完成这项工作：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can use this `diff` output to check whether the changes you made will actually
    have the effect you expected. Also, it will warn you if the state of the live
    resource is out of sync with the YAML manifest, perhaps because someone edited
    it imperatively since you last applied it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此 `diff` 输出来检查您所做的更改是否会产生您预期的效果。此外，它还会在实际资源的状态与 YAML 清单不同步时发出警告，这可能是因为自上次应用它以来有人通过命令方式编辑了它。
- en: Best Practice
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Use `kubectl diff` to check what would change before applying any updates to
    your production cluster.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl diff` 在将任何更新应用到生产集群之前检查将会发生的变化。
- en: Working with Containers
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与容器一起工作
- en: Most of what goes on in a Kubernetes cluster happens inside containers, so when
    things go wrong, it can be hard to see what’s happening. Here are a few useful
    ways to work with running containers using `kubectl`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Kubernetes 集群中的操作发生在容器内部，因此当出现问题时，很难看到发生了什么。以下是使用 `kubectl` 与运行中容器一起工作的几种有用方法。
- en: Viewing a Container’s Logs
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看容器的日志
- en: When you’re trying to get a container working and it’s not behaving as it should,
    one of the most useful sources of information is the container’s *logs*. In Kubernetes,
    logs are considered to be whatever a container writes to the *standard output*
    and *standard error* streams; if you were running the program in a terminal, these
    are what you would see printed in the terminal.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试使一个容器正常工作但其行为不符合预期时，其中一个最有用的信息源是容器的*日志*。在 Kubernetes 中，日志被认为是容器写入*标准输出*和*标准错误*流的内容；如果您在终端中运行程序，这些内容就是您在终端中看到的打印输出。
- en: In production applications, especially distributed ones, you’ll need to be able
    to aggregate logs from multiple services, store them in a persistent database,
    and query and graph them. This is a big topic, and one we’ll treat in much more
    detail in [Chapter 15](ch15.html#observability).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用程序中，特别是分布式应用程序，您需要能够聚合来自多个服务的日志，将它们存储在持久性数据库中，并进行查询和图形化显示。这是一个重要的话题，我们将在[第
    15 章](ch15.html#observability)中详细讨论。
- en: 'Inspecting the log messages from specific containers is still a very useful
    troubleshooting technique, though, and you can do this directly with `kubectl
    logs`, followed by the name of a Pod:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，检查特定容器的日志消息仍然是一个非常有用的故障排除技术，您可以直接使用 `kubectl logs` 命令，后跟 Pod 的名称：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Most long-running containers will generate a *lot* of log output, so you’ll
    usually want to restrict it to just the most recent lines, using the `--tail`
    flag, as in this example. (The container logs will be shown with timestamps, but
    we’ve trimmed those here to fit the messages on the page.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数长时间运行的容器会生成*大量*的日志输出，因此通常您会希望仅限于最近的几行，可以使用 `--tail` 标志，就像这个例子一样。（这些容器日志会显示时间戳，但在这里我们已经对其进行了修剪以适应页面上的消息。）
- en: 'To watch a container as it’s running, and stream its log output to your terminal,
    use the `--follow` flag (`-f` for short):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在容器运行时观看其输出并将日志实时流式传输到您的终端，请使用 `--follow` 标志（简写为 `-f`）：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As long as you leave the `kubectl logs` command running with the `--follow`
    flag, you’ll continue to see any new output from the Pod.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 只要使用 `kubectl logs` 命令并带有 `--follow` 标志持续运行，您将继续看到来自 Pod 的任何新输出。
- en: It can be particularly useful to view the Kubernetes API server’s logs; for
    example, if you have RBAC permission errors (see [“Introducing Role-Based Access
    Control (RBAC)”](ch11.html#rbac)), they’ll show up here. If you have access to
    your control plane nodes, you can find the `kube-apiserver` Pod in the `kube-system`
    namespace and use `kubectl logs` to see its output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 Kubernetes API 服务器的日志尤为有用；例如，如果您遇到 RBAC 权限错误（参见[“引入基于角色的访问控制（RBAC）”](ch11.html#rbac)），它们将显示在这里。如果您可以访问控制平面节点，则可以在
    `kube-system` 命名空间中找到 `kube-apiserver` Pod，并使用 `kubectl logs` 查看其输出。
- en: If you’re using a managed service, where the control plane nodes are not visible
    to you, check your provider’s documentation to see how to find the control plane
    logs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用托管服务，控制平面节点对您不可见，请查阅提供商的文档，了解如何查找控制平面日志。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'When there are multiple containers in a Pod, you can specify which one you
    want to see the logs for using the `--container` flag (`-c` for short):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Pod 中有多个容器时，您可以使用 `--container` 标志（简写为 `-c`）指定您想查看日志的容器：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For more sophisticated log watching, you may want to use a dedicated tool like
    Stern instead (see [“Stern”](#stern)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的日志监控，您可能需要使用类似 Stern 这样的专用工具（参见 [“Stern”](#stern)）。
- en: Attaching to a Container
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加到容器
- en: 'When looking at the logs of a container isn’t enough, you might need to attach
    your local terminal to the container instead. This lets you see the container’s
    output directly. To do this, use `kubectl attach`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看容器的日志不足以解决问题时，您可能需要将本地终端连接到容器中。这样可以直接查看容器的输出。要执行此操作，请使用 `kubectl attach`：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Watching Kubernetes Resources with kubespy
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubespy 观察 Kubernetes 资源
- en: When you deploy changes to your Kubernetes manifests, there’s often an anxious
    period of waiting to see what happens next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当您部署 Kubernetes 清单的更改时，通常会有一段焦虑的等待期，以查看接下来会发生什么。
- en: Often when you deploy an application, lots of things need to happen behind the
    scenes, as Kubernetes creates your resources, spins up Pods, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署应用程序时，通常需要在幕后执行许多操作，例如 Kubernetes 创建资源、启动 Pods 等等。
- en: Because this happens *automagically*, as engineers like to say, it can be difficult
    to tell what’s going on. `kubectl get` and `kubectl describe` can give you snapshots
    of individual resources, but what we’d really like is a way to see the state of
    Kubernetes resources changing in real time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种情况是 *自动完成* 的，就像工程师们常说的那样，很难分辨发生了什么。`kubectl get` 和 `kubectl describe` 可以为您提供单个资源的快照，但我们真正想要的是一种能实时查看
    Kubernetes 资源状态变化的方法。
- en: Enter [kubespy](https://oreil.ly/YqyBk), a neat tool from the Pulumi project.^([1](ch07.html#idm45979385899936))
    kubespy can watch an individual resource in the cluster and show you what’s happening
    to it over time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍了 [kubespy](https://oreil.ly/YqyBk)，这是来自 Pulumi 项目的一个很棒的工具。^([1](ch07.html#idm45979385899936))
    kubespy 能够监视集群中的单个资源，并展示它随时间的变化情况。
- en: For example, if you point kubespy at a Service resource, it will show you when
    the Service is created, when it’s allocated an IP address, when its endpoints
    are connected, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将 kubespy 指向一个 Service 资源，它会显示 Service 创建时的情况，当其分配了 IP 地址时，以及连接其终端节点时的情况，等等。
- en: Forwarding a Container Port
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转发容器端口
- en: 'We’ve used `kubectl port-forward` before, in [“Running the Demo App”](ch02.html#runningdemo),
    to forward a Kubernetes Service to a port on your local machine. But you can also
    use it to forward a container port, if you want to connect directly to a specific
    Pod. Just specify the Pod name and the local and remote ports:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 [“运行演示应用”](ch02.html#runningdemo) 中使用过 `kubectl port-forward`，将 Kubernetes
    Service 转发到本地机器上的某个端口。但是，您也可以用它来转发容器的端口，如果您想直接连接到特定的 Pod。只需指定 Pod 名称以及本地和远程端口即可：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now port 9999 on your local machine will be forwarded to port 8888 on the container,
    and you can connect to it with a web browser, for example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您本地机器上的 9999 端口将会被转发到容器上的 8888 端口，并且您可以用浏览器连接它，例如。
- en: Executing Commands on Containers
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器上执行命令
- en: The isolated nature of containers is great when you want to run reliable, secure
    workloads. But it can be a little inconvenient when something’s not working right,
    and you can’t see why.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的隔离性在您需要运行可靠、安全工作负载时非常有用。但当某些问题出现时，你却看不到问题所在，这可能会有点不便。
- en: 'When you’re running a program on your local machine and it misbehaves, you
    have the power of the command line at your disposal to troubleshoot it: you can
    look at the running processes with `ps`, list and display files with `ls` and
    `cat`, and even edit the files directly with a text editor.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在本地机器上运行程序时，如果它表现不正常，您可以利用命令行的强大功能来进行故障排除：您可以用 `ps` 查看运行中的进程，用 `ls` 和 `cat`
    列出和显示文件，甚至可以用文本编辑器直接编辑文件。
- en: Very often, with a malfunctioning container, it would be useful to have a shell
    running in the container so that we can do this kind of interactive debugging.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器出现故障时，很多时候需要在容器中运行一个 shell，以便进行此类交互式调试。
- en: 'Using the `kubectl exec` command, you can run a specified command in any container,
    including a shell:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl exec` 命令，您可以在任何容器中运行指定的命令，包括 shell：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the Pod has more than one container in it, `kubectl exec` will run the command
    in the first container by default. Alternatively, you can specify the container
    with the `-c` flag:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Pod 中有多个容器，`kubectl exec` 默认会在第一个容器中运行命令。或者，你可以使用 `-c` 标志指定容器：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: (If the container doesn’t have a shell, see [“Adding BusyBox to Your Containers”](#addingbusybox).)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: （如果容器没有 shell，请参阅 [“将 BusyBox 添加到您的容器”](#addingbusybox)。）
- en: Running Containers for Troubleshooting
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于故障排除的运行容器
- en: In addition to running commands on an existing container, sometimes it’s handy
    to be able to run commands like `wget` or `nslookup` in the cluster, to see the
    results that your application would get. You’ve already learned how to run containers
    in the cluster with `kubectl run`, but here are a few useful examples of running
    one-off container commands for debugging purposes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在现有容器上运行命令之外，有时还可以在集群中运行像 `wget` 或 `nslookup` 这样的命令，以查看你的应用程序的结果。你已经学会了如何使用
    `kubectl run` 在集群中运行容器，但这里有一些用于调试目的的有用的一次性容器命令示例。
- en: 'First, let’s run an instance of the demo application to test against:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们运行一个演示应用实例进行测试：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `demo` service should have been allocated an IP address and a DNS name
    of `demo` that is accessible from inside the cluster. Let’s check that, using
    the `nslookup` command running inside a container:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`demo` 服务应已分配一个 IP 地址和一个名为 `demo` 的 DNS 名称，可从集群内部访问。让我们通过在容器内运行 `nslookup`
    命令来检查一下：'
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Good news: the DNS name works, so we should be able to make an HTTP request
    to it using `wget` and see the result:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是：DNS 名称有效，因此我们应该能够使用 `wget` 进行 HTTP 请求并查看结果：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can see that this pattern of `kubectl run` commands uses a common set of
    flags:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些 `kubectl run` 命令使用了一组常见的标志：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What do these do?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令做什么？
- en: '`--rm`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`--rm`'
- en: This tells Kubernetes to delete the resources created in this command for attached
    containers so that it doesn’t clutter up your nodes’ local storage.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Kubernetes 删除此命令创建的附加容器的资源，以免占用节点的本地存储空间。
- en: '`-it`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`-it`'
- en: This runs the container interactively (`i`), via a terminal (`t`), so that you
    see the output from the container in your own terminal, and can send keystrokes
    to it if you need to.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以交互方式（`i`）在终端（`t`）中运行容器，以便你在自己的终端中看到容器的输出，并且如果需要，可以向其发送按键。
- en: '`--restart=Never`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`--restart=Never`'
- en: This tells Kubernetes to skip its usual helpful behavior of restarting a container
    whenever it exits. Since we only want to run the container one time, we can disable
    the default restart policy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Kubernetes 在容器退出时跳过其通常的重新启动行为。由于我们只想运行容器一次，我们可以禁用默认的重启策略。
- en: '`--command --`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`--command --`'
- en: This specifies a command to run, instead of the container’s default entrypoint.
    Everything following the `--` will be passed to the container as a command line,
    complete with arguments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定要运行的命令，而不是容器的默认入口点。`--` 后面的所有内容将作为命令行传递给容器，包括参数。
- en: Using BusyBox Commands
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 BusyBox 命令
- en: Although you can run any container available to you, the `busybox` image is
    particularly useful because it contains a wealth of the most commonly used Unix
    commands, such as `cat`, `echo`, `find`, `grep`, and `kill`. You can see a complete
    list of [BusyBox commands](https://oreil.ly/KiiEE) on their website.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以运行任何可用的容器，但 `busybox` 镜像特别有用，因为它包含了最常用的 Unix 命令，如 `cat`、`echo`、`find`、`grep`
    和 `kill`。你可以在它们的网站上查看完整的 [BusyBox 命令](https://oreil.ly/KiiEE) 列表。
- en: 'BusyBox also includes a lightweight bash-like shell, called `ash`, which is
    compatible with standard `/bin/sh` shell scripts. So to get an interactive shell
    in your cluster, you can run:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 还包括一个轻量级的类似 bash 的 shell，称为 `ash`，与标准的 `/bin/sh` shell 脚本兼容。因此，要在集群中获取交互式
    shell，你可以运行：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Because the pattern for running commands from the BusyBox image is always the
    same, you could even make a shell alias for it (see [“Shell Aliases”](#shellaliases)):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为从 BusyBox 镜像运行命令的模式总是相同的，你甚至可以为其制作一个 shell 别名（参见 [“Shell 别名”](#shellaliases)）：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Adding BusyBox to Your Containers
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 BusyBox 添加到您的容器
- en: 'If your container already has a shell in it (for example, if it’s built from
    a Linux base image, such as `alpine`), then you can get shell access on the container
    by running:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的容器已经有一个 shell（例如，如果它是从 Linux 基础镜像构建的，比如 `alpine`），那么你可以通过运行
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: But what if there’s no */bin/sh* in the container? For example, if you’re using
    a minimal, scratch image as described in [“Understanding Dockerfiles”](ch02.html#multistagedockerfile).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果容器中没有 */bin/sh* 怎么办？例如，如果您正在使用如 [“理解 Dockerfile”](ch02.html#multistagedockerfile)
    中描述的极简、scratch 镜像。
- en: The simplest way to make your containers easily debuggable, while keeping the
    images very small, is to copy the `busybox` executable into them at build time.
    It’s only 1 MiB, which is a small price to pay for having a usable shell and a
    set of Unix utilities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的容器易于调试的最简单方法，同时保持镜像非常小，就是在构建时将 `busybox` 可执行文件复制到其中。它仅有 1 MiB，这对于拥有一个可用的
    shell 和一组 Unix 实用程序来说是一个小代价。
- en: You learned in the earlier discussion of multistage builds that you can copy
    a file from a previously built container into a new container using the Dockerfile
    `COPY --from` command. A lesser-known feature of this command is that you can
    also copy a file from any public image, not just one that you built locally.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面讨论多阶段构建时，您学到可以使用 Dockerfile 的 `COPY --from` 命令将文件从先前构建的容器复制到新容器中。这个命令的一个较少为人知的特性是，您还可以从任何公共镜像复制文件，而不仅限于本地构建的镜像。
- en: 'The following Dockerfile shows how to do this with the demo image:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Dockerfile 显示了如何在演示镜像中执行此操作：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the `--from=busybox:1.28` references the public BusyBox library image.^([2](ch07.html#idm45979385568432))
    You could copy a file from any image you like (such as `alpine`, for example).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`--from=busybox:1.28` 引用了公共 BusyBox 库镜像。^([2](ch07.html#idm45979385568432))
    您可以从任何喜欢的镜像中复制文件（例如 `alpine`）。
- en: 'Now you still have a very small container, but you can also get a shell on
    it, by running:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您仍然拥有一个非常小的容器，但您也可以通过运行以下命令在其上获取一个 shell：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Instead of executing `/bin/sh` directly, you execute `/bin/busybox` followed
    by the name of the command you want; in this case, `sh`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接执行 `/bin/sh`，您可以执行 `/bin/busybox`，然后是您想要的命令名称；在这种情况下，是 `sh`。
- en: Installing Programs on a Container
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器上安装程序
- en: 'If you need some programs that aren’t included in BusyBox, or aren’t available
    in a public container image, you can run a Linux image such as `alpine` or `ubuntu`
    instead, and install whatever you need on it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一些不包含在 BusyBox 中或者在公共容器镜像中不可用的程序，您可以运行 Linux 镜像，比如 `alpine` 或 `ubuntu`，然后在其上安装您需要的任何内容：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Keep in mind that these temporary debugging containers would likely need to
    run as the root user in order to install new packages, and, once the container
    exits, any changes inside the container would be lost. This process would only
    be for one-off troubleshooting sessions, not something you should rely on for
    long-running applications that you want to stick around on the cluster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些临时调试容器可能需要以 root 用户身份运行，以便安装新包，而且一旦容器退出，容器内的任何更改都会丢失。这个过程仅适用于一次性故障排除会话，而不是您希望在集群上持续运行的应用程序。
- en: Contexts and Namespaces
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文与命名空间
- en: So far in this book we’ve been working with a single Kubernetes cluster, and
    all the `kubectl` commands you’ve run have naturally applied to that cluster.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中我们一直在使用单个 Kubernetes 集群，并且您运行的所有 `kubectl` 命令自然应用于该集群。
- en: So what happens when you have more than one cluster? For example, maybe you
    have a Kubernetes cluster on your machine for local testing and a production cluster
    in the cloud, and perhaps another remote cluster for staging and development.
    How does `kubectl` know which one you mean?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当您拥有多个集群时会发生什么呢？例如，也许您在本地测试机器上有一个 Kubernetes 集群，在云中有一个生产集群，也许还有一个用于暂存和开发的远程集群。`kubectl`
    如何知道您指的是哪一个？
- en: To solve this problem, `kubectl` has *contexts*. A context is a combination
    of a cluster, a user, and a namespace (see [“Using Namespaces”](ch05.html#namespaces)).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，`kubectl` 有*上下文*。上下文是集群、用户和命名空间的组合（参见 [“使用命名空间”](ch05.html#namespaces)）。
- en: 'When you run `kubectl` commands, they’re always executed in the *current context*.
    Let’s look at an example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `kubectl` 命令时，它们始终在*当前上下文*中执行。让我们看一个例子：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the contexts `kubectl` currently knows about. Each context has a name,
    and refers to a particular cluster, a username that authenticates to the cluster,
    and a namespace within the cluster. The `docker-for-desktop` context, as you might
    expect, refers to my local Kubernetes cluster.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `kubectl` 当前知道的上下文。每个上下文都有一个名称，并指向一个特定的集群，一个用于认证到该集群的用户名，以及集群内的一个命名空间。正如您可能期望的那样，`docker-for-desktop`
    上下文指的是我的本地 Kubernetes 集群。
- en: 'The current context is shown with a `*` in the first column (in the example,
    it’s `docker-for-desktop`). If I run a `kubectl` command now, it will operate
    on the Docker Desktop cluster, in the default namespace (because the `NAMESPACE`
    column is blank, indicating that the context refers to the default namespace):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当前上下文在第一列中用 `*` 显示（在示例中为 `docker-for-desktop`）。如果现在运行 `kubectl` 命令，它将在 Docker
    Desktop 集群中的默认命名空间中执行（因为 `NAMESPACE` 列为空，表示上下文指向默认命名空间）：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can switch to another context using the `kubectl config use-context` command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `kubectl config use-context` 命令切换到另一个上下文：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You could think of contexts as being like bookmarks: they let you switch easily
    to a particular cluster and a particular namespace. To create a new context, use
    `kubectl config set-context`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将上下文想象为书签：它们可以让你轻松切换到特定的集群和特定的命名空间。要创建新的上下文，请使用 `kubectl config set-context`：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now whenever you switch to the `myapp` context, your current context will be
    the `myapp` namespace on the Docker Desktop cluster.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当切换到 `myapp` 上下文时，当前上下文将是 Docker Desktop 集群上的 `myapp` 命名空间。
- en: 'If you forget what your current context is, `kubectl config current-context`
    will tell you:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忘记了当前上下文是什么，可以使用 `kubectl config current-context` 命令查看：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: kubeconfig files
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubeconfig 文件
- en: These contexts for different Kubernetes clusters are stored by default in a
    file (or multiple files) typically located at *~/.kube/config* on your machine.
    This can be customized using the `KUBECONFIG` environment variable if you wish
    to use a different path per the docs on managing kubeconfig files found [here](https://oreil.ly/lZ0Lc).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同 Kubernetes 集群的上下文默认存储在一个文件（或多个文件）中，通常位于您的机器上的 *~/.kube/config*。如果希望使用不同的路径，可以自定义
    `KUBECONFIG` 环境变量，具体见管理 kubeconfig 文件的 [文档](https://oreil.ly/lZ0Lc)。
- en: kubectx and kubens
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubectx 和 kubens
- en: If, like us, you type for a living, you probably don’t like typing any more
    keystrokes than you have to. For faster switching of `kubectl` contexts, you can
    use the `kubectx` and `kubens` tools. Follow the [instructions](https://oreil.ly/CAGwf)
    on GitHub to install both `kubectx` and `kubens`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我们一样以键盘为生，可能不喜欢多敲击键盘。为了快速切换 `kubectl` 上下文，可以使用 `kubectx` 和 `kubens` 工具。在
    GitHub 上查看 [说明](https://oreil.ly/CAGwf) 安装 `kubectx` 和 `kubens`。
- en: 'Now you can use the `kubectx` command to switch contexts:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用 `kubectx` 命令切换上下文：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'One nice feature of `kubectx` is that `kubectx -` will switch to your previous
    context, so you can quickly toggle between two contexts:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectx` 的一个很好的功能是 `kubectx -` 可以切换到先前的上下文，因此可以快速在两个上下文之间切换：'
- en: '[PRE53]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Just `kubectx` on its own will list all the contexts you have stored, with the
    current context highlighted.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 只需`kubectx`命令，将显示所有已存储的上下文，并突出显示当前上下文。
- en: 'Switching namespaces is something you’ll probably do more often than switching
    contexts, so the `kubens` tool is ideal for this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 切换命名空间比切换上下文更常见，因此 `kubens` 工具非常适合这种情况：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can also install these using the [`krew`](https://oreil.ly/JOhBN) package
    manager tool, which opens up an entire ecosystem of helpful plugins that make
    working with Kubernetes easier.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 [`krew`](https://oreil.ly/JOhBN) 包管理工具来安装它们，它会打开一个整个生态系统的有用插件，使得与 Kubernetes
    工作更轻松。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `kubectx` and `kubens` tools do one thing well, and they’re very useful
    additions to your Kubernetes toolbox. `krew` makes it easy to install similar
    helper tools.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectx`和`kubens`工具各有所长，是Kubernetes工具箱中非常实用的补充。使用`krew`可以轻松安装类似的辅助工具。'
- en: kube-ps1
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-ps1
- en: If you use the `bash` or `zsh` shells, there’s a little [utility](https://oreil.ly/Pfgnm)
    that will add the current Kubernetes context to your prompt.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `bash` 或 `zsh` shell，还有一个小 [实用工具](https://oreil.ly/Pfgnm)，它将当前的 Kubernetes
    上下文添加到您的提示符中。
- en: 'With `kube-ps1` installed, you can’t forget which context you’re in:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 `kube-ps1` 后，你将不会忘记当前所在的上下文：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Kubernetes Shells and Tools
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes Shell 和工具
- en: While using `kubectl` in an ordinary shell is perfectly sufficient for most
    things you’ll want to do with a Kubernetes cluster, there are other options.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通 shell 中使用 `kubectl` 对于大多数需要在 Kubernetes 集群中执行的任务来说已经足够，但也有其他选择。
- en: kube-shell
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kube-shell
- en: If `kubectl` auto-completion isn’t fancy enough for you, there’s always [`kube-shell`](https://oreil.ly/klA3D),
    a wrapper for `kubectl` that provides a pop-up menu of possible completions for
    each command (see [Figure 7-1](#img-kube-shell)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `kubectl` 自动完成功能对你来说还不够，还有 [`kube-shell`](https://oreil.ly/klA3D)，这是一个 `kubectl`
    的包装器，为每个命令提供可能的完成选项的弹出菜单（见 [图 7-1](#img-kube-shell)）。
- en: '![Screenshot of kube-shell](assets/cnd2_0701.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![kube-shell 的屏幕截图](assets/cnd2_0701.png)'
- en: Figure 7-1\. `kube-shell` is an interactive Kubernetes client
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. `kube-shell` 是一个交互式的 Kubernetes 客户端。
- en: Click
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Click
- en: A more sophisticated Kubernetes terminal experience is provided by [*Click*](https://oreil.ly/ilnpq).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Click*](https://oreil.ly/ilnpq) 提供了更复杂的 Kubernetes 终端体验。'
- en: Click is like an interactive version of `kubectl`, which *remembers* the current
    object you’re working with. For example, when you want to find and describe a
    Pod in `kubectl`, you usually have to list all the matching Pods first, then copy
    and paste the unique name of the Pod you’re interested in into a new command.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Click 就像是一个交互式的 `kubectl` 版本，它*记住*了你正在处理的当前对象。例如，在 `kubectl` 中想要查找和描述一个 Pod，通常需要先列出所有匹配的
    Pods，然后复制并粘贴感兴趣的 Pod 的唯一名称到一个新命令中。
- en: Instead, with Click you can select any resource from a list by typing its number
    (for example, `1` for the first item). That’s now the current resource, and the
    next Click command will operate on that resource by default. To make finding the
    object you want easier, Click supports searching by regular expressions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用 Click，你可以通过键入其编号（例如，`1` 表示第一个项目）来选择列表中的任何资源。这样选择后，当前的资源就是所选的资源，默认情况下，下一个
    Click 命令将操作该资源。为了更轻松地找到你想要的对象，Click 支持通过正则表达式进行搜索。
- en: kubed-sh
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: kubed-sh
- en: 'While `kube-shell` and Click provide local shells that know a little about
    Kubernetes, [`kubed-sh`](https://kubed.sh) (pronounced *kube-dash*) is a more
    intriguing idea: a shell that runs, in some sense, *on* the cluster itself.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `kube-shell` 和 Click 提供了一些了解 Kubernetes 的本地 shell 功能，[`kubed-sh`](https://kubed.sh)（发音为
    *kube-dash*）是一个更有趣的想法：一种在集群内部运行的 shell。
- en: '`kubed-sh` will pull and run the necessary containers to execute JavaScript,
    Ruby, or Python programs on your current cluster. You can create, for example,
    a Ruby script on your local machine, and use `kubed-sh` to execute the script
    as a Kubernetes Deployment.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubed-sh` 将拉取并运行必要的容器来执行 JavaScript、Ruby 或 Python 程序在你的当前集群上。例如，你可以在本地机器上创建一个
    Ruby 脚本，并使用 `kubed-sh` 将该脚本作为 Kubernetes 部署执行。'
- en: Stern
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stern
- en: While `kubectl logs` is a useful command (see [“Viewing a Container’s Logs”](#containerlogs)),
    it’s not as convenient as it could be. For example, before you can use it, you
    first have to find out the unique name of the Pod and container whose logs you
    want to see, and specify these on the command line, which generally means at least
    one copy and paste.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `kubectl logs` 是一个有用的命令（参见 [“查看容器日志”](#containerlogs)），但它并不像它本应该那样方便。例如，在使用它之前，你首先需要找出你想要查看日志的
    Pod 和容器的唯一名称，并在命令行中指定这些信息，通常意味着至少要复制并粘贴一次。
- en: Also, if you’re using `-f` to follow logs from a particular container, whenever
    the container is restarted, your log stream will stop. You’ll have to find out
    the new name of the container and run `kubectl logs` again to follow it. And you
    can only follow logs from one Pod at a time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你使用 `-f` 来跟踪特定容器的日志，当容器重新启动时，你的日志流将停止。你需要找出容器的新名称，然后再次运行 `kubectl logs`
    来跟踪它。而且你一次只能跟踪一个 Pod 的日志。
- en: A more sophisticated log-streaming tool would allow you to specify a group of
    Pods with a regular expression matching their names or labels, and it would be
    able to keep on streaming logs even if individual containers are restarted.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的日志流工具可以让你通过匹配它们的名称或标签的正则表达式来指定一组 Pods，并且即使个别容器被重新启动，它也能持续流式传输日志。
- en: Fortunately, that’s exactly what the [Stern](https://oreil.ly/5fNnO) tool does.
    Stern tails the logs from all Pods matching a regular expression (for example
    `demo.*`). If there are multiple containers within the Pod, Stern will show you
    log messages from each, prefixed by its name.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这正是 [Stern](https://oreil.ly/5fNnO) 工具所做的。Stern 尾随匹配正则表达式的所有 Pods 的日志（例如
    `demo.*`）。如果 Pod 中有多个容器，Stern 将显示每个容器的日志消息，以其名称为前缀。
- en: The `--since` flag lets you limit the output to recent messages (within the
    last 10 minutes, in the example).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`--since` 标志允许你限制输出到最近的消息（例如在上述示例中为最近 10 分钟内的消息）。'
- en: Instead of matching specific Pod names with a regular expression, you can use
    any Kubernetes label selector expression, just as with `kubectl`. Combined with
    the `--all-namespaces` flag, this is ideal for watching logs from multiple containers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用正则表达式匹配特定 Pod 名称不同，你可以使用任何 Kubernetes 标签选择器表达式，就像使用 `kubectl` 一样。结合 `--all-namespaces`
    标志使用，这非常适合查看多个容器的日志。
- en: Kubernetes IDEs
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes IDEs
- en: As you use Kubernetes more and more, you will quickly find that you need ways
    to efficiently find, view, and edit all of the YAML manifests involved. You will
    be jumping around between different applications across different namespaces and
    clusters. Your favorite text editor and `kubectl` may be all that you need, but
    there are also some great tools that are worth trying out that add nice features
    and visualizations for interacting with Kubernetes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您对Kubernetes的使用越来越多，您将迅速发现需要有效地查找、查看和编辑涉及的所有YAML清单的方法。您将在不同的命名空间和集群之间跳转。您喜爱的文本编辑器和`kubectl`可能是您所需的一切，但也有一些很棒的工具值得尝试，这些工具为与Kubernetes交互添加了漂亮的功能和可视化效果。
- en: Lens
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lens
- en: '[Lens](https://oreil.ly/5JwOQ) is a GUI application that works like an advanced
    visualizer and IDE specifically made for interacting with Kubernetes clusters.
    You can use it as a dashboard explorer to see what is happening inside of your
    cluster. Lens makes it easy to jump between contexts and namespaces to get an
    overview of what is running and includes an integrated Terminal you can use for
    `kubectl`.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[Lens](https://oreil.ly/5JwOQ)是一个GUI应用程序，像高级可视化器和IDE一样专为与Kubernetes集群交互而制作。您可以将其用作仪表板资源管理器，查看集群内部的运行情况。Lens使得在不同上下文和命名空间之间快速切换变得容易，并包括一个集成的终端，您可以用于`kubectl`。'
- en: VS Code Kubernetes Extension
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code Kubernetes扩展
- en: VS Code is a popular text editor with a huge ecosystem of extensions for just
    about anything. Like Lens, you can use the [Kubernetes extension](https://oreil.ly/4sQU3)
    as a dashboard tool for your cluster. It also includes special integration with
    Azure for creating AKS clusters and directly deploying applications.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[VS Code](https://oreil.ly/4sQU3)是一个流行的文本编辑器，拥有庞大的扩展生态系统，可以为几乎所有内容提供扩展。就像[Lens](https://oreil.ly/5JwOQ)，你可以使用[Kubernetes扩展](https://oreil.ly/4sQU3)作为集群的仪表板工具。它还包括与Azure的特殊集成，用于创建AKS集群和直接部署应用程序。'
- en: Building Your Own Kubernetes Tools
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您自己的Kubernetes工具
- en: Combined with query tools like `jq` and the standard set of Unix utilities (`cut`,
    `grep`, `xargs`, and friends), `kubectl` can be used for some fairly sophisticated
    scripting of Kubernetes resources. As we’ve seen in this chapter, there are also
    many third-party tools available that you can use as part of automated scripts.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 结合像`jq`和标准的Unix工具集（`cut`，`grep`，`xargs`等）这样的查询工具，`kubectl`可以用于对Kubernetes资源进行一些相当复杂的脚本编写。正如我们在本章中看到的那样，还有许多第三方工具可用于自动化脚本的一部分。
- en: This approach has its limits, however. It’s fine to cook up ingenious one-liners
    and ad hoc shell scripts for interactive debugging and exploration, but they can
    be hard to understand and maintain.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有其局限性。为交互式调试和探索编写巧妙的单行命令和临时shell脚本是可以的，但它们可能难以理解和维护。
- en: For real systems programs automating your production workflows, we strongly
    recommend you use a real systems programming language. Go is the logical choice,
    since it was good enough for the Kubernetes authors—and naturally, Kubernetes
    includes a [full-featured client library](https://oreil.ly/XYJYq) for use in Go
    programs.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动化生产工作流程的真实系统程序，我们强烈建议您使用真实的系统编程语言。Go是一个合乎逻辑的选择，因为它足够好用于Kubernetes的作者们——当然，Kubernetes还包含了用于Go程序的[功能齐全的客户端库](https://oreil.ly/XYJYq)。
- en: 'Because the `client-go` library gives you complete access to the Kubernetes
    API, you can do anything with it that `kubectl` can do, and more. The following
    snippet shows how to list all the Pods in your cluster, for example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`client-go`库为您提供了对Kubernetes API的完全访问权限，您可以像`kubectl`一样做任何事情，甚至更多。以下片段展示了如何列出集群中的所有Pods，例如：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can also create or delete Pods, Deployments, or any other resources. You
    can even implement your own custom resource types.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建或删除Pods、Deployments或任何其他资源。您甚至可以实现自己的自定义资源类型。
- en: If you need a feature that’s missing from Kubernetes, you can implement it yourself,
    using the client library.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个在Kubernetes中缺失的功能，可以使用客户端库自行实现。
- en: Other programming languages, such as Python, Java, and dotnet, also have official
    [Kubernetes client libraries](https://oreil.ly/vRTPf) you can use in the same
    way. There are also community-maintained libraries for other programming languages
    as well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 其他编程语言，如Python，Java和dotnet，也有官方的[Kubernetes客户端库](https://oreil.ly/vRTPf)，您可以以同样的方式使用。还有社区维护的其他编程语言的库。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There is a bewildering profusion of Kubernetes tools available, and more are
    released every week. You could be forgiven for feeling a little weary when reading
    about yet another tool you apparently can’t do without.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 工具种类繁多，每周都会有新工具发布。再看到另一个貌似离不开的工具时，你可能会感到有些厌倦。
- en: The fact is, you don’t need most of these tools. Kubernetes itself, via `kubectl`,
    can do most everything you want it to. The rest is just for fun and convenience.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大多数这些工具你都不需要。Kubernetes 本身通过 `kubectl` 就能完成你大部分需求。其余的只是为了好玩和方便而已。
- en: Nobody knows everything, but everybody knows something. In writing this chapter,
    we’ve incorporated tips and tricks from lots of experienced Kubernetes engineers,
    from books, blog posts, and documentation, and one or two little discoveries of
    our own. Everybody we’ve shown it to, no matter how expert, learned at least one
    useful thing. That makes us happy.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人知道所有事情，但每个人都知道一些事情。在撰写本章时，我们整合了许多经验丰富的 Kubernetes 工程师的技巧和窍门，来自书籍、博客文章和文档，以及我们自己的一两个小发现。我们向每个人展示过，无论多么专家，至少都学到了一些有用的东西。这让我们感到高兴。
- en: It’s worth taking a little time to get familiar with `kubectl` and explore its
    possibilities; it’s the most important Kubernetes tool you have, and you’ll be
    using it a lot.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花点时间来熟悉 `kubectl` 并探索其可能性；它是你使用最多的最重要的 Kubernetes 工具。
- en: 'Here are a few of the most important things to know:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几个最重要的要点需要知道：
- en: '`kubectl` includes complete and exhaustive documentation on itself, available
    with `kubectl -h`, and on every Kubernetes resource, field, or feature, using
    `kubectl explain`.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` 包含了关于自身的完整详尽文档，可以使用 `kubectl -h` 获取，以及关于每个 Kubernetes 资源、字段或特性的文档，使用
    `kubectl explain`。'
- en: When you want to do complicated filtering and transformations on `kubectl` output,
    for example in scripts, select JSON format with `-o json`. Once you have JSON
    data, you can use power tools like `jq` to query it.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如在脚本中需要对 `kubectl` 输出进行复杂的过滤和转换时，可以选择 JSON 格式，使用 `-o json`。有了 JSON 数据，你可以使用像
    `jq` 这样的强大工具来查询。
- en: The `--dry-run=client` option to `kubectl`, combined with `-o YAML` to get YAML
    output, lets you use imperative commands to generate Kubernetes manifests. This
    is a big time-saver when creating manifest files for new applications, for example.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl --dry-run=client` 选项结合 `-o YAML` 可以使用命令式命令生成 Kubernetes 清单文件。例如，对于新应用程序的清单文件创建，这可以大大节省时间。'
- en: You can turn existing resources into YAML manifests, too, using the `-o` flag
    to `kubectl get`.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用 `-o` 标志将现有资源转换为 YAML 清单，使用 `kubectl get`。
- en: '`kubectl diff` will tell you what *would* change if you applied a manifest,
    without actually changing it.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl diff` 将告诉你如果应用清单会发生什么*变化*，而不会实际更改它。'
- en: You can see the output and error messages from any container with `kubectl logs`,
    stream them continuously with the `--follow` flag, or do more sophisticated multi-Pod
    log tailing with Stern.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `kubectl logs` 查看任何容器的输出和错误消息，使用 `--follow` 标志连续流式传输它们，或者使用 Stern 进行更复杂的多
    Pod 日志尾随。
- en: To troubleshoot problem containers, you can attach to them with `kubectl attach`
    or get a shell on the container with `kubectl exec -it ... -- /bin/sh`.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要调试问题容器时，可以使用 `kubectl attach` 来附加到容器上，或者使用 `kubectl exec -it ... -- /bin/sh`
    在容器上获取 shell。
- en: You can run any public container image with `kubectl run` to help solve problems,
    including the multitalented BusyBox tool, which contains all your favorite Unix
    commands.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `kubectl run` 运行任何公共容器镜像来帮助解决问题，包括多才多艺的 BusyBox 工具，其中包含了所有你喜欢的 Unix 命令。
- en: Kubernetes contexts are like bookmarks, marking your place in a particular cluster
    and namespace. You can switch conveniently between contexts and namespaces using
    the `kubectx` and `kubens` tools.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 上下文就像书签，标记着你在特定集群和命名空间中的位置。你可以使用 `kubectx` 和 `kubens` 工具方便地在上下文和命名空间之间切换。
- en: 'Click is a powerful Kubernetes shell that gives you all the functionality of
    `kubectl`, but with added state: it remembers the currently selected object from
    one command to the next, so you don’t have to specify it every time.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Click 是一个强大的 Kubernetes shell，提供了所有 `kubectl` 的功能，但增加了状态：它记住了从一个命令到下一个命令选择的当前对象，因此你不必每次都指定它。
- en: Lens is a great standalone application you can use to manage Kubernetes clusters.
    VS Code also has a Kubernetes extension, allowing you to interact with your clusters
    alongside of your code.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lens 是一个出色的独立应用程序，可以用来管理 Kubernetes 集群。VS Code 也有一个 Kubernetes 扩展，让你可以在代码旁边与你的集群交互。
- en: Kubernetes is designed to be automated and controlled by code. When you need
    to go beyond what `kubectl` provides, the Kubernetes `client-go` library gives
    you complete control over every aspect of your cluster using Go code.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 设计为可以通过代码自动化和控制。当你需要超出 `kubectl` 提供的功能时，Kubernetes 的 `client-go`
    库可以让你通过 Go 代码完全控制集群的每个方面。
- en: ^([1](ch07.html#idm45979385899936-marker)) [Pulumi](https://www.pulumi.com)
    is a cloud native IaC framework.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#idm45979385899936-marker)) [Pulumi](https://www.pulumi.com)
    是一个云原生基础设施即代码框架。
- en: ^([2](ch07.html#idm45979385568432-marker)) Versions of the BusyBox image later
    than 1.28 have [a problem doing DNS lookups](https://oreil.ly/XxKDS) in Kubernetes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#idm45979385568432-marker)) BusyBox 图像版本在 1.28 之后在 Kubernetes
    中存在 [DNS 查询问题](https://oreil.ly/XxKDS)。
