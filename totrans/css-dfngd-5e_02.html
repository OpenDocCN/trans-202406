<html><head></head><body><section data-pdf-bookmark="Chapter 2. Selectors" data-type="chapter" epub:type="chapter"><div class="chapter" id="selectors">&#13;
<h1><span class="label">Chapter 2. </span>Selectors</h1>&#13;
&#13;
&#13;
<p>One of the <a data-primary="selectors" data-type="indexterm" id="ix_selector_ch2"/>primary advantages of CSS is its ability to easily apply a set of styles to all elements of the same type. Unimpressed? Consider this: by editing a single line of CSS, you can change the colors of all your headings. Don’t like the blue you’re using? Change that one line of code, and they can all be purple, yellow, maroon, or any other color you desire.</p>&#13;
&#13;
<p>This capability lets you, the author, focus on design and user experience rather than tedious find-and-replace operations. The next time you’re in a meeting and someone wants to see headings with a different shade of green, just edit your style and hit Reload. Voilà! The results are accomplished in seconds and there for everyone to see.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Style Rules" data-type="sect1"><div class="sect1" id="basic_style_rules">&#13;
<h1>Basic Style Rules</h1>&#13;
&#13;
<p>As <a data-primary="CSS (Cascading Style Sheets)" data-secondary="basic style rules" data-type="indexterm" id="idm45176129667888"/><a data-primary="rules" data-type="indexterm" id="idm45176129666912"/>stated, a central feature of CSS is its ability to apply certain rules to an entire set of element types in a document. For example, let’s say that you want to make the text of all <code>&lt;h2&gt;</code> elements appear gray. Before we had CSS, you’d have to do this by inserting <code>&lt;font color="gray"&gt;...&lt;/font&gt;</code> tags inside all your <code>&lt;h2&gt;</code> elements. Applying inline styles using the <code>style</code> attribute, which is also bad practice, would require you to include <code>style="color: gray;"</code> in all your <code>&lt;h2&gt;</code> elements, like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h2</code><code class="w"> </code><code class="na">style=</code><code class="s">"color: gray;"</code><code class="nt">&gt;</code>This<code class="w"> </code>is<code class="w"> </code>h2<code class="w"> </code>text<code class="nt">&lt;/h2&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This will be a tedious process if your document contains a lot of <code>&lt;h2&gt;</code> elements. Worse, if you later decide that you want all those <code>&lt;h2&gt;</code>s to be green instead of gray, you’d have to start the manual tagging all over again. (Yes, this is really how it used to be done!)</p>&#13;
&#13;
<p>CSS allows you to create rules that are simple to change, edit, and apply to all the text elements you define (the next section explains how these rules work). For example, you can write this rule once to make all your <code>&lt;h2&gt;</code> elements gray:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Selectors" data-type="sect1"><div class="sect1" id="element_selectors">&#13;
<h1>Type Selectors</h1>&#13;
&#13;
<p>A <em>type selector</em>, previously <a data-primary="document structure" data-secondary="type selectors for" data-type="indexterm" id="idm45176136798448"/><a data-primary="selectors" data-secondary="type" data-type="indexterm" id="idm45176136797440"/><a data-primary="type selectors" data-type="indexterm" id="idm45176136772880"/><a data-primary="element (type) selectors" data-type="indexterm" id="idm45176136772208"/>known as an <em>element selector</em>, is most often an HTML element, but not always. For example, if a CSS file contains styles for an XML document, the type selectors might look something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">quote</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">bib</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">booktitle</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">myElement</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In other words, the elements of the document are the node types being selected. In XML, a <a data-primary="XML" data-secondary="type selectors for" data-type="indexterm" id="idm45176136723456"/>selector could be anything because XML allows for the creation of new markup languages that can have just about anything as an element name. If you’re styling an HTML document, the selector will generally be one of the many defined HTML elements such as <code>&lt;p&gt;</code>, <code>&lt;h3&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;a&gt;</code>, or even <code>&lt;html&gt;</code> itself. For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">html</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#simple_styling_of_a_simple_document">Figure 2-1</a> shows the results of this stylesheet.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="simple_styling_of_a_simple_document">&#13;
<img alt="css5 0201" src="assets/css5_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Simple styling of a simple document</h6>&#13;
</div></figure>&#13;
&#13;
<p>Once you’ve globally applied styles directly to elements, you can shift those styles from one element to another. Let’s say you decide that the paragraph text, not the <code>&lt;h1&gt;</code> elements, in <a data-type="xref" href="#simple_styling_of_a_simple_document">Figure 2-1</a> should be gray. No problem. Just change the <code>h1</code> selector to <code>p</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">html</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#moving_a_style_from_one_element_to_anoth">Figure 2-2</a> shows the results.<a data-primary="" data-startref="ix_elem_selector" data-type="indexterm" id="idm45176136623952"/><a data-primary="" data-startref="ix_selector_type" data-type="indexterm" id="idm45176136623072"/><a data-primary="" data-startref="ix_doc_struct_type_sel" data-type="indexterm" id="idm45176136622128"/></p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="moving_a_style_from_one_element_to_anoth">&#13;
<img alt="css5 0202" src="assets/css5_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>Moving a style from one element to another</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grouping" data-type="sect1"><div class="sect1" id="grouping">&#13;
<h1>Grouping</h1>&#13;
&#13;
<p>So far, you’ve seen fairly simple techniques for applying a single style to a single selector. But what if you want the same style to apply to multiple elements? <em>Grouping</em> allows an author to drastically compact certain types of style assignments, which makes for a shorter stylesheet.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grouping Selectors" data-type="sect2"><div class="sect2" id="grouping_selectors">&#13;
<h2>Grouping Selectors</h2>&#13;
&#13;
<p>Let’s <a data-primary="selectors" data-secondary="grouping of" data-type="indexterm" id="ix_selector_group"/><a data-primary="grouping of selectors" data-type="indexterm" id="ix_group_select"/>say you want both <code>&lt;h2&gt;</code> elements and paragraphs to have gray text. The easiest way to accomplish this is to use the following declaration:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h2</code><code class="o">,</code> <code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>By <a data-primary="comma (,)" data-secondary="separating selectors" data-type="indexterm" id="idm45176136587216"/><a data-primary=", (comma)" data-secondary="separating selectors" data-type="indexterm" id="idm45176136586144"/><a data-primary="{…​} (curly braces)" data-secondary="grouping selectors" data-type="indexterm" id="idm45176136585200"/><a data-primary="curly braces ({…​})" data-secondary="grouping selectors" data-type="indexterm" id="idm45176136584256"/>placing the <code>h2</code> and <code>p</code> selectors at the beginning of the rule, before the opening curly brace, and separating them with a comma, you’ve defined a rule indicating that the style inside the curly braces (<code>color: gray;</code>) applies to the elements referenced by both selectors. The comma tells the browser that two different selectors are involved in the rule. Leaving out the comma would give the rule a completely different meaning, which we’ll explore in <a data-type="xref" href="#descendant_selectors">“Defining Descendant Selectors”</a>.</p>&#13;
&#13;
<p>These <a data-primary="values" data-secondary="specifying multiple" data-type="indexterm" id="idm45176136580784"/>alternatives produce exactly the same result, but one is a lot easier to type:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">h4</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">h5</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">h6</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
&#13;
<code class="nt">h1</code><code class="o">,</code> <code class="nt">h2</code><code class="o">,</code> <code class="nt">h3</code><code class="o">,</code> <code class="nt">h4</code><code class="o">,</code> <code class="nt">h5</code><code class="o">,</code> <code class="nt">h6</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code></pre>&#13;
&#13;
<p id="the_universal_selector">The second alternative, with one grouped selector, is also a lot easier to maintain &#13;
<span class="keep-together">over time.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The universal selector" data-type="sect3"><div class="sect3" id="idm45176136489152">&#13;
<h3>The universal selector</h3>&#13;
&#13;
<p>The <em>universal selector</em>, <a data-primary="* (asterisk)" data-secondary="universal selector" data-type="indexterm" id="idm45176136487472"/><a data-primary="asterisk (*)" data-secondary="universal selector" data-type="indexterm" id="idm45176136486464"/><a data-primary="universal selector (*)" data-type="indexterm" id="idm45176136485520"/><a data-primary="selectors" data-secondary="universal" data-type="indexterm" id="idm45176136484848"/>displayed as an asterisk (<code>*</code>), matches any element at all, much like a wildcard. For example, to make every single element in a document bold, you would write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This declaration is equivalent to a grouped selector that lists every element contained within the document. The universal selector lets you assign the <code>font-weight</code> value <code>bold</code> to every element in the document in one efficient stroke. Beware, however: although the universal selector is convenient because it targets everything within its declaration scope, it can have unintended consequences, which are discussed in <a data-type="xref" href="ch04.html#zeroed_selector_specificity">“Zeroed Selector Specificity”</a>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grouping Declarations" data-type="sect2"><div class="sect2" id="grouping_declarations">&#13;
<h2>Grouping Declarations</h2>&#13;
&#13;
<p>Just as you can <a data-primary="rules" data-secondary="declarations" data-type="indexterm" id="ix_rules_declar"/><a data-primary="grouping of declarations" data-type="indexterm" id="ix_group_declar"/><a data-primary="declarations" data-secondary="grouping of" data-type="indexterm" id="ix_decl_group"/>group selectors into a single rule, you can also group declarations. Assuming that you want all <code>&lt;h1&gt;</code> elements to appear in purple, 18-pixel-high Helvetica text on an aqua background (and you don’t mind blinding your readers), you could write your styles like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">font</code><code class="o">:</code> <code class="m">18px</code> <code class="n">Helvetica</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">aqua</code><code class="p">;}</code></pre>&#13;
&#13;
<p>But this method is inefficient—imagine creating such a list for an element that will carry 10 or 15 styles! Instead, you can group your declarations together:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">font</code><code class="o">:</code> <code class="m">18px</code> <code class="n">Helvetica</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">aqua</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will have exactly the same effect as the three-line stylesheet just shown.</p>&#13;
&#13;
<p>Note <a data-primary="whitespace" data-secondary="separating value keywords" data-type="indexterm" id="idm45176136406944"/><a data-primary="CSS (Cascading Style Sheets)" data-secondary="whitespace in" data-type="indexterm" id="idm45176136406096"/><a data-primary="; (semicolon), in rules" data-type="indexterm" id="idm45176136365600"/><a data-primary="semicolon (;), in rules" data-type="indexterm" id="idm45176136364928"/>that using semicolons at the end of each declaration is crucial when you’re grouping them. Browsers ignore whitespace in stylesheets, so the user agent must rely on correct syntax to parse the stylesheet. You can fearlessly format styles like the <span class="keep-together">following</span>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code>&#13;
  <code class="k">font</code><code class="o">:</code> <code class="m">18px</code> <code class="n">Helvetica</code><code class="p">;</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;</code>&#13;
  <code class="k">background</code><code class="o">:</code> <code class="nb">aqua</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can also minimize your CSS, removing all unrequired spaces:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code><code class="p">{</code><code class="k">font</code><code class="o">:</code><code class="m">18px</code> <code class="n">Helvetica</code><code class="p">;</code><code class="k">color</code><code class="o">:</code><code class="nb">purple</code><code class="p">;</code><code class="k">background</code><code class="o">:</code><code class="nb">aqua</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The last three examples are treated equally by the server, but the second one is generally regarded as the most human-readable, and is the recommended method of writing your CSS during development. You might choose to minimize your CSS for network-performance reasons, but this is usually automatically handled by a build tool, server-side script, caching network, or other service, so you’re usually better off writing your CSS in a human-readable fashion.</p>&#13;
&#13;
<p>If the <a data-primary="; (semicolon), in rules" data-type="indexterm" id="idm45176136311552"/><a data-primary="semicolon (;), in rules" data-type="indexterm" id="idm45176136310944"/>semicolon is omitted on the second statement,  the user agent will interpret the stylesheet as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code>&#13;
  <code class="k">font</code><code class="o">:</code> <code class="m">18px</code> <code class="n">Helvetica</code><code class="p">;</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">purple</code> <code class="k">background</code><code class="o">:</code> <code class="nb">aqua</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because <code>background:</code> is not a valid value for <code>color</code>, a user agent will ignore the <code>color</code> declaration entirely (including the <code>background: aqua</code> part). You might think the browser would at least render <code>&lt;h1&gt;</code>s as purple text without an aqua background, but not so. Instead, they will be the inherited color with a transparent background. The declaration <code>font: 18px Helvetica</code> will still take effect since it was correctly terminated with a semicolon.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Although following the last declaration of a rule with a semicolon is not technically necessary in CSS, doing so is generally good practice. First, it will keep you in the habit of terminating your declarations with semicolons, the lack of which is one of the most common causes of rendering errors. Second, if you decide to add another declaration to a rule, you won’t have to worry about forgetting to insert an extra semicolon.</p>&#13;
</div>&#13;
&#13;
<p>As with selector grouping, declaration grouping is a convenient way to keep your stylesheets short, expressive, and easy to maintain.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grouping Everything" data-type="sect2"><div class="sect2" id="grouping_everything">&#13;
<h2>Grouping Everything</h2>&#13;
&#13;
<p>You now know that you can group selectors and you can group declarations. By combining both kinds of grouping in single rules, you can define very complex styles using only a few statements. Now, what if you want to assign some complex styles to all the headings in a document, and you want the same styles to be applied to all of them? Here’s how:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code><code class="o">,</code> <code class="nt">h2</code><code class="o">,</code> <code class="nt">h3</code><code class="o">,</code> <code class="nt">h4</code><code class="o">,</code> <code class="nt">h5</code><code class="o">,</code> <code class="nt">h6</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;</code>&#13;
  <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">black</code><code class="p">;</code> <code class="k">font-family</code><code class="o">:</code> <code class="n">Charcoal</code><code class="o">,</code> <code class="nb">sans-serif</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Here we’ve <a data-primary="{…​} (curly braces)" data-secondary="grouping declarations" data-type="indexterm" id="idm45176117889200"/><a data-primary="curly braces ({…​})" data-secondary="grouping declarations" data-type="indexterm" id="idm45176117885072"/>grouped the selectors, so the styles inside the curly braces will be applied to all the headings listed; grouping the declarations means that all of the listed styles will be applied to the selectors on the left side of the rule. <a data-type="xref" href="#grouping_both_selectors_and_rules">Figure 2-3</a> shows the result of this rule.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="grouping_both_selectors_and_rules">&#13;
<img alt="css5 0203" src="assets/css5_0203.png"/>&#13;
<h6><span class="label">Figure 2-3. </span>Grouping both selectors and rules</h6>&#13;
</div></figure>&#13;
&#13;
<p>This approach is preferable to the drawn-out alternative, which would begin with something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h4</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h5</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h6</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<p>…​and continue for many lines. You <em>can</em> write out your styles the long way, but we don’t recommend it—editing them would be about as tedious as using <code>style</code> attributes &#13;
<span class="keep-together">everywhere!</span></p>&#13;
&#13;
<p>Grouping allows for some interesting choices. <a data-primary="" data-startref="ix_group_select" data-type="indexterm" id="idm45176117838736"/><a data-primary="" data-startref="ix_decl_group" data-type="indexterm" id="idm45176117837760"/><a data-primary="" data-startref="ix_group_declar" data-type="indexterm" id="idm45176117836816"/><a data-primary="" data-startref="ix_rules_declar" data-type="indexterm" id="idm45176117835872"/><a data-primary="" data-startref="ix_selector_group" data-type="indexterm" id="idm45176117834928"/>For example, all the groups of rules in the following example are equivalent—each merely shows a different way of grouping both selectors and declarations:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* group 1 */</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h4</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">b</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
&#13;
&#13;
<code class="c">/* group 2 */</code>&#13;
<code class="nt">h1</code><code class="o">,</code> <code class="nt">h2</code><code class="o">,</code> <code class="nt">h4</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">h2</code><code class="o">,</code> <code class="nt">h3</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h1</code><code class="o">,</code> <code class="nt">h4</code><code class="o">,</code> <code class="nt">b</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">b</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
&#13;
<code class="c">/* group 3 */</code>&#13;
<code class="nt">h1</code><code class="o">,</code> <code class="nt">h4</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">h2</code><code class="o">,</code> <code class="nt">h3</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">b</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Any of these three approaches to grouping selectors and declarations will yield the result shown in <a data-type="xref" href="#the_result_of_equivalent_style_sheets">Figure 2-4</a>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="the_result_of_equivalent_style_sheets">&#13;
<img alt="css5 0204" src="assets/css5_0204.png"/>&#13;
<h6><span class="label">Figure 2-4. </span>The result of equivalent stylesheets</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Class and ID Selectors" data-type="sect1"><div class="sect1" id="class_and_id_selectors">&#13;
<h1>Class and ID Selectors</h1>&#13;
&#13;
<p>So far, we’ve been grouping selectors and declarations together in a variety of ways, but the selectors we’ve been using are very simple ones that refer only to document elements. Type selectors are fine up to a point, but oftentimes you need something a little more focused.</p>&#13;
&#13;
<p>In addition to type selectors, CSS has <em>class selectors</em> and <em>ID selectors</em>, which let you assign styles based on HTML attributes but independent of element type. These selectors can be used on their own or in conjunction with type selectors. However, they work only if you’ve marked up your document appropriately, so using them generally involves a little forethought and planning.</p>&#13;
&#13;
<p>For example, say a document contains multiple warnings. You want each warning to appear in boldfaced text so that it will stand out. However, you don’t know which element types contain this warning content. Some warnings could be entire paragraphs, while others could be a single item within a lengthy list or a few words in a section of text. So, you can’t define a rule using type selectors of any kind. Suppose you tried this route:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code>&#13;
  <code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><em>All</em> paragraphs would be red and bold, not just those that contain warnings. You need a way to select only the text that contains warnings—or, more precisely, a way to select only those elements that are warnings. How do you do it? You apply styles to parts of the document that have been marked in a certain way, independent of the elements involved, by using class selectors.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Class Selectors" data-type="sect2"><div class="sect2" id="class_selectors">&#13;
<h2>Class Selectors</h2>&#13;
&#13;
<p>The <a data-primary="class selectors" data-type="indexterm" id="ix_class_selector"/><a data-primary="selectors" data-secondary="class" data-type="indexterm" id="ix_selector_class"/>most common way to apply styles without worrying about the elements involved is to use <em>class selectors</em>. Before you can use them, however, you need to modify your document markup so that the class selectors will work. Enter the <code>class</code> attribute:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"warning"</code><code class="nt">&gt;</code>When<code class="w"> </code>handling<code class="w"> </code>plutonium,<code class="w"> </code>care<code class="w"> </code>must<code class="w"> </code>be<code class="w"> </code>taken<code class="w"> </code>to<code class="w"> </code>avoid<code class="w"/>&#13;
the<code class="w"> </code>formation<code class="w"> </code>of<code class="w"> </code>a<code class="w"> </code>critical<code class="w"> </code>mass.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code>With<code class="w"> </code>plutonium,<code class="w"> </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"warning"</code><code class="nt">&gt;</code>the<code class="w"> </code>possibility<code class="w"> </code>of<code class="w"> </code>implosion<code class="w"> </code>is<code class="w"/>&#13;
very<code class="w"> </code>real,<code class="w"> </code>and<code class="w"> </code>must<code class="w"> </code>be<code class="w"> </code>avoided<code class="w"> </code>at<code class="w"> </code>all<code class="w"> </code>costs<code class="nt">&lt;/span&gt;</code>.<code class="w"> </code>This<code class="w"> </code>can<code class="w"> </code>be<code class="w"> </code>accomplished<code class="w"/>&#13;
by<code class="w"> </code>keeping<code class="w"> </code>the<code class="w"> </code>various<code class="w"> </code>masses<code class="w"> </code>separate.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>To <a data-primary="class attribute" data-type="indexterm" id="idm45176127783840"/>associate the styles of a class selector with an element, you must assign a <code>class</code> attribute the appropriate value. In the previous code block, a <code>class</code> value of <code>warning</code> is assigned to two elements: the first paragraph and the <code>&lt;span&gt;</code> element in the second &#13;
<span class="keep-together">paragraph.</span></p>&#13;
&#13;
<p>To <a data-primary="period (.), in class selectors" data-type="indexterm" id="ix_period_class_select2"/><a data-primary=". (period), in class selectors" data-type="indexterm" id="ix_period_class_select"/>apply styles to these classed elements, you can use a compact notation in which the name of the class is preceded by a period (<code>.</code>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nc">.warning</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>When combined with the example markup shown earlier, this simple rule has the effect shown in <a data-type="xref" href="#using_a_class_selector">Figure 2-5</a>. The declaration <code>font-weight: bold</code> will be applied to every element that carries a <code>class</code> attribute with a value of <code>warning</code>.</p>&#13;
&#13;
<p>As <a data-type="xref" href="#using_a_class_selector">Figure 2-5</a> illustrates, the class selector works by directly referencing a value that will be found in the <code>class</code> attribute of an element. This reference is <em>always</em> preceded by a period (<code>.</code>), which marks it as a class selector. The period helps keep the class selector separate from anything with which it might be combined, such as a type selector. For example, you may want boldfaced warning text only when an entire paragraph is a warning:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.warning</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="using_a_class_selector">&#13;
<img alt="css5 0205" src="assets/css5_0205.png"/>&#13;
<h6><span class="label">Figure 2-5. </span>Using a class selector</h6>&#13;
</div></figure>&#13;
&#13;
<p>The selector now matches any <code>&lt;p&gt;</code> elements that have a <code>class</code> attribute containing the word <code>warning</code>, but no other elements of any kind, classed or otherwise. Since the <code>&lt;span&gt;</code> element is not a paragraph, the rule’s selector doesn’t match it, and it won’t be displayed using boldfaced text.</p>&#13;
&#13;
<p>If you wanted to assign different styles to the <code>&lt;span&gt;</code> element, you could use the selector <code>span.warning</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.warning</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nt">span</code><code class="nc">.warning</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In this case, the warning paragraph is boldfaced, while the warning <code>&lt;span&gt;</code> is italicized. Each rule applies only to a specific type of element/class combination, so it does not leak over to other elements.</p>&#13;
&#13;
<p>Another option is to use a combination of a general class selector and an element-specific class selector to make the styles even more useful, as in the following markup:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.warning</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="nt">span</code><code class="nc">.warning</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#using_generic_and_specific_selectors_to">Figure 2-6</a> shows the results.</p>&#13;
&#13;
<p>In this situation, any warning text will be italicized, but only the text within a <code>&lt;span&gt;</code> element with a <code>class</code> of <code>warning</code> will be both boldfaced and italicized.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="using_generic_and_specific_selectors_to">&#13;
<img alt="css5 0206" src="assets/css5_0206.png"/>&#13;
<h6><span class="label">Figure 2-6. </span>Using generic and specific selectors to combine styles</h6>&#13;
</div></figure>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Notice the <a data-primary="selectors" data-secondary="universal" data-type="indexterm" id="idm45176127657296"/><a data-primary="asterisk (*)" data-secondary="universal selector" data-type="indexterm" id="idm45176127656288"/><a data-primary="universal selector (*)" data-secondary="class selector and" data-type="indexterm" id="idm45176127655344"/><a data-primary="* (asterisk)" data-secondary="universal selector" data-type="indexterm" id="idm45176127631408"/>format of the general class selector used in the previous example: it’s a class name preceded by a period, and without an element name or universal selector. If you want to select all elements that share a class name, you can omit the universal selector from a class selector without any ill effects. Thus, <code>*.warning</code> and <code>.warning</code> will have exactly the same effect.<a data-primary="" data-startref="ix_period_class_select" data-type="indexterm" id="idm45176127629504"/><a data-primary="" data-startref="ix_period_class_select2" data-type="indexterm" id="idm45176127628528"/></p>&#13;
</div>&#13;
&#13;
<p>Another thing about class names: they should <em>never</em> begin with a number.  Browsers will allow you to get away with this, but CSS validators will complain, and it’s a bad habit to get into.  Thus, you should write <code>.c8675</code> in your CSS and <code>class="c8675"</code> in your HTML, rather than <code>.8675</code> and <code>class="8675"</code>.  If you must refer to classes that begin with numbers, put a backslash between the period and the first number in your class selector, like so: <code>.\8675</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Multiple Classes" data-type="sect2"><div class="sect2" id="multiple_classes">&#13;
<h2>Multiple Classes</h2>&#13;
&#13;
<p>In the <a data-primary="multiple class selectors" data-type="indexterm" id="ix_multi_class_selector"/>previous section, we dealt with <code>class</code> values that contain a single word. <a data-primary="HTML" data-secondary="multiple selector values versus CSS" data-type="indexterm" id="idm45176127621296"/>In HTML, it’s possible to have a space-separated list of words in a single <code>class</code> value. For example, if you want to mark a particular element as being both urgent and a warning, you could write this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"urgent warning"</code><code class="nt">&gt;</code>When<code class="w"> </code>handling<code class="w"> </code>plutonium,<code class="w"> </code>care<code class="w"> </code>must<code class="w"> </code>be<code class="w"> </code>taken<code class="w"> </code>to<code class="w"/>&#13;
avoid<code class="w"> </code>the<code class="w"> </code>formation<code class="w"> </code>of<code class="w"> </code>a<code class="w"> </code>critical<code class="w"> </code>mass.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code>With<code class="w"> </code>plutonium,<code class="w"> </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"warning"</code><code class="nt">&gt;</code>the<code class="w"> </code>possibility<code class="w"> </code>of<code class="w"> </code>implosion<code class="w"> </code>is<code class="w"/>&#13;
very<code class="w"> </code>real,<code class="w"> </code>and<code class="w"> </code>must<code class="w"> </code>be<code class="w"> </code>avoided<code class="w"> </code>at<code class="w"> </code>all<code class="w"> </code>costs<code class="nt">&lt;/span&gt;</code>.<code class="w"> </code>This<code class="w"> </code>can<code class="w"> </code>be<code class="w"> </code>accomplished<code class="w"/>&#13;
by<code class="w"> </code>keeping<code class="w"> </code>the<code class="w"> </code>various<code class="w"> </code>masses<code class="w"> </code>separate.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The <a data-primary="case sensitivity" data-secondary="class selectors" data-type="indexterm" id="idm45176127592816"/>order of the words doesn’t matter; <code>warning urgent</code> would also work and would yield precisely the same results no matter how your CSS is written. Unlike HTML tags and type selectors, class selectors are case-sensitive.</p>&#13;
&#13;
<p>Now let’s say you want all elements with a <code>class</code> of <code>warning</code> to be boldfaced, those with a <code>class</code> of <code>urgent</code> to be italic, and those elements with both values to have a silver background. This would be written as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.warning</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nc">.urgent</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="nc">.warning.urgent</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>By <a data-primary="chaining" data-type="indexterm" id="idm45176127478384"/>chaining two class selectors together, you can select only those elements that have both class names, in any order. As you can see, the HTML source contains <code>class="urgent warning"</code>, but the CSS selector is written <code>.warning.urgent</code>. Regardless, the rule will still cause the “When handling plutonium… ” paragraph to have a silver background, as illustrated in <a data-type="xref" href="#selecting_elements_with_multiple_class_n">Figure 2-7</a>. This happens because the order in which the words are written in the source document, or in the CSS, doesn’t matter. (This is not to say the order of classes is always irrelevant, but we’ll get to that later in the chapter.)</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_elements_with_multiple_class_n">&#13;
<img alt="css5 0207" src="assets/css5_0207.png"/>&#13;
<h6><span class="label">Figure 2-7. </span>Selecting elements with multiple class names</h6>&#13;
</div></figure>&#13;
&#13;
<p>If a multiple class selector contains a name that is not in the space-separated list, the match will fail. Consider the following rule:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.warning.help</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As you might expect, the selector will match only those <code>&lt;p&gt;</code> elements with a <code>class</code> containing the space-separated words <code>warning</code> and <code>help</code>. Therefore, it will not match a <code>&lt;p&gt;</code> element with just the words <code>warning</code> and <code>urgent</code> in its <code>class</code> attribute. It would, however, match the following:<a data-primary="" data-startref="ix_selector_class" data-type="indexterm" id="idm45176127489632"/><a data-primary="" data-startref="ix_class_selector" data-type="indexterm" id="idm45176127457328"/><a data-primary="" data-startref="ix_multi_class_selector" data-type="indexterm" id="idm45176127456384"/></p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"urgent warning help"</code><code class="nt">&gt;</code>Help<code class="w"> </code>me!<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="ID Selectors" data-type="sect2"><div class="sect2" id="id_selectors">&#13;
<h2>ID Selectors</h2>&#13;
&#13;
<p>In <a data-primary="selectors" data-secondary="ID" data-type="indexterm" id="ix_selectors_id"/><a data-primary="ID selectors" data-type="indexterm" id="ix_id_selector"/><a data-primary="number sign (#)" data-secondary="in ID selectors" data-secondary-sortas="ID selectors" data-type="indexterm" id="idm45176127425968"/><a data-primary="octothorpe (#)" data-secondary="in ID selectors" data-secondary-sortas="ID selectors" data-type="indexterm" id="idm45176127424752"/><a data-primary="pound sign (#)" data-secondary="in ID selectors" data-type="indexterm" id="idm45176127423536"/><a data-primary="hash mark (#)" data-secondary="in ID selectors" data-secondary-sortas="ID selectors" data-type="indexterm" id="idm45176127422592"/><a data-primary="# (octothorpe)" data-secondary="in ID selectors" data-secondary-sortas="ID selectors" data-type="indexterm" id="idm45176127421376"/>some ways, <em>ID selectors</em> are similar to class selectors, but a few crucial differences exist. First, ID selectors are preceded by a hash sign (<code>#</code>)—formally called an octothorpe and also known as a pound sign (in the United States), number sign, or tic-tac-toe board—instead of a period. Thus, you might see a rule like this one:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nf">#first-para</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This <a data-primary="id attribute" data-type="indexterm" id="idm45176127392192"/>rule produces boldfaced text in any element whose <code>id</code> attribute has a value of &#13;
<span class="keep-together"><code>first-para</code>.</span></p>&#13;
&#13;
<p>The second difference is that instead of referencing values of the <code>class</code> attribute, ID selectors refer, sensibly enough, to values found in <code>id</code> attributes. Here’s an example of an ID selector in action:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nf">#lead-para</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">id=</code><code class="s">"lead-para"</code><code class="nt">&gt;</code>This<code class="w"> </code>paragraph<code class="w"> </code>will<code class="w"> </code>be<code class="w"> </code>boldfaced.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code>This<code class="w"> </code>paragraph<code class="w"> </code>will<code class="w"> </code>NOT<code class="w"> </code>be<code class="w"> </code>bold.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Note that the value <code>lead-para</code> could have been assigned to any element within the document. In this particular case, it is applied to the first paragraph, but we could have applied it just as easily to the second or third paragraph.  Or an unordered list.  Or anything.</p>&#13;
&#13;
<p>The third difference is that a document should have only one instance of a given ID value.  If you find yourself wanting to apply the same ID to multiple elements in a document, make it a class instead.</p>&#13;
&#13;
<p>As with <a data-primary="selectors" data-secondary="universal" data-type="indexterm" id="idm45176127314672"/><a data-primary="universal selector (*)" data-secondary="class selector and" data-type="indexterm" id="idm45176127313696"/><a data-primary="* (asterisk)" data-secondary="universal selector" data-type="indexterm" id="idm45176127312752"/><a data-primary="asterisk (*)" data-secondary="universal selector" data-type="indexterm" id="idm45176127311808"/>class selectors, it is possible (and very much the norm) to omit the universal selector from an ID selector. In the previous example, we could also have written this with the exact same effect:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#lead-para</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This is useful when you know that a certain ID value will appear in a document, but you don’t know the element type on which it will appear. For example, you may know that in any given document, there will be an element with an ID value of <code>mostImportant</code>. You don’t know whether that most important thing will be a paragraph, a short phrase, a list item, or a section heading. You know only that it will exist in each document, occur in an arbitrary element, and appear no more than once. In that case, you would write a rule like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#mostImportant</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This rule would match any of the following elements (which, as noted before, should <em>not</em> appear together in the same document because they all have the same ID value):</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1</code><code class="w"> </code><code class="na">id=</code><code class="s">"mostImportant"</code><code class="nt">&gt;</code>This<code class="w"> </code>is<code class="w"> </code>important!<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;em</code><code class="w"> </code><code class="na">id=</code><code class="s">"mostImportant"</code><code class="nt">&gt;</code>This<code class="w"> </code>is<code class="w"> </code>important!<code class="nt">&lt;/em&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;ul</code><code class="w"> </code><code class="na">id=</code><code class="s">"mostImportant"</code><code class="nt">&gt;</code>This<code class="w"> </code>is<code class="w"> </code>important!<code class="nt">&lt;/ul&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>While HTML standards say each <code>id</code> must be unique in a document, CSS doesn’t care. If we had erroneously included the HTML shown just now, all three would likely be red with a yellow background because all three match the <code>#mostImportant</code> selector.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As with class names, IDs should never start with numbers.  If you must refer to an ID that begins with a number and cannot change the ID value in the markup, use a backslash before the first number, as in <code>#\309</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deciding Between Class and ID" data-type="sect2"><div class="sect2" id="deciding_between_class_and_id">&#13;
<h2>Deciding Between Class and ID</h2>&#13;
&#13;
<p>You may <a data-primary="selectors" data-secondary="class" data-type="indexterm" id="idm45176134320032"/><a data-primary="class selectors" data-type="indexterm" id="idm45176134319024"/>assign classes to any number of elements, as demonstrated earlier; the class name <code>warning</code> was applied to both a <code>&lt;p&gt;</code> and a <code>&lt;span&gt;</code> element, and it could have been applied to many more elements. ID values, on the other hand, should be used once, and only once, within an HTML document. Therefore, if you have an element with an <code>id</code> value of <code>lead-para</code>, no other element in that document should have an <code>id</code> value of &#13;
<span class="keep-together"><code>lead-para</code>.</span></p>&#13;
&#13;
<p>That’s <a data-primary="HTML" data-secondary="multiple selector values versus CSS" data-type="indexterm" id="idm45176134287728"/>according to the HTML specification, anyway.  As noted previously, CSS doesn’t care if your HTML is valid or not: it should find however many elements a selector can match.  That means that if you sprinkle an HTML document with several elements, all of which have the same value for their ID attributes, you should get the same styles applied to each.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Having <a data-primary="Document Object Model (DOM)" data-secondary="ID selectors and" data-type="indexterm" id="idm45176134285648"/>more than one of the same ID value in a document makes DOM scripting more difficult, since functions like <code>getElementById()</code> depend on there being one, and only one, element with a given ID value.</p>&#13;
</div>&#13;
&#13;
<p>Unlike class selectors, ID selectors can’t be combined with other IDs, since ID attributes do not permit a space-separated list of words.  An ID selector can be combined with itself, though: <code>#warning#warning</code> will match the element with an <code>id</code> value of <code>warning</code>.  This should rarely, if ever, be done, but it is possible.</p>&#13;
&#13;
<p>Another difference between <code>class</code> and <code>id</code> names is that IDs carry more weight when you’re trying to determine which styles should be applied to a given element. This is explained in greater detail in <a data-type="xref" href="ch04.html#specificity_comma_inheritance">Chapter 4</a>.</p>&#13;
&#13;
<p>Also <a data-primary="case sensitivity" data-secondary="ID selectors" data-type="indexterm" id="idm45176134279712"/>note that HTML defines class and ID values to be case-sensitive, so the capitalization of your class and ID values must match what’s found in your documents. Thus, in the following pairing of CSS and HTML, the element’s text will not be boldfaced:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.criticalInfo</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"criticalinfo"</code><code class="nt">&gt;</code>Don't<code class="w"> </code>look<code class="w"> </code>down.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Because of the change in case for the letter <em>i</em>, the selector will not match the &#13;
<span class="keep-together">element</span> shown.</p>&#13;
&#13;
<p>On a <a data-primary="XML" data-secondary="class selector support" data-type="indexterm" id="idm45176134257056"/><a data-primary="XML" data-secondary="dot-class notation issue for" data-type="indexterm" id="idm45176134256048"/>purely syntactical level, the dot-class notation (e.g., <code>.warning</code>) is not guaranteed to work for XML documents. As of this writing, the dot-class notation works in HTML, Scalar Vector Graphics (SVG), and Mathematical Markup Language (MathML), and it may well be permitted in future languages, but it’s up to each language’s specification to decide that. The hash-ID notation (e.g., <code>#lead</code>) should work in any document language that has an attribute whose value is supposed to be unique within a document.<a data-primary="" data-startref="ix_id_selector" data-type="indexterm" id="idm45176134254080"/><a data-primary="" data-startref="ix_selectors_id" data-type="indexterm" id="idm45176134226352"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Attribute Selectors" data-type="sect1"><div class="sect1" id="attribute_selectors">&#13;
<h1>Attribute Selectors</h1>&#13;
&#13;
<p>With both <a data-primary="selectors" data-secondary="attribute" data-type="indexterm" id="ix_selector_attrib"/><a data-primary="attribute selectors" data-type="indexterm" id="ix_attrib_select"/>class and ID selectors, what you’re really doing is selecting values of elements’ attributes. The syntax used in the previous two sections is particular to HTML, SVG, and MathML documents as of this writing. In other markup languages, these class and ID selectors may not be available (as, indeed, those attributes may not be present).</p>&#13;
&#13;
<p>To <a data-primary="CSS2 specification" data-secondary="attribute selectors" data-type="indexterm" id="idm45176134220736"/>address this situation, CSS2 introduced <em>attribute selectors</em>, which can be used to select elements based on their attributes and the values of those attributes. There are four general types of attribute selectors: simple attribute selectors, exact attribute value selectors, partial-match attribute value selectors, and leading-value attribute selectors.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simple Attribute Selectors" data-type="sect2"><div class="sect2" id="simple_attribute_selectors">&#13;
<h2>Simple Attribute Selectors</h2>&#13;
&#13;
<p>If you want to select elements that have a certain attribute, regardless of that attribute’s value, you can use a <em>simple attribute selector</em>. For example, to select all <code>&lt;h1&gt;</code> elements that have a <code>class</code> attribute with any value and make their text silver, write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code><code class="o">[</code><code class="nt">class</code><code class="o">]</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>So, given the following markup,</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1</code><code class="w"> </code><code class="na">class=</code><code class="s">"hoopla"</code><code class="nt">&gt;</code>Hello<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h1&gt;</code>Serenity<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h1</code><code class="w"> </code><code class="na">class=</code><code class="s">"fancy"</code><code class="nt">&gt;</code>Fooling<code class="nt">&lt;/h1&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>you get the result shown in <a data-type="xref" href="#selecting_elements_based_on_their_attrib">Figure 2-8</a>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_elements_based_on_their_attrib">&#13;
<img alt="css5 0208" src="assets/css5_0208.png"/>&#13;
<h6><span class="label">Figure 2-8. </span>Selecting elements based on their attributes</h6>&#13;
</div></figure>&#13;
&#13;
<p>This <a data-primary="XML" data-secondary="attribute selectors with" data-type="indexterm" id="idm45176134141488"/>strategy is very useful in XML documents, as XML languages tend to have element and attribute names that are specific to their purpose. Consider an XML language that is used to describe planets of the solar system (we’ll call it <em>PlanetML</em>). If you want to select all <code>&lt;pml-planet&gt;</code> elements with a <code>moons</code> attribute and make them boldface, thus calling attention to any planet that has moons, you would write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">pml-planet</code><code class="o">[</code><code class="nt">moons</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This would cause the text of the second and third elements in the following markup fragment to be boldfaced, but not the first:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;pml-planet&gt;</code>Venus<code class="nt">&lt;/pml-planet&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;pml-planet</code><code class="w"> </code><code class="na">moons=</code><code class="s">"1"</code><code class="nt">&gt;</code>Earth<code class="nt">&lt;/pml-planet&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;pml-planet</code><code class="w"> </code><code class="na">moons=</code><code class="s">"2"</code><code class="nt">&gt;</code>Mars<code class="nt">&lt;/pml-planet&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In <a data-primary="HTML" data-secondary="attribute selectors with" data-type="indexterm" id="idm45176134098336"/>HTML documents, you can use this feature in creative ways. For example, you could style all images that have an <code>alt</code> attribute, thus highlighting those images that are correctly formed:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="o">[</code><code class="nt">alt</code><code class="o">]</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code> <code class="nb">forestgreen</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This particular example is generally useful more for diagnostic purposes—determining whether images are indeed correctly marked up—than for design purposes.</p>&#13;
&#13;
<p>If you wanted to boldface any element that includes <code>title</code> information, which most browsers display as a tool tip when a cursor hovers over the element, you could write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*[</code><code class="nt">title</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Similarly, you could style only those anchors (<code>&lt;a&gt;</code> elements) that have an <code>href</code> attribute, thus applying the styles to any hyperlink but not to any placeholder anchors.</p>&#13;
&#13;
<p>It is also <a data-primary="attribute selectors" data-secondary="chaining" data-type="indexterm" id="idm45176134053712"/>possible to select elements based on the presence of more than one attribute. You do this by chaining the attribute selectors together. For example, to boldface the text of any HTML hyperlink that has both an <code>href</code> and a <code>title</code> attribute, you would write the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">][</code><code class="nt">title</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This would boldface the first link in the following markup, but not the second or third:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"https://www.w3.org/"</code><code class="w"> </code><code class="na">title=</code><code class="s">"W3C Home"</code><code class="nt">&gt;</code>W3C<code class="nt">&lt;/a&gt;&lt;br</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"https://developer.mozilla.org"</code><code class="nt">&gt;</code>Standards<code class="w"> </code>Info<code class="nt">&lt;/a&gt;&lt;br</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">title=</code><code class="s">"Not a link"</code><code class="nt">&gt;</code>dead.letter<code class="nt">&lt;/a&gt;</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selection Based on Exact Attribute Value" data-type="sect2"><div class="sect2" id="selection_based_on_exact_attribute_value">&#13;
<h2>Selection Based on Exact Attribute Value</h2>&#13;
&#13;
<p>You can <a data-primary="attribute selectors" data-secondary="based on exact value" data-type="indexterm" id="ix_attrib_exact"/>further narrow the selection process to encompass only those elements whose attributes are a certain value. For example, let’s say you want to boldface any hyperlink that points to a certain document on the web server. This would look something like &#13;
<span class="keep-together">the following:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">=</code><code class="s2">"http://www.css-discuss.org/about.html"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will boldface the text of any <code>a</code> element that has an <code>href</code> attribute with <em>exactly</em> the value <code>http://www.css-discuss.org/about.html</code>. Any change at all, even dropping the <code>www.</code> part or changing to a secure protocol with <code>https</code>, will prevent a match.</p>&#13;
&#13;
<p>Any <a data-primary="XML" data-secondary="attribute selectors with" data-type="indexterm" id="idm45176133901728"/>attribute and value combination can be specified for any element. However, if that exact combination does not appear in the document, the selector won’t match anything. Again, XML languages can benefit from this approach to styling. Let’s return to our PlanetML example. Suppose you want to select only those <code>planet</code> elements that have a value of <code>1</code> for the attribute <code>moons</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">planet</code><code class="o">[</code><code class="nt">moons</code><code class="o">=</code><code class="s2">"1"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This would boldface the text of the second element in the following markup fragment, but not the first or third:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;planet&gt;</code>Venus<code class="nt">&lt;/planet&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;planet</code><code class="w"> </code><code class="na">moons=</code><code class="s">"1"</code><code class="nt">&gt;</code>Earth<code class="nt">&lt;/planet&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;planet</code><code class="w"> </code><code class="na">moons=</code><code class="s">"2"</code><code class="nt">&gt;</code>Mars<code class="nt">&lt;/planet&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>As with <a data-primary="attribute selectors" data-secondary="chaining" data-type="indexterm" id="idm45176133789648"/>attribute selection, you can chain together multiple attribute value selectors to select a single document. For example, to double the size of the text of any HTML hyperlink that has both an <code>href</code> with a value of <code>https://www.w3.org/</code> and a <code>title</code> attribute with a value of <code>W3C Home</code>, you would write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">=</code><code class="s2">"https://www.w3.org/"</code><code class="o">][</code><code class="nt">title</code><code class="o">=</code><code class="s2">"W3C Home"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">200%</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This would double the text size of the first link in the following markup, but not the second or third:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"https://www.w3.org/"</code><code class="w"> </code><code class="na">title=</code><code class="s">"W3C Home"</code><code class="nt">&gt;</code>W3C<code class="nt">&lt;/a&gt;&lt;br</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"https://developer.mozilla.org"</code><code class="w"/>&#13;
<code class="w">  </code><code class="na">title=</code><code class="s">"Mozilla Developer Network"</code><code class="nt">&gt;</code>Standards<code class="w"> </code>Info<code class="nt">&lt;/a&gt;&lt;br</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"http://www.example.org/"</code><code class="w"> </code><code class="na">title=</code><code class="s">"W3C Home"</code><code class="nt">&gt;</code>confused.link<code class="nt">&lt;/a&gt;</code><code class="w"/></pre>&#13;
&#13;
<p><a data-type="xref" href="#selecting_elements_based_on_attributes_a">Figure 2-9</a> shows the results.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_elements_based_on_attributes_a">&#13;
<img alt="css5 0209" src="assets/css5_0209.png"/>&#13;
<h6><span class="label">Figure 2-9. </span>Selecting elements based on attributes and their values</h6>&#13;
</div></figure>&#13;
&#13;
<p>Again, this format requires an <em>exact</em> match for the attribute’s value. Matching becomes an issue when an attribute selector encounters values that can, in turn, contain a space-separated list of values (e.g., the HTML attribute <code>class</code>). For example, consider the following markup fragment:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;planet</code><code class="w"> </code><code class="na">type=</code><code class="s">"barren rocky"</code><code class="nt">&gt;</code>Mercury<code class="nt">&lt;/planet&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The only way to match this element based on its exact attribute value is to write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">planet</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"barren rocky"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If you were to write <code>planet[type="barren"]</code>, the rule would not match the example markup and thus would fail. This is true even for the <code>class</code> attribute in HTML. Consider the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"urgent warning"</code><code class="nt">&gt;</code>When<code class="w"> </code>handling<code class="w"> </code>plutonium,<code class="w"> </code>care<code class="w"> </code>must<code class="w"> </code>be<code class="w"> </code>taken<code class="w"> </code>to<code class="w"/>&#13;
avoid<code class="w"> </code>the<code class="w"> </code>formation<code class="w"> </code>of<code class="w"> </code>a<code class="w"> </code>critical<code class="w"> </code>mass.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>To select this element based on its exact attribute value, you would have to write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="o">[</code><code class="nt">class</code><code class="o">=</code><code class="s2">"urgent warning"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This is <em>not</em> equivalent to the dot-class notation covered earlier, as you will see in the next section. Instead, it selects any <code>p</code> element whose <code>class</code> attribute has <em>exactly</em> the value <code>urgent warning</code>, with the words in that order and a single space between them. It’s effectively an exact string match, whereas when using a <code>class</code> selector, the class order doesn’t matter.</p>&#13;
&#13;
<p>Also, be aware that <a data-primary="ID selectors" data-type="indexterm" id="idm45176127013632"/>ID selectors and attribute selectors that target the <code>id</code> attribute are not precisely the same. In other words, a subtle but crucial difference exists between <code>h1#page-title</code> and <code>h1[id="page-title"]</code>. This difference is explained in <a data-type="xref" href="ch04.html#specificity_comma_inheritance">Chapter 4</a>.<a data-primary="" data-startref="ix_attrib_exact" data-type="indexterm" id="idm45176127010608"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selection Based on Partial Attribute Values" data-type="sect2"><div class="sect2" id="selection_based_on_partial_attribute_val">&#13;
<h2>Selection Based on Partial Attribute Values</h2>&#13;
&#13;
<p>Odds are <a data-primary="substring matching, for attribute selectors" data-type="indexterm" id="ix_substring_attrib"/><a data-primary="attribute selectors" data-secondary="based on partial value" data-type="indexterm" id="ix_attrib_partial"/>that you’ll sometimes want to select elements based on portions of their attribute values, rather than the full value.  For such situations, CSS offers a variety of options for matching substrings in an attribute’s value.  These are summarized in <a data-type="xref" href="#substring_matching_with_attribute_select">Table 2-1</a>.<a data-primary="^= (caret, equal sign), in attribute selectors" data-type="indexterm" id="idm45176127004880"/><a data-primary="|= (vertical bar, equal sign), in attribute selectors" data-type="indexterm" id="idm45176127004208"/><a data-primary="$= (dollar sign, equal sign), in attribute selectors" data-type="indexterm" id="idm45176127003504"/><a data-primary="dollar sign, equal sign ($=), in attribute selectors" data-type="indexterm" id="idm45176127002800"/><a data-primary="vertical bar, equal sign (|=), in attribute selectors" data-type="indexterm" id="idm45176127002096"/><a data-primary="~= (tilde, equal sign), in attribute selectors" data-type="indexterm" id="idm45176127001392"/><a data-primary="tilde, equal sign (~=), in attribute selectors" data-type="indexterm" id="idm45176127000688"/></p>&#13;
<table id="substring_matching_with_attribute_select">&#13;
<caption><span class="label">Table 2-1. </span>Substring matching with attribute selectors</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>[foo~="bar"]</code></p></td>&#13;
<td><p>Selects any element with an attribute <code>foo</code> whose value contains the word <code>bar</code> in a space-separated list of words</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>[foo*="bar"]</code></p></td>&#13;
<td><p>Selects any element with an attribute <code>foo</code> whose value <em>contains</em> the substring <code>bar</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>[foo^="bar"]</code></p></td>&#13;
<td><p>Selects any element with an attribute <code>foo</code> whose value <em>begins</em> with <code>bar</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>[foo$="bar"]</code></p></td>&#13;
<td><p>Selects any element with an attribute <code>foo</code> whose value <em>ends</em> with <code>bar</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>[foo|="bar"]</code></p></td>&#13;
<td><p>Selects any element with an attribute <code>foo</code> whose value <em>starts</em> with <code>bar</code> followed by a hyphen (U+002D) or whose value is exactly equal to <code>bar</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The last of these attribute selectors that match on a partial subset of an element’s attribute value is easier to show than it is to describe. Consider the following rule:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*[</code><code class="nt">lang</code><code class="o">|=</code><code class="s2">"en"</code><code class="o">]</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This rule will select any element whose <code>lang</code> attribute is equal to <code>en</code> or begins with <code>en-</code>. Therefore, the first three elements in the following example markup would be selected, but the last two would not:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1</code><code class="w"> </code><code class="na">lang=</code><code class="s">"en"</code><code class="nt">&gt;</code>Hello!<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p</code><code class="w"> </code><code class="na">lang=</code><code class="s">"en-us"</code><code class="nt">&gt;</code>Greetings!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">lang=</code><code class="s">"en-au"</code><code class="nt">&gt;</code>G'day!<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p</code><code class="w"> </code><code class="na">lang=</code><code class="s">"fr"</code><code class="nt">&gt;</code>Bonjour!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h4</code><code class="w"> </code><code class="na">lang=</code><code class="s">"cy-en"</code><code class="nt">&gt;</code>Jrooana!<code class="nt">&lt;/h4&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In general, the form <code>[att|="val"]</code> can be used for any attribute and its values. Let’s say you have a series of figures in an HTML document, each of which has a filename like <em>figure-1.gif</em> or <em>figure-3.jpg</em>. You can match all of these images by using the following &#13;
<span class="keep-together">selector:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="o">[</code><code class="nt">src</code><code class="o">|=</code><code class="s2">"figure"</code><code class="o">]</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Or, if you’re creating a CSS framework or pattern library, instead of creating redundant classes like <code>"btn btn-small btn-arrow btn-active"</code>, you can declare <code>"btn-small-arrow-active"</code>, and target the class of elements with the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*[</code><code class="nt">class</code><code class="o">|=</code><code class="s2">"btn"</code><code class="o">]</code> <code class="p">{</code> <code class="k">border-radius</code><code class="o">:</code> <code class="m">5px</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">button</code> <code class="nt">class</code><code class="o">=</code><code class="s2">"btn-small-arrow-active"</code><code class="o">&gt;</code><code class="nt">Click</code> <code class="nt">Me</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>The most common use for this type of attribute selector is to match language values, as demonstrated in <a data-type="xref" href="ch03.html#the_colon_lang_pseudo-class">“The :lang() and :dir() Pseudo-Classes”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Matching one word in a space-separated list" data-type="sect3"><div class="sect3" id="matching_one_word_in_a_space-separated_l">&#13;
<h3>Matching one word in a space-separated list</h3>&#13;
&#13;
<p>For any <a data-primary="space-separated list of words" data-type="indexterm" id="idm45176126808720"/>attribute that accepts a space-separated list of words, you can select elements based on the presence of any one of those words. The classic example in HTML is the <code>class</code> attribute, which can accept one or more words as its value. Consider our usual example text:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"urgent warning"</code><code class="nt">&gt;</code>When<code class="w"> </code>handling<code class="w"> </code>plutonium,<code class="w"> </code>care<code class="w"> </code>must<code class="w"> </code>be<code class="w"> </code>taken<code class="w"> </code>to<code class="w"/>&#13;
avoid<code class="w"> </code>the<code class="w"> </code>formation<code class="w"> </code>of<code class="w"> </code>a<code class="w"> </code>critical<code class="w"> </code>mass.<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Let’s say you want to select elements whose <code>class</code> attribute contains the word <code>warning</code>. You can do this with an attribute selector:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="o">[</code><code class="nt">class</code><code class="o">~=</code><code class="s2">"warning"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Note the presence of the tilde (<code>~</code>) in the selector. It is the key to selection based on the presence of a space-separated word within the attribute’s value. If you omit the tilde, you would have an exact value-matching attribute selector, as discussed in the previous &#13;
<span class="keep-together">section.</span></p>&#13;
&#13;
<p>This selector construct is equivalent to the dot-class notation discussed in <a data-type="xref" href="#deciding_between_class_and_id">“Deciding Between Class and ID”</a>. Thus, <code>p.warning</code> and <code>p[class~="warning"]</code> are equivalent when applied to HTML documents. Here’s an example that is an HTML version of the PlanetML markup seen earlier:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"barren rocky"</code><code class="nt">&gt;</code>Mercury<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"cloudy barren"</code><code class="nt">&gt;</code>Venus<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"life-bearing cloudy"</code><code class="nt">&gt;</code>Earth<code class="nt">&lt;/span&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>To italicize all elements with the word <code>barren</code> in their <code>class</code> attribute, you write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">span</code><code class="o">[</code><code class="nt">class</code><code class="o">~=</code><code class="s2">"barren"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This rule’s selector will match the first two elements in the example markup and thus italicize their text, as shown in <a data-type="xref" href="#selecting_elements_based_on_portions_of">Figure 2-10</a>. This is the same result we would expect from writing <code>span.barren {font-style: italic;}</code>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_elements_based_on_portions_of">&#13;
<img alt="css5 0210" src="assets/css5_0210.png"/>&#13;
<h6><span class="label">Figure 2-10. </span>Selecting elements based on portions of attribute values</h6>&#13;
</div></figure>&#13;
&#13;
<p>So why bother with the tilde-equals attribute selector in HTML? Because it can be used for any attribute, not just <code>class</code>. For example, you might have a document that contains numerous images, only some of which are figures. You can use a partial-match value attribute selector aimed at the <code>title</code> text to select only those figures:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="o">[</code><code class="nt">title</code><code class="o">~=</code><code class="s2">"Figure"</code><code class="o">]</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This rule selects any image whose <code>title</code> text contains the word <code>Figure</code> (but not <code>figure</code>, as title attributes are case-sensitive). Therefore, as long as all your figures have <code>title</code> text that looks something like “Figure 4. A bald-headed elder statesman,” this rule will match those images. For that matter, the selector <code>img[title~="Figure"]</code> will also match a title attribute with the value “How to Figure Out Who’s in Charge.” Any image that does not have a <code>title</code> attribute, or whose <code>title</code> value doesn’t contain the word <code>Figure</code>, won’t be matched.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Matching a substring within an attribute value" data-type="sect3"><div class="sect3" id="matching_a_substring_within_an_attribute">&#13;
<h3>Matching a substring within an attribute value</h3>&#13;
&#13;
<p>Sometimes you want to <a data-primary="asterisk, equal sign (*=), in attribute selectors" data-type="indexterm" id="ix_asterisk_attrib2"/><a data-primary="*= (asterisk, equal sign), in attribute selectors" data-type="indexterm" id="ix_asterisk_attrib"/>select elements based on a portion of their attribute values, but the values in question aren’t space-separated lists of words. In these cases, you can use the asterisk-equals substring matching form <code>[attr*="val"]</code> to match substrings that appear anywhere inside the attribute values. For example, the following CSS matches any <code>&lt;span&gt;</code> element whose <code>class</code> attribute contains the substring <code>cloud</code>, so both “cloudy” planets are matched, as shown in <a data-type="xref" href="#selecting_elements_based_on_substrings_w">Figure 2-11</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">span</code><code class="o">[</code><code class="nt">class</code><code class="o">*=</code><code class="s2">"cloud"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"barren rocky"</code><code class="nt">&gt;</code>Mercury<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"cloudy barren"</code><code class="nt">&gt;</code>Venus<code class="nt">&lt;/span&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;span</code><code class="w"> </code><code class="na">class=</code><code class="s">"life-bearing cloudy"</code><code class="nt">&gt;</code>Earth<code class="nt">&lt;/span&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_elements_based_on_substrings_w">&#13;
<img alt="css5 0211" src="assets/css5_0211.png"/>&#13;
<h6><span class="label">Figure 2-11. </span>Selecting elements based on substrings within attribute values</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note the presence of the asterisk (<code>*</code>) in the selector.  It’s the key to selecting elements based on the presence of a substring within an attribute’s value. To be clear, it is <em>not</em> related to the universal selector, other than it uses the same character.</p>&#13;
&#13;
<p>As you can imagine, this particular capability has many useful applications. For example, suppose you want to specially style any links to the W3C’s website. Instead of classing them all and writing styles based on that class, you could instead write the following rule:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">*=</code><code class="s2">"w3.org"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<p>You aren’t confined to the <code>class</code> and <code>href</code> attributes. Any attribute is up for grabs here (<code>title</code>, <code>alt</code>, <code>src</code>, <code>id</code>…); if the attribute has a value, you can style based on a substring within that value. The following rule draws attention to any image with the string <code>space</code> in its source URL:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="o">[</code><code class="nt">src</code><code class="o">*=</code><code class="s2">"space"</code><code class="o">]</code> <code class="p">{</code><code class="k">outline</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-primary="&lt;input&gt; element" data-primary-sortas="input element" data-type="indexterm" id="idm45176126444064"/>Similarly, the following rule draws attention to <code>&lt;input&gt;</code> elements that have a title telling the user what to do, along with any other input whose title contains the substring <code>format</code> in its title:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="o">[</code><code class="nt">title</code><code class="o">*=</code><code class="s2">"format"</code><code class="o">]</code> <code class="p">{</code><code class="k">background-color</code><code class="o">:</code> <code class="m">#dedede</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">type=</code><code class="s">"tel"</code><code class="w"/>&#13;
<code class="w">    </code><code class="na">title=</code><code class="s">"Telephone number should be formatted as XXX-XXX-XXXX"</code><code class="w"/>&#13;
<code class="w">    </code><code class="na">pattern=</code><code class="s">"\d{3}\-\d{3}\-\d{4}"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>A common use for the general substring attribute selector is to match a section of a class in pattern library class names. Elaborating on the preceding example, we can target any class name that starts with <code>btn</code> followed by a hyphen, and that contains the substring <code>arrow</code> preceded by a hyphen, by using the pipe-equals attribute selector:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*[</code><code class="nt">class</code><code class="o">|=</code><code class="s2">"btn"</code><code class="o">][</code><code class="nt">class</code><code class="o">*=</code><code class="s2">"-arrow"</code><code class="o">]</code><code class="nd">:after</code> <code class="p">{</code> <code class="k">content</code><code class="o">:</code> <code class="s2">"▼"</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;button</code><code class="w"> </code><code class="na">class=</code><code class="s">"btn-small-arrow-active"</code><code class="nt">&gt;</code>Click<code class="w"> </code>Me<code class="nt">&lt;/button&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The <a data-primary="case sensitivity" data-secondary="attribute selectors" data-type="indexterm" id="idm45176126318624"/>matches are exact: if you include whitespace in your selector, whitespace must also be present in an attribute’s value. The attribute values are case-sensitive when the underlying document language requires case sensitivity. Class names, titles, URLs, and ID values are all case-sensitive, but enumerated HTML attribute values, such as input type keyword values, are not:<a data-primary="" data-startref="ix_asterisk_attrib" data-type="indexterm" id="idm45176126317648"/><a data-primary="" data-startref="ix_asterisk_attrib2" data-type="indexterm" id="idm45176126316704"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code><code class="o">[</code><code class="nt">type</code><code class="o">=</code><code class="s2">"CHeckBoX"</code><code class="o">]</code> <code class="p">{</code><code class="k">margin-right</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;input</code><code class="w"> </code><code class="na">type=</code><code class="s">"checkbox"</code><code class="w"> </code><code class="na">name=</code><code class="s">"rightmargin"</code><code class="w"> </code><code class="na">value=</code><code class="s">"10px"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Matching a substring at the beginning of an attribute value" data-type="sect3"><div class="sect3" id="matching_a_substring_at_the_beginning_of">&#13;
<h3>Matching a substring at the beginning of an attribute value</h3>&#13;
&#13;
<p>If you <a data-primary="^= (caret, equal sign), in attribute selectors" data-type="indexterm" id="idm45176126251008"/><a data-primary="caret, equal sign (^=), in attribute selectors" data-type="indexterm" id="idm45176126250336"/>want to select elements based on a substring at the beginning of an attribute value, the caret-equals attribute selector pattern <code>[att^="val"]</code> is what you’re seeking. This can be particularly useful when you want to style types of links differently, as illustrated in <a data-type="xref" href="#selecting_elements_based_on_substrings_t">Figure 2-12</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">^=</code><code class="s2">"https:"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="o">^=</code><code class="s2">"mailto:"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_elements_based_on_substrings_t">&#13;
<img alt="css5 0212" src="assets/css5_0212.png"/>&#13;
<h6><span class="label">Figure 2-12. </span>Selecting elements based on substrings that begin attribute values</h6>&#13;
</div></figure>&#13;
&#13;
<p>In another use case, you may want to style all images in an article that are also figures, like the figures you see throughout this text. Assuming that the <code>alt</code> text of each figure begins with text in the pattern “Figure 5”—which is an entirely reasonable assumption in this case—you can select only those images with the caret-equals attribute selector:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="o">[</code><code class="nt">alt</code><code class="o">^=</code><code class="s2">"Figure"</code><code class="o">]</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">2px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code>  <code class="k">display</code><code class="o">:</code> <code class="nb">block</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">2em</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The potential drawback here is that <em>any</em> <code>&lt;img&gt;</code> element whose <code>alt</code> starts with <code>Figure</code> will be selected, whether or not it’s meant to be an illustrative figure. The likeliness of that occurring depends on the document in question.</p>&#13;
&#13;
<p>Another use case is selecting all of the calendar events that occur on Mondays. In this case, let’s assume all of the events have a <code>title</code> attribute containing a date in the format “Monday, March 5th, 2012.” Selecting them all is just a simple matter of using &#13;
<span class="keep-together"><code>[title^="Monday"]</code>.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Matching a substring at the end of an attribute value" data-type="sect3"><div class="sect3" id="matching_a_substring_at_the_end_of_an_at">&#13;
<h3>Matching a substring at the end of an attribute value</h3>&#13;
&#13;
<p>The <a data-primary="$= (dollar sign, equal sign), in attribute selectors" data-type="indexterm" id="idm45176126133296"/><a data-primary="dollar sign, equal sign ($=), in attribute selectors" data-type="indexterm" id="idm45176126132592"/>mirror image of beginning-substring matching is ending-substring matching, which is accomplished using the <code>[att$="val"]</code> pattern. A very common use for this capability is to style links based on the kind of resource they target, such as separate styles for PDF documents, as illustrated in <a data-type="xref" href="#selecting_elements_based_on_substring">Figure 2-13</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="o">[</code><code class="nt">href</code><code class="err">$</code><code class="o">=</code><code class="s2">".pdf"</code><code class="o">]</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_elements_based_on_substring">&#13;
<img alt="css5 0213" src="assets/css5_0213.png"/>&#13;
<h6><span class="label">Figure 2-13. </span>Selecting elements based on substrings that end attribute values</h6>&#13;
</div></figure>&#13;
&#13;
<p>Similarly, you could (for whatever reason) select images based on their image format with the dollar-equals attribute selector:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="o">[</code><code class="nt">src</code><code class="err">$</code><code class="o">=</code><code class="s2">".gif"</code><code class="o">]</code> <code class="p">{</code><code class="o">...</code><code class="p">}</code>&#13;
<code class="nt">img</code><code class="o">[</code><code class="nt">src</code><code class="err">$</code><code class="o">=</code><code class="s2">".jpg"</code><code class="o">]</code> <code class="p">{</code><code class="o">...</code><code class="p">}</code>&#13;
<code class="nt">img</code><code class="o">[</code><code class="nt">src</code><code class="err">$</code><code class="o">=</code><code class="s2">".png"</code><code class="o">]</code> <code class="p">{</code><code class="o">...</code><code class="p">}</code></pre>&#13;
&#13;
<p>To continue the calendar example from the previous section, it would be possible to select all of the events occurring within a given year by using a selector like <code>[title$="2015"]</code>.<a data-primary="" data-startref="ix_attrib_partial" data-type="indexterm" id="idm45176126043712"/><a data-primary="" data-startref="ix_substring_attrib" data-type="indexterm" id="idm45176126042832"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You may have noticed that we’ve quoted all the attribute values in the attribute selectors. <a data-primary="'…​' or &quot;…​&quot; (quotes)" data-secondary="enclosing attribute values" data-type="indexterm" id="idm45176126040800"/><a data-primary="quotes ('…​' or &quot;…​&quot;)" data-secondary="enclosing attribute values" data-type="indexterm" id="idm45176126039888"/>Quoting is required if the value includes any special characters, begins with a hyphen or digit, or is otherwise invalid as an identifier and needs to be quoted as a string. To be safe, we recommend always quoting attribute values in attribute selectors, even though it is required only to make strings out of invalid identifiers.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Case-Insensitivity Identifier" data-type="sect2"><div class="sect2" id="the_case_insensitivity_identifier">&#13;
<h2>The Case-Insensitivity Identifier</h2>&#13;
&#13;
<p>Including an <code>i</code> before the <a data-primary="attribute selectors" data-secondary="case-insensitivity identifier for" data-type="indexterm" id="idm45176126007088"/><a data-primary="case sensitivity" data-secondary="attribute selectors" data-type="indexterm" id="idm45176126006112"/><a data-primary="&quot;i&quot;, in attribute selectors" data-type="indexterm" id="idm45176126005168"/>closing bracket of an attribute selector will allow that selector to match attribute values case-insensitively, regardless of document language rules. For example, suppose you want to select all links to PDF documents, but you don’t know if they’ll end in <em>.pdf</em>, <em>.PDF</em>, or even <em>.Pdf</em>.  Here’s how:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">a</code><code class="p">[</code><code class="n">href</code><code class="err">$</code><code class="o">=</code><code class="s1">'.PDF'</code> <code class="n">i</code><code class="p">]</code></pre>&#13;
&#13;
<p>Adding that humble little <code>i</code> means the selector will match any <code>a</code> element whose <code>href</code> attribute’s value ends in <code>.pdf</code>, regardless of the capitalization of the letters <em>P</em>, <em>D</em>, and <em>F</em>.</p>&#13;
&#13;
<p>This case-insensitivity option is available for all the attribute selectors we’ve covered.  Note, however, that this applies to only the <em>values</em> in the attribute selectors.  It does not enforce case insensitivity on the attribute names themselves.  Thus, in a case-sensitive language, <code>planet[type*="rock" i]</code> will match all of the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;planet</code><code class="w"> </code><code class="na">type=</code><code class="s">"barren rocky"</code><code class="nt">&gt;</code>Mercury<code class="nt">&lt;/planet&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;planet</code><code class="w"> </code><code class="na">type=</code><code class="s">"cloudy ROCKY"</code><code class="nt">&gt;</code>Venus<code class="nt">&lt;/planet&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;planet</code><code class="w"> </code><code class="na">type=</code><code class="s">"life-bearing Rock"</code><code class="nt">&gt;</code>Earth<code class="nt">&lt;/planet&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>It will <em>not</em> match the following element, because the attribute <code>TYPE</code> isn’t matched by <code>type</code> in XML:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;planet</code><code class="w"> </code><code class="na">TYPE=</code><code class="s">"dusty rock"</code><code class="nt">&gt;</code>Mars<code class="nt">&lt;/planet&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This is in languages that enforce case sensitivity in the element and attribute syntax. In languages that are case-insensitive, like HTML, this isn’t an issue.<a data-primary="" data-startref="ix_attrib_select" data-type="indexterm" id="idm45176125901168"/><a data-primary="" data-startref="ix_selector_attrib" data-type="indexterm" id="idm45176125900320"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A proposed mirror identifier, <code>s</code>, enforces case sensitivity.  As of early 2023, it is supported by only the Firefox family of browsers.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Document Structure" data-type="sect1"><div class="sect1" id="using_document_structure">&#13;
<h1>Using Document Structure</h1>&#13;
&#13;
<p>CSS is so <a data-primary="selectors" data-secondary="document structure and" data-type="indexterm" id="ix_selctor_doc_struct_ch2"/><a data-primary="document structure" data-secondary="selectors based on" data-type="indexterm" id="ix_doc_struct_ch2"/>capable because it uses the structure of documents to determine appropriate styles and how to apply them. Let’s take a moment to discuss structure before moving on to more powerful forms of selection.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding the Parent-Child Relationship" data-type="sect2"><div class="sect2" id="understanding_the_parent-child_relations">&#13;
<h2>Understanding the Parent-Child Relationship</h2>&#13;
&#13;
<p>To <a data-primary="parent-child relationship, document structure" data-type="indexterm" id="idm45176125933824"/>understand the relationship between selectors and documents, we need to once again examine how documents are structured. Consider this very simple HTML document:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;html</code><code class="w"> </code><code class="na">lang=</code><code class="s">"en-us"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;head&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;meta</code><code class="w"> </code><code class="na">charset=</code><code class="s">"utf-8"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;meta</code><code class="w"> </code><code class="na">name=</code><code class="s">"viewport"</code><code class="w"> </code><code class="na">content=</code><code class="s">"width=device-width"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;title&gt;</code>Meerkat<code class="w"> </code>Central<code class="nt">&lt;/title&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/head&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;body&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;h1&gt;</code>Meerkat<code class="w"> </code><code class="nt">&lt;em&gt;</code>Central<code class="nt">&lt;/em&gt;&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w"> </code>Welcome<code class="w"> </code>to<code class="w"> </code>Meerkat<code class="w"> </code><code class="nt">&lt;em&gt;</code>Central<code class="nt">&lt;/em&gt;</code>,<code class="w"> </code>the<code class="w"> </code><code class="nt">&lt;strong&gt;</code>best<code class="w"> </code>meerkat<code class="w"> </code>web<code class="w"> </code>site<code class="w"/>&#13;
<code class="w"> </code>on<code class="w"> </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"inet.html"</code><code class="nt">&gt;</code>the<code class="w"> </code><code class="nt">&lt;em&gt;</code>entire<code class="nt">&lt;/em&gt;</code><code class="w"> </code>Internet<code class="nt">&lt;/a&gt;&lt;/strong&gt;</code>!<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;li&gt;</code>We<code class="w"> </code>offer:<code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;&lt;strong&gt;</code>Detailed<code class="w"> </code>information<code class="nt">&lt;/strong&gt;</code><code class="w"> </code>on<code class="w"> </code>how<code class="w"> </code>to<code class="w"> </code>adopt<code class="w"> </code>a<code class="w"> </code>meerkat<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Tips<code class="w"> </code>for<code class="w"> </code>living<code class="w"> </code>with<code class="w"> </code>a<code class="w"> </code>meerkat<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;&lt;em&gt;</code>Fun<code class="nt">&lt;/em&gt;</code><code class="w"> </code>things<code class="w"> </code>to<code class="w"> </code>do<code class="w"> </code>with<code class="w"> </code>a<code class="w"> </code>meerkat,<code class="w"> </code>including:<code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;li&gt;</code>Playing<code class="w"> </code>fetch<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;li&gt;</code>Digging<code class="w"> </code>for<code class="w"> </code>food<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;li&gt;</code>Hide<code class="w"> </code>and<code class="w"> </code>seek<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">     </code><code class="nt">&lt;/ol&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;li&gt;</code>...and<code class="w"> </code>so<code class="w"> </code>much<code class="w"> </code>more!<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w"> </code>Questions?<code class="w"> </code><code class="nt">&lt;a</code><code class="w"> </code><code class="na">href=</code><code class="s">"mailto:suricate@meerkat.web"</code><code class="nt">&gt;</code>Contact<code class="w"> </code>us!<code class="nt">&lt;/a&gt;</code><code class="w"/>&#13;
<code class="w"> </code><code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/body&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/html&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Much of the <a data-primary="sibling elements, document structure" data-type="indexterm" id="idm45176125929920"/>power of CSS is based on the <em>parent-child relationship</em> of elements. HTML documents (and most structured documents of any kind) are based on a hierarchy of elements, which is visible in the “tree” view of the document (see <a data-type="xref" href="#a_document_tree_structure">Figure 2-14</a>). In this hierarchy, each element fits somewhere into the overall structure of the document. Every element in the document is either the <em>parent</em> or the <em>child</em> of another element, and it’s often both.  If a parent has more than one child, those children are <em>siblings</em>.</p>&#13;
&#13;
<figure><div class="figure" id="a_document_tree_structure">&#13;
<img alt="css5 0214" src="assets/css5_0214.png"/>&#13;
<h6><span class="label">Figure 2-14. </span>A document tree structure</h6>&#13;
</div></figure>&#13;
&#13;
<p>An element is said to be the parent of another element if it appears directly above that element in the document hierarchy. For example, in <a data-type="xref" href="#a_document_tree_structure">Figure 2-14</a>, the first <code>&lt;p&gt;</code> element from the left is parent to the <code>&lt;em&gt;</code> and <code>&lt;strong&gt;</code> elements, while <code>&lt;strong&gt;</code> is parent to an anchor (<code>&lt;a&gt;</code>) element, which is itself parent to another <code>&lt;em&gt;</code> element. Conversely, an element is the child of another element if it is directly beneath the other element. Thus, the anchor element on the far right side of <a data-type="xref" href="#a_document_tree_structure">Figure 2-14</a> is the child of a <code>&lt;p&gt;</code> element, which is in turn child to the <code>&lt;body&gt;</code> element, and so on.</p>&#13;
&#13;
<p>The <a data-primary="ancestor-descendant relationship, document structure" data-type="indexterm" id="idm45176122966128"/>terms <em>parent</em> and <em>child</em> are specific applications of the terms <em>ancestor</em> and <em>descendant</em>, respectively. There is a difference between them: in the tree view, if an element is exactly one level above or below another, those elements have a <em>parent-child</em> relationship. If the path from one element to another is traced through two or more levels, the elements have an ancestor-descendant relationship, but not a parent-child relationship. (A child is also a descendant, and a parent is also an ancestor.) In <a data-type="xref" href="#a_document_tree_structure">Figure 2-14</a>, the uppermost <code>&lt;ul&gt;</code> element is parent to two <code>&lt;li&gt;</code> elements, but the uppermost <code>&lt;ul&gt;</code> is also the ancestor of every element descended from its <code>&lt;li&gt;</code> element, all the way down to the most deeply nested <code>&lt;li&gt;</code> elements.  Those <code>&lt;li&gt;</code> elements, children of the <code>&lt;ol&gt;</code>, are siblings.</p>&#13;
&#13;
<p>Also, in <a data-type="xref" href="#a_document_tree_structure">Figure 2-14</a>, there is an <a data-primary="elements" data-secondary="root" data-type="indexterm" id="idm45176122957664"/><a data-primary="root elements" data-type="indexterm" id="idm45176122956656"/>anchor that is a child of <code>&lt;strong&gt;</code>, but also a descendant of the <code>&lt;p&gt;</code>, <code>&lt;body&gt;</code>, and <code>&lt;html&gt;</code> elements. The <code>&lt;body&gt;</code> element is an ancestor of everything that the browser will display by default, and the <code>&lt;html&gt;</code> element is ancestor to the entire document. For this reason, in an HTML document, the <code>&lt;html&gt;</code> element is also called the <em>root element</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Descendant Selectors" data-type="sect2"><div class="sect2" id="descendant_selectors">&#13;
<h2>Defining Descendant Selectors</h2>&#13;
&#13;
<p>The first <a data-primary="descendant (contextual) selectors" data-type="indexterm" id="ix_descend_selector"/><a data-primary="selectors" data-secondary="descendant (contextual)" data-type="indexterm" id="ix_selector_desc"/>benefit of understanding this model is the ability to define <em>descendant selectors</em>. Defining descendant selectors is the act of creating rules that operate in certain structural circumstances but not others. As an example, let’s say you want to style only those <code>&lt;em&gt;</code> elements that are descended from <code>&lt;h1&gt;</code> elements.  To do so, write the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This rule will make gray any text in an <code>&lt;em&gt;</code> element that is the descendant of an <code>&lt;h1&gt;</code> element. Other <code>&lt;em&gt;</code> text, such as that found in a paragraph or a block quote, will not be selected by this rule. <a data-type="xref" href="#selecting_an_element_based_on_its_contex">Figure 2-15</a> illustrates the result.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_an_element_based_on_its_contex">&#13;
<img alt="css5 0215" src="assets/css5_0215.png"/>&#13;
<h6><span class="label">Figure 2-15. </span>Selecting an element based on its context</h6>&#13;
</div></figure>&#13;
&#13;
<p>In a <a data-primary="combinators" data-secondary="descendant selectors" data-type="indexterm" id="idm45176122906176"/>descendant selector, the selector side of a rule is composed of two or more space-separated selectors. The space between the selectors is an example of a <em>combinator</em>. Each space combinator can be translated as “found within,” “which is part of,” or “that is a descendant of,” but only if you read the selector right to left. Thus, <code>h1 em</code> can be translated as, “Any <code>&lt;em&gt;</code> element that is a descendant of an <code>&lt;h1&gt;</code> element.”</p>&#13;
&#13;
<p>To read the selector left to right, you might phrase it like, “Any <code>&lt;h1&gt;</code> that contains an <code>&lt;em&gt;</code> will have the following styles applied to the <code>&lt;em&gt;</code>.” That’s much more verbose and confusing, and it’s why we, like the browser, read selectors from right to left.</p>&#13;
&#13;
<p>You aren’t limited to two selectors. For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="nt">ol</code> <code class="nt">ul</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In this case, as <a data-type="xref" href="#a_very_specific_descendant_selector">Figure 2-16</a> shows, any emphasized text that is part of an unordered list that is part of an ordered list that is itself part of an unordered list (yes, this is correct) will be gray. This is obviously a very specific selection criterion.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="a_very_specific_descendant_selector">&#13;
<img alt="css5 0216" src="assets/css5_0216.png"/>&#13;
<h6><span class="label">Figure 2-16. </span>A very specific descendant selector</h6>&#13;
</div></figure>&#13;
&#13;
<p>Descendant selectors can be extremely powerful. Let’s consider a common example. Assume you have a document with a sidebar and a main area. The sidebar has a blue background, the main area has a white background, and both areas include lists of links. You can’t set all links to be blue because they’d be impossible to read in the sidebar, and you also can’t set all links to white because they’d disappear in the main part of the page.</p>&#13;
&#13;
<p>The solution: descendant selectors. In this case, you give the element that contains your sidebar a class of <code>sidebar</code> and enclose the main part of the page in a <code>&lt;main&gt;</code> element. Then, you write styles like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.sidebar</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">main</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nc">.sidebar</code> <code class="nt">a</code><code class="nd">:any-link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code>&#13;
<code class="nt">main</code> <code class="nt">a</code><code class="nd">:any-link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#using_descendant_selectors_to_apply_diff">Figure 2-17</a> shows the result.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="using_descendant_selectors_to_apply_diff">&#13;
<img alt="css5 0217" src="assets/css5_0217.png"/>&#13;
<h6><span class="label">Figure 2-17. </span>Using descendant selectors to apply different styles to the same type &#13;
<span class="keep-together">of element</span></h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>:any-link</code> refers to both visited and unvisited links. We’ll talk about it in detail in <a data-type="xref" href="ch03.html#pseudo_classes_and_elements">Chapter 3</a>.</p>&#13;
</div>&#13;
&#13;
<p>Here’s another example: let’s say that you want gray to be the text color of any <code>&lt;b&gt;</code> (boldfaced) element that is part of a <code>blockquote</code> and for any bold text that is found in a normal paragraph:</p>&#13;
&#13;
<pre data-type="programlisting">blockquote b, p b {color: gray;}</pre>&#13;
&#13;
<p>The result is that the text within <code>&lt;b&gt;</code> elements that are descended from paragraphs or block quotes will be gray.</p>&#13;
&#13;
<p>One overlooked aspect of descendant selectors is that the degree of separation between two elements can be practically infinite. For example, if you write <code>ul em</code>, that syntax will select any <code>&lt;em&gt;</code> element descended from a <code>&lt;ul&gt;</code> element, no matter how deeply nested the <code>&lt;em&gt;</code> may be. Thus, <code>ul em</code> would select the <code>&lt;em&gt;</code> element in the following markup:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1-1<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1-2<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1-3<code class="w"/>&#13;
<code class="w">        </code><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1-3-1<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code><code class="nt">&lt;em&gt;</code>1-3-2<code class="nt">&lt;/em&gt;&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1-3-3<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">&lt;/ol&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1-4<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/ol&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ul&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>A more subtle aspect of descendant selectors is that they have no notion of element proximity. In other words, the closeness of two elements within the document tree has no bearing on whether a rule applies. This is important when it comes to specificity (which we’ll cover in the next chapter) and when considering rules that might appear to cancel each other out.</p>&#13;
&#13;
<p>For example, consider the following (which contains <code>:not()</code>, a selector type we’ll discuss in <a data-type="xref" href="ch03.html#the_negation_pseudo-class">“The negation pseudo-class”</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nd">:not</code><code class="o">(</code><code class="nc">.help</code><code class="o">)</code> <code class="nt">span</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.help</code> <code class="nt">span</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"help"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"aside"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">      </code>This<code class="w"> </code>text<code class="w"> </code>contains<code class="w"> </code><code class="nt">&lt;span&gt;</code>a<code class="w"> </code>span<code class="w"> </code>element<code class="nt">&lt;/span&gt;</code><code class="w"> </code>within.<code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>What the CSS says, in effect, is “any <code>&lt;span&gt;</code> inside a <code>&lt;div&gt;</code> that doesn’t have a <code>class</code> containing the word <code>help</code> should be gray” in the first rule, and “any <code>&lt;span&gt;</code> inside a <code>&lt;div&gt;</code> whose <code>class</code> contains the word <code>help</code>” in the second rule. In the given markup fragment, <em>both</em> rules apply to the <code>&lt;span&gt;</code> shown.</p>&#13;
&#13;
<p>Because the two rules have equal specificity weight and the <code>red</code> rule is written last, it wins out, and the <code>&lt;span&gt;</code> is red. The fact that <code>div class="aside"</code> is “closer to” <code>&lt;span&gt;</code> than <code>div class="help"</code> is irrelevant. Again: descendant selectors have no notion of element proximity. Both rules match, only one color can be applied, and because of the way CSS works, red is the winner here.  (We’ll discuss why that’s so in the next chapter.)<a data-primary="" data-startref="ix_selector_desc" data-type="indexterm" id="idm45176122584576"/><a data-primary="" data-startref="ix_descend_selector" data-type="indexterm" id="idm45176122583600"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of early 2023, proposals have been made to add element-proximity awareness to CSS via <em>selector scoping</em>, but the proposals are still being actively revised and may not come to fruition.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting Children" data-type="sect2"><div class="sect2" id="selecting_children">&#13;
<h2>Selecting Children</h2>&#13;
&#13;
<p>In some <a data-primary="selectors" data-secondary="child combinator for" data-type="indexterm" id="idm45176122579296"/><a data-primary="child combinator" data-type="indexterm" id="idm45176122578288"/><a data-primary="combinators" data-secondary="child" data-type="indexterm" id="idm45176122577616"/>cases, you don’t want to select an arbitrarily descended element. Rather, you want to narrow your range to select an element that is specifically a child of another element. You might, for example, want to select a <code>&lt;strong&gt;</code> element only if it is a child (as opposed to any other level of descendant) of an <code>&lt;h1&gt;</code> element. <a data-primary="greater-than sign (&gt;)" data-type="indexterm" id="idm45176122553920"/><a data-primary="&gt; (greater-than sign)" data-type="indexterm" id="idm45176122553184"/>To do this, you use the <em>child combinator</em>, which is the greater-than symbol (<code>&gt;</code>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="o">&gt;</code> <code class="nt">strong</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This rule will make red the <code>&lt;strong&gt;</code> element shown in the first <code>&lt;h1&gt;</code>, but not the second:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1&gt;</code>This<code class="w"> </code>is<code class="w"> </code><code class="nt">&lt;strong&gt;</code>very<code class="nt">&lt;/strong&gt;</code><code class="w"> </code>important.<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h1&gt;</code>This<code class="w"> </code>is<code class="w"> </code><code class="nt">&lt;em&gt;</code>really<code class="w"> </code><code class="nt">&lt;strong&gt;</code>very<code class="nt">&lt;/strong&gt;&lt;/em&gt;</code><code class="w"> </code>important.<code class="nt">&lt;/h1&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Read right to left, the selector <code>h1 &gt; strong</code> translates as, “Selects any <code>&lt;strong&gt;</code> element that is a direct child of an <code>&lt;h1&gt;</code> element.” The child combinator can be optionally surrounded by whitespace. Thus, <code>h1 &gt; strong</code>, <code>h1&gt; strong</code>, and <code>h1&gt;strong</code> are all equivalent. You can use or omit whitespace as you wish.</p>&#13;
&#13;
<p>When viewing the document as a tree structure, we can see that a child selector restricts its matches to elements that are directly connected in the tree. <a data-type="xref" href="#a_document_tree_fragment">Figure 2-18</a> shows part of a document tree.</p>&#13;
&#13;
<figure class="width_set_70"><div class="figure" id="a_document_tree_fragment">&#13;
<img alt="css5 0218" src="assets/css5_0218.png"/>&#13;
<h6><span class="label">Figure 2-18. </span>A document tree fragment</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this tree fragment, you can pick out parent-child relationships. For example, the <code>&lt;a&gt;</code> element is a parent to <code>&lt;strong&gt;</code> and is also a child of the <code>&lt;p&gt;</code> element. You could match elements in this fragment with the selectors <code>p &gt; a</code> and <code>a &gt; strong</code>, but not <code>p &gt; strong</code>, since <code>&lt;strong&gt;</code> is a descendant of <code>&lt;p&gt;</code> but not its child.</p>&#13;
&#13;
<p>You can also combine descendant and child combinators in the same selector. Thus, <code>table.summary td &gt; p</code> will select any <code>&lt;p&gt;</code> element that is a <em>child</em> of a <code>&lt;td&gt;</code> element that is itself <em>descended</em> from a <code>&lt;table&gt;</code> element that has a <code>class</code> attribute containing the word <code>summary</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting Adjacent-Sibling Elements" data-type="sect2"><div class="sect2" id="selecting_adjacent_sibling_elements">&#13;
<h2>Selecting Adjacent-Sibling Elements</h2>&#13;
&#13;
<p>Let’s say you <a data-primary="sibling elements, document structure" data-type="indexterm" id="ix_sib_elem_doc_struct"/><a data-primary="selectors" data-secondary="adjacent-sibling combinator" data-type="indexterm" id="ix_selector_adj_sib"/><a data-primary="plus sign (+)" data-secondary="adjacent-sibling combinator" data-type="indexterm" id="ix_plus_sibling2"/><a data-primary="combinators" data-secondary="adjacent-sibling" data-type="indexterm" id="ix_comb_adj_sib"/><a data-primary="adjacent-sibling combinator (+)" data-type="indexterm" id="ix_adj_sib_comb"/><a data-primary="+ (plus sign)" data-secondary="adjacent-sibling combinator" data-type="indexterm" id="ix_plus_sibling"/>want to style the paragraph immediately after a heading, or give a special margin to a list that immediately follows a paragraph. To select an element that immediately follows another element with the same parent, you use the <em>adjacent-sibling combinator</em>, represented as a plus symbol (+). As with the child combinator, the symbol can be surrounded by whitespace, or not, at your discretion.</p>&#13;
&#13;
<p>To remove the top margin from a paragraph immediately following an <code>&lt;h1&gt;</code> element, write this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="o">+</code> <code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The selector is read as, “Select any <code>&lt;p&gt;</code> element that immediately follows an <code>&lt;h1&gt;</code> element that <em>shares a parent</em> with the <code>&lt;p&gt;</code> element.”</p>&#13;
&#13;
<p>To visualize how this selector works, let’s once again consider a fragment of a document tree, shown in <a data-type="xref" href="#another_document_tree_fragment">Figure 2-19</a>.</p>&#13;
&#13;
<figure class="width_set_70"><div class="figure" id="another_document_tree_fragment">&#13;
<img alt="css5 0219" src="assets/css5_0219.png"/>&#13;
<h6><span class="label">Figure 2-19. </span>Another document tree fragment</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this fragment, a pair of lists descends from a <code>&lt;div&gt;</code> element, one ordered and the other not, each containing three list items. Each list is an adjacent sibling, and the list items themselves are also adjacent siblings. However, the list items from the first list are <em>not</em> siblings of the second, as the two sets of list items do not share the same parent element. (At best, they’re cousins, and CSS has no cousin selector.)</p>&#13;
&#13;
<p>Remember that you can select the second of two adjacent siblings only with a single combinator. Thus, if you write <code>li + li {font-weight: bold;}</code>, only the second and third items in each list will be boldfaced. The first list items will be unaffected, as illustrated in <a data-type="xref" href="#selecting_adjacent_siblings">Figure 2-20</a>.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_adjacent_siblings">&#13;
<img alt="css5 0220" src="assets/css5_0220.png"/>&#13;
<h6><span class="label">Figure 2-20. </span>Selecting adjacent siblings</h6>&#13;
</div></figure>&#13;
&#13;
<p>To work properly, CSS requires that the two elements appear in <em>source order</em>. In our example, an <code>&lt;ol&gt;</code> element is followed by a <code>&lt;ul&gt;</code> element. This allows us to select the second element with <code>ol + ul</code>, but we cannot select the first by using the same syntax. For <code>ul + ol</code> to match, an ordered list must immediately follow an unordered list.</p>&#13;
&#13;
<p>Keep in mind that text content between two elements does <em>not</em> prevent the adjacent-sibling combinator from working. Consider this markup fragment, whose tree view would be the same as that shown in <a data-type="xref" href="#a_document_tree_fragment">Figure 2-18</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>List<code class="w"> </code>item<code class="w"> </code>1<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ol&gt;</code><code class="w"/>&#13;
<code class="w">  </code>This<code class="w"> </code>is<code class="w"> </code>some<code class="w"> </code>text<code class="w"> </code>that<code class="w"> </code>is<code class="w"> </code>part<code class="w"> </code>of<code class="w"> </code>the<code class="w"> </code>'div'.<code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ul&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>A<code class="w"> </code>list<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Another<code class="w"> </code>list<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Yet<code class="w"> </code>another<code class="w"> </code>list<code class="w"> </code>item<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ul&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Even though we have text between the two lists, we can still match the second list with the selector <code>ol + ul</code>. That’s because the intervening text is not contained within a sibling element, but is instead part of the parent <code>&lt;div&gt;</code>. If we wrapped that text in a paragraph element, it would then prevent <code>ol + ul</code> from matching the second list. Instead, we might have to write something like <code>ol + p + ul</code>.</p>&#13;
&#13;
<p>As the <a data-primary="combinators" data-secondary="multiple types" data-type="indexterm" id="idm45176125134480"/>following example illustrates, the adjacent-sibling combinator can be used in conjunction with other combinators:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">html</code> <code class="o">&gt;</code> <code class="nt">body</code> <code class="nt">table</code> <code class="o">+</code> <code class="nt">ul</code><code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">1.5em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The selector translates as, “Selects any <code>&lt;ul&gt;</code> element that immediately follows a sibling <code>&lt;table&gt;</code> element that is descended from a <code>&lt;body&gt;</code> element that is itself a child of an <code>&lt;html&gt;</code> element.”</p>&#13;
&#13;
<p>As with all combinators, you can place the adjacent-sibling combinator in a more complex setting, such as <code>div#content h1 + div ol</code>. That selector is read as, “Selects any <code>&lt;ol&gt;</code> element that is descended from a <code>&lt;div&gt;</code> when the <code>&lt;div&gt;</code> is the adjacent sibling of an <code>&lt;h1&gt;</code> that is itself descended from a <code>&lt;div&gt;</code> whose <code>id</code> attribute has a value of <code>content</code>.”<a data-primary="" data-startref="ix_plus_sibling" data-type="indexterm" id="idm45176125054096"/><a data-primary="" data-startref="ix_adj_sib_comb" data-type="indexterm" id="idm45176125053088"/><a data-primary="" data-startref="ix_comb_adj_sib" data-type="indexterm" id="idm45176125052144"/><a data-primary="" data-startref="ix_plus_sibling2" data-type="indexterm" id="idm45176125051200"/><a data-primary="" data-startref="ix_selector_adj_sib" data-type="indexterm" id="idm45176125030496"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Selecting Following Siblings" data-type="sect2"><div class="sect2" id="selecting_following_siblings">&#13;
<h2>Selecting Following Siblings</h2>&#13;
&#13;
<p>The <em>general sibling combinator</em> lets you <a data-primary="following siblings, selecting" data-type="indexterm" id="ix_follow_sib"/><a data-primary="general sibling combinator" data-type="indexterm" id="ix_gen_sib_comb"/><a data-primary="~ (tilde), general-sibling combinator" data-type="indexterm" id="idm45176125025648"/><a data-primary="combinators" data-secondary="general-sibling combinator" data-type="indexterm" id="ix_comb_gen_sib"/><a data-primary="tilde (~), general-sibling combinator" data-type="indexterm" id="idm45176125023728"/>select any element that follows another element when both elements share the same parent, represented using the tilde (<code>~</code>) combinator.</p>&#13;
&#13;
<p>As an example, to italicize any <code>&lt;ol&gt;</code> that follows an <code>&lt;h2&gt;</code> and also shares a parent with the <code>&lt;h2&gt;</code>, you’d write <code>h2 ~ ol {font-style: italic;}</code>. The two elements do not have to be adjacent siblings, although they can be adjacent and still match this rule. The result of applying this rule to the following markup is shown in <a data-type="xref" href="#selecting_following_siblings-id1">Figure 2-21</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;h2&gt;</code>Subheadings<code class="nt">&lt;/h2&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code>It<code class="w"> </code>is<code class="w"> </code>the<code class="w"> </code>case<code class="w"> </code>that<code class="w"> </code>not<code class="w"> </code>every<code class="w"> </code>heading<code class="w"> </code>can<code class="w"> </code>be<code class="w"> </code>a<code class="w"> </code>main<code class="w"> </code>heading.<code class="w">  </code>Some<code class="w"> </code>headings<code class="w"/>&#13;
<code class="w">  </code>must<code class="w"> </code>be<code class="w"> </code>subheadings.<code class="w">  </code>Examples<code class="w"> </code>include:<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Headings<code class="w"> </code>that<code class="w"> </code>are<code class="w"> </code>less<code class="w"> </code>important<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Headings<code class="w"> </code>that<code class="w"> </code>are<code class="w"> </code>subsidiary<code class="w"> </code>to<code class="w"> </code>more<code class="w"> </code>important<code class="w"> </code>headlines<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Headings<code class="w"> </code>that<code class="w"> </code>like<code class="w"> </code>to<code class="w"> </code>be<code class="w"> </code>dominated<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ol&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;p&gt;</code>Let's<code class="w"> </code>restate<code class="w"> </code>that<code class="w"> </code>for<code class="w"> </code>the<code class="w"> </code>record:<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;ol&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Headings<code class="w"> </code>that<code class="w"> </code>are<code class="w"> </code>less<code class="w"> </code>important<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Headings<code class="w"> </code>that<code class="w"> </code>are<code class="w"> </code>subsidiary<code class="w"> </code>to<code class="w"> </code>more<code class="w"> </code>important<code class="w"> </code>headlines<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Headings<code class="w"> </code>that<code class="w"> </code>like<code class="w"> </code>to<code class="w"> </code>be<code class="w"> </code>dominated<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/ol&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>As you can see, both ordered lists are italicized. That’s because both of them are <code>&lt;ol&gt;</code> elements that follow an <code>&lt;h2&gt;</code> with which they share a parent (the <code>&lt;div&gt;</code>).<a data-primary="" data-startref="ix_sib_elem_doc_struct" data-type="indexterm" id="idm45176124872992"/><a data-primary="" data-startref="ix_comb_gen_sib" data-type="indexterm" id="idm45176124935744"/><a data-primary="" data-startref="ix_follow_sib" data-type="indexterm" id="idm45176124934800"/><a data-primary="" data-startref="ix_gen_sib_comb" data-type="indexterm" id="idm45176124933856"/><a data-primary="" data-startref="ix_selector_gen_sib_comb" data-type="indexterm" id="idm45176124932912"/></p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="selecting_following_siblings-id1">&#13;
<img alt="css5 0221" src="assets/css5_0221.png"/>&#13;
<h6><span class="label">Figure 2-21. </span>Selecting following siblings</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="sel_summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>By using selectors based on the document’s language, you can create CSS rules that apply to a large number of similar elements just as easily as you can construct rules that apply in very narrow circumstances. The ability to group together both selectors and rules keeps stylesheets compact and flexible, which incidentally leads to smaller file sizes and faster download times.<a data-primary="" data-startref="ix_doc_struct_ch2" data-type="indexterm" id="idm45176124843856"/><a data-primary="" data-startref="ix_selctor_doc_struct_ch2" data-type="indexterm" id="idm45176124842880"/></p>&#13;
&#13;
<p>Selectors are the one thing that user agents usually must get right, because the inability to correctly interpret selectors pretty much prevents a user agent from using CSS at all. On the flip side, it’s crucial for authors to correctly write selectors because errors can prevent the user agent from applying the styles as intended. An integral part of correctly understanding selectors and how they can be combined is having a strong grasp of how selectors relate to document structure and how mechanisms—such as inheritance and the cascade itself—come into play when determining how an element will be styled.<a data-primary="" data-startref="ix_selector_ch2" data-type="indexterm" id="idm45176124841584"/></p>&#13;
&#13;
<p>The selectors we covered in this chapter aren’t the end of the story, though.  They’re not even half the story.  In the next chapter, we’ll dive into the powerful and ever-expanding world of pseudo-class and pseudo-element selectors.</p>&#13;
</div></section>&#13;
</div></section></body></html>