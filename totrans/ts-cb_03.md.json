["```\n// Type inference\nlet aNumber = 2;\n// aNumber: number\n\n// Type annotation\nlet anotherNumber: number = 3;\n// anotherNumber: number\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\nconst me: Person = createPerson();\n```", "```\nfunction createPerson(): Person {\n  return { name: \"Stefan\", age: 39 };\n}\n```", "```\nfunction printPerson(person: Person) {\n  console.log(person.name, person.age);\n}\n\nprintPerson(me);\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\n// Inferred!\n// return type is { name: string, age: number }\nfunction createPerson() {\n  return { name: \"Stefan\", age: 39 };\n}\n\n// Inferred!\n// me: { name: string, age: number}\nconst me = createPerson();\n\n// Annotated! You have to check if types are compatible\nfunction printPerson(person: Person) {\n  console.log(person.name, person.age);\n}\n\n// All works\nprintPerson(me);\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype User = {\n  name: string;\n  age: number;\n  id: number;\n};\n\nfunction printPerson(person: Person) {\n  console.log(person.name, person.age);\n}\n\nconst user: User = {\n  name: \"Stefan\",\n  age: 40,\n  id: 815,\n};\n\nprintPerson(user); // works!\n```", "```\nprintPerson({\n  name: \"Stefan\",\n  age: 40,\n  id: 1000,\n  // ^- Argument of type '{ name: string; age: number; id: number; }'\n  //    is not assignable to parameter of type 'Person'.\n  //    Object literal may only specify known properties,\n  //    and 'id' does not exist in type 'Person'.(2345)\n});\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype Studying = {\n  semester: number;\n};\n\ntype Student = {\n  id: string;\n  age: number;\n  semester: number;\n};\n\nfunction createPerson() {\n  return { name: \"Stefan\", age: 39, semester: 25, id: \"XPA\" };\n}\n\nfunction printPerson(person: Person) {\n  console.log(person.name, person.age);\n}\n\nfunction studyForAnotherSemester(student: Studying) {\n  student.semester++;\n}\n\nfunction isLongTimeStudent(student: Student) {\n  return student.age - student.semester / 2 > 30 && student.semester > 20;\n}\n\nconst me = createPerson();\n\n// All work!\nprintPerson(me);\nstudyForAnotherSemester(me);\nisLongTimeStudent(me);\n```", "```\nconst name: any = \"Stefan\";\nconst person: any = { name: \"Stefan\", age: 40 };\nconst notAvailable: any = undefined;\n```", "```\nconst name: any = \"Stefan\";\n// This is ok for TypeScript, but will crash in JavaScript\nconsole.log(name.profession.experience[0].level);\n```", "```\nconst me: any = \"Stefan\";\n// Good!\nconst name: string = me;\n// Bad, but ok for the type system.\nconst age: number = me;\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\nfunction printPerson(person: Person) {\n  for (let key in person) {\n    console.log(`${key}: ${person[key]}`);\n// Element implicitly has an 'any' --^\n// type because expression of type 'string'\n// can't be used to index type 'Person'.\n// No index signature with a parameter of type 'string'\n// was found on type 'Person'.(7053)\n  }\n}\n```", "```\nfunction printPerson(person: any) {\n  for (let key in person) {\n    console.log(`${key}: ${person[key]}`);\n  }\n}\n```", "```\nfunction printPerson(person: Person) {\n  for (let key in person) {\n    console.log(`${key}: ${person[key as keyof Person]}`);\n  }\n}\n```", "```\nconst me: unknown = \"Stefan\";\nconst name: string = me;\n//    ^- Type 'unknown' is not assignable to type 'string'.(2322)\nconst age: number = me;\n//    ^- Type 'unknown' is not assignable to type 'number'.(2322)\n```", "```\nfunction doSomething(value: unknown) {\n  if (typeof value === \"string\") {\n    // value: string\n    console.log(\"It's a string\", value.toUpperCase());\n  } else if (typeof value === \"number\") {\n    // value: number\n    console.log(\"it's a number\", value * 2);\n  }\n}\n```", "```\nObject.create(2);\n// Uncaught TypeError: Object prototype may only be an Object or null: 2\n//    at Function.create (<anonymous>)\n```", "```\nlet obj: {}; // Similar to Object\nobj = 32;\nobj = \"Hello\";\nobj = true;\nobj = () => { console.log(\"Hello\") };\nobj = undefined; // Error\nobj = null; // Error\nobj = { name: \"Stefan\", age: 40 };\nobj = [];\nobj = /.*/;\n```", "```\nlet okObj: {} = {\n  toString() {\n    return false;\n  }\n}; // OK\n\nlet obj: Object = {\n  toString() {\n    return false;\n  }\n// ^-  Type 'boolean' is not assignable to type 'string'.ts(2322)\n}\n```", "```\nlet obj: object;\nobj = 32; // Error\nobj = \"Hello\"; // Error\nobj = true; // Error\nobj = () => { console.log(\"Hello\") };\nobj = undefined;  // Error\nobj = null; // Error\nobj = { name: \"Stefan\", age: 40 };\nobj = [];\nobj = /.*/;\n```", "```\nconst person = [\"Stefan\", 40]; // name and age\n```", "```\n// objects.js\n// Using objects\nconst person = {\n  name: \"Stefan\",\n  age: 40,\n};\n\nconst { name, age } = person;\n\nconsole.log(name); // Stefan\nconsole.log(age); // 40\n\nconst { anotherName = name, anotherAge = age } = person;\n\nconsole.log(anotherName); // Stefan\nconsole.log(anotherAge); // 40\n\n// arrays.js\n// Using arrays\nconst person = [\"Stefan\", 40]; // name and age\n\nconst [name, age] = person;\n\nconsole.log(name); // Stefan\nconsole.log(age); // 40\n\nconst [anotherName, anotherAge] = person;\n\nconsole.log(anotherName); // Stefan\nconsole.log(anotherAge); // 40\n```", "```\nconst person = [\"Stefan\", 40];\n// person: (string | number)[]\n```", "```\nconst [name, age] = person;\n// name: string | number\n// age: string | number\n```", "```\nconst person: [string, number] = [\"Stefan\", 40];\n\nconst [name, age] = person;\n// name: string\n// age: number\n```", "```\nperson[1] = 41; // OK!\nperson[2] = false; // Error\n//^- Type 'false' is not assignable to type 'undefined'.(2322)\n```", "```\ntype Person = [name: string, age: number];\n```", "```\nfunction hello(name: string, msg: string): void {\n  // ...\n}\n```", "```\nfunction hello(...args: [name: string, msg: string]): {\n  // ...\n}\n```", "```\nfunction h(a: string, b: string, c: string): void {\n  //...\n}\n// equal to\nfunction h(a: string, b: string, ...r: [string]): void {\n  //...\n}\n// equal to\nfunction h(a: string, ...r: [string, string]): void {\n  //...\n}\n// equal to\nfunction h(...r: [string, string, string]): void {\n  //...\n}\n```", "```\nconst person: [string, number] = [\"Stefan\", 40];\n\nfunction hello(...args: [name: string, msg: string]): {\n // ...\n}\n\nhello(...person);\n```", "```\ntype PersonAsType = {\n  name: string;\n  age: number;\n  address: string[];\n  greet(): string;\n};\n\ninterface PersonAsInterface {\n  name: string;\n  age: number;\n  address: string[];\n  greet(): string;\n}\n```", "```\ninterface Person {\n  name: string;\n}\n\ninterface Person {\n  age: number;\n}\n\n// Person is now { name: string; age: number; }\n```", "```\n// Some data we collect in a web form\ninterface FormData {\n  name: string;\n  age: number;\n  address: string[];\n}\n\n// A function that sends this data to a backend\nfunction send(data: FormData) {\n  console.log(data.entries()) // this compiles!\n  // but crashes horrendously in runtime\n}\n```", "```\ntype FormData = {\n//   ^-- Duplicate identifier 'FormData'.(2300)\n  name: string;\n  age: number;\n  address: string[];\n};\n```", "```\ntask(\"default\", [\"scripts\", \"styles\"]);\n\ntask(\"scripts\", [\"lint\"], () => {\n    // ...\n});\n\ntask(\"styles\", () => {\n    // ...\n});\n```", "```\ntype CallbackFn = () => void;\n\nfunction task(\n  name: string, param2: string[] | CallbackFn, param3?: CallbackFn\n): void {\n//...\n}\n```", "```\ntask(\n  \"what\",\n  () => {\n    console.log(\"Two callbacks?\");\n  },\n  () => {\n    console.log(\"That's not supported, but the types say yes!\");\n  }\n);\n```", "```\n// Types for the type system\nfunction task(name: string, dependencies: string[]): void;\nfunction task(name: string, callback: CallbackFn): void\nfunction task(name: string, dependencies: string[], callback: CallbackFn): void\n// The actual implementation\nfunction task(\n  name: string, param2: string[] | CallbackFn, param3?: CallbackFn\n): void {\n//...\n}\n```", "```\nfunction fn(input: number): number\nfunction fn(input: string): string\nfunction fn(input: number | string): number | string {\n  if(typeof input === \"number\") {\n    return \"this also works\";\n  } else {\n    return 1337;\n  }\n}\n\nconst typeSaysNumberButItsAString = fn(12);\nconst typeSaysStringButItsANumber = fn(\"Hello world\");\n```", "```\ntype TaskFn = {\n  (name: string, dependencies: string[]): void;\n  (name: string, callback: CallbackFn): void;\n  (name: string, dependencies: string[], callback: CallbackFn): void;\n}\n```", "```\nconst author = {\n  name: \"Stefan\",\n  // function shorthand\n  hi() {\n    console.log(this.name);\n  },\n};\n\nauthor.hi(); // prints 'Stefan'\n```", "```\nconst author = {\n  name: \"Stefan\",\n};\n\nfunction hi() {\n  console.log(this.name);\n}\n\nconst pet = {\n  name: \"Finni\",\n  kind: \"Cat\",\n};\n\nhi.apply(pet); // prints \"Finni\"\nhi.call(author); // prints \"Stefan\"\n\nconst boundHi = hi.bind(author);\n\nboundHi(); // prints \"Stefan\"\n```", "```\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  hi() {\n    console.log(this.name);\n  }\n\n  hi_timeout() {\n    setTimeout(function() {\n      console.log(this.name);\n    }, 0);\n  }\n\n  hi_timeout_arrow() {\n    setTimeout(() => {\n      console.log(this.name);\n    }, 0);\n  }\n}\n\nconst person = new Person(\"Stefan\")\nperson.hi(); // prints \"Stefan\"\nperson.hi_timeout(); // prints \"undefined\"\nperson.hi_timeout_arrow(); // prints \"Stefan\"\n```", "```\nconst button = document.querySelector(\"button\");\nbutton?.addEventListener(\"click\", function() {\n  this.classList.toggle(\"clicked\");\n});\n```", "```\nconst button = document.querySelector(\"button\");\nbutton.addEventListener(\"click\", handleToggle);\n\nfunction handleToggle() {\n  this.classList.toggle(\"clicked\");\n// ^- 'this' implicitly has type 'any'\n//     because it does not have a type annotation\n}\n```", "```\nconst button = document.querySelector(\"button\");\nbutton?.addEventListener(\"click\", handleToggle);\n\nfunction handleToggle(this: HTMLButtonElement) {\n  this.classList.toggle(\"clicked\");\n}\n```", "```\nhandleToggle();\n// ^- The 'this' context of type 'void' is not\n//    assignable to method's 'this' of type 'HTMLButtonElement'.\n```", "```\nconst button = document.querySelector(\"button\");\nbutton?.addEventListener(\"click\", handleToggle);\n\nconst input = document.querySelector(\"input\");\ninput?.addEventListener(\"click\", handleToggle);\n\nfunction handleToggle(this: HTMLElement) {\n  this.classList.toggle(\"clicked\");\n}\n```", "```\nfunction handleToggle(this: HTMLElement) {\n  this.classList.toggle(\"clicked\");\n}\n\ntype ToggleFn = typeof handleToggle;\n// (this: HTMLElement) => void\n\ntype WithoutThis = OmitThisParameter<ToggleFn>\n// () = > void\n\ntype ToggleFnThis = ThisParameterType<ToggleFn>\n// HTMLElement\n```", "```\nconst TITLE = Symbol('title')\n```", "```\nconst ACADEMIC_TITLE = Symbol('title')\nconst ARTICLE_TITLE = Symbol('title')\n\nif(ACADEMIC_TITLE === ARTICLE_TITLE) {\n  // This is never true\n}\n```", "```\nconsole.log(ACADEMIC_TITLE.description) // title\nconsole.log(ACADEMIC_TITLE.toString()) // Symbol(title)\n```", "```\n// A really bad logging framework\nconst LEVEL_INFO = Symbol('INFO')\nconst LEVEL_DEBUG = Symbol('DEBUG')\nconst LEVEL_WARN = Symbol('WARN')\nconst LEVEL_ERROR = Symbol('ERROR')\n\nfunction log(msg, level) {\n  switch(level) {\n    case LEVEL_WARN:\n      console.warn(msg); break\n    case LEVEL_ERROR:\n      console.error(msg); break;\n    case LEVEL_DEBUG:\n      console.log(msg);\n      debugger; break;\n    case LEVEL_INFO:\n      console.log(msg);\n  }\n}\n```", "```\nconst print = Symbol('print')\n\nconst user = {\n  name: 'Stefan',\n  age: 40,\n  [print]: function() {\n    console.log(`${this.name} is ${this.age} years old`)\n  }\n}\n\nJSON.stringify(user) // { name: 'Stefan', age: 40 }\nuser[print]() // Stefan is 40 years old\n```", "```\nSymbol.for('print') // creates a global symbol\n\nconst user = {\n  name: 'Stefan',\n  age: 37,\n  // uses the global symbol\n  [Symbol.for('print')]: function() {\n    console.log(`${this.name} is ${this.age} years old`)\n  }\n}\n```", "```\nconst usedSymbolKeys = []\n\nfunction extendObject(obj, symbol, value) {\n  //Oh, what symbol is this?\n  const key = Symbol.keyFor(symbol)\n  //Alright, let's better store this\n  if(!usedSymbolKeys.includes(key)) {\n    usedSymbolKeys.push(key)\n  }\n  obj[symbol] = value\n}\n\n// now it's time to retreive them all\nfunction printAllValues(obj) {\n  usedSymbolKeys.forEach(key => {\n    console.log(obj[Symbol.for(key)])\n  })\n}\n```", "```\nconst sym = Symbol('foo')\n\nfunction extendObject(obj: any, sym: symbol, value: any) {\n  obj[sym] = value\n}\n\nextendObject({}, sym, 42) // Works with all symbols\n```", "```\nconst PROD: unique symbol = Symbol('Production mode')\nconst DEV: unique symbol = Symbol('Development mode')\n\nfunction showWarning(msg: string, mode: typeof DEV | typeof PROD) {\n // ...\n}\n```", "```\n// Collection is in TypeScript land! --> type\ntype Collection = Person[]\n\n// printCollection is in JavaScript land! --> value\nfunction printCollection(coll: Collection) {\n  console.log(...coll.entries)\n}\n```", "```\n// a value\nconst person = {\n  name: \"Stefan\",\n};\n\n// a type\ntype Person = typeof person;\n```", "```\n// declaration\nclass Person {\n  name: string;\n\n  constructor(n: string) {\n    this.name = n;\n  }\n}\n\n// used as a value\nconst person = new Person(\"Stefan\");\n\n// used as a type\ntype Collection = Person[];\n\nfunction printPersons(coll: Collection) {\n  //...\n}\n```", "```\ntype PersonProps = {\n  name: string;\n};\n\nfunction Person({ name }: PersonProps) {\n  // ...\n}\n\ntype PrintComponentProps = {\n  collection: Person[];\n  //          ^- 'Person' refers to a value,\n  //              but is being used as a type\n}\n```", "```\nclass Person {\n  name: string;\n\n  constructor(n: string) {\n    this.name = n;\n  }\n}\n\nfunction printPerson(person: Person) {\n  console.log(person.name);\n}\n\nprintPerson(new Person(\"Stefan\")); // ok\nprintPerson({ name: \"Stefan\" }); // also ok\n```", "```\nfunction checkPerson(person: Person) {\n  return person instanceof Person;\n}\n\ncheckPerson(new Person(\"Stefan\")); // true\ncheckPerson({ name: \"Stefan\" }); // false\n```"]