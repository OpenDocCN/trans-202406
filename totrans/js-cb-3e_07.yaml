- en: Chapter 6\. Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are the building blocks that you use to assemble a program out of
    discrete, reusable code routines. But in JavaScript, that’s only part of the story.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript functions are also genuine *objects*—instances of the `Function`
    type. They can be assigned to variables and passed around your code. They can
    be declared in an expression, without a function name, and optionally using a
    streamlined *arrow syntax*. You can even wrap one function in another to create
    a private package that includes the function’s state (called a *closure*).
  prefs: []
  type: TYPE_NORMAL
- en: Functions are also at the core of JavaScript’s object-oriented support. That’s
    because custom classes are really just a special type of constructor function
    (as you’ll see in [Chapter 8](ch08.html#ch08)). Sooner or later, everything in
    JavaScript comes back to functions.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a Function as an Argument to Another Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re calling a function that expects you to provide your own function. What’s
    the best way to pass it?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many functions in JavaScript accept, or even require, a function that’s passed
    as an argument. Some operations ask for a callback function that will be triggered
    when a task is complete. Others need to use your function to complete a broader
    task. For example, many methods of the `Array` object ask you to provide a function
    for sorting, converting, combining, or selecting data. The array then uses your
    function multiple times, until it has processed every element.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different approaches you can use when supplying a function
    as an argument. Here are three common patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a reference to a function that’s already declared elsewhere in your
    code. This approach makes sense if you want to use the function in other parts
    of your application, or if the function is particularly long or complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the function in a *function expression*, then pass it as an argument.
    This approach works well for straightforward tasks, and if you don’t plan to use
    the function anywhere else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare the function inline, at the exact moment it’s required—when you pass
    it as an argument to another function. This is similar to the second approach,
    but it makes your code even more compact. It works best for very short, straightforward
    functions (especially one-liners).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with a simple page that has this button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We attach an event handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the built-in `setTimeout()` function, which schedules a function
    to run after a certain delay (you supply the function). Here’s the first approach
    to function passing, with a separate function named `showMessage()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you pass a function reference by name, make sure you don’t add a set of
    empty parentheses. This example passes `showMessage` to the `setTimeout()` function.
    If you accidentally write `showMessage()`, JavaScript will *run* the `showMessage()`
    function immediately, and pass its return value to `setTimeout()` instead of passing
    a function reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the second approach, which declares the function closer to where it’s
    needed using a function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the scope of `showMessage()` is limited to the `buttonClicked()`
    function. It can’t be called from another function elsewhere in your code. Optionally,
    you could omit the function name (`showMessage`), making it an *anonymous function*.
    Either way, `timeoutCallback` works the same, but a function name can be useful
    in debugging, because it will appear in a stack trace if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the third approach, which declares the function inline when calling
    `setTimeout()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `showMessage()` function is declared and passed to `setTimeout()` in
    one statement. There’s no way for any other part of code to interact with `showMessage()`,
    even inside the `buttonClicked()` function. Optionally, you can leave out the
    name `showMessage()` so that it becomes an anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can simplify this approach even further using arrow syntax, as demonstrated
    in [“Using Arrow Functions”](#arrow_functions). But using a function name is a
    good practice for long or complex code routines. That’s because you’ll see the
    function name in the stack trace if an error occurs inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pay attention to your organization’s style conventions when you use anonymous
    functions. One common pattern is to place the `function()` declaration and the
    opening `{` brace on the same line. Then, put all the code for the anonymous function
    underneath, with one extra level of indent. Finally, put the closing `}` brace
    on a separate line, followed immediately by the rest of the arguments for the
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These three approaches demonstrate a gradually narrowing scope, from the most
    accessible function (in the first example) to the least accessible function (in
    the last example). As a general rule, it’s best to use the narrowest scope possible.
    This reduces ambiguity in your code (making it more understandable for the other
    developers who follow in your footsteps), and reduces the possibility of unexpected
    side effects. However, there’s a trade-off. As a function becomes longer and more
    complex, inline declarations become less readable. And if you want to use the
    function separately, or run unit tests against it, you will need to break it out
    into a separate function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re in any doubt about how a function *uses* a function reference, here’s
    a simple example with a custom function named `callYouBack()` that accepts a function
    parameter and then calls it. Inside the `callYouBack()` function, you treat the
    function reference exactly like an ordinary function, calling it by name and supplying
    any parameters it needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code and click the button, it produces output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [“Using Arrow Functions”](#arrow_functions) for a syntax that lets you simplify
    the declaration of anonymous functions, and is especially useful for single-line
    functions that return a value. See [Table 5-1](ch05.html#functional_array_methods)
    for the most important `Array` methods that accept function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Arrow Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use JavaScript’s arrow syntax to declare an inline function in the
    most compact way possible.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent years, JavaScript has shifted to emphasize functional programming
    patterns—array processing and asynchronous promises are two notable examples.
    To help, they’ve added a new, streamlined function syntax for writing inline functions,
    called *arrow syntax*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of using the `Array.map()` method to transform the contents
    of an array using a named function without using arrow syntax. The initial array
    is a list of numbers, and the transformed array has the square of each number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the same example, but with the `squareNumber()` function declared inline
    using arrow syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example uses the most compact form of arrow syntax. This works for single-parameter,
    single-statement functions. Other functions may not be able to use all the simplifications
    of arrow syntax. To understand why, here’s a step-by-step breakdown of how you
    convert a named function to a function expression that uses arrow syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the list of parameters first, followed the `=>` symbol. If there are no
    parameters, use an empty set of parentheses before the `=>` symbol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If there is exactly one parameter (as in this example), you can remove the parentheses
    around the parameter list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Put the braces and body of the function on the other side of the arrow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If there is just one statement, you can remove the braces and the `return` keyword.
    But if you have more than one statement, you must keep both the braces *and* the
    `return` keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, the arrow function is used for declaring inline functions, so you’ll
    always be passing it to a parameter or assigning it to a variable in an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s look at converting this slightly more complex function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can carry out steps 1, 3, and 4, but step 2 doesn’t apply (because this
    function has two parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, consider this more detailed string processing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, steps 1, 2, and 3 apply, but step 4 does not. You must keep the braces
    and `return` statement intact.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now the difference between the traditional approach and the arrow syntax is
    much smaller. Only the function declaration at the beginning has changed, and
    the overall code savings is minimal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here’s where the decisions around arrow syntax become murkier. It’s often possible
    to compress a function with several statements into a single expression. In the
    string processing example, you could use method chaining (as in [“Replacing All
    Occurrences of a String”](ch02.html#replacing_all_occurrences_string)) and the
    `Array.map()` function ([“Transforming Every Element of an Array”](ch05.html#mapping_array))
    instead of a `for` loop. Applied aggressively, these changes can shorten `applyTitleCase()`
    down to one long statement. You could then use all the arrow syntax shortcuts.
    However, in this case the goal of more concise code isn’t worth the tradeoff in
    clarity. As a general rule of thumb, arrow syntax is a benefit only when it helps
    you write more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions have a different way of binding the `this` keyword. In a declared
    function, `this` maps to the object that calls the function, which could be the
    current window, a button, and so on. In an arrow function, `this` simply refers
    to the code where the arrow function is defined. (In other words, whatever `this`
    is where you create your arrow function remains `this` when the function runs.)
    This behavior simplifies many issues, but at a cost. It means that arrow syntax
    isn’t suitable for object methods and constructors, because arrow functions won’t
    be bound to the object on which they’re called. Even using `Function.bind()` won’t
    change this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few smaller restrictions as well. Arrow functions can’t be used
    with `yield` to make a generator function, and don’t support the `arguments` object.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html#arrays) has numerous examples that use arrow syntax to
    pass short functions to array-processing methods. See, for instance, Recipes ,
    , and .'
  prefs: []
  type: TYPE_NORMAL
- en: Providing a Default Parameter Value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to specify a default value for a parameter, which will be used if the
    caller doesn’t pass in an argument when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can directly assign default values to your parameters when you declare
    a function. Here’s an example that sets a default value for the third parameter,
    `thirdNum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s possible to call this function without specifying all three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Default parameters are a relatively recent invention. However, JavaScript has
    never forced function callers to supply all the parameters for a function. In
    this distant past, functions could simply check if a parameter was `undefined`
    (by testing it with the `typeof` operator, as described in [“Checking if an Object
    Is a Certain Type”](ch07.html#check_object_type)).
  prefs: []
  type: TYPE_NORMAL
- en: You can set default values for as many parameters as you want. As a matter of
    good style, you should put your required parameters first, followed by parameters
    that have default values. In other words, once you add a default parameter, all
    the parameters *after* should also become optional and have default values. This
    convention isn’t required, but it makes code clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling a function that has multiple default parameters, you can pick
    and choose which values you supply. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to specify `firstNum`, `secondNum`, and `multiplier`, but omit
    the `thirdNum` parameter, you need to use `undefined` as a placeholder. This allows
    you to pass all your parameters in the proper order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But `null` won’t work as a placeholder. In this example, it’s simply converted
    to the number 0, changing the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Many other languages have nicer shortcuts for default parameters (such as using
    commas to indicate order without needing to supply a placeholder value, or setting
    parameter values by name). JavaScript does not, although you can simulate named
    parameters using object literal syntax ([“Using Named Function Parameters”](#named_parameters)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Function That Accepts Unlimited Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a function that accepts as many arguments as the caller wants
    to supply, without requiring the creation of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a *rest parameter* when you declare your function. The rest parameter is
    defined with three dots before its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rest parameter does not need to be the only parameter, but it must be the
    last parameter. It collects all the extra arguments that are passed to the function
    and adds them to a new array.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, JavaScript developers used the `arguments` object for similar functionality.
    The `arguments` object is available in every function (technically, it’s the `Function.arguments`
    property), and it provides array-like access to all the parameters. However, `arguments`
    is not a true array, and developers often used boilerplate code to transform it
    into one. You may still see this approach in the wild, but today rest parameters
    avoid this hassle.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The rest parameter looks the same as the spread operator ([“Breaking Down an
    Array into Separate Variables”](ch05.html#destructuring_arrays)), but the two
    play complementary roles. The spread operator *expands* an array or the properties
    of an object into separate values, whereas the rest operator collects separate
    values and inserts them into a single array object.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have an array of values that you want to pass into a function, but the
    function expects a rest parameter, you can make the conversion using the spread
    operator (see [“Breaking Down an Array into Separate Variables”](ch05.html#destructuring_arrays)).
  prefs: []
  type: TYPE_NORMAL
- en: This example uses a loop to process the array of values, but you could achieve
    the same result more cleanly with the `Array.reduce()` function, as demonstrated
    in [“Combining an Array’s Values in a Single Calculation”](ch05.html#reducing_array).
  prefs: []
  type: TYPE_NORMAL
- en: Using Named Function Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want an easier way to choose the optional parameters you send to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bundle all the optional parameters into a single object literal ([“Using an
    Object Literal to Bundle Data”](ch07.html#object_literal)). The caller can then
    decide what optional parameters to include when they create the object literal.
    Here’s an example of how you call a function that uses this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In your function, you can use *destructuring assignment* to quickly copy the
    values out of the object literal and into separate variables. Here’s an example
    of a function that accepts three arguments. The first two (`newerDate` and `olderDate`)
    are required, but the third parameter is an object literal that can hold three
    optional values (`discardTime`, `discardYears`, and `precision`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call `dateDifferenceInSeconds()` with or without the object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common pattern in JavaScript is to use an object literal to transmit optional
    values. This lets you set only the properties you need, without worrying about
    the order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the function, you can retrieve properties from the object literal individually,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But this solution in this recipe uses a better shortcut. It unpacks the object
    literal into named variables using destructuring, which maps the properties of
    an object to individual, named variables. You can use destructuring assignment
    in a statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'or right in the function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a good practice to set an empty object literal as a default value ([“Providing
    a Default Parameter Value”](#provide_default_parameter)). This empty object is
    used if the caller doesn’t supply the object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s up to the caller whether they decide to set some, all, or none of the
    properties in the object literal. Any values that aren’t set will evaluate to
    the special value `undefined`, which you can test for in your code. Here’s a less-optimized
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, you won’t need to explicitly check for `undefined` values. For example,
    `undefined` evaluates to `false` in conditional logic. The `dateDifferenceInSeconds()`
    function uses the behavior when it evaluates the `discardYears` and `discardTime`
    properties, allowing us to shorten the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There’s a similar shortcut with the `precision` property. It’s safe to call
    `Number.toPrecision(undefined)`, because that’s the same as calling `toPrecision()`
    with no argument. Either way, the number is rounded to the nearest whole integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only disadvantage to the object literal pattern is that there’s no way
    to prevent property-naming mistakes, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Using an Object Literal to Bundle Data”](ch07.html#object_literal) introduces
    object literals. [“Breaking Down an Array into Separate Variables”](ch05.html#destructuring_arrays)
    shows the array destructuring syntax, which is similar to the object destructuring
    syntax used in this recipe, except it acts on arrays instead of objects (and uses
    square brackets instead of curly braces).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Function That Stores its State with a Closure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a function that can remember data, but without having to
    use global variables and without repeatedly sending the same data with each function
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wrap the function that needs to preserve its state in *another* function. The
    outer function returns the inner function, following this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Both of these functions can accept parameters. But here’s the trick. The outer
    function’s parameters live as long as you have a reference to the inner function.
    You can call the inner function as many times as you want, and the data from the
    outer function persists. (Conceptually, it’s as though the outer function is an
    object-creation method, and the inner function is an object with state.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, you’ll find that you need a way to store data that’s used across several
    function calls. You could use global variables, but that’s a technique of last
    resort. Global variables lead to naming collisions, complicate code, and often
    lead to hidden interdependencies between different functions, limiting the reuse
    of your code and giving cover for subtle coding bugs to hide.
  prefs: []
  type: TYPE_NORMAL
- en: You could ask the function caller to maintain this information, and send it
    with each function call, but this can also be awkward. This example shows a different
    solution—creating a stateful function package called a *closure*.
  prefs: []
  type: TYPE_NORMAL
- en: In this solution, the outer function `greetingMaker()` takes one argument, which
    is a specific greeting. It also returns an inner function, `addName()`, which
    itself takes the person’s name. The closure encompasses the `addName()` function
    and its surrounding context, which includes the parameter that was passed to the
    `greetingMaker()` function. To demonstrate this fact, two copies of `addName()`
    are created, in two different contexts. One exists in a closure where a daytime
    message was passed to `greetingMaker()`, and the other exists in a closure where
    a nighttime message was passed to `greetingMaker()`. Either way, when the `addName()`
    function is called, it uses the current context to construct its message.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth noting that state isn’t limited to parameter values. Any variables
    that are in the outer function also stay alive as long as the function reference
    exists. Here’s an example that uses a simple counter variable to keep track of
    how many function calls you’ve made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see an another example of a function that uses a closure to store state,
    see [“Extra: Building a Repeatable Pseudorandom Number Generator”](#repeatable_PRNG).'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not an accident that closures and wrapped functions seem to echo object-oriented
    programming. In the past, JavaScript developers used functions to mimic custom
    classes (see [“Using the Constructor Pattern to Make a Custom Class”](ch08.html#constructor_pattern)),
    and JavaScript’s `class` keyword extends this approach (see [“Creating a Reusable
    Class”](ch08.html#using_es6_classes)).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Generator Function That Yields Multiple Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a *generator*, a function that can provide multiple values
    on-demand. Each time a generator returns a value, it pauses its execution until
    the caller requests the next value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To declare a generator function, start by replacing the `function` keyword
    with `function*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Inside the generator function, use the `yield` keyword each time you want to
    return a result. Remember, execution stops after you yield (much like when you
    use the `return` keyword). However, execution *resumes* when the caller asks for
    the function’s next value. This process continues until your function code ends,
    or you return a final value with the `return` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a naïve implementation of a generator. (It works, but it doesn’t solve
    a useful problem.) This function yields three values, followed by a return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When you call a generator function, you receive a `Generator` object as a return
    value. This happens immediately, before the generator function code begins to
    run. You use the `Generator` object to run the function and retrieve the values
    that are yielded. You can also use it to determine when the generator function
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Each time you call `Generator.next()`, the generator function runs until it
    reaches the next `yield` (or the final `return`). The `next()` method returns
    an object with two values. The `value` property wraps the yielded or returned
    value from the generator function. The `done` property is a Boolean that remains
    `false` until the generator function has ended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generators allow you to create functions that can be paused and resumed. Best
    of all, JavaScript manages their state automatically, which means you don’t need
    to write any code to preserve values in-between calls to `next()`. (This is different
    than building a custom iterator, for example.)
  prefs: []
  type: TYPE_NORMAL
- en: Because generators have a lazy-execution model, they’re a good choice for time-consuming
    data creation or retrieval operations. For example, you could use a generator
    to calculate numbers in a complex sequence, to retrieve chunks of information
    from a stream of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, you won’t know how many values a generator will return. You could
    write a `while` loop that checks the `Generator.done` property and keeps calling
    `next()` until it’s finished. But because the generator object is iterable, a
    `for`…`of` loop works even better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Either way, this approach only gets *yielded* results. If your generator has
    a final return value, it’s ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Some generator functions are designed to be *infinite*. As long as you keep
    calling `next()`, they keep yielding values. If you’re calling an infinite generator,
    you can’t dump all its values into an array (your program will hang). Instead,
    you’ll probably use a `while` loop with a condition that turns `false` when you
    have all the values you need.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Creating an Asynchronous Generator Function”](ch09.html#async_generator)
    shows how to create generators that run asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Building a Repeatable Pseudorandom Number Generator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you’ve dissected the essential syntax for generator functions, you
    haven’t seen a truly practical example. Here’s one that shows how an infinite
    generator function can provide a useful sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [“Generating Random Numbers”](ch03.html#generating_random_numbers),
    the `Math.random()` method lets you generate pseudorandom numbers, but you can’t
    control the *seed value*. (Instead, `Math.random()` seeds its pseudorandom number
    generator using a opaque, noncryptographically secure method that may vary from
    one JavaScript implementation to the next.) This is fine for most applications.
    But in some scenarios you need a way to generate a *repeatable* sequence of random-seeming
    numbers. The numbers still need to be statistically random in their distribution;
    the only difference is that you need to be able to ask your pseudorandom number
    generator to give you same sequence more than once. Examples where repeatable
    pseudorandom numbers are important include certain types of simulations or tests
    that need to be precisely reproducible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several third-party JavaScript libraries that provide seedable (and
    thus repeatable) pseudorandom number generators. You can find a long list at [GitHub](https://github.com/bryc/code/blob/master/jshash/PRNGs.md).
    One of the simplest is Mulberry32\. Its JavaScript implementation fits in a single
    dense block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `mulberry32()` function uses the closure technique described in [“Creating
    a Function That Stores its State with a Closure”](#create_a_function_that_remembers_its_sta).
    It accepts a seed value that’s then locked into the context of the inner `random()`
    function. That means that whenever you call `random()`, the original seed value
    will be available in the outer function. This is important, because a different
    seed means a different sequence of random variables. If you call `mulberry32()`
    with the same seed value, you’re guaranteed to get the same sequence of pseudorandom
    numbers from `random()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like most pseudorandom number generators, Mulberry32 returns a fractional value
    between 0 and 1\. To convert this to integer in a given range, use the technique
    shown in [“Generating Random Numbers”](ch03.html#generating_random_numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures have been a part of the JavaScript language since time immemorial,
    but generators are a much newer innovation. You can rewrite this example using
    a generator function, which more clearly expresses its purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Because the `mulberry32()` function is declared with `function*`, it’s immediately
    obvious that it will return multiple values. Inside, an infinite loop ensures
    that the generator will always be ready to create a new number. After each pass
    through the loop, `random()` yields a new random value and then pauses until a
    new value is requested with `next()`. The overall operation of this solution is
    similar to its original version, but now it follows a familiar pattern that could
    make its usage easier to discover. (But—as always—the value of a refactoring like
    this depends on the conventions of your organization, the expectations of the
    people reading your code, and your own personal taste.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s no danger to building an infinite loop in a generator as long as it
    yields. Yielding pauses the code, ensuring that it won’t tie up the JavaScript
    event loop. Unlike normal functions, there is no expectation that a generator
    function will run to its final closing brace. As soon as a `Generator` object
    goes out of scope, that function and its context are made available for garbage
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing Redundancy by Using Partial Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a function that takes several arguments. You want to wrap this function
    with one or more specialized versions that require fewer arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following `makestring()` function accepts three parameters (in other words,
    it has an *arity* of 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: However, the first and last arguments are often repeated based on a specific
    use case. You want to eliminate the repetition of arguments whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can solve this problem by creating new functions that wrap the previously
    created `makeString()` function, but with known argument values locked down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now only one argument is needed to call any of these new functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique of wrapping one function in another function to lock down one
    or more argument values is called *partial application* (because the new functions
    *partially apply* the argument values to the original function). Of course, the
    tradeoff is that the extra functions you create can also clutter up your code,
    so don’t build wrappers you don’t intend to use and reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced: A Partial Function Factory'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can reduce the redundancy of this approach even further by creating a function
    that can partial-ize *any* other function. In fact, this approach is a fairly
    common JavaScript design pattern. In the past, you needed to rely on the JavaScript
    `arguments` object and array manipulation. In modern JavaScript, the rest and
    spread operators make the job much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation shown here, the partial-izing function is named `partial()`.
    It’s capable of reducing any number of arguments for any function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This function requires a bit of unpacking. But first, it helps to see a simple
    example that uses it. Here, the `partial()` function is used to create a new `cubeIt()`
    function that wraps the more general `raiseToPower()` function. In other words,
    `cubeIt()` uses partial application to lock down one of the `raiseToPower()` arguments
    (the exponent, which it sets to 3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now when you call `cubeIt(9)`, the call is mapped to `raiseToPower(3, 9)`.
  prefs: []
  type: TYPE_NORMAL
- en: So how does it work? The `partial()` function accepts two arguments. First is
    the function you want to partial-ize (`fn`). Second is a list of all the arguments
    you want to lock in place (`argsToApply`), which is captured in an array using
    the rest operator (`...`), as explained in [“Creating a Function That Accepts
    Unlimited Arguments”](#creating_function_unlimted_arguments).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now things get interesting. The `partial` function returns a nested inner function
    (a technique explored in [“Creating a Function That Stores its State with a Closure”](#create_a_function_that_remembers_its_sta)).
    The nested inner function accepts all the arguments that *aren’t* locked in place.
    Once again, these arguments are captured in an array using the rest operator (`...restToApply`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This newly created function now has three key pieces of information: the underlying
    function (`fn`), the arguments that are locked in place (`argsToApply`), and the
    arguments that are set each time the function is called (`restArgsToApply`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s only one line of code inside this function, but it packs in a lot.
    It expands the two arrays into argument lists using the spread operator (which,
    somewhat confusingly, looks exactly like the rest operator). In other words, `argsToApply`
    becomes a list or arguments followed by `restToApply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A common practice in functional programming is writing *higher-order functions*
    (functions that operate on other functions). The `partial()` function is a higher-level
    function that creates a wrapper for another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one limitation to this implementation of the `partial()` function.
    Because it puts fixed arguments first, you can’t lock down a later argument without
    locking down all the arguments that occur first. If you wanted to use `partial()`
    to make a wrapper for the `makeString()` function from the original solution,
    you need to rearrange its arguments first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Extra: Using bind() to Partially Provide Arguments'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also create partial applications with the `Function.bind()` method.
    The `bind()` method returns a new function, setting `this` to whatever is provided
    as a first argument. All the other arguments are prepended to the argument list
    for the new function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than having to use `partial()` to create the named entity function,
    we can now use `bind()` to provide the same functionality, passing in `undefined`
    as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now you have two good ways to create multiple versions of a function that use
    different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing this with Function Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your function is attempting to use the keyword `this`, but it’s not bound to
    the right object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Function.bind()` method to change the context of your function and
    the meaning of the `this` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The keyword `this` refers to the owner or parent of a function. The challenge
    associated with `this` in JavaScript is that we can’t always guarantee what parent
    object will apply to a function.
  prefs: []
  type: TYPE_NORMAL
- en: In the solution, the object has a method, `sayGreeting()`, which outputs a message
    and maps another nested function to its property, `nestedGreeting`. You’ll see
    this approach if you use the constructor pattern ([“Using the Constructor Pattern
    to Make a Custom Class”](ch08.html#constructor_pattern)) to create class-like
    function objects.
  prefs: []
  type: TYPE_NORMAL
- en: Without the `Function.bind()` method, the first message would say “Now this
    is easy, object,” but the second would say “hello window.” The reason the second
    message has a different name is because the nesting of the function disassociates
    the inner function from the surrounding object, and all *unscoped* functions automatically
    become the property of the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `bind()` method solves this problem by binding the function to the object
    you choose. In the example, the `bind()` method is invoked on the nested function
    and given a reference to the parent object. Now, when the code inside `nestedGreeting()`
    uses `this`, it points to the parent object you set.
  prefs: []
  type: TYPE_NORMAL
- en: The `bind()` method is particularly useful for the `setTimeout()` and `setInterval()`
    timer functions. Ordinarily, when these functions trigger your callback, the `this`
    reference is lost (it becomes `undefined`). But with `bind()`, you can ensure
    that the callback function keeps the reference you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 6-1](#demonstration_of_the_utility_of_function) is a web page that
    uses `setTimeout()` to perform a countdown operation from 10 to 0\. As the numbers
    are counted down, they’re inserted into the web page. This example also uses the
    constructor pattern for object creation (as described in [“Using the Constructor
    Pattern to Make a Custom Class”](ch08.html#constructor_pattern)) to create a class-like
    `Counter` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1\. Demonstrating the utility of `bind()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `setTimeout()` function in the code sample had been the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: it would lose `this`, and the callback function wouldn’t be able to access variables
    like `currentCount`, even though the `incrementCounter()` method is part of the
    same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: self = this'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An older alternative to using `bind()`, and one that is still in use, is to
    assign `this` to a variable in the outer function, which is then accessible to
    the inner. Typically `this` is assigned to a variable named `that` or `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Without the assignment, the second message would once again reference “window,”
    not “object.”
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Recursive Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to implement a function that *calls itself* to accomplish a task, which
    is a technique called recursion. Recursion is useful when dealing with hierarchical
    data structures (for example, node trees or nested arrays), certain types of algorithms
    (sorting), and some mathematical calculations (the Fibonacci sequence).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursion is a well-known concept in the field of mathematics, as well as computer
    science. An example of recursion in mathematics is the *Fibonacci sequence*. A
    Fibonacci number is the sum of the two previous Fibonacci numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of mathematical recursion is a *factorial*, usually denoted
    with an exclamation point (4!). A factorial is the product of all integers from
    1 to a given number *n*. If *n* is 4, then the factorial (4!) would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'These recursions can be coded in JavaScript using a series of loops and conditions,
    but they can also be coded using functional recursion. Here’s a recursive function
    that finds the nth number in the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s one that solves a factorial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A characteristic that distinguishes recursive functions is a *termination condition*
    (also known as a *base case*). A recursive function cannot keep calling itself
    indiscriminately, because that would lead to an infinite loop (until stack space
    is exhausted and the program fails). Instead, a recursive function examines a
    condition and then decides to call itself (stepping one level deeper into recursion)
    or return a value (stepping one level back, to the calling function). When the
    top-level function returns a value, that becomes the final result and the recursive
    operation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: In the Fibonacci example, `n` is tested to see if it’s less than 2\. If it is,
    it’s returned; otherwise the Fibonacci function is called again with (`n-1`) and
    with (`n-2`), and the sum of both is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In the factorial example, when the function is first called, the value passed
    as the argument is compared to the number 1\. If `n` is less than or equal to
    1 (negative numbers aren’t supported in this simple implementation), the function
    terminates, returning 1\. However, if `n` is greater than 1, what’s returned is
    the value of `n` times a call to the `factorial()` function again, this time passing
    in a value of `n–1`. The value of `n` then decreases with each iteration of the
    function, until the termination condition is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a factorial is being computed, the interim values of each function call
    are pushed onto a stack in memory and kept until the termination condition is
    met. Then the values are popped from memory and returned, in a state similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| return 1; | // 0! |'
  prefs: []
  type: TYPE_TB
- en: '| return 1; | // 1! |'
  prefs: []
  type: TYPE_TB
- en: '| return 1 * 2; | // 2! |'
  prefs: []
  type: TYPE_TB
- en: '| return 1 * 2 * 3; | // 3! |'
  prefs: []
  type: TYPE_TB
- en: '| return 1 * 2 * 3 * 4; | // 4! |'
  prefs: []
  type: TYPE_TB
- en: Most recursive functions can be replaced with code that performs the same function
    linearly, via some kind of loop. And loops may perform better, although the difference
    is often negligible. The advantage of recursion is that recursive functions can
    be very terse and minimal. Whether they are clearer is a matter of debate. (They
    are clearly *shorter*, which makes them easier to digest, but their self-referential
    nature can make their logic harder to grasp at first glance, particularly for
    programmers who haven’t used recursive functions before.)
  prefs: []
  type: TYPE_NORMAL
- en: If a recursive function calls itself over and over again, it will eventually
    exhaust the call stack. This condition leads to an error with a message like “Out
    of stack space,” “Too much recursion,” or “Maximum call stack size exceeded.”
    The exact message and the number of open function calls that are allowed at once
    depend on the implementation of the JavaScript engine. However, these error messages
    usually indicate an incorrectly structured recursive function that is failing
    to evaluate its termination condition and calling itself in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
