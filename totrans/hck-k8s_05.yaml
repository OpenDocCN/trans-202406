- en: Chapter 5\. Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will focus on networking aspects of your workloads. We will
    first review the defaults that Kubernetes proper comes equipped with and what
    else is readily available due to integrations. We cover networking topics including
    East-West and North-South traffic—that is, intra-pod and inter-pod communication,
    communication with the worker node (hosts), cluster-external communication, workload
    identity, and encryption on the wire.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second part of this chapter we have a look at two more recent additions
    to the Kubernetes networking toolbox: service meshes and the Linux kernel extension
    mechanism eBPF. We try to give you a rough idea if, how, and where you can, going
    forward, benefit from both.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 5-1](#fig-networking-layer-model), there are many
    moving parts in the networking space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Network layer model](Images/haku_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Network layer model
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The good news is that most if not all of the protocols should be familiar to
    you, since Kubernetes uses the standard Internet Engineering Task Force (IETF)
    suite of networking protocols, from the [Internet Protocol](https://oreil.ly/xp1b4)
    to the Domain Name System ([DNS](https://oreil.ly/nzOlg)). What changes, really,
    is the scope and generally the assumptions about how the protocols are used. For
    example, when deployed on a worldwide scale, it makes sense to make the time-to-live
    (TTL) of a DNS record months or longer.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of a container that may run for hours or days at best, this assumption
    doesn’t hold anymore. Clever adversaries can exploit such assumptions and as you
    should know by now, that’s exactly what the Captain would do.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will focus on the protocols most often used in Kubernetes—and
    their weak points with respect to workloads. As Captain Hashjack likes to say,
    “loose lips sink ships,” so we’ll first explore for permissive networking defaults,
    then show how to attack them as well as discuss the controls you can implement
    to detect and mitigate these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With defaults we mean the default values of configurations of components that
    you get when you use Kubernetes from source, in an unmodified manner. From a networking
    perspective, workloads in Kubernetes have the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Flat topology. Every pod can see and talk to every other pod in the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No securityContext. Workloads can escalate to host network interface controller
    (NIC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No environmental restrictions. Workloads can query their host and cloud metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No identity for workloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No encryption on the wire (between pods and cluster-external traffic).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the preceding list might look scary, a different way to look at it might
    make it easier to assess the risks present. As depicted in [Figure 5-2](#fig-networking-overview),
    the main communication paths in Kubernetes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Intra-pod traffic: containers within a pod communicating (see the next section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inter-pod traffic: pods in the same cluster communicating (see [“Inter-Pod
    Traffic”](#workload-networking-inter-pod))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod-to-worker node traffic (see [“Pod-to-Worker Node Traffic”](#workload-networking-env))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cluster-external traffic: communication of pods with the outside world (see
    [“Cluster-External Traffic”](#workload-networking-external))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Kubernetes networking overview](Images/haku_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Kubernetes networking overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s now have a closer look at the communication paths and other networking-relevant
    defaults in Kubernetes. Among other things, we’ll discuss [“The State of the ARP”](#workload-networking-arp),
    [“No securityContext”](#workload-networking-sec-ctx), [“No Workload Identity”](#workload-networking-identity),
    and [“No Encryption on the Wire”](#workload-networking-encryption).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are some aspects of the networking space that depend heavily on the environment
    in which Kubernetes is used. For example, when using hosted Kubernetes from one
    of the cloud providers, the control plane and/or data plane may or may not be
    publicly available. If you are interested in learning more how the big three handle
    this, have a look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon [EKS private clusters](https://oreil.ly/Q8VkK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure [AKS private clusters](https://oreil.ly/7XD3l)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google [GKE private clusters](https://oreil.ly/lNCG3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this is not an intrinsic property of Kubernetes and many combinations
    are possible, we decided to exclude this topic from our discussion in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, are you ready to learn about the Kubernetes networking defaults?
  prefs: []
  type: TYPE_NORMAL
- en: Intra-Pod Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way intra-pod networking in Kubernetes works is as follows. An implicit
    so-called [pause](https://oreil.ly/VRjJQ) container in a pod (`cp` in [Figure 5-3](#fig-networking-pod))
    spans a Linux [network namespace](https://oreil.ly/rr1RM).
  prefs: []
  type: TYPE_NORMAL
- en: '![Internals of a Kubernetes pod](Images/haku_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Internals of a Kubernetes pod
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other containers in the pod, such as init containers (like `ci1` and `ci2`),
    and the main application container and sidecars, such as proxies or logging containers
    (for example, `c1` to `c3`), then join the pause container’s network and IPC namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The pause container has the network bridge mode enabled and all the other containers
    in the pod are sharing their namespace via container mode.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 2](ch02.xhtml#ch-pod-level-resources), pods were designed
    to make it easy to lift and shift existing applications into Kubernetes, which
    has sobering security implications. Ideally, you rewrite the application so that
    the tight coupling of containers in a pod are not necessary or deploy traditional
    tooling in the context of a pod.
  prefs: []
  type: TYPE_NORMAL
- en: While the latter seems like a good idea initially, do remember that this is
    a stopgap measure at best. Once the boundaries are clear and effectively every
    microservice is deployed in its own pod, you can go ahead and use the techniques
    discussed in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, no matter if you’re looking at defense in depth in the context
    of a pod or cluster-wide, you can employ a range of dedicated container security
    open source and commercial offerings. See also respective section [“Networking”](app02.xhtml#apx-networking)
    in [Appendix B](app02.xhtml#appendix-resources).
  prefs: []
  type: TYPE_NORMAL
- en: Inter-Pod Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Kubernetes cluster, by default every pod can see and talk to every other
    pod. This default is a nightmare from a security perspective (or a free ride,
    depending on which side you’re on) and we can not emphasize enough how dangerous
    this fact is.
  prefs: []
  type: TYPE_NORMAL
- en: No matter what your threat model is, this “all traffic is allowed” policy for
    both inter-pod and external traffic represents one giant attack vector. In other
    words, you should never rely on the Kubernetes defaults in the networking space.
    You should never, ever run a Kubernetes cluster without restricting network traffic
    in some form or shape. For a practical example on how you can go about this, have
    a look at [“Traffic Flow Control”](#workload-network-policies).
  prefs: []
  type: TYPE_NORMAL
- en: Pod-to-Worker Node Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If not disabled, workloads can query the worker node (host) they are running
    on as well as the (cloud) environments they are deployed into.
  prefs: []
  type: TYPE_NORMAL
- en: No default protection exists for worker nodes, routable from the CNI. Further,
    the worker nodes may be able to access cloud resources, datastores, and API servers.
    Some cloud providers, notably Google, offer some solutions for this issue; see,
    for example, [shielded GKE Nodes](https://oreil.ly/RykAM).
  prefs: []
  type: TYPE_NORMAL
- en: For cloud environments in general, good practices exist. For example, Amazon
    EKS recommends to [restrict access to instance metadata](https://oreil.ly/ycvSd)
    and equally GKE documents how to [protect cluster metadata](https://oreil.ly/pMDaj).
  prefs: []
  type: TYPE_NORMAL
- en: Further, commercial offerings like Nirmata’s [Virtual Clusters and Workload
    Policies](https://oreil.ly/LSElg) can be used in this context.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster-External Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To allow pods to communicate with cluster-external endpoints, Kubernetes has
    added a number of mechanisms over time. The most recent and widely used is called
    an [Ingress](https://oreil.ly/F17YB). This allows for layer 7 routing (HTTP),
    whereas for other use cases such as layer 3/4 routing you would need to use older,
    less convenient methods. See also [Publishing Services (ServiceTypes)](https://oreil.ly/pzlGE)
    in the docs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for you to use the Ingress resource, you will need to pick an ingress
    controller. You have many many choices, oftentimes open source-based, which include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Emissary-ingress](https://oreil.ly/N8v57)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Contour](https://oreil.ly/T9nsX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HAProxy Ingress](https://oreil.ly/ZAm5g)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NGINX Ingress Controller](https://oreil.ly/G6yS3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Traefik](https://oreil.ly/h0Tpr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, cloud providers usually provide their own solutions, integrated
    with their managed load-balancing services.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption on the wire (TLS) is almost the default nowadays, and most Ingress
    solutions support it out of the box. Alternatively, you can use a service mesh
    for securing your North-South traffic (see [“Service Meshes”](#workload-networking-service-meshes)).
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, on the application level you might want to consider using
    a web application firewall (WAF) such as offered by most cloud providers, or you
    can use standalone offering such as [Wallarm](https://oreil.ly/iTXQu).
  prefs: []
  type: TYPE_NORMAL
- en: More and more practitioners are sharing their experiences in this space, so
    keep an eye out for blog posts and CNCF webinars covering this topic. See, for
    example, [“Shaping Chick-fil-A One Traffic in a Multi-Region Active-Active Architecture”](https://oreil.ly/Q8Twj).
  prefs: []
  type: TYPE_NORMAL
- en: The State of the ARP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Address Resolution Protocol](https://oreil.ly/8egtf) (ARP) is a link layer
    protocol used by the Internet Protocol (IP) to map IP network addresses to the
    hardware (MAC) addresses. Liz Rice showed in her KubeCon NA 2019 talk, [“CAP_NET_RAW
    and ARP Spoofing in Your Cluster: It’s Going Downhill From Here”](https://oreil.ly/wnQKi),
    how defaults allow us to open raw network sockets and how this can lead to issues.'
  prefs: []
  type: TYPE_NORMAL
- en: It involves using ARP and DNS to fool a victim pod to visit a fake URL, which
    is possible due to the way Kubernetes [handles local FQDNs](https://oreil.ly/NAPnT),
    and it requires that `CAP_NET_RAW` is available to a pod.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, see the Aqua Security blog post [“DNS Spoofing on Kubernetes
    Clusters”](https://oreil.ly/g6Zu3).
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is, there are defenses available to mitigate the ARP-based attacks
    and spoil the Captain’s mood:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Pod Security Policies (PSP) as discussed in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies),
    to drop `CAP_NET_RAW`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic policy engines as described in [“Generic Policy Engines”](ch08.xhtml#generic-policy-engines)
    such as [Open Policy Agent/Gatekeeper](https://oreil.ly/VpDrN), or by using [Kyverno
    to convert PSPs](https://oreil.ly/5Xn2T) (also see [this video](https://oreil.ly/ZWp1X)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using, for example, [Calico](https://oreil.ly/jQchh) or [Cilium](https://oreil.ly/ZWrKF)
    on layer 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you tell if you’re affected? Use [kube-hunter](https://oreil.ly/uDFka),
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: No securityContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, workloads can escalate to the NIC of the worker node they are running
    on. For example, when running privileged containers, one can escape from the container
    [using kernel modules](https://oreil.ly/uRrgr). Further, as the Microsoft Azure
    team pointed out in its [“Threat matrix for Kubernetes” blog post](https://oreil.ly/1ohm8):'
  prefs: []
  type: TYPE_NORMAL
- en: Attackers with network access to the host (for example, via running code on
    a compromised container) can send API requests to the Kubelet API. Specifically
    querying `https://[NODE IP]:10255/pods/` retrieves the running pods on the node.
    `https://[NODE IP]:10255/spec/` retrieves information about the node itself, such
    as CPU and memory consumption.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Naturally, one wants to avoid these scenarios and one way to go about this is
    to apply PSPs, as discussed in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the [Baseline/default policy](https://oreil.ly/MD6BD) has the
    following defined:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing the host namespaces must be disallowed
  prefs: []
  type: TYPE_NORMAL
- en: '`spec.hostNetwork`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.hostPID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.hostIPC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privileged pods disable most security mechanisms and must be disallowed
  prefs: []
  type: TYPE_NORMAL
- en: '`spec.containers[*].securityContext.privileged`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.initContainers[*].securityContext.privileged`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HostPorts` should be disallowed or at minimum restricted to a known list'
  prefs: []
  type: TYPE_NORMAL
- en: '`spec.containers[*].ports[*].hostPort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spec.initContainers[*].ports[*].hostPort`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there are a number of commercial offerings, such as Palo Alto Networks
    [Prisma Cloud](https://oreil.ly/3kNmb) (formerly Twistlock), that you can use
    to harden your worker nodes in this context.
  prefs: []
  type: TYPE_NORMAL
- en: No Workload Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Kubernetes does not assign an identity to services. SPIFFE/SPIRE
    can be used to manage workload identities and enable mTLS. [SPIFFE](https://spiffe.io)
    (Secure Production Identity Framework for Everyone) is a collection of specifications
    for securely identifying workloads. It provides a framework enabling you to dynamically
    issue an identity to a service across environments by defining short-lived cryptographic
    identity documents—called SPIFFE Verifiable Identity Documents (SVIDs)—via an
    API. Your workloads in turn can use these SVIDs when authenticating to other workloads.
    For example, an SVID can be used to establish an TLS connection or to verify a
    JWT token.
  prefs: []
  type: TYPE_NORMAL
- en: No Encryption on the Wire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For workloads in regulated industries, that is, any kind of app that is required
    to conform to a (government issued) regulation, encryption on the wire—or encryption
    in transit, as it’s sometimes called—is typically one of the requirements. For
    example, if you have a [Payment Card Industry Data Security Standard](https://oreil.ly/Pr7oP)
    (PCI DSS)–compliant app as a bank, or a [Health Insurance Portability and Accountability
    Act](https://oreil.ly/uLjNn) (HIPAA)–compliant app as a health care provider,
    you will want to make sure that the communication between your containerized microservices
    is protected against sniffing and person-in-the-middle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: These days, the Transport Layer Security (TLS) protocol as defined in [RFC 8446](https://oreil.ly/VeMXC)
    and older IETF paperwork is usually used to encrypt traffic on the wire. It uses
    asymmetric encryption to agree on a shared secret negotiated at the beginning
    of the session (“handshake”) and in turn symmetric encryption to encrypt the workload
    data. This setup is a nice performance versus security trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: While control plane components such as the API server, `etcd`, or a `kubelet`
    can rely on an PKI infra out-of-the-box, providing APIs and good practices for
    [certificates](https://oreil.ly/PA3NQ), the same is sadly not true for your workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see the API server’s hostname, and any IPs encoded into its TLS certificate,
    with `openssl`. You can find example code for this in [“Control Plane”](ch07.xhtml#control_plane).
  prefs: []
  type: TYPE_NORMAL
- en: By default, the traffic between pods and to the outside world is not encrypted.
    To mitigate, enable workload encryption on the wire, for example with [Calico](https://oreil.ly/jwHQU),
    with [Wireguard](https://oreil.ly/ZxGoa) VPN, or with Cilium, which supports both
    [Wireguard and IPsec](https://oreil.ly/6bYn9). Another option to provide not only
    this sort of encryption but also workload identity, as discussed in [“No Workload
    Identity”](#workload-networking-identity), are service meshes. With the defaults
    out of the way, let’s move on to the threat modeling for the networking space.
  prefs: []
  type: TYPE_NORMAL
- en: Threat Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The threat model in the networking space (see [“Starting to Threat Model”](ch01.xhtml#threat-models-def));
    that is, the collection of identified networking vulnerabilities according to
    the risk they pose—is what we’re focusing on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the threat model we consider in the networking space, with respect
    to workloads? What are our assumptions about what attackers could do to our precious
    workloads and beyond to the infrastructure?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following observations should give you an idea about potential threat models.
    We illustrate these scenarios with some examples of past attacks, covering the
    2018–2020 time frame:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the front door, for example via an ingress controller or a load balancer,
    and then either pivoting or performing a denial-of-service attack, such as observed
    in [CVE-2020-15127](https://oreil.ly/m4aKx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using developer access paths like `kubectl cp` ([CVE-2019-11249](https://oreil.ly/U7ogf))
    or developer environments such as Minikube, witnessed in [CVE-2018-1002103](https://oreil.ly/lkf3P)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching a pod with access to host networking or unnecessary capabilities,
    as we will further discuss in [“The State of the ARP”](#workload-networking-arp)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging a compromised workload to connect to another workload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning of all CNI plug-ins and further use this information to identify
    vulnerabilities; for example, [CVE-2019-9946](https://oreil.ly/3kVUY)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking a control plane component such as the API server and `etcd` or a `kubelet`
    or `kube-proxy` on the worker; for example, [CVE-2020-8558](https://oreil.ly/tauhi),
    [CVE-2019-11248](https://oreil.ly/Tybuu), [CVE-2019-11247](https://oreil.ly/60und),
    and [CVE-2018-1002105](https://oreil.ly/KouIk)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing server-side request forgery (SSRF); for example, concerning the hosting
    environment, like a cloud provider’s VMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing person-in-the-middle attacks, such as seen in the context of [IPv6
    routing](https://oreil.ly/hGXIM); see also [CVE-2020-10749](https://oreil.ly/CHK6q)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a basic idea of the potential threat model, let’s go through
    and see how the defaults can be exploited and defended against, in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic Flow Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen the networking defaults and what kind of communication paths are
    present in Kubernetes. In this section, we walk you through an end-to-end setup
    and show you how to secure the external traffic using network policies.
  prefs: []
  type: TYPE_NORMAL
- en: The Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate the networking defaults in action, let’s use [kind](https://oreil.ly/9KldR),
    a tool for running local Kubernetes clusters using Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `kind` cluster with networking prepared for Calico and enable
    Ingress (also see the [documentation](https://oreil.ly/H7dPf)). We are using the
    following config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Enable Ingress for cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Disable the native `kindnet`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In preparation to install Calico, set to its default subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the preceding YAML snippet is stored in a file called *cluster-config.yaml*,
    you can now create the `kind` cluster as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you do this the first time, the preceding output might look different
    and it can take several minutes to pull the respective container images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we install and patch Calico to make it work with `kind`. Kudos to Alex
    Brand for putting together the necessary [patch instructions](https://oreil.ly/qudSv):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And to verify if everything is up and running as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before we can deploy our app, we need one last bit of infrastructure in place,
    a load balancer, making the pods available to the outside world (your machine).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this we use [Ambassador](https://oreil.ly/fv4K2) as an ingress controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can launch the application, a web server. First off, we want to do all
    of the following in a dedicated namespace called `npdemo`, so let’s create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a YAML file called *workload.yaml* that defines a deployment,
    a service, and an ingress resource, in total representing our workload application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We configure the ingress in a way that if we hit the */api* URL path we expect
    it to route traffic to our `nginx` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you want to create the resources defined in *workload.yaml* by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you now try to access the app as exposed in the Ingress resource you should
    be able to do the following (note that we’re only counting the lines returned
    to verify we get something back):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Wait. What just happened? We put an Ingress in front of the NGINX service and
    it happily receives traffic from outside? That can’t be good.
  prefs: []
  type: TYPE_NORMAL
- en: Network Policies to the Rescue!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, how can we keep the Captain and their crew from getting their dirty paws
    on our cluster? [Network policies](https://oreil.ly/lIqM8) are coming to our rescue.
    While we will cover policies in a dedicated chapter (see [Chapter 8](ch08.xhtml#ch-policy)),
    we point out network policies and their usage here since they are so useful and,
    given the “by default all traffic is allowed” attitude of Kubernetes, one can
    argue almost necessary.
  prefs: []
  type: TYPE_NORMAL
- en: While Kubernetes allows you to define and apply network policies out-of-the-box,
    you need something that *enforces* the policies you define and that’s the job
    of a [provider](https://oreil.ly/4uK2d).
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the following walkthrough, we will be using [Calico](https://oreil.ly/zoAbv),
    however there are many more options available, such as the eBPF-based solutions
    discussed in [“eBPF”](#workload-networking-bpf).
  prefs: []
  type: TYPE_NORMAL
- en: 'We shut down all traffic with the following Kubernetes network policy in a
    file called, fittingly, *np-deny-all.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Selects the pods in the same namespace, in our case all.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Disallow any Ingress traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Network policies are notoriously difficult to get right, so in this context,
    you may want to check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: To help you edit and visualize network pollicies, check out the tool available
    from [networkpolicy.io](https://oreil.ly/6bTIb).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To debug network policy you can use [krew-net-forward](https://oreil.ly/2bk4K).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test policies, have a look at [netassert](https://oreil.ly/xvabI).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So let’s apply the preceding network policy and see if we can still access
    the app from outside of the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And this should fail now, based on our network policy (giving it a 3-second
    time out, just to be sure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you only have `kubectl` available, you can still make raw network requests,
    as [Rory McCune](https://oreil.ly/TDxaW) pointed out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it shouldn’t be in your container image in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: We hope by now you get an idea how dangerous the defaults are—all network traffic
    to and from pods is allowed—and how you can defend against it.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about network policies, including recipes, tips, and tricks, via
    the resources we put together in [Appendix B](app02.xhtml#appendix-resources).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to network policies, some cloud providers offer other native mechanisms
    to restrict traffic from/to pods; for example, see AWS [security groups for pods](https://oreil.ly/HWxpu).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, don’t forget to clean up your Kubernetes cluster using `kind delete
    cluster --name cnnp`, once you’re done exploring the topic of network policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve seen a concrete networking setup in action, let’s move on to
    a different topic: service meshes. This relatively recent technology can help
    you in addressing some of the not-so-secure defaults discussed earlier, including
    workload identity and encryption on the wire.'
  prefs: []
  type: TYPE_NORMAL
- en: Service Meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A somewhat advanced topic, a service mesh is in a sense complementary to Kubernetes
    and can be beneficial in a number of [use cases](https://oreil.ly/0GmzF). Let’s
    have a look at how the most important workload-level networking issues can be
    addressed using a service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A service mesh as conceptually shown in [Figure 5-4](#fig-networking-service-mesh-concept)
    is, as per its [creators](https://oreil.ly/Zo8Xk), a collection of userspace proxies
    in front of your apps along with a management process to configure said proxies.
  prefs: []
  type: TYPE_NORMAL
- en: '![Service mesh concept](Images/haku_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Service mesh concept
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The proxies are referred to as the service mesh’s *data plane*, and the management
    process as its *control plane*. The proxies intercept calls between services and
    do something interesting with or to these calls, such as disallowing a certain
    communication path or collecting metrics from the call. The control plane, on
    the other hand, coordinates the behavior of the proxies and provides the administrator
    an API.
  prefs: []
  type: TYPE_NORMAL
- en: Options and Uptake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, a number of [service meshes](https://oreil.ly/DeWKV)
    exist as well as proposed quasi-standards for interoperability, such as the CNCF
    project [Service Mesh Interface](https://oreil.ly/2s1H4) or work of the Envoy-based
    [Universal Data Plane API Working Group](https://oreil.ly/3xQ3m) (UDPA-WG).
  prefs: []
  type: TYPE_NORMAL
- en: 'While it is early days, we witness certain uptake, especially out of security
    considerations (see [Figure 5-5](#fig-networking-service-mesh-survey)). For example,
    The New Stack (TNS) reports in its 2020 [Service Mesh survey](https://oreil.ly/m0Kk7):'
  prefs: []
  type: TYPE_NORMAL
- en: A third of respondents’ organizations are using service meshes to control communications
    traffic between microservices in production Kubernetes environments. Another 34%
    use service mesh technology in a test environment, or are piloting or actively
    evaluating solutions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![TNS 2020 service mesh survey excerpt](Images/haku_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. TNS 2020 service mesh survey excerpt
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Going forward, many exciting application areas and nifty defense mechanisms
    based on service meshes are possible—for example, [Identity Federation for Multi-Cluster
    Kubernetes and Service Mesh](https://oreil.ly/WxRpf) or using [OPA in Istio](https://oreil.ly/2KacR).
    That said, many end users are not yet ready to go all in and/or are in a holding
    pattern, waiting for cloud and platform providers to make the data plane of the
    service mesh part of the underlying infrastructure. Alternatively, the data plane
    may be implemented on the operating system level, for example, using [eBPF](https://ebpf.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study: mTLS with Linkerd'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linkerd is a graduated CNCF project, originally created by Buoyant.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd [automatically enables](https://oreil.ly/vGiXq) mutual Transport Layer
    Security (mTLS) for most HTTP-based communication between meshed pods. Let’s see
    that in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along, [install Linkerd](https://oreil.ly/crGez) in a test cluster.
    We’re using `kind` in the following example and assume you have both the Kubernetes
    cluster set up and configured as well as the Linkerd CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know that we’re in a position to install Linkerd, let’s go ahead
    and do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally verify the install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Great! All up and running. You could have a quick look at the Linkerd dashboard
    using `linkerd dashboard &`, which should show something similar to what’s depicted
    in [Figure 5-6](#fig-networking-linkerd-dashboard).
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, back to mTLS: once we have enabled the mesh in the respective namespaces
    it should be impossible for us, even from within the cluster, to directly talk
    to a service using, say `curl`, and doing an HTTP query. Let’s see how that works.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we’re reusing the setup from [“Inter-Pod Traffic”](#workload-networking-inter-pod)
    but you can really use any workload that exposes an HTTP service within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '![Linkerd dashboard showing example traffic stats](Images/haku_0506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Linkerd dashboard showing example traffic stats
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'First, we need to enable the mesh, or meshify, as the good folks from Buoyant
    call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can [validate](https://oreil.ly/RsUhF) our mTLS setup using [tshark](https://oreil.ly/0JAvk)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the sample app is up and running we can use an remote shell into the attached
    debug container that Linkerd kindly put there for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to pod for interactive (terminal) use.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Provide pod name for the `exec` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Target the `linkerd-debug` container in the pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from within the debug container we use `tshark` to inspect the packets
    on the NIC and expect to see TLS traffic (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Listen on all available network interfaces for live packet capture.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Decode any traffic running over port `8080` as TLS.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring `127.0.0.1` (localhost) as this traffic will always be unencrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Yay, it works, encryption on the wire for free! And with this we’ve completed
    the mTLS case study.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about how to use service meshes to secure your East-West
    communication, we have put together some suggested further reading in [“Networking”](app02.xhtml#apx-networking)
    in [Appendix B](app02.xhtml#appendix-resources).
  prefs: []
  type: TYPE_NORMAL
- en: While service meshes certainly can help you with networking-related security
    challenges, fending off the Captain and their crew, you should be aware of weaknesses.
    For example, from Envoy-based systems, if you run a container with UID 1337, it
    bypasses the Istio/Envoy sidecar or, by default, the Envoy admin dashboard is
    accessible from within the container because it shares a network. For more background
    on this topic, check out the in-depth [Istio Security Assessment](https://oreil.ly/1LKUg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to move on to the last part of the workload networking topic:
    what happens on a single worker node.'
  prefs: []
  type: TYPE_NORMAL
- en: eBPF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the service mesh adventure, we focus our attention now on a topic that
    is on the one hand entirely of opposite character and on the other hand can also
    be viewed and understood to be used in the service mesh data plane. We have a
    look at eBPF, a modern and powerful way to extend the Linux kernel, and with it
    you can address a number of networking-related security challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally, this piece of Linux kernel technology was known under the name Berkeley
    Packet Filter (BPF). Then it experienced a number of enhancements, mainly dirven
    by Google, Facebook, and Netflix, and to distinguish it from the original implementation
    it was called [eBPF](https://oreil.ly/xIhBB). Nowadays, the kernel project and
    technology is commonly known as eBPF, which is a term in itself and does not stand
    for anything per se; that is, it’s not considered an acronym any longer.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, eBPF is a feature of the Linux kernel and you’ll need the Linux
    kernel version 3.18 or above to benefit from it. It enables you to safely and
    efficiently extend the Linux kernel functions by using the `bpf(2)` syscall (see
    also the [man pages](https://oreil.ly/YurzV) for details). eBPF is implemented
    as an in-kernel virtual machine using a custom 64-bit RISC instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 5-7](#fig-bpf-overview) you see a high-level overview taken from
    Brendan Gregg’s [*Linux Extended BPF (eBPF) Tracing Tools* (Addison-Wesley)](https://oreil.ly/n7jqx)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![eBPF overview in the Linux kernel](Images/haku_0507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. eBPF overview in the Linux kernel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This all looks promising, but is eBPF already used in the wild, and also, which
    options are available? Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Options and Uptake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 2021, eBPF is already used in a number of places and for use cases such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, as a CNI plug-in to enable, for example, pod networking in [Cilium](https://oreil.ly/mjYG3)
    and Project Calico, as well as for service scalability (in the context of `kube-proxy`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For observability, like for Linux kernel tracing such as with [iovisor/bpftrace](https://oreil.ly/Qk7G5)
    as well as in a clustered setup with [Hubble](https://oreil.ly/Pqzra)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a security control, for example to perform container runtime scanning as
    you can use with projects such as [CNCF Falco](https://falco.org), but also for
    enforcing network policies in Kubernetes (via Cilium, Calico, etc.) as discussed
    in [“Traffic Flow Control”](#workload-network-policies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network load balancing like Facebook’s L4 [katran](https://oreil.ly/csPLr) library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low-level intrusion detection systems (IDS) for Kubernetes (see [Chapter 9](ch09.xhtml#ch-intrusion-detection)
    for details)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We see an increasing number of players entering the eBPF field and leading
    the charge is [Isovalent](https://isovalent.com). While it’s still early days
    from an adoption perspective, eBPF has a huge potential. Coming back to the service
    mesh data plane: it is perfectly doable and thinkable to implement the Envoy APIs
    as a set of eBPF programs and push the handling from user space sidecar proxy
    into the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Extending the kernel with userspace programs sounds interesting, but how does
    that look, in practice?
  prefs: []
  type: TYPE_NORMAL
- en: 'Case Study: Attaching a Probe to a Go Program'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s have a look at an example from the [Cilium](https://oreil.ly/MPvHJ) project.
    The following is a Go program available in [main.go](https://oreil.ly/I0L8S) and
    demonstrates how you can attach an eBPF program (written in C) to a kernel symbol.
    The overall result of the exercise is that whenever the `sys_execve` syscall is
    invoked, a kernel counter is increased, which the Go program then reads and prints
    out the number of times the probed symbol has been called per second.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line in *main.go* (edited to fit the page; should all be on the
    same line) instructs the Go toolchain to include the compiled C program that contains
    our eBPF code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In [kprobe_example.c](https://oreil.ly/BmGIb) we find the eBPF program itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_networking_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: You must define a license.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_networking_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Enables exchange of data between kernel and userspace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_networking_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The entry point of our eBPF probe (program).
  prefs: []
  type: TYPE_NORMAL
- en: As you can guess, writing eBPF by hand is not fun. Luckily there are a number
    of great tools and environments available that take care of the low-level stuff
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just as we were wrapping up the book writing, the Linux Foundation announced
    that Facebook, Google, Isovalent, Microsoft, and Netflix joined together to [create
    the eBPF Foundation](https://oreil.ly/9JkNz), and with it giving the eBPF project
    a vendor-neutral home. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: To dive deeper into the eBPF topic we suggest you read [*Linux Observability
    with BPF*](https://oreil.ly/jbERf) by David Calavera and Lorenzo Fontana (O’Reilly).
    If you’re looking for a quick overview, Matt Oswalt has a nice [Introduction to
    eBPF](https://oreil.ly/kROpT).
  prefs: []
  type: TYPE_NORMAL
- en: To stay on top of things, have a look at [ebpf.io](https://ebpf.io) and check
    out what the community publishes on the [YouTube channel](https://oreil.ly/wfFnN)
    for this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Further, have a look at [Pixie](https://px.dev), an open source, eBPF-based
    observability tool with an active community and broad industry support (see [Figure 5-8](#fig-pixie-example)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Pixie in action](Images/haku_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Pixie in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Summing up, there are a number of defaults in the Kubernetes networking space
    you want to be aware of. As a baseline, you can apply the good practices you know
    from a noncontainerized environment in combination with intrusion detection tooling
    as shown in [Chapter 9](ch09.xhtml#ch-intrusion-detection). In addition, you want
    to use native resources such as network policies potentially in combination with
    other CNCF projects such as SPIFFE for workload identity to strengthen your security
    posture.
  prefs: []
  type: TYPE_NORMAL
- en: Service meshes, while still in the early days, are another promising option
    to enforce policies and gain insights into what is going on. Last but not least,
    eBPF is the up and coming star in the networking arena, enabling a number of security-related
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the networking secured, we are ready for the Captain to move
    on to more “solid” grounds: storage.'
  prefs: []
  type: TYPE_NORMAL
