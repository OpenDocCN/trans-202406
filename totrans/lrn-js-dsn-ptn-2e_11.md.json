["```\nconst myUniqueApplication = (() => {\n  function myMethod() {\n    // code\n    return;\n  }\n\n  return {\n    myMethod,\n  };\n})();\n\n// Usage\nmyUniqueApplication.myMethod();\n\n// In this updated example, we use an immediately invoked function expression\n// (IIFE) to create a unique namespace for our application, which is stored in\n// the myUniqueApplication variable. The IIFE returns an object with functions\n// and properties, and we can access these using dot notation\n// (e.g., myUniqueApplication.myMethod()).\n```", "```\nconst myApplication_propertyA = {};\nconst myApplication_propertyB = {};\nfunction myApplication_myMethod(){   //...\n}\n```", "```\nconst myApplication = {\n\n    // As we've seen, we can easily define functionality for\n    // this object literal...\n    getInfo() {\n      //...\n    },\n\n    // but we can also populate it to support\n    // further object namespaces containing anything\n    // anything we wish:\n    models : {},\n    views : {\n        pages : {}\n    },\n    collections : {}\n};\n```", "```\nmyApplication.foo = () => \"bar\"\n\nmyApplication.utils = {\n    toString() {\n        //...\n    },\n    export() {\n        //...\n    }\n}\n```", "```\n// This doesn't check for existence of \"myApplication\" in\n// the global namespace. Bad practice as we can easily\n// clobber an existing variable/namespace with the same name\nconst myApplication = {};\n\n// The following options *do* check for variable/namespace existence.\n// If already defined, we use that instance, otherwise we assign a new\n// object literal to myApplication.\n//\n// Option 1: var myApplication = myApplication || {};\n// Option 2  if( !MyApplication ){ MyApplication = {} };\n// Option 3: window.myApplication || ( window.myApplication = {} );\n// Option 4: var myApplication = $.fn.myApplication = function() {};\n// Option 5: var myApplication = myApplication === undefined ? {} :\n// myApplication;\n```", "```\nmyApplication || (myApplication = {});\n```", "```\nfunction foo() {\n  myApplication || ( myApplication = {} );\n}\n\n// myApplication hasn't been initialized,\n// so foo() throws a ReferenceError\n\nfoo();\n\n// However accepting myApplication as an\n// argument\n\nfunction foo( myApplication ) {\n  myApplication || ( myApplication = {} );\n}\n\nfoo();\n\n// Even if myApplication === undefined, there is no error\n// and myApplication gets set to {} correctly\n```", "```\n// If we were to define a new plug-in...\nvar myPlugin = $.fn.myPlugin = function() { ... };\n\n// Then later rather than having to type:\n$.fn.myPlugin.defaults = {};\n\n// We can do:\nmyPlugin.defaults = {};\n```", "```\nconst namespace = (() => {\n    // defined within the local scope\n    const privateMethod1 = () => { /* ... */ };\n\n    const privateMethod2 = () => { /* ... */ };\n    privateProperty1 = \"foobar\";\n\n    return {\n\n        // the object literal returned here can have as many\n        // nested depths as we wish; however, as mentioned,\n        // this way of doing things works best for smaller,\n        // limited-scope applications in my personal opinion\n        publicMethod1: privateMethod1,\n\n        // nested namespace with public properties\n        properties:{\n            publicProperty1: privateProperty1\n        },\n\n        // another tested namespace\n        utils:{\n            publicMethod2: privateMethod2\n        }\n        ...\n    }\n})();\n```", "```\nconst myConfig = {\n\n    language: \"english\",\n\n    defaults: {\n        enableGeolocation: true,\n        enableSharing: false,\n        maxPhotos: 20\n    },\n\n    theme: {\n        skin: \"a\",\n        toolbars: {\n            index: \"ui-navigation-toolbar\",\n            pages: \"ui-custom-toolbar\"\n        }\n    }\n\n};\n```", "```\nYAHOO.util.Dom.getElementsByClassName(\"test\");\n```", "```\nconst myApp =  myApp || {};\n\n// perform a similar existence check when defining nested\n// children\nmyApp.routers = myApp.routers || {};\nmyApp.model = myApp.model || {};\nmyApp.model.special = myApp.model.special || {};\n\n// nested namespaces can be as complex as required:\n// myApp.utilities.charting.html5.plotGraph(/*..*/);\n// myApp.modules.financePlanner.getSummary();\n// myApp.services.social.facebook.realtimeStream.getLatest();\n```", "```\nmyApp[\"routers\"] = myApp[\"routers\"] || {};\nmyApp[\"models\"] = myApp[\"models\"] || {};\nmyApp[\"controllers\"] = myApp[\"controllers\"] || {};\n```", "```\n// an (anonymous) immediately invoked function expression\n(() => { /*...*/})();\n\n// a named immediately invoked function expression\n(function foobar () { /*..*/}());\n\n// this is technically a self-executing function which is quite different\nfunction foobar () { foobar(); }\n```", "```\nconst namespace = namespace || {};\n\n// here a namespace object is passed as a function\n// parameter, where we assign public methods and\n// properties to it\n(o => {\n    o.foo = \"foo\";\n    o.bar = () => \"bar\";\n})(namespace);\n\nconsole.log( namespace );\n```", "```\n// namespace (our namespace name) and undefined are passed here\n// to ensure: 1\\. namespace can be modified locally and isn't\n// overwritten outside of our function context;\n// 2\\. the value of undefined is guaranteed as being truly\n// undefined. This is to avoid issues with undefined being\n// mutable pre-ES5.\n\n;((namespace, undefined) => {\n    // private properties\n    const foo = \"foo\";\n\n    const bar = \"bar\";\n\n    // public methods and properties\n    namespace.foobar = \"foobar\";\n    namespace.sayHello = () => {\n        speak( \"hello world\" );\n    };\n\n    // private method\n    function speak(msg) {\n        console.log( `You said: ${msg}` );\n    };\n\n    // check to evaluate whether \"namespace\" exists in the\n    // global namespace - if not, assign window.namespace an\n    // object literal\n})(window.namespace = window.namespace || {});\n\n// we can then test our properties and methods as follows\n\n// public\n\n// Outputs: foobar\nconsole.log( namespace.foobar );\n\n// Outputs: hello world\nnamespace.sayHello();\n\n// assigning new properties\nnamespace.foobar2 = \"foobar\";\n\n// Outputs: foobar\nconsole.log( namespace.foobar2 );\n```", "```\n// let's extend the namespace with new functionality\n((namespace, undefined) => {\n\n    // public method\n    namespace.sayGoodbye = () => {\n        console.log( namespace.foo );\n        console.log( namespace.bar );\n        speak( \"goodbye\" );\n    }\n})(window.namespace = window.namespace || {});\n\n// Outputs: goodbye\nnamespace.sayGoodbye();\n```", "```\nconst myApp = myApp || {};\nmyApp.utils =  {};\n\n(function () {\n  let val = 5;\n\n  this.getValue = () => val;\n\n  this.setValue = newVal => {\n      val = newVal;\n  }\n\n  // also introduce a new subnamespace\n  this.tools = {};\n\n}).apply( myApp.utils );\n\n// inject new behavior into the tools namespace\n// which we defined via the utilities module\n\n(function () {\n    this.diagnose = () => \"diagnosis\"\n}).apply( myApp.utils.tools );\n\n// note, this same approach to extension could be applied\n// to a regular IIFE, by just passing in the context as\n// an argument and modifying the context rather than just\n// \"this\"\n\n// Usage:\n\n// Outputs our populated namespace\nconsole.log( myApp );\n\n// Outputs: 5\nconsole.log( myApp.utils.getValue() );\n\n// Sets the value of `val` and returns it\nmyApp.utils.setValue( 25 );\nconsole.log( myApp.utils.getValue() );\n\n// Testing another level down\nconsole.log( myApp.utils.tools.diagnose() );\n```", "```\n// define a namespace we can use later\nconst ns = ns || {};\n\nconst ns2 = ns2 || {};\n\n// the module/namespace creator\nconst creator = function( val ){\n\n    var val = val || 0;\n\n    this.next = () => val++;\n\n    this.reset = () => {\n        val = 0;\n    }\n};\n\ncreator.call( ns );\n\n// ns.next, ns.reset now exist\ncreator.call( ns2 , 5000 );\n\n// ns2 contains the same methods\n// but has an overridden value for val\n// of 5000\n```", "```\nconst application = {\n      utilities:{\n          drawing:{\n              canvas:{\n                  paint:{\n                          //...\n                  }\n              }\n          }\n    }\n};\n```", "```\n// top-level namespace being assigned an object literal\nconst myApp = {};\n\n// a convenience function for parsing string namespaces and\n// automatically generating nested namespaces\nfunction extend( ns, ns_string ) {\n    const parts = ns_string.split(\".\");\n    let parent = ns;\n    let pl;\n\n    pl = parts.length;\n\n    for ( let i = 0; i < pl; i++ ) {\n        // create a property if it doesn't exist\n        if ( typeof parent[parts[i]] === \"undefined\" ) {\n            parent[parts[i]] = {};\n        }\n\n        parent = parent[parts[i]];\n    }\n\n    return parent;\n}\n\n// Usage:\n// extend myApp with a deeply nested namespace\nconst mod = extend(myApp, \"modules.module2\");\n\n// the correct object with nested depths is output\nconsole.log(mod);\n\n// minor test to check the instance of mod can also\n// be used outside of the myApp namespace as a clone\n// that includes the extensions\n\n// Outputs: true\nconsole.log(mod == myApp.modules.module2);\n\n// further demonstration of easier nested namespace\n// assignment using extend\nextend(myApp, \"moduleA.moduleB.moduleC.moduleD\");\nextend(myApp, \"longer.version.looks.like.this\");\nconsole.log(myApp);\n```", "```\n// common approach to accessing nested namespaces\nmyApp.utilities.math.fibonacci( 25 );\nmyApp.utilities.math.sin( 56 );\nmyApp.utilities.drawing.plot( 98,50,60 );\n\n// with local/cached references\nconst utils = myApp.utilities;\n\nconst maths = utils.math;\nconst drawing = utils.drawing;\n\n// easier to access the namespace\nmaths.fibonacci( 25 );\nmaths.sin( 56 );\ndrawing.plot( 98, 50,60 );\n\n// note that this is particularly performant when\n// compared to hundreds or thousands of calls to nested\n// namespaces vs. a local reference to the namespace\n```", "```\n// Deep object extension using Object.assign and recursion\nfunction extendObjects(destinationObject, sourceObject) {\n  for (const property in sourceObject) {\n    if (\n      sourceObject[property] &&\n      typeof sourceObject[property] === \"object\" &&\n      !Array.isArray(sourceObject[property])\n    ) {\n      destinationObject[property] = destinationObject[property] || {};\n      extendObjects(destinationObject[property], sourceObject[property]);\n    } else {\n      destinationObject[property] = sourceObject[property];\n    }\n  }\n  return destinationObject;\n}\n\n// Example usage\nconst myNamespace = myNamespace || {};\n\nextendObjects(myNamespace, {\n  utils: {},\n});\n\nconsole.log(\"test 1\", myNamespace);\n\nextendObjects(myNamespace, {\n  hello: {\n    world: {\n      wave: {\n        test() {\n          // ...\n        },\n      },\n    },\n  },\n});\n\nmyNamespace.hello.test1 = \"this is a test\";\nmyNamespace.hello.world.test2 = \"this is another test\";\nconsole.log(\"test 2\", myNamespace);\n\nmyNamespace.library = {\n  foo() {},\n};\n\nextendObjects(myNamespace, {\n  library: {\n    bar() {\n      // ...\n    },\n  },\n});\n\nconsole.log(\"test 3\", myNamespace);\n\nconst shorterNamespaceAccess = myNamespace.hello.world;\nshorterNamespaceAccess.test3 = \"hello again\";\nconsole.log(\"test 4\", myNamespace);\n```", "```\n// top-level namespace\nconst myApplication = myApplication || {};\n\n// directly assign a nested namespace\nmyApplication.library = {\n  foo() {\n    // ...\n  },\n};\n\n// deep extend/merge this namespace with another\n// to make things interesting, let's say it's a namespace\n// with the same name but with a different function\n// signature: $.extend( deep, target, object1, object2 )\n$.extend(true, myApplication, {\n  library: {\n    bar() {\n      // ...\n    },\n  },\n});\n\nconsole.log(\"test\", myApplication);\n```"]