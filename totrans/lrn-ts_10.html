<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Classes"><div class="chapter" id="classes">
<h1><span class="label">Chapter 8. </span>Classes</h1>

<blockquote>
<p>Some functional devs</p>

<p>Try to <em>never</em> use classes</p>

<p>Too intense for me</p></blockquote>

<p>The world of JavaScript during TypeScript’s creation and release in the early 2010s was quite different from today.
Features such as arrow functions and <code>let</code>/<code>const</code> variables that would later be standardized in ES2015 were still distant hopes on the horizon.
Babel was a few years away from its first commit; its predecessor tools such as Traceur that converted newer JavaScript syntax to old hadn’t achieved full mainstream adoption.</p>

<p>TypeScript’s early marketing and feature set were tailored to that world.
In addition to its type checking, its transpiler was emphasized—with classes as a frequent example.
Nowadays TypeScript’s class support is just one feature among many to support all JavaScript language features.
TypeScript neither encourages nor discourages class use or any other popular JavaScript pattern.</p>






<section data-type="sect1" data-pdf-bookmark="Class Methods"><div class="sect1" id="idm45584683358352">
<h1>Class Methods</h1>

<p>TypeScript<a data-type="indexterm" data-primary="classes" data-secondary="methods of" id="class-method"/><a data-type="indexterm" data-primary="methods" data-secondary="of classes" data-tertiary="described" data-secondary-sortas="classes" id="method-class"/> generally understands methods the same way it understands standalone functions.
Parameter types default to <code>any</code> unless given a type or default value; calling the method requires an acceptable number of arguments; return types can generally be inferred if the function is not recursive.</p>

<p>This code snippet defines a <code>Greeter</code> class with a <code>greet</code> class method that takes in a single required parameter of type <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Greeter</code> <code class="p">{</code>
    <code class="nx">greet</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">, do your stuff!`</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">Greeter</code><code class="p">().</code><code class="nx">greet</code><code class="p">(</code><code class="s2">"Miss Frizzle"</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="k">new</code> <code class="nx">Greeter</code><code class="p">().</code><code class="nx">greet</code><code class="p">();</code>
<code class="c1">//            ~~~~~</code>
<code class="c1">// Error: Expected 1 arguments, but got 0.</code></pre>

<p>Class constructors <a data-type="indexterm" data-primary="classes" data-secondary="constructors" data-tertiary="parameters" id="idm45584683243664"/><a data-type="indexterm" data-primary="constructors (of classes)" data-secondary="parameters" id="idm45584683298864"/><a data-type="indexterm" data-primary="parameters" data-secondary="class constructors" id="idm45584683297952"/>are treated like typical class methods with regards to their parameters.
TypeScript will perform type checking to make sure a correct number of arguments with correct types are provided to method calls.</p>

<p>This <code>Greeted</code> constructor also expects its <code>message: string</code> parameter to be 
<span class="keep-together">provided:</span></p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Greeted</code> <code class="p">{</code>
    <code class="kr">constructor</code><code class="p">(</code><code class="nx">message</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`As I always say: </code><code class="si">${</code><code class="nx">message</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">Greeted</code><code class="p">(</code><code class="s2">"take chances, make mistakes, get messy"</code><code class="p">);</code>

<code class="k">new</code> <code class="nx">Greeted</code><code class="p">();</code>
<code class="c1">// Error: Expected 1 arguments, but got 0.</code></pre>

<p>I’ll cover constructors in the context of subclasses later in this <a data-type="indexterm" data-primary="classes" data-secondary="methods of" data-startref="class-method" id="idm45584683231696"/><a data-type="indexterm" data-primary="methods" data-secondary="of classes" data-tertiary="described" data-secondary-sortas="classes" data-startref="method-class" id="idm45584683195360"/>chapter.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Class Properties"><div class="sect1" id="idm45584683193376">
<h1>Class Properties</h1>

<p>To <a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="declaring" id="class-property-declare"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="declaring" data-secondary-sortas="classes" id="property-class-declare"/><a data-type="indexterm" data-primary="declaring" data-secondary="properties of classes" id="declare-property-class"/>read from or write to a property on a class in TypeScript, it must be explicitly declared in the class.
Class properties are declared using the same syntax as interfaces: their name followed optionally by a type annotation.</p>

<p>TypeScript will not attempt to deduce what members may exist on a class from their assignments in a constructor.</p>

<p>In this example, <code>destination</code> is allowed to be assigned to and accessed on instances of the <code>FieldTrip</code> class because it is explicitly declared as a <code>string</code>.
The 
<span class="keep-together"><code>this.nonexistent</code></span> assignment in the constructor is not allowed because the class does not declare a <code>nonexistent</code> property:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">FieldTrip</code> <code class="p">{</code>
    <code class="nx">destination</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">destination</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">destination</code> <code class="o">=</code> <code class="nx">destination</code><code class="p">;</code> <code class="c1">// Ok</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`We're going to </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">destination</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>

        <code class="k">this</code><code class="p">.</code><code class="nx">nonexistent</code> <code class="o">=</code> <code class="nx">destination</code><code class="p">;</code>
        <code class="c1">//   ~~~~~~~~~~~</code>
        <code class="c1">// Error: Property 'nonexistent' does not exist on type 'FieldTrip'.</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Explicitly declaring class properties allows TypeScript to quickly understand what is or is not allowed to exist on instances of classes.
Later, when class instances are in use, TypeScript uses that understanding to give a type error if code attempts to access a member of a class instance not known to exist, such as with this<a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="declaring" data-startref="class-property-declare" id="idm45584683163680"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="declaring" data-secondary-sortas="classes" data-startref="property-class-declare" id="idm45584683155376"/><a data-type="indexterm" data-primary="declaring" data-secondary="properties of classes" data-startref="declare-property-class" id="idm45584683153616"/> continuation’s <code>trip.nonexistent</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">trip</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">FieldTrip</code><code class="p">(</code><code class="s2">"planetarium"</code><code class="p">);</code>

<code class="nx">trip</code><code class="p">.</code><code class="nx">destination</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">trip</code><code class="p">.</code><code class="nx">nonexistent</code><code class="p">;</code>
<code class="c1">//   ~~~~~~~~~~~</code>
<code class="c1">// Error: Property 'nonexistent' does not exist on type 'FieldTrip'.</code></pre>








<section data-type="sect2" data-pdf-bookmark="Function Properties"><div class="sect2" id="idm45584683089216">
<h2>Function Properties</h2>

<p>Let’s <a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="as functions" data-tertiary-sortas="functions" id="class-property-function"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="as functions" data-secondary-sortas="classes" data-tertiary-sortas="functions" id="property-class-function"/><a data-type="indexterm" data-primary="functions" data-secondary="of classes, properties as" data-secondary-sortas="classes" id="function-class-property"/>recap some JavaScript method scoping and syntax fundamentals for a bit, as they can be surprising if you’re not accustomed to them.
JavaScript contains two syntaxes for declaring a member on a class to be a callable function: <em>method</em> and <em>property</em>.</p>

<p>I’ve already shown the method approach of putting parentheses after the member name, like <code>myFunction() {}</code>.
The method approach assigns a function to the class prototype, so all class instances use the same function definition.</p>

<p>This <code>WithMethod</code> class declares a <code>myMethod</code> method that all instances are able to refer to:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">WithMethod</code> <code class="p">{</code>
    <code class="nx">myMethod() {</code><code class="p">}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">WithMethod</code><code class="p">().</code><code class="nx">myMethod</code> <code class="o">===</code> <code class="k">new</code> <code class="nx">WithMethod</code><code class="p">().</code><code class="nx">myMethod</code><code class="p">;</code> <code class="c1">// true</code></pre>

<p>The other syntax is to declare a property whose value happens to be a function.
This creates a new function per instance of the class, which can be useful with <code>() =&gt;</code> arrow functions whose <code>this</code> scope should always point to the class instance (at the time and memory cost of creating a new function per class instance).</p>

<p>This <code>WithProperty</code> class contains a single property of name <code>myProperty</code> and type <code>() =&gt; void</code> that will be re-created for each class instance:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">WithProperty</code> <code class="p">{</code>
    <code class="nx">myProperty</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">WithMethod</code><code class="p">().</code><code class="nx">myProperty</code> <code class="o">===</code> <code class="k">new</code> <code class="nx">WithMethod</code><code class="p">().</code><code class="nx">myProperty</code><code class="p">;</code> <code class="c1">// false</code></pre>

<p class="less_space pagebreak-before">Function properties can be given parameters and return types using the same syntax as class methods and standalone functions.
After all, they’re a value assigned to a class member and the value happens to be a function.</p>

<p>This <code>WithPropertyParameters</code> class has a <code>takesParameters</code> property of<a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="as functions" data-tertiary-sortas="functions" data-startref="class-property-function" id="idm45584682955216"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="as functions" data-secondary-sortas="classes" data-tertiary-sortas="functions" data-startref="property-class-function" id="idm45584682953392"/><a data-type="indexterm" data-primary="functions" data-secondary="of classes, properties as" data-secondary-sortas="classes" data-startref="function-class-property" id="idm45584682951360"/> type <code>(input: string) =&gt; number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">WithPropertyParameters</code> <code class="p">{</code>
    <code class="nx">takesParameters</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code> <code class="o">?</code> <code class="s2">"Yes"</code> <code class="o">:</code> <code class="s2">"No"</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">instance</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">WithPropertyParameters</code><code class="p">();</code>

<code class="nx">instance</code><code class="p">.</code><code class="nx">takesParameters</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">instance</code><code class="p">.</code><code class="nx">takesParameters</code><code class="p">(</code><code class="mi">123</code><code class="p">);</code>
<code class="c1">//                       ~~~</code>
<code class="c1">// Error: Argument of type 'number' is not</code>
<code class="c1">// assignable to parameter of type 'boolean'.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Initialization Checking"><div class="sect2" id="idm45584683080240">
<h2>Initialization Checking</h2>

<p>With<a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="initialization checking" id="class-property-initial"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="initialization checking" data-secondary-sortas="classes" id="property-class-initial"/><a data-type="indexterm" data-primary="initialization checking of class properties" id="initial-class-property"/> strict compiler settings enabled, TypeScript will check that each property declared whose type does not include <code>undefined</code> is assigned a value in the constructor.
This strict initialization checking is useful because it prevents code from accidentally forgetting to assign a value to a class property.</p>

<p>The following <code>WithValue</code> class does not assign a value to its <code>unused</code> property, which TypeScript recognizes as a type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">WithValue</code> <code class="p">{</code>
    <code class="nx">immediate</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="c1">// Ok</code>
    <code class="nx">later</code>: <code class="nx">number</code><code class="p">;</code> <code class="c1">// Ok (set in the constructor)</code>
    <code class="nx">mayBeUndefined</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code> <code class="c1">// Ok (allowed to be undefined)</code>

    <code class="nx">unused</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="c1">// Error: Property 'unused' has no initializer</code>
    <code class="c1">// and is not definitely assigned in the constructor.</code>

    <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">later</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Without strict initialization checking, a class instance could be allowed to access a value that might be <code>undefined</code> even though the type system says it can’t be.</p>

<p>This example would compile happily if strict initialization checking didn’t happen, but the resultant JavaScript would crash at runtime:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">class</code> <code class="nx">MissingInitializer</code> <code class="p">{</code>
    <code class="nx">property</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">MissingInitializer</code><code class="p">().</code><code class="nx">property</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="c1">// TypeError: Cannot read property 'length' of undefined</code></pre>

<p>The billion-dollar mistake strikes again!</p>

<p>Configuring strict property initialization checking with TypeScript’s 
<span class="keep-together"><code>strictPropertyInitialization</code></span> compiler option is covered<a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="initialization checking" data-startref="class-property-initial" id="idm45584682823888"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="initialization checking" data-secondary-sortas="classes" data-startref="property-class-initial" id="idm45584682778592"/><a data-type="indexterm" data-primary="initialization checking of class properties" data-startref="initial-class-property" id="idm45584682776832"/> in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch12.xhtml#using_ide_features">Chapter 12, “Using IDE Features”</a>.</p>










<section data-type="sect3" data-pdf-bookmark="Definitely assigned properties"><div class="sect3" id="idm45584682774432">
<h3>Definitely assigned properties</h3>

<p>Although<a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="disabling initialization checking" id="idm45584682772640"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="disabling initialization checking" data-secondary-sortas="classes" id="idm45584682771392"/><a data-type="indexterm" data-primary="disabling initialization checking" id="idm45584682769936"/><a data-type="indexterm" data-primary="! (exclamation point)" data-secondary="disabling initialization checking" id="idm45584682769296"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="disabling initialization checking" id="idm45584682768336"/> strict initialization checking is useful most of the time, you may come across some cases where a class property is intentionally able to be unassigned after the class constructor.
If you are absolutely sure a property should not have strict initialization checking applied to it, you can add a <code>!</code> after its name to disable the check.
Doing so asserts to TypeScript that the property will be assigned a value other than <code>undefined</code> before its first usage.</p>

<p>This <code>ActivitiesQueue</code> class is meant to be re-initialized any number of times separately from its constructor, so its <code>pending</code> property must be asserted with a <code>!</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">ActivitiesQueue</code> <code class="p">{</code>
    <code class="nx">pending</code><code class="o">!:</code> <code class="kt">string</code><code class="p">[];</code> <code class="c1">// Ok</code>

    <code class="nx">initialize</code><code class="p">(</code><code class="nx">pending</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">pending</code> <code class="o">=</code> <code class="nx">pending</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">next() {</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">pending</code><code class="p">.</code><code class="nx">pop</code><code class="p">();</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">activities</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ActivitiesQueue</code><code class="p">();</code>

<code class="nx">activities</code><code class="p">.</code><code class="nx">initialize</code><code class="p">([</code><code class="s1">'eat'</code><code class="p">,</code> <code class="s1">'sleep'</code><code class="p">,</code> <code class="s1">'learn'</code><code class="p">])</code>
<code class="nx">activities</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Needing to disable strict initialization checking on a class property is often a sign of code being set up in a way that doesn’t lend itself well to type checking.
Instead of adding a <code>!</code> assertion and reducing type safety for the property, consider refactoring the class to no longer need the assertion.</p>
</div>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Optional Properties"><div class="sect2" id="idm45584682886976">
<h2>Optional Properties</h2>

<p>Much <a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="optional" id="class-property-optional"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="optional" data-secondary-sortas="classes" id="property-class-optional"/><a data-type="indexterm" data-primary="optional properties" data-secondary="of classes" data-secondary-sortas="classes" id="optional-property-class"/>like interfaces, classes in TypeScript may declare a property as optional by adding a <code>?</code> after its declaration name.
Optional properties behave roughly the same as properties whose types happen to be a union that includes <code>| undefined</code>.
Strict initialization checking won’t mind if they’re not explicitly set in their constructor.</p>

<p>This <code>OptionalProperty</code> class marks its <code>property</code> as optional, so it’s allowed to not be assigned in the class constructor regardless of strict property initialization checking:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">MissingInitializer</code> <code class="p">{</code>
    <code class="nx">property?</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">MissingInitializer</code><code class="p">().</code><code class="nx">property</code><code class="o">?</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="k">new</code> <code class="nx">MissingInitializer</code><code class="p">().</code><code class="nx">property</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="c1">// Error: Object is possibly 'undefined'.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Read-Only Properties"><div class="sect2" id="idm45584682634048">
<h2>Read-Only Properties</h2>

<p>Again <a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="read-only" id="class-property-readonly"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="read-only" data-secondary-sortas="classes" id="property-class-readonly"/><a data-type="indexterm" data-primary="read-only properties" data-secondary="of classes" data-secondary-sortas="classes" id="readonly-property-class"/>much like interfaces, classes in TypeScript may declare a property as read-only by adding the <code>readonly</code> keyword before its declaration name.
The <code>readonly</code> keyword exists purely within the type system and is removed when compiling to JavaScript.</p>

<p>Properties declared as <code>readonly</code> may only be assigned initial values where they are declared or in a constructor.
Any other location—including methods on the class itself—may only read from the properties, not write to them.</p>

<p>In this example, the <code>text</code> property on the <code>Quote</code> class is given a value in the constructor, but the other uses cause type errors:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Quote</code> <code class="p">{</code>
    <code class="nx">readonly</code> <code class="nx">text</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">text</code> <code class="o">=</code> <code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">emphasize() {</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">text</code> <code class="o">+=</code> <code class="s2">"!"</code><code class="p">;</code>
        <code class="c1">//   ~~~~</code>
        <code class="c1">// Error: Cannot assign to 'text' because it is a read-only property.</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">quote</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Quote</code><code class="p">(</code>
    <code class="s2">"There is a brilliant child locked inside every student."</code>
<code class="p">);</code>

<code class="nx">Quote</code><code class="p">.</code><code class="nx">text</code> <code class="o">=</code> <code class="s2">"Ha!"</code><code class="p">;</code>
<code class="c1">// Error: Cannot assign to 'text' because it is a read-only property.</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>External users of your code, such as consumers of any npm packages you published, might not respect <code>readonly</code> modifiers—especially if they’re writing JavaScript and don’t have type checking.
If you need true read-only protection, consider using <code>#</code> private fields and/or <code>get()</code> function properties.</p>
</div>

<p>Properties <a data-type="indexterm" data-primary="narrowing" data-secondary="class properties" id="idm45584682540528"/><a data-type="indexterm" data-primary="widening class properties" id="idm45584682504816"/>declared as <code>readonly</code> with an initial value of a primitive have a slight quirk compared to other properties: they are inferred to be their value’s narrowed <em>literal</em> type if possible, rather than the wider <em>primitive</em>.
TypeScript feels comfortable with a more aggressive initial type narrowing because it knows the value won’t be changed later; it is similar to <code>const</code> variables taking on narrower types than <code>let</code> variables.</p>

<p>In this example, the class properties are both initially declared as a string literal, so in order to widen one of them to <code>string</code>, a type annotation is needed:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">RandomQuote</code> <code class="p">{</code>
    <code class="nx">readonly</code> <code class="nx">explicit</code>: <code class="nx">string</code> <code class="o">=</code> <code class="s2">"Home is the nicest word there is."</code><code class="p">;</code>
    <code class="nx">readonly</code> <code class="nx">implicit</code> <code class="o">=</code> <code class="s2">"Home is the nicest word there is."</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code> <code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">explicit</code> <code class="o">=</code> <code class="s2">"We start learning the minute we're born."</code> <code class="c1">// Ok;</code>

            <code class="k">this</code><code class="p">.</code><code class="nx">implicit</code> <code class="o">=</code> <code class="s2">"We start learning the minute we're born."</code><code class="p">;</code>
            <code class="c1">// Error: Type '"We start learning the minute we're born."' is</code>
            <code class="c1">// not assignable to type '"Home is the nicest word there is."'.</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">quote</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">RandomQuote</code><code class="p">();</code>

<code class="nx">quote</code><code class="p">.</code><code class="nx">explicit</code><code class="p">;</code> <code class="c1">// Type: string</code>
<code class="nx">quote</code><code class="p">.</code><code class="nx">implicit</code><code class="p">;</code> <code class="c1">// Type: "Home is the nicest word there is."</code></pre>

<p>Widening a property’s type explicitly is not necessary very often.
Still, it can sometimes be useful in the case of conditional logic in constructors like the one<a data-type="indexterm" data-primary="classes" data-secondary="properties" data-tertiary="read-only" data-startref="class-property-readonly" id="idm45584682485152"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="read-only" data-secondary-sortas="classes" data-startref="property-class-readonly" id="idm45584682458000"/><a data-type="indexterm" data-primary="read-only properties" data-secondary="of classes" data-secondary-sortas="classes" data-startref="readonly-property-class" id="idm45584682456240"/> in <code>RandomQuote</code>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Classes as Types"><div class="sect1" id="idm45584683192880">
<h1>Classes as Types</h1>

<p>Classes <a data-type="indexterm" data-primary="classes" data-secondary="as types" data-secondary-sortas="types" id="class-type"/><a data-type="indexterm" data-primary="types" data-secondary="classes as" id="type-class"/>are relatively unique in the type system in that a class declaration creates both a runtime value—the class itself—as well as a type that can be used in type annotations.</p>

<p>The name of this <code>Teacher</code> class is used to annotate a <code>teacher</code> variable, telling TypeScript that it should be assigned only values that are assignable to the <code>Teacher</code> class—such as instances of the <code>Teacher</code> class itself:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Teacher</code> <code class="p">{</code>
    <code class="nx">sayHello() {</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Take chances, make mistakes, get messy!"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">teacher</code>: <code class="nx">Teacher</code><code class="p">;</code>

<code class="nx">teacher</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Teacher</code><code class="p">();</code> <code class="c1">// Ok</code>

<code class="nx">teacher</code> <code class="o">=</code> <code class="s2">"Wahoo!"</code><code class="p">;</code>
<code class="c1">// Error: Type 'string' is not assignable to type 'Teacher'.</code></pre>

<p>Interestingly, TypeScript will consider any object type that happens to include all the same members of a class to be assignable to the class.
This is because TypeScript’s structural typing cares only about the shape of objects, not how they’re declared.</p>

<p>Here, <code>withSchoolBus</code> takes in a parameter of type <code>SchoolBus</code>.
That can be satisfied by any object that happens to have a <code>getAbilities</code> property of type <code>() =&gt; string[]</code>, such as an instance of the <code>SchoolBus</code> class:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">SchoolBus</code> <code class="p">{</code>
    <code class="nx">getAbilities() {</code>
        <code class="k">return</code> <code class="p">[</code><code class="s2">"magic"</code><code class="p">,</code> <code class="s2">"shapeshifting"</code><code class="p">];</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">withSchoolBus</code><code class="p">(</code><code class="nx">bus</code>: <code class="nx">SchoolBus</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">bus</code><code class="p">.</code><code class="nx">getAbilities</code><code class="p">());</code>
<code class="p">}</code>

<code class="nx">withSchoolBus</code><code class="p">(</code><code class="k">new</code> <code class="nx">SchoolBus</code><code class="p">());</code> <code class="c1">// Ok</code>

<code class="c1">// Ok</code>
<code class="nx">withSchoolBus</code><code class="p">({</code>
    <code class="nx">getAbilities</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">[</code><code class="s2">"transmogrification"</code><code class="p">],</code>
<code class="p">});</code>

<code class="nx">withSchoolBus</code><code class="p">({</code>
    <code class="nx">getAbilities</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">123</code><code class="p">,</code>
    <code class="c1">//                  ~~~</code>
    <code class="c1">// Error: Type 'number' is not assignable to type 'string[]'.</code>
<code class="p">});</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>In most real-world code, developers don’t pass object values in places that ask for class types.
This structural checking behavior may seem unexpected but doesn’t come up <a data-type="indexterm" data-primary="classes" data-secondary="as types" data-secondary-sortas="types" data-startref="class-type" id="idm45584682303456"/><a data-type="indexterm" data-primary="types" data-secondary="classes as" data-startref="type-class" id="idm45584682280272"/>very often.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Classes and Interfaces"><div class="sect1" id="idm45584682278672">
<h1>Classes and Interfaces</h1>

<p>Back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.xhtml#interfaces">Chapter 7, “Interfaces”</a>, I <a data-type="indexterm" data-primary="classes" data-secondary="interfaces and" id="class-interface"/><a data-type="indexterm" data-primary="interfaces" data-secondary="classes and" id="interface-class"/>showed you how interfaces allow TypeScript developers to set up expectations for object shapes in code.
TypeScript allows a class to declare its instances as adhering to an interface by adding the <code>implements</code> keyword after the class name, followed by the name of an interface.
Doing so indicates to TypeScript that instances of the class should be assignable to each of those interfaces.
Any mismatches would be called out as type errors by the type checker.</p>

<p>In this example, the <code>Student</code> class correctly implements the <code>Learner</code> interface by including its property <code>name</code> and method <code>study</code>, but <code>Slacker</code> is missing a <code>study</code> and thus results in a type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Learner</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">study</code><code class="p">(</code><code class="nx">hours</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Student</code> <code class="kr">implements</code> <code class="nx">Learner</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">study</code><code class="p">(</code><code class="nx">hours</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">hours</code><code class="p">;</code> <code class="nx">i</code><code class="o">+=</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"...studying..."</code><code class="p">);</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Slacker</code> <code class="kr">implements</code> <code class="nx">Learner</code> <code class="p">{</code>
   <code class="c1">// ~~~~~~~</code>
   <code class="c1">// Error: Class 'Slacker' incorrectly implements interface 'Learner'.</code>
   <code class="c1">//  Property 'study' is missing in type 'Slacker'</code>
   <code class="c1">//  but required in type 'Learner'.</code>
    <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Rocky"</code><code class="p">;</code>
<code class="p">}</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Interfaces meant to be implemented by classes are a typical reason to use the method syntax for declaring an interface member as a function—as used by the <code>Learner</code> interface.</p>
</div>

<p>Marking a class as implementing an interface doesn’t change anything about how the class is used.
If the class already happened to match up to the interface, TypeScript’s type checker would have allowed its instances to be used in places where an instance of the interface is required anyway.
TypeScript won’t even infer the types of methods or properties on the class from the interface: if we had added a <code>study(hours) {}</code> method to the <code>Slacker</code> example, TypeScript would consider the <code>hours</code> parameter an implicit <code>any</code> unless we gave it a type annotation.</p>

<p>This version of the <code>Student</code> class causes implicit <code>any</code> type errors because it doesn’t provide type annotations on its members:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Student</code> <code class="kr">implements</code> <code class="nx">Learner</code> <code class="p">{</code>
    <code class="nx">name</code><code class="p">;</code>
    <code class="c1">// Error: Member 'name' implicitly has an 'any' type.</code>

    <code class="nx">study</code><code class="p">(</code><code class="nx">hours</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Error: Parameter 'hours' implicitly has an 'any' type.</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Implementing an interface is purely a safety check.
It does not copy any interface members onto the class definition for you.
Rather, implementing an interface signals your intention to the type checker and surfaces type errors in the class definition, rather than later on where class instances are used.
It’s similar in purpose to adding a type annotation to a variable even though it has an initial value.</p>








<section data-type="sect2" data-pdf-bookmark="Implementing Multiple Interfaces"><div class="sect2" id="idm45584682082640">
<h2>Implementing Multiple Interfaces</h2>

<p>Classes <a data-type="indexterm" data-primary="multiple interfaces" data-secondary="implementing in classes" id="multiple-interface-class"/>in TypeScript are allowed to be declared as implementing multiple interfaces.
The list of implemented interfaces for a class may be any number of interface names with commas in-between.</p>

<p>In this example, both classes are required to have at least a <code>grades</code> property to implement <code>Graded</code> and a <code>report</code> property to implement <code>Reporter</code>.
The <code>Empty</code> class has two type errors for failing to implement either of the interfaces properly:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Graded</code> <code class="p">{</code>
    <code class="nx">grades</code>: <code class="nx">number</code><code class="p">[];</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">Reporter</code> <code class="p">{</code>
    <code class="nx">report</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">ReportCard</code> <code class="kr">implements</code> <code class="nx">Graded</code><code class="p">,</code> <code class="nx">Reporter</code> <code class="p">{</code>
    <code class="nx">grades</code>: <code class="nx">number</code><code class="p">[];</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">grades</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">grades</code> <code class="o">=</code> <code class="nx">grades</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">report() {</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">grades</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">", "</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Empty</code> <code class="kr">implements</code> <code class="nx">Graded</code><code class="p">,</code> <code class="nx">Reporter</code> <code class="p">{</code> <code class="p">}</code>
   <code class="c1">// ~~~~~</code>
   <code class="c1">// Error: Class 'Empty' incorrectly implements interface 'Graded'.</code>
   <code class="c1">//   Property 'grades' is missing in type 'Empty'</code>
   <code class="c1">//   but required in type 'Graded'.</code>
   <code class="c1">// ~~~~~</code>
   <code class="c1">// Error: Class 'Empty' incorrectly implements interface 'Reporter'.</code>
   <code class="c1">//   Property 'report' is missing in type 'Empty'</code>
   <code class="c1">//   but required in type 'Reporter'.</code></pre>

<p>In practice, there may be some interfaces whose definitions make it impossible to have a class implement both.
Attempting to declare a class implementing two conflicting interfaces will result in at least one type error on the class.</p>

<p>The following <code>AgeIsANumber</code> and <code>AgeIsNotANumber</code> interfaces declare very different types for an <code>age</code> property.
Neither the <code>AsNumber</code> class nor <code>NotAsNumber</code> class properly implement both:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">AgeIsANumber</code> <code class="p">{</code>
    <code class="nx">age</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">AgeIsNotANumber</code> <code class="p">{</code>
    <code class="nx">age</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">AsNumber</code> <code class="kr">implements</code> <code class="nx">AgeIsANumber</code><code class="p">,</code> <code class="nx">AgeIsNotANumber</code> <code class="p">{</code>
    <code class="nx">age</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
 <code class="c1">// ~~~</code>
 <code class="c1">// Error: Property 'age' in type 'AsNumber' is not assignable</code>
 <code class="c1">// to the same property in base type 'AgeIsNotANumber'.</code>
 <code class="c1">//   Type 'number' is not assignable to type '() =&gt; string'.</code>
<code class="p">}</code></pre>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">class</code> <code class="nx">NotAsNumber</code> <code class="kr">implements</code> <code class="nx">AgeIsANumber</code><code class="p">,</code> <code class="nx">AgeIsNotANumber</code> <code class="p">{</code>
    <code class="nx">age() {</code> <code class="k">return</code> <code class="s2">""</code><code class="p">;</code> <code class="p">}</code>
 <code class="c1">// ~~~</code>
 <code class="c1">// Error: Property 'age' in type 'NotAsNumber' is not assignable</code>
 <code class="c1">// to the same property in base type 'AgeIsANumber'.</code>
 <code class="c1">//   Type '() =&gt; string' is not assignable to type 'number'.</code>
<code class="p">}</code></pre>

<p>Cases where two interfaces describe very different object shapes generally indicate you shouldn’t try to implement them with the same <a data-type="indexterm" data-primary="classes" data-secondary="interfaces and" data-startref="class-interface" id="idm45584681897936"/><a data-type="indexterm" data-primary="interfaces" data-secondary="classes and" data-startref="interface-class" id="idm45584681896848"/><a data-type="indexterm" data-primary="multiple interfaces" data-secondary="implementing in classes" data-startref="multiple-interface-class" id="idm45584681895632"/>class.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Extending a Class"><div class="sect1" id="idm45584682278048">
<h1>Extending a Class</h1>

<p>TypeScript <a data-type="indexterm" data-primary="classes" data-secondary="extending" id="idm45584681834384"/><a data-type="indexterm" data-primary="extending" data-secondary="classes" id="idm45584681833376"/><a data-type="indexterm" data-primary="subclasses" id="idm45584681832432"/><a data-type="indexterm" data-primary="derived classes" data-see="subclasses" id="idm45584681831760"/>adds type checking onto the JavaScript concept of a class extending, or subclassing, another class.
To start, any method or property declared on a base class will be available on the subclass, also known as the derived class.</p>

<p>In this example, <code>Teacher</code> declares a <code>teach</code> method that may be used by instances of the <code>StudentTeacher</code> subclass:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Teacher</code> <code class="p">{</code>
    <code class="nx">teach() {</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"The surest test of discipline is its absence."</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">StudentTeacher</code> <code class="kr">extends</code> <code class="nx">Teacher</code> <code class="p">{</code>
    <code class="nx">learn() {</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"I cannot afford the luxury of a closed mind."</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">teacher</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">StudentTeacher</code><code class="p">();</code>
<code class="nx">teacher</code><code class="p">.</code><code class="nx">teach</code><code class="p">();</code> <code class="c1">// Ok (defined on base)</code>
<code class="nx">teacher</code><code class="p">.</code><code class="nx">learn</code><code class="p">();</code> <code class="c1">// Ok (defined on subclass)</code>

<code class="nx">teacher</code><code class="p">.</code><code class="nx">other</code><code class="p">();</code>
 <code class="c1">//     ~~~~~</code>
 <code class="c1">// Error: Property 'other' does not exist on type 'StudentTeacher'.</code></pre>








<section data-type="sect2" data-pdf-bookmark="Extension Assignability"><div class="sect2" id="idm45584681791184">
<h2>Extension Assignability</h2>

<p>Subclasses <a data-type="indexterm" data-primary="classes" data-secondary="extending" data-tertiary="assignability" id="class-extend-assign"/><a data-type="indexterm" data-primary="extending" data-secondary="classes" data-tertiary="assignability" id="extend-class-assign"/><a data-type="indexterm" data-primary="subclasses" data-secondary="assignability" id="subclass-assign"/><a data-type="indexterm" data-primary="assignability" data-secondary="of subclasses" data-secondary-sortas="subclasses" id="assign-subclass"/>inherit members from their base class much like derived interfaces extend base interfaces.
Instances of subclasses have all the members of their base class and thus may be used wherever an instance of the base is required.
If a base class doesn’t have all the members a subclass does, then it can’t be used when the more specific subclass is required.</p>

<p>Instances of the following <code>Lesson</code> class may not be used where instances of its derived <code>OnlineLesson</code> are required, but derived instances may be used to satisfy either the base or subclass:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Lesson</code> <code class="p">{</code>
    <code class="nx">subject</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">subject</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">subject</code> <code class="o">=</code> <code class="nx">subject</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">OnlineLesson</code> <code class="kr">extends</code> <code class="nx">Lesson</code> <code class="p">{</code>
    <code class="nx">url</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">subject</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">url</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">subject</code><code class="p">);</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">url</code> <code class="o">=</code> <code class="nx">url</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">lesson</code>: <code class="nx">Lesson</code><code class="p">;</code>
<code class="nx">lesson</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Lesson</code><code class="p">(</code><code class="s2">"coding"</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="nx">lesson</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">OnlineLesson</code><code class="p">(</code><code class="s2">"coding"</code><code class="p">,</code> <code class="s2">"oreilly.com"</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="kd">let</code> <code class="nx">online</code>: <code class="nx">OnlineLesson</code><code class="p">;</code>
<code class="nx">online</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">OnlineLesson</code><code class="p">(</code><code class="s2">"coding"</code><code class="p">,</code> <code class="s2">"oreilly.com"</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">online</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Lesson</code><code class="p">(</code><code class="s2">"coding"</code><code class="p">);</code>
<code class="c1">// Error: Property 'url' is missing in type</code>
<code class="c1">// 'Lesson' but required in type 'OnlineLesson'.</code></pre>

<p>Per TypeScript’s structural typing, if all the members on a subclass already exist on its base class with the same type, then instances of the base class are still allowed to be used in place of the subclass.</p>

<p>In this example, <code>LabeledPastGrades</code> only adds an optional property to <code>PastGrades</code>, so instances of the base class may be used in place of the subclass:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">PastGrades</code> <code class="p">{</code>
    <code class="nx">grades</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">LabeledPastGrades</code> <code class="kr">extends</code> <code class="nx">PastGrades</code> <code class="p">{</code>
    <code class="nx">label?</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">subClass</code>: <code class="nx">LabeledPastGrades</code><code class="p">;</code>

<code class="nx">subClass</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">LabeledPastGrades</code><code class="p">();</code> <code class="c1">// Ok</code>
<code class="nx">subClass</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">PastGrades</code><code class="p">();</code> <code class="c1">// Ok</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>In most real-world code, subclasses generally add new required type information on top of their base class.
This structural checking behavior may seem unexpected but doesn’t come up <a data-type="indexterm" data-primary="classes" data-secondary="extending" data-tertiary="assignability" data-startref="class-extend-assign" id="idm45584681527200"/><a data-type="indexterm" data-primary="extending" data-secondary="classes" data-tertiary="assignability" data-startref="extend-class-assign" id="idm45584681525776"/><a data-type="indexterm" data-primary="subclasses" data-secondary="assignability" data-startref="subclass-assign" id="idm45584681524288"/><a data-type="indexterm" data-primary="assignability" data-secondary="of subclasses" data-secondary-sortas="subclasses" data-startref="assign-subclass" id="idm45584681523072"/>very often.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Overridden Constructors"><div class="sect2" id="idm45584681493344">
<h2>Overridden Constructors</h2>

<p>As <a data-type="indexterm" data-primary="classes" data-secondary="extending" data-tertiary="constructor overrides" id="class-extend-constructor-override"/><a data-type="indexterm" data-primary="extending" data-secondary="classes" data-tertiary="constructor overrides" id="extend-class-constructor-override"/><a data-type="indexterm" data-primary="subclasses" data-secondary="constructor overrides" id="subclass-constructor-override"/><a data-type="indexterm" data-primary="constructors (of classes)" data-secondary="overriding" id="constructor-override"/><a data-type="indexterm" data-primary="classes" data-secondary="constructors" data-tertiary="overriding" id="class-construct-override"/><a data-type="indexterm" data-primary="overriding" data-secondary="class constructors" id="override-constructor"/>with vanilla JavaScript, subclasses are not required by TypeScript to define their own constructor.
Subclasses without their own constructor implicitly use the constructor from their base class.</p>

<p>In JavaScript, if a subclass does declare its own constructor, then it must call its base class constructor via<a data-type="indexterm" data-primary="super keyword" id="idm45584681483344"/> the <code>super</code> keyword.
Subclass constructors may declare any parameters regardless of what their base class requires.
TypeScript’s type checker will make sure that the call to the base class constructor uses the correct parameters.</p>

<p>In this example, <code>PassingAnnouncer</code>’s constructor correctly calls the base constructor with a <code>number</code> argument, while <code>FailingAnnouncer</code> gets a type error for forgetting to make that call:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">GradeAnnouncer</code> <code class="p">{</code>
    <code class="nx">message</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">grade</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">message</code> <code class="o">=</code> <code class="nx">grade</code> <code class="o">&gt;=</code> <code class="mi">65</code> <code class="o">?</code> <code class="s2">"Maybe next time..."</code> <code class="o">:</code> <code class="s2">"You pass!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">PassingAnnouncer</code> <code class="kr">extends</code> <code class="nx">GradeAnnouncer</code> <code class="p">{</code>
    <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="mi">100</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">FailingAnnouncer</code> <code class="kr">extends</code> <code class="nx">GradeAnnouncer</code> <code class="p">{</code>
    <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code> <code class="p">}</code>
 <code class="c1">// ~~~~~~~~~~~~~~~~~</code>
 <code class="c1">// Error: Constructors for subclasses must contain a 'super' call.</code>
<code class="p">}</code></pre>

<p>As per JavaScript rules, the constructor of a subclass must call the base constructor before accessing <code>this</code> or <code>super</code>.
TypeScript will report a type error if it sees a <code>this</code> or <code>super</code> being accessed before <code>super()</code>.</p>

<p>The following <code>ContinuedGradesTally</code> class erroneously refers to <code>this.grades</code> in its constructor before calling to <code>super()</code>:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">class</code> <code class="nx">GradesTally</code> <code class="p">{</code>
    <code class="nx">grades</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>

    <code class="nx">addGrades</code><code class="p">(...</code><code class="nx">grades</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">grades</code><code class="p">.</code><code class="nx">push</code><code class="p">(...</code><code class="nx">grades</code><code class="p">);</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">grades</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">ContinuedGradesTally</code> <code class="kr">extends</code> <code class="nx">GradesTally</code> <code class="p">{</code>
    <code class="kr">constructor</code><code class="p">(</code><code class="nx">previousGrades</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">grades</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">previousGrades</code><code class="p">];</code>
        <code class="c1">// Error: 'super' must be called before accessing</code>
        <code class="c1">// 'this' in the constructor of a subclass.</code>

        <code class="kr">super</code><code class="p">();</code>

        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Starting with length"</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">grades</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// Ok</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Overridden Methods"><div class="sect2" id="idm45584681279008">
<h2>Overridden Methods</h2>

<p>Subclasses <a data-type="indexterm" data-primary="classes" data-secondary="extending" data-tertiary="method overrides" id="idm45584681277872"/><a data-type="indexterm" data-primary="extending" data-secondary="classes" data-tertiary="method overrides" id="idm45584681336560"/><a data-type="indexterm" data-primary="subclasses" data-secondary="method overrides" id="idm45584681335344"/><a data-type="indexterm" data-primary="methods" data-secondary="of classes" data-tertiary="overriding" data-secondary-sortas="classes" id="idm45584681334400"/><a data-type="indexterm" data-primary="overriding" data-secondary="class methods" id="idm45584681332912"/>may redeclare new methods with the same names as the base class, as long as the method on the subclass method is assignable to the method on the base class.
Remember, since subclasses can be used wherever the original class is used, the types of the new methods must be usable in place of the original methods.</p>

<p>In this example, <code>FailureCounter</code>’s <code>countGrades</code> method is permitted because it has the same first parameter and return type as the base <code>GradeCounter</code>’s <code>countGrades</code> method.
<code>AnyFailureChecker</code>’s <code>countGrades</code> causes a type error for having the wrong return type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">GradeCounter</code> <code class="p">{</code>
    <code class="nx">countGrades</code><code class="p">(</code><code class="nx">grades</code>: <code class="nx">string</code><code class="p">[],</code> <code class="nx">letter</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">grades</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">grade</code> <code class="o">=&gt;</code> <code class="nx">grade</code> <code class="o">===</code> <code class="nx">letter</code><code class="p">).</code><code class="nx">length</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">FailureCounter</code> <code class="kr">extends</code> <code class="nx">GradeCounter</code> <code class="p">{</code>
    <code class="nx">countGrades</code><code class="p">(</code><code class="nx">grades</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">countGrades</code><code class="p">(</code><code class="nx">grades</code><code class="p">,</code> <code class="s2">"F"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">AnyFailureChecker</code> <code class="kr">extends</code> <code class="nx">GradeCounter</code> <code class="p">{</code>
    <code class="nx">countGrades</code><code class="p">(</code><code class="nx">grades</code>: <code class="nx">string</code><code class="p">[])</code> <code class="p">{</code>
        <code class="c1">// Property 'countGrades' in type 'AnyFailureChecker' is not</code>
        <code class="c1">// assignable to the same property in base type 'GradeCounter'.</code>
        <code class="c1">//   Type '(grades: string[]) =&gt; boolean' is not assignable</code>
        <code class="c1">//   to type '(grades: string[], letter: string) =&gt; number'.</code>
        <code class="c1">//      Type 'boolean' is not assignable to type 'number'.</code>
        <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">countGrades</code><code class="p">(</code><code class="nx">grades</code><code class="p">,</code> <code class="s2">"F"</code><code class="p">)</code> <code class="o">!==</code> <code class="mi">0</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">counter</code>: <code class="nx">GradeCounter</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">AnyFailureChecker</code><code class="p">();</code>

<code class="c1">// Expected type: number</code>
<code class="c1">// Actual type: boolean</code>
<code class="kr">const</code> <code class="nx">count</code> <code class="o">=</code> <code class="nx">counter</code><code class="p">.</code><code class="nx">countGrades</code><code class="p">([</code><code class="s2">"A"</code><code class="p">,</code> <code class="s2">"C"</code><code class="p">,</code> <code class="s2">"F"</code><code class="p">]);</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Overridden Properties"><div class="sect2" id="idm45584681229312">
<h2>Overridden Properties</h2>

<p>Subclasses <a data-type="indexterm" data-primary="classes" data-secondary="extending" data-tertiary="property overrides" id="class-extend-property-override"/><a data-type="indexterm" data-primary="extending" data-secondary="classes" data-tertiary="property overrides" id="extend-class-property-override"/><a data-type="indexterm" data-primary="subclasses" data-secondary="property overrides" id="subclass-property-override"/><a data-type="indexterm" data-primary="properties" data-secondary="of classes" data-tertiary="overriding" data-secondary-sortas="classes" id="property-class-override"/><a data-type="indexterm" data-primary="overriding" data-secondary="class properties" id="override-class-property"/>may also explicitly redeclare properties of their base class with the same name, as long as the new type is assignable to the type on the base class.
As with overridden methods, subclasses must structurally match up with base classes.</p>

<p>Most subclasses that redeclare properties do so either to make those properties a more specific subset of a type union or to make the properties a type that extends from the base class property’s type.</p>

<p>In this example, the base class <code>Assignment</code> declares its <code>grade</code> to be <code>number |</code> 
<span class="keep-together"><code>undefined</code>,</span> while the subclass <code>GradedAssignment</code> declares it as a <code>number</code> that must always exist:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Assignment</code> <code class="p">{</code>
    <code class="nx">grade?</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">GradedAssignment</code> <code class="kr">extends</code> <code class="nx">Assignment</code> <code class="p">{</code>
    <code class="nx">grade</code>: <code class="nx">number</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">grade</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">();</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">grade</code> <code class="o">=</code> <code class="nx">grade</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Expanding the allowed set of values of a property’s union type is not allowed, as doing so would make the subclass property no longer assignable to the base class property’s type.</p>

<p>In this example, <code>VagueGrade</code>’s <code>value</code> tries to add <code>| string</code> on top of the base class <code>NumericGrade</code>’s <code>number</code> type, causing a type
error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">NumericGrade</code> <code class="p">{</code>
    <code class="nx">value</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">VagueGrade</code> <code class="kr">extends</code> <code class="nx">NumericGrade</code> <code class="p">{</code>
    <code class="nx">value</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code> <code class="o">?</code> <code class="mi">1</code> <code class="o">:</code> <code class="s2">"..."</code><code class="p">;</code>
    <code class="c1">// Error: Property 'value' in type 'NumberOrString' is not</code>
    <code class="c1">// assignable to the same property in base type 'JustNumber'.</code>
    <code class="c1">//   Type 'string | number' is not assignable to type 'number'.</code>
    <code class="c1">//     Type 'string' is not assignable to type 'number'.</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">instance</code>: <code class="nx">NumericGrade</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">VagueGrade</code><code class="p">();</code>

<code class="c1">// Expected type: number</code>
<code class="c1">// Actual type: number | string</code>
<code class="nx">instance</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Abstract Classes"><div class="sect1" id="idm45584680966096">
<h1>Abstract Classes</h1>

<p>It <a data-type="indexterm" data-primary="classes" data-secondary="abstract" data-tertiary="described" id="class-abstract"/><a data-type="indexterm" data-primary="abstract classes" data-secondary="described" id="abstract-class"/>can sometimes be useful to create a base class that doesn’t itself declare the implementation of some methods, but instead expects a subclass to provide them.
Marking a class as abstract is done by adding TypeScript’s <code>abstract</code> keyword in front of the class name and in front of any method intended to be abstract.
Those abstract method declarations skip providing a body in the abstract base class; instead, they are declared the same way an interface would be.</p>

<p>In this example, the <code>School</code> class and its <code>getStudentTypes</code> method are marked as <code>abstract</code>.
Its subclasses—<code>Preschool</code> and <code>Absence</code>—are therefore expected to implement <code>getStudentTypes</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">abstract</code> <code class="kr">class</code> <code class="nx">School</code> <code class="p">{</code>
    <code class="nx">readonly</code> <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kr">abstract</code> <code class="nx">getStudentTypes</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Preschool</code> <code class="kr">extends</code> <code class="nx">School</code> <code class="p">{</code>
    <code class="nx">getStudentTypes() {</code>
        <code class="k">return</code> <code class="p">[</code><code class="s2">"preschooler"</code><code class="p">];</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Absence</code> <code class="kr">extends</code> <code class="nx">School</code> <code class="p">{</code> <code class="p">}</code>
   <code class="c1">// ~~~~~~~</code>
   <code class="c1">// Error: Nonabstract class 'Absence' does not implement</code>
   <code class="c1">// inherited abstract member 'getStudentTypes' from class 'School'.</code></pre>

<p>An abstract class cannot be instantiated directly, as it doesn’t have definitions for some methods that its implementation may assume do exist.
Only nonabstract (“concrete”) classes can be instantiated.</p>

<p>Continuing the <code>School</code> example, attempting to call <code>new School</code> would result in a TypeScript type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">school</code>: <code class="nx">School</code><code class="p">;</code>

<code class="nx">school</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Preschool</code><code class="p">(</code><code class="s2">"Sunnyside Daycare"</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">school</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">School</code><code class="p">(</code><code class="s2">"somewhere else"</code><code class="p">);</code>
<code class="c1">// Error: Cannot create an instance of an abstract class.</code></pre>

<p>Abstract classes are often used in frameworks where consumers are expected to fill out details of a class.
The class may be used as a type annotation to indicate values must adhere to the class—as with the earlier example of <code>school: School</code>—but creating new instances must be done with <a data-type="indexterm" data-primary="classes" data-secondary="abstract" data-tertiary="described" data-startref="class-abstract" id="idm45584680809968"/><a data-type="indexterm" data-primary="abstract classes" data-secondary="described" data-startref="abstract-class" id="idm45584680808576"/>subclasses.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Member Visibility"><div class="sect1" id="idm45584680807104">
<h1>Member Visibility</h1>

<p>JavaScript <a data-type="indexterm" data-primary="classes" data-secondary="member visibility" id="class-member-visibility"/><a data-type="indexterm" data-primary="member visibility for classes" id="member-visible-class"/><a data-type="indexterm" data-primary="visibility of class members" id="visible-class-member"/><a data-type="indexterm" data-primary="# (pound sign), private class members" id="pound-sym-private"/><a data-type="indexterm" data-primary="pound sign (#), private class members" id="pound-sign-private"/><a data-type="indexterm" data-primary="private class members" id="private-class-member"/><a data-type="indexterm" data-primary="protected class members" id="protect-class-member"/><a data-type="indexterm" data-primary="public class members" id="public-class-member"/>includes the ability to start the name of a class member with <code>#</code> to mark it as a “private” class member.
Private class members may only be accessed by instances of that class.
JavaScript runtimes enforce that privacy by throwing an error if an area of code outside the class tries to access the private method or property.</p>

<p>TypeScript’s class support predates JavaScript’s true <code>#</code> privacy, and while TypeScript supports private class members, it also allows a slightly more nuanced set of privacy definitions on class methods and properties that exist solely in the type system.
TypeScript’s member visibilities are achieved by adding one of the following keywords before the declaration name of a class member:</p>
<dl>
<dt><code>public</code> (default)</dt>
<dd>
<p>Allowed to be accessed by anybody, anywhere</p>
</dd>
<dt><code>protected</code></dt>
<dd>
<p>Allowed to be accessed only by the class itself and its subclasses</p>
</dd>
<dt><code>private</code></dt>
<dd>
<p>Allowed to be accessed only by the class itself</p>
</dd>
</dl>

<p>These keywords exist purely within the type system.
They’re removed along with all other type system syntax when the code is compiled to JavaScript.</p>

<p>Here, <code>Base</code> declares two <code>public</code> members, one <code>protected</code>, one <code>private</code>, and one true private with <code>#truePrivate</code>.
<code>Subclass</code> is allowed to access the <code>public</code> and <code>protected</code> members but not <code>private</code> or <code>#truePrivate</code>:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">class</code> <code class="nx">Base</code> <code class="p">{</code>
    <code class="nx">isPublicImplicit</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="kr">public</code> <code class="nx">isPublicExplicit</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
    <code class="kr">protected</code> <code class="nx">isProtected</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
    <code class="kr">private</code> <code class="nx">isPrivate</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
    <code class="err">#</code><code class="nx">truePrivate</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Subclass</code> <code class="kr">extends</code> <code class="nx">Base</code> <code class="p">{</code>
    <code class="nx">examples() {</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">isPublicImplicit</code><code class="p">;</code> <code class="c1">// Ok</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">isPublicExplicit</code><code class="p">;</code> <code class="c1">// Ok</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">isProtected</code><code class="p">;</code> <code class="c1">// Ok</code>

        <code class="k">this</code><code class="p">.</code><code class="nx">isPrivate</code><code class="p">;</code>
        <code class="c1">// Error: Property 'isPrivate' is private</code>
        <code class="c1">// and only accessible within class 'Base'.</code>

        <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">truePrivate</code><code class="p">;</code>
        <code class="c1">// Property '#truePrivate' is not accessible outside</code>
        <code class="c1">// class 'Base' because it has a private identifier.</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">Subclass</code><code class="p">().</code><code class="nx">isPublicImplicit</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="k">new</code> <code class="nx">Subclass</code><code class="p">().</code><code class="nx">isPublicExplicit</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="k">new</code> <code class="nx">Subclass</code><code class="p">().</code><code class="nx">isProtected</code><code class="p">;</code>
<code class="c1">//             ~~~~~~~~~~~</code>
<code class="c1">// Error: Property 'isProtected' is protected</code>
<code class="c1">// and only accessible within class 'Base' and its subclasses.</code>

<code class="k">new</code> <code class="nx">Subclass</code><code class="p">().</code><code class="nx">isPrivate</code><code class="p">;</code>
<code class="c1">//             ~~~~~~~~~~~</code>
<code class="c1">// Error: Property 'isPrivate' is private</code>
<code class="c1">// and only accessible within class 'Base'.</code></pre>

<p>The key difference between TypeScript’s member visibilities and JavaScript’s true private declarations is that TypeScript’s exist only in the type system, while JavaScript’s also exist at runtime.
A TypeScript class member declared as <code>protected</code> or <code>private</code> will compile to the same JavaScript code as if they were declared <code>public</code> explicitly or implicitly.
As with interfaces and type annotations, visibility keywords are erased when outputting JavaScript.
Only <code>#</code> private fields are truly private in runtime 
<span class="keep-together">JavaScript.</span></p>

<p class="less_space pagebreak-before">Visibility modifiers may be marked along with <code>readonly</code>.
To declare a member both as <code>readonly</code> and with an explicit visibility, the visibility comes first.</p>

<p>This <code>TwoKeywords</code> class declares its <code>name</code> member as both <code>private</code> and <code>readonly</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">TwoKeywords</code> <code class="p">{</code>
    <code class="kr">private</code> <code class="nx">readonly</code> <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s2">"Anne Sullivan"</code><code class="p">;</code> <code class="c1">// Ok</code>
    <code class="p">}</code>

    <code class="nx">log() {</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code> <code class="c1">// Ok</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">two</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">TwoKeywords</code><code class="p">();</code>

<code class="nx">two</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s2">"Savitribai Phule"</code><code class="p">;</code>
 <code class="c1">// ~~~~</code>
 <code class="c1">// Error: Property 'name' is private and</code>
 <code class="c1">// only accessible within class 'TwoKeywords'.</code>
 <code class="c1">// ~~~~</code>
 <code class="c1">// Error: Cannot assign to 'name'</code>
 <code class="c1">// because it is a read-only property.</code></pre>

<p>Note that it is not permitted to mix TypeScript’s old member visibility keyword with JavaScript’s new <code>#</code> private fields.
Private fields are always private by default, so there’s no need to additionally mark them with<a data-type="indexterm" data-primary="# (pound sign), private class members" data-startref="pound-sym-private" id="idm45584680611392"/><a data-type="indexterm" data-primary="pound sign (#), private class members" data-startref="pound-sign-private" id="idm45584680591824"/><a data-type="indexterm" data-primary="private class members" data-startref="private-class-member" id="idm45584680590944"/><a data-type="indexterm" data-primary="protected class members" data-startref="protect-class-member" id="idm45584680590000"/><a data-type="indexterm" data-primary="public class members" data-startref="public-class-member" id="idm45584680589056"/> the <code>private</code> keyword.</p>








<section data-type="sect2" data-pdf-bookmark="Static Field Modifiers"><div class="sect2" id="idm45584680587568">
<h2>Static Field Modifiers</h2>

<p>JavaScript <a data-type="indexterm" data-primary="static keyword" id="idm45584680585744"/>allows declaring members on a class itself—rather than its instances—using the <code>static</code> keyword.
TypeScript supports using the <code>static</code> keyword on its own and/or with <code>readonly</code> and/or with one of the visibility keywords.
When combined, the visibility keyword comes first, then <code>static</code>, then <code>readonly</code>.</p>

<p>This <code>HasStatic</code> class puts them all together to make its <code>static</code> <code>prompt</code> and <code>answer</code> properties <a data-type="indexterm" data-primary="classes" data-secondary="member visibility" data-startref="class-member-visibility" id="idm45584680536080"/><a data-type="indexterm" data-primary="member visibility for classes" data-startref="member-visible-class" id="idm45584680534896"/><a data-type="indexterm" data-primary="visibility of class members" data-startref="visible-class-member" id="idm45584680533984"/>both <code>readonly</code> and <code>protected</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Question</code> <code class="p">{</code>
    <code class="kr">protected</code> <code class="kr">static</code> <code class="nx">readonly</code> <code class="nx">answer</code><code class="o">:</code> <code class="s2">"bash"</code><code class="p">;</code>
    <code class="kr">protected</code> <code class="kr">static</code> <code class="nx">readonly</code> <code class="nx">prompt</code> <code class="o">=</code>
        <code class="s2">"What's an ogre's favorite programming language?"</code><code class="p">;</code>

    <code class="nx">guess</code><code class="p">(</code><code class="nx">getAnswer</code><code class="o">:</code> <code class="p">(</code><code class="nx">prompt</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">const</code> <code class="nx">answer</code> <code class="o">=</code> <code class="nx">getAnswer</code><code class="p">(</code><code class="nx">Question</code><code class="p">.</code><code class="nx">prompt</code><code class="p">);</code>

        <code class="c1">// Ok</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">answer</code> <code class="o">===</code> <code class="nx">Question</code><code class="p">.</code><code class="nx">answer</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"You got it!"</code><code class="p">);</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Try again..."</code><code class="p">)</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="nx">Question</code><code class="p">.</code><code class="nx">answer</code><code class="p">;</code>
<code class="c1">//       ~~~~~~</code>
<code class="c1">// Error: Property 'answer' is protected and only</code>
<code class="c1">// accessible within class 'HasStatic' and its subclasses.</code></pre>

<p>Using read-only and/or visibility modifiers to static class fields is useful for restricting those fields from being accessed or modified outside their class.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584680806480">
<h1>Summary</h1>

<p>This chapter introduced a plethora of type system features and syntaxes around classes:</p>

<ul>
<li>
<p>Declaring and using class methods and properties</p>
</li>
<li>
<p>Marking properties <code>readonly</code> and/or optional</p>
</li>
<li>
<p>Using class names as types in type annotations</p>
</li>
<li>
<p>Implementing interfaces to enforce class instance shapes</p>
</li>
<li>
<p>Extending classes, along with assignability and override rules for subclasses</p>
</li>
<li>
<p>Marking classes and methods as abstract</p>
</li>
<li>
<p>Adding type system modifiers to class fields</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/classes"><em class="hyperlink">https://learningtypescript.com/classes</em></a>.</p>
</div>
<blockquote class="joke">
<p>Why do object-oriented programming developers always wear suits?</p>

<p>Because they’ve got class.</p></blockquote>
</div></section>







</div></section></div></body></html>