<html><head></head><body><div id="sbo-rt-content"><section data-type="appendix" epub:type="appendix" data-pdf-bookmark="Answers to Review Questions"><div class="appendix" id="appendix-a">
<h1>Answers to Review Questions</h1>







<section data-type="sect1" data-pdf-bookmark="Chapter 2, “Cluster Architecture, Installation, and Configuration”"><div class="sect1" id="idm45322716257904">
<h1>Chapter 2, “Cluster Architecture, Installation, and Configuration”</h1>
<ol>
<li>
<p><a data-type="indexterm" data-primary="answers, to review questions" data-secondary="clusters" id="arq_clu"/><a data-type="indexterm" data-primary="clusters" data-secondary="answers to review questions" id="clu_arq"/>First, create the namespace named <code>apps</code>. Then, we’ll create the ServiceAccount:</p>

<pre data-type="programlisting"><strong>$ kubectl create namespace apps</strong>
<strong>$ kubectl create serviceaccount api-access -n apps</strong></pre>

<p>Alternatively, you can use the declarative approach. Create the namespace from the definition in the file <code>apps-namespace.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps</code><code class="w"/></pre>

<p>Create the namespace from the YAML file:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f apps-namespace.yaml</strong></pre>

<p>Create a new YAML file called <code>api-serviceaccount.yaml</code> with the following contents:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-access</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps</code><code class="w"/></pre>

<p><a data-type="indexterm" data-primary="create command" id="idm45322716215232"/><a data-type="indexterm" data-primary="commands" data-secondary="create" id="idm45322716152944"/>Run the <code>create</code> command to instantiate the ServiceAccount from the YAML file:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f api-serviceaccount.yaml</strong></pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="create clusterrole command" id="idm45322716179088"/><a data-type="indexterm" data-primary="commands" data-secondary="createclusterrole" id="idm45322716178384"/>Use the <code>create clusterrole</code> command to create the ClusterRole imperatively:</p>

<pre data-type="programlisting"><strong>$ kubectl create clusterrole api-clusterrole --verb=watch,list,get</strong> \
  <strong>--resource=pods</strong></pre>

<p>If you’d rather start with the YAML file, use content shown in the file <code>api-clusterrole.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-clusterrole</code><code class="w"/>
<code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"pods"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"watch"</code><code class="p-Indicator">,</code><code class="s">"list"</code><code class="p-Indicator">,</code><code class="s">"get"</code><code class="p-Indicator">]</code><code class="w"/></pre>

<p>Create the ClusterRole from the YAML file:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f api-clusterrole.yaml</strong></pre>

<p><a data-type="indexterm" data-primary="commands" data-secondary="create clusterrolebinding" id="idm45322716077296"/><a data-type="indexterm" data-primary="create clusterrolebinding command" id="idm45322716109120"/>Use the <code>create clusterrolebinding</code> command to create the ClusterRoleBinding imperatively.</p>

<pre data-type="programlisting"><strong>$ kubectl create clusterrolebinding api-clusterrolebinding</strong> \
  <strong>--serviceaccount=apps:api-access --clusterrole=api-clusterrole</strong></pre>

<p>The declarative approach of the ClusterRoleBinding could look like the one in the file <code>api-clusterrolebinding.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRoleBinding</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-clusterrolebinding</code><code class="w"/>
<code class="nt">roleRef</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/>
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-clusterrole</code><code class="w"/>
<code class="nt">subjects</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-access</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps</code><code class="w"/></pre>

<p>Create the ClusterRoleBinding from the YAML file:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f api-clusterrolebinding.yaml</strong></pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="run command" id="idm45322716010288"/><a data-type="indexterm" data-primary="commands" data-secondary="run" id="idm45322716009616"/>Execute the <code>run</code> command to create the Pods in the different namespaces. You will need to create the namespace <code>rm</code> before you can instantiate the Pod 
<span class="keep-together"><code>disposable</code>:</span></p>

<pre data-type="programlisting"><strong>$ kubectl run operator --image=nginx:1.21.1 --restart=Never</strong> \
  <strong>--port=80 --serviceaccount=api-access -n apps</strong>
<strong>$ kubectl create namespace rm</strong>
<strong>$ kubectl run disposable --image=nginx:1.21.1 --restart=Never</strong> \
  <strong>-n rm</strong></pre>

<p>The following YAML manifest shows the <code>rm</code> namespace definition stored in the file <code>rm-namespace.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rm</code><code class="w"/></pre>

<p>The YAML representation of those Pods stored in the file <code>api-pods.yaml</code> could look as follows:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">operator</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-access</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">operator</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.21.1</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>
<code class="nn">---</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">disposable</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rm</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">disposable</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.21.1</code><code class="w"/></pre>

<p>Create the namespace and Pods from the YAML files:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f rm-namespace.yaml</strong>
<strong>$ kubectl create -f api-pods.yaml</strong></pre>
</li>
<li>
<p>Determine the API server endpoint and the Secret access token of the 
<span class="keep-together">ServiceAccount.</span> You will need this information for making the API calls:</p>
<pre data-type="programlisting">
<strong>$ kubectl config view --minify -o</strong> \
  <strong>jsonpath='{.clusters[0].cluster.server}'</strong>
https://192.168.64.4:8443
<strong>$ kubectl get secret $(kubectl get serviceaccount api-access -n apps</strong> \
  <strong>-o jsonpath='{.secrets[0].name}') -o jsonpath='{.data.token}' -n apps</strong> \
  <strong>| base64 --decode</strong>
eyJhbGciOiJSUzI1NiIsImtpZCI6Ii1hOUhI...
</pre>

<p>Open an interactive shell to the Pod named <code>operator</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl exec operator -it -n apps -- /bin/sh</strong></pre>

<p>Emit API calls for listing all Pods and deleting the Pod <code>disposable</code> living in the <code>rm</code> namespace. You will find that while the <code>list</code> operation is permitted, the <code>delete</code> operation isn’t:</p>

<pre data-type="programlisting"># curl https://192.168.64.4:8443/api/v1/namespaces/rm/pods --header \
"Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Ii1hOUhI..." \
--insecure
{
    "kind": "PodList",
    "apiVersion": "v1",
    ...
}
# curl -X DELETE https://192.168.64.4:8443/api/v1/namespaces \
/rm/pods/disposable --header \
"Authorization: Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Ii1hOUhI..." \
--insecure
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {

  },
  "status": "Failure",
  "message": "pods \"disposable\" is forbidden: User \
  \"system:serviceaccount:apps:api-access\" cannot delete \
  resource \"pods\" in
  API group \"\" in the namespace \"rm\"",
  "reason": "Forbidden",
  "details": {
    "name": "disposable",
    "kind": "pods"
  },
  "code": 403
}</pre>
</li>
<li>
<p>The solution to this sample exercise requires a lot of manual steps. The following commands do not render their output.</p>

<p>Open an interactive shell to the control plane node using Vagrant:</p>

<pre data-type="programlisting"><strong>$ vagrant ssh k8s-control-plane</strong></pre>

<p>Upgrade <code>kubeadm</code> to version 1.21.2 and apply it:</p>

<pre data-type="programlisting"><strong>$ sudo apt-mark unhold kubeadm &amp;&amp; sudo apt-get update &amp;&amp; sudo apt-get</strong> \
  <strong>install -y kubeadm=1.21.2-00 &amp;&amp; sudo apt-mark hold kubeadm</strong>
<strong>$ sudo kubeadm upgrade apply v1.21.2</strong></pre>

<p>Drain the node, upgrade the kubelet and <code>kubectl</code>, restart the kubelet, and uncordon the node:</p>

<pre data-type="programlisting"><strong>$ kubectl drain k8s-control-plane --ignore-daemonsets</strong>
<strong>$ sudo apt-get update &amp;&amp; sudo apt-get install -y</strong> \
  <strong>--allow-change-held-packages kubelet=1.21.2-00 kubectl=1.21.2-00</strong>
<strong>$ sudo systemctl daemon-reload</strong>
<strong>$ sudo systemctl restart kubelet</strong>
<strong>$ kubectl uncordon k8s-control-plane</strong></pre>

<p>The version of the node should now say v1.21.2. Exit the node:</p>

<pre data-type="programlisting"><strong>$ kubectl get nodes
$ exit</strong></pre>

<p>Open an interactive shell to the first worker node using Vagrant. Repeat all of the following steps for the other worker nodes:</p>

<pre data-type="programlisting"><strong>$ vagrant ssh worker-1</strong></pre>

<p>Upgrade <code>kubeadm</code> to version 1.21.2 and apply it to the node:</p>

<pre data-type="programlisting"><strong>$ sudo apt-get update &amp;&amp; sudo apt-get install -y</strong> \
  <strong>--allow-change-held-packages kubeadm=1.21.2-00</strong>
<strong>$ sudo kubeadm upgrade node</strong></pre>

<p>Drain the node, upgrade the kubelet and <code>kubectl</code>, restart the kubelet, and uncordon the node:</p>

<pre data-type="programlisting"><strong>$ kubectl drain worker-1 --ignore-daemonsets</strong>
<strong>$ sudo apt-get update &amp;&amp; sudo apt-get install -y</strong> \
  <strong>--allow-change-held-packages kubelet=1.21.2-00 kubectl=1.21.2-00</strong>
<strong>$ sudo systemctl daemon-reload</strong>
<strong>$ sudo systemctl restart kubelet</strong>
<strong>$ kubectl uncordon worker-1</strong></pre>

<p>The version of the node should now say v1.21.2. Exit the node:</p>

<pre data-type="programlisting"><strong>$ kubectl get nodes
$ exit</strong></pre>
</li>
<li>
<p>The solution to this sample exercise requires a lot of manual steps. The following commands do not render their output.</p>

<p>Open an interactive shell to the control plane node using Vagrant. That’s not with the <code>etcdctl</code> command-line tool installed:</p>

<pre data-type="programlisting"><strong>$ vagrant ssh k8s-control-plane</strong></pre>

<p>Determine the parameters of the Pod <code>etcd-k8s-control-plane</code> by describing it. Use the correct parameter values to create a snapshot file:</p>

<pre data-type="programlisting"><strong>$ kubectl describe pod etcd-k8s-control-plane -n kube-system</strong>
<strong>$ sudo ETCDCTL_API=3 etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt</strong> \
  <strong>--cert=/etc/kubernetes/pki/etcd/server.crt</strong> \
  <strong>--key=/etc/kubernetes/pki/etcd/server.key snapshot save /opt/etcd.bak</strong></pre>

<p>Restore the backup from the snapshot file. Edit the etcd YAML manifest and change the value of <code>spec.volumes.hostPath.path</code> for the volume named <code>etcd-data</code>:</p>

<pre data-type="programlisting"><strong>$ sudo ETCDCTL_API=3 etcdctl --data-dir=/var/bak snapshot restore</strong> \
  <strong>/opt/etcd.bak</strong>
<strong>$ sudo vim /etc/kubernetes/manifests/etcd.yaml</strong></pre>

<p><a data-type="indexterm" data-primary="" data-startref="arq_clu" id="idm45322715721376"/><a data-type="indexterm" data-primary="" data-startref="clu_arq" id="idm45322715720400"/>After a short while, the Pod <code>etcd-k8s-control-plane</code> should transition back into the “Running” status. Exit the node:</p>

<pre data-type="programlisting"><strong>$ kubectl get pod etcd-k8s-control-plane -n kube-system
$ exit</strong></pre>
</li>

</ol>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Chapter 3, “Workloads”"><div class="sect1" id="idm45322715717712">
<h1>Chapter 3, “Workloads”</h1>
<ol>
<li>
<p><a data-type="indexterm" data-primary="answers, to review questions" data-secondary="workloads" id="idm45322715715648"/><a data-type="indexterm" data-primary="workloads" data-secondary="answers to review questions" id="idm45322715714656"/>First, create the Deployment named <code>nginx</code>. Use the imperative approach for the fastest turnaround time:</p>

<pre data-type="programlisting"><strong>$ kubectl create deployment nginx --image=nginx:1.17.0 --replicas=2</strong></pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="scale command" id="idm45322715711440"/><a data-type="indexterm" data-primary="commands" data-secondary="scale" id="idm45322715710736"/>The <code>scale</code> command increases the number of replicas to 7. The <code>get</code> command should render seven Pods with the Deployment’s name as the prefix in their names:</p>

<pre data-type="programlisting"><strong>$ kubectl scale deployment nginx --replicas=7
$ kubectl get deployments,pods</strong>
NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx   7/7     7            7           93s

NAME                         READY   STATUS    RESTARTS   AGE
pod/nginx-844f997cc9-6tbzw   1/1     Running   0          93s
pod/nginx-844f997cc9-8mzz2   1/1     Running   0          93s
pod/nginx-844f997cc9-n7g8x   1/1     Running   0          10s
pod/nginx-844f997cc9-sbrmf   1/1     Running   0          10s
pod/nginx-844f997cc9-wtbk6   1/1     Running   0          10s
pod/nginx-844f997cc9-xghl9   1/1     Running   0          10s
pod/nginx-844f997cc9-zsggj   1/1     Running   0          10s</pre>
</li>
<li>
<p>The API version of a Horizontal Pod Autoscaler that currently supports defining CPU and memory utilization thresholds is <code>autoscaling/v2beta2</code>. The following YAML manifest specifies the autoscaling parameters in the file <code>hpa.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">autoscaling/v2beta2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">HorizontalPodAutoscaler</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-hpa</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">scaleTargetRef</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">minReplicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w"/>
<code class="w">  </code><code class="nt">maxReplicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">20</code><code class="w"/>
<code class="w">  </code><code class="nt">metrics</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Resource</code><code class="w"/>
<code class="w">    </code><code class="nt">resource</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cpu</code><code class="w"/>
<code class="w">      </code><code class="nt">target</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Utilization</code><code class="w"/>
<code class="w">        </code><code class="nt">averageUtilization</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">65</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Resource</code><code class="w"/>
<code class="w">    </code><code class="nt">resource</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memory</code><code class="w"/>
<code class="w">      </code><code class="nt">target</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">AverageValue</code><code class="w"/>
<code class="w">        </code><code class="nt">averageValue</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1Gi</code><code class="w"/></pre>

<p>Create the Horizontal Pod Autoscaler with the <code>create</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f hpa.yaml</strong></pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="set image command" id="idm45322715646976"/><a data-type="indexterm" data-primary="commands" data-secondary="set image" id="idm45322715646048"/><a data-type="indexterm" data-primary="rollout undo command" id="idm45322715645104"/><a data-type="indexterm" data-primary="commands" data-secondary="rollout undo" id="idm45322715644432"/>You can either manually change the image name by editing the live object via the <code>edit</code> command or use the <code>set image</code> command as a shortcut. Use the <code>--record</code> option so that the command is recorded as the change cause:</p>

<pre data-type="programlisting"><strong>$ kubectl set image deployment nginx nginx=nginx:1.21.1 --record</strong></pre>

<p>The rollout history will show two revisions, the starting revision 1 and the most recent change as 2. Notice that the change cause shows the recorded command:</p>

<pre data-type="programlisting"><strong>$ kubectl rollout history deployment nginx</strong>
deployment.apps/nginx
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         kubectl set image deployment nginx nginx=nginx:1.21.1 \
          --record=true</pre>

<p>Use the <code>rollout undo</code> command to roll back to the previous revision. Revision 1 is turned into revision 3:</p>

<pre data-type="programlisting"><strong>$ kubectl rollout undo deployment nginx --to-revision=1
$ kubectl rollout history deployment nginx</strong>
deployment.apps/nginx
REVISION  CHANGE-CAUSE
2         kubectl set image deployment nginx nginx=nginx:1.21.1 \
          --record=true
3         &lt;none&gt;</pre>
</li>
<li>
<p>The following YAML manifest shows the Secret of type <code>kubernetes.io/basic-auth</code> in the file <code>basic-auth-secret.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">basic-auth</code><code class="w"/>
<code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubernetes.io/basic-auth</code><code class="w"/>
<code class="nt">stringData</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">username</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">super</code><code class="w"/>
<code class="w">  </code><code class="nt">password</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-s8cr3t</code><code class="w"/></pre>

<p>Create the Secret using the <code>create</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f basic-auth-secret.yaml</strong></pre>

<p><a data-type="indexterm" data-primary="edit command" id="idm45322715484240"/><a data-type="indexterm" data-primary="commands" data-secondary="edit" id="idm45322715483536"/>To mount the Secret as a volume to the Pod template, edit the live object of the Deployment using the <code>edit</code> command. The essential portions of the Deployment will look similar to the following YAML manifest:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">7</code><code class="w"/>
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.17.0</code><code class="w"/>
<code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/secret</code><code class="w"/>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">auth-vol</code><code class="w"/>
<code class="w">          </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">      </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">auth-vol</code><code class="w"/>
<code class="w">        </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">basic-auth</code><code class="w"/></pre>
</li>

</ol>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Chapter 4, “Scheduling and Tooling”"><div class="sect1" id="idm45322715478432">
<h1>Chapter 4, “Scheduling and Tooling”</h1>
<ol>
<li>
<p><a data-type="indexterm" data-primary="answers, to review questions" data-secondary="scheduling and tooling" id="idm45322715476592"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="answers to review questions" id="idm45322715312608"/>The manifest of a Pod that defines resource boundaries stored in a file <code>ingress-controller-pod.yaml</code> could look as follows:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ingress-controller</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ingress-controller</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bitnami/nginx-ingress-controller:1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"256Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1"</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1024Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"2.5"</code><code class="w"/></pre>
</li>
<li>
<p>Assume a cluster with three nodes: one control plane node and two worker nodes. The following multinode cluster has been set up with Minikube. For more information, see the <a href="https://oreil.ly/nVhYn">setup instructions</a>:</p>

<pre data-type="programlisting"><strong>$ kubectl get nodes</strong>
NAME           STATUS   ROLES                  AGE   VERSION
minikube       Ready    control-plane,master   41d   v1.21.2
minikube-m02   Ready    &lt;none&gt;                 21h   v1.21.2
minikube-m03   Ready    &lt;none&gt;                 21h   v1.21.2</pre>

<p>You can identify which node runs the Pod after creating the object. Write the node name to the file <code>node.txt</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f ingress-controller-pod.yaml
$ kubectl get pod ingress-controller -o yaml | grep nodeName:</strong>
  nodeName: minikube-m02
<strong>$ echo "minikube-m02" &gt;&gt; node.txt</strong></pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="apply command" id="idm45322715175440"/><a data-type="indexterm" data-primary="commands" data-secondary="apply" id="idm45322715174736"/>Navigate to the folder containing the <code>manifests</code> directory. Create all objects contained in the <code>manifests</code> directory using the recursive <code>apply</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -f manifests/ -R</strong>
configmap/logs-config created
pod/nginx created</pre>
</li>
<li>
<p>Modify the value of the key <code>dir</code> in the file <code>configmap.yaml</code> using an editor. Then update the live object of the ConfigMap using the following command:</p>

<pre data-type="programlisting"><strong>$ vim manifests/configmap.yaml
$ kubectl apply -f manifests/configmap.yaml</strong>
configmap/logs-config configured</pre>

<p>Delete all objects that have been created from the <code>manifests</code> directory using the recursive <code>delete</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl delete -f manifests/ -R</strong>
configmap "logs-config" deleted
pod "nginx" deleted</pre>
</li>
<li>
<p>Create the file <code>kustomization.yaml</code>. It should define the common attribute for the namespace and reference the resource with the file <code>pod.yaml</code>. The following YAML file shows its contents:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">t012</code><code class="w"/>
<code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">pod.yaml</code><code class="w"/></pre>

<p><a data-type="indexterm" data-primary="kustomize command" id="idm45322715132832"/><a data-type="indexterm" data-primary="commands" data-secondary="kustomize" id="idm45322715132224"/>Run the following <code>kustomize</code> command to render the transformed manifest as console output:</p>

<pre data-type="programlisting"><strong>$ kubectl kustomize ./</strong>
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  namespace: t012
spec:
  containers:
  - image: nginx:1.21.1
    name: nginx</pre>
</li>

</ol>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Chapter 5, “Services and Networking”"><div class="sect1" id="idm45322715129440">
<h1>Chapter 5, “Services and Networking”</h1>
<ol>
<li>
<p><a data-type="indexterm" data-primary="answers, to review questions" data-secondary="networking" id="arq_n"/><a data-type="indexterm" data-primary="answers, to review questions" data-secondary="services" id="arq_s"/><a data-type="indexterm" data-primary="networking" data-secondary="answers to review questions" id="n_arq"/><a data-type="indexterm" data-primary="services" data-secondary="answers to review questions" id="s_arq"/>Start by creating the namespace <code>external</code>. Within the namespace, create the Deployment and the Service using the imperative command:</p>

<pre data-type="programlisting"><strong>$ kubectl create namespace external</strong>
<strong>$ kubectl create deployment nginx --image=nginx --port=80 --replicas=3</strong> \
  <strong>-n external</strong>
<strong>$ kubectl create service loadbalancer nginx --tcp=80:80 -n external</strong></pre>

<p>If you’d rather use the declarative approach, see the following YAML manifests:</p>

<p><code>external-namespace.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external</code><code class="w"/></pre>

<p><code>external-deployment.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre>

<p><code>external-service.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">LoadBalancer</code><code class="w"/>
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>
<code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre>

<p>To create all object, run the <code>create</code> or <code>apply</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f external-namespace.yaml
$ kubectl create -f external-deployment.yaml
$ kubectl create -f external-service.yaml</strong></pre>
</li>
<li>
<p>Determine the external IP address of the Service of type <code>LoadBalancer</code>. In the following output, the external IP address is <code>10.108.34.2</code>. If you are using Minikube, remember to run <code>minikube tunnel</code> in another shell so that the value of <code>EXTERNAL-IP</code> gets populated:</p>

<pre data-type="programlisting"><strong>$ kubectl get service -n external</strong>
NAME    TYPE           CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE
nginx   LoadBalancer   10.108.34.2   10.108.34.2   80:31898/TCP   36m</pre>

<p><a data-type="indexterm" data-primary="curl command" id="idm45322714842352"/><a data-type="indexterm" data-primary="commands" data-secondary="curl" id="idm45322714841648"/>The following <code>curl</code> command makes a call to the Service using the external IP address and port:</p>

<pre data-type="programlisting"><strong>$ wget 10.108.34.2:80</strong>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...</pre>
</li>
<li>
<p>Edit the live object by changing the value of the attribute <code>spec.type</code> from 
<span class="keep-together"><code>LoadBalancer</code></span> to <code>ClusterIP</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl edit service nginx -n external</strong>
...
spec:
  type: ClusterIP
...</pre>

<p>The Service should indicate the type <code>ClusterIP</code> now. Notice that there’s no more value for the external IP address. Furthermore, the statically assigned port is gone as well:</p>

<pre data-type="programlisting"><strong>$ kubectl get service -n external</strong>
NAME    TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
nginx   ClusterIP   10.108.34.2   &lt;none&gt;        80/TCP    52m</pre>

<p>A Service of type <code>ClusterIP</code> is accessible only from within the cluster. You can make a call to the Service from a temporary Pod in the same namespace. You can either use the cluster IP address (in this case <code>10.108.34.2</code>) or use the DNS name for the Service <code>nginx</code>:</p>
<pre data-type="programlisting">
<strong>$ kubectl run tmp --image=busybox --restart=Never -n external -it --rm</strong> \
  <strong>-- wget 10.108.34.2:80</strong>
Connecting to 10.108.34.2:80 (10.108.34.2:80)
saving to 'index.html'
index.html           100% |********************************|   615  \
0:00:00 ETA
'index.html' saved
pod "tmp" deleted
<strong>$ kubectl run tmp --image=busybox --restart=Never -n external -it --rm</strong> \
  <strong>-- wget nginx:80</strong>
Connecting to 10.108.34.2:80 (10.108.34.2:80)
saving to 'index.html'
index.html           100% |********************************|   615  \
0:00:00 ETA
'index.html' saved
pod "tmp" deleted
</pre>
</li>
<li>
<p>To create the Ingress imperatively, run the following command:</p>
<pre data-type="programlisting">
<strong>$ kubectl create ingress incoming --rule="/*=nginx:80" -n external</strong>
</pre>

<p>If you’d rather use the declarative approach, see the YAML manifest in the file <code>incoming-ingress.yaml</code> shown here:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Ingress</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">incoming</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">http</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">paths</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">backend</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"/>
<code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>
<code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Prefix</code><code class="w"/></pre>

<p>To create the object, run the <code>create</code> or <code>apply</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f incoming-ingress.yaml</strong></pre>
</li>
<li>
<p>To verify the correct behavior of the Ingress, retrieve the IP address of any node in the cluster. Here, we are dealing with only a single node that has the IP address <code>192.168.64.19</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl get nodes -o wide</strong>
NAME      STATUS   ROLES                 AGE   VERSION   INTERNAL-IP   \
EXTERNAL-IP   OS-IMAGE               KERNEL-VERSION   CONTAINER-RUNTIME
minikube  Ready    control-plane,master  13d   v1.21.2   192.168.64.19 \
&lt;none&gt;        Buildroot 2020.02.12   4.19.182         docker://20.10.6</pre>

<p>The Ingress is configured to access calls to any hostname. Make a call to the node’s IP address from your local machine. The traffic will be routed to the Pods through the Service named <code>nginx</code>:</p>

<pre data-type="programlisting"><strong>$ curl 192.168.64.19</strong>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...</pre>
</li>
<li>
<p>For a fast turnaround, you can create the <code>echoserver</code> Pod and the Service together with the <code>run</code> command plus the <code>--expose</code> CLI option:</p>

<pre data-type="programlisting"><strong>$ kubectl run echoserver --image=k8s.gcr.io/echoserver:1.10</strong> \
  <strong>--restart=Never --port=8080 --expose -n external</strong></pre>

<p>The declarative approach requires the creation of the following YAML manifests:</p>

<p><code>external-echoserver-pod.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">echoserver</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">run</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">echoserver</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8s.gcr.io/echoserver:1.10</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/></pre>

<p><code>external-echoserver-service.yaml</code>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">echoserver</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterIP</code><code class="w"/>
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">run</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/></pre>

<p>To create the object, run the <code>create</code> or <code>apply</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f external-echoserver-pod.yaml
$ kubectl create -f external-echoserver-service.yaml</strong></pre>

<p>Modify the existing Ingress and add a new rule that routes to the <code>echoservice</code> Service. The resulting YAML definition should look as follows:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">networking.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Ingress</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">incoming</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">http</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">paths</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">backend</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"/>
<code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/</code><code class="w"/>
<code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Prefix</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">backend</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">echoserver</code><code class="w"/>
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"/>
<code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/echo</code><code class="w"/>
<code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Exact</code><code class="w"/></pre>
</li>
<li>
<p>Make a call to the node’s IP address from your local machine using the path <code>/echo</code>. The traffic will be routed to the Pods through the Service named 
<span class="keep-together"><code>echoservice</code>:</span></p>

<pre data-type="programlisting"><strong>$ curl 192.168.64.19/echo</strong>

Hostname: echoserver
...</pre>
</li>
<li>
<p>You can customize CoreDNS settings by editing the ConfigMap <code>coredns</code> in the namespace <code>kube-system</code> using the command <code>kubectl edit configmap coredns -n kube-system</code>. The following YAML manifest shows the <code>rewrite</code> rule:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">coredns-custom</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kube-system</code><code class="w"/>
<code class="nt">data</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">Corefile</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w"/>
<code class="w">    </code><code class="no">.:53 {</code><code class="w"/>
<code class="w">        </code><code class="no">...</code><code class="w"/>
<code class="w">        </code><code class="no">rewrite name substring svc.cka.example.com svc.cluster.local</code><code class="w"/>
<code class="w">        </code><code class="no">kubernetes cluster.local in-addr.arpa ip6.arpa {</code><code class="w"/>
<code class="w">        </code><code class="no">...</code><code class="w"/>
<code class="w">    </code><code class="no">}</code><code class="w"/></pre>

<p>Find the Pod running CoreDNS in the namespace <code>kube-system</code> and delete it to force a re-creation of the Pod. You should see that Kubernetes creates a new object for the CoreDNS Pod:</p>

<pre data-type="programlisting"><strong>$ kubectl get pods -n kube-system</strong>
NAME                               READY   STATUS    RESTARTS   AGE
coredns-558bd4d5db-kjdtx           1/1     Running   0          9m35s
...
<strong>$ kubectl delete pod coredns-558bd4d5db-kjdtx -n kube-system
$ kubectl get pods -n kube-system</strong>
NAME                               READY   STATUS    RESTARTS   AGE
coredns-558bd4d5db-mc98t           1/1     Running   0          54s
...</pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="wget command" id="idm45322714261664"/><a data-type="indexterm" data-primary="commands" data-secondary="wget" id="idm45322714260800"/><a data-type="indexterm" data-primary="" data-startref="arq_n" id="idm45322714259856"/><a data-type="indexterm" data-primary="" data-startref="arq_s" id="idm45322714258912"/><a data-type="indexterm" data-primary="" data-startref="n_arq" id="idm45322714257968"/><a data-type="indexterm" data-primary="" data-startref="s_arq" id="idm45322714257024"/>Create the namespace <code>hello</code> if it doesn’t exist yet. Run a <code>wget</code> command against <code>echoserver.external.svc.cka.example.com</code> from a temporary Pod in the <code>hello</code> namespace. The call should succeed:</p>
<pre data-type="programlisting">
<strong>$ kubectl create namespace hello
$ kubectl run tmp --image=busybox --restart=Never -n hello -it --rm</strong> \
  <strong>-- wget echoserver.external.svc.cka.example.com:8080</strong>
Connecting to echoserver.external.svc.cka.example.com:8080 \
(10.104.248.24:8080)
saving to 'index.html'
index.html           100% |********************************|   \
460  0:00:00 ETA
'index.html' saved
pod "tmp" deleted
</pre>
</li>

</ol>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Chapter 6, “Storage”"><div class="sect1" id="idm45322714252368">
<h1>Chapter 6, “Storage”</h1>
<ol>
<li>
<p><a data-type="indexterm" data-primary="answers, to review questions" data-secondary="storage" id="arq_sto"/><a data-type="indexterm" data-primary="storage" data-secondary="answers to review questions" id="sto_arq"/>Start by creating a new file named <code>logs-pv.yaml</code>. The contents could look as follows:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolume</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">logs-pv</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">capacity</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2Gi</code><code class="w"/>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadOnlyMany</code><code class="w"/>
<code class="w">  </code><code class="nt">persistentVolumeReclaimPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Delete</code><code class="w"/>
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">  </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/tmp/logs</code><code class="w"/></pre>

<p>Create the PersistentVolume object and check on its status:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f logs-pv.yaml</strong>
persistentvolume/logs-pv created
<strong>$ kubectl get pv</strong>
NAME      CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS \
  CLAIM              STORAGECLASS   REASON   AGE
logs-pv   2Gi        RWO,ROX        Delete           Bound  \
  default/logs-pvc                           16m</pre>
</li>
<li>
<p>Create the file <code>logs-pvc.yaml</code> to define the PersistentVolumeClaim. The following YAML manifest shows its contents:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolumeClaim</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">logs-pvc</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1Gi</code><code class="w"/></pre>

<p>Create the PersistentVolumeClaim object and check on its status:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f logs-pvc.yaml</strong>
persistentvolumeclaim/logs-pvc created
<strong>$ kubectl get pvc</strong>
NAME       STATUS   VOLUME    CAPACITY   ACCESS MODES \
  STORAGECLASS   AGE
logs-pvc   Bound    logs-pv   2Gi        RWO,ROX      \
                 17m</pre>
</li>
<li>
<p>Create the basic YAML manifest using the <code>--dry-run</code> command-line option:</p>

<pre data-type="programlisting"><strong>$ kubectl run nginx --image=nginx --dry-run=client --restart=Never</strong> \
  <strong>-o yaml &gt; nginx-pod.yaml</strong></pre>

<p>Now, edit the file <code>nginx-pod.yaml</code> and bind the PersistentVolumeClaim to it:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">creationTimestamp</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">null</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">run</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">logs-volume</code><code class="w"/>
<code class="w">      </code><code class="nt">persistentVolumeClaim</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">claimName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">logs-pvc</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/var/log/nginx"</code><code class="w"/>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">logs-volume</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/>
<code class="w">  </code><code class="nt">dnsPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterFirst</code><code class="w"/>
<code class="w">  </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Never</code><code class="w"/>
<code class="nt">status</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/></pre>

<p>Create the Pod using the following command and check its status:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f nginx-pod.yaml</strong>
pod/nginx created
<strong>$ kubectl get pods</strong>
NAME    READY   STATUS    RESTARTS   AGE
nginx   1/1     Running   0          8s</pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="commands" data-secondary="exec" id="idm45322713898096"/><a data-type="indexterm" data-primary="exec command" id="idm45322713897120"/>Use the <code>exec</code> command to open an interactive shell to the Pod and create a file in the mounted directory:</p>

<pre data-type="programlisting"><strong>$ kubectl exec nginx -it -- /bin/sh</strong>
# cd /var/log/nginx
# touch my-nginx.log
# ls
access.log  error.log  my-nginx.log
# exit</pre>
</li>
<li>
<p>Delete the Pod and the PersistentVolumeClaim. The PersistentVolume will be deleted automatically due to its reclaim policy:</p>

<pre data-type="programlisting"><strong>$ kubectl delete pod nginx
$ kubectl delete pvc logs-pvc
$ kubectl get pv,pvc</strong>
No resources found</pre>
</li>
<li>
<p>You can list the storage classes with the following command. If you are using Minikube, you will likely find only a single storage class, the default one. The existing storage class is named <code>standard</code> and uses the provisioner <code>k8s.io/minikube-hostpath</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl get sc</strong>
NAME                 PROVISIONER                RECLAIMPOLICY \
  VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
standard (default)   k8s.io/minikube-hostpath   Delete        \
  Immediate           false                  22d</pre>
</li>
<li>
<p>Create the file <code>custom-sc.yaml</code> for the storage class. The YAML manifest could look as follows:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">storage.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">StorageClass</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">custom</code><code class="w"/>
<code class="nt">provisioner</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8s.io/minikube-hostpath</code><code class="w"/></pre>

<p>Create the storage class using the following command. Listing all storage classes renders the default storage class and the new one:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f custom-sc.yaml</strong>
storageclass.storage.k8s.io/custom created
<strong>$ kubectl get sc</strong>
NAME                 PROVISIONER                RECLAIMPOLICY \
  VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
custom               k8s.io/minikube-hostpath   Delete        \
  Immediate           false                  11s
standard (default)   k8s.io/minikube-hostpath   Delete        \
  Immediate           false                  22d</pre>
</li>
<li>
<p>Create the file <code>custom-pvc.yaml</code> to define the PersistentVolumeClaim. The following YAML manifest shows its contents:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolumeClaim</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">custom-pvc</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">custom</code><code class="w"/>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500Mi</code><code class="w"/></pre>

<p>Create the PersistentVolumeClaim object and check on its status:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f custom-pvc.yaml</strong>
persistentvolumeclaim/custom-pvc created
<strong>$ kubectl get pv,pvc</strong>
NAME                                                        CAPACITY \
  ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM   STORAGECLASS \
    REASON   AGE
persistentvolume/pvc-6fe081b5-e425-45cd-a94a-3488ce24cb87   500Mi    \
  RWO            Delete           Bound    default/custom-pvc   custom \
                   13s

NAME                               STATUS \
  VOLUME                                     CAPACITY   ACCESS MODES \
   STORAGECLASS   AGE
persistentvolumeclaim/custom-pvc   Bound  \
  pvc-6fe081b5-e425-45cd-a94a-3488ce24cb87   500Mi      RWO \
            custom           13s</pre>
</li>
<li>
<p>Write the name of the PersistentVolume to the file <code>pv-name.txt</code>:</p>

<pre data-type="programlisting"><strong>$ echo "pvc-6fe081b5-e425-45cd-a94a-3488ce24cb87" &gt; pv-name.txt</strong></pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="" data-startref="arq_sto" id="idm45322713775424"/><a data-type="indexterm" data-primary="" data-startref="sto_arq" id="idm45322713774448"/>Deleting the PersistentVolumeClaim will delete the bound PersistentVolume as well:</p>

<pre data-type="programlisting"><strong>$ kubectl delete pvc custom-pvc
$ kubectl get pv,pvc</strong>
No resources found</pre>
</li>

</ol>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Chapter 7, “Troubleshooting”"><div class="sect1" id="idm45322713772112">
<h1>Chapter 7, “Troubleshooting”</h1>
<ol>
<li>
<p><a data-type="indexterm" data-primary="answers, to review questions" data-secondary="troubleshooting" id="arq_tro"/><a data-type="indexterm" data-primary="troubleshooting" data-secondary="answers to review questions" id="tro_arq"/>Start by creating a YAML starting point for the Pod in the file named <code>multi-container.yaml</code>. The following command creates the file:</p>

<pre data-type="programlisting"><strong>$ kubectl run multi --image=nginx:1.21.6 -o yaml --dry-run=client</strong> \
  <strong>--restart=Never &gt; multi-container.yaml</strong></pre>

<p>Edit the YAML manifest. Add the sidecar container. The contents of the YAML file could look as follows:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">multi</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.21.6</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.35.0</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">streaming</code><code class="w"/>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">/bin/sh</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">-c</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">'tail</code><code class="nv"> </code><code class="s">-n+1</code><code class="nv"> </code><code class="s">-f</code><code class="nv"> </code><code class="s">/var/log/nginx/access.log'</code><code class="p-Indicator">]</code><code class="w"/></pre>
</li>
<li>
<p>Add the volume definition and mount it to both containers. The final YAML manifest is shown here:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">multi</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx:1.21.6</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">accesslog</code><code class="w"/>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/log/nginx</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox:1.35.0</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">streaming</code><code class="w"/>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">/bin/sh</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">-c</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">'tail</code><code class="nv"> </code><code class="s">-n+1</code><code class="nv"> </code><code class="s">-f</code><code class="nv"> </code><code class="s">/var/log/nginx/access.log'</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">accesslog</code><code class="w"/>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/log/nginx</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">accesslog</code><code class="w"/>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/></pre>

<p>Create the Pod by pointing the <code>create</code> command to the YAML file:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f multi-container.yaml</strong></pre>
</li>
<li>
<p>Determine the IP address of the Pod. In the following example, the IP address is <code>10.244.2.3</code>. Make three calls to nginx using a temporary Pod. The logs of the <code>streaming</code> container has three entries:</p>

<pre data-type="programlisting"><strong>$ kubectl get pod multi -o wide</strong>
NAME    READY   STATUS    RESTARTS   AGE     IP           NODE         \
  NOMINATED NODE   READINESS GATES
multi   2/2     Running   0          3m23s   10.244.2.3   minikube-m03 \
  &lt;none&gt;           &lt;none&gt;
<strong>$ kubectl run tmp --image=busybox --restart=Never -it --rm</strong> \
  <strong>-- wget 10.244.2.3</strong>
<strong>$ kubectl run tmp --image=busybox --restart=Never -it --rm</strong> \
  <strong>-- wget 10.244.2.3</strong>
<strong>$ kubectl run tmp --image=busybox --restart=Never -it --rm</strong> \
  <strong>-- wget 10.244.2.3</strong>
<strong>$ kubectl logs multi -c streaming</strong>
10.244.1.2 - - [27/Jan/2022:16:44:25 +0000] "GET / HTTP/1.1" 200 \
615 "-" "Wget" "-"
10.244.1.3 - - [27/Jan/2022:16:44:29 +0000] "GET / HTTP/1.1" 200 \
615 "-" "Wget" "-"
10.244.1.4 - - [27/Jan/2022:16:44:32 +0000] "GET / HTTP/1.1" 200 \
615 "-" "Wget" "-"</pre>
</li>
<li>
<p>Create the Pods <code>stress-1</code> and <code>stress-2</code>. The following YAML manifest shows the definition for the Pod named <code>stress-1</code> in the file <code>stress-1-pod.yaml</code>. Create a second YAML file and change the Pod name accordingly:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">stress-1</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">polinux/stress:1.0.4</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">consumer</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"250Mi"</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"250Mi"</code><code class="w"/>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">/bin/sh</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">-c</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">'stress</code><code class="nv"> </code><code class="s">--vm</code><code class="nv"> </code><code class="s">1</code><code class="nv"> </code><code class="s">--vm-bytes</code><code class="nv"> </code><code class="s">\</code><code class="w"/>
<code class="w">           </code><code class="s">$(shuf</code><code class="nv"> </code><code class="s">-i</code><code class="nv"> </code><code class="s">20-200</code><code class="nv"> </code><code class="s">-n</code><code class="nv"> </code><code class="s">1)M</code><code class="nv"> </code><code class="s">--vm-hang</code><code class="nv"> </code><code class="s">1'</code><code class="p-Indicator">]</code><code class="w"/></pre>

<p>Create the Pods and check their status:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f stress-1-pod.yaml
$ kubectl create -f stress-2-pod.yaml
$ kubectl get pods</strong>
NAME       READY   STATUS    RESTARTS   AGE
stress-1   1/1     Running   0          15m
stress-2   1/1     Running   0          6m28s</pre>
</li>
<li>
<p><a data-type="indexterm" data-primary="" data-startref="arq_tro" id="idm45322713305360"/><a data-type="indexterm" data-primary="" data-startref="tro_arq" id="idm45322713304384"/>Install the <a href="https://oreil.ly/e1NSC">metrics server</a> if it isn’t already available on your cluster. Retrieve the metrics for the Pods from the metrics server. In the example below, the Pod named <code>stress-2</code> consumes more memory. Write the name of the Pod the file <em>max-memory.txt</em>:</p>

<pre data-type="programlisting"><strong>$ kubectl top pods</strong>
NAME       CPU(cores)   MEMORY(bytes)
stress-1   32m          93Mi
stress-2   47m          117Mi
<strong>$ echo "stress-2" &gt; max-memory.txt</strong></pre>
</li>
<li>
<p>You can find the solution in the file <a class="orm:hideurl" href="https://oreil.ly/BjXvd"><em>app-a/ch07/troubleshooting-pod/solution/solution.md</em></a> of the checked-out GitHub repository <a href="https://oreil.ly/jUIq8"><em>bmuschko/cka-study-guide</em></a>.</p>
</li>
<li>
<p>You can find the solution in the file <a class="orm:hideurl" href="https://oreil.ly/PQEQt"><em>app-a/ch07/troubleshooting-deployment/solution/solution.md</em></a> of the checked-out GitHub repository <a href="https://oreil.ly/jUIq8"><em>bmuschko/cka-study-guide</em></a>.</p>
</li>
<li>
<p>You can find the solution in the file <a class="orm:hideurl" href="https://oreil.ly/oPmYR"><em>app-a/ch07/troubleshooting-service/solution/solution.md</em></a> of the checked-out GitHub repository <a href="https://oreil.ly/jUIq8"><em>bmuschko/cka-study-guide</em></a>.</p>
</li>
<li>
<p>You can find the solution in the file <a class="orm:hideurl" href="https://oreil.ly/CcLJe"><em>app-a/ch07/troubleshooting-control-plane-node/solution/solution.md</em></a> of the checked-out GitHub repository <a href="https://oreil.ly/jUIq8"><em>bmuschko/cka-study-guide</em></a>.</p>
</li>
<li>
<p>You can find the solution in the file <a class="orm:hideurl" href="https://oreil.ly/WI3sa"><em>app-a/ch07/troubleshooting-worker-node/solution/solution.md</em></a> of the checked-out GitHub repository <a href="https://oreil.ly/jUIq8"><em>bmuschko/cka-study-guide</em></a>.</p>
</li>

</ol>
</div></section>







</div></section></div></body></html>