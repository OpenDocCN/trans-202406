- en: Chapter 20\. Chaos Testing, Load Testing, and Experiments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 20 章 混沌测试、负载测试和实验
- en: 'This chapter covers three different methods of testing applications in your
    Kubernetes cluster: chaos testing, load testing, and experiments. All these tools
    can be used to help you build more useful, more resilient, and more performant
    applications. They can also provide insight into your application and help you
    better understand your users and anticipate the impact of changes before you roll
    them out broadly. This insight enables you to make better decisions and identify
    areas for future improvements. The following sections will describe the details
    of each type of test, their goals, and the prerequisites necessary before starting
    each test.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在你的 Kubernetes 集群中测试应用程序的三种不同方法：混沌测试、负载测试和实验。所有这些工具都可以帮助你构建更有用、更具弹性和更高性能的应用程序。它们还可以为你的应用程序提供洞察，并帮助你更好地理解你的用户，并在广泛推出变更之前预测其影响。这些洞察力使你能够做出更好的决策，并识别未来改进的领域。接下来的几节将描述每种测试类型的详细信息、其目标以及开始每项测试之前所需的先决条件。
- en: Chaos Testing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混沌测试
- en: Chaos testing, as its name indicates, is testing your application’s ability
    to respond to chaos in the world, But what exactly does chaos mean? Broadly speaking,
    for an application chaos means introducing unusual, but not wholly unexpected,
    edge conditions to your application and seeing how it responds. This enables you
    to understand if your application is resilient to these edge conditions that may
    not have previously occurred during development of the application but may occur
    at some point during the operation of your application. Often our application
    development occurs during idealized conditions. Unfortunately, when exposed to
    the real world for long enough, these idealized conditions are challenged by errors
    and failures that were not present during initial development. These errors can
    include communication errors, network disconnections, storage problems, and application
    crashes and failures. Chaos testing is the art of artificially introducing these
    errors into your test environments and observing how well your application copes
    with them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌测试，顾名思义，是测试你的应用程序对世界混乱的响应能力。但是混沌究竟意味着什么呢？广义上来说，对于一个应用程序而言，混沌意味着引入不寻常但并非完全意外的边缘条件，观察应用程序如何响应。这使你能够了解你的应用程序是否能够对这些边缘条件具有弹性，这些条件可能在应用程序开发过程中之前从未发生过，但在应用程序运行期间某个时刻可能会发生。通常情况下，我们的应用程序开发都在理想化的条件下进行。不幸的是，长时间暴露在真实世界中时，这些理想化条件会面临在初步开发阶段不存在的错误和故障。这些错误包括通信错误、网络断开、存储问题以及应用程序崩溃和失败。混沌测试就是在测试环境中人为地引入这些错误，观察你的应用程序如何处理它们的艺术。
- en: Goals for Chaos Testing
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混沌测试的目标
- en: The goals for chaos testing are to introduce extreme conditions into your application’s
    environment and to observe how your application behaves in these conditions, especially,
    how it fails. It may seem unusual to test in such a way that failures are expected
    and desirable. While application failures in general are something that we try
    to avoid, it is far better to observe those failures in a test environment where
    customers or users are not impacted. We hope to observe failures when chaos testing
    because they offer an opportunity to fix those problems before they affect our
    users or customers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌测试的目标是将极端条件引入你的应用程序环境，并观察你的应用程序在这些条件下的行为，特别是它如何失败。以这种方式进行测试，似乎不寻常，因为我们预期并希望观察到失败。虽然总体上我们尽量避免应用程序的失败，但是在测试环境中观察这些失败要好得多，因为此时不会影响到客户或用户。我们希望通过混沌测试观察到失败，因为它们为我们在影响到用户或客户之前修复这些问题提供了机会。
- en: Of course the goal is to introduce a *realistic* level of error into our applications
    to see how they behave. Introducing a level of error that is not expected to ever
    occur in practice, while interesting, isn’t a great use of time or resources.
    Excessive levels of error can help us harden our applications for extreme environments,
    but if such extremes never occur, the effort to harden the application is wasted.
    Of course each application has a different level of both variability and resilience
    that is desired. The level of resiliency expected of a mobile game is dramatically
    less than the level of resilience expected of an aircraft or automobile. Understanding
    both the resilience requirements and expected environment for your application
    is a critical prerequisite for high-quality chaos testing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，目标是在我们的应用程序中引入一个*现实的*错误水平，以查看它们的行为。引入一个在实践中预计不会发生的错误水平，虽然有趣，但不是时间或资源的好用途。过高的错误水平可以帮助我们加固应对极端环境的应用程序，但如果这样的极端情况从未发生，加固应用程序的努力就是浪费的。当然，每个应用程序都有其所需的不同程度的可变性和弹性水平。对于移动游戏所期望的弹性水平远低于对飞机或汽车所期望的弹性水平。了解应用程序的弹性要求和预期环境对于高质量的混沌测试是至关重要的先决条件。
- en: Prerequisites for Chaos Testing
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混沌测试的先决条件
- en: To build a useful chaos test it is critical to understand the environmental
    conditions that your application may encounter. This includes both the expected
    frequency of errors and also the types of errors that may occur. For example,
    is your storage already resilient? If you are building a stateless application
    that uses cloud-backed storage as a service, you may not need to test your application
    for disk failures, but you will likely want to introduce chaos in the communication
    with the cloud storage solution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个有用的混沌测试，理解应用程序可能遇到的环境条件至关重要。这包括错误的预期频率以及可能发生的错误类型。例如，你的存储是否已经具备了弹性？如果你正在构建一个使用云支持的无状态应用程序，你可能不需要测试应用程序的硬盘故障，但你可能希望在与云存储解决方案的通信中引入混沌。
- en: Before beginning chaos testing think about the risks in your application, and
    identify places where you want to introduce error and at what frequency. When
    thinking about frequency, remember that we’re not trying to test for the average
    case. The average case is already well represented in your existing integration
    tests. Instead we are looking to simulate the kind of environment that may occur
    only once a year or once in a decade. You need to understand your application
    well enough to describe what is plausible.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始混沌测试之前，要考虑你的应用程序中存在的风险，并确定希望引入错误的位置及其频率。在考虑频率时，请记住我们并不试图测试平均情况。平均情况已经在您现有的集成测试中得到很好的代表。相反，我们希望模拟可能仅在一年一次或十年一次发生的环境。你需要充分了解你的应用程序，以描述什么是合理的。
- en: In terms of understanding your application, the other important prerequisite
    for chaos testing is high-quality monitoring for the correctness and behavior
    of your application. It is one thing to introduce chaos into your environment,
    but to make this chaos useful you also need to be able to observe the operation
    of your application with sufficient detail to determine the impact of the chaos
    and to identify the areas where your application needs hardening to be able to
    deal with the chaos. In general, this monitoring is necessary for any production
    application. In addition to its core contributions around resiliency, chaos testing
    can also be a good test to see if your monitoring and logging are sufficient to
    handle a real outage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解你的应用程序方面，混沌测试的另一个重要先决条件是对你的应用程序的正确性和行为进行高质量的监控。引入混沌到你的环境中是一回事，但要使这种混沌有用，你还需要能够以足够详细的方式观察你的应用程序的运行情况，以确定混沌的影响，并识别你的应用程序需要加固的地方，以能够处理混沌。总的来说，这种监控对于任何生产应用程序都是必需的。除了在弹性方面的核心贡献之外，混沌测试还可以是一个测试，看看你的监控和日志记录是否足以处理真实的故障。
- en: Chaos Testing Your Application’s Communication
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混沌测试你的应用程序通信
- en: One of the easiest ways to inject chaos into your application’s communication
    is to place a proxy between each client and your service. This proxy handles all
    the network traffic between your client and the server and injects random faults
    like extra latency, disconnects, or other errors. There are several different
    open source options for such a proxy, but one of the most popular is [ToxiProxy](https://oreil.ly/N8QNF),
    which was created by Shopify. The easiest way to add ToxiProxy to your system
    is to effectively run a ToxiProxy layer in front of each actual service in your
    cluster.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将混沌注入到应用程序通信中的最简单方法之一是在每个客户端和您的服务之间放置代理。该代理处理客户端和服务器之间的所有网络流量，并注入额外的延迟、断开连接或其他错误等随机故障。有几种不同的开源选项可以用作这种代理，但其中最受欢迎的之一是[ToxiProxy](https://oreil.ly/N8QNF)，由Shopify创建。将ToxiProxy添加到系统中的最简单方法是在集群中的每个实际服务前有效地运行一个ToxiProxy层。
- en: 'To achieve this, you first need to rename each service to which you want to
    add chaos. To see this in more detail, suppose you have a service named `backend`
    that serves traffic on port 8080. You can update a Kubernetes Service named `backend`
    to be called `backend-real`. Then you can create new Deployment of ToxiProxy Pods
    that are configured using the ToxiProxy command-line tool as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您首先需要将要添加混沌的每个服务重命名。以更详细地查看这一点，假设您有一个名为`backend`的服务，该服务在端口8080上提供流量。您可以更新名为`backend`的Kubernetes服务为`backend-real`。然后，您可以使用ToxiProxy命令行工具创建配置如下的新ToxiProxy
    Pods部署：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you build the Pod definition for this Deployment of ToxiProxy, you can
    run this command as a PostStart life-cycle hook. This command configures ToxiProxy
    to listen on port 8080 within the pod and then forward traffic to your actual
    backend service, which has the DNS name `backend-real`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为ToxiProxy的这个Pod部署构建Pod定义时，您可以将此命令作为PostStart生命周期钩子运行。此命令配置ToxiProxy在Pod内的8080端口上监听，然后将流量转发到您的实际后端服务，该服务具有DNS名称`backend-real`。
- en: Next you create a new service named `backend` to replace the one that you renamed,
    and you point this service at the Deployment of ToxiProxy Pods that you just created.
    In this way, any client in your application that communicates with `backend` will
    automatically start communicating with the chaos proxy instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以创建一个名为`backend`的新服务来替换您重命名的服务，并将此服务指向您刚刚创建的ToxiProxy Pods的部署。这样，您应用程序中与`backend`通信的任何客户端都会自动开始与混沌代理进行通信。
- en: 'Finally, you can start adding chaos to your application using the ToxiProxy
    command-line tool by issuing commands like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用ToxiProxy命令行工具向应用程序添加混沌，例如发出以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will add 2,000 milliseconds of latency to all traffic through this proxy.
    If you create multiple pods in your proxy Deployment, you will need to run this
    command for each pod, or automate it using scripts or code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向通过此代理的所有流量添加2000毫秒的延迟。如果您在代理部署中创建多个Pods，则需要为每个Pod运行此命令，或者使用脚本或代码进行自动化。
- en: Chaos Testing Your Application’s Operation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用程序操作的混沌测试
- en: In addition to testing the operation of your application when communication
    is flaky, it is also a good idea to test your application in situations where
    the infrastructure it is running on is flaky or overloaded.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在通信不稳定时测试应用程序的操作外，还可以考虑在基础设施运行不稳定或过载的情况下测试应用程序的运行情况。
- en: 'The easiest way to start with infrastructure failures is to simply delete pods.
    Starting with a single Deployment, you can delete random pods within the Deployment
    based on its label selector using a simple bash script:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 开始基础设施故障的最简单方法是简单地删除Pods。从单个Deployment开始，您可以根据其标签选择器删除Deployment中的随机Pods，使用一个简单的bash脚本：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of course if you’d rather have something more complete you can write code using
    the various [Kubernetes clients](https://oreil.ly/Ib1kp) out there or even an
    existing open source tool like [Chaos Mesh](https://chaos-mesh.org).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您更愿意拥有更完整的功能，您可以使用各种[Kubernetes客户端](https://oreil.ly/Ib1kp)编写代码，甚至使用现有的开源工具如[Chaos
    Mesh](https://chaos-mesh.org)。
- en: 'Once you have moved through all the microservice Deployments in your application,
    you can move on to deleting pods within the different services at once. This simulates
    a more broad outage. You can extend the previous script to randomly delete pods
    within a particular namespace as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了应用程序中所有微服务部署的移动，您可以继续一次性删除不同服务中的Pods。这会模拟更广泛的故障。您可以扩展先前的脚本，根据以下方式随机删除特定命名空间内Deployment的Pods：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, you can simulate complete failures in your infrastructure by causing
    entire nodes in your cluster to fail. There are a variety of ways to accomplish
    this. If you are running in a cloud-based Kubernetes, you can use cloud VM APIs
    to shut down or reboot a machine in your cluster. If you are running on physical
    infrastructure, you can literally pull the power plug on a particular machine,
    or reboot it by logging in and running commands. On both physical and virtual
    hardware you can also cause your kernel to panic by running `sudo sh -c 'echo
    c > /proc/sysrq-trigger'`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过导致集群中整个节点失败来模拟您基础设施中的完全故障。有多种方法可以实现这一点。如果您在基于云的 Kubernetes 上运行，您可以使用云
    VM API 来关闭或重新启动集群中的机器。如果您在物理基础设施上运行，您可以直接拔掉特定机器的电源插头，或者登录并运行命令来重新启动它。在物理和虚拟硬件上，您还可以通过运行
    `sudo sh -c 'echo c > /proc/sysrq-trigger'` 来使您的内核发生紧急情况。
- en: 'Here is a simple script that will randomly panic approximately 10% of the machines
    in a Kubernetes cluster:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的脚本，它将在 Kubernetes 集群中大约随机使 10% 的机器发生紧急情况：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Fuzz Testing Your Application for Security and Resiliency
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对应用程序进行模糊测试以确保安全性和弹性
- en: One final type of testing in the same spirit as chaos testing is fuzz testing.
    Fuzz testing is like chaos testing in that it introduces randomness and chaos
    into your application, but instead of introducing failures, fuzz testing focuses
    on introducing inputs that are technically legal but extreme in one way or another.
    For example, you might send an endpoint a legal JSON request but include duplicate
    fields or data that is especially long or contains random values. The goal of
    fuzz testing is to test the resiliency of your application to random extreme or
    malicious inputs. Fuzz testing is most often used in the context of security testing
    because random inputs can cause unexpected code paths to be executed and to introduce
    vulnerabilities or crashes. Fuzz testing can help you ensure that your application
    is resilient to chaos from malicious or erroneous input in addition to failures
    in the environment. Fuzz testing can be added at both the cluster service level
    as well as the unit test level.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与混沌测试精神相同的最后一种测试类型是模糊测试。模糊测试与混沌测试类似，因为它引入了随机性和混乱到您的应用程序中，但不是引入故障，而是专注于引入在某种方式上技术上合法但极端的输入。例如，您可以向端点发送一个合法的
    JSON 请求，但包含重复字段或特别长或包含随机值的数据。模糊测试的目标是测试您的应用程序对随机极端或恶意输入的弹性。模糊测试最常用于安全测试的背景中，因为随机输入可能导致执行意外代码路径并引入漏洞或崩溃。模糊测试可以帮助您确保您的应用程序对来自恶意或错误输入的混沌具有弹性，除了环境中的故障。模糊测试可以在集群服务级别和单元测试级别都添加。
- en: Summary
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Chaos testing is the art of introducing unexpected but not impossible conditions
    into the runtime of your application and observing what happens. Introducing potential
    errors and failures into an environment before any failures can impact actual
    usage of your application helps you identify problem areas before they become
    critical.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌测试是在应用程序运行时引入意外但不是不可能的条件的艺术，并观察发生了什么。在任何故障影响实际应用程序使用之前，将潜在错误和故障引入环境有助于您在它们变得关键之前识别问题区域。
- en: Load Testing
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载测试
- en: Load testing is used to determine how your application behaves under load. A
    load-testing tool is used to generate realistic application traffic that is equivalent
    to real production usage of your application. This traffic can either be artificially
    generated or recorded traffic from actual production traffic that is replayed.
    Load testing can be used to either identify areas that may become problems in
    the future or to ensure that new code and features do not cause regressions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试用于确定您的应用程序在负载下的行为。使用负载测试工具生成等同于您的应用程序真实生产使用的实际应用流量的真实应用流量。这种流量可以是人工生成的，也可以是从实际生产流量中记录并重放的流量。负载测试可用于识别未来可能成为问题的领域，或者确保新代码和功能不会引起退步。
- en: Goals for Load Testing
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载测试的目标
- en: The core goal for load testing is to understand how your application behaves
    under load. When you are building an application, it is generally exposed to occasional
    traffic from only a few users. This traffic is sufficient for understanding the
    correctness of the application, but it doesn’t help us understand how the application
    behaves under realistic load. Thus, to understand how your application works when
    deployed in production, load testing is necessary.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试的核心目标是了解你的应用在负载下的行为。当你构建一个应用时，通常只有少数用户偶尔访问。这些流量足以理解应用的正确性，但无法帮助我们了解应用在实际负载下的表现。因此，为了了解你的应用在生产环境中的运行情况，负载测试是必要的。
- en: 'Two fundamental uses of load testing are estimating current capacity and regression
    prevention. Regression prevention is the use of load testing to ensure that a
    new release of software can sustain the same load as the previous version of the
    software. Whenever we roll out a new version of our software there is new code
    and configuration in the release (if there wasn’t, then what is the point of the
    release?). While these code changes introduce new features and fix bugs, they
    can also introduce performance regressions: the new version cannot serve the same
    level of load as the previous version. Of course sometimes these performance regressions
    are known and expected; for example, a new feature may have made a computation
    more complex and thus slower, but even in such cases, load testing is necessary
    to determine how the infrastructure (e.g., the number of pods, the resources they
    require) needs to be scaled up to sustain production traffic.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试的两个基本用途是估算当前容量和预防回归。预防回归是利用负载测试确保新版本软件可以与之前版本承受相同负载的使用。每次我们发布软件的新版本时，都会有新的代码和配置（如果没有，那发布的意义何在？）。虽然这些代码变更引入了新功能并修复了错误，但它们也可能引入性能退化：新版本无法像旧版本那样提供相同水平的负载。当然，有时这些性能退化是已知且预期的；例如，新功能可能使计算变得更复杂，因此更慢，但即使在这种情况下，负载测试也是必要的，以确定基础设施（例如
    pod 数量、它们需要的资源）需要如何扩展以支持生产流量。
- en: In contrast to regression prevention, which is used to catch problems newly
    introduced into your application, predictive load testing is used to anticipate
    problems before they occur. For many services, there is a steady growth in the
    use of the service. Each month there are more users and more requests to your
    service. In general this is a good thing, but keeping those users happy means
    continuing to improve your infrastructure to keep up with the new load. Predictive
    load testing takes the historical growth trends from your application and uses
    them to test your application as if it were operating in the future. For example,
    if your application’s traffic is growing 10% each month, you might run a predictive
    load test at 110% of the current peak traffic to simulate how your application
    will work in the next month. While scaling up your application can be as easy
    as adding more replicas and more resources, often fundamental bottlenecks in your
    application require rearchitecting. Predictive load testing allows you to anticipate
    the future and perform these changes without the emergency of a user-facing outage
    due to increased load.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与回归预防相比，后者用于捕获新引入到应用程序中的问题，预测性负载测试用于在问题发生之前预测。对于许多服务来说，服务的使用是稳定增长的。每个月都会有更多的用户和对你的服务的请求。总体而言，这是一件好事，但是要保持这些用户的满意意味着不断改进基础设施以跟上新的负载。预测性负载测试利用应用程序的历史增长趋势，并使用它们来测试你的应用程序，仿佛它在未来运行一样。例如，如果你的应用程序流量每个月增长10%，你可以在当前峰值流量的110%处运行预测性负载测试，模拟你的应用程序在下个月的工作情况。虽然扩展你的应用程序可能只需添加更多的副本和资源，但通常应用程序中的基本瓶颈需要重新架构。预测性负载测试允许你预见未来并进行这些更改，而不会因负载增加而导致用户面临的紧急故障。
- en: Predictive load testing can also be used to anticipate how an application will
    behave prior to launch. Rather than using historical information, you can use
    your predictions about usage at launch to ensure that such a launch is successful
    and not a disaster.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 预测性负载测试也可以用于预测应用在发布前的行为。与使用历史信息不同，你可以使用对发布时使用情况的预测来确保发布成功而不是灾难。
- en: Prerequisites for Load Testing
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载测试的先决条件
- en: Load testing is used to ensure that your application can perform while operating
    under significant load. Further, like chaos testing, load testing can also introduce
    failure conditions in your application due to that load. Consequently, load testing
    shares the same prerequisites as chaos testing around application observability.
    To successfully use a load test, you need to be able to verify that your application
    is operating correctly and have enough information to gain insight into where
    and why failures occur if they do.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试用于确保您的应用程序在承受重大负载时仍能正常运行。此外，与混沌测试类似，负载测试也可能因负载而在您的应用程序中引入故障条件。因此，负载测试与应用程序的可观察性具有相同的先决条件。要成功使用负载测试，您需要验证应用程序是否正常运行，并且有足够的信息来了解故障发生的位置和原因（如果有的话）。
- en: In addition to the core observability of your application, another critical
    prerequisite for load testing is the ability to generate realistic load for your
    test. If your load test doesn’t closely mimic real-world user behaviors, then
    it is of little use. As a concrete example, imagine if your load test continuously
    makes repeated requests for a single user. In many applications, such traffic
    will produce an unrealistic cache hit rate, and your load test will seem to show
    an ability to handle large amounts of load that is not possible under more realistic
    traffic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用程序的核心可观察性之外，负载测试的另一个关键先决条件是能够为您的测试生成真实的负载。如果您的负载测试不能紧密模拟真实世界用户的行为，那么它将毫无用处。具体来说，想象一下，如果您的负载测试不断重复向单个用户发出请求，那么在许多应用程序中，这样的流量将导致不现实的缓存命中率，并且您的负载测试将似乎展示出一种在更真实的流量下是不可能实现的处理大量负载的能力。
- en: Generating Realistic Traffic
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成真实流量
- en: Methods for generating real-world traffic patterns for your application vary
    depending on your application. For certain types of more read-only sites, for
    example, a news site, it may be sufficient to repeatedly access each of the different
    pages using some sort of probability distribution. But for many applications,
    especially those that involve both reading and writing operations, the only way
    to generate a realistic load test is to record real-world traffic and play it
    back. One of the easiest ways to do this is to write the complete details of each
    HTTP request to a file, and then resend those requests back to the server at a
    later time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为您的应用程序生成真实世界的流量模式，方法会因应用程序的类型而异。例如，对于某些更多只读操作的网站，比如新闻网站，仅仅使用某种概率分布重复访问每个不同页面可能就足够了。但是对于许多应用程序，特别是涉及读写操作的应用程序，生成真实的负载测试的唯一方法是记录真实世界的流量并回放。其中一种最简单的方法是将每个
    HTTP 请求的完整细节写入文件，然后稍后重新发送这些请求到服务器。
- en: Unfortunately, such an approach can have complications. The first and foremost
    consequence of recording all the requests to your application is user privacy
    and security. In many cases requests to an application contain both private information
    as well as security tokens. If you record all this information to a file for playback,
    you must be very, very careful in handling these files to ensure that user privacy
    and security are respected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法可能会带来复杂性。将所有请求记录到应用程序可能涉及用户隐私和安全的首要后果。在许多情况下，向应用程序发出的请求同时包含私人信息和安全令牌。如果将所有这些信息记录到文件以供回放，则必须非常小心地处理这些文件，以确保尊重用户的隐私和安全性。
- en: Another challenge with recording and playing back actual user requests has to
    do with the timeliness of the requests themselves. If there is a time component
    to the requests, for example, search queries about the latest news events, these
    requests will have a very different behavior several weeks (or months) after those
    events have occurred. There will be many fewer messages related to old news. Timeliness
    also affects the correct behavior of your application. Requests often contain
    security tokens and if you are doing security properly, those tokens are short
    lived. This means that recorded tokens will likely not work correctly when verified.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记录并回放实际用户请求的另一个挑战与请求本身的及时性有关。例如，如果请求包含了关于最新新闻事件的搜索查询，这些请求在几周（或几个月）后的行为将会非常不同。旧新闻相关的消息会大大减少。及时性还会影响应用程序的正确行为。请求通常包含安全令牌，如果您在正确处理安全性，这些令牌的生命周期很短。这意味着验证时记录的令牌可能无法正确工作。
- en: Finally, when requests write data to backend storage systems, replaying requests
    that modify storage must be performed in a copy or snapshot of the production
    storage infrastructure. If you are not careful about how you set this up, you
    can cause significant problems with customer data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当请求向后端存储系统写入数据时，修改存储的请求必须在生产存储基础设施的副本或快照中执行。如果在设置这一点时不小心，可能会导致客户数据的重大问题。
- en: For all these reasons, simply recording and playing back requests, though easy,
    is not a best practice. Instead the more useful way to use requests is to build
    up a model of the ways in which your service is used. How many read requests?
    For what resources? How many writes? Using this model you can generate synthetic
    load that has realistic characteristics.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有这些原因，简单地记录和回放请求虽然简单，但不是最佳实践。相反，更有用的使用请求的方式是建立服务使用方式的模型。有多少读请求？针对哪些资源？有多少写入操作？使用这个模型，您可以生成具有现实特征的合成负载。
- en: Load Testing Your Application
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试您的应用程序负载
- en: Once you have generated the requests to power your load test, it is simply a
    matter of applying that load to your service. Unfortunately, it is rarely that
    simple. In most real-world applications there are databases and other storage
    systems involved. To correctly simulate your application under load, you also
    need to write into storage systems, but not to the production data store since
    this is artificial load. Thus, to correctly load test your application, you need
    to be able to turn up a true copy of your application with all its dependencies.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了用于驱动负载测试的请求，将这种负载应用到您的服务就是一件简单的事情。不幸的是，实际应用中很少会这么简单。在大多数实际应用中，涉及到数据库和其他存储系统。为了正确模拟承受负载的应用程序，您还需要写入存储系统，但不能写入生产数据存储，因为这是人为负载。因此，要正确进行应用程序负载测试，您需要能够启动一个真实的应用程序副本及其所有依赖关系。
- en: Once your application clone is up and running, it is a matter of sending all
    the requests. It turns out large-scale load testing is also a distributed systems
    problem. You will want to use a large number of different pods to send load onto
    your application. This is to ensure an even distribution of requests through the
    load balancers and to make it feasible to send more load than a single pod’s network
    can support. One of the choices you will need to make is whether to run these
    load testing pods within the same cluster as your application or in a separate
    cluster. Running the pods within the same cluster maximizes the load that you
    can send to your application, but it does exercise the edge load balancers that
    bring traffic from the internet onto your application. Depending on which parts
    of your application you wish to test, you may want to run the load within the
    cluster, outside of the cluster, or both.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用克隆运行起来，发送所有请求就成了问题。事实证明，大规模负载测试也是分布式系统问题。您将希望使用大量不同的Pod来向您的应用程序发送负载。这样可以通过负载均衡器均匀分发请求，并使得发送超过单个Pod网络支持负载成为可能。您需要做出的选择之一是是否将这些负载测试Pod运行在与您的应用程序相同的集群中，还是在单独的集群中运行。在同一集群内运行Pod最大化了您可以发送到应用程序的负载，但它确实会对从互联网上引入流量到您的应用程序的边缘负载均衡器进行测试。根据您希望测试的应用程序的哪些部分，您可能希望在集群内运行负载，集群外运行，或者两者兼而有之。
- en: Two popular tools for running distributed load tests in Kubernetes are [JMeter](https://oreil.ly/MXBgj)
    and [Locust](https://locust.io). Both provide ways to describe the load that you
    want to send to your service and allow you to deploy distributed load test bots
    to Kubernetes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中运行分布式负载测试的两个流行工具是[JMeter](https://oreil.ly/MXBgj)和[Locust](https://locust.io)。两者都提供了描述要发送到您的服务的负载的方式，并允许您部署分布式负载测试机器人到Kubernetes中。
- en: Tuning Your Application Using Load Tests
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用负载测试调整您的应用程序
- en: 'In addition to using load tests to prevent performance regressions and to anticipate
    future performance problems, load testing can also be used to optimize the resource
    utilization of your application. For any given service multiple variables can
    be tuned and can impact system performance. For the purposes of this discussion
    we consider three: number of pods, number of cores, and memory.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用负载测试来防止性能回归和预测未来的性能问题外，负载测试还可以用于优化您的应用程序的资源利用率。对于任何给定的服务，可以调整多个变量，并且可以影响系统性能。对于本讨论的目的，我们考虑了三个变量：Pod的数量，核心数和内存。
- en: 'At first it might seem that an application would perform the same given the
    same number of replicas times cores. That is, an application with five pods, each
    with three cores, would perform the same as an application with three pods, each
    with five cores. In some cases this is true, but in many cases it is not; the
    specific details of the service and location of its bottlenecks often cause differences
    in behavior that are hard to anticipate. For example, an application built in
    a language like Java, dotnet, or Go that provides garbage collection: with one
    or two cores, the application is going to tune the garbage collector significantly
    differently than if it has many cores.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，似乎一个应用在相同数量的副本乘以核心数的情况下表现相同。也就是说，一个每个有三个核心的五个pod的应用与一个每个有五个核心的三个pod的应用表现相同。在某些情况下，这是正确的，但在许多情况下，情况并非如此；服务的具体细节和其瓶颈的位置通常会导致行为上的差异，这些差异很难预料。例如，使用Java、dotnet或Go等语言构建的应用程序提供垃圾收集：如果只有一两个核心，应用程序会对垃圾收集器进行显着不同的调整，而如果有多个核心，则会有所不同。
- en: The same thing is true of memory. More memory means that more things can be
    kept in cache, and this often leads to more performance, but this benefit has
    an asymptotic limit. You cannot simply throw more memory at a service and expect
    it to continue to improve in performance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于内存。更多的内存意味着可以将更多内容保留在缓存中，这通常会带来更好的性能，但这种好处有一个渐近限制。您不能简单地为服务抛出更多内存，并期望它继续提高性能。
- en: Often times the only way to understand how your application will behave under
    different configurations is to actually do the experimentation. To do this properly
    you can set up an experimental set of configurations with different values for
    pods, cores, and memory and run each configuration through a load test. Using
    the data from these experiments you often can identify patterns of behavior that
    can drive insight into the particular details of your system’s performance, and
    you can use the results to select the most efficient configuration for your service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，了解你的应用在不同配置下的行为方式的唯一方法是实际进行实验。要做到这一点，你可以设置一组实验性配置，其中包含不同的pod、核心和内存值，并对每个配置运行负载测试。通过这些实验的数据，你通常可以识别出行为模式，这些模式可以洞察系统性能的特定细节，并且你可以使用结果来选择最高效的服务配置。
- en: Summary
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Performance is a critical part of building an application that delights users.
    Load testing ensures that you do not introduce regressions that impact performance
    and lead to poor user experiences. Load testing can also serve as a time machine,
    enabling you to imagine your application’s behavior in the future and make changes
    to your architecture to support additional growth. Load testing can also help
    you understand and optimize your resource usage, lowering costs and improving
    efficiency.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是构建令用户满意的应用程序的关键部分。负载测试确保您不会引入影响性能并导致用户体验不佳的退化。负载测试还可以作为一台时光机，让您可以想象应用程序在未来的行为，并对架构进行更改以支持额外的增长。负载测试还可以帮助您理解和优化资源使用，降低成本并提高效率。
- en: Experiments
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验
- en: In contrast to chaos testing and load testing, experiments are used not to discover
    problems in your service’s architecture and operation but to identify ways to
    improve how your users use your service. An experiment is a long-running change
    to your service, generally in the user experience, in which a small percentage
    of users (for example, 1% of all traffic) receive a slightly different experience.
    From examining the difference between the control (the group with no changes)
    and the experiment (the group that had a different experience) you can understand
    the impact of the changes and decide whether to continue to experiment or to roll
    out the changes more broadly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与混沌测试和负载测试相比，实验不是用于发现服务架构和操作中的问题，而是用于识别改进用户如何使用您的服务的方式。实验是对您的服务的长期更改，通常涉及用户体验，在这种更改中，一小部分用户（例如，所有流量的1%）将获得稍有不同的体验。通过检查控制组（没有更改的组）和实验组（经历了不同体验的组）之间的差异，您可以理解更改的影响，并决定是否继续进行实验或广泛推广更改。
- en: Goals for Experiments
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验的目标
- en: When we build a service, we build it with a goal in mind. That goal more often
    than not is to provide something that is useful, easy to use, and pleasing to
    our customers or users. But how can we know if we have achieved that goal? It’s
    relatively easy to see that our site breaks in the presence of chaos or that it
    can only handle a small amount of load before failing, but understanding how a
    user experiences our services can be tricky to determine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建一个服务时，我们构建它是有一个目标的。那个目标往往是为用户或客户提供一个有用、易于使用和令人愉悦的东西。但我们怎么知道我们是否实现了这个目标呢？我们很容易看到我们的网站在混乱环境中会崩溃，或者在负载量较小时会失败，但了解用户体验我们服务的方式可能会比较棘手。
- en: 'Several traditional methods for understanding user experience include surveys,
    in which you ask users how they feel about the current service. While this can
    be useful in understanding the current performance of our service, it is much
    harder to use surveys to predict the impact of future changes. Much like performance
    regressions, it is far better to know the impact *before* the change is rolled
    out everywhere. That is the main goal of any experiment: to learn with minimal
    impact on our users’ experience.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 几种传统的了解用户体验的方法包括调查，通过这些调查您可以询问用户对当前服务的感受。虽然这在理解我们服务的当前表现方面很有用，但要使用调查来预测未来变化的影响则更加困难。就像性能回归一样，最好在变更完全部署之前就知道影响。这是任何实验的主要目标：以最小影响学习我们用户体验。
- en: Prerequisites for an Experiment
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验的先决条件
- en: Just like when we were kids in a science fair, every good experiment starts
    with a good hypothesis, and that is a natural prerequisite for our service experiments
    also. There is some change that we are thinking about making, and we need to have
    a guess as to what impact it will have on user experience.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们小时候在科学展览会上一样，每一个好的实验都始于一个好的假设，这也是我们服务实验的一个自然前提。我们考虑要进行某种变化，我们需要猜测它对用户体验的影响。
- en: Of course to understand the impact on user experience, we also need to be able
    to measure the user experience. This data can come in the form of the surveys
    mentioned previously, through which you can gather metrics like satisfaction (“please
    rate us one through five”) or net promoter score (“how likely are you to recommend
    this to a friend?”). Or it can come from passive metrics associated with user
    behavior (“how long did they spend on our site?” or “how many pages did they click
    on?” etc.).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了理解用户体验的影响，我们还需要能够衡量用户体验。这些数据可以通过之前提到的调查来获取，通过这些调查可以收集到像满意度（“请您评价我们一到五分”）或净推荐值（“您多有可能向朋友推荐此服务？”）等指标。或者可以从与用户行为相关的被动指标中获取（“他们在我们网站上花费了多少时间？”或“他们点击了多少个页面？”等）。
- en: Once you have a hypothesis and a way to measure user experience, you’re ready
    to begin the experiment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了假设和衡量用户体验的方法，您就可以开始实验了。
- en: Setting Up an Experiment
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验设置
- en: There are two different ways to set up an experiment. The approach you take
    depends on the specific things being tested. You can include multiple possible
    experiences in a single service, or you can deploy two copies of your service
    and use a service mesh to direct traffic between them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的方式可以设置实验。您采取的方法取决于正在测试的具体内容。您可以在单个服务中包含多种可能的体验，或者部署两个服务副本并使用服务网格来在它们之间分配流量。
- en: The first approach is to check both versions of the code into your release binary
    and switch between the experiment and control using some property of the requests
    that your service is receiving. You can use HTTP headers, cookies, or query parameters
    to enable users to explicitly opt in to the experiment. Alternatively you can
    use characteristics of the requests, such as the source IP, to randomly select
    users for your experiments. For example, you could choose people for the experiments
    whose IP addresses ended in one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是将代码的两个版本都提交到您的发布二进制文件中，并使用服务收到请求的某些属性来在实验组和对照组之间进行切换。您可以使用HTTP头部、cookie或查询参数来让用户明确选择参与实验。或者您可以使用请求的特征，如源IP，随机选择用户进行实验。例如，您可以选择IP地址以某个数字结尾的用户进行实验。
- en: A common way to implement experiments is to use explicit feature flagging where
    a user decides to opt in to an experiment by supplying the query parameter or
    cookie that turns on the experiment. This is a good way to allow specific customers
    to try new functionality or to demonstrate a new feature without releasing it
    broadly. Feature flags can also be used to rapidly turn features on or off in
    the case of instability. Numerous open source projects, for example [Flagger](https://flagger.app),
    can be used to implement feature flagging.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实施实验的常见方式是使用显式功能标志，用户通过提供打开实验的查询参数或Cookie来选择参与实验。这是允许特定客户尝试新功能或演示新功能而不广泛发布的好方法。功能标志还可以在不稳定情况下快速启用或禁用功能。许多开源项目，例如
    [Flagger](https://flagger.app)，可以用于实施功能标志。
- en: The benefit of placing the experiment in the same binary as your control code
    is that it is simplest to roll it out into production, but this simplicity also
    leads to two drawbacks. The first is that if the experimental code is unstable
    and crashes, it can also impact your production traffic. The other is that because
    any changes are tied to a complete release of your service it is much slower to
    make changes to update the experiment or to roll out new experiments.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将实验放置在与控制代码相同的二进制文件中的好处在于，将其推广到生产环境是最简单的，但这种简单性也带来了两个缺点。第一个是，如果实验代码不稳定并且崩溃，它也可能影响您的生产流量。另一个是，因为任何更改都与服务的完整发布相关联，因此更新实验或推出新实验的速度要慢得多。
- en: The second approach to experiments is to deploy two (or more) different versions
    of your service. In this approach, you have the control production service that
    receives the bulk of the traffic and a separate experimental deployment of your
    service that receives only a fraction of the traffic. You can use a service mesh
    (described in [Chapter 9](ch09.html#networking_network_security_and_service_mesh))
    to route a small percentage of traffic to this experimental deployment instead
    of the production deployment. Though this approach is more complex to implement,
    it is significantly more agile and robust than including experimental code in
    your production binary. Because it requires a completely new deployment of code
    the upfront cost of setting up an experiment is increased, but because it has
    no impact on anything except the experimental traffic, you can easily deploy new
    versions of the experiment (or even multiple versions of the experiment) at any
    time without impacting the bulk of your traffic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 实验的第二种方法是部署两个（或更多）不同版本的服务。在这种方法中，您有控制生产服务接收大部分流量，以及一个单独的实验部署服务，只接收部分流量。您可以使用服务网格（在
    [第9章](ch09.html#networking_network_security_and_service_mesh) 中描述）将小部分流量路由到此实验部署，而不是生产部署。尽管这种方法在实施上更复杂，但比将实验代码包含在生产二进制文件中要更灵活和更健壮。因为它需要完全新的代码部署，设置实验的前期成本增加了，但因为它只影响实验流量，所以您可以随时轻松地部署新版本的实验（甚至多个版本的实验），而不影响大部分流量。
- en: Additionally, because the service mesh can measure whether requests are successful,
    if the experimental code starts failing it can quickly be removed from use and
    user impact is minimized. Of course detecting these failures can be a challenge.
    You need to make sure that the experimental infrastructure is monitored independently
    from the standard production monitoring; otherwise the experimental failures may
    be lost in successful requests that are processed by the current production infrastructure.
    Ideally the name of the pod or the deployment provides sufficient context to determine
    if the monitoring signals are from production or an experiment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于服务网格可以衡量请求是否成功，如果实验代码开始失败，可以迅速将其从使用中移除，并最小化用户影响。当然，检测这些失败可能是一个挑战。您需要确保实验基础设施独立监控，而不是与标准生产监控混为一谈；否则，实验失败可能会在当前生产基础设施处理的成功请求中丢失。理想情况下，Pod
    的名称或部署应提供足够的上下文，以确定监控信号是来自生产还是实验。
- en: In general, using separate deployments and some sort of traffic router like
    a service mesh is the best practice for experiments, but it is a lot of infrastructure
    to set up. For your initial experiments, or if you are a small team that is already
    fairly agile, it may be that checking in experimental code is the easiest path
    to experimentation and iteration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使用单独的部署以及某种流量路由器如服务网格是进行实验的最佳实践，但这需要大量的基础设施来设置。对于你的初步实验，或者如果你是一个已经相当敏捷的小团队，可能直接提交实验性代码是最简便的实验和迭代路径。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Experiments enable you to understand the impact of changes on your users’ experience
    before those changes are rolled out to the broad user base. Experiments play a
    critical role in helping us quickly understand what changes are possible and how
    we can update our services to better serve our users. Experiments make the improvement
    of our services easier, quicker, and safer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 实验能让你在将更改推广到广泛用户群之前了解这些变化对用户体验的影响。实验在帮助我们迅速了解可行的变更及如何更新我们的服务以更好地为用户服务方面起到关键作用。实验使得改进我们的服务变得更加容易、快速和安全。
- en: Chaos Testing, Load Testing, and Experiments Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混沌测试、负载测试和实验总结
- en: In this chapter we’ve covered a variety of different ways to learn more about
    your service to make it more resilient, more performant, and more useful. Just
    as testing your code with unit tests is a critical part of the software development
    process, testing your service with chaos, load, and experiments is a critical
    part of service design and operation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了多种学习服务更加弹性、性能更好和更有用的不同方式。正如使用单元测试来测试你的代码是软件开发过程的关键部分一样，使用混沌、负载和实验来测试你的服务是服务设计和运营的关键部分。
