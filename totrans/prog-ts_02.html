<html><head></head><body><section data-pdf-bookmark="Chapter 2. TypeScript: A 10_000 Foot View" data-type="chapter" epub:type="chapter"><div class="chapter" id="typeScript_overview">&#13;
<h1><span class="label">Chapter 2. </span>TypeScript: A 10_000 Foot View</h1>&#13;
&#13;
&#13;
<p>Over the next few chapters, I’ll introduce the TypeScript language, give you an overview of how the TypeScript Compiler (TSC) works, and take you on a tour of TypeScript’s features and the patterns you can develop with them. We’ll start with the compiler.<a data-primary="TypeScript" data-secondary="compiler" data-type="indexterm" id="ix_TScmpl"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Compiler" data-type="sect1"><div class="sect1" id="idm46304995927048">&#13;
<h1>The Compiler</h1>&#13;
&#13;
<p>Depending on what programming languages you worked with in the past (that is, before you decided to buy this book and commit to a life of type safety), you’ll have a different understanding of how programs work. The way TypeScript works is unusual compared to other mainstream languages like JavaScript or Java, so it’s important that we’re on the same page before we go any further.</p>&#13;
&#13;
<p>Let’s start broad: programs are files that contain a bunch of text written by you, the  programmer.<a data-primary="compilers" data-secondary="TypeScript compiler" data-type="indexterm" id="ix_cmplTS"/> That text is parsed by a special program called a <em>compiler</em>, which transforms it into an <em>abstract syntax tree (AST)</em>, a data structure that ignores things like whitespace, comments, and where you stand on the tabs versus spaces debate.<a data-primary="AST (abstract syntax tree)" data-type="indexterm" id="idm46304995652568"/><a data-primary="abstract syntax tree (AST)" data-type="indexterm" id="idm46304990590312"/> The compiler then converts that AST to a lower-level representation called <em>bytecode</em>.<a data-primary="bytecode" data-type="indexterm" id="idm46304994226760"/> You can feed that bytecode into another program called a <em>runtime</em> to evaluate it and get a result.<a data-primary="runtime" data-type="indexterm" id="idm46304994173656"/> So when you run a program, what you’re really doing is telling the runtime to evaluate the bytecode generated by the compiler from the AST parsed from your source code. The details vary, but for most languages this is an accurate high-level view.</p>&#13;
&#13;
<p>Once again, the steps are:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Program is parsed into an AST.</p>&#13;
</li>&#13;
<li>&#13;
<p>AST is compiled to bytecode.</p>&#13;
</li>&#13;
<li>&#13;
<p>Bytecode is evaluated by the runtime.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Where TypeScript is special is that instead of compiling straight to bytecode, TypeScript compiles to… JavaScript code! You then run that JavaScript code like you normally would—in your browser, or with NodeJS, or by hand with a paper and pen (for anyone reading this after the machine uprising has begun).</p>&#13;
&#13;
<p>At this point you may be thinking: “Wait! In the last chapter you said TypeScript makes my code safer! When does that happen?”</p>&#13;
&#13;
<p>Great question. I actually skipped over a crucial step: after the TypeScript Compiler generates an AST for your program—but before it emits code—it <em>typechecks</em> your code.<a data-primary="typechecking" data-type="indexterm" id="idm46304989964536"/><a data-primary="typechecker" data-type="indexterm" id="idm46304995067960"/></p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304990924024">&#13;
<h5>Typechecker</h5>&#13;
<p>A special program that verifies that your code is typesafe.</p>&#13;
</div></aside>&#13;
&#13;
<p>This typechecking is the magic behind TypeScript. It’s how TypeScript makes sure that your program works as you expect, that there aren’t obvious mistakes, and that the cute barista across the street really will call you back when they said they would. (Don’t worry, they’re probably just busy.)</p>&#13;
&#13;
<p>So if we include typechecking and JavaScript emission, the process of compiling TypeScript now looks roughly like <a data-type="xref" href="#ch02-compilation-pipeline">Figure 2-1</a>:</p>&#13;
&#13;
<figure><div class="figure" id="ch02-compilation-pipeline">&#13;
<img alt="prts 0201" src="assets/prts_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Compiling and running TypeScript</h6>&#13;
</div></figure>&#13;
&#13;
<p>Steps 1–3 are done by TSC, and steps 4–6 are done by the JavaScript runtime that lives in your browser, NodeJS, or whatever JavaScript engine you’re using.<a data-primary="TSC compiler" data-type="indexterm" id="idm46304989860424"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>JavaScript compilers and runtimes tend to be smushed into a single program called an <em>engine</em>; as a programmer,<a data-primary="JavaScript" data-secondary="engine" data-type="indexterm" id="idm46304995715032"/> this is what you’ll normally interact with. <a data-primary="engines (JavaScript)" data-type="indexterm" id="idm46304995713896"/>It’s how V8 (the engine powering NodeJS, Chrome, and Opera), SpiderMonkey (Firefox), JSCore (Safari), and Chakra (Edge) work, and it’s what gives JavaScript the appearance of being an <em>interpreted</em> language.<a data-primary="interpreted languages" data-type="indexterm" id="idm46304995671176"/></p>&#13;
</div>&#13;
&#13;
<p>In this process, steps 1–2 use your program’s types; step 3 does not. That’s worth reiterating: <em>when TSC compiles your code from TypeScript to JavaScript, it won’t look at your types</em>. That means your program’s types will never affect your program’s generated output, and are only used for typechecking. This feature makes it foolproof to play around with, update, and improve your program’s types, without risking breaking your application.<a data-primary="compilers" data-secondary="TypeScript compiler" data-startref="ix_cmplTS" data-type="indexterm" id="idm46304993327336"/><a data-primary="TypeScript" data-secondary="compiler" data-startref="ix_TScmpl" data-type="indexterm" id="idm46304993326120"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Type System" data-type="sect1"><div class="sect1" id="idm46304990937640">&#13;
<h1>The Type System</h1>&#13;
&#13;
<p>Modern languages have all<a data-primary="type systems" data-type="indexterm" id="ix_typsys"/><a data-primary="TypeScript" data-secondary="type system" data-type="indexterm" id="ix_TStypsys"/> sorts of different <em>type systems</em>.</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304995712328">&#13;
<h5>Type system</h5>&#13;
<p>A set of rules that a typechecker uses to assign types to your program.</p>&#13;
</div></aside>&#13;
&#13;
<p>There are generally two kinds of type systems: type systems in which you have to tell the compiler what type everything is with explicit syntax, and type systems that infer the types of things for you automatically. Both approaches have trade-offs.<sup><a data-type="noteref" href="ch02.html#idm46304995709880" id="idm46304995709880-marker">1</a></sup></p>&#13;
&#13;
<p>TypeScript is inspired by both kinds of type systems: you can explicitly annotate your types, or you can let TypeScript infer most of them for you.</p>&#13;
&#13;
<p>To explicitly signal to TypeScript what your types are, use annotations. Annotations take the form <em>value: type</em> and tell the typechecker, “Hey! You see this <em>value</em> here?<a data-primary="value: type annotations" data-type="indexterm" id="idm46304996125048"/><a data-primary="variables" data-secondary="with explicitly annotated types" data-type="indexterm" id="idm46304996124312"/> Its type is <em>type</em>.” Let’s look at a few examples (the comments following each line are the actual types inferred by TypeScript):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code>: <code class="kt">number</code> <code class="o">=</code> <code class="mi">1</code>                <code class="c1">// a is a number</code>&#13;
<code class="kd">let</code> <code class="nx">b</code>: <code class="kt">string</code> <code class="o">=</code> <code class="s1">'hello'</code>          <code class="c1">// b is a string</code>&#13;
<code class="kd">let</code> <code class="nx">c</code>: <code class="kt">boolean</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="kc">true</code><code class="p">,</code> <code class="kc">false</code><code class="p">]</code> <code class="c1">// c is an array of booleans</code></pre>&#13;
&#13;
<p>And if you want TypeScript to infer your types for you, just leave them off and let <a data-primary="variables" data-secondary="with implicitly inferred types" data-type="indexterm" id="idm46304996122008"/>TypeScript get to work:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code>                        <code class="c1">// a is a number</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="s1">'hello'</code>                  <code class="c1">// b is a string</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="p">[</code><code class="kc">true</code><code class="p">,</code> <code class="kc">false</code><code class="p">]</code>            <code class="c1">// c is an array of booleans</code></pre>&#13;
&#13;
<p>Right away, you’ll notice how good TypeScript is at inferring types for you.<a data-primary="inferring types" data-type="indexterm" id="idm46304996090152"/> If you leave off the annotations, the types are the same! Throughout this book, we will use annotations only when necessary, and let TypeScript work its inference magic for us whenever possible.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In general, it is good style to let TypeScript infer as many types as it can for you, keeping explicitly typed code to a minimum.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TypeScript Versus JavaScript" data-type="sect2"><div class="sect2" id="idm46304996087896">&#13;
<h2>TypeScript Versus JavaScript</h2>&#13;
&#13;
<p>Let’s take a deeper look at TypeScript’s type system, and  how it compares to JavaScript’s type system. <a data-type="xref" href="#comparing-type-systems">Table 2-1</a> presents an overview. <a data-primary="type systems" data-secondary="comparison for JavaScript and TypeScript" data-type="indexterm" id="ix_typsyscomp"/><a data-primary="TypeScript" data-secondary="type system" data-tertiary="comparison to JavaScript" data-type="indexterm" id="ix_TStypsysJS"/><a data-primary="JavaScript" data-secondary="type system, comparison to TypeScript" data-type="indexterm" id="ix_JStypsys"/>A good understanding of the differences is key to building a mental model of how TypeScript works.</p>&#13;
<table id="comparing-type-systems">&#13;
<caption><span class="label">Table 2-1. </span>Comparing JavaScript’s and TypeScript’s type systems</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type system feature</th>&#13;
<th>JavaScript</th>&#13;
<th>TypeScript</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>How are types bound?</strong></p></td>&#13;
<td><p>Dynamically</p></td>&#13;
<td><p>Statically</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Are types automatically converted?</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>No (mostly)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>When are types checked?</strong></p></td>&#13;
<td><p>At runtime</p></td>&#13;
<td><p>At compile time</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>When are errors surfaced?</strong></p></td>&#13;
<td><p>At runtime (mostly)</p></td>&#13;
<td><p>At compile time (mostly)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How are types bound?" data-type="sect3"><div class="sect3" id="idm46304996011752">&#13;
<h3>How are types bound?</h3>&#13;
&#13;
<p>Dynamic type binding means that JavaScript needs to actually run your program to know the types of things in it. JavaScript doesn’t know your types before running your program.<a data-primary="types" data-secondary="binding, JavaScript versus TypeScript" data-type="indexterm" id="idm46304996010264"/></p>&#13;
&#13;
<p>TypeScript is a <em>gradually typed</em> language.<a data-primary="gradually typed languages" data-type="indexterm" id="idm46304996008392"/> That means that TypeScript works best when it knows the types of everything in your program at compile time, but it doesn’t have to know every type in order to compile your program. Even in an untyped program TypeScript can infer some types for you and catch some mistakes, but without knowing the types for everything, it will let a lot of mistakes slip through to your users.</p>&#13;
&#13;
<p>This gradual typing is really useful for migrating legacy codebases from untyped JavaScript to typed TypeScript (more on that in <a data-type="xref" href="ch11.html#migrating-to-typescript">“Gradually Migrating from JavaScript to TypeScript”</a>), but unless you’re in the middle of migrating your codebase, you should aim for 100% type coverage. That is the approach this book takes, except where explicitly noted.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Are types automatically converted?" data-type="sect3"><div class="sect3" id="idm46304995984504">&#13;
<h3>Are types automatically converted?</h3>&#13;
&#13;
<p>JavaScript is weakly typed, meaning if you do something invalid like add a number and an array (like we did in <a data-type="xref" href="ch01.html#intro">Chapter 1</a>), it will apply a bunch of rules to figure out what you really meant so it can do the best it can with what you gave it.<a data-primary="types" data-secondary="conversions, JavaScript versus Typescript" data-type="indexterm" id="idm46304995981736"/><a data-primary="weakly typed languages" data-type="indexterm" id="idm46304995980824"/><a data-primary="conversions (type)" data-type="indexterm" id="idm46304995980152"/><a data-primary="strings" data-secondary="automatic type conversions in JavaScript" data-type="indexterm" id="idm46304995979480"/> Let’s walk through the specific example of how JavaScript evaluates <code>3 + [1]</code>:</p>&#13;
<ol>&#13;
<li>&#13;
<p>JavaScript notices that <code>3</code> is a number and <code>[1]</code> is an array.</p>&#13;
</li>&#13;
<li>&#13;
<p>Because we’re using <code>+</code>, it assumes we want to concatenate the two.</p>&#13;
</li>&#13;
<li>&#13;
<p>It implicitly converts <code>3</code> to a string, yielding <code>"3"</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>It implicitly converts <code>[1]</code> to a string, yielding <code>"1"</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>It concatenates the results, yielding <code>"31"</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>We could do this more explicitly too (so JavaScript avoids doing steps 1, 3, and 4):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="mi">3</code> <code class="o">+</code> <code class="p">[</code><code class="mi">1</code><code class="p">];</code>                         <code class="c1">// evaluates to "31"</code>&#13;
&#13;
<code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code> <code class="o">+</code> <code class="p">[</code><code class="mi">1</code><code class="p">].</code><code class="nx">toString</code><code class="p">()</code>  <code class="c1">// evaluates to "31"</code></pre>&#13;
&#13;
<p>While JavaScript tries to be helpful by doing clever type conversions for you, TypeScript complains as soon as you do something invalid. When you run that same JavaScript code through <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2365" data-type="indexterm" id="idm46304990860456"/>TSC, you’ll get an error:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="mi">3</code> <code class="o">+</code> <code class="p">[</code><code class="mi">1</code><code class="p">];</code>                         <code class="c1">// Error TS2365: Operator '+' cannot be applied to</code>&#13;
                                 <code class="c1">// types '3' and 'number[]'.</code>&#13;
&#13;
<code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code> <code class="o">+</code> <code class="p">[</code><code class="mi">1</code><code class="p">].</code><code class="nx">toString</code><code class="p">()</code>  <code class="c1">// evaluates to "31"</code></pre>&#13;
&#13;
<p>If you do something that doesn’t seem right, TypeScript complains, and if you’re explicit about your intentions, TypeScript gets out of your way. This behavior makes sense: who in their right mind would try to add a number and an array, expecting the result to be a string (of course, besides Bavmorda the JavaScript witch who spends her time coding by candlelight in your startup’s basement)?</p>&#13;
&#13;
<p>The kind of implicit conversion that JavaScript does can be a really hard-to-track-down source of errors, and is the bane of many JavaScript programmers. It makes it hard for individual engineers to get their jobs done, and it makes it even harder to scale code across a large team, since every engineer needs to understand the implicit assumptions your code makes.</p>&#13;
&#13;
<p>In short, if you must convert types, do it explicitly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When are types checked?" data-type="sect3"><div class="sect3" id="idm46304995983912">&#13;
<h3>When are types checked?</h3>&#13;
&#13;
<p>In most places JavaScript doesn’t care what types you give it, and it instead tries to do its best to convert what you gave it to what it expects.<a data-primary="typechecking" data-secondary="JavaScript versus TypeScript" data-type="indexterm" id="idm46304990847528"/></p>&#13;
&#13;
<p>TypeScript, on the other hand, typechecks your code at compile time (remember step 2 in the list at the beginning of this chapter?), so you don’t need to actually run your code to see the <code>Error</code> from the previous example. TypeScript <em>statically analyzes</em> your code for errors like these, and shows them to you before you run it. If your code doesn’t compile, that’s a really good sign that you made a mistake and you should fix it before you try to run the code.</p>&#13;
&#13;
<p><a data-type="xref" href="#ch02-ide-error">Figure 2-2</a> shows what happens when <a data-primary="code editors" data-type="indexterm" id="idm46304990812168"/><a data-primary="editors" data-type="indexterm" id="idm46304990811496"/>I type the last code example into VSCode (my code editor of choice).</p>&#13;
&#13;
<figure><div class="figure" id="ch02-ide-error">&#13;
<img alt="prts 0202" src="assets/prts_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>TypeError reported by VSCode</h6>&#13;
</div></figure>&#13;
&#13;
<p>With a good TypeScript extension for your preferred code editor, the error will show up as a red squiggly line under your code <em>as you type it</em>. This dramatically speeds up the feedback loop between writing code, realizing that you made a mistake, and updating the code to fix that mistake.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When are errors surfaced?" data-type="sect3"><div class="sect3" id="idm46304990807448">&#13;
<h3>When are errors surfaced?</h3>&#13;
&#13;
<p>When JavaScript throws exceptions or performs implicit type conversions, it does so at runtime.<sup><a data-type="noteref" href="ch02.html#idm46304990806104" id="idm46304990806104-marker">2</a></sup> This means you have to actually run your program to get a useful signal back that you did something invalid.<a data-primary="errors" data-secondary="surfacing, in JavaScript versus TypeScript" data-type="indexterm" id="idm46304990804632"/> In the best case, that means as part of a unit test; in the worst case, it means an angry email from a user.</p>&#13;
&#13;
<p>TypeScript throws both syntax-related errors and type-related errors at compile time. In practice, that means those kinds of errors will show up in your code editor, right as you type—it’s an amazing experience if you’ve never worked with an incrementally compiled statically typed language before.<sup><a data-type="noteref" href="ch02.html#idm46304990802632" id="idm46304990802632-marker">3</a></sup></p>&#13;
&#13;
<p>That said, there are lots of errors that TypeScript can’t catch for you at compile time—things like stack overflows, broken network connections, and malformed user inputs—that will still result in runtime exceptions. What TypeScript does is make compile-time errors out of most errors that would have otherwise been runtime errors in a pure JavaScript world.<a data-primary="TypeScript" data-secondary="type system" data-startref="ix_TStypsysJS" data-tertiary="comparison to JavaScript" data-type="indexterm" id="idm46304990801112"/><a data-primary="JavaScript" data-secondary="type system, comparison to TypeScript" data-startref="ix_JStypsys" data-type="indexterm" id="idm46304990799528"/><a data-primary="type systems" data-secondary="comparison for JavaScript and TypeScript" data-startref="ix_typsyscomp" data-type="indexterm" id="idm46304990798296"/><a data-primary="type systems" data-startref="ix_typsys" data-type="indexterm" id="idm46304990797048"/><a data-primary="TypeScript" data-secondary="type system" data-startref="ix_TStypsys" data-type="indexterm" id="idm46304990796104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Editor Setup" data-type="sect1"><div class="sect1" id="idm46304993322616">&#13;
<h1>Code Editor Setup</h1>&#13;
&#13;
<p>Now that you have some intuition for how the TypeScript Compiler and type system work, let’s get your code editor set up so we can start diving into some real code.<a data-primary="TypeScript" data-secondary="setting up code editors" data-type="indexterm" id="ix_TScodeed"/><a data-primary="code editors" data-secondary="setting up for TypeScript" data-type="indexterm" id="ix_cdedset"/></p>&#13;
&#13;
<p>Start by downloading a code editor to write your code in. I like VSCode because it provides <a data-primary="VSCode" data-type="indexterm" id="idm46304990767928"/>a particularly nice TypeScript editing experience, but you can also use Sublime Text, Atom, Vim, WebStorm, or whatever editor you like. Engineers tend to be really picky about IDEs, so I’ll leave it to you to decide. If you do want to use VSCode, follow the instructions on the <a href="https://code.visualstudio.com/">website</a> to get it set up.<a data-primary="TSC compiler" data-type="indexterm" id="idm46304990766120"/></p>&#13;
&#13;
<p>TSC is itself a command-line application written in TypeScript,<sup><a data-type="noteref" href="ch02.html#idm46304990765000" id="idm46304990765000-marker">4</a></sup> which means you need NodeJS to run it. Follow the instructions on the official NodeJS <a href="https://nodejs.org">website</a> to get NodeJS up and running on your machine.<a data-primary="NodeJS" data-secondary="installing and running" data-type="indexterm" id="idm46304990763240"/><a data-primary="self-hosting compilers" data-type="indexterm" id="idm46304990762264"/></p>&#13;
&#13;
<p>NodeJS comes with NPM, a package manager that you will use to manage your project’s dependencies and orchestrate your build. <a data-primary="NPM package manager" data-type="indexterm" id="idm46304990761064"/>We’ll start by using it to install TSC and TSLint (a linter for TypeScript). <a data-primary="TSLint" data-secondary="installing" data-type="indexterm" id="idm46304990760232"/><a data-primary="TSC compiler" data-secondary="installing with npm" data-type="indexterm" id="idm46304990759288"/>Start by opening your terminal and creating a new folder, then initializing a new NPM project in it:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="c"># Create a new folder</code>&#13;
mkdir chapter-2&#13;
<code class="nb">cd </code>chapter-2&#13;
&#13;
<code class="c"># Initialize a new NPM project (follow the prompts)</code>&#13;
npm init&#13;
&#13;
<code class="c"># Install TSC, TSLint, and type declarations for NodeJS</code>&#13;
npm install --save-dev typescript tslint @types/node</pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="tsconfig.json" data-type="sect2"><div class="sect2" id="tsconfig.json">&#13;
<h2>tsconfig.json</h2>&#13;
&#13;
<p>Every TypeScript project should include a file called <em>tsconfig.json</em> in its root directory.<a data-primary="tsconfig.json" data-type="indexterm" id="idm46304990738952"/><a data-primary="TSC compiler" data-secondary="configuring with tsconfig.json" data-type="indexterm" id="idm46304990738216"/> This <em>tsconfig.json</em> is where TypeScript projects define things like which files should be compiled, which directory to compile them to, and which version of JavaScript to emit.</p>&#13;
&#13;
<p class="pagebreak-before">Create a new file called <em>tsconfig.json</em> in your root folder (<code>touch tsconfig.json</code>),<sup><a data-type="noteref" href="ch02.html#idm46304990750392" id="idm46304990750392-marker">5</a></sup> then pop it open in your code editor and give it the following contents:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"lib"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"es2015"</code><code class="p">],</code>&#13;
    <code class="nt">"module"</code><code class="p">:</code> <code class="s2">"commonjs"</code><code class="p">,</code>&#13;
    <code class="nt">"outDir"</code><code class="p">:</code> <code class="s2">"dist"</code><code class="p">,</code>&#13;
    <code class="nt">"sourceMap"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"strict"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"target"</code><code class="p">:</code> <code class="s2">"es2015"</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"include"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="s2">"src"</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s briefly go over some of those options and<a data-primary="tsconfig.json" data-secondary="options" data-type="indexterm" id="idm46304990666264"/> what they mean (<a data-type="xref" href="#tsconfig-json-table">Table 2-2</a>):</p>&#13;
<table id="tsconfig-json-table">&#13;
<caption><span class="label">Table 2-2. </span><em>tsconfig.json</em> options</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Option</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>include</code></p></td>&#13;
<td><p>Which folders should TSC look in to find your TypeScript files?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>lib</code></p></td>&#13;
<td><p>Which APIs should TSC assume exist in the environment you’ll be running your code in? This includes things like ES5’s <code>Function.prototype.bind</code>, ES2015’s <code>Object.assign</code>, and the DOM’s <code><span class="keep-together">document.querySelector</span></code>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>module</code></p></td>&#13;
<td><p>Which module system should TSC compile your code to (CommonJS, SystemJS, ES2015, etc.)?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>outDir</code></p></td>&#13;
<td><p>Which folder should TSC put your generated JavaScript code in?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>strict</code></p></td>&#13;
<td><p>Be as strict as possible when checking for invalid code. This option enforces that all of your code is properly typed. We’ll be using it for all of the examples in the book, and you should use it for your TypeScript project too.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>target</code></p></td>&#13;
<td><p>Which JavaScript version should TSC compile your code to (ES3, ES5, ES2015, ES2016, etc.)?</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>These are just a few of the available options—<em>tsconfig.json</em> supports dozens of options, and new ones are added all the time. You won’t find yourself changing these much in practice, besides dialing in the <code>module</code> and <code>target</code> settings when switching to a new module bundler, adding <code>"dom"</code> to <code>lib</code> when writing TypeScript for the browser (you’ll learn more about this in <a data-type="xref" href="ch12.html#typescript-in-production">Chapter 12</a>), or adjusting your level of <code>strict</code>ness when migrating your existing JavaScript code to TypeScript (see <a data-type="xref" href="ch11.html#migrating-to-typescript">“Gradually Migrating from JavaScript to TypeScript”</a>). For a complete and up-to-date list of supported options, head over to the official documentation on the <a href="http://bit.ly/2JWfsgY">TypeScript website</a>.</p>&#13;
&#13;
<p>Note that while using a <em>tsconfig.json</em> file to configure TSC is handy because it lets us check that configuration into source control, you can set most of TSC’s options from the command line too. Run <code>./node_modules/.bin/tsc --help</code> for a list of available command-line options.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="tslint.json" data-type="sect2"><div class="sect2" id="idm46304993230696">&#13;
<h2>tslint.json</h2>&#13;
&#13;
<p>Your project should also have a <em>tslint.json</em> file containing your TSLint configuration, codifying whatever stylistic conventions you want for your code (tabs versus spaces, etc.).<a data-primary="TSLint" data-secondary="configuring with tslint.json" data-type="indexterm" id="idm46304993228600"/><a data-primary="code style" data-secondary="configuring for TSLint" data-type="indexterm" id="idm46304993227608"/><a data-primary="tslint.json" data-type="indexterm" id="idm46304993226664"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Using TSLint is optional, but it’s strongly recommend for all TypeScript projects to enforce a consistent coding style. Most importantly, it will save you from arguing over code style with coworkers during code reviews.</p>&#13;
</div>&#13;
&#13;
<p>The following command will generate a <em>tslint.json</em> file with a default TSLint <span class="keep-together">configuration</span>:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">./node_modules/.bin/tslint --init</pre>&#13;
&#13;
<p>You can then add overrides to this to conform with your own coding style. For example, my <em>tslint.json</em> looks like this:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"defaultSeverity"</code><code class="p">:</code> <code class="s2">"error"</code><code class="p">,</code>&#13;
  <code class="nt">"extends"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="s2">"tslint:recommended"</code>&#13;
  <code class="p">],</code>&#13;
  <code class="nt">"rules"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"semicolon"</code><code class="p">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
    <code class="nt">"trailing-comma"</code><code class="p">:</code> <code class="kc">false</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For the full list of available rules, head over to the <a href="https://palantir.github.io/tslint/rules/">TSLint documentation</a>. You can also add custom rules, or install extra presets (like for <a href="https://www.npmjs.com/package/tslint-react">ReactJS</a>).<a data-primary="TypeScript" data-secondary="setting up code editors" data-startref="ix_TScodeed" data-type="indexterm" id="idm46304993202248"/><a data-primary="code editors" data-secondary="setting up for TypeScript" data-startref="ix_cdedset" data-type="indexterm" id="idm46304993201064"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="index.ts" data-type="sect1"><div class="sect1" id="idm46304993177528">&#13;
<h1>index.ts</h1>&#13;
&#13;
<p>Now that you’ve set up your <em>tsconfig.json</em> and <em>tslint.json</em>, create a <em>src</em> folder containing your <a data-primary="projects, setting up for TypeScript" data-type="indexterm" id="idm46304993174296"/><a data-primary="TypeScript" data-secondary="setting up projects, index.ts file" data-type="indexterm" id="idm46304993173624"/><a data-primary="index.ts" data-type="indexterm" id="idm46304993172712"/><a data-primary="src/index.ts" data-type="indexterm" id="idm46304993172040"/>first TypeScript file:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">mkdir src&#13;
touch src/index.ts</pre>&#13;
&#13;
<p class="pagebreak-before">Your<a data-primary="folder structure for TypeScript projects" data-type="indexterm" id="idm46304993169576"/> project’s folder structure should now look this:</p>&#13;
&#13;
<pre data-type="programlisting">chapter-2/&#13;
├──node_modules/&#13;
├──src/&#13;
│ └──index.ts&#13;
├──package.json&#13;
├──tsconfig.json&#13;
└──tslint.json</pre>&#13;
&#13;
<p>Pop open <em>src/index.ts</em> in your code editor, and enter the following TypeScript code:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Hello TypeScript!'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Then, compile and run your TypeScript code:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="c"># Compile your TypeScript with TSC</code>&#13;
./node_modules/.bin/tsc&#13;
&#13;
<code class="c"># Run your code with NodeJS</code>&#13;
node ./dist/index.js</pre>&#13;
&#13;
<p>If you’ve followed all the steps here, your code should run and you should see a single log in your console:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">Hello TypeScript!</pre>&#13;
&#13;
<p>That’s it—you just set up and ran your first TypeScript project from scratch. Nice work!</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Since this might have been your first time setting up a TypeScript project from scratch, I wanted to walk through each step so you have a sense for all the moving pieces. There are a couple of shortcuts you can take to do this faster next time:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Install <a href="https://npmjs.org/package/ts-node"><code>ts-node</code></a>, and use it to compile and run your TypeScript with a single command.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use a scaffolding tool like <a href="https://github.com/Microsoft/TypeScript-Node-Starter"><code>typescript-node-starter</code></a> to quickly generate your folder structure for you.</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before" data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46304993176936">&#13;
<h1>Exercises</h1>&#13;
&#13;
<p>Now that your environment is set up, open up <em>src/index.ts</em> in your code editor. Enter the following code:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">+</code> <code class="mi">2</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="mi">3</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">apple</code>: <code class="kt">a</code><code class="p">,</code>&#13;
  <code class="nx">banana</code>: <code class="kt">b</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">apple</code> <code class="o">*</code> <code class="mi">4</code></pre>&#13;
&#13;
<p>Now hover over <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>, and notice how TypeScript infers the types of all your variables for you: <code>a</code> is a <code>number</code>, <code>b</code> is a <code>number</code>, <code>c</code> is an object with a specific shape, and <code>d</code> is also a <code>number</code> (<a data-type="xref" href="#ch02-ide-example">Figure 2-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="ch02-ide-example">&#13;
<img alt="prts 0203" src="assets/prts_0203.png"/>&#13;
<h6><span class="label">Figure 2-3. </span>TypeScript inferring types for you</h6>&#13;
</div></figure>&#13;
&#13;
<p>Play around with your code a bit. See if you can:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Get TypeScript to show a red squiggly when you do something invalid (we call this “throwing a <code>TypeError</code>“).</p>&#13;
</li>&#13;
<li>&#13;
<p>Read the <code>TypeError</code>, and try to understand what it means.</p>&#13;
</li>&#13;
<li>&#13;
<p>Fix the <code>TypeError</code> and see the red squiggly disappear.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you’re ambitious, try to write a piece of code that TypeScript is unable to infer the type for.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304995709880"><sup><a href="ch02.html#idm46304995709880-marker">1</a></sup> There are languages all over this spectrum: JavaScript, Python, and Ruby infer types at runtime; Haskell and OCaml infer and check missing types at compile time; Scala and TypeScript require some explicit types and infer and check the rest at compile time; and Java and C need explicit annotations for almost everything, which they check at compile time.</p><p data-type="footnote" id="idm46304990806104"><sup><a href="ch02.html#idm46304990806104-marker">2</a></sup> To be sure, JavaScript surfaces syntax errors and a few select bugs (like multiple <code>const</code> declarations with the same name in the same scope) after it parses your program, but before it runs it. If you parse your JavaScript as part of your build process (e.g., with Babel), you can surface these errors at build time.</p><p data-type="footnote" id="idm46304990802632"><sup><a href="ch02.html#idm46304990802632-marker">3</a></sup> Incrementally compiled languages can be quickly recompiled when you make a small change, rather than having to recompile your whole program (including the parts you didn’t touch).</p><p data-type="footnote" id="idm46304990765000"><sup><a href="ch02.html#idm46304990765000-marker">4</a></sup> This puts TSC in the mystical class of compilers known as <em>self-hosting compilers</em>, or compilers that compile themselves.</p><p data-type="footnote" id="idm46304990750392"><sup><a href="ch02.html#idm46304990750392-marker">5</a></sup> For this exercise, we’re creating a <em>tsconfig.json</em> manually. When you set up TypeScript projects in the future, you can use TSC’s built-in initialize command to generate one for you: <code>./node_modules/.bin/tsc --init</code>.</p></div></div></section></body></html>