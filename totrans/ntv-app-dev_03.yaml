- en: Chapter 2\. Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 视图
- en: In most graphical UI (GUI) frameworks, visual elements on the screen are represented
    by objects generally called “views” in architectural parlance. In web applications,
    a view might be an HTML element, but in some web frameworks a view is an entire
    web page, or a fragment of a page. Java Swing, and a number of other frameworks,
    use “components” to represent the view portion of the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数图形用户界面（GUI）框架中，屏幕上的视觉元素通常被称为架构术语中的“视图”。在Web应用程序中，视图可能是HTML元素，但在某些Web框架中，视图可能是整个网页或页面片段。Java
    Swing和许多其他框架使用“组件”来表示应用程序的视图部分。
- en: In native mobile development, a view is exactly that—an instance of a `View`
    (Android) or `UIView` (iOS) subclass.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在原生移动开发中，视图确实就是这样——`View`（Android）或`UIView`（iOS）子类的实例。
- en: Views can be atomic elements and represent a single visual element on a screen,
    like a piece of text or an image, but might also be a more complicated hierarchy
    of views for layout, like a list of rows, or even more sophisticated, like a calendar
    widget with significant, sophisticated behavior built into the view itself.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以是原子元素，表示屏幕上的单个视觉元素，如文本片段或图像，也可以是用于布局的更复杂的视图层次结构，如一系列行或更复杂的，如具有内置复杂行为的日历小部件。
- en: Views are also necessary to receive user input. Buttons, switches and toggles,
    checkboxes, select boxes, and text inputs are all examples of views that enable
    your user to interact with your app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还必须用于接收用户输入。按钮、开关、复选框、选择框和文本输入框都是使用户能够与应用程序交互的视图的示例。
- en: Tasks
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: 'In this chapter, you’ll learn to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: Create a new view.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新视图。
- en: Nest views.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嵌套视图。
- en: Update a view’s state.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新视图的状态。
- en: Android
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android
- en: In Android, the base class is `View`, and it is *not* `abstract`—you can instantiate
    a simple `View` where needed, although it may not be that common. One example
    is that sometimes simple `View` instances are used as lines or shapes, by simply
    providing dimensions and a background color, or as hit areas without visual representation.
    Some common examples of actual android `View` subclasses are `TextView`, `ImageView`,
    `Button`, and `EditText`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，基类是 `View`，它*不是* `abstract`——你可以在需要时实例化一个简单的 `View`，尽管这可能不太常见。一个例子是有时简单的
    `View` 实例被用作线条或形状，只需提供尺寸和背景颜色，或作为没有可视化表示的点击区域。一些实际的Android `View` 子类的常见示例包括 `TextView`、`ImageView`、`Button`
    和 `EditText`。
- en: 'A base `View` cannot contain another `View`, but a `ViewGroup` can (a `ViewGroup`
    is a subclass of `View`, so it is a `View` itself). There are a number of `ViewGroup`
    classes in the framework library that are intended for layout purposes only: `LinearLayout`,
    `FrameLayout`, `ConstraintLayout`, and many others. Most of your layout needs
    can be accomplished using these prepackaged `ViewGroup` subclasses, but since
    these classes are pure Java, you’re free to subclass `ViewGroup` and define your
    own logic; I do so very commonly.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 `View` 不能包含另一个 `View`，但 `ViewGroup` 可以（`ViewGroup` 是 `View` 的子类，因此它本身也是
    `View`）。在框架库中有许多 `ViewGroup` 类专门用于布局：`LinearLayout`、`FrameLayout`、`ConstraintLayout`
    等等。大多数布局需求可以通过这些预制的 `ViewGroup` 子类来实现，但由于这些类是纯Java的，你可以自由地继承 `ViewGroup` 并定义自己的逻辑；我经常这样做。
- en: Other `ViewGroup` subclasses that aren’t strictly for layout include `ScrollView`,
    `RecyclerView`, `Spinner`, and `ViewPager`. Each of these components provides
    a great deal of functionality beyond displaying and laying out content—for example,
    the `RecyclerView` manages a scrolling list of items that are removed from the
    screen (and memory) when they’re off screen, and “recycled” (thus the name) when
    new items are scrolled into view. These are informally known as “widgets” in the
    Android ecosystem (not to be confused with device homescreen Widgets).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其他不严格用于布局的 `ViewGroup` 子类包括 `ScrollView`、`RecyclerView`、`Spinner` 和 `ViewPager`。每个组件提供了除了显示和布局内容之外的大量功能，例如，`RecyclerView`
    管理一个滚动的项目列表，当它们移出屏幕时（和内存中时）被移除，并在新项目滚动到视图中时“回收”（因此得名）。在Android生态系统中，这些通常称为“小部件”（不要与设备主屏幕的小部件混淆）。
- en: Create a New View
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新视图
- en: '`View` classes can be constructed just like any other object instance by using
    the `new` keyword and the `View` subclass’s constructor in Java, or just invoking
    the class’s constructor when using Kotlin. In most cases, this will require at
    least a `Context` parameters, and possibly more:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 类可以像其他对象实例一样通过在Java中使用 `new` 关键字和 `View` 子类的构造函数进行构造，或者在使用Kotlin时仅调用类的构造函数。在大多数情况下，这将至少需要一个
    `Context` 参数，可能还需要更多：'
- en: A more common way to create a `View`, and generally an entire hierarchy of nested
    `View` and `ViewGroup` instances, is to inflate an XML “layout.” “Inflate” simply
    means to parse the XML and its instructions and either add that view tree to an
    existing UI or simply return it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `View` 和通常是整个嵌套 `View` 和 `ViewGroup` 层次结构的更常见的方法是充气 XML “布局”。 “充气” 简单地意味着解析
    XML 及其指令，并将该视图树添加到现有 UI 中或简单返回它。
- en: XML layouts in Android follow traditional XML rules, with a couple conventions
    you should be aware of.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android 中的 XML 布局遵循传统的 XML 规则，并有一些你应该了解的约定。
- en: 'The XML declaration is optional, but recommended:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: XML 声明是可选的，但建议使用：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After that, the XML must have a *single* root node. This is almost always a
    `ViewGroup` (for a view tree) or a single `View` that represents the entire contents
    of the layout. I say “almost” because there are advanced mechanisms like the `merge`
    tag; this is not technically a `View` but provides an instruction to return the
    contents of the node.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，XML 必须有一个 *单一* 根节点。这几乎总是一个 `ViewGroup`（对于视图树）或表示布局整体内容的单个 `View`。我说“几乎”是因为还有像
    `merge` 标签这样的高级机制；这在技术上不是一个 `View`，但提供一个指令来返回节点的内容。
- en: 'For example, you might have a view tree like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能会有这样的视图树：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, your layout might be a single `View`, like so:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你的布局可能是一个单独的 `View`，如下所示：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Layout files are stored in the *res/layout/* folder and must follow the standard
    Android resource naming scheme (alphanumeric characters and underscores only).
    This folder is processed at compile time to make references to each layout a symbol
    that points to a numeric ID. It’s not critical to understand exactly how that
    happens right now; just know that if you save you layout file as *res/layout/my_activity.xml*,
    it will be available on the global `R` static configuration object as `R.layout.my_activity`,
    which is appropriate and available to pass to any method expecting a resource
    ID.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 布局文件存储在 *res/layout/* 文件夹中，并且必须遵循标准的 Android 资源命名方案（只能是字母数字字符和下划线）。这个文件夹在编译时处理，以使每个布局的引用成为指向数字
    ID 的符号。现在不必完全理解这是如何发生的；只需知道，如果你将布局文件保存为 *res/layout/my_activity.xml*，它将作为 `R`
    静态配置对象上的 `R.layout.my_activity` 可用，这是适当的，并且可以传递给任何期望资源 ID 的方法。
- en: 'Back to those conventions we mentioned earlier. Android packages a lot of functionality
    into the inflation process, but you’ll need to use their namespace to take advantage
    of that. This is simple enough: include a namespace attribute on the root node
    that points to the Android schema: *http://schemas.android.com/apk/res/android*.
    This namespace can be anything you’d like, but convention is to call it “android,”
    like so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前提到的约定。Android 在膨胀过程中捆绑了大量功能，但你需要使用它们的命名空间来利用这些功能。这很简单：在根节点上包含一个指向 Android
    架构的命名空间属性：*http://schemas.android.com/apk/res/android*。这个命名空间可以是任何你喜欢的，但通常称之为“android”，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once that’s established, you can access Android framework properties by appending
    the property with that namespace, as seen in the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了这个，你可以通过附加该命名空间的属性来访问 Android 框架属性，如下所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that namespace set up, when the framework inflates your XML to create a
    `LinearLayout` with a `TextView` in it, the `TextView` will have its `text` property
    set to “Hello World!” (which will render on the screen in the system’s font, color,
    and size).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了这个命名空间后，当框架充气你的 XML 来创建一个带有 `TextView` 的 `LinearLayout` 时，`TextView` 的 `text`
    属性将设置为“Hello World！”（将在系统的字体、颜色和大小下显示在屏幕上）。
- en: 'Note that you’ll probably never see it, but it’s perfectly acceptable to use
    your own name for the namespace, simply by specifying it in the layout file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可能永远不会看到它，但使用自己的命名空间名称是完全可以接受的，只需在布局文件中指定即可：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Another important namespace to include is the “auto” namespace, which is required
    when using your own custom components, as well as when using certain support components.
    This must point to *http://schemas.android.com/apk/res-auto* and is generally
    named “app” (but again, any name that follows the XML format for a namespace name
    is acceptable):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的要包含的命名空间是“auto”命名空间，当使用自定义组件或特定支持组件时是必需的。这必须指向 *http://schemas.android.com/apk/res-auto*，通常命名为“app”（但同样，任何遵循
    XML 命名空间名称格式的名称都是可以接受的）：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With those two namespaces on your root node, you should be ready to handle pretty
    much any XML layout functionality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个命名空间在你的根节点上，你应该准备好处理几乎所有的 XML 布局功能。
- en: As you write this, you might notice that all Android `Views` require a `layout_width`
    and `layout_height` property (which, in your namespaced XML, will look like `android:layout_width="100dp"`).
    This is not required for programmatically instantiated `Views`, which will always
    use the constant `WRAP_CONTENT` flag to indicate they should consume whatever
    size they require to display their content.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写时，您可能会注意到所有Android `Views`都需要`layout_width`和`layout_height`属性（在您的命名空间XML中，看起来像`android:layout_width="100dp"`）。这对于以编程方式实例化的`Views`并不需要，它们将始终使用常量`WRAP_CONTENT`标志，以指示它们应该消耗显示其内容所需的任何大小。
- en: 'The acceptable values are any dimensional value (`100dp`, `100px`, or `100sp`)
    or a few predefined constants: `LayoutParams.WRAP_CONTENT` and `LayoutParams.MATCH_PARENT`.
    The former is pretty self-explanatory—if you have a `TextView` with “Hello World”
    and both dimensions set to `WRAP_CONTENT`, the `TextView` will take as much space
    as is required to render those glyphs. `MATCH_PARENT` means the `View` will try
    to fill all the available space within its parent, along that dimension.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可接受的值是任何尺寸值（`100dp`、`100px`或`100sp`）或几个预定义的常量：`LayoutParams.WRAP_CONTENT`和`LayoutParams.MATCH_PARENT`。前者相当明显——如果您有一个`TextView`，内容为“Hello
    World”，并且两个尺寸设置为`WRAP_CONTENT`，那么`TextView`将占用所需的空间来呈现这些字符。`MATCH_PARENT`表示`View`将尝试填充其父级内所有可用的空间，沿着该维度。
- en: 'So a final, workable layout file might look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的可用布局文件可能如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A quick note about this code: it’s common to want to have one element (in this
    case, the `AppBarLayout` containing the `Toolbar`) take up as much room as it
    needs and have another element fill up the rest (maybe a `LinearLayout` or `ScrollView`).
    In this case, a `FrameLayout` that will serve as a container for dynamically added
    and removed `Views` will consume whatever space is available within its parent.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此代码的一个快速说明：通常希望一个元素（在本例中是包含`Toolbar`的`AppBarLayout`）占据所需的所有空间，并且另一个元素填充其余空间（也许是`LinearLayout`或`ScrollView`）。在这种情况下，作为动态添加和删除`Views`的容器的`FrameLayout`将占用其父级中可用的任何空间。
- en: 'You might think to do this with `MATCH_PARENT` on the `FrameLayout`, but the
    parent is actually as tall as the screen (assuming this is a root view), so the
    `FrameLayout` would clip along the bottom of the screen by an amount equal to
    the height of the `Toolbar`. This trick with `LinearLayout` solves this common
    issue: set the dimension of the variable-sized `View` to `WRAP_CONTENT`; then
    for the `View` that should expand to fill the remainder of the space in the parent,
    set that dimension to `0dp` but add a `layout_weight` of `1` (or anything, really).
    Layout weight tells the `LinearLayout` what percentage of available space to apportion
    to a `View`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为在`FrameLayout`上使用`MATCH_PARENT`，但父级实际上与屏幕一样高（假设这是根视图），因此`FrameLayout`将通过等于`Toolbar`高度的底部剪切。这种使用`LinearLayout`的技巧解决了这个常见问题：将变大小的`View`的尺寸设置为`WRAP_CONTENT`；然后对于应该扩展以填充父级中余下空间的`View`，将该尺寸设置为`0dp`，但添加`layout_weight`为`1`（或任何值）。布局权重告诉`LinearLayout`应该将多少可用空间分配给`View`。
- en: We finally have a usable layout in the resources file, precompiled and ready
    to go. How do we use it? There are a few ways, some of which we touched on in
    [Chapter 1](ch01.html#topics_ui_controllers) on UI controllers. For now, let’s
    concentrate on a couple common approaches, and explore a couple that are less
    common.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终在资源文件中有一个可用的布局，预编译并准备就绪。我们如何使用它？有几种方法，其中一些我们在[第1章](ch01.html#topics_ui_controllers)中已经涉及到UI控制器。现在，让我们专注于几种常见方法，并探索一些不太常见的方法。
- en: 'One strategy would be to set the layout as the root view of your `Activity`.
    Simply call `Activity.setContentView` and pass the resource ID of your layout.
    In this example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是将布局设置为你的`Activity`的根视图。只需调用`Activity.setContentView`并传递布局的资源ID。在这个例子中：
- en: That’s it! When `MyActivity` starts, you’ll immediately see the view tree described
    in the layout XML file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！当`MyActivity`启动时，您将立即看到在布局XML文件中描述的视图树。
- en: 'Another strategy would be to add your content to an existing view tree. If
    you’ve already set up a view tree in any other way, you can add or remove `View`
    instances using `ViewGroup` methods pretty easily, for example, `ViewGroup.addView`
    and `ViewGroup.removeView`. This works great for programmatically created views,
    but we can get access to layout inflation explicitly as well. There’s a system
    service that will do that for us, and there are two identical ways to get a reference
    to that service:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种策略是将内容添加到现有的视图树中。如果您已经以其他方式设置了视图树，您可以使用 `ViewGroup` 方法相当容易地添加或删除 `View` 实例，例如
    `ViewGroup.addView` 和 `ViewGroup.removeView`。这对于以编程方式创建的视图非常有效，但我们也可以明确地访问布局膨胀。有一个系统服务可以为我们做到这一点，有两种相同的方法可以获取对该服务的引用：
- en: 'Alternatively:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: 'Once you have a reference on an inflater instance, you can call the `inflate`
    method directly. One option is to append the inflated `Views` to another `ViewGroup`
    passed as a parameter:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有一个 inflater 实例的引用，可以直接调用 `inflate` 方法。其中一种选项是将膨胀的 `Views` 追加到作为参数传递的另一个
    `ViewGroup` 中：
- en: 'This signature will automatically add the inflated view tree to the second
    parameter, `someViewGroup`, and return that same root (`someViewGroup`). Alternatively,
    you can call it without a root:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名将自动将膨胀的视图树添加到第二个参数 `someViewGroup`，并返回相同的根 (`someViewGroup`)。或者，您可以在没有根的情况下调用它：
- en: The benefit to this version is that the view tree that was inflated is returned
    directly and does not need to be added to an existing view tree immediately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的好处在于，膨胀的视图树直接返回，无需立即添加到现有的视图树中。
- en: In addition, when using a `Fragment` (also covered in [Chapter 1](ch01.html#topics_ui_controllers)),
    your `Fragment` instances will want to return a `View` instance from its `onCreateView`
    callback (which is automatically called when the `Fragment` is created). Also,
    view manager classes like `RecyclerView` and `ViewPager` will provide hooks that
    should return (or decorate) a `View` as the needs of the display change (by scrolling
    or paging).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在使用 `Fragment`（也在 [第1章](ch01.html#topics_ui_controllers) 中涵盖）时，您的 `Fragment`
    实例将希望从其 `onCreateView` 回调中返回一个 `View` 实例（在 `Fragment` 创建时自动调用）。此外，像 `RecyclerView`
    和 `ViewPager` 这样的视图管理器类将提供挂钩，应根据显示需求（通过滚动或分页）返回（或装饰）一个 `View`。
- en: Nesting Views
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套视图
- en: Any `ViewGroup` can have any number of child `View` instances. Those children
    will be displayed within the containing `ViewGroup`, so if the container is removed
    or hidden, the children will also be removed or hidden.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 `ViewGroup` 可以拥有任意数量的子 `View` 实例。这些子项将显示在包含的 `ViewGroup` 内，因此如果容器被移除或隐藏，则子项也将被移除或隐藏。
- en: Child views will be positioned within the parent `ViewGroup` depending on the
    explicit layout logic of the `ViewGroup`. A `LinearLayout`, for example, will
    arrange its children in vertical or horizontal order, based on the size of each
    child, while a `FrameLayout` uses absolute pixel positioning.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 子视图将根据 `ViewGroup` 的显式布局逻辑在父 `ViewGroup` 内定位。例如，`LinearLayout` 将根据每个子项的大小以垂直或水平顺序排列其子项，而
    `FrameLayout` 使用绝对像素定位。
- en: A `View` can be added to a `ViewGroup` with any of the `ViewGroup.addView` methods.
    Signatures exist to accommodate index of insertion and layout instructions. `Views`
    can be removed with `ViewGroup.removeView` method. Remember that `ViewGroup` instances
    inherit from `View`, so one `ViewGroup` can add or remove another.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 可以使用任何 `ViewGroup.addView` 方法添加到 `ViewGroup` 中。存在签名以适应插入索引和布局指令。可以使用
    `ViewGroup.removeView` 方法删除 `Views`。请记住，`ViewGroup` 实例继承自 `View`，因此一个 `ViewGroup`
    可以添加或删除另一个。'
- en: This is handled for you in XML layouts. When `Views` are represented in XML
    layout files, the parent–child relationship of the XML nodes is reflected in the
    view tree as well; that’s to say that a `LinearLayout` node with two `TextView`
    child nodes will be inflated to a `LinearLayout` as a `ViewGroup` instance with
    two `TextView` instances as children. However, it’s still possible to change these
    relationships with `addView` and `removeView` after a layout has been inflated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 XML 布局中已为您处理。当 `Views` 在 XML 布局文件中表示时，XML 节点的父子关系也反映在视图树中；也就是说，一个具有两个 `TextView`
    子节点的 `LinearLayout` 节点将被膨胀为一个 `LinearLayout`，作为一个具有两个 `TextView` 实例的子项的 `ViewGroup`
    实例。但是，在膨胀布局后仍然可以使用 `addView` 和 `removeView` 更改这些关系。
- en: Update a View’s State
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新视图的状态
- en: The `View` API offers a number of methods for modifying the `View`’s visible
    properties. For example, `View.setLeft` will update the position of the `View`
    relative to its container, while `View.setAlpha` will adjust the transparency
    of the `View`. Very commonly you’ll use `setVisibility` to show or hide a `View`.
    When modifying position, it’s usually advisable to use `setTranslationX` or `setTranslationY`
    rather than `setLeft`, `setTop`, `setX`, or `setY`. The translation-based properties
    are an “offset,” computed on top of whatever normal position is appropriate for
    the `View`. For example, if you had a `LinearLayout` with several rows of thumbnails
    and labels and called `setTop` on the second row, the entire flow of the list
    of rows might be impacted. On the other hand, if you wanted to slide it down briefly
    to reveal some UI beneath it, you could safely use `setTranslationY` without affecting
    the container’s overall layout math.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` API 提供了多种方法来修改 `View` 的可见属性。例如，`View.setLeft` 将更新 `View` 相对于其容器的位置，而
    `View.setAlpha` 将调整 `View` 的透明度。非常常见的是，您会使用 `setVisibility` 来显示或隐藏 `View`。在修改位置时，通常建议使用
    `setTranslationX` 或 `setTranslationY` 而不是 `setLeft`、`setTop`、`setX` 或 `setY`。基于平移的属性是一种“偏移量”，计算在适当的
    `View` 正常位置之上。例如，如果您有一个包含多行缩略图和标签的 `LinearLayout`，并且在第二行调用了 `setTop`，那么整个行列表的流程可能会受到影响。另一方面，如果您想暂时向下滑动以显示其下的一些
    UI，则可以安全地使用 `setTranslationY` 而不影响容器的整体布局数学计算。'
- en: '`View` subclasses are a mixed bag and generally have specific APIs. For example,
    `TextView` has methods like `setText` and `setTextSize`, while `ImageView` has
    `setImageBitmap` to update the image displayed.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 子类是一个混合包，通常具有特定的 API。例如，`TextView` 具有诸如 `setText` 和 `setTextSize` 的方法，而
    `ImageView` 则具有 `setImageBitmap` 来更新显示的图像。'
- en: While most `View` properties can be set initially in XML, you almost always
    need to update programmatically. The Android framework uses getter and setter
    methods almost exclusively over direct property assignment. You would always use
    `myView.setVisibility(View.GONE);` rather than using `myView.visibility = View.GONE;`.
    This has a rather long history (and equally long controversy) with the Java community
    specifically and more generally with any technology with access modifiers (`private`
    versus `public`). The nickel tour is that a bunch of smart people got together
    some time ago and said, basically, never (or at least, very rarely) use directly
    assignable properties; use getter and setter methods, so both the authors and
    consumers of an API could intercept these “events” and add logic before or after
    a read or write mutated the state of the program.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数 `View` 属性可以在 XML 中最初设置，但您几乎总是需要通过编程方式进行更新。Android 框架几乎完全使用 getter 和 setter
    方法而不是直接属性赋值。您始终应该使用 `myView.setVisibility(View.GONE);` 而不是使用 `myView.visibility
    = View.GONE;`。这在特定的 Java 社区和更广泛的任何具有访问修饰符（`private` versus `public`）的技术中有着相当长的历史（以及同样长的争议）。简而言之，一群聪明的人很久以前聚在一起，基本上说，几乎不要（或至少很少）使用直接可赋值的属性；使用
    getter 和 setter 方法，以便 API 的作者和使用者可以拦截这些“事件”，在读取或写入数据之前或之后添加逻辑来改变程序的状态。
- en: 'That said, Kotlin *does* allow the appearance of direct property assignment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Kotlin *确实* 允许直接属性赋值的出现：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But behind the scenes, setter methods are being invoked; indeed, if you add
    logic in Kotlin to a setter method but then directly assign the property a value
    as shown in the immediately preceding code block, the logic in the setter *will*
    be invoked.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但在幕后，调用了 setter 方法；确实，如果您在 Kotlin 中为 setter 方法添加逻辑，然后像在前面的代码块中所示直接为属性赋值，setter
    中的逻辑 *将* 被调用。
- en: iOS
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS
- en: In iOS, the term “view” typically refers to an instance of `UIView` or a subclass.
    Views can be anything displayed on-screen—a label, an image, a map, an inline
    web browser, and much more! That being said, all views are, in their simplest
    form, a simple rectangle positioned in the device’s screen at a set of coordinates.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中，“view” 一词通常指 `UIView` 的一个实例或其子类。视图可以是显示在屏幕上的任何东西——标签、图像、地图、内联 Web 浏览器等等！话虽如此，所有视图在其最简单的形式中都是设备屏幕上的一个简单矩形，位于一组坐标中。
- en: The base view that all iOS applications start with is an instance of `UIWindow`.
    Every `UIViewController` has a `view` property that contains an instance of a
    `UIView`. An app’s window has its root view controller’s view nested within it.
    Changing the topmost presented view controller using segues and calls to `show(_:sender:)`,
    in their most basic form, simply swap one `UIView` (managed by a view controller)
    with another `UIView` (managed by another view controller) on the screen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有iOS应用程序开始时的基础视图是`UIWindow`的一个实例。每个`UIViewController`都有一个`view`属性，其中包含一个`UIView`的实例。应用程序的窗口在其中嵌套其根视图控制器的视图。通过segues和调用`show(_:sender:)`来改变顶部呈现的视图控制器，在其最基本的形式中，只是在屏幕上简单地交换一个由视图控制器管理的`UIView`与另一个由另一个视图控制器管理的`UIView`。
- en: Given the importance of `UIView` within iOS, let’s take a look at how to deal
    with this class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于`UIView`在iOS中的重要性，让我们来看看如何处理这个类。
- en: Create a New View
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新视图
- en: 'The first thing you might want to do is create a new view. In iOS, you do this
    by calling the initializer for a `UIView` and passing it a frame where that view
    will go on-screen like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要做的第一件事是创建一个新的视图。在iOS中，通过调用`UIView`的初始化程序并传递一个框架来完成这一点，这个视图将会显示在屏幕上，如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code creates a view that is 100pt wide and 50pt high; it will
    be placed 10pt from the left of its containing view and 30pt from the top of its
    containing view. This is the view’s `frame`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个宽度为100pt、高度为50pt的视图；它将放置在其包含视图的左侧10pt处和顶部30pt处。这是视图的`frame`。
- en: 'Sometimes, you might not know where a view should be placed on the screen when
    it’s created. It’s possible to instantiate a view without a known frame size by
    instead passing in a `CGRect` that has all its values set to `0`. This is common
    enough, in fact, that `CGRect` has a static variable that outputs a zero value
    rectangle. You can instantiate a view using it as shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当创建视图时，您可能不知道应该将视图放置在屏幕上的位置。事实上，可以通过传入一个所有值均设置为`0`的`CGRect`来实例化一个没有已知框架大小的视图。这种情况非常普遍，事实上，`CGRect`有一个静态变量，输出一个零值矩形。您可以使用它来实例化一个视图，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Frames versus bounds
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架与边界
- en: 'Work with `UIView`s long enough, and eventually you encounter the `bounds`
    property. This is also a `CGRect` and is incredibly similar to a view’s `frame`
    with an important distinction: a view’s `bounds` property is a rectangle that
    expresses its position relative to its *own* coordinate system, while a view’s
    `frame` property is a rectangle that expresses its location relative to its containing
    view (or “superview”). For example, the view in our first example would output
    the following for its `bounds` and `frame`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间使用`UIView`，最终会遇到`bounds`属性。这也是一个`CGRect`，与视图的`frame`非常相似，但有一个重要的区别：视图的`bounds`属性是一个表达其位置相对于其*自己*坐标系的矩形，而视图的`frame`属性是一个表达其位置相对于其包含视图（或“父视图”）的矩形。例如，我们第一个示例中的视图将为其`bounds`和`frame`输出以下内容：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice in this example that the `width` and `height` are the same for each property.
    The difference is that `frame` contains position information for the view within
    its superview, while `bounds` does not.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，每个属性的`width`和`height`是相同的。区别在于，`frame`包含视图在其父视图中的位置信息，而`bounds`则没有。
- en: Storyboards and XIBs
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Storyboards和XIBs
- en: So far, we’ve shown how to initialize a view only programmatically. However,
    views are often created behind the scenes after being defined within Xcode inside
    of a storyboard or an XML Interface Builder (XIB).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何仅通过编程方式初始化视图。然而，视图通常在幕后创建，之前在Xcode中定义在Storyboard或XML界面构建器（XIB）中。
- en: 'Storyboard-based views are defined within the context of a view controller
    directly inside Interface Builder. The view controller’s scene contains one or
    more views nested and displayed together. Connecting the view to the view controller
    is done with a special compiler flag, `@IBOutlet`. This flag indicates that a
    property of type `UIView` within a class is eligible to be connected to a view
    contained within a XIB or storyboard. For example, to create a view controller
    that has a blue rectangular subview you would first create a view controller with
    an `IBOutlet`-flagged property like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Storyboard的视图是直接在界面构建器中的视图控制器内定义的。视图控制器的场景包含一个或多个嵌套和一起显示的视图。将视图连接到视图控制器是通过特殊的编译器标志`@IBOutlet`完成的。此标志指示类中类型为`UIView`的属性可以连接到包含在XIB或Storyboard中的视图。例如，要创建一个具有蓝色矩形子视图的视图控制器，您首先要创建一个视图控制器，并在其内部创建一个带有`IBOutlet`标志的属性，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, to link up the view controller with a view, you’d need to do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要将视图控制器与视图链接起来，您需要执行以下操作：
- en: Create a new view controller scene.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的视图控制器场景。
- en: Change the view controller’s custom class via the Identity inspector to “ExampleViewController.”
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过身份检查器将视图控制器的自定义类更改为“ExampleViewController”。
- en: Add a view to the scene within the main view and change its background color
    to blue via the Attributes inspector.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主视图内的场景中添加一个视图，并通过属性检查器将其背景颜色更改为蓝色。
- en: Control-click on the view controller and drag from that to the blue rectangle.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图控制器上控制单击，然后从那里拖动到蓝色矩形。
- en: You should see a pop-up with the eligible Outlets in the view controller listed.
    Select `blueRectangle` and your blue rectangle view shown in Interface Builder
    is now directly linked to the `blueRectangle` property within your `ExampleViewController`
    class.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个弹出窗口，其中列出了视图控制器中的符合条件的出口。 选择`blueRectangle`，然后您在界面生成器中显示的蓝色矩形视图现在直接链接到`ExampleViewController`类中的`blueRectangle`属性。
- en: XIBs function very similarly. A XIB is essentially equivalent to a single view
    controller scene within a storyboard, although this an oversimplification. Really,
    they’re an XML-based format (much like storyboards) used to store information
    about a view so that it can be created via a GUI instead of only through the code.
    They predate storyboards and are becoming rarer but are still somewhat commonplace.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: XIB 的功能非常类似。 XIB 本质上相当于故事板中的单个视图控制器场景，尽管这是一个过度简化的说法。 实际上，它们是基于 XML 的格式（与故事板类似），用于存储关于视图的信息，以便可以通过
    GUI 创建视图，而不仅仅通过代码。 它们比故事板早出现，并且越来越少见，但仍然相对常见。
- en: 'Creating a view from a XIB is similar to a storyboard; the work of configuring
    the view is done via Interface Builder, for example, but a XIB is set up and instantiated
    in a slightly different way. To create a XIB-based view, you would complete the
    following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从 XIB 创建视图类似于故事板； 通过界面生成器完成配置视图的工作，例如，但是 XIB 的设置和实例化方式稍有不同。 要创建基于 XIB 的视图，您需要完成以下步骤：
- en: Create a `UIView` subclass named “CustomView.”
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“CustomView”的 `UIView` 子类。
- en: 'Add a new XIB (*CustomView.xib*) to your iOS project and set its custom class
    via the Identity inspector to the class we just created: `CustomView`.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 iOS 项目添加一个新的 XIB（*CustomView.xib*），并通过身份检查器设置其自定义类为我们刚刚创建的类：`CustomView`。
- en: Inside a view controller, or other object, instantiate the object.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图控制器或其他对象内实例化对象。
- en: 'How do you instantiate the object? You have to reference the XIB and then use
    that to instantiate the object itself like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实例化对象？ 您必须引用 XIB，然后像这样使用它来实例化对象本身：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, `instantiate(withOwner:options:)` creates a generic `UIView`
    instance, so you have to cast to the intended subclass.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`instantiate(withOwner:options:)` 创建一个通用的 `UIView` 实例，因此您必须将其转换为预期的子类。
- en: We’ve learned how to create views, but the real power in UIs comes in nesting
    and composing the views together. Let’s see how to nest a view inside another
    view.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何创建视图，但 UI 的真正力量在于嵌套和组合视图在一起。 让我们看看如何将一个视图嵌套在另一个视图中。
- en: Nesting Views
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套视图
- en: Views can be created and added to other views, which can hold other views that
    hold other views and so on and so forth—it truly is `UIView`s all the way down!
    Let’s create a view and add it as a child of another view.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建并添加到其他视图中的视图，这些视图可以容纳其他视图，这些视图可以容纳其他视图，依此类推——这确实是一种`UIView`的方式！ 让我们创建一个视图，并将其作为另一个视图的子视图添加。
- en: 'The following code block creates a parent view and a child view and then calls
    `addSubview(_:)` to add the child view to the parent’s array of subviews:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块创建了一个父视图和一个子视图，然后调用 `addSubview(_:)` 将子视图添加到父视图的子视图数组中：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We’ve added a view, so let’s remove it now! Using the same example, we can
    have the child remove itself from its parent’s view like so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个视图，现在让我们将其删除！ 使用相同的示例，我们可以让子视图从其父视图中移除自己，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Constraints
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约束
- en: 'Eventually you’ll run into an instance where you want a view to resize itself
    automatically. You do this by providing a set of constraints to a view relative
    to another view. Let’s say we have a button, a special type of view that can receive
    events, that we want positioned 16pt from the edge of the screen on either side
    and 100pt from the top of the screen. We could accomplish this layout using constraints
    within code like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您会遇到一个实例，希望视图自动调整大小。 您可以通过为视图提供与另一个视图相关的一组约束来实现这一点。 假设我们有一个按钮，这是一种特殊类型的视图，可以接收事件，我们希望它距离屏幕边缘的每一侧都有
    16pt，并且距离屏幕顶部有 100pt。 我们可以通过代码中的约束来实现这种布局，如下所示：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s walk through what’s happening here. First, we’re defining a view controller
    to hold a button that’s called `ExampleViewController`; it’s a subclass of `UIViewController`
    and, like every view controller, has a subview it manages called `view`. Within
    this class, we have a `setupButton()` method that’s called after the view is loaded
    to create the button and lay it out within the view. Next, inside of `setupButton()`
    we instantiate a button with an empty frame and set `translatesAutoresizingMaskIntoConstraints`
    to `false`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里发生了什么。首先，我们定义了一个视图控制器来容纳一个名为 `ExampleViewController` 的按钮；它是 `UIViewController`
    的子类，并且像每个视图控制器一样，有一个它管理的子视图叫做 `view`。在这个类中，我们有一个 `setupButton()` 方法，在视图加载后调用该方法来创建按钮并在视图内部进行布局。接下来，在
    `setupButton()` 内部，我们用空框架实例化一个按钮，并将 `translatesAutoresizingMaskIntoConstraints`
    设置为 `false`。
- en: Looking at the constraints we’re setting, you can see we reference the top anchor
    of the button (i.e., the top of the button) and set it 100pt from the top anchor
    of the containing view. We do this with the leading anchor (the left side) and
    the trailing anchor (the right side) as well, but with a value of `16.0` instead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 看到我们设置的约束条件，你会发现我们引用了按钮的顶部锚点（即按钮的顶部），并将其设置为距包含视图的顶部锚点 100pt。我们在左侧锚点（即左侧）和右侧锚点（即右侧）也是如此，但值为
    `16.0`。
- en: Running this code shows a view that looks something like [Figure 2-1](#topics_views_button).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将显示一个类似于 [图 2-1](#topics_views_button) 的视图。
- en: '![Button with constraints](assets/nmdv_0201.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![具有约束的按钮](assets/nmdv_0201.png)'
- en: Figure 2-1\. Button with constraints on iPhone X
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. iPhone X 上带有约束的按钮
- en: Warning
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you’re creating a view programmatically and adding constraints, you should
    set `translatesAutoresizingMaskIntoConstraints` to `false`. This property disables
    the system-created autoresizing constraints and allows us to specify our own constraints
    directly. In fact, it’s good practice to set it to `false` if you create the view
    programmatically at all. Not setting it to `false` often generates frustrating
    and mysterious view layout issues.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以编程方式创建视图并添加约束，应将 `translatesAutoresizingMaskIntoConstraints` 设置为 `false`。此属性禁用系统创建的自动调整大小约束，并允许我们直接指定自己的约束。实际上，如果您完全通过编程方式创建视图，将其设置为
    `false` 是一个好习惯。不将其设置为 `false` 往往会导致令人沮丧和神秘的视图布局问题。
- en: Where the power in constraints lies is that this view is 100% resizable based
    on the constraints defined. So if you were to rotate the device, the button would
    maintain its spacing relative to the top, left, and right anchor points of the
    view like in [Figure 2-2](#topics_views_button_rotated).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 约束的力量在于，该视图完全可以根据定义的约束进行调整大小。因此，如果你旋转设备，按钮将保持其相对于视图的顶部、左侧和右侧锚点的间距，就像在 [图 2-2](#topics_views_button_rotated)
    中一样。
- en: '![Button with constraints to fit landscape oritentation in iPhone X](assets/nmdv_0202.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![适应 iPhone X 横向方向的约束按钮](assets/nmdv_0202.png)'
- en: Figure 2-2\. Button with constraints that have adapted to fit landscape orientation
    on iPhone X
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 适应 iPhone X 横向方向的约束按钮
- en: Interface Builder to the Rescue
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口生成器来拯救
- en: 'While it’s possible to create constraints entirely in code, it quickly becomes
    complex when views have multiple relationships and behavior based on the size
    classes of the device. More commonly, constraints are created from within Interface
    Builder. To re-create the same button, we might follow a process similar to the
    following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以完全通过代码创建约束，但当视图具有多个关系和基于设备大小类的行为时，这很快变得复杂。更常见的做法是从 Interface Builder 中创建约束。为了重新创建相同的按钮，我们可能会遵循类似以下的过程：
- en: Open up a storyboard and add a new view controller scene.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个故事板并添加一个新的视图控制器场景。
- en: Change the custom class of the view controller in the Identity inspector to
    “ExampleViewController.”
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Identity inspector”中更改视图控制器的自定义类为“ExampleViewController”。
- en: Add a button to the view controller’s view.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向视图控制器的视图添加一个按钮。
- en: Click the Add New Constraints button in the lower-right corner of the storyboard
    editor.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击故事板编辑器右下角的“添加新约束”按钮。
- en: Set the margins within the pop-up that displays to our desired values. In this
    case, it would be a top value of 100pt with left and right values of 16pt.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出窗口中设置我们期望的边距值。在这种情况下，顶部值为 100pt，左右值为 16pt。
- en: Running the code would create a view that looks exactly the same as the one
    defined in code, but without any of the code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会创建一个看起来完全与代码中定义的相同的视图，但不包含任何代码。
- en: Auto Layout
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动布局
- en: Constraints are part of a technology within iOS called Auto Layout. It’s an
    *incredibly* powerful and complex tool that, used thoughtfully, can ease the amount
    of work required to make complex and responsive user interfaces. The scope of
    Auto Layout is too big for this section, so check out [the documentation](https://oreil.ly/dYJcl)
    for more information on how to use it effectively within your app.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 约束是 iOS 中称为自动布局的技术的一部分。它是一个*非常*强大且复杂的工具，如果用得当，可以减少制作复杂且响应灵活的用户界面所需的工作量。自动布局的范围对于本节来说太大了，请查阅[文档](https://oreil.ly/dYJcl)以获取更多关于如何在应用程序中有效使用它的信息。
- en: Update a View’s State
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新视图的状态
- en: Creating a view and adding it to a super view will get you only so far. There
    are a ton of properties available to all views to make their display more dynamic
    and to stylize them beyond basic, white rectangles. Let’s take a look at how to
    update some of the more commonly used properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个视图并将其添加到父视图只能做到这一步。所有视图都有大量属性可用来使它们的显示更加动态化，并将它们样式化为超越基本白色矩形的状态。让我们看看如何更新一些常用属性。
- en: Alpha
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Alpha
- en: 'You can update the alpha value, or transparency, of your view as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按以下方式更新视图的alpha值或透明度：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This changes the value to 50% transparency. If you wanted to hide the view
    completely, you could do so with the following snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值更改为50%的透明度。如果想要完全隐藏视图，可以使用以下代码片段：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Hiding views
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐藏视图
- en: 'Setting a view’s alpha to `0.0` won’t actually remove the view from the screen.
    It’ll still respond to touch events and block other views if it’s overlaid on
    top of them. In order to truly hide a view, use the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将视图的`alpha`设置为`0.0`实际上并不会从屏幕上移除视图。它仍然会响应触摸事件，并且如果它覆盖在其他视图之上，会阻止其他视图。为了真正隐藏视图，请使用以下代码：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Background color
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景颜色
- en: 'All views have a background color. The default background color for views on
    iOS is white. This is expressed as a `UIColor` object, or more specifically `UIColor.white`.
    You can set the background color to blue like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有视图都有背景颜色。iOS 上视图的默认背景颜色是白色。这可以用`UIColor`对象来表达，更具体地说是`UIColor.white`。你可以像这样将背景颜色设置为蓝色：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or, if you’d rather set it to a custom color you’ve defined, you can do so
    like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你更喜欢将其设置为自定义颜色，可以这样做：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `alpha` value in the `UIColor` affects only the background color. This
    does make it possible to have a view that is semi-transparent without affecting
    the view’s contents like setting the view’s `alpha` property directly would. In
    other words:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIColor`中的`alpha`值仅影响背景颜色。这确实使得有可能创建一个半透明的视图，而不像直接设置视图的`alpha`属性那样影响视图的内容。换句话说：'
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One important thing to note about colors within iOS is that “clear” is itself
    a color. For example, to create a view without a background color at all, you
    need to set the view’s background color to clear like so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中，一个重要的事情是，“clear”本身也是一种颜色。例如，要创建一个没有任何背景颜色的视图，你需要将视图的背景颜色设置为clear，如下所示：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Modifying Position
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改位置
- en: 'Want to modify the position of a view? You have two options, and the choice
    is based on if you used constraints or not. If constraints were not used, you
    can interact with the view through its `frame`. For example, to change a view’s
    position via the frame, do something like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想要修改视图的位置吗？你有两个选项，选择基于是否使用了约束。如果没有使用约束，可以通过其`frame`与视图进行交互。例如，要通过frame改变视图的位置，可以像下面这样做：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you used constraints to position the view, you’ll need to update the constraints
    directly. This can be done programmatically by creating a constraint within Interface
    Builder and assigning it to an `@IBOutlet` created within a class to edit the
    constraint’s value. If you have a width constraint defined in Interface Builder
    as `100.0`, you could change it to `50.0` in the code like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用约束来定位视图，则需要直接更新约束。这可以通过在界面构建器中创建约束，并将其分配给在类中创建的`@IBOutlet`来以编程方式完成。例如，如果在界面构建器中定义了一个宽度约束为`100.0`，则可以在代码中将其更改为`50.0`，如下所示：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You could also avoid setting values in the code and have two constraints added
    directly to the object in Interface Builder with one constraint turned off. Then,
    when the time is right, you could switch the constraints like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以避免在代码中设置值，并直接向对象添加两个约束，在一个约束被关闭的情况下。然后，在合适的时机，你可以像这样切换约束：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These are the most common ways to adjust constraints, but honestly, there are
    a number of different ways to go about changing the constraints an object has
    connected to it. That is the power, and complexity, of Auto Layout.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是调整约束的最常见方式，但说实话，有许多不同的方法可以改变与对象连接的约束。这就是Auto Layout的力量和复杂性。
- en: Other properties
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他属性
- en: This only scratches the surface of the number of properties available within
    views. Other views, like `UILabel`, have font options available. Views like `UIImageView`
    can have `UIImage`s assigned to them. Views like `WKWebView`, the built-in web
    view provided by iOS, have yet even more complex states that can be enabled and
    toggled. It’s best to look at the documentation for a particular class on Apple’s
    documentation site to get a full understanding of the properties available for
    control.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是触及了视图中可用属性数量的表面。其他视图，如`UILabel`，有可用的字体选项。像`UIImageView`这样的视图可以分配`UIImage`。像`WKWebView`这样的视图，在iOS提供的内置Web视图中，有更复杂的状态可以启用和切换。最好查看Apple文档网站上特定类的文档，以全面了解可用于控制的属性。
- en: Core Animation
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心动画
- en: One thing that wasn’t discussed in this chapter was Core Animation layers. This
    is a wholly different and complementary way to change and alter the appearance
    of a view. Things like `borderRadius` and `mask` make it possible to create complex
    user interfaces that are able to be animated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有讨论的一件事是核心动画层(Core Animation layers)。这是一种完全不同且互补的方式，用于改变和修改视图的外观。像`borderRadius`和`mask`这样的东西使得创建能够进行动画的复杂用户界面成为可能。
- en: SwiftUI
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SwiftUI
- en: A successor to UIKit has arrived in the form of SwiftUI. This is a new library
    with which to build user interfaces within Swift. It’s a declarative syntax that
    has tons of promise for the next generation of UI development. It’s still early
    and a bit rough around the edges right now, but given the investment Apple is
    making in this technology, it’s a safe bet that it will become much more relevant
    and—if Apple has its way—the predominant way to build apps in a few short years.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI作为UIKit的后继者已经到来。这是一个新的库，用于在Swift中构建用户界面。它是一种声明性语法，对于下一代UI开发有很大的潜力。现在它还比较早期，并且在某些方面还有些粗糙，但考虑到Apple在这项技术上的投入，可以肯定它将在未来几年内变得更加重要，如果Apple按照其计划进行的话，可能会成为构建应用程序的主要方式。
- en: What We’ve Learned
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们学到了什么
- en: 'Android and iOS have very different mechanisms for displaying views on a device’s
    screen, but fundamentally they have the same goal: display content to a user for
    interaction. In order to achieve that, we’ve covered the following items:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Android和iOS在显示视图在设备屏幕上的机制上有着非常不同的方式，但基本上它们有着相同的目标：向用户显示内容以进行交互。为了实现这一目标，我们已经涵盖了以下内容：
- en: How to create a new view in both the platforms to display on the screen
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在两个平台上创建新视图以显示在屏幕上
- en: The differences in creating views with raw XML in Android and storyboards in
    iOS, which are ultimately represented using XML as the underlying file structure
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android中使用原始XML创建视图和在iOS中使用storyboards创建视图的区别，最终都使用XML作为底层文件结构进行表示。
- en: How to deal with changing device sizes in iOS through the use of constraints
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用约束来处理iOS中不同设备尺寸的变化
- en: The ease with which views can be nested and updated
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图可以轻松嵌套和更新的便利性
- en: This information gives us a good amount of base knowledge to understand the
    next chapter on custom views. Let’s get started!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息为我们提供了足够的基础知识，以理解接下来关于自定义视图的章节。让我们开始吧！
