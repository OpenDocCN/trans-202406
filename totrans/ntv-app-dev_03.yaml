- en: Chapter 2\. Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most graphical UI (GUI) frameworks, visual elements on the screen are represented
    by objects generally called “views” in architectural parlance. In web applications,
    a view might be an HTML element, but in some web frameworks a view is an entire
    web page, or a fragment of a page. Java Swing, and a number of other frameworks,
    use “components” to represent the view portion of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In native mobile development, a view is exactly that—an instance of a `View`
    (Android) or `UIView` (iOS) subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Views can be atomic elements and represent a single visual element on a screen,
    like a piece of text or an image, but might also be a more complicated hierarchy
    of views for layout, like a list of rows, or even more sophisticated, like a calendar
    widget with significant, sophisticated behavior built into the view itself.
  prefs: []
  type: TYPE_NORMAL
- en: Views are also necessary to receive user input. Buttons, switches and toggles,
    checkboxes, select boxes, and text inputs are all examples of views that enable
    your user to interact with your app.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nest views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update a view’s state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, the base class is `View`, and it is *not* `abstract`—you can instantiate
    a simple `View` where needed, although it may not be that common. One example
    is that sometimes simple `View` instances are used as lines or shapes, by simply
    providing dimensions and a background color, or as hit areas without visual representation.
    Some common examples of actual android `View` subclasses are `TextView`, `ImageView`,
    `Button`, and `EditText`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A base `View` cannot contain another `View`, but a `ViewGroup` can (a `ViewGroup`
    is a subclass of `View`, so it is a `View` itself). There are a number of `ViewGroup`
    classes in the framework library that are intended for layout purposes only: `LinearLayout`,
    `FrameLayout`, `ConstraintLayout`, and many others. Most of your layout needs
    can be accomplished using these prepackaged `ViewGroup` subclasses, but since
    these classes are pure Java, you’re free to subclass `ViewGroup` and define your
    own logic; I do so very commonly.'
  prefs: []
  type: TYPE_NORMAL
- en: Other `ViewGroup` subclasses that aren’t strictly for layout include `ScrollView`,
    `RecyclerView`, `Spinner`, and `ViewPager`. Each of these components provides
    a great deal of functionality beyond displaying and laying out content—for example,
    the `RecyclerView` manages a scrolling list of items that are removed from the
    screen (and memory) when they’re off screen, and “recycled” (thus the name) when
    new items are scrolled into view. These are informally known as “widgets” in the
    Android ecosystem (not to be confused with device homescreen Widgets).
  prefs: []
  type: TYPE_NORMAL
- en: Create a New View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`View` classes can be constructed just like any other object instance by using
    the `new` keyword and the `View` subclass’s constructor in Java, or just invoking
    the class’s constructor when using Kotlin. In most cases, this will require at
    least a `Context` parameters, and possibly more:'
  prefs: []
  type: TYPE_NORMAL
- en: A more common way to create a `View`, and generally an entire hierarchy of nested
    `View` and `ViewGroup` instances, is to inflate an XML “layout.” “Inflate” simply
    means to parse the XML and its instructions and either add that view tree to an
    existing UI or simply return it.
  prefs: []
  type: TYPE_NORMAL
- en: XML layouts in Android follow traditional XML rules, with a couple conventions
    you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'The XML declaration is optional, but recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After that, the XML must have a *single* root node. This is almost always a
    `ViewGroup` (for a view tree) or a single `View` that represents the entire contents
    of the layout. I say “almost” because there are advanced mechanisms like the `merge`
    tag; this is not technically a `View` but provides an instruction to return the
    contents of the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might have a view tree like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, your layout might be a single `View`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Layout files are stored in the *res/layout/* folder and must follow the standard
    Android resource naming scheme (alphanumeric characters and underscores only).
    This folder is processed at compile time to make references to each layout a symbol
    that points to a numeric ID. It’s not critical to understand exactly how that
    happens right now; just know that if you save you layout file as *res/layout/my_activity.xml*,
    it will be available on the global `R` static configuration object as `R.layout.my_activity`,
    which is appropriate and available to pass to any method expecting a resource
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to those conventions we mentioned earlier. Android packages a lot of functionality
    into the inflation process, but you’ll need to use their namespace to take advantage
    of that. This is simple enough: include a namespace attribute on the root node
    that points to the Android schema: *http://schemas.android.com/apk/res/android*.
    This namespace can be anything you’d like, but convention is to call it “android,”
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that’s established, you can access Android framework properties by appending
    the property with that namespace, as seen in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that namespace set up, when the framework inflates your XML to create a
    `LinearLayout` with a `TextView` in it, the `TextView` will have its `text` property
    set to “Hello World!” (which will render on the screen in the system’s font, color,
    and size).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you’ll probably never see it, but it’s perfectly acceptable to use
    your own name for the namespace, simply by specifying it in the layout file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another important namespace to include is the “auto” namespace, which is required
    when using your own custom components, as well as when using certain support components.
    This must point to *http://schemas.android.com/apk/res-auto* and is generally
    named “app” (but again, any name that follows the XML format for a namespace name
    is acceptable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With those two namespaces on your root node, you should be ready to handle pretty
    much any XML layout functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As you write this, you might notice that all Android `Views` require a `layout_width`
    and `layout_height` property (which, in your namespaced XML, will look like `android:layout_width="100dp"`).
    This is not required for programmatically instantiated `Views`, which will always
    use the constant `WRAP_CONTENT` flag to indicate they should consume whatever
    size they require to display their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The acceptable values are any dimensional value (`100dp`, `100px`, or `100sp`)
    or a few predefined constants: `LayoutParams.WRAP_CONTENT` and `LayoutParams.MATCH_PARENT`.
    The former is pretty self-explanatory—if you have a `TextView` with “Hello World”
    and both dimensions set to `WRAP_CONTENT`, the `TextView` will take as much space
    as is required to render those glyphs. `MATCH_PARENT` means the `View` will try
    to fill all the available space within its parent, along that dimension.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So a final, workable layout file might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick note about this code: it’s common to want to have one element (in this
    case, the `AppBarLayout` containing the `Toolbar`) take up as much room as it
    needs and have another element fill up the rest (maybe a `LinearLayout` or `ScrollView`).
    In this case, a `FrameLayout` that will serve as a container for dynamically added
    and removed `Views` will consume whatever space is available within its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think to do this with `MATCH_PARENT` on the `FrameLayout`, but the
    parent is actually as tall as the screen (assuming this is a root view), so the
    `FrameLayout` would clip along the bottom of the screen by an amount equal to
    the height of the `Toolbar`. This trick with `LinearLayout` solves this common
    issue: set the dimension of the variable-sized `View` to `WRAP_CONTENT`; then
    for the `View` that should expand to fill the remainder of the space in the parent,
    set that dimension to `0dp` but add a `layout_weight` of `1` (or anything, really).
    Layout weight tells the `LinearLayout` what percentage of available space to apportion
    to a `View`.'
  prefs: []
  type: TYPE_NORMAL
- en: We finally have a usable layout in the resources file, precompiled and ready
    to go. How do we use it? There are a few ways, some of which we touched on in
    [Chapter 1](ch01.html#topics_ui_controllers) on UI controllers. For now, let’s
    concentrate on a couple common approaches, and explore a couple that are less
    common.
  prefs: []
  type: TYPE_NORMAL
- en: 'One strategy would be to set the layout as the root view of your `Activity`.
    Simply call `Activity.setContentView` and pass the resource ID of your layout.
    In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! When `MyActivity` starts, you’ll immediately see the view tree described
    in the layout XML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another strategy would be to add your content to an existing view tree. If
    you’ve already set up a view tree in any other way, you can add or remove `View`
    instances using `ViewGroup` methods pretty easily, for example, `ViewGroup.addView`
    and `ViewGroup.removeView`. This works great for programmatically created views,
    but we can get access to layout inflation explicitly as well. There’s a system
    service that will do that for us, and there are two identical ways to get a reference
    to that service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a reference on an inflater instance, you can call the `inflate`
    method directly. One option is to append the inflated `Views` to another `ViewGroup`
    passed as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This signature will automatically add the inflated view tree to the second
    parameter, `someViewGroup`, and return that same root (`someViewGroup`). Alternatively,
    you can call it without a root:'
  prefs: []
  type: TYPE_NORMAL
- en: The benefit to this version is that the view tree that was inflated is returned
    directly and does not need to be added to an existing view tree immediately.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when using a `Fragment` (also covered in [Chapter 1](ch01.html#topics_ui_controllers)),
    your `Fragment` instances will want to return a `View` instance from its `onCreateView`
    callback (which is automatically called when the `Fragment` is created). Also,
    view manager classes like `RecyclerView` and `ViewPager` will provide hooks that
    should return (or decorate) a `View` as the needs of the display change (by scrolling
    or paging).
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any `ViewGroup` can have any number of child `View` instances. Those children
    will be displayed within the containing `ViewGroup`, so if the container is removed
    or hidden, the children will also be removed or hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Child views will be positioned within the parent `ViewGroup` depending on the
    explicit layout logic of the `ViewGroup`. A `LinearLayout`, for example, will
    arrange its children in vertical or horizontal order, based on the size of each
    child, while a `FrameLayout` uses absolute pixel positioning.
  prefs: []
  type: TYPE_NORMAL
- en: A `View` can be added to a `ViewGroup` with any of the `ViewGroup.addView` methods.
    Signatures exist to accommodate index of insertion and layout instructions. `Views`
    can be removed with `ViewGroup.removeView` method. Remember that `ViewGroup` instances
    inherit from `View`, so one `ViewGroup` can add or remove another.
  prefs: []
  type: TYPE_NORMAL
- en: This is handled for you in XML layouts. When `Views` are represented in XML
    layout files, the parent–child relationship of the XML nodes is reflected in the
    view tree as well; that’s to say that a `LinearLayout` node with two `TextView`
    child nodes will be inflated to a `LinearLayout` as a `ViewGroup` instance with
    two `TextView` instances as children. However, it’s still possible to change these
    relationships with `addView` and `removeView` after a layout has been inflated.
  prefs: []
  type: TYPE_NORMAL
- en: Update a View’s State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `View` API offers a number of methods for modifying the `View`’s visible
    properties. For example, `View.setLeft` will update the position of the `View`
    relative to its container, while `View.setAlpha` will adjust the transparency
    of the `View`. Very commonly you’ll use `setVisibility` to show or hide a `View`.
    When modifying position, it’s usually advisable to use `setTranslationX` or `setTranslationY`
    rather than `setLeft`, `setTop`, `setX`, or `setY`. The translation-based properties
    are an “offset,” computed on top of whatever normal position is appropriate for
    the `View`. For example, if you had a `LinearLayout` with several rows of thumbnails
    and labels and called `setTop` on the second row, the entire flow of the list
    of rows might be impacted. On the other hand, if you wanted to slide it down briefly
    to reveal some UI beneath it, you could safely use `setTranslationY` without affecting
    the container’s overall layout math.
  prefs: []
  type: TYPE_NORMAL
- en: '`View` subclasses are a mixed bag and generally have specific APIs. For example,
    `TextView` has methods like `setText` and `setTextSize`, while `ImageView` has
    `setImageBitmap` to update the image displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: While most `View` properties can be set initially in XML, you almost always
    need to update programmatically. The Android framework uses getter and setter
    methods almost exclusively over direct property assignment. You would always use
    `myView.setVisibility(View.GONE);` rather than using `myView.visibility = View.GONE;`.
    This has a rather long history (and equally long controversy) with the Java community
    specifically and more generally with any technology with access modifiers (`private`
    versus `public`). The nickel tour is that a bunch of smart people got together
    some time ago and said, basically, never (or at least, very rarely) use directly
    assignable properties; use getter and setter methods, so both the authors and
    consumers of an API could intercept these “events” and add logic before or after
    a read or write mutated the state of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, Kotlin *does* allow the appearance of direct property assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: But behind the scenes, setter methods are being invoked; indeed, if you add
    logic in Kotlin to a setter method but then directly assign the property a value
    as shown in the immediately preceding code block, the logic in the setter *will*
    be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In iOS, the term “view” typically refers to an instance of `UIView` or a subclass.
    Views can be anything displayed on-screen—a label, an image, a map, an inline
    web browser, and much more! That being said, all views are, in their simplest
    form, a simple rectangle positioned in the device’s screen at a set of coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The base view that all iOS applications start with is an instance of `UIWindow`.
    Every `UIViewController` has a `view` property that contains an instance of a
    `UIView`. An app’s window has its root view controller’s view nested within it.
    Changing the topmost presented view controller using segues and calls to `show(_:sender:)`,
    in their most basic form, simply swap one `UIView` (managed by a view controller)
    with another `UIView` (managed by another view controller) on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Given the importance of `UIView` within iOS, let’s take a look at how to deal
    with this class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a New View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing you might want to do is create a new view. In iOS, you do this
    by calling the initializer for a `UIView` and passing it a frame where that view
    will go on-screen like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a view that is 100pt wide and 50pt high; it will
    be placed 10pt from the left of its containing view and 30pt from the top of its
    containing view. This is the view’s `frame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you might not know where a view should be placed on the screen when
    it’s created. It’s possible to instantiate a view without a known frame size by
    instead passing in a `CGRect` that has all its values set to `0`. This is common
    enough, in fact, that `CGRect` has a static variable that outputs a zero value
    rectangle. You can instantiate a view using it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Frames versus bounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Work with `UIView`s long enough, and eventually you encounter the `bounds`
    property. This is also a `CGRect` and is incredibly similar to a view’s `frame`
    with an important distinction: a view’s `bounds` property is a rectangle that
    expresses its position relative to its *own* coordinate system, while a view’s
    `frame` property is a rectangle that expresses its location relative to its containing
    view (or “superview”). For example, the view in our first example would output
    the following for its `bounds` and `frame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice in this example that the `width` and `height` are the same for each property.
    The difference is that `frame` contains position information for the view within
    its superview, while `bounds` does not.
  prefs: []
  type: TYPE_NORMAL
- en: Storyboards and XIBs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we’ve shown how to initialize a view only programmatically. However,
    views are often created behind the scenes after being defined within Xcode inside
    of a storyboard or an XML Interface Builder (XIB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Storyboard-based views are defined within the context of a view controller
    directly inside Interface Builder. The view controller’s scene contains one or
    more views nested and displayed together. Connecting the view to the view controller
    is done with a special compiler flag, `@IBOutlet`. This flag indicates that a
    property of type `UIView` within a class is eligible to be connected to a view
    contained within a XIB or storyboard. For example, to create a view controller
    that has a blue rectangular subview you would first create a view controller with
    an `IBOutlet`-flagged property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to link up the view controller with a view, you’d need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new view controller scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the view controller’s custom class via the Identity inspector to “ExampleViewController.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a view to the scene within the main view and change its background color
    to blue via the Attributes inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Control-click on the view controller and drag from that to the blue rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see a pop-up with the eligible Outlets in the view controller listed.
    Select `blueRectangle` and your blue rectangle view shown in Interface Builder
    is now directly linked to the `blueRectangle` property within your `ExampleViewController`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: XIBs function very similarly. A XIB is essentially equivalent to a single view
    controller scene within a storyboard, although this an oversimplification. Really,
    they’re an XML-based format (much like storyboards) used to store information
    about a view so that it can be created via a GUI instead of only through the code.
    They predate storyboards and are becoming rarer but are still somewhat commonplace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a view from a XIB is similar to a storyboard; the work of configuring
    the view is done via Interface Builder, for example, but a XIB is set up and instantiated
    in a slightly different way. To create a XIB-based view, you would complete the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `UIView` subclass named “CustomView.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new XIB (*CustomView.xib*) to your iOS project and set its custom class
    via the Identity inspector to the class we just created: `CustomView`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside a view controller, or other object, instantiate the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How do you instantiate the object? You have to reference the XIB and then use
    that to instantiate the object itself like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, `instantiate(withOwner:options:)` creates a generic `UIView`
    instance, so you have to cast to the intended subclass.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned how to create views, but the real power in UIs comes in nesting
    and composing the views together. Let’s see how to nest a view inside another
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Views can be created and added to other views, which can hold other views that
    hold other views and so on and so forth—it truly is `UIView`s all the way down!
    Let’s create a view and add it as a child of another view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block creates a parent view and a child view and then calls
    `addSubview(_:)` to add the child view to the parent’s array of subviews:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added a view, so let’s remove it now! Using the same example, we can
    have the child remove itself from its parent’s view like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Eventually you’ll run into an instance where you want a view to resize itself
    automatically. You do this by providing a set of constraints to a view relative
    to another view. Let’s say we have a button, a special type of view that can receive
    events, that we want positioned 16pt from the edge of the screen on either side
    and 100pt from the top of the screen. We could accomplish this layout using constraints
    within code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through what’s happening here. First, we’re defining a view controller
    to hold a button that’s called `ExampleViewController`; it’s a subclass of `UIViewController`
    and, like every view controller, has a subview it manages called `view`. Within
    this class, we have a `setupButton()` method that’s called after the view is loaded
    to create the button and lay it out within the view. Next, inside of `setupButton()`
    we instantiate a button with an empty frame and set `translatesAutoresizingMaskIntoConstraints`
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the constraints we’re setting, you can see we reference the top anchor
    of the button (i.e., the top of the button) and set it 100pt from the top anchor
    of the containing view. We do this with the leading anchor (the left side) and
    the trailing anchor (the right side) as well, but with a value of `16.0` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Running this code shows a view that looks something like [Figure 2-1](#topics_views_button).
  prefs: []
  type: TYPE_NORMAL
- en: '![Button with constraints](assets/nmdv_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Button with constraints on iPhone X
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re creating a view programmatically and adding constraints, you should
    set `translatesAutoresizingMaskIntoConstraints` to `false`. This property disables
    the system-created autoresizing constraints and allows us to specify our own constraints
    directly. In fact, it’s good practice to set it to `false` if you create the view
    programmatically at all. Not setting it to `false` often generates frustrating
    and mysterious view layout issues.
  prefs: []
  type: TYPE_NORMAL
- en: Where the power in constraints lies is that this view is 100% resizable based
    on the constraints defined. So if you were to rotate the device, the button would
    maintain its spacing relative to the top, left, and right anchor points of the
    view like in [Figure 2-2](#topics_views_button_rotated).
  prefs: []
  type: TYPE_NORMAL
- en: '![Button with constraints to fit landscape oritentation in iPhone X](assets/nmdv_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Button with constraints that have adapted to fit landscape orientation
    on iPhone X
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Interface Builder to the Rescue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it’s possible to create constraints entirely in code, it quickly becomes
    complex when views have multiple relationships and behavior based on the size
    classes of the device. More commonly, constraints are created from within Interface
    Builder. To re-create the same button, we might follow a process similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up a storyboard and add a new view controller scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the custom class of the view controller in the Identity inspector to
    “ExampleViewController.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to the view controller’s view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the Add New Constraints button in the lower-right corner of the storyboard
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the margins within the pop-up that displays to our desired values. In this
    case, it would be a top value of 100pt with left and right values of 16pt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the code would create a view that looks exactly the same as the one
    defined in code, but without any of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constraints are part of a technology within iOS called Auto Layout. It’s an
    *incredibly* powerful and complex tool that, used thoughtfully, can ease the amount
    of work required to make complex and responsive user interfaces. The scope of
    Auto Layout is too big for this section, so check out [the documentation](https://oreil.ly/dYJcl)
    for more information on how to use it effectively within your app.
  prefs: []
  type: TYPE_NORMAL
- en: Update a View’s State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a view and adding it to a super view will get you only so far. There
    are a ton of properties available to all views to make their display more dynamic
    and to stylize them beyond basic, white rectangles. Let’s take a look at how to
    update some of the more commonly used properties.
  prefs: []
  type: TYPE_NORMAL
- en: Alpha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can update the alpha value, or transparency, of your view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the value to 50% transparency. If you wanted to hide the view
    completely, you could do so with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Hiding views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting a view’s alpha to `0.0` won’t actually remove the view from the screen.
    It’ll still respond to touch events and block other views if it’s overlaid on
    top of them. In order to truly hide a view, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Background color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All views have a background color. The default background color for views on
    iOS is white. This is expressed as a `UIColor` object, or more specifically `UIColor.white`.
    You can set the background color to blue like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you’d rather set it to a custom color you’ve defined, you can do so
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `alpha` value in the `UIColor` affects only the background color. This
    does make it possible to have a view that is semi-transparent without affecting
    the view’s contents like setting the view’s `alpha` property directly would. In
    other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'One important thing to note about colors within iOS is that “clear” is itself
    a color. For example, to create a view without a background color at all, you
    need to set the view’s background color to clear like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Modifying Position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Want to modify the position of a view? You have two options, and the choice
    is based on if you used constraints or not. If constraints were not used, you
    can interact with the view through its `frame`. For example, to change a view’s
    position via the frame, do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you used constraints to position the view, you’ll need to update the constraints
    directly. This can be done programmatically by creating a constraint within Interface
    Builder and assigning it to an `@IBOutlet` created within a class to edit the
    constraint’s value. If you have a width constraint defined in Interface Builder
    as `100.0`, you could change it to `50.0` in the code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also avoid setting values in the code and have two constraints added
    directly to the object in Interface Builder with one constraint turned off. Then,
    when the time is right, you could switch the constraints like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These are the most common ways to adjust constraints, but honestly, there are
    a number of different ways to go about changing the constraints an object has
    connected to it. That is the power, and complexity, of Auto Layout.
  prefs: []
  type: TYPE_NORMAL
- en: Other properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This only scratches the surface of the number of properties available within
    views. Other views, like `UILabel`, have font options available. Views like `UIImageView`
    can have `UIImage`s assigned to them. Views like `WKWebView`, the built-in web
    view provided by iOS, have yet even more complex states that can be enabled and
    toggled. It’s best to look at the documentation for a particular class on Apple’s
    documentation site to get a full understanding of the properties available for
    control.
  prefs: []
  type: TYPE_NORMAL
- en: Core Animation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing that wasn’t discussed in this chapter was Core Animation layers. This
    is a wholly different and complementary way to change and alter the appearance
    of a view. Things like `borderRadius` and `mask` make it possible to create complex
    user interfaces that are able to be animated.
  prefs: []
  type: TYPE_NORMAL
- en: SwiftUI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A successor to UIKit has arrived in the form of SwiftUI. This is a new library
    with which to build user interfaces within Swift. It’s a declarative syntax that
    has tons of promise for the next generation of UI development. It’s still early
    and a bit rough around the edges right now, but given the investment Apple is
    making in this technology, it’s a safe bet that it will become much more relevant
    and—if Apple has its way—the predominant way to build apps in a few short years.
  prefs: []
  type: TYPE_NORMAL
- en: What We’ve Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android and iOS have very different mechanisms for displaying views on a device’s
    screen, but fundamentally they have the same goal: display content to a user for
    interaction. In order to achieve that, we’ve covered the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a new view in both the platforms to display on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences in creating views with raw XML in Android and storyboards in
    iOS, which are ultimately represented using XML as the underlying file structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with changing device sizes in iOS through the use of constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ease with which views can be nested and updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information gives us a good amount of base knowledge to understand the
    next chapter on custom views. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
