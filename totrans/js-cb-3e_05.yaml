- en: Chapter 4\. Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has surprisingly capable date features, which are wrapped in the
    somewhat old-fashioned `Date` object. As you’ll see, the `Date` object has quirks
    and hidden traps—like the way it counts months starting at 0 and parses year information
    differently depending on the locale settings of the current computer. But once
    you learn to navigate these stumbling blocks, you’ll be able to accomplish a number
    of common, useful operations, like counting the days between two dates, formatting
    dates for display, and timing events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Current Date and Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to get the current date or time.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript includes a `Date` object that provides good support for manipulating
    date information (and more modest support for performing date calculations). When
    you create a new `Date` object, it is automatically populated with the current
    day and time, down to the nearest millisecond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now it’s simply a matter of extracting the information you want from your `Date`
    object. The `Date` object has a long list of methods that can help you in this
    task. [Table 4-1](#date_methods) lists the most important methods. Notice that
    the counting used by different methods isn’t always consistent. Months and weekdays
    are numbered starting at 0, while days are numbered starting at 1.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Date methods for getting pieces of date information
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Gets | Possible values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getFullYear()` | The year | A four-digit number like 2021 |'
  prefs: []
  type: TYPE_TB
- en: '| `getMonth()` | The month number | 0 to 11, where 0 represents January |'
  prefs: []
  type: TYPE_TB
- en: '| `getDate()` | The day of the month | 1 to 31 |'
  prefs: []
  type: TYPE_TB
- en: '| `getDay()` | The day of the week | 0 to 6, where 0 represents Sunday |'
  prefs: []
  type: TYPE_TB
- en: '| `getHours()` | The hour of the day | 0 to 23 |'
  prefs: []
  type: TYPE_TB
- en: '| `getMinutes()` | The minute | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: '| `getSeconds()` | The seconds | 0 to 59 |'
  prefs: []
  type: TYPE_TB
- en: '| `getMilliseconds()` | The milliseconds (one thousandth seconds) | 0 to 999
    |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s an example that displays some basic information about the current date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Date` methods listed in [Table 4-1](#date_methods) exist in two versions.
    The versions shown in the table use the local time settings. The second set of
    methods adds the prefix *UTC* (as in `getUTCMonth()` and `getUTCSeconds()`). They
    use *Coordinated Universal Time*, the global time standard. If you need to compare
    dates from different time zones (or ones that have different conventions for following
    *daylight saving time*), you must use the UTC methods. Internally, the `Date`
    object always uses UTC.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Date()` object has several constructors. The empty constructor creates
    a `Date` object for the current date and time, as you’ve just seen. But you can
    also create a `Date` object for a different date by specifying the year, month,
    and day, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once again, be wary of the inconsistent counting (months start at 0, while days
    start at 1). That means the `anotherDay` variable above represents February 10,
    *not* January 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, you can tack on up to four more parameters to the `Date` constructor
    for hours, minutes, seconds, and milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you’ll see in this chapter, JavaScript’s built-in `Date` object has some
    well-known limitations and a few quirks. If you need to perform extensive date
    operations in your code, such as calculating date ranges, parsing different types
    of date strings, or shifting dates between time zones, the best practice is to
    use a tested third-party date library, such as [*day.js*](https://github.com/iamkun/dayjs)
    or [*date-fns*](https://date-fns.org).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have a date, you may want to use it in date calculations, as explained
    in [“Comparing Dates and Testing Dates for Equality”](#comparing_dates). You may
    also be interested in turning a date into a formatted string ([“Formatting a Date
    Value as a String”](#convert_date_to_string)), or a date-containing string into
    a proper `Date` object ([“Converting a String to a Date”](#convert_string_to_date)).
  prefs: []
  type: TYPE_NORMAL
- en: Converting a String to a Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have date information in a string, but you want to convert it to a `Date`
    object so you can manipulate it in your code or perform date calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re fortunate, you’ll have your date string in the ISO 8601 standard
    timestamp format (like “2021-12-17T03:24:00Z”), which you can pass directly to
    the `Date` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The *T* in this string separates the the date from the time, and the *Z* at
    the end of the string indicates it’s a universal time using the UTC time zone,
    which is the best way to ensure consistency on different computers.
  prefs: []
  type: TYPE_NORMAL
- en: There are other formats that the `Date` constructor (and the `Date.parse()`
    method) may recognize. However, they are now strongly discouraged, because their
    implementations are not consistent across different browsers. They may appear
    to work in a test example, but they run into trouble when different browsers apply
    different locale-specific settings, like daylight saving time.
  prefs: []
  type: TYPE_NORMAL
- en: If your date isn’t in the ISO 8601 format, you’ll need to take a manual approach.
    Extract the different date components from your string, then use those with the
    `Date` constructor. You can make good use of `String` methods like `split()`,
    `slice()`, and `indexOf()`, which are explored in more detail in the recipes in
    [Chapter 2](ch02.html#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a date string in the format *mm/dd/yyyy*, you can
    use code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Date` object constructor doesn’t perform much validation. Check your input
    before you create a `Date` object, because the `Date` object may accept values
    that you would not. For example, it will allow day numbers to roll over (in other
    words, if you set 40 as your day number, JavaScript will just move your date into
    the next month). The `Date` constructor will also accept strings that may be parsed
    inconsistently on different computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attempt to create a `Date` object with a nonnumeric string, you’ll receive
    an “Invalid Date” object. You can test for this condition using `isNaN()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This technique works because `Date` objects are actually *numbers* behind the
    scenes, a fact explored in [“Comparing Dates and Testing Dates for Equality”](#comparing_dates).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Formatting a Date Value as a String”](#convert_date_to_string) explains the
    reverse operation—taking a `Date` object and converting it to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Days to a Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find a date that’s a specific number of days before or after another
    date.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find the current day number with `Date.getDate()`, then change it with `Date.setDate()`.
    The `Date` object is smart enough to roll over to the next month or year as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setDate()` method isn’t limited to positive integers. You can use a negative
    number to shift a date backward. You may want to use the other *setXxx()* methods
    to modify a date, like `setMonths()` to move it forward or backward one month
    at a time, `setHours()` to move it by hours, and so on. All these methods roll
    over just like `setDate()`, so adding 48 hours will move a date exactly two days
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Date` object is *mutable*, which makes its behavior look distinctly old-fashioned.
    In more modern JavaScript libraries, you would expect a method like `setDate()`
    to return a new `Date` object. But what it actually does is change the *current*
    `Date` object. This happens even if you declare a date with `const`. (The `const`
    prevents you from setting your variable to point to a different `Date` object,
    but it doesn’t stop you from altering the currently referenced `Date` object.)
    To safely avoid potential problems, you can clone your date before operating on
    it. Just use `Date.getTime()` to get the underlying millisecond count that represents
    your date and use it to create a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Calculating the Time Elapsed Between Two Dates”](#calculating_time_between_dates)
    shows how to calculate the time period between two dates.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Dates and Testing Dates for Equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to see if two `Date` objects represent the same calendar date, or determine
    if one date is before another.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can compare `Date` objects just like you compare numbers, with the `<`
    and `>` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Internally, dates are stored as numbers. When you use the `<` or `>` operator,
    they are automatically converted to numbers and compared. When you run this code,
    you are comparing the millisecond value for `oldDay` (943,074,000,000) to the
    millisecond value for `newerDay` (1,612,155,600,000).
  prefs: []
  type: TYPE_NORMAL
- en: The equality operator (`=`) works differently. It tests the object reference,
    not the object *content*. (In other words, two `Date` objects are equal only if
    you are comparing two variables that point to the same instance.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test if two `Date` objects represent the same moment in time,
    you need to convert them to numbers yourself. The clearest way to do this is by
    calling `Date.getTime()`, which returns the millisecond number for a date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Despite its name, `getTime()` does not return *just* the time. It returns the
    millisecond number that is an exact representation of that `Date` object’s date
    *and* time.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, a `Date` object is just an integer. Specifically, it’s the number
    of milliseconds that have elapsed since January 1, 1970\. The millisecond number
    can be negative or positive, which means that the `Date` object can represent
    dates from the distant past (roughly 271,821 BCE) to the distant future (year
    275,760 CE). You can get the millisecond number by calling `Date.getTime()`.
  prefs: []
  type: TYPE_NORMAL
- en: Two `Date` objects are only the same if they match exactly, down to the millisecond.
    Two `Date` objects that represent the same date but have a different time component
    won’t match. This can be a problem, because you may not realize that your `Date`
    object contains time information. This is a common issue when creating a `Date`
    object for the current day ([“Getting the Current Date and Time”](#get_current_date_and_time)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this issue, you can remove the time information using `Date.setHours()`.
    Despite its name, the `setHours()` method accepts up to four parameters, allowing
    you to set the hour, minute, second, and millisecond. To create a date-only `Date`
    object, set all these components to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more math with dates, see Recipes and .
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Time Elapsed Between Two Dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to calculate how many days, hours, or minutes separate two dates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because dates are numbers (in milliseconds, see [“Comparing Dates and Testing
    Dates for Equality”](#comparing_dates)), calculations with them are relatively
    straightforward. If you subtract one date from another, you get the number of
    milliseconds in between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you’re timing short operations for performance testing, the number of
    milliseconds isn’t a particularly useful unit. It’s up to you to divide this number
    to convert it into a more meaningful number of minutes, hours, or days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Even though this calculation should work out to an exact number of days (because
    neither date has any time information), you still need to use `Math.round()` on
    the result to deal with the rounding errors inherent to floating-point math (see
    [“Preserving Accuracy in Decimal Values”](ch03.html#preserving_decimal_accuracy)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two pitfalls to be aware of when performing date calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: Dates may contain time information. (For example, a new `Date` object created
    for the current day is accurate up to the millisecond it was created.) Before
    you count days, use `setHours()` to remove the time component, as explained in
    [“Comparing Dates and Testing Dates for Equality”](#comparing_dates).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculations with two dates only make sense if the dates are in the same time
    zone. Ideally, that means you are comparing two local dates or two dates in the
    UTC standard. It may seem straightforward enough to convert dates from one time
    zone to another, but often there are unexpected edge cases with daylight saving
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a tentative replacement for the aging `Date` object. The [`Temporal`
    object](https://oreil.ly/BAbB2) aims to improve calculations with local dates
    and different time zones. In the meantime, if your date needs go beyond the `Date`
    object, you can experiment with a third-party library for manipulating the date.
    Both [*day.js*](https://github.com/iamkun/dayjs) and [*date-fns*](https://date-fns.org)
    are popular choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you want to use tiny time calculations for profiling performance, the
    `Date` object is not the best choice. Instead, use the `Performance` object, which
    is available in a browser environment through the built-in `window.performance`
    property. It lets you capture a high-resolution timestamp that’s accurate to *fractions*
    of a millisecond, if supported by the system. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The result (`elapsedMilliseconds`) is not the nearest whole millisecond, but
    the most accurate fractional millisecond count that’s supported on the current
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although Node doesn’t provide the `Performance` object, it has its own mechanism
    for retrieving high-resolution time information. You use its global `process`
    object, which provides the `process.hrtime.bigint()` method. It returns a timing
    readout in *nanoseconds*, or billionths of a second. Simply subtract one `process.hrtime.bigint()`
    readout from another to find the time difference in nanoseconds. (Each millisecond
    is 1,000,000 nanoseconds.)
  prefs: []
  type: TYPE_NORMAL
- en: Because the nanosecond count is obviously going to be a very large number, you
    need to use the `BigInt` data type to hold it, as described in [“Manipulating
    Very Large Numbers with BigInt”](ch03.html#using_bigint).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Adding Days to a Date”](#adding_days_to_date) shows how to move a date forward
    or backward by adding to it or subtracting from it.'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a Date Value as a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a formatted string based on a `Date` object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you print a date with `console.log()`, you’ll get the date’s nicely formatted
    string representation, like “Wed Oct 21 2020 22:17:03 GMT-0400 (Eastern Daylight
    Time).” This representation is created by the `DateTime.toString()` method. It’s
    a standardized, nonlocale-specific date string that’s defined in the [JavaScript
    standard](https://oreil.ly/S0lMb).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Internally, the `Date` object stores its time information as a UTC time, with
    no additional time zone information. When you convert a `Date` to a string, that
    UTC time is converted into a locale-specific time for the current time zone, as
    set on the computer or device where your code is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want your date string formatted differently, you could call one of the
    other prebuilt `Date` methods demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that if you use `toLocaleString()` or `toLocaleTime()`, your string
    representation is based on the browser implementation and the settings of the
    current computer. Do not assume consistency!
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many possible ways to turn date information into a string. For display
    purposes, the *toXxxString()* methods work well. But if you want something more
    specific or fine-tuned, you may need to take control of the `Date` object yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to go beyond the standard formatting methods, there are two approaches
    you can take. You can use the *getXxx()* methods described in [“Getting the Current
    Date and Time”](#get_current_date_and_time) to extract individual time components
    from a date, and then concatenate those into the exact string you need. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This approach is extremely flexible, but it forces you to write your own date
    boilerplate, which isn’t ideal because it adds complexity and creates room for
    new bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use a standard format for a specific locale, life is a bit easier.
    You can use the `Intl.DateTimeFormat` object to perform the conversion. Here are
    three examples that use locale strings for the US, the UK, and Japan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these are date-only strings, but there are many other options you can
    set when you create the `Intl.DateTimeFormat()` object. Here’s just one example
    that adds the day of the week and month to the string, in German:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These options also give you the ability to add time information to your string
    with the `hour`, `minute`, and `second` properties, which can be set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Converting a Numeric Value to a Formatted String”](ch02.html#converting_number_to_string)
    introduced the `Intl` object and the concept of locale strings, which identify
    different geographic and cultural regions. For a comprehensive explanation of
    the 21 options the `Intl.DateTimeFormat` object supports, see the [MDN reference](https://oreil.ly/at36f).
    It’s worth noting that a few of these details are implementation dependent and
    may not be present on all browsers. (Examples include the `timeStyle`, `dateStyle`,
    and `timeZone` properties, which we haven’t discussed here.) As always, for complex
    `Date` manipulation, consider a third-party library.'
  prefs: []
  type: TYPE_NORMAL
