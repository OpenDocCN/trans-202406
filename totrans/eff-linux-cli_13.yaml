- en: Chapter 10\. Efficiency at the Keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a typical day, on a typical Linux workstation, you might have many application
    windows open: web browsers, text editors, software development environments, music
    players, video editors, virtual machines, and so on. Some applications are GUI-focused,
    such as a paint program, and tailored to a pointing device like a mouse or trackball.
    Others are more keyboard-focused, like a shell inside a terminal program. A typical
    Linux user might shift between keyboard and mouse dozens (or even hundreds) of
    times per hour. Each switch takes time. It slows you down. If you can reduce the
    number of switches, you can work more efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is about spending more time at the keyboard and less with a pointing
    device. Ten fingers tapping one hundred keys are often more nimble than a couple
    of fingers on a mouse. I’m not just talking about using keyboard shortcuts—I’m
    confident you can look them up without needing this book (though I present a few).
    I’m talking about a different approach to speed up some everyday tasks that seem
    inherently “mousey”: working with windows, retrieving information from the web,
    and copying and pasting with the clipboard.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I share tips for launching windows efficiently, particularly
    shell windows (terminals) and browser windows.
  prefs: []
  type: TYPE_NORMAL
- en: Instant Shells and Browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most Linux desktop environments, such as GNOME, KDE Plasma, Unity, and Cinnamon,
    provide some way to define hotkeys or custom keyboard shortcuts—special keystrokes
    that launch commands or perform other operations. I strongly recommend that you
    define keyboard shortcuts for these common operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a new shell window (a terminal program)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a new web browser window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these shortcuts defined, you can open a terminal or browser anytime in
    an instant, no matter what other application you’re in the middle of using.^([1](ch10.xhtml#idm46586637526832))
    To set this up, you need to know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The command that launches your preferred terminal program
  prefs: []
  type: TYPE_NORMAL
- en: Some popular ones are `gnome-terminal`, `konsole`, and `xterm`.
  prefs: []
  type: TYPE_NORMAL
- en: The command that launches your preferred browser
  prefs: []
  type: TYPE_NORMAL
- en: Some popular ones are `firefox`, `google-chrome`, and `opera`.
  prefs: []
  type: TYPE_NORMAL
- en: How to define a custom keyboard shortcut
  prefs: []
  type: TYPE_NORMAL
- en: The instructions differ for each desktop environment and may change from version
    to version, so it’s better if you look them up on the web. Search for the name
    of your desktop environment followed by “define keyboard shortcut.”
  prefs: []
  type: TYPE_NORMAL
- en: On my desktop, I assign the keyboard shortcut Ctrl-Windows-T to run `konsole`
    and Ctrl-Windows-C to run `google-chrome`.
  prefs: []
  type: TYPE_NORMAL
- en: Working Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you launch a shell via a keyboard shortcut in your desktop environment,
    it’s a child of your login shell. Its current directory is your home directory
    (unless you’ve somehow configured it to be different).
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this with opening a new shell from within your terminal program—by
    explicitly running (say) `gnome-terminal` or `xterm` at the command line or using
    your terminal program’s menu to open a new window. In this case, the new shell
    is a child of *that terminal’s shell*. Its current directory is the same as its
    parent’s, which might not be your home directory.
  prefs: []
  type: TYPE_NORMAL
- en: One-Shot Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you’re in the middle of using several applications when suddenly you
    need a shell to run one command. Many users would grab the mouse and hunt through
    their open windows for a running terminal. Don’t do this—you’re wasting time.
    Just pop open a new terminal with your hotkey, run your command, and exit the
    terminal right afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have hotkeys assigned to launch terminal programs and browser windows,
    go ahead and open and close these windows in great numbers with wild abandon.
    I recommend it! Create and destroy terminals and browser windows on a regular
    basis, rather than leaving them open for a long time. I call these short-lived
    windows *one-shot windows*. You pop them open quickly, use them for a few moments,
    and close them.
  prefs: []
  type: TYPE_NORMAL
- en: You might leave a few shells open for a long time if you’re developing software
    or performing other lengthy work, but one-shot terminal windows are perfect for
    other random commands throughout the day. *It’s often quicker to pop up a new
    terminal than to search your screen for an existing terminal.* Don’t ask yourself,
    “Where’s that terminal window I need?” and poke around the desktop looking for
    it. Make a new one and close it after it has served its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise for web browser windows. Do you ever lift your head after a long day
    of Linux hacking to discover that your browser has just one window and 83 open
    tabs? That’s a symptom of too few one-shot windows. Pop one open, view whatever
    web page you need to view, and close it. Need to revisit the page later? Locate
    it in your browser history.
  prefs: []
  type: TYPE_NORMAL
- en: Browser Keyboard Shortcuts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we’re on the topic of browser windows, make sure you know the most important
    keyboard shortcuts in [Table 10-1](#table_browser_shortcuts). If your hands are
    already on the keyboard and you want to browse to a new website, it’s often faster
    to press Ctrl-L to jump to the address bar or Ctrl-T to open a tab than to point
    and click.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. The most important keyboard shortcuts for Firefox, Google Chrome,
    and Opera
  prefs: []
  type: TYPE_NORMAL
- en: '| Action | Keyboard shortcut |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Open new window | Ctrl-N |'
  prefs: []
  type: TYPE_TB
- en: '| Open new private/incognito window | Ctrl-Shift-P (Firefox), Ctrl-Shift-N
    (Chrome and Opera) |'
  prefs: []
  type: TYPE_TB
- en: '| Open new tab | Ctrl-T |'
  prefs: []
  type: TYPE_TB
- en: '| Close tab | Ctrl-W |'
  prefs: []
  type: TYPE_TB
- en: '| Cycle through browser tabs | Ctrl-Tab (cycle forward) and Ctrl-Shift-Tab
    (cycle backward) |'
  prefs: []
  type: TYPE_TB
- en: '| Jump to address bar | Ctrl-L (or Alt-D or F6) |'
  prefs: []
  type: TYPE_TB
- en: '| Find (search) for text in current page | Ctrl-F |'
  prefs: []
  type: TYPE_TB
- en: '| Display your browsing history | Ctrl-H |'
  prefs: []
  type: TYPE_TB
- en: Switching Windows and Desktops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your busy desktop is filled with windows, how do you find the window you
    want quickly? You could point and click your way through the morass, but it’s
    often quicker to use the keyboard shortcut Alt-Tab. Keep pressing Alt-Tab and
    you cycle through all windows on the desktop, one at a time. When you reach the
    window you want, release the keys and that window is in focus and ready to use.
    To cycle in the reverse direction, press Alt-Shift-Tab.
  prefs: []
  type: TYPE_NORMAL
- en: To cycle through all windows on the desktop that belong to the same application,
    such as all Firefox windows, press Alt-` (Alt-backquote, or Alt plus the key above
    Tab). To cycle backward, add the Shift key (Alt-Shift-backquote).
  prefs: []
  type: TYPE_NORMAL
- en: Once you can switch windows, it’s time to talk about switching desktops. If
    you do serious work on Linux and you’re using just one desktop, you’re missing
    out on a great way to organize your work. Multiple desktops, also called workspaces
    or virtual desktops, are just what they sound like. Instead of a single desktop,
    you might have four or six or more, each with its own windows, and you can switch
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'On my workstation running Ubuntu Linux with KDE Plasma, I run six virtual desktops
    and assign them different purposes. Desktop #1 is my main workspace with email
    and browsing, #2 is for family-related tasks, #3 is where I run VMware virtual
    machines, #4 is for writing books like this one, and #5–6 are for any ad hoc tasks.
    These consistent assignments make it quick and easy to locate my open windows
    from different applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Linux desktop environment such as GNOME, KDE Plasma, Cinnamon, and Unity
    has its own way to implement virtual desktops, and they all provide a graphical
    “switcher” or “pager” to switch between them. I recommend defining keyboard shortcuts
    in your desktop environment to jump speedily to each desktop. On my computer,
    I defined Windows + F1 through Windows + F6 to jump to desktops #1 through #6,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other styles of working with desktops and windows. Some people
    use one desktop per application: a desktop for shells, a desktop for web browsing,
    a desktop for word processing, and so on. Some people with small laptop screens
    open just one window on each desktop, full-screen, instead of multiple windows
    per desktop. Find a style that works for you, as long as it’s speedy and efficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Web Access from the Command Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Point-and-click browsers are almost synonymous with the web, but you can also
    access websites from the Linux command line to great effect.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Browser Windows from the Command Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be accustomed to launching a web browser by clicking or tapping an
    icon, but you can also do it from the Linux command line. If the browser isn’t
    running yet, add an ampersand to run it in the background so you get your shell
    prompt back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If a given browser is already running, omit the ampersand. The command tells
    an existing browser instance to open a new window or tab. The command immediately
    exits and gives you the shell prompt back.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A backgrounded browser command might print diagnostic messages and clutter
    up your shell window. To prevent this, redirect all output to */dev/null* when
    you first launch the browser. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To open a browser and visit a URL from the command line, provide the URL as
    an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the preceding commands open a new tab and bring it into focus.
    To force them to open a new window instead, add an option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To open a private or incognito browser window, add the appropriate command-line
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands might seem like a lot of typing and effort, but you
    can be efficient by defining aliases for sites you visit often:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, if you have a file that contains a URL of interest, extract the URL
    with `grep`, `cut`, or other Linux commands and pass it to the browser on the
    command line with command substitution. Here’s an example with a tab-separated
    file with two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, suppose you keep track of packages you’re expecting with a file of tracking
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The shell script in [Example 10-1](#ex_ups) opens the tracking pages for the
    appropriate shippers (UPS, FedEx, or the US Postal Service) by appending tracking
    numbers to the appropriate URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1\. `track-it` script that hits the tracking page of shippers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving HTML with curl and wget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web browsers aren’t the only Linux programs that visit websites. The programs
    `curl` and `wget` can download web pages and other web content with a single command,
    without touching a browser. By default, `curl` prints its output to stdout, and
    `wget` saves its output to a file (after printing lots of diagnostic messages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Some sites don’t support retrieval by `wget` and `curl`. Both commands can
    masquerade as another browser in such cases. Just tell each program to change
    its user agent—the string that identifies a web client to a web server. A convenient
    user agent is “Mozilla”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `wget` and `curl` have tons of options and features that you can discover
    on their manpages. For now, let’s see how to incorporate these commands into brash
    one-liners. Suppose the website *efficientlinux.com* has a directory, *images*,
    containing files *1.jpg* through *20.jpg*, and you’d like to download them. Their
    URLs are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An inefficient method would be to visit each URL in a web browser, one at a
    time, and download each image. (Raise your hand if you’ve ever done this!) A better
    method is to use `wget`. Generate the URLs with `seq` and `awk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the string “wget” into the awk program and pipe the resulting commands
    to `bash` for execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use `xargs` to create and execute the `wget` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `xargs` solution is superior if your `wget` commands contain any special
    characters. The “pipe to bash” solution would cause the shell to evaluate those
    characters (which you don’t want to happen) whereas `xargs` would not.
  prefs: []
  type: TYPE_NORMAL
- en: 'My example was a bit contrived because the image filenames are so uniform.
    In a more realistic example, you could download all the images on a web page by
    retrieving the page with `curl`, piping it through a clever sequence of commands
    to isolate the image URLs, one per line, and then applying one of the techniques
    I just showed you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Processing HTML with HTML-XML-utils
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you know some HTML and CSS, you can parse the HTML source of web pages from
    the command line. It’s sometimes more efficient than copying and pasting chunks
    of a web page from a browser window by hand. A handy suite of tools for this purpose
    is HTML-XML-utils, which is available in many Linux distros and from the [World
    Wide Web Consortium](https://oreil.ly/81yM2). A general recipe is:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `curl` (or `wget`) to capture the HTML source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `hxnormalize` to help ensure that the HTML is well-formed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify CSS selectors for the values you want to capture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `hxselect` to isolate the values, and pipe the output to further commands
    for processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s extend the example from [“Building an Area Code Database”](ch09.xhtml#sec_areacodes)
    to grab area code data from the web and produce the *areacodes.txt* file used
    in that example. For your convenience, I’ve created an HTML table of area codes
    for you to download and process, shown in [Figure 10-1](#fig_areacodes).
  prefs: []
  type: TYPE_NORMAL
- en: '![A table of area codes, US states, and US cities](Images/elcl_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. A table of area codes at [*https://efficientlinux.com/areacodes.html*](https://efficientlinux.com/areacodes.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'First, grab the HTML source with `curl`, using the `-s` option to suppress
    on-screen messages. Pipe the output to `hxnormalize -x` to clean it up a bit.
    Pipe it to `less` to view the output one screenful at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The HTML table on that page, shown in [Example 10-2](#ex_areacodes_html), has
    CSS ID `#ac`, and its three columns (area code, state, and location) use CSS classes
    `ac`, `state`, and `cities`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. Partial HTML source of the table in [Figure 10-1](#fig_areacodes)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `hxselect` to extract the area code data from each table cell, supplying
    the `-c` option to omit the `td` tags from the output. Print the results as one
    long line, with fields separated by a character of your choice (using the `-s`
    option).^([2](ch10.xhtml#idm46586637066128)) I chose the character `@` for its
    easy visibility on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, pipe the output to `sed` to turn this long line into three tab-separated
    columns. Write a regular expression to match the following strings:'
  prefs: []
  type: TYPE_NORMAL
- en: An area code, which consists of digits, `[0-9]*`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `@` symbol
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A state abbreviation, which is two capital letters, `[A-Z][A-Z]`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `@` symbol
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cities, which is any text that doesn’t include an `@` symbol, `[^@]*`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `@` symbol
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Combine the parts to produce the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Capture the area code, state, and cities as three subexpressions by surrounding
    them with `\(` and `\)`. You now have a complete regular expression for `sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For `sed`’s replacement string, provide the three subexpressions separated
    by tabs and terminated by newlines, which produces the format of the *areacodes.txt*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine the preceding regular expression and replacement string to make this
    sed script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The finished command produces the needed data for the *areacodes.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving Rendered Web Content with a Text-Based Browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes when you retrieve data from the web at the command line, you might
    not want the HTML source of a web page, but a rendered version of the page in
    text. The rendered text might be easier to parse. To accomplish this task, use
    a text-based browser such as `lynx` or `links`. Text-based browsers display web
    pages in a stripped-down format without images or other fancy features. [Figure 10-2](#fig_lynx)
    displays the area codes page from the previous section as rendered by `lynx`.
  prefs: []
  type: TYPE_NORMAL
- en: '![lynx renders the page https://efficientlinux.com/areacodes.html](Images/elcl_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. `lynx` renders the page [*https://efficientlinux.com/areacodes.html*](https://efficientlinux.com/areacodes.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both `lynx` and `links` download a rendered page with the `-dump` option. Use
    whichever program you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`lynx` and `links` are also great for checking out a suspicious-looking link
    when you’re unsure if it’s legitimate or malicious. These text-based browsers
    don’t support JavaScript or render images, so they are less vulnerable to attack.
    (They can’t promise complete security, of course, so use your best judgment.)'
  prefs: []
  type: TYPE_NORMAL
- en: Clipboard Control from the Command Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every modern software application with an Edit menu includes the operations
    cut, copy, and paste to transfer content in and out of the system clipboard. You
    might also know keyboard shortcuts for these operations. But did you know that
    you can process the clipboard directly from the command line?
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of background first: copy and paste operations on Linux are part of a
    more general mechanism called *X selections*. A selection is a destination for
    copied content, such as the system clipboard. “X” is just the name of the Linux
    windowing software.'
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux desktop environments that are built on X, such as GNOME, Unity, Cinnamon,
    and KDE Plasma, support two selections.^([3](ch10.xhtml#idm46586636889712)) The
    first is the *clipboard*, and it works just like clipboards on other operating
    systems. When you run cut or copy operations in an application, the content goes
    to the clipboard, and you retrieve the content with a paste operation. A less
    familiar X selection is called the *primary selection*. When you select text in
    certain applications, it’s written to the primary selection even if you don’t
    run a copy operation. An example is highlighting text in a terminal window with
    the mouse. That text is automatically written to the primary selection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you connect to a Linux host remotely by SSH or similar programs, copy/paste
    generally is handled by the local computer, not by X selections on the remote
    Linux host.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 10-2](#table_clipboards) lists mouse and keyboard operations to access
    X selections in GNOME’s Terminal (`gnome-terminal`) and KDE’s Konsole (`konsole`).
    If you use a different terminal program, check its Edit menu for keyboard equivalents
    for Copy and Paste.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2\. Accessing X selections in common terminal programs
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Clipboard | Primary selection |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Copy (mouse) | Open the right button menu and select Copy | Click and drag;
    or double-click to select the current word; or triple-click to select the current
    line |'
  prefs: []
  type: TYPE_TB
- en: '| Paste (mouse) | Open the right button menu and select Paste | Press the middle
    mouse button (usually the scroll wheel) |'
  prefs: []
  type: TYPE_TB
- en: '| Copy (keyboard) | Ctrl-Shift-C | *n/a* |'
  prefs: []
  type: TYPE_TB
- en: '| Paste (keyboard), `gnome-terminal` | Ctrl-Shift-V or Ctrl-Shift-Insert |
    Shift-Insert |'
  prefs: []
  type: TYPE_TB
- en: '| Paste (keyboard), `konsole` | Ctrl-Shift-V or Shift-Insert | Ctrl-Shift-Insert
    |'
  prefs: []
  type: TYPE_TB
- en: Connecting Selections to stdin and stdout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linux provides a command, `xclip`, that connects X selections to stdin and
    stdout. You can therefore insert copy and paste operations into pipelines and
    other combined commands. For example, you may have copied text into an application
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a Linux command and redirect its output to a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: View the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your mouse to copy the file’s content to the clipboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the content into another application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `xclip`, you can shorten the process considerably:'
  prefs: []
  type: TYPE_NORMAL
- en: Pipe a Linux command’s output to `xclip`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the content into another application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Conversely, you may have pasted text into a file to process it with Linux commands
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your mouse to copy a bunch of text in an application program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste it into a text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the text file with Linux commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `xclip -o`, you can skip the intermediate text file:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your mouse to copy a bunch of text in an application program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pipe the output of `xclip -o` to other Linux commands for processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re reading this book digitally on a Linux device and want to try some
    of the `xclip` commands in this section, *don’t copy and paste the commands* into
    a shell window. Type the commands by hand. Why? Because your copy operation may
    overwrite the same X selection that the commands access with `xclip`, causing
    the commands to produce unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `xclip` reads stdin and writes the primary selection. It can read
    from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'or from a pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now print the text to stdout, or pipe the selection contents to other commands,
    such as `wc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Any combined command that writes to stdout can pipe its results to `xclip`,
    like this one from [“Command #6: uniq”](ch01.xhtml#section_uniq):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Clear the primary selection by setting its value to the empty string with `echo
    -n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `-n` option is important; otherwise, `echo` prints a newline character on
    stdout that ends up in the primary selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy text to the clipboard instead of the primary selection, run `xclip`
    with the option `-selection clipboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`xclip` options may be abbreviated as long as they’re unambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch a Firefox browser window to visit the preceding URL, using command substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Linux offers another command, `xsel`, that also reads and writes X selections.
    It has a few extra features, like clearing a selection (`xsel -c`) and appending
    to a selection (`xsel -a`). Feel free to read the manpage and experiment with
    `xsel`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Password Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s use your newfound knowledge of `xclip` to integrate X selections into
    the password manager `pman` from [“Building a Password Manager”](ch09.xhtml#section_pman).
    When the modified `pman` script matches a single line in the *vault.gpg* file,
    it writes the username to the clipboard and the password to the primary selection.
    Afterward, you can fill out a login page on the web, for example, by pasting the
    username with Ctrl-V and pasting the password with the middle mouse button.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ensure that you are *not* running a clipboard manager or any other applications
    that keep track of X selections and their contents. Otherwise, usernames and/or
    passwords become visible in the clipboard manager, which is a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new version of `pman` is in [Example 10-3](#ex_pman_clip). `pman`’s behavior
    has changed in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A new function, `load_password`, loads the associated username and password
    into X selections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `pman` locates a single match for the search string, either by key (field
    3) or by any other part of a line, it runs `load_password`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `pman` locates multiple matches, it prints all the keys and notes (fields
    3 and 4) from the matching lines so the user can search again by key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 10-3\. An improved `pman` script that loads username and password as
    selections
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Passwords hang around in the primary selection until it’s overwritten. To automatically
    clear the password after (say) 30 seconds, append the following line to the `load_password`
    function. The line launches a subshell in the background that waits 30 seconds
    and then clears the primary selection (by setting it to the empty string). Adjust
    the number 30 as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you defined a custom keyboard shortcut to launch terminal windows in [“Instant
    Shells and Browsers”](#section_popup), you now have a quick way to access your
    passwords. Pop up a terminal by hotkey, run `pman`, and close the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope this chapter has encouraged you to try some new techniques that keep
    your hands on the keyboard. They may seem effortful at first, but with practice
    they become quick and automatic. Soon you’ll be the envy of your Linux friends
    as you smoothly manipulate desktop windows, web content, and X selections in ways
    that the mouse-bound masses cannot.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.xhtml#idm46586637526832-marker)) Unless you’re working in an application
    that captures all keystrokes, such as a virtual machine in a window.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.xhtml#idm46586637066128-marker)) This example uses three CSS selectors,
    but some old versions of `hxselect` can handle only two. If your version of `hxselect`
    is afflicted by this shortcoming, download the latest version from the [World
    Wide Web Consortium](https://oreil.ly/81yM2) and build it with the command `configure
    && make`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch10.xhtml#idm46586636889712-marker)) Really there are three X selections,
    but one of them, called the *secondary selection*, is rarely exposed by modern
    desktop environments.
  prefs: []
  type: TYPE_NORMAL
