- en: Chapter 6\. Solutions for Writing Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we’ve had a look at custom controllers and operators on a conceptual
    level in [“Controllers and Operators”](ch01.html#ch_controllers-operators) and,
    in [Chapter 5](ch05.html#ch_autocodegen), how to use Kubernetes code generators—a
    rather low-level way to deal with the topic. In this chapter we’ll walk through
    three solutions for writing custom controllers and operators in detail and discuss
    some more alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Using one of the solutions discussed in this chapter should help you to avoid
    writing a lot of repetitive code and enable you to focus on the business logic,
    rather than on boilerplate code. It should get you started more quickly and make
    you more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Operators in general, and the tools we discuss in this chapter specifically,
    are still rapidly evolving as of mid-2019\. While we do our best, certain commands
    and/or their outputs you see shown here, may change. Take this into account, and
    make sure that you always use the latest version of the respective tool, keeping
    an eye on the respective issue trackers, mailing lists, and Slack channels.
  prefs: []
  type: TYPE_NORMAL
- en: While there are resources available online that [compare](http://bit.ly/2ZC5fZT)
    the solutions we discuss here, we will not recommend a specific solution to you.
    We do, however, encourage you to evaluate and compare them yourself and pick the
    one that is the best fit for your organization and environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using `cnat` (cloud-native `at`, which we introduced in [“A Motivational
    Example”](ch01.html#mot-example)) as the running example for the different solutions
    in this chapter. If you want to follow along, note that we assume you:'
  prefs: []
  type: TYPE_NORMAL
- en: Have Go version 1.12 or above installed and set up properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have access to a Kubernetes cluster in version 1.12 or above—either locally
    through, for example, `kind` or `k3d`, or remotely through your favorite cloud
    provider—and `kubectl` configured to access it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git clone` our [GitHub repository](http://bit.ly/2N3R6U4). The complete, functioning
    source code and the necessary commands shown in the following sections are available
    there. Note that what we’re showing here is how things work from scratch. If you
    want to see the results rather than carrying out the steps yourself, you’re also
    welcome to clone the repository and run only the commands to install the CRD,
    install the CR, and launch the custom controller.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With these housekeeping items out of the way, let’s jump into writing operators:
    we will covers, the `sample-controller`, Kubebuilder, and the Operator SDK in
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Ready? Let’s Go—pun intended!
  prefs: []
  type: TYPE_NORMAL
- en: Following sample-controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start off by implementing `cnat` based on the [*k8s.io/sample-controller*](http://bit.ly/2UppsTN),
    which uses the `client-go` library [directly](http://bit.ly/2Yas9HK). The `sample-controller`
    uses the [*k8s.io/code-generator*](http://bit.ly/2Kw8I8U) to generate a typed
    client, informers, listers, and deep-copy functions. Whenever the API types change
    in your custom controller—for example, adding a new field in the custom resource—you
    have to use the *update-codegen.sh* script (see also its [source](http://bit.ly/2Fq3Td1)
    in GitHub) to regenerate the aforementioned source files.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might have noticed *k8s.io* being used as the base URL throughout the book.
    We introduced its usage in [Chapter 3](ch03.html#ch_client-go); as a reminder,
    it is really an alias for *kubernetes.io*, and in the context of Go package management
    it resolves to *github.com/kubernetes*. Note that *k8s.io* does not come with
    an automatic redirect. So, for example, *k8s.io/sample-controller* really means
    that you should be looking at [*github.com/kubernetes/sample-controller*](http://bit.ly/2UppsTN),
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: OK, let’s implement our [`cnat`](http://bit.ly/2RpHhON) operator using `client-go`,
    following the `sample-controller`. (See the [corresponding directory in our repo](http://bit.ly/2N3R6U4).)
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin, do a **`go get k8s.io/sample-controller`** to get the source and dependencies
    onto your system, which should be in *$GOPATH/src/k8s.io/sample-\controller*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you start from scratch, copy the content of the *sample-controller* directory
    into a directory of your choice (for example, we use *cnat-client-go* in our repo),
    and you can run the following command sequence to build and run the base controller
    (with the default implementation, not the `cnat` business logic yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will launch the custom controller and wait for you to register
    the CRD and create a custom resource. Let’s do this now and see what happens.
    In a second terminal session, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure the CRD is properly registered and available like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that you may see other CRDs here, depending on the Kubernetes distro you’re
    using; however, *foos.samplecontroller.k8s.io* should be listed, at least.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the example custom resource *foo.samplecontroller.k8s.io/example-foo*
    and check if the controller does its job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Yay, it works as expected! We can now move on to implementing the actual `cnat`-specific
    business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Business Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To kick off implementing the business logic, we first rename the existing directory
    *pkg/apis/samplecontroller* to *pkg/apis/cnat* and then create our own CRD and
    custom resource as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that whenever the API types change—for example, when you add a new field
    to the `At` CRD—you have to execute the *update-codegen.sh* script, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will automatically generate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*pkg/apis/cnat/v1alpha1/zz_generated.deepcopy.go*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pkg/generated/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of the business logic, we have two parts to implement in the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: In [*types.go*](http://bit.ly/31QosJw) we modify the `AtSpec` struct to include
    the respective fields, such as `schedule` and `command`. Note that you must run
    `update-codegen.sh` whenever you change something here in order to regenerate
    dependent files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*controller.go*](http://bit.ly/31MM4OS) we change the `NewController()`
    and `syncHandler()` functions as well as add helper functions, including creating
    pods and checking schedule time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *types.go*, note the three constants representing the three phases of the
    `At` resource: up until the scheduled time in `PENDING`, then `RUNNING` to completion,
    and finally in the `DONE` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note the explicit usage of the build tags `+k8s:deepcopy-gen:interfaces` (refer
    to [Chapter 5](ch05.html#ch_autocodegen)) so that the respective sources are autogenerated.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in the position to implement the business logic of the custom controller.
    That is, we implement the state transitions between the three phases—from `PhasePending`
    to `PhaseRunning` to `PhaseDone`—in [controller.go](http://bit.ly/31MM4OS).
  prefs: []
  type: TYPE_NORMAL
- en: 'In [“Work Queue”](ch03.html#workqueue) we introduced and explained the work
    queue that `client-go` provides. We can now put this knowledge to work: in the
    `processNextWorkItem()` in *controller.go*—to be more precise, in [lines 176 to
    186](http://bit.ly/2WYDbyi)—you can find the following (generated) code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet shows how our (yet-to-be-written) custom `syncHandler()` function
    (explained shortly) is invoked and covers these three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `if` branch requeues the item via the `AddRateLimited()` function
    call, handling transient errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second branch, the `else if`, requeues the item via the `AddAfter()` function
    call to avoid hot-looping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last case, the `else`, is where the item has been processed successfully
    and is discarded via the `Forget()` function call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we’ve got a sound understanding of the generic handling, let’s move
    on to the business-logic-specific functionality. Key to it is the aforementioned
    `syncHandler()` function, where we are implementing the business logic of our
    custom controller. It has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This `syncHandler()` function implements the following state transitions:^([1](ch06.html#idm46336858995208))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, to set up informers and the controller at large, we implement the
    following in `NewController()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two further helper functions we need in order to make it work: one
    calculates the time until the schedule, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'and the other creates a pod with the command to execute, using a `busybox`
    container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will be reusing these two helper functions and the basic flow of the business
    logic as presented here in the `syncHandler()` function later in this chapter,
    so make sure you familiarize yourself with their details.
  prefs: []
  type: TYPE_NORMAL
- en: Note that from the point of the `At` resource, the pod is a secondary resource
    and the controller must make sure to clean those pods up or otherwise risk orphaned
    pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `sample-controller` is a good tool to learn how the sausage is made, but
    usually you want to focus on creating the business logic rather than dealing with
    the boilerplate code. For this, there are two related projects you can choose
    from: Kubebuilder and the Operator SDK. Let’s have a look at each and how `cnat`
    is implemented with them.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubebuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Kubebuilder](http://bit.ly/2I8w9mz), owned and maintained by the Kubernetes
    Special Interest Group (SIG) API Machinery, is a tool and set of libraries enabling
    you to build operators in an easy and efficient manner. The best resource for
    a deep dive on Kubebuilder is the online [Kubebuilder book](https://book.kubebuilder.io),
    which walks you through its components and usage. We will, however, focus here
    on implementing our [`cnat`](http://bit.ly/2RpHhON) operator with Kubebuilder
    (see [the corresponding directory in our Git repository](http://bit.ly/2Iv6pAS)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s make sure all the dependencies—that is, [dep](http://bit.ly/2x9Yrqq),
    [kustomize](http://bit.ly/2Y3JeCV) (see [“Kustomize”](ch07.html#kustomize)), and
    [Kubebuilder itself](http://bit.ly/32pQmfu)—are installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’ll walk you through the steps for writing the `cnat` operator from scratch.
    First, create a directory of your choice (we use *cnat-kubebuilder* in our repo)
    that you’ll use as the base for all further commands.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the time of this writing, Kubebuilder is moving to a new version (v2). Since
    it’s not stable yet, we show the commands and setup for (stable) [version v1](https://book-v1.book.kubebuilder.io).
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To bootstrap the `cnat` operator, we use the `init` command like so (note that
    this can take several minutes, depending on your environment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On completion of this command, Kubebuilder has scaffolded the operator, effectively
    generating a bunch of files, from the custom controller to a sample CRD. Your
    base directory should now look something like the following (excluding the huge
    *vendor* directory for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an API—that is, a custom controller—using the `create api`
    command (this should be faster than the previous command but still takes a little
    while):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what has changed, focusing on the two directories that have received
    updates and additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note the addition of *cnat_v1alpha1_at.yaml* in *config/crds/*, which is the
    CRD, as well as *cnat_v1alpha1_at.yaml* (yes, the same name) in *config/samples/*,
    representing a custom resource example instance of the CRD. Further, in *pkg/*
    we see a number of new files, most importantly *apis/cnat/v1alpha1/at_types.go*
    and *controller/at/at_controller.go*, both of which we will modify next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a dedicated namespace, `cnat`, in Kubernetes and use it as
    the default, setting the context as follows (as a good practice, always use a
    dedicated namespace, not the `default` one):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We install the CRD with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can launch the operator locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Leave the terminal session running and, in a new session, install the CRD,
    validate it, and create the sample custom resource like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now look at the output of the session where `make run` runs, you should
    notice the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that the overall setup was successful! Now that we’ve completed
    the scaffolding and successfully launched the `cnat` operator, we can move on
    to the actual core task: implementing the `cnat` business logic with Kubebuilder.'
  prefs: []
  type: TYPE_NORMAL
- en: Business Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For starters, we’ll change [*config/crds/cnat_v1alpha1_at.yaml*](http://bit.ly/2N1jQNb)
    and [*config/samples/cnat_v1alpha1_at.yaml*](http://bit.ly/2Xs1F7c) to our own
    definitions of the `cnat` CRD and custom resource values, re-using the same structures
    as in [“Following sample-controller”](#cnat-client-go).
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the business logic, we have two parts to implement in the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: In [*pkg/apis/cnat/v1alpha1/at_types.go*](http://bit.ly/31KNLfO) we modify the
    `AtSpec` struct to include the respective fields, such as `schedule` and `command`.
    Note that you must run `make` whenever you change something here in order to regenerate
    dependent files. Kubebuilder uses the Kubernetes generators (described in [Chapter 5](ch05.html#ch_autocodegen))
    and ships its own set of generators (e.g., to generate the CRD manifest).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*pkg/controller/at/at_controller.go*](http://bit.ly/2Iwormg) we modify the
    `Reconcile(request reconcile.Request)` method to create a pod at the time defined
    in `Spec.Schedule`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *at_types.go*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In *at_controller.go* we implement the state transition between the three phases,
    `PENDING` to `RUNNING` to `DONE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note here that the `Update` call at the end operates on the */status* subresource
    (see [“Status subresource”](ch04.html#status-subresource)) instead of the whole
    CR. Hence, here we follow the best practice of a spec-status split.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once the CR `example-at` is created, we see the following output of the
    locally executed operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify whether our custom controller has done its job, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! The `example-at-pod` has been created, and now it’s time to see the
    result of the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re done developing the custom controller, using local mode as shown
    here, you’ll likely want to build a container image out of it. This custom controller
    container image can subsequently be used, for example, in a Kubernetes deployment.
    You can use the following command to generate the container image and push it
    into the repo *quay.io/pk/cnat*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this we move on to the Operator SDK, which shares some of Kubebuilder’s
    code base and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The Operator SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make it easier to build Kubernetes applications, CoreOS/Red Hat has put together
    the Operator Framework. Part of that is the [Operator SDK](http://bit.ly/2KtpK7D),
    which enables developers to build operators without requiring deep knowledge of
    Kubernetes APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The Operator SDK provides the tools to build, test, and package operators. While
    there is much more functionality available in the SDK, especially around testing,
    we focus here on implementing our [`cnat`](http://bit.ly/2RpHhON) operator with
    the SDK (see [the corresponding directory in our Git repository](http://bit.ly/2FpCtE9)).
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: make sure to [install the Operator SDK](http://bit.ly/2ZBQlCT)
    and check if all dependencies are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Bootstrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it’s time to bootstrap the `cnat` operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, and very similar to Kubebuilder, we add an API—or simply put: initialize
    the custom controller like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These commands generate the necessary boilerplate code as well as a number of
    helper functions, such as the deep-copy functions `DeepCopy()`, `DeepCopyInto()`,
    and `DeepCopyObject()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re in a position to apply the autogenerated CRD to the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s launch our `cnat` custom controller locally. With this, it can start
    processing requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our custom controller will remain in this state until we create a CR, *ats.cnat.programming-kubernetes.info*.
    So let’s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Business Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In terms of the business logic, we have two parts to implement in the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: In [*pkg/apis/cnat/v1alpha1/at_types.go*](http://bit.ly/31Ip2sF) we modify the
    `AtSpec` struct to include the respective fields, such as `schedule` and `command`,
    and use `operator-sdk generate k8s` to regenerate code, as well as using the `operator-sdk
    generate openapi` command for the OpenAPI bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*pkg/controller/at/at_controller.go*](http://bit.ly/2Fpo5Mi) we modify the
    `Reconcile(request reconcile.Request)` method to create a pod at the time defined
    in `Spec.Schedule`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The changes applied to the bootstrapped code in greater detail are as follows
    (focusing on the relevant bits). In *at_types.go*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In *at_controller.go* we implement the state diagram for the three phases, `PENDING`
    to `RUNNING` to `DONE`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The [`controller-runtime`](http://bit.ly/2ZFtDKd) is another SIG API Machinery–owned
    project, aimed at providing a common set of low-level functionality for building
    controllers in the form of Go packages. See [Chapter 4](ch04.html#ch_crds) for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'As both Kubebuilder and the Operator SDK share the controller runtime, the
    `Reconcile()` function is in fact the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the CR `example-at` is created, we see the following output of the locally
    executed operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see the three phases of our operator: `PENDING` until timestamp
    `1555044964.518566`, then `RUNNING`, then `DONE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate the function of our custom controller and check the result of the
    operation, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re done developing the custom controller, using local mode as shown
    here, you’ll likely want to build a container image out of it. This custom controller
    container image can subsequently be used, for example, in a Kubernetes deployment.
    You can use the following command to generate the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some further resources to learn more about the Operator SDK and examples
    around it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[“A Complete Guide to Kubernetes Operator SDK”](http://bit.ly/2RqkGSf) by Toader
    Sebastian on BanzaiCloud'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rob Szumski’s blog post [“Building a Kubernetes Operator for Prometheus and
    Thanos”](http://bit.ly/2KvgHmu)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Kubernetes Operator Development Guidelines for Improved Usability”](http://bit.ly/31P7rPC)
    from CloudARK on ITNEXT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To wrap up this chapter, let’s look at some alternative ways to write custom
    controllers and operators.
  prefs: []
  type: TYPE_NORMAL
- en: Other Approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to, or potentially in combination with, the approaches we’ve discussed,
    you might want to have a look at the following projects, libraries, and tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Metacontroller](https://metacontroller.app)'
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of Metacontroller is to provide you with a declarative specification
    of the state and changes, interfacing with JSON, based on a level-triggered reconciliation
    loop. That is, you receive JSON describing the observed state and return JSON
    describing your desired state. This is especially useful for rapid development
    of automation in dynamic scripting languages like Python or JavaScript. In addition
    to simple controllers, Metacontroller allows you to compose APIs into higher-level
    abstractions—for example, [BlueGreenDeployment](http://bit.ly/31KNTfi).
  prefs: []
  type: TYPE_NORMAL
- en: '[KUDO](https://kudo.dev)'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to Metacontroller, KUDO provides a declarative approach to building
    Kubernetes operators, covering the entire application lifecycle. In a nutshell,
    it’s Mesosphere’s experience from Apache Mesos frameworks, ported to Kubernetes.
    KUDO is highly opinionated but also easy to use and requires little to no coding;
    essentially, all you have to specify is a collection of Kubernetes manifests with
    a built-in logic to define what is executed when.
  prefs: []
  type: TYPE_NORMAL
- en: '[Rook operator kit](http://bit.ly/2J34faw)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a common library for implementing operators. It originated from the
    Rook operator but has been spun out into a separate, independent project.
  prefs: []
  type: TYPE_NORMAL
- en: '[ericchiang/k8s](http://bit.ly/2ZHc5h0)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a slimmed-down Go client by Eric Chiang generated using the Kubernetes
    protocol buffer support. It behaves similarly to the official Kubernetes `client-go`,
    but imports only two external dependencies. While it comes with certain limitations—for
    example, in terms of [cluster access configuration](http://bit.ly/2ZBQIxh)—it
    is a simple-to-use Go package.
  prefs: []
  type: TYPE_NORMAL
- en: '[`kutil`](http://bit.ly/2Fq3ojh)'
  prefs: []
  type: TYPE_NORMAL
- en: AppsCode provides Kubernetes `client-go` add-ons via `kutil`.
  prefs: []
  type: TYPE_NORMAL
- en: CLI-client-based approaches
  prefs: []
  type: TYPE_NORMAL
- en: A client-side approach, mainly for experimentation and testing, is to leverage
    `kubectl` programmatically (e.g., the [kubecuddler](http://bit.ly/2L3CDoi) library).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While we focus on writing operators using the Go programming language in this
    book, you can write operators in other languages. Two notable examples are Flant’s
    [Shell-operator](http://bit.ly/2ZxkZ0m), which enables you to write operators
    in good old shell scripts, and Zalando’s [Kopf (Kubernetes operators framework)](http://bit.ly/2WRXU6Q),
    a Python framework and a library.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the beginning of this chapter, the operator field is rapidly
    evolving, and more and more practitioners are sharing their knowledge in the form
    of code and best practices, so keep an eye on new tooling here. Make sure to check
    out online resources and forums, such as the `#kubernetes-operators`, `#kubebuilder`,
    and `#client-go-docs` channels on the Kubernetes Slack, to learn about new approaches
    and/or discuss issues and receive help when you’re stuck.
  prefs: []
  type: TYPE_NORMAL
- en: Uptake and Future Directions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jury is still out on which of the approaches to write operators will be
    the most popular and widely used. In the context of the Kubernetes project, there
    are activities in several SIGs when it comes to CRs and controllers. The main
    stakeholder is the SIG [API Machinery](http://bit.ly/2RuTPEp), which owns CRs
    and controllers and is responsible for the [Kubebuilder](http://bit.ly/2I8w9mz)
    project. The Operator SDK has increased its efforts to align with the Kubebuilder
    API, so there’s a lot of overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we had a look at different tools allowing you to write custom
    controllers and operators more efficiently. Traditionally, following the `sample-controller`
    was the only option out there, but with Kubebuilder and the Operator SDK you now
    have two options that allow you to focus on the business logic of your custom
    controller rather than dealing with boilerplate. And luckily these two tools share
    a lot of APIs and code, so moving from one to the other should not be too difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how to deliver the results of our labor—that is, how to package
    and ship the controllers we’ve been writing.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch06.html#idm46336858995208-marker)) We’re only showing the relevant sections
    here; the function itself has a lot of other boilerplate code we’re not concerned
    with for our purposes.
  prefs: []
  type: TYPE_NORMAL
