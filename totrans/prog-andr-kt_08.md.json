["```\ndata class Hike(\n   val name: String,\n   val miles: Float,\n   val ascentInFeet: Int)\n\nclass Weather // Implementation removed for brevity\n\ndata class HikeData(val hike: Hike, val weather: Weather?)\n```", "```\nfun fetchHikesForUser(userId: String): List<Hike> {\n    // implementation removed for brevity\n}\n\nfun fetchWeather(hike: Hike): Weather {\n    // implementation removed for brevity\n}\n```", "```\nclass HikesViewModel : ViewModel() {\n    private val ioThreadPool: ExecutorService =\n        Executors.newWorkStealingPool(10)\n\n    fun fetchHikesAsync(userId: String) {\n        ioThreadPool.submit {\n            val hikes = fetchHikesForUser(userId)\n            onHikesFetched(hikes)\n        }\n    }\n\n    private fun onHikesFetched(hikes: List<Hike>) {\n        // Continue with the rest of the view-model logic\n        // Beware, this code is executed from a background thread\n    }\n}\n```", "```\nprivate val ioThreadPool: ExecutorService =\n    ThreadPoolExecutor(\n        4,   // Initial pool size\n        10,  // Maximum pool size\n        1L,\n        TimeUnit.SECONDS,\n        LinkedBlockingQueue()\n    )\n```", "```\nclass HikesViewModel : ViewModel() {\n    // other attributes\n    private val hikeDataList = mutableListOf<HikeData>()\n    private val hikeLiveData = MutableLiveData<List<HikeData>>()\n\n    fun fetchHikesAsync(userId: String) { // content hidden } \n    private fun onHikesFetched(hikes: List<Hike>) {\n        hikes.forEach { hike  ->\n            ioThreadPool.submit {\n                val weather = fetchWeather(hike)         ![1](assets/1.png)\n                val hikeData = HikeData(hike, weather)   ![2](assets/2.png)\n                hikeDataList.add(hikeData)               ![3](assets/3.png)\n                hikeLiveData.postValue(hikeDataList)     ![4](assets/4.png)\n            }\n        }\n    }\n}\n```", "```\nfun addHike(hike: Hike) {\n    hikeDataList.add(HikeData(hike, null))\n    // then fetch Weather and notify view using hikeLiveData\n}\n```", "```\npublic final boolean post(@NonNull Runnable r) { ... }\n```", "```\n// Direct translation in Kotlin (though not idiomatic)\nhandler.post(object: Runnable {\n      override fun run() {\n         // content of run\n      }\n   }\n)\n\n// ..which can be nicely simplified into:\nhandler.post {\n    // content of `run` method\n}\n```", "```\nval handler: Handler = Handler(Looper.getMainLooper())\n```", "```\nclass HikesViewModel : ViewModel() {\n    private val ioThreadPool: ExecutorService = Executors.newWorkStealingPool(10)\n    private val hikeDataList = mutableListOf<HikeData>()\n    private val hikeLiveData = MutableLiveData<List<HikeData>>()\n    private val handler: Handler = Handler(Looper.getMainLooper())\n\n    private fun onHikesFetched(hikes: List<Hike>) {\n        hikes.forEach { hike  ->\n            ioThreadPool.submit {\n                val weather = fetchWeather(hike)\n                val hikeData = HikeData(hike, weather)\n\n                // Here we post a Runnable\n                handler.post {\n                    hikeDataList.add(hikeData)           ![1](assets/1.png)\n                    hikeLiveData.value = hikeDataList    ![2](assets/2.png)\n                }\n            }\n        }\n    }\n\n    // other methods removed for brevity }\n```", "```\nsuspend fun hikesForUser(userId: String): List<Hike> {\n    return withContext(Dispatchers.IO) {\n        fetchHikesForUser(userId)\n    }\n}\n```", "```\nsuspend fun weatherForHike(hike: Hike): Weather {\n    return withContext(Dispatchers.IO) {\n        fetchWeather(hike)\n    }\n}\n```", "```\nclass HikesViewModel : ViewModel() {\n    private val hikeDataList = mutableListOf<HikeData>()\n    private val hikeLiveData = MutableLiveData<List<HikeData>>()\n\n    fun update() {\n        viewModelScope.launch {                                 ![1](assets/1.png)\n            /* Step 1: get the list of hikes */\n            val hikes = hikesForUser(\"userId\")                  ![2](assets/2.png)\n\n            /* Step 2: for each hike, get the weather, wrap into a\n             * container, update hikeDataList, then notify view\n             * listeners by updating the corresponding LiveData */\n            hikes.forEach { hike ->                             ![3](assets/3.png)\n                launch {\n                    val weather = weatherForHike(hike)          ![4](assets/4.png)\n                    val hikeData = HikeData(hike, weather)\n                    hikeDataList.add(hikeData)\n                    hikeLiveData.value = hikeDataList\n                }\n            }\n        }\n    }\n}\n```", "```\nlaunch {\n    val weather = weatherForHike(hike)\n    val hikeData = HikeData(hike, weather)\n    hikeDataList.add(hikeData)\n    hikeLiveData.value = hikeDataList\n}\n```", "```\nval ViewModel.viewModelScope: CoroutineScope\n  get() {\n    val scope: CoroutineScope? = this.getTag(JOB_KEY)\n    if (scope != null) {\n       return scope\n    }\n    return setTagIfAbsent(\n       JOB_KEY,\n       CloseableCoroutineScope(\n          SupervisorJob() +  Dispatchers.Main.immediate))\n  }\n\n```", "```\nval job = scope.launch(start = CoroutineStart.LAZY) { ... }\n// some work\njob.start()\n```", "```\nviewModelScope.launch {\n    launch {\n        fetchData()   // might take some time\n    }\n    launch {\n        fetchOtherData()\n    }\n}\n```", "```\nval startTime = System.currentTimeMillis()\nval job = launch(Dispatchers.Default) {\n    var nextPrintTime = startTime\n    while (true) {\n        if (System.currentTimeMillis() >= nextPrintTime) {\n            println(\"job: I'm working..\")\n            nextPrintTime += 500\n        }\n    }\n}\ndelay(1200)\nprintln(\"main: I'm going to cancel this job\")\njob.cancel()\nprintln(\"main: Done\")\n```", "```\njob: I'm working..\njob: I'm working..\njob: I'm working..\nmain: I'm going to cancel this job\nmain: Done\njob: I'm working..\njob: I'm working..\n```", "```\nval job = launch(Dispatchers.Default) {\n    var nextPrintTime = startTime\n    while (isActive) {\n        if (System.currentTimeMillis() >= nextPrintTime) {\n            println(\"job: I'm working..\")\n            nextPrintTime += 500\n        }\n    }\n}\n```", "```\n/**\n * Returns true when the current Job is still active (has not\n * completed and was not cancelled yet).\n */\nval CoroutineScope.isActive: Boolean (source)\n```", "```\njob: I'm working..\njob: I'm working..\njob: I'm working..\nmain: I'm going to cancel this job\nmain: Done\n```", "```\nif (!isActive) {\n    throw CancellationException()\n}\n```", "```\nfun run() {\n    val request = Request.Builder()\n        .url(\"https://publicobject.com/helloworld.txt\")\n        .build()\n\n    client.newCall(request).execute().use { response ->\n      if (!response.isSuccessful)\n          throw IOException(\"Unexpected code $response\")\n\n      for ((name, value) in response.headers) {\n        println(\"$name: $value\")\n      }\n\n      println(response.body?.string())\n    }\n}\n```", "```\nif (!isActive) {\n    call.cancel()\n    return\n}\n```", "```\nsuspend fun Call.await() = suspendCancellableCoroutine<ResponseBody?> {\n    continuation ->\n\n    continuation.invokeOnCancellation {\n        cancel()\n    }\n\n    enqueue(object : Callback {\n        override fun onResponse(call: Call, response: Response) {\n            continuation.resume(response.body)\n        }\n\n        override fun onFailure(call: Call, e: IOException) {\n            continuation.resumeWithException(e)\n        }\n    })\n}\n```", "```\npublic suspend inline fun <T> suspendCancellableCoroutine(\n    crossinline block: (CancellableContinuation<T>) -> Unit\n): T\n```", "```\ncontinuation.invokeOnCancellation {\n    cancel()   // Call.cancel()\n}\n```", "```\nfun main() = runBlocking {\n    val job = launch {                                        ![1](assets/1.png)\n        val response = performHttpRequest()                   ![2](assets/2.png)\n        println(\"Got response ${response?.string()}\")\n    }\n    delay(200)                                                ![3](assets/3.png)\n    job.cancelAndJoin()                                       ![4](assets/4.png)\n    println(\"Done\")\n}\n\nval okHttpClient = OkHttpClient()\nval request = Request.Builder().url(\n    \"http://publicobject.com/helloworld.txt\"\n).build()\n\nsuspend fun performHttpRequest(): ResponseBody? {\n     return withContext(Dispatchers.IO) {\n         val call = okHttpClient.newCall(request)\n         call.await()\n     }\n}\n```", "```\nsuspend fun wasteCpu() = withContext(Dispatchers.Default) {\n    var nextPrintTime = System.currentTimeMillis()\n    while (isActive) {\n        if (System.currentTimeMillis() >= nextPrintTime) {\n            println(\"job: I'm working..\")\n            nextPrintTime += 500\n        }\n    }\n}\n```", "```\nsuspend fun wasteCpu() = withContext(Dispatchers.Default) {\n    var nextPrintTime = System.currentTimeMillis()\n    while (isActive) {\n        if (System.currentTimeMillis() >= nextPrintTime) {\n            println(\"job: I'm working..\")\n            nextPrintTime += 500\n        }\n    }\n\n    // cleanup\n    if (!isActive) { .. }\n}\n```", "```\nfun main() = runBlocking {\n    val job = launch {\n        try {\n            wasteCpu()\n        } catch (e: CancellationException) {\n            // handle cancellation\n        }\n    }\n    delay(200)\n    job.cancelAndJoin()\n    println(\"Done\")\n}\n```", "```\nkotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job=\"wasteCpu#2\":StandaloneCoroutine{Cancelling}@53bd815b\n```", "```\npublic suspend fun delay(timeMillis: Long) {\n    if (timeMillis <= 0) return // don't delay\n    return suspendCancellableCoroutine sc@ { .. }\n}\n```", "```\nprivate suspend fun wasteCpu() = withContext(Dispatchers.Default) {\n    var nextPrintTime = System.currentTimeMillis()\n    while (true) {       ![1](assets/1.png)\n        delay(10)        ![2](assets/2.png)\n        if (System.currentTimeMillis() >= nextPrintTime) {\n            println(\"job: I'm working..\")\n            nextPrintTime += 500\n        }\n    }\n}\n```", "```\nsuspend fun compute() = withContext(Dispatchers.Default) {\n     blockingCall()  // a regular blocking call, hopefully not blocking too long\n     yield()  // give the opportunity to cancel\n     anotherBlockingCall()   // because why not\n}\n```", "```\nlaunch {\n    try {\n        suspendCall()\n    } catch (e: CancellationException) {\n       // handle cancellation\n       anotherSuspendCall()\n   }\n}\n```", "```\nlaunch {\n    try {\n        suspendCall()\n    } catch (e: CancellationException) {\n       // handle cancellation\n       withContext(NonCancellable) {\n            anotherSuspendCall()\n       }\n   }\n}\n```", "```\nfun main() = runBlocking {\n    val job = launch {\n        val child1 = launch {\n            delay(Long.MAX_VALUE)\n        }\n        val child2 = launch {\n            child1.join()\n            println(\"Child 1 is cancelled\")\n\n            delay(100)\n            println(\"Child 2 is still alive!\")\n        }\n\n        println(\"Cancelling child 1..\")\n        child1.cancel()\n        child2.join()\n        println(\"Parent is not cancelled\")\n    }\n    job.join()\n}\n```", "```\nCancelling child 1..\nChild 1 is cancelled\nChild 2 is still alive!\nParent is not cancelled\n```", "```\nfun main() = runBlocking {\n    val scope = CoroutineScope(coroutineContext + Job())    ![1](assets/1.png)\n\n    val job = scope.launch {                                ![2](assets/2.png)\n        launch {\n            try {\n                delay(Long.MAX_VALUE)                       ![3](assets/3.png)\n            } finally {\n                println(\"Child 1 was cancelled\")\n            }\n        }\n\n        launch {\n            delay(1000)                                     ![4](assets/4.png)\n            throw IOException()\n        }\n    }\n    job.join()                                              ![5](assets/5.png)\n}\n```", "```\nfun main() = runBlocking {\n    val ceh = CoroutineExceptionHandler { _, exception ->\n        println(\"Caught original $exception\")\n    }\n    val scope = CoroutineScope(coroutineContext + ceh + Job())\n\n    val job = scope.launch {\n         // same as in the previous code sample\n    }\n}\n```", "```\nfun main() = runBlocking {\n    val ceh = CoroutineExceptionHandler { _, exception ->\n        println(\"Caught original $exception\")\n    }\n\n    // The CEH can also be part of the scope\n    val scope = CoroutineScope(coroutineContext + Job())\n\n    val job = scope.launch(ceh) {\n        // same as in the previous code sample\n    }\n}\n```", "```\nChild 1 was cancelled\nCaught original java.io.IOException\n```", "```\nfun main() = runBlocking {\n    val ceh = CoroutineExceptionHandler { _, e -> println(\"Handled $e\") }\n    val supervisor = SupervisorJob()\n    val scope = CoroutineScope(coroutineContext + ceh + supervisor)\n    with(scope) {\n        val firstChild = launch {\n            println(\"First child is failing\")\n            throw AssertionError(\"First child is cancelled\")\n        }\n\n        val secondChild = launch {\n            firstChild.join()\n\n            delay(10) // playing nice with hypothetical cancellation\n            println(\"First child is cancelled: ${firstChild.isCancelled}, but second one is still active\")\n        }\n\n        // wait until the second child completes\n        secondChild.join()\n    }\n}\n```", "```\nFirst child is failing\nHandled java.lang.AssertionError: First child is cancelled\nFirst child is cancelled: true, but second one is still active\n```", "```\nfun main() = runBlocking {\n    val ceh = CoroutineExceptionHandler { _, e -> println(\"Handled $e\") }\n    val supervisor = SupervisorJob()\n    val scope = CoroutineScope(coroutineContext + supervisor)\n    with(scope) {\n        val firstChild = launch(ceh) {\n            println(\"First child is failing\")\n            throw AssertionError(\"First child is cancelled\")\n        }\n\n        val secondChild = launch {\n            firstChild.join()\n\n            delay(10)\n            println(\"First child is cancelled: ${firstChild.isCancelled}, but second one is still active\")\n        }\n\n        // wait until the second child completes\n        secondChild.join()\n    }\n}\n```", "```\nval firstChild = launch {\n    println(\"First child is failing\")\n    launch(ceh) {\n       throw AssertionError(\"First child is cancelled\")\n    }\n}\n```", "```\nprivate suspend fun weatherForHike(hike: Hike): Weather =\n        withContext(Dispatchers.IO) {\n   val deferredWind = async { fetchWind(hike) }\n   val deferredTemp = async { fetchTemperatures(hike) }\n   val wind = deferredWind.await()\n   val temperatures = deferredTemp.await()\n   Weather(wind, temperatures) // assuming Weather can be built that way\n}\n```", "```\nprivate suspend fun weatherForHike(hike: Hike): Weather = coroutineScope {\n    // Wind and temperature fetch are performed concurrently\n    val deferredWind = async(Dispatchers.IO) {\n        fetchWind(hike)\n    }\n    val deferredTemp = async(Dispatchers.IO) {\n        fetchTemperatures(hike)\n    }\n   val wind = deferredWind.await()\n   val temperatures = deferredTemp.await()\n   Weather(wind, temperatures) // assuming Weather can be built that way\n}\n```", "```\npublic suspend fun <R> coroutineScope(block: suspend CoroutineScope.() -> R): R\n```", "```\nscope.launch {\n    try {\n        regularFunctionWhichCanThrowException()\n    } catch (e: Exception) {\n        // handle exception\n    }\n}\n```", "```\nfun main() = runBlocking {\n\n    val itemCntDeferred = async {\n        try {\n            getItemCount()\n        } catch (e: Exception) {\n            // Something went wrong. Suppose you don't care and consider it should return 0.\n            0\n        }\n    }\n\n    val count = itemCntDeferred.await()\n    println(\"Item count: $count\")\n}\n\nfun getItemCount(): Int {\n    throw Exception()\n    1\n}\n```", "```\nItem count: 0\n```", "```\nscope.launch {\n     val result = runCatching {\n           regularFunctionWhichCanThrowException()\n     }\n\n     if (result.isSuccess) {\n         // no exception was thrown\n     } else {\n         // exception was thrown\n     }\n}\n```", "```\n/**\n * Calls the specified function [block] with `this` value as its receiver\n * and returns its encapsulated result if invocation was successful,\n * catching and encapsulating any thrown exception as a failure.\n */\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n```", "```\nfun main() = runBlocking {\n\n    val scope = CoroutineScope(Job())\n\n    val job = scope.launch {\n        supervisorScope {\n            val task1 = launch {\n                // simulate a background task\n                delay(1000)\n                println(\"Done background task\")\n            }\n\n            val task2 = async {\n                // try to fetch some count, but it fails\n                throw Exception()\n                1\n            }\n\n            try {\n                task2.await()\n            } catch (e: Exception) {\n                println(\"Caught exception $e\")\n            }\n            task1.join()\n        }\n    }\n\n    job.join()\n    println(\"Program ends\")\n}\n```", "```\nCaught exception java.lang.Exception\nDone background task\nProgram ends\n```", "```\nfun main() = runBlocking {\n\n    val scope = CoroutineScope(Job())\n\n    val job = scope.launch {\n        coroutineScope {\n            val task1 = launch {\n                delay(1000)\n                println(\"Done background task\")\n            }\n\n            val task2 = async {\n                throw Exception()\n                1\n            }\n\n            try {\n                task2.await()\n            } catch (e: Exception) {\n                println(\"Caught exception $e\")\n            }\n            task1.join()\n        }\n    }\n\n    job.join()\n    println(\"Program ends\")\n}\n```", "```\nCaught exception java.lang.Exception\n```", "```\nCaught exception java.lang.Exception\n(stacktrace of java.lang.Exception)\nProgram ends\n```", "```\nfun main() = runBlocking {\n\n    val ceh = CoroutineExceptionHandler { _, t ->\n        println(\"CEH handle $t\")\n    }\n\n    val scope = CoroutineScope(Job())\n\n    val job = scope.launch(ceh) {\n        coroutineScope {\n            val task1 = launch {\n                delay(1000)\n                println(\"Done background task\")\n            }\n\n            val task2 = async {\n                throw Exception()\n                1\n            }\n\n            task1.join()\n        }\n    }\n\n    job.join()\n    println(\"Program ends\")\n}\n```", "```\nCaught exception java.lang.Exception\nCEH handle java.lang.Exception\nProgram ends\n```", "```\nfun main() = runBlocking {\n\n    val ceh = CoroutineExceptionHandler { _, t ->\n        println(\"CEH handle $t\")\n    }\n\n    val scope = CoroutineScope(Job() + ceh)\n\n    val job = scope.launch {\n       // same as previous example\n    }\n}\n```", "```\nfun main() = runBlocking {\n\n    val ceh = CoroutineExceptionHandler { _, t ->\n        println(\"CEH handle $t\")\n    }\n\n    val scope = CoroutineScope(Job())\n\n    val job = scope.launch {\n        supervisorScope {\n            val task1 = launch {\n                // simulate a background task\n                delay(1000)\n                println(\"Done background task\")\n            }\n\n            val task2 = launch(ceh) {\n                // try to fetch some count, but it fails\n                throw Exception()\n            }\n\n            task1.join()\n            task2.join()\n        }\n    }\n\n    job.join()\n    println(\"Program ends\")\n}\n```"]