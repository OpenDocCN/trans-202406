["```\n// browser\ncores = navigator.hardwareConcurrency;\n\n// Node.js\ncores = require('os').cpus().length;\n```", "```\n#!/usr/bin/env node const http = require('http');\nconst RpcWorkerPool = require('./rpc-worker.js');\nconst worker = new RpcWorkerPool('./worker.js',\n  Number(process.env.THREADS), ![1](Images/1.png)\n  process.env.STRATEGY); ![2](Images/2.png)\n\nconst server = http.createServer(async (req, res) => {\n  const value = Math.floor(Math.random() * 100_000_000);\n  const sum = await worker.exec('square_sum', value);\n  res.end(JSON.stringify({ sum, value }));\n});\n\nserver.listen(1337, (err) => {\n  if (err) throw err;\n  console.log('http://localhost:1337/');\n});\n```", "```\nconst { parentPort } = require('worker_threads');\n\nfunction asyncOnMessageWrap(fn) {\n  return async function(msg) {\n    parentPort.postMessage(await fn(msg));\n  }\n}\n\nconst commands = {\n  async square_sum(max) {\n    await new Promise((res) => setTimeout(res, 100));\n    let sum = 0; for (let i = 0; i < max; i++) sum += Math.sqrt(i);\n    return sum;\n  }\n};\n\nparentPort.on('message', asyncOnMessageWrap(async ({ method, params, id }) => ({\n  result: await commands[method](...params), id\n})));\n```", "```\nconst { Worker } = require('worker_threads');\nconst CORES = require('os').cpus().length;\nconst STRATEGIES = new Set([ 'roundrobin', 'random', 'leastbusy' ]);\n\nmodule.exports = class RpcWorkerPool {\n  constructor(path, size = 0, strategy = 'roundrobin') {\n    if (size === 0)     this.size = CORES; ![1](Images/1.png)\n    else if (size < 0)  this.size = Math.max(CORES + size, 1);\n    else                this.size = size;\n\n    if (!STRATEGIES.has(strategy)) throw new TypeError('invalid strategy');\n    this.strategy = strategy; ![2](Images/2.png)\n    this.rr_index = -1;\n\n    this.next_command_id = 0;\n    this.workers = []; ![3](Images/3.png)\n    for (let i = 0; i < this.size; i++) {\n      const worker = new Worker(path);\n      this.workers.push({ worker, in_flight_commands: new Map() }); ![4](Images/4.png)\n      worker.on('message', (msg) => {\n        this.onMessageHandler(msg, i);\n      });\n    }\n  }\n```", "```\n  onMessageHandler(msg, worker_id) {\n    const worker = this.workers[worker_id];\n    const { result, error, id } = msg;\n    const { resolve, reject } = worker.in_flight_commands.get(id);\n    worker.in_flight_commands.delete(id);\n    if (error) reject(error);\n    else resolve(result);\n  }\n```", "```\n  exec(method, ...args) {\n    const id = ++this.next_command_id;\n    let resolve, reject;\n    const promise = new Promise((res, rej) => { resolve = res; reject = rej; });\n    const worker = this.getWorker(); ![1](Images/1.png)\n    worker.in_flight_commands.set(id, { resolve, reject });\n    worker.worker.postMessage({ method, params: args, id });\n    return promise;\n  }\n```", "```\n  getWorker() {\n    let id;\n    if (this.strategy === 'random') {\n      id = Math.floor(Math.random() * this.size);\n    } else if (this.strategy === 'roundrobin') {\n      this.rr_index++;\n      if (this.rr_index >= this.size) this.rr_index = 0;\n      id = this.rr_index;\n    } else if (this.strategy === 'leastbusy') {\n      let min = Infinity;\n      for (let i = 0; i < this.size; i++) {\n        let worker = this.workers[i];\n        if (worker.in_flight_commands.size < min) {\n          min = worker.in_flight_commands.size;\n          id = i;\n        }\n      }\n    }\n    console.log('Selected Worker:', id);\n    return this.workers[id];\n  }\n};\n```", "```\n$ THREADS=3 STRATEGY=leastbusy node main.js\n```", "```\n$ npx autocannon -c 5 -a 20 http://localhost:1337\n```", "```\n$ THREADS=3 STRATEGY=roundrobin node main.js\n```", "```\n$ THREADS=3 STRATEGY=random node main.js\n```", "```\nconst {\n  Worker, isMainThread, workerData\n} = require('worker_threads');\nconst assert = require('assert');\n\nif (isMainThread) {\n  const shared = new SharedArrayBuffer(4 * 4); ![1](Images/1.png)\n  const sharedInts = new Int32Array(shared);\n  sharedInts.set([2, 3, 5, 7]);\n  for (let i = 0; i < 3; i++) {\n    new Worker(__filename, { workerData: { i, shared } });\n  }\n} else {\n  const { i, shared } = workerData;\n  const sharedInts = new Int32Array(shared);\n  const a = Atomics.load(sharedInts, i);\n  for (let j = 0; j < 1_000_000; j++) {}\n  const b = Atomics.load(sharedInts, 3);\n  Atomics.store(sharedInts, 3, a * b);\n  assert.strictEqual(Atomics.load(sharedInts, 3), a * b); ![2](Images/2.png)\n}\n```", "```\n$ node thread-product.js\n```", "```\nconst UNLOCKED = 0;\nconst LOCKED = 1;\n\nconst {\n  compareExchange, wait, notify\n} = Atomics;\n\nclass Mutex {\n  constructor(shared, index) {\n    this.shared = shared;\n    this.index = index;\n  }\n```", "```\n  acquire() {\n    if (compareExchange(this.shared, this.index, UNLOCKED, LOCKED) === UNLOCKED) {\n      return;\n    }\n    wait(this.shared, this.index, LOCKED);\n    this.acquire();\n  }\n```", "```\n  release() {\n    if (compareExchange(this.shared, this.index, LOCKED, UNLOCKED) !== LOCKED) {\n      throw new Error('was not acquired');\n    }\n    notify(this.shared, this.index, 1);\n  }\n```", "```\n  exec(fn) {\n    this.acquire();\n    try {\n      return fn();\n    } finally {\n      this.release();\n    }\n  }\n}\n\nmodule.exports = Mutex;\n```", "```\n  const { i, shared } = workerData;\n  const sharedInts = new Int32Array(shared);\n  const mutex = new Mutex(sharedInts, 4); ![1](Images/1.png)\n  mutex.exec(() => {\n    const a = sharedInts[i]; ![2](Images/2.png)\n    for (let j = 0; j < 1_000_000; j++) {}\n    const b = sharedInts[3];\n    sharedInts[3] = a * b;\n    assert.strictEqual(sharedInts[3], a * b);\n  });\n```", "```\n$ node thread-product-mutex.js\n```", "```\nclass RingBuffer {\n  constructor(meta/*: Uint32Array[3]*/, buffer /*: Uint8Array */) {\n    this.meta = meta;\n    this.buffer = buffer;\n  }\n\n  get head() {\n    return this.meta[0];\n  }\n\n  set head(n) {\n    this.meta[0] = n;\n  }\n\n  get tail() {\n    return this.meta[1];\n  }\n\n  set tail(n) {\n    this.meta[1] = n;\n  }\n\n  get length() {\n    return this.meta[2];\n  }\n\n  set length(n) {\n    this.meta[2] = n;\n  }\n```", "```\n  write(data /*: Uint8Array */) { ![1](Images/1.png)\n    let bytesWritten = data.length;\n    if (bytesWritten > this.buffer.length - this.length) { ![2](Images/2.png)\n      bytesWritten = this.buffer.length - this.length;\n      data = data.subarray(0, bytesWritten);\n    }\n    if (bytesWritten === 0) {\n      return bytesWritten;\n    }\n    if (\n      (this.head >= this.tail && this.buffer.length - this.head >= bytesWritten) ||\n      (this.head < this.tail && bytesWritten <= this.tail - this.head) ![3](Images/3.png)\n    ) {\n      // Enough space after the head. Just write it in and increase the head.\n      this.buffer.set(data, this.head);\n      this.head += bytesWritten;\n    } else { ![4](Images/4.png)\n      // We need to split the chunk into two.\n      const endSpaceAvailable = this.buffer.length - this.head;\n      const endChunk = data.subarray(0, endSpaceAvailable);\n      const beginChunk = data.subarray(endSpaceAvailable);\n      this.buffer.set(endChunk, this.head);\n      this.buffer.set(beginChunk, 0);\n      this.head = beginChunk.length;\n    }\n    this.length += bytesWritten;\n    return bytesWritten;\n  }\n```", "```\n  read(bytes) {\n    if (bytes > this.length) { ![1](Images/1.png)\n      bytes = this.length;\n    }\n    if (bytes === 0) {\n      return new Uint8Array(0);\n    }\n    let readData;\n    if (\n      this.head > this.tail || this.buffer.length - this.tail >= bytes ![2](Images/2.png)\n    ) {\n      // The data is in a contiguous chunk.\n      readData = this.buffer.slice(this.tail, bytes)\n      this.tail += bytes;\n    } else { ![3](Images/3.png)\n      // Read from the end and the beginning.\n      readData = new Uint8Array(bytes);\n      const endBytesToRead = this.buffer.length - this.tail;\n      readData.set(this.buffer.subarray(this.tail, this.buffer.length));\n      readData.set(this.buffer.subarray(0, bytes - endBytesToRead), endBytesToRead);\n      this.tail = bytes - endBytesToRead;\n    }\n    this.length -= bytes;\n    return readData;\n  }\n}\n```", "```\nconst Mutex = require('../ch6-mutex/mutex.js');\n\nclass SharedRingBuffer {\n  constructor(shared/*: number | SharedArrayBuffer*/) {\n    this.shared = typeof shared === 'number' ?\n      new SharedArrayBuffer(shared + 16) : shared;\n    this.ringBuffer = new RingBuffer(\n      new Uint32Array(this.shared, 4, 3),\n      new Uint8Array(this.shared, 16)\n    );\n    this.lock = new Mutex(new Int32Array(this.shared, 0, 1));\n  }\n\n  write(data) {\n    return this.lock.exec(() => this.ringBuffer.write(data));\n  }\n\n  read(bytes) {\n    return this.lock.exec(() => this.ringBuffer.read(bytes));\n  }\n}\n```", "```\nconst { isMainThread, Worker, workerData } = require('worker_threads');\nconst fs = require('fs');\n\nif (isMainThread) {\n  const shared = new SharedArrayBuffer(116);\n  const threads = [\n    new Worker(__filename, { workerData: { shared, isProducer: true } }),\n    new Worker(__filename, { workerData: { shared, isProducer: true } }),\n    new Worker(__filename, { workerData: { shared, isProducer: false } }),\n    new Worker(__filename, { workerData: { shared, isProducer: false } })\n  ];\n} else {\n  const { shared, isProducer } = workerData;\n  const ringBuffer = new SharedRingBuffer(shared);\n\n  if (isProducer) {\n    const buffer = Buffer.from('Hello, World!\\n');\n    while (true) {\n      ringBuffer.write(buffer);\n    }\n  } else {\n    while (true) {\n      const readBytes = ringBuffer.read(20);\n      fs.writeSync(1, `Read ${readBytes.length} bytes\\n`); ![1](Images/1.png)\n    }\n  }\n}\n```", "```\n$ node ring-buffer.js\n```", "```\n#!/usr/bin/env node\n\nconst http = require('http');\nconst net = require('net');\n\nconst [,, web_host, actor_host] = process.argv;\nconst [web_hostname, web_port] = web_host.split(':');\nconst [actor_hostname, actor_port] = actor_host.split(':');\n\nlet message_id = 0;\nlet actors = new Set(); // collection of actor handlers\nlet messages = new Map(); // message ID -> HTTP response\n```", "```\nnet.createServer((client) => {\n  const handler = data => client.write(JSON.stringify(data) + '\\0'); ![1](Images/1.png)\n  actors.add(handler);\n  console.log('actor pool connected', actors.size);\n  client.on('end', () => {\n    actors.delete(handler); ![2](Images/2.png)\n    console.log('actor pool disconnected', actors.size);\n  }).on('data', (raw_data) => {\n    const chunks = String(raw_data).split('\\0'); ![3](Images/3.png)\n    chunks.pop(); ![4](Images/4.png)\n    for (let chunk of chunks) {\n      const data = JSON.parse(chunk);\n      const res = messages.get(data.id);\n      res.end(JSON.stringify(data) + '\\0');\n      messages.delete(data.id);\n    }\n  });\n}).listen(actor_port, actor_hostname, () => {\n  console.log(`actor: tcp://${actor_hostname}:${actor_port}`);\n});\n```", "```\nhttp.createServer(async (req, res) => {\n  message_id++;\n  if (actors.size === 0) return res.end('ERROR: EMPTY ACTOR POOL');\n  const actor = randomActor();\n  messages.set(message_id, res);\n  actor({\n    id: message_id,\n    method: 'square_sum',\n    args: [Number(req.url.substr(1))]\n  });\n}).listen(web_port, web_hostname, () => {\n  console.log(`web:   http://${web_hostname}:${web_port}`);\n});\n```", "```\nfunction randomActor() {\n  const pool = Array.from(actors);\n  return pool[Math.floor(Math.random() * pool.length)];\n}\n```", "```\n#!/usr/bin/env node\n\nconst net = require('net');\nconst RpcWorkerPool = require('./rpc-worker.js');\n\nconst [,, host] = process.argv;\nconst [hostname, port] = host.split(':');\nconst worker = new RpcWorkerPool('./worker.js', 4, 'leastbusy');\n```", "```\nconst upstream = net.connect(port, hostname, () => {\n  console.log('connected to server');\n}).on('data', async (raw_data) => {\n  const chunks = String(raw_data).split('\\0'); ![1](Images/1.png)\n  chunks.pop();\n  for (let chunk of chunks) {\n    const data = JSON.parse(chunk);\n    const value = await worker.exec(data.method, ...data.args);\n    upstream.write(JSON.stringify({\n      id: data.id,\n      value,\n      pid: process.pid\n    }) + '\\0');\n  }\n}).on('end', () => {\n  console.log('disconnect from server');\n});\n```", "```\n$ node server.js 127.0.0.1:8000 127.0.0.1:9000\n# web:   http://127.0.0.1:8000\n# actor: tcp://127.0.0.1:9000\n```", "```\n$ curl http://localhost:8000/9999\n# ERROR: EMPTY ACTOR POOL\n```", "```\n$ node actor.js 127.0.0.1:9000\n```", "```\n$ curl http://localhost:8000/99999\n# {\"id\":4,\"value\":21081376.519967034,\"pid\":160004}\n```", "```\n$ node actor.js 127.0.0.1:9000\n\n$ curl http://localhost:8000/8888888\n# {\"id\":4,\"value\":21081376.519967034,\"pid\":160005}\n```", "```\nconst RpcWorkerPool = require('./rpc-worker.js');\nconst worker = new RpcWorkerPool('./worker.js', 4, 'leastbusy');\nactors.add(async (data) => {\n  const value = await worker.exec(data.method, ...data.args);\n  messages.get(data.id).end(JSON.stringify({\n    id: data.id,\n    value,\n    pid: 'server'\n  }) + '\\0');\n  messages.delete(data.id);\n});\n```", "```\n$ node server.js 127.0.0.1:8000 127.0.0.1:9000\n$ curl http://localhost:8000/8888888\n# {\"id\":8,\"value\":17667693458.923462,\"pid\":\"server\"}\n```"]