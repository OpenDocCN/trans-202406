<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Asynchronous APIs" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_async">&#13;
<h1><span class="label">Chapter 1. </span>Asynchronous APIs</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introduction" data-type="sect1"><div class="sect1" id="id6">&#13;
<h1>Introduction</h1>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-type="indexterm" id="ix_01-async-asciidoc0"/>A <a data-primary="asynchronous APIs" data-secondary="basics" data-type="indexterm" id="ix_01-async-asciidoc1"/>lot of the APIs covered in this book are <em>asynchronous</em>. When you call one of these functions or methods, you might not get the result back right away. Different APIs have different mechanisms to get the result back to you when it’s ready.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Callback Functions" data-type="sect2"><div class="sect2" id="id7">&#13;
<h2>Callback Functions</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="callback functions" data-type="indexterm" id="id689"/><a data-primary="callback functions, asynchronous APIs and" data-type="indexterm" id="id690"/>The most basic asynchronous pattern is a <em>callback function</em>. This is a function that you pass to an asynchronous API. When the work is complete, it calls your callback with the result. Callbacks can be used on their own or as part of other asynchronous patterns.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Events" data-type="sect2"><div class="sect2" id="id258">&#13;
<h2>Events</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="events" data-type="indexterm" id="id691"/><a data-primary="events" data-secondary="asynchronous APIs and" data-type="indexterm" id="id692"/>Many browser APIs are <em>event</em> based. An event is something that happens asynchronously. Some examples of events are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A button was clicked.</p>&#13;
</li>&#13;
<li>&#13;
<p>The mouse was moved.</p>&#13;
</li>&#13;
<li>&#13;
<p>A network request was completed.</p>&#13;
</li>&#13;
<li>&#13;
<p>An error occurred.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>An event has a name, such as <code>click</code> or <code>mouseover</code>, and an object with data about the event that occurred. This might include information such as what element was clicked or an HTTP status code. When you listen for an event, you provide a callback function that receives the event object as an argument.</p>&#13;
&#13;
<p>Objects that emit events implement the <code>EventTarget</code> interface, which provides the <code>addEventListener</code> and <code>removeEventListener</code> methods. To listen for an event on an element or other object, you can call <code>addEventListener</code> on it, passing the name &#13;
<span class="keep-together">of the</span> event and a handler function. The callback is called every time the event &#13;
<span class="keep-together">is triggered</span> until it is removed. A listener can be removed manually by calling &#13;
<span class="keep-together"><code>removeEventListener</code></span>, or in many cases listeners are automatically removed by the browser when objects are destroyed or removed from the DOM.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Promises" data-type="sect2"><div class="sect2" id="id8">&#13;
<h2>Promises</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="Promises" data-type="indexterm" id="id693"/><a data-primary="Promises" data-secondary="asynchronous APIs and" data-type="indexterm" id="id694"/>Many newer APIs use <code>Promise</code>s. A <code>Promise</code> is an object, returned from a function, that is a placeholder for the eventual result of the asynchronous action. Instead of listening for an event, you call <code>then</code> on a <code>Promise</code> object. You pass a callback function to <code>then</code> that is eventually called with the result as its argument. To handle errors, you pass another callback function to the <code>Promise</code>’s <code>catch</code> method.</p>&#13;
&#13;
<p>A <code>Promise</code> is <em>fulfilled</em> when the operation completes successfully, and it is <em>rejected</em> when there’s an error. The fulfilled value is passed as an argument to the <code>then</code> callback, or the rejected value is passed as an argument to the <code>catch</code> callback.</p>&#13;
&#13;
<p><a data-primary="events" data-secondary="Promises versus" data-type="indexterm" id="id695"/><a data-primary="Promises" data-secondary="events versus" data-type="indexterm" id="id696"/>There are a few key differences between events and <code>Promise</code>s:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Event handlers are fired multiple times, whereas a <code>then</code> callback is executed only once. You can think of a <code>Promise</code> as a one-time operation.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you call <code>then</code> on a <code>Promise</code>, you’ll always get the result (if there is one). This is different from events where, if an event occurs before you add a listener, the event is lost.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Promise</code>s have a built-in error-handling mechanism. With events, you typically need to listen for an error event to handle error conditions<a data-startref="ix_01-async-asciidoc1" data-type="indexterm" id="id697"/>.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Working with Promises" data-type="sect1"><div class="sect1" id="recipePromises">&#13;
<h1>Working with Promises</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id259">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="working with Promises" data-type="indexterm" id="ix_01-async-asciidoc2"/><a data-primary="Promises" data-secondary="working with" data-type="indexterm" id="ix_01-async-asciidoc3"/>You want to call an API that uses <code>Promise</code>s and retrieve the result.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id388">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Call <code>then</code> on the <code>Promise</code> object to handle the result in a callback function. To handle potential errors, add a call to <code>catch</code>.</p>&#13;
&#13;
<p>Imagine you have a function <code>getUsers</code> that makes a network request to load a list of users. This function returns a <code>Promise</code> that eventually resolves to the user list (see <a data-type="xref" href="#promiseGetUsers">Example 1-1</a>).</p>&#13;
<div data-type="example" id="promiseGetUsers">&#13;
<h5><span class="label">Example 1-1. </span>Using a <code>Promise</code>-based API</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">getUsers</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">(</code>&#13;
    <code class="c1">// This function is called when the user list has been loaded.</code>&#13;
    <code class="nx">userList</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'User List:'</code><code class="p">);</code>&#13;
      <code class="nx">userList</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
      <code class="p">});</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">).</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'Failed to load the user list:'</code><code class="p">,</code> <code class="nx">error</code><code class="p">);</code>&#13;
  <code class="p">});</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id9">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <code>Promise</code> returned from <code>getUsers</code> is an object with a <code>then</code> method. When the user list is loaded, the callback passed to <code>then</code> is executed with the user list as its &#13;
<span class="keep-together">argument.</span></p>&#13;
&#13;
<p><a data-primary="catch method (Promise)" data-type="indexterm" id="id698"/>This <code>Promise</code> also has a <code>catch</code> method for handling errors. If an error occurs while loading the user list, the callback passed to <code>catch</code> is called with the error object. Only one of these callbacks is called, depending on the outcome.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id699">&#13;
<h1>Always Handle Errors</h1>&#13;
<p><a data-primary="errors, Promises and" data-type="indexterm" id="id700"/><a data-primary="Promises" data-secondary="handling error case" data-type="indexterm" id="id701"/>It’s important to always handle the error case of a <code>Promise</code>. If you don’t, and a <code>Promise</code> is rejected, the browser throws an exception for the unhandled rejection and could crash your app.</p>&#13;
&#13;
<p>To prevent an unhandled rejection from taking down your app, add a listener to the <code>window</code> object for the <code>unhandledrejection</code> event. If any <code>Promise</code> is rejected and you don’t handle it with a <code>catch</code>, this event fires. Here you can take action such as logging the error<a data-startref="ix_01-async-asciidoc3" data-type="indexterm" id="id702"/><a data-startref="ix_01-async-asciidoc2" data-type="indexterm" id="id703"/>.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Loading an Image with a Fallback" data-type="sect1"><div class="sect1" id="id389">&#13;
<h1>Loading an Image with a Fallback</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id10">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="fallback image loading" data-type="indexterm" id="ix_01-async-asciidoc4"/><a data-primary="fallback, loading an image with" data-type="indexterm" id="ix_01-async-asciidoc5"/><a data-primary="images" data-secondary="loading with fallback" data-type="indexterm" id="ix_01-async-asciidoc6"/>You want to load an image to display on the page. If there’s an error loading the image, you want to use a known good image URL as a fallback.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id11">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="Image element" data-type="indexterm" id="id704"/><a data-primary="Promises" data-secondary="Image element and" data-type="indexterm" id="id705"/>Create an <code>Image</code> element programmatically, and listen for its <code>load</code> and <code>error</code> events. If the <code>error</code> event triggers, replace it with the fallback image. Once either the requested image or the placeholder image loads, add it to the DOM when desired.</p>&#13;
&#13;
<p>For a cleaner API, you can wrap this in a <code>Promise</code>. The <code>Promise</code> either resolves with an <code>Image</code> to be added or rejects with an error if neither the image nor the fallback can be loaded (see <a data-type="xref" href="#example1-2">Example 1-2</a>).</p>&#13;
<div data-type="example" id="example1-2">&#13;
<h5><span class="label">Example 1-2. </span>Loading an image with a fallback</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Loads an image. If there's an error loading the image, uses a fallback</code>&#13;
<code class="cm"> * image URL instead.</code>&#13;
<code class="cm"> *</code>&#13;
<code class="cm"> * @param url The image URL to load</code>&#13;
<code class="cm"> * @param fallbackUrl The fallback image to load if there's an error</code>&#13;
<code class="cm"> * @returns a Promise that resolves to an Image element to insert into the DOM</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">loadImage</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">fallbackUrl</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">image</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Image</code><code class="p">();</code>&#13;
&#13;
    <code class="c1">// Attempt to load the image from the given URL</code>&#13;
    <code class="nx">image</code><code class="p">.</code><code class="nx">src</code> <code class="o">=</code> <code class="nx">url</code><code class="p">;</code>&#13;
&#13;
    <code class="c1">// The image triggers the 'load' event when it is successfully loaded.</code>&#13;
    <code class="nx">image</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s1">'load'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// The now-loaded image is used to resolve the Promise</code>&#13;
      <code class="nx">resolve</code><code class="p">(</code><code class="nx">image</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="c1">// If an image failed to load, it triggers the 'error' event.</code>&#13;
    <code class="nx">image</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s1">'error'</code><code class="p">,</code> <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// Reject the Promise in one of two scenarios:</code>&#13;
      <code class="c1">// (1) There is no fallback URL.</code>&#13;
      <code class="c1">// (2) The fallback URL is the one that failed.</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">fallbackUrl</code> <code class="o">||</code> <code class="nx">image</code><code class="p">.</code><code class="nx">src</code> <code class="o">===</code> <code class="nx">fallbackUrl</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">reject</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>&#13;
      <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="c1">// If this is executed, it means the original image failed to load.</code>&#13;
        <code class="c1">// Try to load the fallback.</code>&#13;
        <code class="nx">image</code><code class="p">.</code><code class="nx">src</code> <code class="o">=</code> <code class="nx">fallbackUrl</code><code class="p">;</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id12">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <code>loadImage</code> function takes a URL and a fallback URL and returns a <code>Promise</code>. Then it creates a new <code>Image</code> and sets its <code>src</code> attribute to the given URL. The browser attempts to load the image.</p>&#13;
&#13;
<p>There are three possible outcomes:</p>&#13;
<dl>&#13;
<dt>Success case</dt>&#13;
<dd>&#13;
<p>If the image loads successfully, the <code>load</code> event is triggered. The event handler resolves the <code>Promise</code> with the <code>Image</code>, which can then be inserted into the DOM.</p>&#13;
</dd>&#13;
<dt>Fallback case</dt>&#13;
<dd>&#13;
<p>If the image fails to load, the <code>error</code> event is triggered. The error handler sets the <code>src</code> attribute to the fallback URL, and the browser attempts to load the fallback image. If <em>that</em> is successful, the <code>load</code> event fires and resolves the <code>Promise</code> with the fallback <code>Image</code>.</p>&#13;
</dd>&#13;
<dt>Failure case</dt>&#13;
<dd>&#13;
<p>If neither the image nor the fallback image could be loaded, the error handler rejects the <code>Promise</code> with the <code>error</code> event.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The <code>error</code> event is triggered every time there’s a load error. The handler first checks if it’s the fallback URL that failed. If so, this means that the original URL and fallback URL both failed to load. This is the failure case, so the <code>Promise</code> is rejected.</p>&#13;
&#13;
<p>If it’s not the fallback URL, this means the requested URL failed to load. Now it sets the fallback URL and tries to load that.</p>&#13;
&#13;
<p>The order of checks here is important. Without that first check, if the fallback fails to load, the error handler would trigger an infinite loop of setting the (invalid) fallback URL, requesting it, and firing the <code>error</code> event again.</p>&#13;
&#13;
<p><a data-type="xref" href="#example1-3">Example 1-3</a> shows how to use this <code>loadImage</code> function<a data-startref="ix_01-async-asciidoc6" data-type="indexterm" id="id706"/><a data-startref="ix_01-async-asciidoc5" data-type="indexterm" id="id707"/><a data-startref="ix_01-async-asciidoc4" data-type="indexterm" id="id708"/>.</p>&#13;
<div data-type="example" id="example1-3">&#13;
<h5><span class="label">Example 1-3. </span>Using the <code>loadImage</code> function</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">loadImage</code><code class="p">(</code><code class="s1">'https://example.com/profile.jpg'</code><code class="p">,</code> <code class="s1">'https://example.com/fallback.jpg'</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">image</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// container is an element in the DOM where the image will go</code>&#13;
    <code class="nx">container</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">image</code><code class="p">);</code>&#13;
  <code class="p">}).</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'Image load failed'</code><code class="p">);</code>&#13;
  <code class="p">});</code></pre></div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chaining Promises" data-type="sect1"><div class="sect1" id="id390">&#13;
<h1>Chaining Promises</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id13">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="chaining Promises" data-type="indexterm" id="ix_01-async-asciidoc7"/><a data-primary="chaining Promises" data-type="indexterm" id="ix_01-async-asciidoc8"/><a data-primary="Promises" data-secondary="chaining" data-type="indexterm" id="ix_01-async-asciidoc9"/>You want to call several <code>Promise</code>-based APIs in sequence. Each operation depends on the result of the previous one.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id391">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a chain of <code>Promise</code>s to run the asynchronous tasks in sequence. Imagine a blog application with two APIs, both of which return <code>Promise</code>s:</p>&#13;
<dl>&#13;
<dt><code>getUser(id)</code></dt>&#13;
<dd>&#13;
<p>Loads a user with the given user ID</p>&#13;
</dd>&#13;
<dt><code>getPosts(user)</code></dt>&#13;
<dd>&#13;
<p>Loads all the blog posts for a given user</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>If you want to load the posts for a user, you first need to load the <code>user</code> object—you can’t call <code>getPosts</code> until the user details are loaded. You can do this by chaining the two <code>Promise</code>s together, as shown in <a data-type="xref" href="#promiseChain">Example 1-4</a>.</p>&#13;
<div data-type="example" id="promiseChain">&#13;
<h5><span class="label">Example 1-4. </span>Using a <code>Promise</code> chain</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Loads the post titles for a given user ID.</code>&#13;
<code class="cm"> * @param userId is the ID of the user whose posts you want to load</code>&#13;
<code class="cm"> * @returns a Promise that resolves to an array of post titles</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">getPostTitles</code><code class="p">(</code><code class="nx">userId</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">getUser</code><code class="p">(</code><code class="nx">userId</code><code class="p">)</code>&#13;
    <code class="c1">// Callback is called with the loaded user object</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Getting posts for </code><code class="si">${</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
      <code class="c1">// This Promise is also returned from .then</code>&#13;
      <code class="k">return</code> <code class="nx">getPosts</code><code class="p">(</code><code class="nx">user</code><code class="p">);</code>&#13;
    <code class="p">})</code>&#13;
    <code class="c1">// Calling then on the getPosts' Promise</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">posts</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// Returns another Promise that will resolve to an array of post titles</code>&#13;
      <code class="k">return</code> <code class="nx">posts</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">post</code> <code class="o">=&gt;</code> <code class="nx">post</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>&#13;
    <code class="p">})</code>&#13;
    <code class="c1">// Called if either getUser or getPosts are rejected</code>&#13;
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'Error loading data:'</code><code class="p">,</code> <code class="nx">error</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id14">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The value returned from a <code>Promise</code>’s <code>then</code> handler is wrapped in a new <code>Promise</code>. This <code>Promise</code> is returned from the <code>then</code> method itself. This means the return value of <code>then</code> is also a <code>Promise</code>, so you can chain another <code>then</code> onto it. This is how you create a chain of <code>Promise</code>s.</p>&#13;
&#13;
<p><code>getUser</code> returns a <code>Promise</code> that resolves to the <code>user</code> object. The <code>then</code> handler calls <code>getPosts</code> and returns the resulting <code>Promise</code>, which is returned again from <code>then</code>, so you can call <code>then</code> once more to get the final result, the array of posts.</p>&#13;
&#13;
<p>At the end of the chain is a call to <code>catch</code> to handle any errors. This works like a <code>try</code>/<code>catch</code> block. If an error occurs at any point within the chain, the <code>catch</code> handler is called with that error and the rest of the chain does not get executed<a data-startref="ix_01-async-asciidoc9" data-type="indexterm" id="id709"/><a data-startref="ix_01-async-asciidoc8" data-type="indexterm" id="id710"/><a data-startref="ix_01-async-asciidoc7" data-type="indexterm" id="id711"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the async and await Keywords" data-type="sect1"><div class="sect1" id="id392">&#13;
<h1>Using the async and await Keywords</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id15">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="async keyword" data-type="indexterm" id="id712"/><a data-primary="asynchronous APIs" data-secondary="async and await keywords" data-type="indexterm" id="id713"/><a data-primary="await keyword" data-type="indexterm" id="id714"/>You are working with an API that returns a <code>Promise</code>, but you want the code to read in a more linear, or synchronous, fashion.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id393">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>await</code> keyword with the <code>Promise</code> instead of calling <code>then</code> on it (see <a data-type="xref" href="#example1-5">Example 1-5</a>). Consider again the <code>getUsers</code> function from <a data-type="xref" href="#recipePromises">“Working with Promises”</a>. This function returns a <code>Promise</code> that resolves to a list of users.</p>&#13;
<div data-type="example" id="example1-5">&#13;
<h5><span class="label">Example 1-5. </span>Using the <code>await</code> keyword</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// A function must be declared with the async keyword</code>&#13;
<code class="c1">// in order to use await in its body.</code>&#13;
<code class="nx">async</code> <code class="kd">function</code> <code class="nx">listUsers</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="c1">// Equivalent to getUsers().then(...)</code>&#13;
    <code class="kr">const</code> <code class="nx">userList</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getUsers</code><code class="p">();</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'User List:'</code><code class="p">);</code>&#13;
    <code class="nx">userList</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Equivalent to .catch(...)</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'Failed to load the user list:'</code><code class="p">,</code> <code class="nx">error</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id394">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><code>await</code> is an alternative syntax for working with <code>Promise</code>s. Instead of calling <code>then</code> with a callback that takes the result as its argument, the expression effectively “pauses” execution of the rest of the function and returns the result when the <code>Promise</code> is fulfilled.</p>&#13;
&#13;
<p>If the <code>Promise</code> is rejected, the <code>await</code> expression throws the rejected value. This is handled with a standard <code>try</code>/<code>catch</code> block.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Promises in Parallel" data-type="sect1"><div class="sect1" id="id395">&#13;
<h1>Using Promises in Parallel</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id260">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="Promises in parallel" data-type="indexterm" id="ix_01-async-asciidoc10"/><a data-primary="Promises" data-secondary="parallel" data-type="indexterm" id="ix_01-async-asciidoc11"/>You want to execute a series of asynchronous tasks in parallel using <code>Promise</code>s.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id396">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Collect all the <code>Promise</code>s, and pass them to <code>Promise.all</code>. This function takes an array of <code>Promise</code>s and waits for them all to complete. It returns a new <code>Promise</code> that is fulfilled once all the given <code>Promise</code>s are fulfilled, or rejects if any of the given <code>Promise</code>s are rejected (see <a data-type="xref" href="#loadMultipleUsers">Example 1-6</a>).</p>&#13;
<div data-type="example" id="loadMultipleUsers">&#13;
<h5><span class="label">Example 1-6. </span>Loading multiple users with <code>Promise.all</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Loading three users at once</code>&#13;
<code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>&#13;
  <code class="nx">getUser</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code>&#13;
  <code class="nx">getUser</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code>&#13;
  <code class="nx">getUser</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>&#13;
<code class="p">]).</code><code class="nx">then</code><code class="p">(</code><code class="nx">users</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// users is an array of user objects—the values returned from</code>&#13;
  <code class="c1">// the parallel getUser calls</code>&#13;
<code class="p">}).</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// If any of the above Promises are rejected</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'One of the users failed to load:'</code><code class="p">,</code> <code class="nx">error</code><code class="p">);</code>&#13;
<code class="p">});</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id16">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>If you have multiple tasks that don’t depend on one another, <code>Promise.all</code> is a good choice. <a data-type="xref" href="#loadMultipleUsers">Example 1-6</a> calls <code>getUser</code> three times, passing a different user ID each time. It collects these <code>Promise</code>s into an array that is passed to <code>Promise.all</code>. All three requests run in parallel.</p>&#13;
&#13;
<p><code>Promise.all</code> returns another <code>Promise</code>. Once all three users have loaded successfully, this new <code>Promise</code> becomes fulfilled with an array containing the loaded users. The index of each result corresponds to the index of the <code>Promise</code> in the input array. In this case, it returns an array with users <code>1</code>, <code>2</code>, and <code>3</code>, in that order.</p>&#13;
&#13;
<p>What if one or more of these users failed to load? Maybe one of the user IDs doesn’t exist or there was a temporary network error. If <em>any</em> of the <code>Promise</code>s passed to <code>Promise.all</code> are rejected, the new <code>Promise</code> immediately rejects as well. The rejection value is the same as that of the rejected <code>Promise</code>.</p>&#13;
&#13;
<p>If one of the users fails to load, the <code>Promise</code> returned by <code>Promise.all</code> is rejected with the error that occurred. The results of the other <code>Promise</code>s are lost.</p>&#13;
&#13;
<p>If you still want to get the results of any resolved <code>Promises</code> (or errors from other rejected ones), you can instead use <code>Promise.allSettled</code>. With <code>Promise.allSettled</code>, a new <code>Promise</code> is returned just like with <code>Promise.all</code>. However, this <code>Promise</code> is always fulfilled, once all of the <code>Promise</code>s are settled (either fulfilled <em>or</em> rejected).</p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#example1-7">Example 1-7</a>, the resolved value is an array whose elements each have a <code>status</code> property. This is either <code>fulfilled</code> or <code>rejected</code>, depending on the result of that <code>Promise</code>. If the status is <code>fulfilled</code>, the object also has a <code>value</code> property that is the resolved value. On the other hand, if the status is <code>rejected</code>, it instead has a &#13;
<span class="keep-together"><code>reason</code></span> property, which is the rejected value<a data-startref="ix_01-async-asciidoc11" data-type="indexterm" id="id715"/><a data-startref="ix_01-async-asciidoc10" data-type="indexterm" id="id716"/>.</p>&#13;
<div data-type="example" id="example1-7">&#13;
<h5><span class="label">Example 1-7. </span>Using <code>Promise.allSettled</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nb">Promise</code><code class="p">.</code><code class="nx">allSettled</code><code class="p">([</code>&#13;
  <code class="nx">getUser</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code>&#13;
  <code class="nx">getUser</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code>&#13;
  <code class="nx">getUser</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>&#13;
<code class="p">]).</code><code class="nx">then</code><code class="p">(</code><code class="nx">results</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">results</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">result</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">status</code> <code class="o">===</code> <code class="s1">'fulfilled'</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'- User:'</code><code class="p">,</code> <code class="nx">result</code><code class="p">.</code><code class="nx">value</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'- Error:'</code><code class="p">,</code> <code class="nx">result</code><code class="p">.</code><code class="nx">reason</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code>&#13;
<code class="c1">// No catch necessary here because allSettled is always fulfilled.</code></pre></div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Animating an Element with requestAnimationFrame" data-type="sect1"><div class="sect1" id="requestAnimationFrame">&#13;
<h1>Animating an Element with requestAnimationFrame</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id17">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="animations" data-secondary="requestAnimationFrame" data-type="indexterm" id="ix_01-async-asciidoc12"/><a data-primary="asynchronous APIs" data-secondary="requestAnimationFrame animation" data-type="indexterm" id="ix_01-async-asciidoc13"/><a data-primary="requestAnimationFrame" data-secondary="animating elements with" data-type="indexterm" id="ix_01-async-asciidoc14"/><a data-primary="animations" data-seealso="Web Animations API" data-type="indexterm" id="id717"/>You want to animate an element in a performant way using JavaScript.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id18">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>requestAnimationFrame</code> function to schedule your animation updates to run at regular intervals.</p>&#13;
&#13;
<p><a data-primary="fade animation" data-type="indexterm" id="ix_01-async-asciidoc15"/>Imagine you have a <code>div</code> element that you want to hide with a fade animation. This is done by adjusting the opacity at regular intervals, using a callback passed to <code>request​A⁠nimationFrame</code> (see <a data-type="xref" href="#fade_requestAnimationFrame">Example 1-8</a>). The duration of each interval depends on the desired frames per second (FPS) of the animation.</p>&#13;
<div data-type="example" id="fade_requestAnimationFrame">&#13;
<h5><span class="label">Example 1-8. </span>Fade-out animation using <code>requestAnimationFrame</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">animationSeconds</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code> <code class="c1">// Animate over 2 seconds</code>&#13;
<code class="kr">const</code> <code class="nx">fps</code> <code class="o">=</code> <code class="mi">60</code><code class="p">;</code> <code class="c1">// A nice, smooth animation</code>&#13;
&#13;
<code class="c1">// The time interval between each frame</code>&#13;
<code class="kr">const</code> <code class="nx">frameInterval</code> <code class="o">=</code> <code class="mi">1000</code> <code class="o">/</code> <code class="nx">fps</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// The total number of frames for the animation</code>&#13;
<code class="kr">const</code> <code class="nx">frameCount</code> <code class="o">=</code> <code class="nx">animationSeconds</code> <code class="o">*</code> <code class="nx">fps</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// The amount to adjust the opacity by in each frame</code>&#13;
<code class="kr">const</code> <code class="nx">opacityIncrement</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">/</code> <code class="nx">frameCount</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// The timestamp of the last frame</code>&#13;
<code class="kd">let</code> <code class="nx">lastTimestamp</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// The starting opacity value</code>&#13;
<code class="kd">let</code> <code class="nx">opacity</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">fade</code><code class="p">(</code><code class="nx">timestamp</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Set the last timestamp to now if there isn't an existing one.</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">lastTimestamp</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">lastTimestamp</code> <code class="o">=</code> <code class="nx">timestamp</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// Calculate how much time has elapsed since the last frame.</code>&#13;
  <code class="c1">// If not enough time has passed yet, schedule another call of this</code>&#13;
  <code class="c1">// function and return.</code>&#13;
  <code class="kr">const</code> <code class="nx">elapsed</code> <code class="o">=</code> <code class="nx">timestamp</code> <code class="o">-</code> <code class="nx">lastTimestamp</code><code class="p">;</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">elapsed</code> <code class="o">&lt;</code> <code class="nx">frameInterval</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">requestAnimationFrame</code><code class="p">(</code><code class="nx">animate</code><code class="p">);</code>&#13;
    <code class="k">return</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// Time for a new animation frame. Remember this timestamp.</code>&#13;
  <code class="nx">lastTimestamp</code> <code class="o">=</code> <code class="nx">timestamp</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// Adjust the opacity value and make sure it doesn't go below 0.</code>&#13;
  <code class="nx">opacity</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="nx">opacity</code> <code class="o">-</code> <code class="nx">opacityIncrement</code><code class="p">)</code>&#13;
  <code class="nx">box</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">opacity</code> <code class="o">=</code> <code class="nx">opacity</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// If the opacity hasn't reached the target value of 0, schedule another</code>&#13;
  <code class="c1">// call to this function.</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">opacity</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">requestAnimationFrame</code><code class="p">(</code><code class="nx">animate</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Schedule the first call to the animation function.</code>&#13;
<code class="nx">requestAnimationFrame</code><code class="p">(</code><code class="nx">fade</code><code class="p">);</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id19">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This is a good, performant way to animate elements using JavaScript that has good browser support. Because it’s done asynchronously, this animation won’t block the browser’s main thread. If the user switches to another tab, the animation is paused and <code>requestAnimationFrame</code> isn’t called unnecessarily.</p>&#13;
&#13;
<p>When you schedule a function to run with <code>requestAnimationFrame</code>, the function is called before the next repaint operation. How often this happens depends on the browser and screen refresh rate.</p>&#13;
&#13;
<p>Before animating, <a data-type="xref" href="#fade_requestAnimationFrame">Example 1-8</a> does some calculations based on a given animation duration (2 seconds) and frame rate (60 frames per second). It calculates the total number of frames, and uses the duration to calculate how long each frame runs. If you want a different frame rate that doesn’t match the system refresh rate, this keeps track of when the last animation update was performed to maintain your target frame rate.</p>&#13;
&#13;
<p>Then, based on the number of frames, it calculates the opacity adjustment made in each frame.</p>&#13;
&#13;
<p>The <code>fade</code> function is scheduled by passing it to a <code>requestAnimationFrame</code> call. Each time the browser calls this function, it passes a timestamp. The <code>fade</code> function calculates how much time has elapsed since the last frame. If not enough time has passed yet, it doesn’t do anything and asks the browser to call again next time around.</p>&#13;
&#13;
<p>Once enough time has passed, it performs an animation step. It takes the calculated opacity adjustment and applies it to the element’s style. Depending on the exact timing, this could result in an opacity less than 0, which is invalid. This is fixed by using <code>Math.max</code> to set a minimum value of 0.</p>&#13;
&#13;
<p>If the opacity hasn’t reached 0 yet, more animation frames need to be performed. It calls <code>requestAnimationFrame</code> again to schedule the next execution.</p>&#13;
&#13;
<p>As an alternative to this method, newer browsers support the Web Animations API, which you’ll learn about in <a data-type="xref" href="ch08.html#ch_webAnimationsApi">Chapter 8</a>. This API lets you specify keyframes with CSS properties, and the browser handles updating the intermediate values for <a data-startref="ix_01-async-asciidoc15" data-type="indexterm" id="id718"/>you<a data-startref="ix_01-async-asciidoc14" data-type="indexterm" id="id719"/><a data-startref="ix_01-async-asciidoc13" data-type="indexterm" id="id720"/><a data-startref="ix_01-async-asciidoc12" data-type="indexterm" id="id721"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wrapping an Event API in a Promise" data-type="sect1"><div class="sect1" id="id398">&#13;
<h1>Wrapping an Event API in a Promise</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id20">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="asynchronous APIs" data-secondary="wrapping an event API in a Promise" data-type="indexterm" id="ix_01-async-asciidoc16"/><a data-primary="event API, wrapping in a Promise" data-type="indexterm" id="ix_01-async-asciidoc17"/><a data-primary="Promises" data-secondary="event API wrapping" data-type="indexterm" id="ix_01-async-asciidoc18"/>You want to wrap an event-based API to return a <code>Promise</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id261">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a new <code>Promise</code> object and register event listeners within its constructor. When you receive the event you’re waiting for, resolve the <code>Promise</code> with the value. Similarly, reject the <code>Promise</code> if an error event occurs.</p>&#13;
&#13;
<p><a data-primary="XMLHttpRequest" data-secondary="promisifying" data-type="indexterm" id="id722"/>Sometimes this is called “promisifying” a function. <a data-type="xref" href="#example1-9">Example 1-9</a> demonstrates promisifying the <code>XMLHttpRequest</code> API.</p>&#13;
<div data-type="example" id="example1-9">&#13;
<h5><span class="label">Example 1-9. </span>Promisifying the <code>XMLHttpRequest</code> API</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Sends a GET request to the specified URL. Returns a Promise that will resolve to</code>&#13;
<code class="cm"> * the JSON body parsed as an object, or will reject if there is an error or the</code>&#13;
<code class="cm"> * response is not valid JSON.</code>&#13;
<code class="cm"> *</code>&#13;
<code class="cm"> * @param url The URL to request</code>&#13;
<code class="cm"> * @returns a Promise that resolves to the response body</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">loadJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Create a new Promise object, performing the async work inside the</code>&#13;
  <code class="c1">// constructor function.</code>&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">request</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">XMLHttpRequest</code><code class="p">();</code>&#13;
&#13;
    <code class="c1">// If the request is successful, parse the JSON response and</code>&#13;
    <code class="c1">// resolve the Promise with the resulting object.</code>&#13;
    <code class="nx">request</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s1">'load'</code><code class="p">,</code> <code class="nx">event</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// Wrap the JSON.parse call in a try/catch block just in case</code>&#13;
      <code class="c1">// the response body is not valid JSON.</code>&#13;
      <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="nx">resolve</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">responseText</code><code class="p">));</code>&#13;
      <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c1">// There was an error parsing the response body.</code>&#13;
        <code class="c1">// Reject the Promise with this error.</code>&#13;
        <code class="nx">reject</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="c1">// If the request fails, reject the Promise with the</code>&#13;
    <code class="c1">// error that was emitted.</code>&#13;
    <code class="nx">request</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s1">'error'</code><code class="p">,</code> <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">reject</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="c1">// Set the target URL and send the request.</code>&#13;
    <code class="nx">request</code><code class="p">.</code><code class="nx">open</code><code class="p">(</code><code class="s1">'GET'</code><code class="p">,</code> <code class="nx">url</code><code class="p">);</code>&#13;
    <code class="nx">request</code><code class="p">.</code><code class="nx">send</code><code class="p">();</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p><a data-type="xref" href="#example1-10">Example 1-10</a> shows how to use the promisified <code>loadJSON</code> function.</p>&#13;
<div data-type="example" id="example1-10">&#13;
<h5><span class="label">Example 1-10. </span>Using the <code>loadJSON</code> helper</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Using .then</code>&#13;
<code class="nx">loadJSON</code><code class="p">(</code><code class="s1">'/api/users/1'</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Got user:'</code><code class="p">,</code> <code class="nx">user</code><code class="p">);</code>&#13;
<code class="p">})</code>&#13;
&#13;
<code class="c1">// Using await</code>&#13;
<code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">loadJSON</code><code class="p">(</code><code class="s1">'/api/users/1'</code><code class="p">);</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Got user:'</code><code class="p">,</code> <code class="nx">user</code><code class="p">);</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id21">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You create a <code>Promise</code> by calling the <code>Promise</code> <em>constructor function</em> with the <code>new</code> operator. This function receives two arguments, a <code>resolve</code> and <code>reject</code> function.</p>&#13;
&#13;
<p>The <code>resolve</code> and <code>reject</code> functions are supplied by the JavaScript engine. Within the <code>Promise</code> constructor, you do your asynchronous work and listen for events. When the <code>resolve</code> function is called, the <code>Promise</code> immediately resolves to that value. Calling <code>reject</code> works the same way—it rejects the <code>Promise</code> with the error.</p>&#13;
&#13;
<p>Creating your own <code>Promise</code> can help these types of situations, but in general you usually don’t need to create them manually like this. If an API already returns a <code>Promise</code>, you don’t need to wrap that in your own <code>Promise</code>—just use it directly<a data-startref="ix_01-async-asciidoc18" data-type="indexterm" id="id723"/><a data-startref="ix_01-async-asciidoc17" data-type="indexterm" id="id724"/><a data-startref="ix_01-async-asciidoc16" data-type="indexterm" id="id725"/>.<a data-startref="ix_01-async-asciidoc0" data-type="indexterm" id="id726"/><a data-primary="debugging" data-see="console" data-type="indexterm" id="id727"/><a data-primary="logging" data-see="console entries" data-type="indexterm" id="id728"/><a data-primary="measuring performance" data-see="performance measurement" data-type="indexterm" id="id729"/><a data-primary="observers, for watching DOM elements" data-see="IntersectionObserver; MutationObserver; ResizeObserver" data-type="indexterm" id="id730"/><a data-primary="storage" data-see="Web Storage API" data-type="indexterm" id="id731"/><a data-primary="synthesizing speech" data-see="speech synthesis" data-type="indexterm" id="id732"/><a data-primary="URLs" data-secondary="routing and" data-see="routing" data-type="indexterm" id="id733"/><a data-primary="validation of forms" data-see="under forms" data-type="indexterm" id="id734"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>