<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Sorting Query Results"><div class="chapter" id="nch-sort"><h1><span class="label">Chapter 9. </span>Sorting Query Results</h1><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820370270256"><h5>A note for Early Release readers</h5><p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p></div></aside><section data-type="sect1" data-pdf-bookmark="9.0 Introduction"><div class="sect1" id="nch-sort-sort-intro"><h1>9.0 Introduction</h1><p>This chapter covers sorting, an extremely important operation for controlling how MySQL
    displays results from <code>SELECT</code>
    statements. To sort a query result, add an <code>ORDER</code> <code>BY</code> clause to the query. Without such a clause,
    MySQL is free to return rows in any order, so sorting helps bring order to
    disorder and makes query results easier to examine and understand.</p><p>You can sort rows of a query result several ways:</p><ul><li><p>Using a single column, a combination of columns, or even parts
        of columns or expression results</p></li><li><p>Using ascending or descending order</p></li><li><p>Using case-sensitive or case-insensitive string
        comparisons</p></li><li><p>Using temporal ordering</p></li></ul><p>Several examples in this chapter use the <code>driver_log</code> table, which contains columns for
    recording daily mileage logs for a set of truck drivers:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log;</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      1 | Ben   | 2014-07-30 |   152 |
|      2 | Suzi  | 2014-07-29 |   391 |
|      3 | Henry | 2014-07-29 |   300 |
|      4 | Henry | 2014-07-27 |    96 |
|      5 | Ben   | 2014-07-29 |   131 |
|      6 | Henry | 2014-07-26 |   115 |
|      7 | Suzi  | 2014-08-02 |   502 |
|      8 | Henry | 2014-08-01 |   197 |
|      9 | Ben   | 2014-08-02 |    79 |
|     10 | Henry | 2014-07-30 |   203 |
+--------+-------+------------+-------+</pre><p>Many other examples use the <code>mail</code>
    table (used in earlier chapters):</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, srchost, dstuser, dsthost, size FROM mail;</code></strong>
+---------------------+---------+---------+---------+---------+---------+
| t                   | srcuser | srchost | dstuser | dsthost | size    |
+---------------------+---------+---------+---------+---------+---------+
| 2014-05-11 10:15:08 | barb    | saturn  | tricia  | mars    |   58274 |
| 2014-05-12 12:48:13 | tricia  | mars    | gene    | venus   |  194925 |
| 2014-05-12 15:02:49 | phil    | mars    | phil    | saturn  |    1048 |
| 2014-05-12 18:59:18 | barb    | saturn  | tricia  | venus   |     271 |
| 2014-05-14 09:31:37 | gene    | venus   | barb    | mars    |    2291 |
| 2014-05-14 11:52:17 | phil    | mars    | tricia  | saturn  |    5781 |
| 2014-05-14 14:42:21 | barb    | venus   | barb    | venus   |   98151 |
| 2014-05-14 17:03:01 | tricia  | saturn  | phil    | venus   | 2394482 |
| 2014-05-15 07:17:48 | gene    | mars    | gene    | saturn  |    3824 |
| 2014-05-15 08:50:57 | phil    | venus   | phil    | venus   |     978 |
| 2014-05-15 10:25:52 | gene    | mars    | tricia  | saturn  |  998532 |
| 2014-05-15 17:35:31 | gene    | saturn  | gene    | mars    |    3856 |
| 2014-05-16 09:00:28 | gene    | venus   | barb    | mars    |     613 |
| 2014-05-16 23:04:19 | phil    | venus   | barb    | venus   |   10294 |
| 2014-05-19 12:49:23 | phil    | mars    | tricia  | saturn  |     873 |
| 2014-05-19 22:21:51 | gene    | saturn  | gene    | venus   |   23992 |
+---------------------+---------+---------+---------+---------+---------+</pre><p>Other tables are used occasionally as well. To create them, use
    scripts found in the <em class="filename">tables</em> directory
    of the <code>recipes</code> distribution.</p></div></section><section data-type="sect1" data-pdf-bookmark="9.1 Using ORDER BY to Sort Query Results"><div class="sect1" id="nch-sort-sort-order-by"><h1>9.1 Using ORDER BY to Sort Query Results</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370225888"><h2>Problem</h2><p>Rows in a query result don’t appear in the order you want.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370225008"><h2>Solution</h2><p>Add an <code>ORDER</code> <code>BY</code> clause to the query to sort its
      result.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370223360"><h2>Discussion</h2><p>The contents of the <code>driver_log</code>
      and <code>mail</code> tables shown in the chapter
      introduction are disorganized and difficult to make sense of. The values in the <code>id</code> and <code>t</code>
      columns are in order only by a coincident.</p><p>When you select rows, they’re returned from the database in
      whatever order the server happens to use. A relational database makes no
      guarantee about the order in which it returns rows—unless you tell it
      how, by adding an <code>ORDER</code> <code>BY</code> clause to your <code>SELECT</code> statement. Without <code>ORDER</code> <code>BY</code>,
      you may find that the retrieval order changes over time as you modify
      the table contents. With an <code>ORDER</code>
      <code>BY</code> clause, MySQL always sorts rows as
      you indicate.</p><p><code>ORDER</code> <code>BY</code> has the following general characteristics:</p><ul><li><p>You can sort using one or more column or expression
          values.</p></li><li><p>You can sort columns independently in ascending order (the
          default) or descending order.</p></li><li><p>You can refer to sort columns by name or by using an
          alias.</p></li></ul><p>This recipe shows some basic sorting techniques, such as how to
      name the sort columns and specify the sort direction. Recipes later in this chapter illustrate how to perform more complex sorts. Paradoxically,
      you can even use <code>ORDER</code> <code>BY</code> to <em>disorder</em> a result
      set, which is useful for randomizing the rows or (in conjunction with
      <code>LIMIT</code>) for picking a row at random
      from a result set (see <a data-type="xref" href="ch17.xhtml#nch-stats-stats-rand-rows">Recipe 17.7</a> and <a data-type="xref" href="ch17.xhtml#nch-stats-stats-rand-items">Recipe 17.8</a>).</p><p>The following examples demonstrate how to sort on a single column
      or multiple columns and how to sort in ascending or descending order.
      The examples select the rows in the <code>driver_log</code> table but sort them in different
      orders to demonstrate the effect of the different <code>ORDER</code> <code>BY</code>
      clauses.</p><p>This query produces a single-column sort using the driver
      name:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log ORDER BY name;</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      1 | Ben   | 2014-07-30 |   152 |
|      9 | Ben   | 2014-08-02 |    79 |
|      5 | Ben   | 2014-07-29 |   131 |
|      8 | Henry | 2014-08-01 |   197 |
|      6 | Henry | 2014-07-26 |   115 |
|      4 | Henry | 2014-07-27 |    96 |
|      3 | Henry | 2014-07-29 |   300 |
|     10 | Henry | 2014-07-30 |   203 |
|      7 | Suzi  | 2014-08-02 |   502 |
|      2 | Suzi  | 2014-07-29 |   391 |
+--------+-------+------------+-------+</pre><p>The default sort direction is ascending. To make the direction for
      an ascending sort explicit, add <code>ASC</code>
      after the sorted column’s name:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">name</code> <code class="k">ASC</code><code class="p">;</code></pre><p>The opposite (or reverse) of ascending order is descending order,
      specified by adding <code>DESC</code> after the
      sorted column’s name:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log ORDER BY name DESC;</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      2 | Suzi  | 2014-07-29 |   391 |
|      7 | Suzi  | 2014-08-02 |   502 |
|     10 | Henry | 2014-07-30 |   203 |
|      8 | Henry | 2014-08-01 |   197 |
|      6 | Henry | 2014-07-26 |   115 |
|      4 | Henry | 2014-07-27 |    96 |
|      3 | Henry | 2014-07-29 |   300 |
|      5 | Ben   | 2014-07-29 |   131 |
|      9 | Ben   | 2014-08-02 |    79 |
|      1 | Ben   | 2014-07-30 |   152 |
+--------+-------+------------+-------+</pre><p>Closely examine the output from the queries just shown and you’ll
      notice that although rows are sorted by name, rows for any given name
      are in no special order. (The <code>trav_date</code> values aren’t in date order for
      Henry or Ben, for example.) That’s because MySQL doesn’t sort something
      unless you tell it to:</p><ul><li><p>The overall order of rows returned by a query is indeterminate
          unless you specify an <code>ORDER</code>
          <code>BY</code> clause.</p></li><li><p>Within a group of rows that sort together based on the values
          in a given column, the order of values in other columns also is
          indeterminate unless you name them in the <code>ORDER</code> <code>BY</code> clause.</p></li></ul><p>To more fully control output order, specify a multiple-column sort
      by listing each column to use for sorting, separated by commas. The
      following query sorts in ascending order by <code>name</code> and by <code>trav_date</code> within the rows for each
      name:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log ORDER BY name, trav_date;</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      5 | Ben   | 2014-07-29 |   131 |
|      1 | Ben   | 2014-07-30 |   152 |
|      9 | Ben   | 2014-08-02 |    79 |
|      6 | Henry | 2014-07-26 |   115 |
|      4 | Henry | 2014-07-27 |    96 |
|      3 | Henry | 2014-07-29 |   300 |
|     10 | Henry | 2014-07-30 |   203 |
|      8 | Henry | 2014-08-01 |   197 |
|      2 | Suzi  | 2014-07-29 |   391 |
|      7 | Suzi  | 2014-08-02 |   502 |
+--------+-------+------------+-------+</pre><p>Multiple-column sorts can be descending as well, but <code>DESC</code> must be specified after
      <em>each</em> column name to perform a fully descending
      sort.</p><p>Multiple-column <code>ORDER</code> <code>BY</code> clauses can perform mixed-order sorting
      where some columns are sorted in ascending order and others in
      descending order. The following query sorts by <code>name</code> in descending order, then by <code>trav_date</code> in ascending order for each
      name:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log ORDER BY name DESC, trav_date;</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      2 | Suzi  | 2014-07-29 |   391 |
|      7 | Suzi  | 2014-08-02 |   502 |
|      6 | Henry | 2014-07-26 |   115 |
|      4 | Henry | 2014-07-27 |    96 |
|      3 | Henry | 2014-07-29 |   300 |
|     10 | Henry | 2014-07-30 |   203 |
|      8 | Henry | 2014-08-01 |   197 |
|      5 | Ben   | 2014-07-29 |   131 |
|      1 | Ben   | 2014-07-30 |   152 |
|      9 | Ben   | 2014-08-02 |    79 |
+--------+-------+------------+-------+</pre><p>The <code>ORDER</code> <code>BY</code> clauses in the queries shown thus far refer
      to the sorted columns by name. You can also name the columns by using
      aliases. That is, if an output column has an alias, you can refer to the
      alias in the <code>ORDER</code> <code>BY</code> clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, trav_date, miles AS distance FROM driver_log</code></strong>
    -&gt; <strong><code>ORDER BY distance;</code></strong>
+-------+------------+----------+
| name  | trav_date  | distance |
+-------+------------+----------+
| Ben   | 2014-08-02 |       79 |
| Henry | 2014-07-27 |       96 |
| Henry | 2014-07-26 |      115 |
| Ben   | 2014-07-29 |      131 |
| Ben   | 2014-07-30 |      152 |
| Henry | 2014-08-01 |      197 |
| Henry | 2014-07-30 |      203 |
| Henry | 2014-07-29 |      300 |
| Suzi  | 2014-07-29 |      391 |
| Suzi  | 2014-08-02 |      502 |
+-------+------------+----------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.2 Using Expressions for Sorting"><div class="sect1" id="nch-sort-sort-expr"><h1>9.2 Using Expressions for Sorting</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370155440"><h2>Problem</h2><p>You want to sort a query result based on values calculated from a column
      rather than the values actually stored in the column.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370154560"><h2>Solution</h2><p>Put the expression that calculates the values in the <code>ORDER</code> <code>BY</code>
      clause.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370152784"><h2>Discussion</h2><p>One of the <code>mail</code> table columns
      shows how large each mail message is, in bytes:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, srchost, dstuser, dsthost, size FROM mail;</code></strong>
+---------------------+---------+---------+---------+---------+---------+
| t                   | srcuser | srchost | dstuser | dsthost | size    |
+---------------------+---------+---------+---------+---------+---------+
| 2014-05-11 10:15:08 | barb    | saturn  | tricia  | mars    |   58274 |
| 2014-05-12 12:48:13 | tricia  | mars    | gene    | venus   |  194925 |
| 2014-05-12 15:02:49 | phil    | mars    | phil    | saturn  |    1048 |
| 2014-05-12 18:59:18 | barb    | saturn  | tricia  | venus   |     271 |
…</pre><p>Suppose that you want to retrieve rows for <q>big</q> mail
      messages (defined as those larger than 50,000 bytes), but you want them
      to be displayed and sorted by sizes in terms of kilobytes, not bytes. In
      this case, the values to sort are calculated by an expression:</p><pre data-type="programlisting">FLOOR((size+1023)/1024)</pre><p>The <code>+1023</code> in the <code>FLOOR()</code> expression groups <code>size</code> values to
      the nearest upper boundary of the 1,024-byte categories. Without it, the
      values group by lower boundaries (for example, a 2,047-byte message is
      reported as having a size of 1 kilobyte rather than 2). <a data-type="xref" href="ch10.xhtml#nch-sum-sum-noncat">Recipe 10.13</a> discusses this technique in more
      detail.</p><p>To sort by that expression, put it directly in the <code>ORDER</code> <code>BY</code>
      clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, FLOOR((size+1023)/1024)</code></strong>
    -&gt; <strong><code>FROM mail WHERE size &gt; 50000</code></strong>
    -&gt; <strong><code>ORDER BY FLOOR((size+1023)/1024);</code></strong>
+---------------------+---------+-------------------------+
| t                   | srcuser | FLOOR((size+1023)/1024) |
+---------------------+---------+-------------------------+
| 2014-05-11 10:15:08 | barb    |                      57 |
| 2014-05-14 14:42:21 | barb    |                      96 |
| 2014-05-12 12:48:13 | tricia  |                     191 |
| 2014-05-15 10:25:52 | gene    |                     976 |
| 2014-05-14 17:03:01 | tricia  |                    2339 |
+---------------------+---------+-------------------------+</pre><p>Alternatively, if the sorting expression appears in the output
      column list, you can alias it there and refer to the alias in the <code>ORDER</code> <code>BY</code>
      clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, FLOOR((size+1023)/1024) AS kilobytes</code></strong>
    -&gt; <strong><code>FROM mail WHERE size &gt; 50000</code></strong>
    -&gt; <strong><code>ORDER BY kilobytes;</code></strong>
+---------------------+---------+-----------+
| t                   | srcuser | kilobytes |
+---------------------+---------+-----------+
| 2014-05-11 10:15:08 | barb    |        57 |
| 2014-05-14 14:42:21 | barb    |        96 |
| 2014-05-12 12:48:13 | tricia  |       191 |
| 2014-05-15 10:25:52 | gene    |       976 |
| 2014-05-14 17:03:01 | tricia  |      2339 |
+---------------------+---------+-----------+</pre><p>You might prefer the alias method for several reasons:</p><ul><li><p>It’s easier to write the alias in the <code>ORDER</code> <code>BY</code> clause than to repeat the (cumbersome)
          expression.</p></li><li><p>Without the alias, if you change the expression one place, you
          must change it in the other.</p></li><li><p>The alias may be useful for display purposes, to provide a
          better column label. Note how the third column heading is much more
          meaningful in the second of the two preceding queries.</p></li></ul></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.3 Displaying One Set of Values While Sorting by Another"><div class="sect1" id="nch-sort-sort-one-display-other"><h1>9.3 Displaying One Set of Values While Sorting by Another</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370134816"><h2>Problem</h2><p>You want to sort a result set using values that don’t appear in the output
      column list.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370133792"><h2>Solution</h2><p>That’s not a problem. The <code>ORDER</code>
      <code>BY</code> clause can refer to columns you
      don’t display.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370131920"><h2>Discussion</h2><p><code>ORDER</code> <code>BY</code> is not limited to sorting only those
      columns named in the output column list. It can sort using values that
      are <q>hidden</q> (that is, not displayed in the query output).
      This technique is commonly used when you have values that can be
      represented different ways and you want to display one type of value but
      sort by another. For example, you may want to display mail message sizes
      not in terms of bytes, but as strings such as <code>103K</code> for 103 kilobytes. You can convert a byte
      count to that kind of value using this expression:</p><pre data-type="programlisting">CONCAT(FLOOR((size+1023)/1024),'K')</pre><p>However, such values are strings, so they sort lexically, not
      numerically. If you use them for sorting, a value such as <code>96K</code> sorts after <code>2339K</code>, even though it represents a smaller
      number:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser,</code></strong>
    -&gt; <strong><code>CONCAT(FLOOR((size+1023)/1024),'K') AS size_in_K</code></strong>
    -&gt; <strong><code>FROM mail WHERE size &gt; 50000</code></strong>
    -&gt; <strong><code>ORDER BY size_in_K;</code></strong>
+---------------------+---------+-----------+
| t                   | srcuser | size_in_K |
+---------------------+---------+-----------+
| 2014-05-12 12:48:13 | tricia  | 191K      |
| 2014-05-14 17:03:01 | tricia  | 2339K     |
| 2014-05-11 10:15:08 | barb    | 57K       |
| 2014-05-14 14:42:21 | barb    | 96K       |
| 2014-05-15 10:25:52 | gene    | 976K      |
+---------------------+---------+-----------+</pre><p>To achieve the desired output order, display the string, but use
      actual numeric size for sorting:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser,</code></strong>
    -&gt; <strong><code>CONCAT(FLOOR((size+1023)/1024),'K') AS size_in_K</code></strong>
    -&gt; <strong><code>FROM mail WHERE size &gt; 50000</code></strong>
    -&gt; <strong><code>ORDER BY size;</code></strong>
+---------------------+---------+-----------+
| t                   | srcuser | size_in_K |
+---------------------+---------+-----------+
| 2014-05-11 10:15:08 | barb    | 57K       |
| 2014-05-14 14:42:21 | barb    | 96K       |
| 2014-05-12 12:48:13 | tricia  | 191K      |
| 2014-05-15 10:25:52 | gene    | 976K      |
| 2014-05-14 17:03:01 | tricia  | 2339K     |
+---------------------+---------+-----------+</pre><p>Displaying values as strings but sorting them as numbers helps
      solve some otherwise difficult problems. Members of sports teams
      typically are assigned a jersey number, which normally you might think
      should be stored using a numeric column. Not so fast! Some players like
      to have a jersey number of zero (<code>0</code>),
      and some like double-zero (<code>00</code>). If a
      team happens to have players with both numbers, you cannot represent
      them using a numeric column because both values will be treated as the
      same number. To solve this problem, store jersey numbers as
      strings:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">roster</code>
<code class="p">(</code>
  <code class="n">name</code>        <code class="nb">CHAR</code><code class="p">(</code><code class="mi">30</code><code class="p">),</code>   <code class="o">#</code> <code class="n">player</code> <code class="n">name</code>
  <code class="n">jersey_num</code>  <code class="nb">CHAR</code><code class="p">(</code><code class="mi">3</code><code class="p">),</code>     <code class="o">#</code> <code class="n">jersey</code> <code class="nb">number</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code><code class="p">(</code><code class="n">name</code><code class="p">)</code>
<code class="p">);</code></pre><p>Then the jersey numbers will display the same way you enter them,
      and <code>0</code> and <code>00</code> will be treated as distinct values.
      Unfortunately, although representing numbers as strings solves the
      problem of distinguishing <code>0</code> and
      <code>00</code>, it introduces a different
      problem. Suppose that a team has the following players:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, jersey_num FROM roster;</code></strong>
+-----------+------------+
| name      | jersey_num |
+-----------+------------+
| Lynne     | 29         |
| Ella      | 0          |
| Elizabeth | 100        |
| Nancy     | 00         |
| Jean      | 8          |
| Sherry    | 47         |
+-----------+------------+</pre><p>Now try to sort the team members by jersey number. If those
      numbers are stored as strings, they sort lexically, and lexical order
      often differs from numeric order. That’s certainly true for the team in
      question:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, jersey_num FROM roster ORDER BY jersey_num;</code></strong>
+-----------+------------+
| name      | jersey_num |
+-----------+------------+
| Ella      | 0          |
| Nancy     | 00         |
| Elizabeth | 100        |
| Lynne     | 29         |
| Sherry    | 47         |
| Jean      | 8          |
+-----------+------------+</pre><p>The values <code>100</code> and <code>8</code> are out of place, but that’s easily solved:
      display the string values and use the numeric values for sorting. To
      accomplish this, add zero to the <code>jersey_num</code> values to force a string-to-number
      conversion:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, jersey_num FROM roster ORDER BY jersey_num+0;</code></strong>
+-----------+------------+
| name      | jersey_num |
+-----------+------------+
| Ella      | 0          |
| Nancy     | 00         |
| Jean      | 8          |
| Lynne     | 29         |
| Sherry    | 47         |
| Elizabeth | 100        |
+-----------+------------+</pre><div data-type="warning" epub:type="warning"><h6>Warning</h6><p>
          Note that because this method performs string-to-number conversion it cannot use indexes and will run slower as the table gets bigger. As alternative solution you may create a column that will hold result of this calculation and use it in the <code>ORDER BY</code> expression.
        </p></div><p>The technique of displaying one value but sorting by another is
      also useful when you display values composed from multiple columns that
      don’t sort the way you want. For example, the <code>mail</code> table lists message senders using
      separate <code>srcuser</code> and <code>srchost</code> values. To display message senders
      from the <code>mail</code> table as email
      addresses in <code>srcuser@srchost</code> format
      with the username first, construct those values using the following
      expression:</p><pre data-type="programlisting">CONCAT(srcuser,'@',srchost)</pre><p>However, those values are no good for sorting if you want to treat
      the hostname as more significant than the username. Instead,
      sort the results using the underlying column values rather than the
      displayed composite values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, CONCAT(srcuser,'@',srchost) AS sender, size</code></strong>
    -&gt; <strong><code>FROM mail WHERE size &gt; 50000</code></strong>
    -&gt; <strong><code>ORDER BY srchost, srcuser;</code></strong>
+---------------------+---------------+---------+
| t                   | sender        | size    |
+---------------------+---------------+---------+
| 2014-05-15 10:25:52 | gene@mars     |  998532 |
| 2014-05-12 12:48:13 | tricia@mars   |  194925 |
| 2014-05-11 10:15:08 | barb@saturn   |   58274 |
| 2014-05-14 17:03:01 | tricia@saturn | 2394482 |
| 2014-05-14 14:42:21 | barb@venus    |   98151 |
+---------------------+---------------+---------+</pre><p>The same idea commonly applies to sorting people’s names. Suppose
      that a <code>names</code> table contains last and
      first names. To display rows sorted by last name first, the query is
      straightforward when the columns are displayed separately:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT last_name, first_name FROM name</code></strong>
    -&gt; <strong><code>ORDER BY last_name, first_name;</code></strong>
+-----------+------------+
| last_name | first_name |
+-----------+------------+
| Blue      | Vida       |
| Brown     | Kevin      |
| Gray      | Pete       |
| White     | Devon      |
| White     | Rondell    |
+-----------+------------+</pre><p>If instead you want to display each name as a single string
      composed of the first name, a space, and the last name, begin the query
      like this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">CONCAT</code><code class="p">(</code><code class="n">first_name</code><code class="p">,</code><code class="s1">' '</code><code class="p">,</code><code class="n">last_name</code><code class="p">)</code> <code class="k">AS</code> <code class="n">full_name</code> <code class="k">FROM</code> <code class="n">name</code> <code class="p">...</code></pre><p>But then how do you sort the names so they come out in last-name
      order? Display composite names, but refer to the constituent values in the <code>ORDER</code>
      <code>BY</code> clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CONCAT(first_name,' ',last_name) AS full_name</code></strong>
    -&gt; <strong><code>FROM name</code></strong>
    -&gt; <strong><code>ORDER BY last_name, first_name;</code></strong>
+---------------+
| full_name     |
+---------------+
| Vida Blue     |
| Kevin Brown   |
| Pete Gray     |
| Devon White   |
| Rondell White |
+---------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.4 Controlling Case Sensitivity of String Sorts"><div class="sect1" id="nch-sort-sort-string"><h1>9.4 Controlling Case Sensitivity of String Sorts</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370022528"><h2>Problem</h2><p>String-sorting operations are case sensitive when you don’t want them to
      be, or vice versa.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370021472"><h2>Solution</h2><p>Alter the comparison characteristics of the sorted values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370020528"><h2>Discussion</h2><p><a data-type="xref" href="ch07.xhtml#nch-strings-strings-properties">Recipe 7.1</a> discusses
      how string-comparison properties depend on whether the
      strings are binary or nonbinary:</p><ul><li><p>Binary strings are sequences of bytes. They are compared byte by byte
          using numeric byte values. Character set and lettercase have no
          meaning for comparisons.</p></li><li><p>Nonbinary strings are sequences of characters. They have a character set and
          collation and are compared character by character using the order
          defined by the collation.</p></li></ul><p>These properties also apply to string sorting because sorting is
      based on comparison. To alter the sorting properties of a string column,
      alter its comparison properties. (For a summary of which string
      data types are binary and nonbinary, see <a data-type="xref" href="ch07.xhtml#nch-strings-strings-types">Recipe 7.2</a>.)</p><p>The examples in this section use a table that has case-insensitive and case-sensitive
      nonbinary columns, and a binary column:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">str_val</code>
<code class="p">(</code>
  <code class="n">ci_str</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code> <code class="nb">CHARACTER</code> <code class="k">SET</code> <code class="n">utf8mb4</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_ai_ci</code><code class="p">,</code>
  <code class="n">cs_str</code>   <code class="nb">CHAR</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code> <code class="nb">CHARACTER</code> <code class="k">SET</code> <code class="n">utf8mb4</code> <code class="k">COLLATE</code> <code class="n">utf8mb4_0900_as_cs</code><code class="p">,</code>
  <code class="n">bin_str</code>  <code class="nb">BINARY</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>
<code class="p">);</code></pre><p>Suppose that the table has these contents:</p><pre data-type="programlisting">+--------+--------+---------+
| ci_str | cs_str | bin_str |
+--------+--------+---------+
| AAA    | AAA    | AAA     |
| aaa    | aaa    | aaa     |
| bbb    | bbb    | bbb     |
| BBB    | BBB    | BBB     |
+--------+--------+---------+</pre><div data-type="tip"><h6>Tip</h6><p>
          As of MySLQ 8.0.19 <span class="command"><em>mysql</em></span> client prints binary data in hexademical format.
          </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">select</code><code> </code><code class="o">*</code><code> </code><code class="k">from</code><code> </code><code class="n">str_val</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">--------+--------+------------------+
</code><code class="o">|</code><code> </code><code class="n">ci_str</code><code> </code><code class="o">|</code><code> </code><code class="n">cs_str</code><code> </code><code class="o">|</code><code> </code><code class="n">bin_str</code><code>          </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">--------+--------+------------------+
</code><code class="o">|</code><code> </code><code class="n">AAA</code><code>    </code><code class="o">|</code><code> </code><code class="n">AAA</code><code>    </code><code class="o">|</code><code> </code><code class="mi">0</code><code class="n">x414141</code><code>         </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">aaa</code><code>    </code><code class="o">|</code><code> </code><code class="n">aaa</code><code>    </code><code class="o">|</code><code> </code><code class="mi">0</code><code class="n">x616161</code><code>         </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">bbb</code><code>    </code><code class="o">|</code><code> </code><code class="n">bbb</code><code>    </code><code class="o">|</code><code> </code><code class="mi">0</code><code class="n">x626262</code><code>         </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">BBB</code><code>    </code><code class="o">|</code><code> </code><code class="n">BBB</code><code>    </code><code class="o">|</code><code> </code><code class="mi">0</code><code class="n">x424242</code><code>         </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">--------+--------+------------------+
</code><code class="mi">4</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">.</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
          To print values in ASCII format start <span class="command"><em>mysql</em></span> with option <code>--binary-as-hex=0</code>.
        </p></div><p>Each column contains the same values, but the natural sort orders
      for the column data types produce three different results:</p><ul><li><p>The case-insensitive collation sorts <code>a</code> and <code>A</code>
          together, placing them before <code>b</code>
          and <code>B</code>. However, for a given
          letter, it does not necessarily order one lettercase before another,
          as shown by the following result:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ci_str FROM str_val ORDER BY ci_str;</code></strong>
+--------+
| ci_str |
+--------+
| AAA    |
| aaa    |
| bbb    |
| BBB    |
+--------+</pre></li><li><p>The case-sensitive collation puts <code>a</code> and <code>A</code>
          before <code>b</code> and <code>B</code>, and sorts lowercase before
          uppercase:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT cs_str FROM str_val ORDER BY cs_str;</code></strong>
+--------+
| cs_str |
+--------+
| aaa    |
| AAA    |
| bbb    |
| BBB    |
+--------+</pre></li><li><p>The binary strings sort numerically. Assuming that uppercase
          letters have numeric values less than those of lowercase letters, a
          binary sort results in the following ordering:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT bin_str FROM str_val ORDER BY bin_str;</code></strong>
+---------+
| bin_str |
+---------+
| AAA     |
| BBB     |
| aaa     |
| bbb     |
+---------+</pre><p>You get the same result for a nonbinary string column that has
          a binary collation, as long as the column contains single-byte
          characters (for example, <code>CHAR(3)</code>
          <code>CHARACTER</code> <code>SET</code> <code>latin1</code> <code>COLLATE</code> <code>latin1_bin</code>). For multibyte characters, a
          binary collation still produces a numeric sort, but the character
          values use multibyte numbers.</p></li></ul><p>To alter the sorting properties of each column, use the techniques
      described in <a data-type="xref" href="ch07.xhtml#nch-strings-strings-compare">Recipe 7.7</a> for
      controlling string comparisons:</p><ul><li><p>To sort case-insensitive strings in case-sensitive fashion,
          order the sorted values using a case-sensitive collation:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ci_str FROM str_val</code></strong>
    -&gt; <strong><code>ORDER BY ci_str COLLATE utf8mb4_0900_as_cs;</code></strong>
+--------+
| ci_str |
+--------+
| aaa    |
| AAA    |
| bbb    |
| BBB    |
+--------+</pre></li><li><p>To sort case-sensitive strings in case-insensitive fashion,
          order the sorted values using a case-insensitive collation:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT cs_str FROM str_val</code></strong>
    -&gt; <strong><code>ORDER BY cs_str COLLATE utf8mb4_0900_ai_ci;</code></strong>
+--------+
| cs_str |
+--------+
| AAA    |
| aaa    |
| bbb    |
| BBB    |
+--------+</pre><p>Alternatively, sort using values that have been converted to
          the same lettercase, which makes lettercase irrelevant:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT cs_str FROM str_val</code></strong>
    -&gt; <strong><code>ORDER BY UPPER(cs_str);</code></strong>
+--------+
| cs_str |
+--------+
| AAA    |
| aaa    |
| bbb    |
| BBB    |
+--------+</pre></li><li><p>Binary strings sort using numeric byte values, so there is no
          concept of lettercase involved. However, because letters in
          different cases have different byte values, comparisons of binary
          strings effectively are case sensitive. (That is, <code>a</code> and <code>A</code>
          are unequal.) To sort binary strings using a case-insensitive
          ordering, convert them to nonbinary strings and apply an appropriate
          collation. For example, to perform a case-insensitive sort, use a
          statement like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT bin_str FROM str_val</code></strong>
    -&gt; <strong><code>ORDER BY CONVERT(bin_str USING utf8mb4) COLLATE utf8mb4_0900_ai_ci;</code></strong>
+---------+
| bin_str |
+---------+
| AAA     |
| aaa     |
| bbb     |
| BBB     |
+---------+</pre><p>If the character-set default collation is case insensitive (as is true for <code>utf8mb4</code>), you can omit the <code>COLLATE</code> clause.</p></li></ul></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.5 Sorting in Temporal Order"><div class="sect1" id="nch-sort-sort-date"><h1>9.5 Sorting in Temporal Order</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369792288"><h2>Problem</h2><p>You want to sort rows in temporal order.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369791248"><h2>Solution</h2><p>Sort using a date or time column. If some parts of the values are
      irrelevant for the sort that you want to accomplish, ignore them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369790144"><h2>Discussion</h2><p>Many database tables include date or time information and it’s
      very often necessary to sort results in temporal order. MySQL knows how
      to sort temporal data types, so there’s no special trick to ordering
      them. The next few examples use the <code>mail</code> table, which
      contains a <code>DATETIME</code> column, but the
      same sorting principles apply to <code>DATE</code>, <code>TIME</code>, and <code>TIMESTAMP</code> columns.</p><p>Here are the messages sent by <code>phil</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, srchost, dstuser, dsthost, size</code></strong>
    -&gt; <strong><code>FROM mail WHERE srcuser = 'phil';</code></strong>
+---------------------+---------+---------+---------+---------+-------+
| t                   | srcuser | srchost | dstuser | dsthost | size  |
+---------------------+---------+---------+---------+---------+-------+
| 2014-05-12 15:02:49 | phil    | mars    | phil    | saturn  |  1048 |
| 2014-05-14 11:52:17 | phil    | mars    | tricia  | saturn  |  5781 |
| 2014-05-15 08:50:57 | phil    | venus   | phil    | venus   |   978 |
| 2014-05-16 23:04:19 | phil    | venus   | barb    | venus   | 10294 |
| 2014-05-19 12:49:23 | phil    | mars    | tricia  | saturn  |   873 |
+---------------------+---------+---------+---------+---------+-------+</pre><p>To display the messages, most recently sent ones first, use <code>ORDER</code>
      <code>BY</code> with <code>DESC</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, srchost, dstuser, dsthost, size</code></strong>
    -&gt; <strong><code>FROM mail WHERE srcuser = 'phil' ORDER BY t DESC;</code></strong>
+---------------------+---------+---------+---------+---------+-------+
| t                   | srcuser | srchost | dstuser | dsthost | size  |
+---------------------+---------+---------+---------+---------+-------+
| 2014-05-19 12:49:23 | phil    | mars    | tricia  | saturn  |   873 |
| 2014-05-16 23:04:19 | phil    | venus   | barb    | venus   | 10294 |
| 2014-05-15 08:50:57 | phil    | venus   | phil    | venus   |   978 |
| 2014-05-14 11:52:17 | phil    | mars    | tricia  | saturn  |  5781 |
| 2014-05-12 15:02:49 | phil    | mars    | phil    | saturn  |  1048 |
+---------------------+---------+---------+---------+---------+-------+</pre><p>Sometimes a temporal sort uses only part of a date or time column.
      In that case, use an expression that extracts the part or parts you need
      and sort the result using the expression. Some examples of this are
      given in the following discussion.</p><section data-type="sect3" data-pdf-bookmark="Sorting by time of day"><div class="sect3" id="idm45820369780208"><h3>Sorting by time of day</h3><p>You can do time-of-day sorting different ways, depending on your
        column type. If the values are stored in a <code>TIME</code> column named <code>timecol</code>, just sort them directly using
        <code>ORDER</code> <code>BY</code> <code>timecol</code>. To put <code>DATETIME</code> or <code>TIMESTAMP</code> values in time-of-day order,
        extract the time parts and sort them. For example, the <code>mail</code> table contains <code>DATETIME</code> values, which can be sorted by time
        of day like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, srchost, dstuser, dsthost, size FROM mail ORDER BY TIME(t);</code></strong>
+---------------------+---------+---------+---------+---------+---------+
| t                   | srcuser | srchost | dstuser | dsthost | size    |
+---------------------+---------+---------+---------+---------+---------+
| 2014-05-15 07:17:48 | gene    | mars    | gene    | saturn  |    3824 |
| 2014-05-15 08:50:57 | phil    | venus   | phil    | venus   |     978 |
| 2014-05-16 09:00:28 | gene    | venus   | barb    | mars    |     613 |
| 2014-05-14 09:31:37 | gene    | venus   | barb    | mars    |    2291 |
| 2014-05-11 10:15:08 | barb    | saturn  | tricia  | mars    |   58274 |
| 2014-05-15 10:25:52 | gene    | mars    | tricia  | saturn  |  998532 |
| 2014-05-14 11:52:17 | phil    | mars    | tricia  | saturn  |    5781 |
| 2014-05-12 12:48:13 | tricia  | mars    | gene    | venus   |  194925 |
…</pre></div></section><section data-type="sect3" data-pdf-bookmark="Sorting by calendar day"><div class="sect3" id="idm45820369773760"><h3>Sorting by calendar day</h3><p>To sort date values in calendar order, ignore the year part of
        the dates and use only the month and day to order values by where they
        fall during the calendar year. Suppose that an <code>occasion</code> table looks like this when values
        are ordered by date:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT date, description FROM occasion ORDER BY date;</code></strong>
+------------+-------------------------------------+
| date       | description                         |
+------------+-------------------------------------+
| 1215-06-15 | Signing of the Magna Carta          |
| 1732-02-22 | George Washington's birthday        |
| 1776-07-14 | Bastille Day                        |
| 1789-07-04 | US Independence Day                 |
| 1809-02-12 | Abraham Lincoln's birthday          |
| 1919-06-28 | Signing of the Treaty of Versailles |
| 1944-06-06 | D-Day at Normandy Beaches           |
| 1957-10-04 | Sputnik launch date                 |
| 1989-11-09 | Opening of the Berlin Wall          |
+------------+-------------------------------------+</pre><p>To put these items in calendar order, sort them by month and day
        within month:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT date, description FROM occasion</code></strong>
    -&gt; <strong><code>ORDER BY MONTH(date), DAYOFMONTH(date);</code></strong>
+------------+-------------------------------------+
| date       | description                         |
+------------+-------------------------------------+
| 1809-02-12 | Abraham Lincoln's birthday          |
| 1732-02-22 | George Washington's birthday        |
| 1944-06-06 | D-Day at Normandy Beaches           |
| 1215-06-15 | Signing of the Magna Carta          |
| 1919-06-28 | Signing of the Treaty of Versailles |
| 1789-07-04 | US Independence Day                 |
| 1776-07-14 | Bastille Day                        |
| 1957-10-04 | Sputnik launch date                 |
| 1989-11-09 | Opening of the Berlin Wall          |
+------------+-------------------------------------+</pre><p>MySQL has a <code>DAYOFYEAR()</code>
        function that you might suspect would be useful for calendar-day
        sorting. However, it can generate the same value for different
        calendar days. For example, February 29 of leap years and March 1 of
        nonleap years have the same day-of-year value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DAYOFYEAR('1996-02-29'), DAYOFYEAR('1997-03-01');</code></strong>
+-------------------------+-------------------------+
| DAYOFYEAR('1996-02-29') | DAYOFYEAR('1997-03-01') |
+-------------------------+-------------------------+
|                      60 |                      60 |
+-------------------------+-------------------------+</pre><p>This means that <code>DAYOFYEAR()</code>
        can group dates that actually occur on different calendar days.</p><p>If a table represents dates using separate year, month, and day
        columns, calendar sorting does not require to extract date parts. Just sort
        the relevant columns directly. For large datasets, sorting using
        separate date-part columns can be much faster than sorts based on
        extracting pieces of <code>DATE</code> values.
        There’s no overhead for part extraction, but more <span class="keep-together">importantly</span>, you can index the date-part
        columns separately—something not possible with a <code>DATE</code> column. The principle here is that you
        should design the table to make it easy to extract or sort by the
        values that you expect to use a lot.</p></div></section><section data-type="sect3" data-pdf-bookmark="Sorting by day of week"><div class="sect3" id="idm45820369764192"><h3>Sorting by day of week</h3><p>Day-of-week sorting is similar to calendar-day sorting, except
        that you use different functions to obtain the relevant ordering
        values.</p><p>You can get the day of the week using <code>DAYNAME()</code>, but that produces strings that sort lexically rather than in
        day-of-week order (Sunday, Monday, Tuesday, and so forth). Here the
        technique of displaying one value but sorting by another is useful
        (see <a data-type="xref" href="#nch-sort-sort-one-display-other">Recipe 9.3</a>). Display day
        names using <code>DAYNAME()</code>, but sort in
        day-of-week order using <code>DAYOFWEEK()</code>, which returns numeric values from 1 to 7 for Sunday through
        Saturday:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DAYNAME(date) AS day, date, description</code></strong>
    -&gt; <strong><code>FROM occasion</code></strong>
    -&gt; <strong><code>ORDER BY DAYOFWEEK(date);</code></strong>
+----------+------------+-------------------------------------+
| day      | date       | description                         |
+----------+------------+-------------------------------------+
| Sunday   | 1776-07-14 | Bastille Day                        |
| Sunday   | 1809-02-12 | Abraham Lincoln's birthday          |
| Monday   | 1215-06-15 | Signing of the Magna Carta          |
| Tuesday  | 1944-06-06 | D-Day at Normandy Beaches           |
| Thursday | 1989-11-09 | Opening of the Berlin Wall          |
| Friday   | 1957-10-04 | Sputnik launch date                 |
| Friday   | 1732-02-22 | George Washington's birthday        |
| Saturday | 1789-07-04 | US Independence Day                 |
| Saturday | 1919-06-28 | Signing of the Treaty of Versailles |
+----------+------------+-------------------------------------+</pre><p>To sort rows in day-of-week order but treat Monday as the first
        day of the week and Sunday as the last, use the modulo operation and the <code>MOD()</code> function to map Monday to 0, Tuesday to 1, …, Sunday to 6:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DAYNAME(date), date, description</code></strong>
    -&gt; <strong><code>FROM occasion</code></strong>
    -&gt; <strong><code>ORDER BY MOD(DAYOFWEEK(date)+5, 7);</code></strong>
+---------------+------------+-------------------------------------+
| DAYNAME(date) | date       | description                         |
+---------------+------------+-------------------------------------+
| Monday        | 1215-06-15 | Signing of the Magna Carta          |
| Tuesday       | 1944-06-06 | D-Day at Normandy Beaches           |
| Thursday      | 1989-11-09 | Opening of the Berlin Wall          |
| Friday        | 1957-10-04 | Sputnik launch date                 |
| Friday        | 1732-02-22 | George Washington's birthday        |
| Saturday      | 1789-07-04 | US Independence Day                 |
| Saturday      | 1919-06-28 | Signing of the Treaty of Versailles |
| Sunday        | 1776-07-14 | Bastille Day                        |
| Sunday        | 1809-02-12 | Abraham Lincoln's birthday          |
+---------------+------------+-------------------------------------+</pre><p>The <a data-type="xref" href="#nch-sort-sort-date-mod">Table 9-1</a> shows the <code>DAYOFWEEK()</code> expressions for putting any day
        of the week first in the sort order:</p><table id="nch-sort-sort-date-mod"><caption><span class="label">Table 9-1. </span>Using modulo to properly order days of a week</caption><thead><tr><th>Day to list first</th><th>DAYOFWEEK() expression</th></tr></thead><tbody><tr><td>Sunday</td><td><code>DAYOFWEEK(date)</code></td></tr><tr><td>Monday</td><td><code>MOD(DAYOFWEEK(date)+5, 7)</code></td></tr><tr><td>Tuesday</td><td><code>MOD(DAYOFWEEK(date)+4, 7)</code></td></tr><tr><td>Wednesday</td><td><code>MOD(DAYOFWEEK(date)+3, 7)</code></td></tr><tr><td>Thursday</td><td><code>MOD(DAYOFWEEK(date)+2, 7)</code></td></tr><tr><td>Friday</td><td><code>MOD(DAYOFWEEK(date)+1, 7)</code></td></tr><tr><td>Saturday</td><td><code>MOD(DAYOFWEEK(date)+0, 7)</code></td></tr></tbody></table><p>You can also use <code>WEEKDAY()</code> for
        day-of-week sorting, although it returns a different set of values (0
        for Monday through 6 for Sunday).</p></div></section></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.6 Sorting by Substrings of Column Values"><div class="sect1" id="nch-sort-sort-substr"><h1>9.6 Sorting by Substrings of Column Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369743328"><h2>Problem</h2><p>You want to sort a set of values using one or more substrings of each
      value.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369742416"><h2>Solution</h2><p>Extract the pieces you want and sort them separately.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369741408"><h2>Discussion</h2><p>This is a specific application of sorting by expression value (see
      <a data-type="xref" href="#nch-sort-sort-expr">Recipe 9.2</a>). To sort rows using just a
      particular portion of a column’s values, extract the substring you need
      and use it in the <code>ORDER</code> <code>BY</code> clause. This is easiest if the substrings
      are at a fixed position and length within the column. For substrings of
      variable position or length, you can still use them for sorting if you
      have a reliable way to identify them. The next several recipes show how
      to use substring extraction to produce specialized sort orders.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.7 Sorting by Fixed-Length Substrings"><div class="sect1" id="nch-sort-sort-substr-fixed"><h1>9.7 Sorting by Fixed-Length Substrings</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369737536"><h2>Problem</h2><p>You want to sort using parts of a column that occur at a given position within
      the column.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369736448"><h2>Solution</h2><p>Pull out the parts you need with <code>LEFT()</code>, <code>SUBSTRING()</code> (<code>MID()</code>), or <code>RIGHT()</code>, and sort them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369733696"><h2>Discussion</h2><p>Suppose that a <code>housewares</code> table
      catalogs houseware furnishings, each identified by 10-character ID
      values consisting of three subparts: a three-character category
      abbreviation (such as <code>DIN</code> for
      <q>dining room</q> or <code>KIT</code> for
      <q>kitchen</q>), a five-digit serial number, and a two-character
      country code indicating where the part is manufactured:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares;</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| DIN40672US | dining table     |
| KIT00372UK | garbage disposal |
| KIT01729JP | microwave oven   |
| BED00038SG | bedside lamp     |
| BTH00485US | shower stall     |
| BTH00415JP | lavatory         |
+------------+------------------+</pre><p>This is not necessarily a good way to store complex ID values, and
      later we’ll consider how to represent them using separate columns. For
      now, assume that the values must be stored as shown.</p><p>To sort rows from this table based on the <code>id</code> values, use the entire column value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares ORDER BY id;</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| BED00038SG | bedside lamp     |
| BTH00415JP | lavatory         |
| BTH00485US | shower stall     |
| DIN40672US | dining table     |
| KIT00372UK | garbage disposal |
| KIT01729JP | microwave oven   |
+------------+------------------+</pre><p>But you might also have a need to sort on any of the three
      subparts (for example, to sort by country of manufacture). For that kind
      of operation, functions such as <code>LEFT()</code>, <code>MID()</code>, and <code>RIGHT()</code> are useful to extract <code>id</code> value components:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT id,</code></strong>
    -&gt; <strong><code>LEFT(id,3) AS category,</code></strong>
    -&gt; <strong><code>MID(id,4,5) AS serial,</code></strong>
    -&gt; <strong><code>RIGHT(id,2) AS country</code></strong>
    -&gt; <strong><code>FROM housewares;</code></strong>
+------------+----------+--------+---------+
| id         | category | serial | country |
+------------+----------+--------+---------+
| DIN40672US | DIN      | 40672  | US      |
| KIT00372UK | KIT      | 00372  | UK      |
| KIT01729JP | KIT      | 01729  | JP      |
| BED00038SG | BED      | 00038  | SG      |
| BTH00485US | BTH      | 00485  | US      |
| BTH00415JP | BTH      | 00415  | JP      |
+------------+----------+--------+---------+</pre><div data-type="tip"><h6>Tip</h6><p>
          Function <code>MID()</code> is a synonym of the function <code>SUBSTRING()</code>.
        </p></div><p>Those fixed-length substrings of the <code>id</code> values can be used for sorting, either
      alone or in combination. For example, to sort by product category,
      extract and use the category in the <code>ORDER</code> <code>BY</code> clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares ORDER BY LEFT(id,3);</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| BED00038SG | bedside lamp     |
| BTH00485US | shower stall     |
| BTH00415JP | lavatory         |
| DIN40672US | dining table     |
| KIT00372UK | garbage disposal |
| KIT01729JP | microwave oven   |
+------------+------------------+</pre><p>To sort by product serial number, use <code>MID()</code> to extract the middle five characters
      from the <code>id</code> values, beginning with
      the fourth:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares ORDER BY MID(id,4,5);</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| BED00038SG | bedside lamp     |
| KIT00372UK | garbage disposal |
| BTH00415JP | lavatory         |
| BTH00485US | shower stall     |
| KIT01729JP | microwave oven   |
| DIN40672US | dining table     |
+------------+------------------+</pre><p>This appears to be a numeric sort, but it’s actually a string sort
      because <code>MID()</code> returns strings. The
      lexical and numeric sort order are the same in this case because the
      <q>numbers</q> have leading zeros to make them all the same
      length.</p><p>To sort by country code, use the rightmost two characters of the
      <code>id</code> values (<code>ORDER</code> <code>BY</code>
      <code>RIGHT(id,2)</code>).</p><p>You can also sort using combinations of substrings; for example,
      by country code and serial number within country:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares ORDER BY RIGHT(id,2), MID(id,4,5);</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| BTH00415JP | lavatory         |
| KIT01729JP | microwave oven   |
| BED00038SG | bedside lamp     |
| KIT00372UK | garbage disposal |
| BTH00485US | shower stall     |
| DIN40672US | dining table     |
+------------+------------------+</pre><p>The <code>ORDER</code> <code>BY</code> clauses just shown suffice to sort by
      substrings of the <code>id</code> values, but if
      such operations on the table are common, it might be worth representing
      houseware IDs differently; for example, using separate columns for the
      ID components. This table, <code>housewares2</code>, is like <code>housewares</code> but uses <code>category</code>, <code>serial</code>, and <code>country</code> columns generated from the <code>id</code> column:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="o">`</code><code class="n">housewares2</code><code class="o">`</code> <code class="p">(</code>
  <code class="o">`</code><code class="n">id</code><code class="o">`</code> <code class="nb">varchar</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="o">`</code><code class="n">category</code><code class="o">`</code> <code class="nb">varchar</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code> <code class="k">GENERATED</code> <code class="n">ALWAYS</code> <code class="k">AS</code> <code class="p">(</code><code class="k">left</code><code class="p">(</code><code class="o">`</code><code class="n">id</code><code class="o">`</code><code class="p">,</code><code class="mi">3</code><code class="p">))</code> <code class="n">STORED</code><code class="p">,</code>
  <code class="o">`</code><code class="nb">serial</code><code class="o">`</code> <code class="nb">char</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code> <code class="k">GENERATED</code> <code class="n">ALWAYS</code> <code class="k">AS</code> <code class="p">(</code><code class="n">substr</code><code class="p">(</code><code class="o">`</code><code class="n">id</code><code class="o">`</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">))</code> <code class="n">STORED</code><code class="p">,</code>
  <code class="o">`</code><code class="n">country</code><code class="o">`</code> <code class="nb">varchar</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="k">GENERATED</code> <code class="n">ALWAYS</code> <code class="k">AS</code> <code class="p">(</code><code class="k">right</code><code class="p">(</code><code class="o">`</code><code class="n">id</code><code class="o">`</code><code class="p">,</code><code class="mi">2</code><code class="p">))</code> <code class="n">STORED</code><code class="p">,</code>
  <code class="o">`</code><code class="n">description</code><code class="o">`</code> <code class="nb">varchar</code><code class="p">(</code><code class="mi">255</code><code class="p">)</code> <code class="k">DEFAULT</code> <code class="k">NULL</code><code class="p">,</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="o">`</code><code class="n">id</code><code class="o">`</code><code class="p">)</code>
<code class="p">);</code></pre><p>
        In this example we used generated columns that are generated based on the expressions, defined at the column creation time.
      </p><p>With the ID values split into separate parts, sorting operations
      are easier to specify; refer to individual columns directly rather than
      pulling out substrings of the original <code>id</code> column. You can also make operations that
      sort the <code>serial</code> and <code>country</code> columns more efficient by adding
      indexes on those columns.</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT category, serial, country, id</code></strong>
    -&gt; <strong><code>FROM housewares2 ORDER BY category, country, serial;</code></strong>
+----------+--------+---------+------------+
| category | serial | country | id         |
+----------+--------+---------+------------+
| BED      |  00038 | SG      | BED00038SG |
| BTH      |  00415 | JP      | BTH00415JP |
| BTH      |  00485 | US      | BTH00485US |
| DIN      |  40672 | US      | DIN40672US |
| KIT      |  01729 | JP      | KIT01729JP |
| KIT      |  00372 | UK      | KIT00372UK |
+----------+--------+---------+------------+</pre><p>This example illustrates an important principle: you might think
      about values one way (<code>id</code> values as
      single strings), but you need not necessarily represent them that way in
      the database. If an alternative representation (separate columns) is
      more efficient or easier to work with, it may well be worth using—even
      if you must reformat the underlying columns so they appear as people expect.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.8 Sorting by Variable-Length Substrings"><div class="sect1" id="nch-sort-sort-substr-variable"><h1>9.8 Sorting by Variable-Length Substrings</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369639488"><h2>Problem</h2><p>You want to sort using parts of a column that do
      <em>not</em> occur at a given position within the
      column.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369638128"><h2>Solution</h2><p>Determine how to identify the parts you need so that you can
      extract them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369637184"><h2>Discussion</h2><p>If substrings to be used for sorting vary in length, you need a
      reliable means of extracting just the part you want. To see how this
      works, let’s create a <code>housewares3</code> table
      that is like the <code>housewares</code> table
      used in <a data-type="xref" href="#nch-sort-sort-substr-fixed">Recipe 9.7</a>, except that it
      has no leading zeros in the serial number part of the <code>id</code> values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares3;</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| DIN40672US | dining table     |
| KIT372UK   | garbage disposal |
| KIT1729JP  | microwave oven   |
| BED38SG    | bedside lamp     |
| BTH485US   | shower stall     |
| BTH415JP   | lavatory         |
+------------+------------------+</pre><p>The category and country parts of the <code>id</code> values can be extracted and sorted
      using <code>LEFT()</code> and
      <code>RIGHT()</code>, just as for the <code>housewares</code> table. But now the numeric segments
      of the values have different lengths and cannot be extracted and sorted
      using a simple <code>MID()</code> call. Instead,
      use its full version <code>SUBSTRING()</code> to skip the first three characters. Of the remainder
      beginning with the fourth character (the first digit), take everything
      but the rightmost two columns. One way to do this is as follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT id, LEFT(SUBSTRING(id,4),CHAR_LENGTH(SUBSTRING(id,4)-2))</code></strong>
    -&gt; <strong><code>FROM housewares3;</code></strong>
+------------+------------------------------------------------------+
| id         | LEFT(SUBSTRING(id,4),CHAR_LENGTH(SUBSTRING(id,4)-2)) |
+------------+------------------------------------------------------+
| DIN40672US | 40672                                                |
| KIT372UK   | 372                                                  |
| KIT1729JP  | 1729                                                 |
| BED38SG    | 38                                                   |
| BTH485US   | 485                                                  |
| BTH415JP   | 415                                                  |
+------------+------------------------------------------------------+</pre><p>But that’s more complex than necessary. The <code>SUBSTRING()</code> function takes an optional third
      argument specifying a desired result length, and we know that the length
      of the middle part is equal to the length of the string minus five
      (three for the characters at the beginning and two for the characters at
      the end). The following query demonstrates how to get the numeric middle
      part by beginning with the ID, and then stripping the rightmost
      suffix:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT id, SUBSTRING(id,4), SUBSTRING(id,4,CHAR_LENGTH(id)-5)</code></strong>
    -&gt; <strong><code>FROM housewares3;</code></strong>
+------------+-----------------+-----------------------------------+
| id         | SUBSTRING(id,4) | SUBSTRING(id,4,CHAR_LENGTH(id)-5) |
+------------+-----------------+-----------------------------------+
| DIN40672US | 40672US         | 40672                             |
| KIT372UK   | 372UK           | 372                               |
| KIT1729JP  | 1729JP          | 1729                              |
| BED38SG    | 38SG            | 38                                |
| BTH485US   | 485US           | 485                               |
| BTH415JP   | 415JP           | 415                               |
+------------+-----------------+-----------------------------------+</pre><p>Unfortunately, although the final expression correctly extracts
      the numeric part from the IDs, the resulting values are strings.
      Consequently, they sort lexically rather than numerically:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares3</code></strong>
    -&gt; <strong><code>ORDER BY SUBSTRING(id,4,CHAR_LENGTH(id)-5);</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| KIT1729JP  | microwave oven   |
| KIT372UK   | garbage disposal |
| BED38SG    | bedside lamp     |
| DIN40672US | dining table     |
| BTH415JP   | lavatory         |
| BTH485US   | shower stall     |
+------------+------------------+</pre><p>How to deal with that? One way is to add zero, which tells MySQL
      to perform a string-to-number conversion that results in a numeric sort
      of the serial number values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares3</code></strong>
    -&gt; <strong><code>ORDER BY SUBSTRING(id,4,CHAR_LENGTH(id)-5)+0;</code></strong>
+------------+------------------+
| id         | description      |
+------------+------------------+
| BED38SG    | bedside lamp     |
| KIT372UK   | garbage disposal |
| BTH415JP   | lavatory         |
| BTH485US   | shower stall     |
| KIT1729JP  | microwave oven   |
| DIN40672US | dining table     |
+------------+------------------+</pre><p>In the preceding example, the ability to extract variable-length substrings
      is based on the different kinds of characters in the middle of the
      <code>id</code> values, compared to the characters on the ends
      (that is, digits versus nondigits). In other cases, you may be able to
      use delimiter characters to pull apart column values. For the next
      examples, assume a <code>housewares4</code> table
      with <code>id</code> values that look like
      this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares4;</code></strong>
+---------------+------------------+
| id            | description      |
+---------------+------------------+
| 13-478-92-2   | dining table     |
| 873-48-649-63 | garbage disposal |
| 8-4-2-1       | microwave oven   |
| 97-681-37-66  | bedside lamp     |
| 27-48-534-2   | shower stall     |
| 5764-56-89-72 | lavatory         |
+---------------+------------------+</pre><p>To extract segments from these values, use <code>SUBSTRING_INDEX(</code><em><code>str</code></em><code>,</code><em><code>c</code></em><code>,</code><em><code>n</code></em><code>)</code>. It searches a string
      <em><code>str</code></em> for the <em><code>n</code></em>-th
      occurrence of a given character <em><code>c</code></em> and returns
      everything to the left of that character. For example, the following
      call returns <code>13-478</code>:</p><pre data-type="programlisting">SUBSTRING_INDEX('13-478-92-2','-',2)</pre><p>If <em><code>n</code></em> is negative, the search for
      <em><code>c</code></em> proceeds from the right and returns the
      rightmost string. This call returns <code>478-92-2</code>:</p><pre data-type="programlisting">SUBSTRING_INDEX('13-478-92-2','-',-3)</pre><p>By combining <code>SUBSTRING_INDEX()</code>
      calls with positive and negative indexes, it’s possible to extract
      successive pieces from each <code>id</code> value:
      extract the first <em><code>n</code></em> segments of the value and
      pull off the rightmost one. By varying <em><code>n</code></em> from
      1 to 4, we get the successive segments from left to right:</p><pre data-type="programlisting">SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',1),'-',-1)
SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',2),'-',-1)
SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',3),'-',-1)
SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',4),'-',-1)</pre><p>The first of those expressions can be optimized because the inner
      <code>SUBSTRING_INDEX()</code> call returns a
      single-segment string and is sufficient by itself to return the leftmost
      <code>id</code> segment:</p><pre data-type="programlisting">SUBSTRING_INDEX(id,'-',1)</pre><p>Another way to obtain substrings is to extract the rightmost
      <em><code>n</code></em> segments of the value and pull off the
      first one. Here we vary <em><code>n</code></em> from –4 to
      –1:</p><pre data-type="programlisting">SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',-4),'-',1)
SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',-3),'-',1)
SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',-2),'-',1)
SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',-1),'-',1)</pre><p>Again, an optimization is possible. For the fourth expression, the
      inner <code>SUBSTRING_INDEX()</code> call is
      sufficient to return the final substring:</p><pre data-type="programlisting">SUBSTRING_INDEX(id,'-',-1)</pre><p>These expressions can be difficult to read and understand, and
      experimenting with a few to see how they work may be useful. Here is an
      example that shows how to get the second and fourth segments from the
      <code>id</code> values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>id,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',2),'-',-1) AS segment2,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',4),'-',-1) AS segment4</code></strong>
    -&gt; <strong><code>FROM housewares4;</code></strong>
+---------------+----------+----------+
| id            | segment2 | segment4 |
+---------------+----------+----------+
| 13-478-92-2   | 478      | 2        |
| 873-48-649-63 | 48       | 63       |
| 8-4-2-1       | 4        | 1        |
| 97-681-37-66  | 681      | 66       |
| 27-48-534-2   | 48       | 2        |
| 5764-56-89-72 | 56       | 72       |
+---------------+----------+----------+</pre><p>To use the substrings for sorting, use the appropriate expressions
      in the <code>ORDER</code> <code>BY</code> clause. (Remember to force a
      string-to-number conversion by adding zero if you want a <span class="keep-together">numeric</span> rather than lexical sort.) The
      following two queries order the results based on the second <code>id</code> segment. The first sorts lexically, the
      second numerically:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM housewares4</code></strong>
    -&gt; <strong><code>ORDER BY SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',2),'-',-1);</code></strong>
+---------------+------------------+
| id            | description      |
+---------------+------------------+
| 8-4-2-1       | microwave oven   |
| 13-478-92-2   | dining table     |
| 873-48-649-63 | garbage disposal |
| 27-48-534-2   | shower stall     |
| 5764-56-89-72 | lavatory         |
| 97-681-37-66  | bedside lamp     |
+---------------+------------------+
mysql&gt; <strong><code>SELECT * FROM housewares4</code></strong>
    -&gt; <strong><code>ORDER BY SUBSTRING_INDEX(SUBSTRING_INDEX(id,'-',2),'-',-1)+0;</code></strong>
+---------------+------------------+
| id            | description      |
+---------------+------------------+
| 8-4-2-1       | microwave oven   |
| 873-48-649-63 | garbage disposal |
| 27-48-534-2   | shower stall     |
| 5764-56-89-72 | lavatory         |
| 13-478-92-2   | dining table     |
| 97-681-37-66  | bedside lamp     |
+---------------+------------------+</pre><p>The substring-extraction expressions here are messy, but at least
      the column values to which we apply the expressions have a consistent
      number of segments. To sort values that have varying numbers of
      segments, the job can be more difficult. <a data-type="xref" href="#nch-sort-sort-domain">Recipe 9.9</a> shows an example illustrating
      why that is.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.9 Sorting Hostnames in Domain Order"><div class="sect1" id="nch-sort-sort-domain"><h1>9.9 Sorting Hostnames in Domain Order</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369496880"><h2>Problem</h2><p>You want to sort hostnames in domain order, with the rightmost parts of the
      names more significant than the leftmost parts.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369495904"><h2>Solution</h2><p>Break apart the names, and sort the pieces from right to
      left.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369494960"><h2>Discussion</h2><p>Hostnames are strings and therefore their natural sort order is
      lexical. However, it’s often desirable to sort hostnames in domain
      order, where the rightmost segments of the hostname values are more
      significant than the leftmost segments. Suppose that a <code>hostname</code> table contains the following
      names:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name FROM hostname ORDER BY name;</code></strong>
+--------------------+
| name               |
+--------------------+
| dbi.perl.org       |
| jakarta.apache.org |
| lists.mysql.com    |
| mysql.com          |
| svn.php.net        |
| www.kitebird.com   |
+--------------------+</pre><p>The preceding query demonstrates the natural lexical sort order of
      the <code>name</code> values. That differs from
      domain order, as the <a data-type="xref" href="#nch-sort-sort-domain-domain">Table 9-2</a> shows:</p><table id="nch-sort-sort-domain-domain"><caption><span class="label">Table 9-2. </span>Lexical versus Domain sort order</caption><thead><tr><th>Lexical order</th><th>Domain order</th></tr></thead><tbody><tr><td><code>dbi.perl.org </code></td><td><code>www.kitebird.com </code></td></tr><tr><td><code>jakarta.apache.org </code></td><td><code>mysql.com </code></td></tr><tr><td><code>lists.mysql.com </code></td><td><code>lists.mysql.com </code></td></tr><tr><td><code>mysql.com </code></td><td><code>svn.php.net </code></td></tr><tr><td><code>svn.php.net </code></td><td><code>jakarta.apache.org </code></td></tr><tr><td><code>www.kitebird.com </code></td><td><code>dbi.perl.org </code></td></tr></tbody></table><p>Producing domain-ordered output is a substring-sorting problem for
      which it’s necessary to extract each segment of the names so they can be
      sorted in right-to-left fashion. There is also an additional
      complication if your values contain different numbers of segments, as
      our example hostnames do. (Most of them have three segments, but
      <code>mysql.com</code> has only two.)</p><p>To extract the pieces of the hostnames, begin by using <code>SUBSTRING_INDEX()</code>
      in a manner similar to that described previously in <a data-type="xref" href="#nch-sort-sort-substr-variable">Recipe 9.8</a>. The hostname values have a
      maximum of three segments, from which the pieces can be extracted left
      to right like this:</p><pre data-type="programlisting">SUBSTRING_INDEX(SUBSTRING_INDEX(name,'.',-3),'.',1)
SUBSTRING_INDEX(SUBSTRING_INDEX(name,'.',-2),'.',1)
SUBSTRING_INDEX(name,'.',-1)</pre><p>These expressions work properly as long as all the hostnames have
      three components. But if a name has fewer than three, you don’t get the
      correct result, as the following query demonstrates:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(name,'.',-3),'.',1) AS leftmost,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(name,'.',-2),'.',1) AS middle,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(name,'.',-1) AS rightmost</code></strong>
    -&gt; <strong><code>FROM hostname;</code></strong>
+--------------------+----------+----------+-----------+
| name               | leftmost | middle   | rightmost |
+--------------------+----------+----------+-----------+
| svn.php.net        | svn      | php      | net       |
| dbi.perl.org       | dbi      | perl     | org       |
| lists.mysql.com    | lists    | mysql    | com       |
| mysql.com          | mysql    | mysql    | com       |
| jakarta.apache.org | jakarta  | apache   | org       |
| www.kitebird.com   | www      | kitebird | com       |
+--------------------+----------+----------+-----------+</pre><p>Notice the output for the <code>mysql.com</code> row; it has <code>mysql</code> for the value of the <code>leftmost</code> column, where it should have an empty
      string. The segment-extraction expressions work by pulling off the
      rightmost <em><code>n</code></em> segments, and then returning the
      leftmost segment of the result. The source of the problem for <code>mysql.com</code> is that if there aren’t
      <em><code>n</code></em> segments, the expression simply returns the
      leftmost segment of however many there are. To fix this problem, add a
      sufficient number of periods at the beginning of the hostname values to
      guarantee that they have the requisite number of segments:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT('..',name),'.',-3),'.',1)</code></strong>
    -&gt; <strong><code>AS leftmost,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT('.',name),'.',-2),'.',1)</code></strong>
    -&gt; <strong><code>AS middle,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(name,'.',-1) AS rightmost</code></strong>
    -&gt; <strong><code>FROM hostname;</code></strong>
+--------------------+----------+----------+-----------+
| name               | leftmost | middle   | rightmost |
+--------------------+----------+----------+-----------+
| svn.php.net        | svn      | php      | net       |
| dbi.perl.org       | dbi      | perl     | org       |
| lists.mysql.com    | lists    | mysql    | com       |
| mysql.com          |          | mysql    | com       |
| jakarta.apache.org | jakarta  | apache   | org       |
| www.kitebird.com   | www      | kitebird | com       |
+--------------------+----------+----------+-----------+</pre><p>That’s pretty ugly. But the expressions do serve to extract the
      substrings that are needed for sorting hostname values correctly in
      right-to-left fashion:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name FROM hostname</code></strong>
    -&gt; <strong><code>ORDER BY</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(name,'.',-1),</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT('.',name),'.',-2),'.',1),</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT('..',name),'.',-3),'.',1);</code></strong>
+--------------------+
| name               |
+--------------------+
| www.kitebird.com   |
| mysql.com          |
| lists.mysql.com    |
| svn.php.net        |
| jakarta.apache.org |
| dbi.perl.org       |
+--------------------+</pre><p>If your hostnames have a maximum of four segments rather than
      three, add to the <code>ORDER</code> <code>BY</code> clause another <code>SUBSTRING_INDEX()</code> expression that adds three
      dots at the beginning of the hostname values.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.10 Sorting Dotted-Quad IP Values in Numeric Order"><div class="sect1" id="nch-sort-sort-ip"><h1>9.10 Sorting Dotted-Quad IP Values in Numeric Order</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369459696"><h2>Problem</h2><p>You want to sort in numeric order strings that represent IP numbers.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369458688"><h2>Solution</h2><p>Break apart the strings, and sort the pieces numerically. Or just
      use <code>INET_ATON()</code>. Or
      consider storing the values as numbers instead.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369457152"><h2>Discussion</h2><p>If a table contains IP numbers represented as strings in
      dotted-quad notation (<code>192.168.1.10</code>),
      they sort lexically rather than numerically. To produce a numeric
      ordering instead, sort them as four-part values with each part sorted
      numerically. Or, to be more efficient, represent the IP numbers as
      32-bit unsigned integers, which take less space and can be ordered by a
      simple numeric sort. This section shows both methods.</p><p>To sort string-valued dotted-quad IP numbers, use a technique
      similar to that for sorting hostnames (see <a data-type="xref" href="#nch-sort-sort-domain">Recipe 9.9</a>), but with the following
      differences:</p><ul><li><p>Dotted quads always have four segments. There’s no need to add
          dots to the value before extracting substrings.</p></li><li><p>Dotted quads sort left to right. The order of the substrings
          used in the <code>ORDER</code> <code>BY</code> clause is opposite to that used for
          hostname sorting.</p></li><li><p>The segments of dotted-quad values are numbers. Add zero to
          each substring to force a numeric rather than lexical sort.</p></li></ul><p>Suppose that a <code>hostip</code> table has
      a string-valued <code>ip</code> column containing
      IP numbers:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ip FROM hostip ORDER BY ip;</code></strong>
+-----------------+
| ip              |
+-----------------+
| 127.0.0.1       |
| 192.168.0.10    |
| 192.168.0.2     |
| 192.168.1.10    |
| 192.168.1.2     |
| 21.0.0.1        |
| 255.255.255.255 |
+-----------------+</pre><p>The preceding query produces output sorted in lexical order. To
      sort the <code>ip</code> values numerically,
      extract each segment and add zero to convert it to a number like
      this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ip FROM hostip</code></strong>
    -&gt; <strong><code>ORDER BY</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(ip,'.',1)+0,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(ip,'.',-3),'.',1)+0,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(SUBSTRING_INDEX(ip,'.',-2),'.',1)+0,</code></strong>
    -&gt; <strong><code>SUBSTRING_INDEX(ip,'.',-1)+0;</code></strong>
+-----------------+
| ip              |
+-----------------+
| 21.0.0.1        |
| 127.0.0.1       |
| 192.168.0.2     |
| 192.168.0.10    |
| 192.168.1.2     |
| 192.168.1.10    |
| 255.255.255.255 |
+-----------------+</pre><p>However, although that <code>ORDER</code>
      <code>BY</code> clause produces a correct result,
      it’s complicated. A simpler solution uses the <code>INET_ATON()</code> function to convert network
      addresses in string form to their underlying numeric values, then sorts
      those numbers:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ip FROM hostip ORDER BY INET_ATON(ip);</code></strong>
+-----------------+
| ip              |
+-----------------+
| 21.0.0.1        |
| 127.0.0.1       |
| 192.168.0.2     |
| 192.168.0.10    |
| 192.168.1.2     |
| 192.168.1.10    |
| 255.255.255.255 |
+-----------------+</pre><p>If you’re tempted to sort by simply adding zero to the <code>ip</code> value and using <code>ORDER</code> <code>BY</code> on
      the result, consider the values that kind of string-to-number conversion
      actually produces:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ip, ip+0 FROM hostip;</code></strong>
+-----------------+---------+
| ip              | ip+0    |
+-----------------+---------+
| 127.0.0.1       |     127 |
| 192.168.0.2     | 192.168 |
| 192.168.0.10    | 192.168 |
| 192.168.1.2     | 192.168 |
| 192.168.1.10    | 192.168 |
| 255.255.255.255 | 255.255 |
| 21.0.0.1        |      21 |
+-----------------+---------+
7 rows in set, 7 warnings (0.00 sec)</pre><p>The conversion retains only as much of each value as can be
      interpreted as a valid number (hence the warnings). The remainder
      becomes unavailable for sorting purposes, even though it’s required for
      a correct ordering.</p><p>Use of <code>INET_ATON()</code> in the
      <code>ORDER</code> <code>BY</code> clause is more efficient than six <code>SUBSTRING_INDEX()</code>
      calls. Moreover, if you storing IP addresses as
      numbers rather than as strings, you can avoid performing any conversion
      at all when sorting. You gain other benefits as well: numeric IP
      addresses have 32 bits, so you can use a 4-byte <code>INT</code> <code>UNSIGNED</code> column to store them, which requires
      less storage than the string form. Also, if you index the column, the
      query optimizer may be able to use the index for certain queries. For
      cases requiring display of numeric IP values in dotted-quad notation,
      convert them with the <code>INET_NTOA()</code>
      function.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.11 Floating Values to the Head or Tail of the Sort Order"><div class="sect1" id="nch-sort-sort-float"><h1>9.11 Floating Values to the Head or Tail of the Sort Order</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369431584"><h2>Problem</h2><p>You want a column to sort the way it normally does, except for a few values
      that should appear at the beginning or end of the sort order. For
      example, you want to sort a list in lexical order except for certain
      high-priority values that should appear first no matter where they fall
      in the normal sort order.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369430288"><h2>Solution</h2><p>Add an initial sort column to the <code>ORDER</code> <code>BY</code>
      clause that places those few values where you want them. The
      remaining sort columns have their usual effect for the other
      values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369428272"><h2>Discussion</h2><p>To sort a result set normally <em>except</em> that you
      want particular values first, create an additional sort column that is 0
      for those values and 1 for everything else. This enables you to float
      the values to the head of the ascending sort order. To put the values at the tail
      instead, use descending sort order or store 1 for rows that you want to be in the end of the list and 0 for others.</p><p>Suppose that a column contains <code>NULL</code>
      values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT val FROM t;</code></strong>
+------+
| val  |
+------+
|    3 |
|  100 |
| NULL |
| NULL |
|    9 |
+------+</pre><p>Normally, sorting groups the <code>NULL</code> values at the beginning for an ascending
      sort:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT val FROM t ORDER BY val;</code></strong>
+------+
| val  |
+------+
| NULL |
| NULL |
|    3 |
|    9 |
|  100 |
+------+</pre><p>To put them at the end instead, without changing the order of
      other values, introduce an extra <code>ORDER</code> <code>BY</code>
      column that maps <code>NULL</code> values to a
      higher value than non-<code>NULL</code> values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT val FROM t ORDER BY IF(val IS NULL,1,0), val;</code></strong>
+------+
| val  |
+------+
|    3 |
|    9 |
|  100 |
| NULL |
| NULL |
+------+</pre><p>The <code>IF()</code> expression creates a
      new column for the sort that is used as the primary sort value.</p><p>For descending sorts, <code>NULL</code>
      values group at the end. To put them at the beginning instead, use the
      same technique, but reverse the second and third arguments of the
      <code>IF()</code> function to map <code>NULL</code> values to a lower value than non-<code>NULL</code> values:</p><pre data-type="programlisting">IF(val IS NULL,0,1)</pre><p>The same technique is useful for floating values other than
      <code>NULL</code> to either end of the sort order.
      Suppose that you want to sort <code>mail</code>
      table messages in sender/recipient order, but you want to put messages
      for a particular sender first. In the real world, the most <span class="keep-together">interesting</span> sender might be <code>postmaster</code> or <code>root</code>. Those names don’t appear in the table,
      so let’s use <code>phil</code> as the name of
      interest instead:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, dstuser, size</code></strong>
    -&gt; <strong><code>FROM mail</code></strong>
    -&gt; <strong><code>ORDER BY IF(srcuser='phil',0,1), srcuser, dstuser;</code></strong>
+---------------------+---------+---------+---------+
| t                   | srcuser | dstuser | size    |
+---------------------+---------+---------+---------+
| 2014-05-16 23:04:19 | phil    | barb    |   10294 |
| 2014-05-12 15:02:49 | phil    | phil    |    1048 |
| 2014-05-15 08:50:57 | phil    | phil    |     978 |
| 2014-05-14 11:52:17 | phil    | tricia  |    5781 |
| 2014-05-19 12:49:23 | phil    | tricia  |     873 |
| 2014-05-14 14:42:21 | barb    | barb    |   98151 |
| 2014-05-11 10:15:08 | barb    | tricia  |   58274 |
| 2014-05-12 18:59:18 | barb    | tricia  |     271 |
| 2014-05-14 09:31:37 | gene    | barb    |    2291 |
| 2014-05-16 09:00:28 | gene    | barb    |     613 |
| 2014-05-15 17:35:31 | gene    | gene    |    3856 |
| 2014-05-15 07:17:48 | gene    | gene    |    3824 |
| 2014-05-19 22:21:51 | gene    | gene    |   23992 |
| 2014-05-15 10:25:52 | gene    | tricia  |  998532 |
| 2014-05-12 12:48:13 | tricia  | gene    |  194925 |
| 2014-05-14 17:03:01 | tricia  | phil    | 2394482 |
+---------------------+---------+---------+---------+</pre><p>The value of the extra sort column is <code>0</code> for rows in which the <code>srcuser</code> value is <code>phil</code>, and <code>1</code>
      for all other rows. By making that the most significant sort column,
      rows for messages sent by <code>phil</code> float
      to the top of the output. (To sink them to the bottom instead, either
      sort the column in reverse order using <code>DESC</code>, or reverse the order of the second and
      third arguments of the <code>IF()</code>
      function.)</p><p>You can also use this technique for particular conditions, not
      only specific values. To put first those rows where people sent messages
      to themselves, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t, srcuser, dstuser, size</code></strong>
    -&gt; <strong><code>FROM mail</code></strong>
    -&gt; <strong><code>ORDER BY IF(srcuser=dstuser,0,1), srcuser, dstuser;</code></strong>
+---------------------+---------+---------+---------+
| t                   | srcuser | dstuser | size    |
+---------------------+---------+---------+---------+
| 2014-05-14 14:42:21 | barb    | barb    |   98151 |
| 2014-05-19 22:21:51 | gene    | gene    |   23992 |
| 2014-05-15 17:35:31 | gene    | gene    |    3856 |
| 2014-05-15 07:17:48 | gene    | gene    |    3824 |
| 2014-05-12 15:02:49 | phil    | phil    |    1048 |
...</pre><p>If you have a pretty good idea about the contents of your table,
      it’s sometimes possible to eliminate the extra sort column. For example,
      <code>srcuser</code> is never <code>NULL</code> in the <code>mail</code> table, so the previous query can be
      rewritten as follows to use one less column in the <code>ORDER</code> <code>BY</code>
      clause (this relies on the property that <code>NULL</code> values sort ahead of all non-<code>NULL</code>
      values):</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">t</code><code class="p">,</code> <code class="n">srcuser</code><code class="p">,</code> <code class="n">dstuser</code><code class="p">,</code> <code class="k">size</code>
<code class="k">FROM</code> <code class="n">mail</code>
<code class="k">ORDER</code> <code class="k">BY</code> <code class="n">IF</code><code class="p">(</code><code class="n">srcuser</code><code class="o">=</code><code class="n">dstuser</code><code class="p">,</code><code class="k">NULL</code><code class="p">,</code><code class="n">srcuser</code><code class="p">),</code> <code class="n">dstuser</code><code class="p">;</code></pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.12 Defining a Custom Sort Order"><div class="sect1" id="nch-sort-sort-user"><h1>9.12 Defining a Custom Sort Order</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369371744"><h2>Problem</h2><p>You want to sort values in a nonstandard order.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369370864"><h2>Solution</h2><p>Use <code>FIELD()</code> to map column
      values to a sequence that places the values in the desired
      order.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369369424"><h2>Discussion</h2><p><a data-type="xref" href="#nch-sort-sort-float">Recipe 9.11</a> shows how to make a
      specific group of rows float to the head of the sort order. To impose a
      specific order on <em>all</em> values in a column, use the
      <code>FIELD()</code> function to map them to a
      list of numeric values and use the numbers for sorting. <code>FIELD()</code> compares its first argument to the
      following arguments and returns an integer indicating which one it
      matches. (This works best when the column contains a small number of
      distinct values.)</p><p>The following <code>FIELD()</code> call
      compares <em><code>value</code></em> to
      <em><code>str1</code></em>, <em><code>str2</code></em>,
      <em><code>str3</code></em>, and <em><code>str4</code></em>,
      and returns 1, 2, 3, or 4, depending on which of them
      <em><code>value</code></em> is equal to:</p><pre data-type="programlisting">FIELD(<em><code>value</code></em>,<em><code>str1</code></em>,<em><code>str2</code></em>,<em><code>str3</code></em>,<em><code>str4</code></em>)</pre><p>If <em><code>value</code></em> is <code>NULL</code> or none of the values match, <code>FIELD()</code> returns 0.</p><p>You can use <code>FIELD()</code> to sort an arbitrary set of
      values into any order you please. For example, to display <code>driver_log</code> rows for Henry, Suzi, and Ben, in
      that order, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log</code></strong>
    -&gt; <strong><code>ORDER BY FIELD(name,'Henry','Suzi','Ben');</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|     10 | Henry | 2014-07-30 |   203 |
|      8 | Henry | 2014-08-01 |   197 |
|      6 | Henry | 2014-07-26 |   115 |
|      4 | Henry | 2014-07-27 |    96 |
|      3 | Henry | 2014-07-29 |   300 |
|      7 | Suzi  | 2014-08-02 |   502 |
|      2 | Suzi  | 2014-07-29 |   391 |
|      5 | Ben   | 2014-07-29 |   131 |
|      9 | Ben   | 2014-08-02 |    79 |
|      1 | Ben   | 2014-07-30 |   152 |
+--------+-------+------------+-------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="9.13 Sorting ENUM Values"><div class="sect1" id="nch-sort-sort-enum"><h1>9.13 Sorting ENUM Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820369326048"><h2>Problem</h2><p><code>ENUM</code> values don’t sort
      like other string columns, and you want them to retrieve results in the order you expect.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820369324656"><h2>Solution</h2><p>
        Study how <code>ENUM</code> stores data and use those properties to your advantage. You can, for example, define your own sort order for strings, stored in the <code>ENUM</code> column.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820369322704"><h2>Discussion</h2><p><code>ENUM</code> is a string data type, but
      <code>ENUM</code> values actually are stored
      numerically with values ordered the same way they are listed in the
      table definition. These numeric values affect how enumerations are
      sorted, which can be very useful. Suppose that a table named <code>weekday</code> contains an enumeration column named
      <code>day</code> that has weekday names as its
      members:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">weekday</code>
<code class="p">(</code>
  <code class="k">day</code> <code class="n">ENUM</code><code class="p">(</code><code class="s1">'Sunday'</code><code class="p">,</code><code class="s1">'Monday'</code><code class="p">,</code><code class="s1">'Tuesday'</code><code class="p">,</code><code class="s1">'Wednesday'</code><code class="p">,</code>
           <code class="s1">'Thursday'</code><code class="p">,</code><code class="s1">'Friday'</code><code class="p">,</code><code class="s1">'Saturday'</code><code class="p">)</code>
<code class="p">);</code></pre><p>Internally, MySQL defines the enumeration values <code>Sunday</code> through <code>Saturday</code> in that definition to have numeric
      values from 1 to 7. To see this for yourself, create the table using the
      definition just shown, and then insert into it a row for each day of the
      week. To make the insertion order differ from sorted order (so that you
      can see the effect of sorting), add the days in random order:</p><pre data-type="programlisting">mysql&gt; <strong><code>INSERT INTO weekday (day) VALUES('Monday'),('Friday'),</code></strong>
    -&gt; <strong><code>('Tuesday'), ('Sunday'), ('Thursday'), ('Saturday'), ('Wednesday');</code></strong></pre><p>Then select the values, both as strings and as the internal
      numeric value (obtain the latter using <code>+0</code> to force a string-to-number
      conversion):</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT day, day+0 FROM weekday;</code></strong>
+-----------+-------+
| day       | day+0 |
+-----------+-------+
| Monday    |     2 |
| Friday    |     6 |
| Tuesday   |     3 |
| Sunday    |     1 |
| Thursday  |     5 |
| Saturday  |     7 |
| Wednesday |     4 |
+-----------+-------+</pre><p>Notice that because the query includes no <code>ORDER</code> <code>BY</code>
      clause, the rows are returned in unsorted order. If you add an <code>ORDER</code> <code>BY</code>
      <code>day</code> clause, it becomes apparent that MySQL uses the internal numeric values for
      sorting:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT day, day+0 FROM weekday ORDER BY day;</code></strong>
+-----------+-------+
| day       | day+0 |
+-----------+-------+
| Sunday    |     1 |
| Monday    |     2 |
| Tuesday   |     3 |
| Wednesday |     4 |
| Thursday  |     5 |
| Friday    |     6 |
| Saturday  |     7 |
+-----------+-------+</pre><p>What about occasions when you want to sort <code>ENUM</code> values in lexical order? Force them to be
      treated as strings for sorting using the <code>CAST()</code>
      function:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT day, day+0 FROM weekday ORDER BY CAST(day AS CHAR);</code></strong>
+-----------+-------+
| day       | day+0 |
+-----------+-------+
| Friday    |     6 |
| Monday    |     2 |
| Saturday  |     7 |
| Sunday    |     1 |
| Thursday  |     5 |
| Tuesday   |     3 |
| Wednesday |     4 |
+-----------+-------+</pre><p>If you always (or nearly always) sort a non-enumeration column in
      a specific nonlexical order, consider changing the data type to <code>ENUM</code>, with its values listed in the desired
      sort order. To see how this works, create a <code>color</code> table containing a string column, and
      populate it with some sample rows:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE color (name CHAR(10), PRIMARY KEY(name));</code></strong>
mysql&gt; <strong><code>INSERT INTO color (name) VALUES ('blue'),('green'),</code></strong>
    -&gt; <strong><code>('indigo'),('orange'),('red'),('violet'),('yellow');</code></strong></pre><p>Sorting by the <code>name</code> column at
      this point produces lexical order because the column contains <code>CHAR</code>
      values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name FROM color ORDER BY name;</code></strong>
+--------+
| name   |
+--------+
| blue   |
| green  |
| indigo |
| orange |
| red    |
| violet |
| yellow |
+--------+</pre><p>Now suppose that you want to sort the column by the order in which
      colors occur in the rainbow. (This is <q>Roy G. Biv</q> order;
      successive letters of that name indicate the first letters of the
      corresponding color names.) One way to produce a rainbow sort is to use
      <code>FIELD()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name FROM color</code></strong>
    -&gt; <strong><code>ORDER BY</code></strong>
    -&gt; <strong><code>FIELD(name,'red','orange','yellow','green','blue','indigo','violet');</code></strong>
+--------+
| name   |
+--------+
| red    |
| orange |
| yellow |
| green  |
| blue   |
| indigo |
| violet |
+--------+</pre><p>To accomplish the same end without <code>FIELD()</code>, use <code>ALTER</code> <code>TABLE</code>
      to convert the <code>name</code> column to an
      <code>ENUM</code> that lists the colors in the
      desired sort order:</p><pre data-type="programlisting">mysql&gt; <strong><code>ALTER TABLE color</code></strong>
    -&gt; <strong><code>MODIFY name</code></strong>
    -&gt; <strong><code>ENUM('red','orange','yellow','green','blue','indigo','violet');</code></strong></pre><p>After converting the table, sorting on the <code>name</code> column produces rainbow sorting naturally
      with no special treatment:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name FROM color ORDER BY name;</code></strong>
+--------+
| name   |
+--------+
| red    |
| orange |
| yellow |
| green  |
| blue   |
| indigo |
| violet |
+--------+</pre><p>
        Note that once you switched to the <code>ENUM</code> data type you would not be able to insert any value that does not belong to list. If you need to change <code>ENUM</code> definition, for example, by adding new color, you will have to perform one more <code>ALTER</code> command.
      </p></div></section></div></section></div></section></div></body></html>