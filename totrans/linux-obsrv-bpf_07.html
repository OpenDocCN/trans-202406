<html><head></head><body><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Linux Networking and BPF"><div class="chapter" id="linux_networking">
<h1><span class="label">Chapter 6. </span>Linux Networking and BPF</h1>


<p>From a networking point of view, we use BPF programs for two main use cases:
packet capturing and filtering.<a data-type="indexterm" data-primary="networking (Linux) and BPF" id="ix_netLi"/></p>

<p>This means that a user-space program can attach a filter to any socket and extract information about packets flowing through it and allow/disallow/redirect certain kinds of packets as they are seen at that level.</p>

<p>The goal of this chapter is to explain how BPF programs can interact with the Socket Buffer structure at different stages of the network data path in the Linux kernel network stack. We are identifying, as common use cases two types of programs:</p>

<ul>
<li>
<p>Program types related to <em>sockets</em></p>
</li>
<li>
<p>Programs written for the BPF-based classifier for <em>Traffic Control</em></p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The Socket Buffer structure, also called SKB or <code>sk_buff</code>, is the one in the kernel that is created and used for every packet sent or received.<a data-type="indexterm" data-primary="Socket Buffer structure" id="idm46623553810376"/> By reading the SKB you can pass or drop packets and populate BPF maps to create statistics and flow metrics about the current traffic.<a data-type="indexterm" data-primary="sk_buff" data-see="Socket Buffer structure" id="idm46623553809400"/><a data-type="indexterm" data-primary="SKB" data-see="Socket Buffer structure" id="idm46623553808456"/></p>

<p>In addition some BPF programs allow you to manipulate the SKB and, by extension, transform the final packets in order to redirect them or change their fundamental structure. For example, on an IPv6-only system, you might write a program that converts all the received packets from IPv4 to IPv6, which can be accomplished by mangling with the packets’ SKB.</p>
</div>

<p>Understanding the differences between the different kinds of programs we can write and how different programs lead to the same goal is the key to understanding BPF and eBPF in networking; in the next section we look at the first two ways to do filtering at socket level: by using classic BPF filters, and by using eBPF programs attached to sockets.</p>






<section data-type="sect1" data-pdf-bookmark="BPF and Packet Filtering"><div class="sect1" id="idm46623553805720">
<h1>BPF and Packet Filtering</h1>

<p>As stated, BPF filters and eBPF programs are the principal use cases for BPF programs in the context of networking; however, originally, BPF programs were synonymous with packet filtering.<a data-type="indexterm" data-primary="filtering" data-secondary="BPF and packet filtering" id="ix_filBPFpkt"/><a data-type="indexterm" data-primary="packet filtering" id="ix_pktfil"/><a data-type="indexterm" data-primary="networking (Linux) and BPF" data-secondary="BPF and packet filtering" id="ix_netLipktfil"/></p>

<p>Packet filtering is still one of the most important use cases and has been expanded
from classic BPF (cBPF) to the modern eBPF in Linux 3.19 with the addition
of map-related functions to the filter<a data-type="indexterm" data-primary="cBPF (classic BPF)" id="idm46623553780776"/><a data-type="indexterm" data-primary="eBPF" data-secondary="packet filtering" id="idm46623553780072"/><a data-type="indexterm" data-primary="BPF_PROG_TYPE_SOCKET_FILTER type" id="idm46623553779128"/> program type <code>BPF_PROG_TYPE_SOCKET_FILTER</code>.</p>

<p>Filters can be used mainly in three high-level scenarios:</p>

<ul>
<li>
<p>Live traffic dropping (e.g., allowing only User Datagram Protocol [UDP] traffic and discarding anything else)</p>
</li>
<li>
<p>Live observation of a filtered set of packets flowing into a live system</p>
</li>
<li>
<p>Retrospective analysis of network traffic captured on a live system, using the <em>pcap format</em>, for example</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The term <em>pcap</em> comes from the <a data-type="indexterm" data-primary="pcap format" id="idm46623553772216"/>conjunction of two words: packet and capture. The pcap format is implemented as a domain-specific API for packet capturing <a data-type="indexterm" data-primary="Packet Capture Library (libpcap)" id="idm46623553771208"/><a data-type="indexterm" data-primary="libpcap (Packet Capture Library)" id="idm46623553770472"/>in a library called Packet Capture Library (<em>libpcap</em>). This format is useful in debugging scenarios when you want to save a set of packets that have been captured on a live system directly to a file to analyze them later using a tool that can read a stream of packets exported in the pcap format.</p>
</div>

<p>In the following sections we show two different ways to apply the concept of packet filtering with BPF programs. First we show how a common and widespread tool like <code>tcpdump</code> acts as a higher-level interface for BPF programs used as filters. Then we write and load our own program using the <code>BPF_PROG_TYPE_SOCKET_FILTER</code> BPF program type.</p>








<section data-type="sect2" data-pdf-bookmark="tcpdump and BPF Expressions"><div class="sect2" id="idm46623553767144">
<h2>tcpdump and BPF Expressions</h2>

<p>When talking about live traffic analysis and observation, one of the command-line tools that almost everyone knows about is <code>tcpdump</code>.<a data-type="indexterm" data-primary="networking (Linux) and BPF" data-secondary="BPF and packet filtering" data-tertiary="tcpdump and BPF expressions" id="ix_netLipktfiltcpd"/><a data-type="indexterm" data-primary="tcpdump and BPF expressions" id="ix_tcpdmp"/><a data-type="indexterm" data-primary="packet filtering" data-secondary="tcpdump and BPF expressions" id="ix_pktfiltcpdBPF"/> Essentially a frontend for <code>libpcap</code>, it allows the user to define high-level filtering expressions. What <code>tcpdump</code> does is read packets from a network interface of your choice (or any interface) and then writes the content of the packets it received to stdout or a file. The packet stream can then be filtered using the pcap filter syntax.<a data-type="indexterm" data-primary="pcap format" data-secondary="filter syntax" id="idm46623553759384"/> The pcap filter syntax is a DSL that is used to filter packets using a higher-level set of expressions made by a set of primitives that are generally easier to remember than BPF assembly. It’s out of the scope of this chapter to explain all the primitives and expressions possible in the pcap filter syntax because the entire set can be found in <code>man 7 pcap-filter</code>, but we do go through some examples so that you can understand its power.</p>

<p>The scenario is that we are in a Linux box that is exposing a web server on port 8080; this web server is not logging the requests it receives, and we really want to know whether it is receiving any request and how those requests are flowing into it because a customer of the served application is complaining about not being able to get any response while browsing the products page. At this point, we know only that the customer is connecting to one of our products pages using our web application served by that web server, and as almost always happens, we have no idea what could be the cause of that because end users generally don’t try to debug your services for you, and unfortunately we didn’t deploy any logging or error reporting strategy into this system, so we are completely blind while investigating the problem. Fortunately, there’s a tool that can come to our rescue! It is <code>tcpdump</code>, which can be told to filter only IPv4 packets flowing in our system that are using the Transmission Control Protocol (TCP) on port 8080.<a data-type="indexterm" data-primary="tcpdump and BPF expressions" data-secondary="tcpdump -n 'ip and tcp port 8080' command" id="idm46623553755752"/><a data-type="indexterm" data-primary="packet filtering" data-secondary="tcpdump and BPF expressions" data-tertiary="tcpdump -n 'ip and tcp port 8080' command" id="idm46623553754664"/> Therefore, we will be able to analyze the traffic of the web server and understand what are the faulty requests.</p>

<p>Here’s the command to conduct that filtering with <code>tcpdump</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># tcpdump -n 'ip and tcp port 8080'</code></pre>

<p>Let’s take a look at what’s happening in this command:</p>

<ul>
<li>
<p><code>-n</code> is there to tell <code>tcpdump</code> to not convert addresses to the respective names, we want to see the addresses for source and destination.</p>
</li>
<li>
<p><code>ip and tcp port 8080</code> is the pcap filter expression that <code>tcpdump</code> will use to filter your packets. <code>ip</code> means <code>IPv4</code>, <code>and</code> is a conjunction to express a more complex filter to allow adding more expressions to match, and then we specify that we are interested only in TCP packets coming from or to port 8080 using <code>tcp port 8080</code>. In this specific case a better filter would’ve been <code>tcp dst port 8080</code> because we are interested only in packets having as the destination port 8080 and not packets coming from it.</p>
</li>
</ul>

<p>The output of that will be something like this (without the redundant parts like complete TCP handshakes):</p>
<pre>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on wlp4s0, link-type EN10MB (Ethernet), capture size 262144 bytes
12:04:29.593703 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],
   seq 1:325, ack 1, win 343,
   options [nop,nop,TS val 25580829 ecr 595195678],
   length 324: HTTP: GET / HTTP/1.1
12:04:29.596073 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [.],
   seq 1:1449, ack 325, win 507,
   options [nop,nop,TS val 595195731 ecr 25580829],
   length 1448: HTTP: HTTP/1.1 200 OK
12:04:29.596139 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],
   seq 1449:2390, ack 325, win 507,
   options [nop,nop,TS val 595195731 ecr 25580829],
   length 941: HTTP
12:04:46.242924 IP 192.168.1.249.44206 &gt; 192.168.1.63.8080: Flags [P.],
   seq 660:996, ack 4779, win 388,
   options [nop,nop,TS val 25584934 ecr 595204802],
   length 336: HTTP: GET /api/products HTTP/1.1
12:04:46.243594 IP 192.168.1.63.8080 &gt; 192.168.1.249.44206: Flags [P.],
   seq 4779:4873, ack 996, win 503,
   options [nop,nop,TS val 595212378 ecr 25584934],
   length 94: HTTP: HTTP/1.1 500 Internal Server Error
12:04:46.329245 IP 192.168.1.249.44234 &gt; 192.168.1.63.8080: Flags [P.],
   seq 471:706, ack 4779, win 388,
   options [nop,nop,TS val 25585013 ecr 595205622],
   length 235: HTTP: GET /favicon.ico HTTP/1.1
12:04:46.331659 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [.],
   seq 4779:6227, ack 706, win 506,
   options [nop,nop,TS val 595212466 ecr 25585013],
   length 1448: HTTP: HTTP/1.1 200 OK
12:04:46.331739 IP 192.168.1.63.8080 &gt; 192.168.1.249.44234: Flags [P.],
   seq 6227:7168, ack 706, win 506,
   options [nop,nop,TS val 595212466 ecr 25585013],
   length 941: HTTP</pre>

<p>The situation is a lot clearer now! We have a bunch of requests going well, returning a <code>200 OK</code> status code, but there is also one with a <code>500 Internal Server Error</code> code on the <code>/api/products</code> endpoint. Our customer is right; we have a problem listing the products!</p>

<p>At this point, you might ask yourself, what does all this pcap filtering stuff and <code>tcpdump</code> have to do with BPF programs if they have their own syntax? Pcap filters on Linux are compiled to BPF programs!<a data-type="indexterm" data-primary="pcap format" data-secondary="pcap filters compiled to BPF programs" id="idm46623553740904"/> And because <code>tcpdump</code> uses pcap filters for the filtering, this means that every time you execute <code>tcpdump</code> using a filter, you are actually compiling and loading a BPF program to filter your packets. Fortunately,<a data-type="indexterm" data-primary="tcpdump and BPF expressions" data-secondary="dumping BPF instructions loaded for specified filter" id="idm46623553738824"/> by passing the <code>-d</code> flag to <code>tcpdump</code>, you can dump the BPF instructions that it will load while using the specified filter:</p>
<pre>tcpdump  -d  'ip and tcp port 8080'</pre>

<p>The filter is the same as the one used in the previous example, but the output now is a set of BPF assembly instructions because of the <code>-d</code> flag.</p>

<p>Here’s the output:</p>

<pre data-type="programlisting" data-code-language="dasm16">(000) ldh      [12]
(001) jeq      #0x800           jt 2    jf 12
(002) ldb      [23]
(003) jeq      #0x6             jt 4    jf 12
(004) ldh      [20]
(005) jset     #0x1fff          jt 12   jf 6
(006) ldxb     4*([14]&amp;0xf)
(007) ldh      [x + 14]
(008) jeq      #0x1f90          jt 11   jf 9
(009) ldh      [x + 16]
(010) jeq      #0x1f90          jt 11   jf 12
(011) ret      #262144
(012) ret      #0</pre>

<p>Let’s analyze it:</p>
<dl>
<dt><code>ldh [12]</code></dt>
<dd>
<p>(<code>ld</code>) Load a (<code>h</code>) half-word (<code>16</code> bit) from the accumulator at offset 12, which is the Ethertype field, as shown in <a data-type="xref" href="#ethernet-II-frame-offsets">Figure 6-1</a>.</p>
</dd>
<dt><code>jeq #0x800 jt 2 jf 12</code></dt>
<dd>
<p>(<code>j</code>) Jump if (<code>eq</code>) equal; check whether the Ethertype value from the previous instruction is equal to <code>0x800</code>—which is the identifier for IPv4—and then use the jump destinations that are <code>2</code> if true (<code>jt</code>) and <code>12</code> if false (<code>jf</code>), so this will continue to the next instruction if the Internet Protocol is IPv4—otherwise it will jump to the end and return zero.</p>
</dd>
<dt><code>ldb [23]</code></dt>
<dd>
<p>Load byte into (<code>ldb</code>), will load the higher-layer protocol field from the IP frame that can be found at offset <code>23</code>—offset <code>23</code> comes from the addition of the 14 bytes of the headers in the Ethernet Layer 2 frame (see <a data-type="xref" href="#ethernet-II-frame-offsets">Figure 6-1</a>) plus the position the protocol has in the IPv4 header, which is the 9th, so 14 + 9 = 23.</p>
</dd>
<dt><code>jeq #0x6 jt 4 jf 12</code></dt>
<dd>
<p>Again a jump if equal. In this case, we check that the previous extracted protocol is <code>0</code> x <code>6</code>, which is TCP. If it is, we jump to the next instruction (<code>4</code>) or we go to the end (<code>12</code>)—if it is not, we drop the packet.</p>
</dd>
<dt><code>ldh [20]</code></dt>
<dd>
<p>This is another load half-word instruction—in this case, it is to load the value of packet offset + fragment offset from the IPv4 header.</p>
</dd>
<dt><code>jset #0x1fff jt 12 6</code></dt>
<dd>
<p>This <code>jset</code> instruction will jump to <code>12</code> if any of the data we found in the fragment offset is true—otherwise, go to <code>6</code>, which is the next instruction. The offset after the instruction <code>0x1fff</code> says to the <code>jset</code> instruction to look only at the last 13 bytes of data. (Expanded it becomes <code>0001 1111 1111 1111</code>.)</p>
</dd>
<dt><code>ldxb 4*([14]&amp;0xf)</code></dt>
<dd>
<p>(<code>ld</code>) Load into x (<code>x</code>) what (<code>b</code>) is. This instruction will load the value of the IP header length into <code>x</code>.</p>
</dd>
<dt><code>ldh [x + 14]</code></dt>
<dd>
<p>Another load half-word instruction that will go get the value at offset (<code>x</code> + <code>14</code>), IP header length + 14, which is the location of the source port within the packet.</p>
</dd>
<dt><code>jeq #0x1f90 jt 11 jf 9</code></dt>
<dd>
<p>If the value at (<code>x</code> + <code>14</code>) is equal to <code>0x1f90</code> (<code>8080</code> in decimal), which means that the source port will be <code>8080</code>, continue to <code>11</code> or go check whether the destination is on port <code>8080</code> by continuing to <code>9</code> if this is false.</p>
</dd>
<dt><code>ldh [x + 16]</code></dt>
<dd>
<p>This is another load half-word instruction that will go get the value at offset (<code>x</code> + <code>16</code>), which is the location of destination port in the packet.</p>
</dd>
<dt><code>jeq #0x1f90 jt 11 jf 12</code></dt>
<dd>
<p>Here’s another jump if equal, this time used to check if the destination is <code>8080</code>, go to <code>11</code>; if not, go to <code>12</code> and discard the packet.</p>
</dd>
<dt><code>ret #262144</code></dt>
<dd>
<p>When this instruction is reached, a match is found—thus return the matched snap length. By default this value is 262,144 bytes. It can be tuned using the <code>-s</code> parameter in <code>tcpdump</code>.</p>
</dd>
</dl>

<figure><div id="ethernet-II-frame-offsets" class="figure">
<img src="assets/lbpf_0601.png" alt="Diagram showing the Layer 2 Ethernet frame structure and the respective lengths"/>
<h6><span class="label">Figure 6-1. </span>Layer 2 Ethernet frame structure</h6>
</div></figure>

<p>Here’s the “correct” example because, as we said in the case of our web server, we only need to take into account the packet having 8080 as a destination, not as a source, so the <code>tcpdump</code> filter can specify it with the <code>dst</code> destination field:<a data-type="indexterm" data-primary="tcpdump and BPF expressions" data-secondary="tcpdump -d 'ip and tcp dst port 8080'" id="idm46623553667560"/></p>

<pre data-type="programlisting" data-code-language="bash">tcpdump -d <code class="s1">'ip and tcp dst port 8080'</code></pre>

<p>In this case, the dumped set of instructions is similar to the previous example, but as you can see, it lacks the entire part about matching the packets with a source of port 8080. In fact, there’s no <code>ldh [x + 14]</code> and the relative <code>jeq #0x1f90 jt 11 jf 9</code>.</p>
<pre>(000) ldh      [12]
(001) jeq      #0x800           jt 2    jf 10
(002) ldb      [23]
(003) jeq      #0x6             jt 4    jf 10
(004) ldh      [20]
(005) jset     #0x1fff          jt 10   jf 6
(006) ldxb     4*([14]&amp;0xf)
(007) ldh      [x + 16]
(008) jeq      #0x1f90          jt 9    jf 10
(009) ret      #262144
(010) ret      #0</pre>

<p>Besides just analyzing the generated assembly from <code>tcpdump</code>, as we did, you might want to write your own code to filter network packets. It turns out that the biggest challenge in that case would be to actually debug the execution of the code to make sure it matches our expectations; in this case, in the kernel source tree, there’s a tool in <code>tools/bpf</code> called <code>bpf_dbg.c</code> that is essentially a debugger that allows you to load a program and a pcap file to test the execution step by step.<a data-type="indexterm" data-primary="bpf_dbg.c tool" id="idm46623553663304"/><a data-type="indexterm" data-primary="debuggers" data-secondary="bpf_dbg.c tool" id="idm46623553662600"/></p>
<div data-type="tip"><h6>Tip</h6>
<p><code>tcpdump</code> can also read directly from a <code>.pcap</code> file and apply BPF filters to it.<a data-type="indexterm" data-primary="pcap format" data-secondary="tcpdump reading directly from .pcap file and applying BPF filters to it" id="idm46623553658648"/><a data-type="indexterm" data-primary="networking (Linux) and BPF" data-secondary="BPF and packet filtering" data-tertiary="tcpdump and BPF expressions" data-startref="ix_netLipktfiltcpd" id="idm46623553657704"/><a data-type="indexterm" data-primary="tcpdump and BPF expressions" data-startref="ix_tcpdmp" id="idm46623553656216"/><a data-type="indexterm" data-primary="packet filtering" data-secondary="tcpdump and BPF expressions" data-startref="ix_pktfiltcpdBPF" id="idm46623553655256"/></p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Packet Filtering for Raw Sockets"><div class="sect2" id="idm46623553766200">
<h2>Packet Filtering for Raw Sockets</h2>

<p>The <code>BPF_PROG_TYPE_SOCKET_FILTER</code> program type allows you to attach the BPF program to a socket.<a data-type="indexterm" data-primary="sockets" data-secondary="packet filtering for raw sockets, BPF_PROG_TYPE_SOCKET_FILTER" id="ix_scktpktfil"/><a data-type="indexterm" data-primary="BPF_PROG_TYPE_SOCKET_FILTER type" id="ix_BPFprogsktfil"/><a data-type="indexterm" data-primary="packet filtering" data-secondary="for raw sockets, BPF_PROG_TYPE_SOCKET_FILTER" id="ix_pktfilrawsck"/> All of the packets received by it will be passed to the program in the form of an <code>sk_buff</code> struct, and then the program can decide whether to discard or allow them. This kind of programs also has the ability to access and work on maps.</p>

<p>Let’s look at an example to see how this kind of BPF program can be used.</p>

<p>The purpose of our example program is to count the number of TCP, UDP, and Internet Control Message Protocol (ICMP) packets flowing in the interface under observation. To do that, we need the <span class="keep-together">following</span>:</p>

<ul>
<li>
<p>The BPF program that can see the packets flowing</p>
</li>
<li>
<p>The code to load the program and attach it to a network interface</p>
</li>
<li>
<p>A script to compile the program and launch the loader</p>
</li>
</ul>

<p>At this point, we can write our BPF program in two ways: as C code that is then compiled to an <em>ELF</em> file, or directly as a BPF assembly. For this example, we opted to use C code to show a higher-level abstraction and how to use Clang to compile the program. It’s important to note that to make this program, we are using headers and helpers available only in the Linux kernel’s source tree, so the first thing to do is to obtain a copy of it using Git. To avoid differences, you can check out the same commit SHA we’ve used to make this example:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">export </code><code class="nv">KERNEL_SRCTREE</code><code class="o">=</code>/tmp/linux-stable
git clone  git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
  <code class="nv">$KERNEL_SRCTREE</code>
<code class="nb">cd</code> <code class="nv">$KERNEL_SRCTREE</code>
git checkout 4b3c31c8d4dda4d70f3f24a165f3be99499e0328</pre>
<div data-type="tip"><h6>Tip</h6>
<p>To contain BPF support, you will need <code>clang &gt;= 3.4.0</code> with <code>llvm &gt;= 3.7.1</code>. To verify BPF support in your installation, you can use the command <code>llc -version</code> and look to see whether it has the BPF target.</p>
</div>

<p>Now that you understand socket filtering, we can get our hands on a BPF program of type <code>socket</code>.</p>










<section data-type="sect3" data-pdf-bookmark="The BPF program"><div class="sect3" id="idm46623553612152">
<h3>The BPF program</h3>

<p>The main duty of the BPF program here is to access the packet it receives; check whether its protocol is TCP, UDP, or ICMP, and then increment the counter on the map array on the specific key for the found protocol.<a data-type="indexterm" data-primary="packet filtering" data-secondary="for raw sockets, BPF_PROG_TYPE_SOCKET_FILTER" data-tertiary="BPF program" id="idm46623553610168"/></p>

<p>For this program we are going to take advantage of the loading mechanism that parses <em>ELF</em> files using the helpers located in <em>samples/bpf/bpf_load.c</em> in the kernel source tree.<a data-type="indexterm" data-primary="load_bpf_file function" id="idm46623553604216"/><a data-type="indexterm" data-primary="ELF (Executable and Linkable Format)" data-secondary="association of ELF section headers to program types" id="idm46623553603512"/> The load function <code>load_bpf_file</code> is able to recognize some specific ELF section headers and can associate them to the respective program types. Here’s how that code looks:</p>

<pre data-type="programlisting" data-code-language="c">	<code class="kt">bool</code> <code class="n">is_socket</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"socket"</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_kprobe</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"kprobe/"</code><code class="p">,</code> <code class="mi">7</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_kretprobe</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"kretprobe/"</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_tracepoint</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"tracepoint/"</code><code class="p">,</code> <code class="mi">11</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_raw_tracepoint</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"raw_tracepoint/"</code><code class="p">,</code> <code class="mi">15</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_xdp</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"xdp"</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_perf_event</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"perf_event"</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_cgroup_skb</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"cgroup/skb"</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_cgroup_sk</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"cgroup/sock"</code><code class="p">,</code> <code class="mi">11</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_sockops</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"sockops"</code><code class="p">,</code> <code class="mi">7</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_sk_skb</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"sk_skb"</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
	<code class="kt">bool</code> <code class="n">is_sk_msg</code> <code class="o">=</code> <code class="n">strncmp</code><code class="p">(</code><code class="n">event</code><code class="p">,</code> <code class="s">"sk_msg"</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code></pre>

<p>The first thing that the code does is to create an association between the section header and an internal variable—like for <code>SEC("socket")</code>, we will end up with <code>bool is_socket=true</code>.</p>

<p>Later in the same file, we see a set of <code>if</code> instructions that create the association between the header and the actual <code>prog_type</code> <a data-type="indexterm" data-primary="sockets" data-secondary="program types related to" id="idm46623553407272"/>, so for <code>is_socket</code>, we end up with <code>BPF_PROG_TYPE_SOCKET_FILTER</code>:</p>

<pre data-type="programlisting" data-code-language="c">	<code class="k">if</code> <code class="p">(</code><code class="n">is_socket</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_SOCKET_FILTER</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_kprobe</code> <code class="o">||</code> <code class="n">is_kretprobe</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_KPROBE</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_tracepoint</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_TRACEPOINT</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_raw_tracepoint</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_RAW_TRACEPOINT</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_xdp</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_XDP</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_perf_event</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_PERF_EVENT</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_cgroup_skb</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_CGROUP_SKB</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_cgroup_sk</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_CGROUP_SOCK</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_sockops</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_SOCK_OPS</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_sk_skb</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_SK_SKB</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="n">is_sk_msg</code><code class="p">)</code> <code class="p">{</code>
		<code class="n">prog_type</code> <code class="o">=</code> <code class="n">BPF_PROG_TYPE_SK_MSG</code><code class="p">;</code>
	<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
		<code class="n">printf</code><code class="p">(</code><code class="s">"Unknown event '%s'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">event</code><code class="p">);</code>
		<code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
	<code class="p">}</code></pre>

<p>Good, so because we want to write a <code>BPF_PROG_TYPE_SOCKET_FILTER</code> program, we need to specify a <code>SEC("socket")</code> as an ELF header to our function that will act as an entry point for our BPF program.<a data-type="indexterm" data-primary="SEC(&quot;socket&quot;) as ELF header" id="idm46623553402712"/></p>

<p>As you can see by that list, there are a variety of program types related to sockets and in general network operations.<a data-type="indexterm" data-primary="XDP programs" data-secondary="BPF_PROG_TYPE_XDP" id="idm46623553151096"/> In this chapter we are showing examples with <code>BPF_PROG_TYPE_SOCKET_FILTER</code>; however, you can find a definition of all the other program types in <a data-type="xref" href="ch02.html#running_your_first_BPF_programs">Chapter 2</a>. Moreover, in <a data-type="xref" href="ch07.html#express_data_path_XDP">Chapter 7</a> we discuss XDP programs with the program type <code>BPF_PROG_TYPE_XDP</code>.</p>

<p>Because we want to store the count of packets for every protocol we encounter, we need to create a key/value map where the protocol is key and the packets count as value. For that purpose, we can use a <code>BPF_MAP_TYPE_ARRAY</code><a data-type="indexterm" data-primary="BPF_MAP_TYPE_ARRAY" id="idm46623553146680"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="holding key/value pair of form &lt;protocol, count of packets&gt;" id="idm46623553145976"/><a data-type="indexterm" data-primary="array maps" id="idm46623553145064"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="holding" id="idm46623553144392"/>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">countmap</code> <code class="o">=</code> <code class="p">{</code>
    <code class="p">.</code><code class="n">type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_ARRAY</code><code class="p">,</code>
    <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
    <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
    <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">256</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>The map is defined using the <code>bpf_map_def</code> struct, and<a data-type="indexterm" data-primary="bpf_map_def struct" id="idm46623553026600"/> it will be named <code>countmap</code> for reference in the program.</p>

<p>At this point, we can write some code to actually count the packets. We know that programs of type <code>BPF_PROG_TYPE_SOCKET_FILTER</code> are one of our options because by using such a program, we can see all the packets flowing through an interface. Therefore we attach the program to the right header with <code>SEC("socket")</code>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">SEC</code><code class="p">(</code><code class="s">"socket"</code><code class="p">)</code>
<code class="kt">int</code> <code class="n">socket_prog</code><code class="p">(</code><code class="k">struct</code> <code class="n">__sk_buff</code> <code class="o">*</code><code class="n">skb</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">proto</code> <code class="o">=</code> <code class="n">load_byte</code><code class="p">(</code><code class="n">skb</code><code class="p">,</code> <code class="n">ETH_HLEN</code> <code class="o">+</code> <code class="n">offsetof</code><code class="p">(</code><code class="k">struct</code> <code class="n">iphdr</code><code class="p">,</code> <code class="n">protocol</code><code class="p">));</code>
  <code class="kt">int</code> <code class="n">one</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
  <code class="kt">int</code> <code class="o">*</code><code class="n">el</code> <code class="o">=</code> <code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">countmap</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">proto</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">el</code><code class="p">)</code> <code class="p">{</code>
    <code class="p">(</code><code class="o">*</code><code class="n">el</code><code class="p">)</code><code class="o">++</code><code class="p">;</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="n">el</code> <code class="o">=</code> <code class="o">&amp;</code><code class="n">one</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">countmap</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">proto</code><code class="p">,</code> <code class="n">el</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code>
  <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>After the ELF header attachment we can use the <code>load_byte</code> function to extract the protocol section from the <code>sk_buff</code> struct.<a data-type="indexterm" data-primary="Socket Buffer structure" data-secondary="extracting protocol section from sk_buff" id="idm46623552956088"/><a data-type="indexterm" data-primary="bpf_map_lookup_elem helper function" id="idm46623552955192"/> Then we use the protocol ID as a key to do a <code>bpf_map_lookup_elem</code> operation to extract the current counter value from our <code>countmap</code> so that we can increment it or set it to 1 if it is the first packet ever.<a data-type="indexterm" data-primary="bpf_map_update_elem function" id="idm46623552953624"/> Now we can update the map with the incremented value using <code>bpf_map_update_elem</code>.</p>

<p>To compile the program to an <em>ELF</em> file, we just use Clang with <code>-target bpf</code>. This<a data-type="indexterm" data-primary="clang utility" data-secondary="-target bpf option" id="idm46623552951288"/> command creates a <code>bpf_program.o</code> file that we will load using the loader:</p>

<pre data-type="programlisting" data-code-language="sh">clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Load and attach to a network interface"><div class="sect3" id="idm46623553611496">
<h3>Load and attach to a network interface</h3>

<p>The loader is the program that actually opens our compiled BPF ELF binary <code>bpf_program.o</code> and attaches the defined BPF program and its maps to a socket that is created against the interface under observation, in our case <code>lo</code>, the loopback interface.<a data-type="indexterm" data-primary="loopback interface, attaching BPF program to" id="idm46623552945656"/><a data-type="indexterm" data-primary="loader programs" id="idm46623552943304"/><a data-type="indexterm" data-primary="packet filtering" data-secondary="for raw sockets, BPF_PROG_TYPE_SOCKET_FILTER" data-tertiary="loading and attaching to network interface" id="idm46623552942664"/></p>

<p>The most <a data-type="indexterm" data-primary="ELF (Executable and Linkable Format)" data-secondary="loader loading compiled BPF ELF binary file" id="idm46623552940936"/>important part of the loader is the actual loading of the <em>ELF</em> file:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="k">if</code> <code class="p">(</code><code class="n">load_bpf_file</code><code class="p">(</code><code class="n">filename</code><code class="p">))</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"%s"</code><code class="p">,</code> <code class="n">bpf_log_buf</code><code class="p">);</code>
    <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">sock</code> <code class="o">=</code> <code class="n">open_raw_sock</code><code class="p">(</code><code class="s">"lo"</code><code class="p">);</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">setsockopt</code><code class="p">(</code><code class="n">sock</code><code class="p">,</code> <code class="n">SOL_SOCKET</code><code class="p">,</code> <code class="n">SO_ATTACH_BPF</code><code class="p">,</code> <code class="n">prog_fd</code><code class="p">,</code>
                 <code class="k">sizeof</code><code class="p">(</code><code class="n">prog_fd</code><code class="p">[</code><code class="mi">0</code><code class="p">])))</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"setsockopt %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code>
    <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
  <code class="p">}</code></pre>

<p>This will populate the <code>prog_fd</code> array by adding one element that is the file descriptor of our loaded program that we can now attach to the socket descriptor of our loopback interface <code>lo</code> opened with <code>open_raw_sock</code>.</p>

<p>The attach is done by setting the option <code>SO_ATTACH_BPF</code> to the raw socket opened for the interface.</p>

<p>At this point our user-space loader is able to look up map elements while the kernel sends them:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">key</code> <code class="o">=</code> <code class="n">IPPROTO_TCP</code><code class="p">;</code>
    <code class="n">assert</code><code class="p">(</code><code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="n">map_fd</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">tcp_cnt</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">);</code>

    <code class="n">key</code> <code class="o">=</code> <code class="n">IPPROTO_UDP</code><code class="p">;</code>
    <code class="n">assert</code><code class="p">(</code><code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="n">map_fd</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">udp_cnt</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">);</code>

    <code class="n">key</code> <code class="o">=</code> <code class="n">IPPROTO_ICMP</code><code class="p">;</code>
    <code class="n">assert</code><code class="p">(</code><code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="n">map_fd</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">icmp_cnt</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">);</code>

    <code class="n">printf</code><code class="p">(</code><code class="s">"TCP %d UDP %d ICMP %d packets</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">tcp_cnt</code><code class="p">,</code> <code class="n">udp_cnt</code><code class="p">,</code> <code class="n">icmp_cnt</code><code class="p">);</code>
    <code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
  <code class="p">}</code></pre>

<p>To do the lookup, we attach to <a data-type="indexterm" data-primary="array maps" data-secondary="attaching to and looking up elements" id="idm46623552837000"/>the array map using a <code>for</code> loop and <code>bpf_map_lookup_elem</code> so that we can read and print the values for the TCP, UDP, and ICMP packet counters, respectively.</p>

<p>The only thing left is to compile the program!</p>

<p>Because <a data-type="indexterm" data-primary="libbpf" id="idm46623552697800"/>this program is using <em>libbpf</em>, we need to compile it from the kernel source tree
we just cloned:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code><code class="nb">cd</code> <code class="nv">$KERNEL_SRCTREE</code>/tools/lib/bpf
<code class="nv">$ </code>make</pre>

<p>Now that we have <em>libbpf</em>, we can <a data-type="indexterm" data-primary="compilation" data-secondary="compiling loader program using a script" id="idm46623552693192"/>compile the loader using this script:</p>

<pre data-type="programlisting" data-code-language="sh"><code class="nv">KERNEL_SRCTREE</code><code class="o">=</code><code class="nv">$1</code>
<code class="nv">LIBBPF</code><code class="o">=</code><code class="si">${</code><code class="nv">KERNEL_SRCTREE</code><code class="si">}</code>/tools/lib/bpf/libbpf.a
clang -o loader-bin -I<code class="si">${</code><code class="nv">KERNEL_SRCTREE</code><code class="si">}</code>/tools/lib/bpf/ <code class="se">\</code>
  -I<code class="si">${</code><code class="nv">KERNEL_SRCTREE</code><code class="si">}</code>/tools/lib -I<code class="si">${</code><code class="nv">KERNEL_SRCTREE</code><code class="si">}</code>/tools/include <code class="se">\</code>
  -I<code class="si">${</code><code class="nv">KERNEL_SRCTREE</code><code class="si">}</code>/tools/perf -I<code class="si">${</code><code class="nv">KERNEL_SRCTREE</code><code class="si">}</code>/samples <code class="se">\</code>
  <code class="si">${</code><code class="nv">KERNEL_SRCTREE</code><code class="si">}</code>/samples/bpf/bpf_load.c <code class="se">\</code>
  loader.c <code class="s2">"</code><code class="si">${</code><code class="nv">LIBBPF</code><code class="si">}</code><code class="s2">"</code> -lelf</pre>

<p>As you can see, the script includes a bunch of headers and the <em>libbpf</em> library from
the kernel itself, so it must know where to find the kernel source code. To do that, you can replace <code>$KERNEL_SRCTREE</code> in it or just write that script into a file and use it:</p>

<pre data-type="programlisting" data-code-language="sh"><code class="nv">$ </code>./build-loader.sh /tmp/linux-stable</pre>

<p>At this point the loader will have created a <code>loader-bin</code> file that can be finally
started along with the BPF program’s <em>ELF</em> file (requires root privileges):</p>

<pre data-type="programlisting" data-code-language="sh"><code class="c"># ./loader-bin bpf_program.o</code></pre>

<p>After the program is loaded and started it will do 10 dumps, one every second showing the packet count for each one of the three considered protocols. Because the program is attached to the loopback device <code>lo</code>, along with the loader you can run <code>ping</code> and see the ICMP counter increasing.<a data-type="indexterm" data-primary="ping, running to generate ICMP traffic to localhost" id="idm46623552517240"/></p>

<p>So run <code>ping</code> to generate ICMP traffic to localhost:</p>

<pre data-type="programlisting" data-code-language="sh"><code class="nv">$ </code>ping -c <code class="m">100</code> 127.0.0.1</pre>

<p>This starts pinging localhost 100 times and outputs something like this:</p>
<pre>PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.100 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.107 ms
64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.093 ms
64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.102 ms
64 bytes from 127.0.0.1: icmp_seq=5 ttl=64 time=0.105 ms
64 bytes from 127.0.0.1: icmp_seq=6 ttl=64 time=0.093 ms
64 bytes from 127.0.0.1: icmp_seq=7 ttl=64 time=0.104 ms
64 bytes from 127.0.0.1: icmp_seq=8 ttl=64 time=0.142 ms</pre>

<p>Then, in another terminal, we can finally run our BPF program:</p>

<pre data-type="programlisting" data-code-language="sh"><code class="c"># ./loader-bin bpf_program.o</code></pre>

<p>It begins dumping out  the following:</p>
<pre>TCP 0 UDP 0 ICMP 0 packets
TCP 0 UDP 0 ICMP 4 packets
TCP 0 UDP 0 ICMP 8 packets
TCP 0 UDP 0 ICMP 12 packets
TCP 0 UDP 0 ICMP 16 packets
TCP 0 UDP 0 ICMP 20 packets
TCP 0 UDP 0 ICMP 24 packets
TCP 0 UDP 0 ICMP 28 packets
TCP 0 UDP 0 ICMP 32 packets
TCP 0 UDP 0 ICMP 36 packets</pre>

<p>At this point, you already know a good amount of what is needed to filter packets on Linux using a socket filter eBPF program. Here’s some big news: that’s not the only way! You might want to instrument the packet scheduling subsystem in place by using the kernel instead of on sockets directly. Just read the next section to learn how.<a data-type="indexterm" data-primary="sockets" data-secondary="packet filtering for raw sockets, BPF_PROG_TYPE_SOCKET_FILTER" data-startref="ix_scktpktfil" id="idm46623552471192"/><a data-type="indexterm" data-primary="BPF_PROG_TYPE_SOCKET_FILTER type" data-startref="ix_BPFprogsktfil" id="idm46623552470072"/><a data-type="indexterm" data-primary="packet filtering" data-secondary="for raw sockets, BPF_PROG_TYPE_SOCKET_FILTER" data-startref="ix_pktfilrawsck" id="idm46623552562904"/><a data-type="indexterm" data-primary="filtering" data-secondary="BPF and packet filtering" data-startref="ix_filBPFpkt" id="idm46623552561656"/><a data-type="indexterm" data-primary="packet filtering" data-startref="ix_pktfil" id="idm46623552560472"/><a data-type="indexterm" data-primary="networking (Linux) and BPF" data-secondary="BPF and packet filtering" data-startref="ix_netLipktfil" id="idm46623552559528"/></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="BPF-Based Traffic Control Classifier"><div class="sect1" id="idm46623553653640">
<h1>BPF-Based Traffic Control Classifier</h1>

<p>Traffic Control is the kernel packet scheduling subsystem architecture. It is made of mechanisms and queuing systems that can decide how packets flow and how they are accepted.<a data-type="indexterm" data-primary="TC" data-see="Traffic Control, BPF-based classifier" id="idm46623552554120"/><a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" id="ix_TrCtl"/><a data-type="indexterm" data-primary="networking (Linux) and BPF" data-secondary="BPF-based Traffic Control classifier" id="ix_netLiTCclass"/></p>

<p>Some use cases for Traffic Control include, but are <a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="Traffic Control use cases" id="idm46623552550536"/>not limited to, the following:</p>

<ul>
<li>
<p>Prioritize certain kinds of packets</p>
</li>
<li>
<p>Drop specific kind of packet</p>
</li>
<li>
<p>Bandwidth distribution</p>
</li>
</ul>

<p>Given that in general Traffic Control is the way to go when you need to redistribute network resources in a system, to get the best out of it, specific Traffic Control configurations should be deployed based on the kind of applications that you want to run.<a data-type="indexterm" data-primary="cls_bpf" id="idm46623552494840"/> Traffic Control provides a programmable classifier, called <code>cls_bpf</code>, to let the hook into different levels of the scheduling operations where they can read and update socket buffer and packet metadata to do things like traffic shaping, tracing, preprocessing, and more.</p>

<p>Support for eBPF in <code>cls_bpf</code> was implemented in kernel 4.1, which means that this kind of program has access to eBPF maps, has tail call support, can access IPv4/IPv6 tunnel metadata, and in general use helpers and utilities coming with eBPF.<a data-type="indexterm" data-primary="eBPF" data-secondary="support in cls_bpf" id="idm46623552492312"/></p>

<p>The tooling used to interact with networking configuration related to Traffic Control is part of the <a href="https://oreil.ly/SYGwI">iproute2</a> suite, which contains <code>ip</code> and <code>tc</code>, which are used to manipulate network interfaces and traffic control configuration, <span class="keep-together">respectively</span>.<a data-type="indexterm" data-primary="iproute2 toolkit" id="idm46623552451672"/></p>

<p>At this point, learning Traffic Control can be difficult without the proper reference in terms of terminology. The following section can help.</p>








<section data-type="sect2" data-pdf-bookmark="Terminology"><div class="sect2" id="idm46623552450360">
<h2>Terminology</h2>

<p>As mentioned, there are interaction points between Traffic Control and BPF programs, so you need to understand some Traffic Control concepts.<a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="Traffic Control concepts" id="idm46623552448696"/> If you have already mastered Traffic Control, feel free to skip this terminology section and go straight to the examples.</p>










<section data-type="sect3" data-pdf-bookmark="Queueing disciplines"><div class="sect3" id="idm46623552447336">
<h3>Queueing disciplines</h3>

<p>Queuing disciplines (qdisc) define the scheduling objects used to enqueue packets<a data-type="indexterm" data-primary="queueing disciplines (qdisc)" id="idm46623552445704"/><a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="Traffic Control concepts" data-tertiary="queueing disciplines (qdisc)" id="idm46623552444984"/> going to an interface by changing the way they are sent; those objects can be classless or <span class="keep-together">classful</span>.</p>

<p>The default qdisc is <code>pfifo_fast</code>, which is classless <a data-type="indexterm" data-primary="pfifo_fast qdisc" id="idm46623552441704"/><a data-type="indexterm" data-primary="qdisc" data-see="queueing disciplines" id="idm46623552440968"/>and enqueues packets on three FIFO (first in first out) queues that are dequeued based on their priority; this qdisc is not used for virtual devices like the loopback (<code>lo</code>) or Virtual Ethernet devices (<code>veth</code>) that use <code>noqueue</code> instead. Besides being a good default for its scheduling algorithm, <code>pfifo_fast</code> also doesn’t require any configuration to work.<a data-type="indexterm" data-primary="noqueue qdisc" id="idm46623552437976"/></p>

<p>Virtual interfaces can be distinguished from<a data-type="indexterm" data-primary="virtual interfaces, distinguishing from physical interfaces" id="idm46623552436952"/><a data-type="indexterm" data-primary="physical interfaces, distinguishing from virtual interfaces" id="idm46623552436280"/> physical interfaces (devices) by asking the <em>/sys</em> pseudo<a data-type="indexterm" data-primary="/sys pseudo filesystem" data-primary-sortas="sys pseudo" id="idm46623552435064"/> filesystem:</p>
<pre>ls -la /sys/class/net
total 0
drwxr-xr-x  2 root root 0 Feb 13 21:52 .
drwxr-xr-x 64 root root 0 Feb 13 18:38 ..
lrwxrwxrwx  1 root root 0 Feb 13 23:26 docker0 -&gt;
../../devices/virtual/net/docker0
lrwxrwxrwx  1 root root 0 Feb 13 23:26 enp0s31f6 -&gt;
../../devices/pci0000:00/0000:00:1f.6/net/enp0s31f6
lrwxrwxrwx  1 root root 0 Feb 13 23:26 lo -&gt; ../../devices/virtual/net/lo</pre>

<p>At this point, some confusion is normal. If you’ve never heard about qdiscs, one thing you can do<a data-type="indexterm" data-primary="ip a command" id="idm46623552432600"/><a data-type="indexterm" data-primary="network interfaces" data-secondary="listing for current system" id="idm46623552431896"/> is to use the <code>ip a</code> command to show the list of network interfaces configured in the current system:</p>
<pre>ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue
state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
    valid_lft forever preferred_lft forever
2: enp0s31f6: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc
fq_codel stateDOWN group default
qlen 1000
link/ether 8c:16:45:00:a7:7e brd ff:ff:ff:ff:ff:ff
6: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc
noqueue state DOWN group default
link/ether 02:42:38:54:3c:98 brd ff:ff:ff:ff:ff:ff
inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
   valid_lft forever preferred_lft forever
inet6 fe80::42:38ff:fe54:3c98/64 scope link
   valid_lft forever preferred_lft forever</pre>

<p>This list already tells us something. Can you find the word <code>qdisc</code> in it? Let’s analyze the situation:</p>

<ul>
<li>
<p>We have three network interfaces in this system: <code>lo</code>, <code>enp0s31f6</code>, and
<code>docker0</code>.</p>
</li>
<li>
<p>The <code>lo</code> interface is a virtual interface, so it has qdisc <code>noqueue</code>.</p>
</li>
<li>
<p>The <code>enp0s31f6</code> is a physical interface. Wait, why is the qdisc here <code>fq_codel</code> (fair queue controlled delay)? Wasn’t <code>pfifo_fast</code> the default? It turns out that the system we’re testing the commands on is running Systemd, which is setting the default qdisc differently using the kernel parameter <code>net.core.default_qdisc</code>.</p>
</li>
<li>
<p>The <code>docker0</code> interface is a bridge interface, so it uses a <code>virtual</code> device and has <code>noqueue</code> qdisc.</p>
</li>
</ul>

<p>The <code>noqueue</code> qdisc doesn’t have classes, a scheduler, or a classifier. What it does is that it tries to send the packets immediately. As stated, <code>noqueue</code> is used by default by virtual devices, but it’s also the qdisc that becomes effective to any interface when you delete its current associated qdisc.</p>

<p><code>fq_codel</code> is a classless qdisc that classifies the incoming packets using a stochastic model in order to be able to queue traffic flows in a fair way.<a data-type="indexterm" data-primary="fair queue controlled delay (fq_codel) qdisc" id="idm46623552416104"/></p>

<p>The situation should be clearer now; we used the <code>ip</code> command to find information about <code>qdiscs</code> but it turns<a data-type="indexterm" data-primary="iproute2 toolkit" data-secondary="tc tool" id="idm46623552413864"/><a data-type="indexterm" data-primary="tc tool" data-secondary="tc qdisc ls command" id="idm46623552412856"/> out that in the <code>iproute2</code> toolbelt there’s also a tool called <code>tc</code> that has a specific subcommand for qdiscs you can use to list them:</p>
<pre>tc qdisc ls
qdisc noqueue 0: dev lo root refcnt 2
qdisc fq_codel 0: dev enp0s31f6 root refcnt 2 limit 10240p flows 1024 quantum 1514
target 5.0ms interval 100.0ms memory_limit 32Mb ecn
qdisc noqueue 0: dev docker0 root refcnt 2</pre>

<p>There’s much more going on here! For <code>docker0</code> and <code>lo</code> we basically see the
same information as with <code>ip a</code>, but for <code>enp0s31f6</code>, for example, it has the following:</p>

<ul>
<li>
<p>A limit of 10,240 incoming packets that it can handle.</p>
</li>
<li>
<p>As mentioned, the stochastic model used by <code>fq_codel</code> wants to queue traffic into
different flows, and this output contains the information about how many of them we
have, which is 1,024.</p>
</li>
</ul>

<p>Now that the key concepts of qdiscs have been introduced, we can take a closer look at classful and classless qdiscs in the next section to understand their differences and which ones are suitable for BPF programs.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Classful qdiscs, filters, and classes"><div class="sect3" id="idm46623552446744">
<h3>Classful qdiscs, filters, and classes</h3>

<p>Classful qdiscs allow the definition of classes for different kinds of traffic
in order to apply different rules to them. <a data-type="indexterm" data-primary="queueing disciplines (qdisc)" data-secondary="classful qdiscs, filters, and classes" id="idm46623552403016"/><a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="Traffic Control concepts" data-tertiary="classful qdiscs, filters, and clases" id="idm46623552401960"/>Having a class for a qdisc means that
it can contain further qdiscs. With this kind of hieararchy, then, we can use a filter (classifier) to classify the traffic by determining the next class
where the packet should be enqueued.<a data-type="indexterm" data-primary="filtering" data-secondary="filters in classful qdiscs" id="idm46623552400328"/></p>

<p><em>Filters</em> are used to assign packets to a particular class based on their type.
Filters are used inside a classful qdiscs to determine in which class the packet
should be enqueued, and two or more filters can map to the same class, as shown in
<a data-type="xref" href="#tc-qdisc-filters">Figure 6-2</a>. Every filter uses a classifier to classify packets based on their
information.</p>

<figure><div id="tc-qdisc-filters" class="figure">
<img src="assets/lbpf_0602.png" alt="A qdisc containing a set of filters that map to two different classes that have associated qdiscs themselves"/>
<h6><span class="label">Figure 6-2. </span>Classful qdisc with filters</h6>
</div></figure>

<p>As mentioned earlier, <code>cls_bpf</code> is the classifier that we want to use to write BPF programs for Traffic Control—we have a concrete example in the next sections on how to use it.</p>

<p><em>Classes</em> are objects that can live only in a classful qdisc; classes are used in Traffic Control to create hierarchies.<a data-type="indexterm" data-primary="classes in classful qdiscs" id="idm46623552393816"/> Complex hierarchies are made possible by the fact that a class can have filters attached to it, which can then be used as an entry point for another class or for a qdisc.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Classless qdiscs"><div class="sect3" id="idm46623552392600">
<h3>Classless qdiscs</h3>

<p>A classless qdiscs is a qdisc that can’t have any children because it is not allowed to have any classes associated. <a data-type="indexterm" data-primary="queueing disciplines (qdisc)" data-secondary="classless" id="idm46623552391208"/><a data-type="indexterm" data-primary="classless qdiscs" id="idm46623552390216"/><a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="Traffic Control concepts" data-tertiary="classless qdiscs" id="idm46623552389544"/>This means that is not possible to attach filters to classless qdiscs. Because classless qdiscs can’t have children, we can’t add filters and classifiers to them, so classless qdiscs are not interesting from a BPF point of view but still useful for simple Traffic Control needs.</p>

<p>After building up some knowledge on qdiscs, filters, and classes, we now show you how to write BPF programs for a <code>cls_bpf</code> classifier.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Traffic Control Classifier Program Using cls_bpf"><div class="sect2" id="idm46623552386584">
<h2>Traffic Control Classifier Program Using cls_bpf</h2>

<p>As we said, Traffic Control is a powerful mechanism that is made even more powerful thanks to classifiers; however, among all the classifiers, there is one that allows you to program the network data path <code>cls_bpf</code> classifier.<a data-type="indexterm" data-primary="cls_bpf" data-secondary="Traffic Control classifier program using" id="ix_clsbpf"/><a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="classifier program using cls_bpf" id="ix_TrCtlclassi"/> This classifier is special because it can run BPF programs, but what does that mean? It means that <code>cls_bpf</code> will allow you to hook your BPF programs directly in the ingress and egress layers, and running BPF programs hooked to those layers means that they will be able to access the <code>sk_buff</code> struct for<a data-type="indexterm" data-primary="Socket Buffer structure" data-secondary="access to sk_buff struct by BPF programs" id="idm46623552379256"/> the respective packets.</p>

<p>To understand better this relationship between Traffic Control and BPF programs, see <a data-type="xref" href="#tc-flow-bpf-cls">Figure 6-3</a>, which shows how BPF programs are loaded against the <code>cls_bpf</code> classifier. You will also notice that such programs are hooked into ingress and egress qdiscs. All the other interactions in context are also described. By taking the network interface as the entry point for network traffic, you will see the following:</p>

<ul>
<li>
<p>The traffic first goes to the Traffic Control’s ingress hook.</p>
</li>
<li>
<p>Then the kernel will execute the BFP program loaded into the ingress from userspace for every request coming in.</p>
</li>
<li>
<p>After the ingress program is executed, the control is given to the networking stack that informs the user’s application about the networking event.</p>
</li>
<li>
<p>After the application gives a response, the control is passed to the Traffic Control’s egress using another BPF program that executes, and upon completion gives back control to the kernel.</p>
</li>
<li>
<p>A response is given to the client.</p>
</li>
</ul>

<p>You can write BPF programs for Traffic Control in C and compile them using LLVM/Clang with the BPF backend.<a data-type="indexterm" data-primary="C language" data-secondary="BPF programs for Traffic Control" id="idm46623552370392"/><a data-type="indexterm" data-primary="compilers" data-secondary="BPF programs for Traffic Control" id="idm46623552369416"/></p>

<figure><div id="tc-flow-bpf-cls" class="figure">
<img src="assets/lbpf_0603.png" alt="Diagram showing the interactions between Traffic Control and BPF programs loaded using cls_bpf"/>
<h6><span class="label">Figure 6-3. </span>Loading of BPF programs using Traffic Control</h6>
</div></figure>
<div data-type="tip"><h6>Tip</h6>
<p>Ingress and egress qdiscs allow<a data-type="indexterm" data-primary="ingress and egress traffic" id="idm46623552365368"/> you to hook Traffic Control into inbound (ingress) and outbound (egress) traffic, respectively.<a data-type="indexterm" data-primary="queueing disciplines (qdisc)" data-secondary="ingress and egress" id="idm46623552364360"/></p>
</div>

<p>To make this example work, you need to run it on a kernel that has been compiled with <code>cls_bpf</code> directly or as a module. To verify that you have everything you need, you can do the following:</p>

<pre data-type="programlisting" data-code-language="bash">cat /proc/config.gz<code class="p">|</code> zcat  <code class="p">|</code> grep -i BPF</pre>

<p>Make sure you get at least the following output with either <code>y</code> or <code>m</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">CONFIG_BPF</code><code class="o">=</code>y
<code class="nv">CONFIG_BPF_SYSCALL</code><code class="o">=</code>y
<code class="nv">CONFIG_NET_CLS_BPF</code><code class="o">=</code>m
<code class="nv">CONFIG_BPF_JIT</code><code class="o">=</code>y
<code class="nv">CONFIG_HAVE_EBPF_JIT</code><code class="o">=</code>y
<code class="nv">CONFIG_BPF_EVENTS</code><code class="o">=</code>y</pre>

<p>Let’s now see how we write the classifier:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">SEC</code><code class="p">(</code><code class="s">"classifier"</code><code class="p">)</code>
<code class="k">static</code> <code class="kr">inline</code> <code class="kt">int</code> <code class="n">classification</code><code class="p">(</code><code class="k">struct</code> <code class="n">__sk_buff</code> <code class="o">*</code><code class="n">skb</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">void</code> <code class="o">*</code><code class="n">data_end</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code>
  <code class="kt">void</code> <code class="o">*</code><code class="n">data</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">ethhdr</code> <code class="o">*</code><code class="n">eth</code> <code class="o">=</code> <code class="n">data</code><code class="p">;</code>

  <code class="n">__u16</code> <code class="n">h_proto</code><code class="p">;</code>
  <code class="n">__u64</code> <code class="n">nh_off</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="n">nh_off</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="o">*</code><code class="n">eth</code><code class="p">);</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">data</code> <code class="o">+</code> <code class="n">nh_off</code> <code class="o">&gt;</code> <code class="n">data_end</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="n">TC_ACT_OK</code><code class="p">;</code>
  <code class="p">}</code></pre>

<p>The “main” of our classifier is the <code>classification</code> function. This function is annotated with a section header called
<code>classifier</code> so that <code>tc</code> can know that this is the classifier to use.</p>

<p>At this point, we need to extract some information from the <code>skb</code>; the <code>data</code> member contains all the data for the current packet and all its protocol details. To let our program know what’s inside of it, we need to cast it to an Ethernet frame (in our case, with the <code>*eth</code> variable). To make the static verifier happy, we need to check that the data, summed up with the size of the <code>eth</code> pointer, does not exceed the space where <code>data_end</code> is. After that, we can go one level inward and get the protocol type from the <code>h_proto</code> member in <code>*eth</code>:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="k">if</code> <code class="p">(</code><code class="n">h_proto</code> <code class="o">==</code> <code class="n">bpf_htons</code><code class="p">(</code><code class="n">ETH_P_IP</code><code class="p">))</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">is_http</code><code class="p">(</code><code class="n">skb</code><code class="p">,</code> <code class="n">nh_off</code><code class="p">)</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
      <code class="n">trace_printk</code><code class="p">(</code><code class="s">"Yes! It is HTTP!</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="n">TC_ACT_OK</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>After we have the protocol, we need to convert it from the host to check whether it is equal to the IPv4 protocol, the one we are interested in, and if it is, we check whether the inner packet is HTTP using our own <code>is_http</code> function. If it is, we print a debug message stating that we found an HTTP packet:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="kt">void</code> <code class="o">*</code><code class="n">data_end</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code>
  <code class="kt">void</code> <code class="o">*</code><code class="n">data</code> <code class="o">=</code> <code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">iphdr</code> <code class="o">*</code><code class="n">iph</code> <code class="o">=</code> <code class="n">data</code> <code class="o">+</code> <code class="n">nh_off</code><code class="p">;</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">iph</code> <code class="o">+</code> <code class="mi">1</code> <code class="o">&gt;</code> <code class="n">data_end</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="k">if</code> <code class="p">(</code><code class="n">iph</code><code class="o">-&gt;</code><code class="n">protocol</code> <code class="o">!=</code> <code class="n">IPPROTO_TCP</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="n">__u32</code> <code class="n">tcp_hlen</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code></pre>

<p>The <code>is_http</code> function is similar to our classifier function, but it will start from an <code>skb</code> by knowing already the start offset for the IPv4 protocol data. As we did earlier, we need to do a check before accessing the IP protocol data with the <code>*iph</code> variable to let the static verifier know our intentions.</p>

<p>When that’s done, we just check whether the IPv4 header contains a TCP packet so that we can go ahead. If the packet’s protocol is of type <code>IPPROTO_TCP</code>, we need to do some more checks again to get the actual TCP header in the <code>*tcph</code> variable:</p>

<pre data-type="programlisting" data-code-language="c">  <code class="n">plength</code> <code class="o">=</code> <code class="n">ip_total_length</code> <code class="o">-</code> <code class="n">ip_hlen</code> <code class="o">-</code> <code class="n">tcp_hlen</code><code class="p">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">plength</code> <code class="o">&gt;=</code> <code class="mi">7</code><code class="p">)</code> <code class="p">{</code>
    <code class="kt">unsigned</code> <code class="kt">long</code> <code class="n">p</code><code class="p">[</code><code class="mi">7</code><code class="p">];</code>
    <code class="kt">int</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">7</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>

      <code class="n">p</code><code class="p">[</code><code class="n">i</code><code class="p">]</code> <code class="o">=</code> <code class="n">load_byte</code><code class="p">(</code><code class="n">skb</code><code class="p">,</code> <code class="n">poffset</code> <code class="o">+</code> <code class="n">i</code><code class="p">);</code>
    <code class="p">}</code>
    <code class="kt">int</code> <code class="o">*</code><code class="n">value</code><code class="p">;</code>
    <code class="k">if</code> <code class="p">((</code><code class="n">p</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">==</code> <code class="sc">'H'</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="p">(</code><code class="n">p</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">==</code> <code class="sc">'T'</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="p">(</code><code class="n">p</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">==</code> <code class="sc">'T'</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="p">(</code><code class="n">p</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="o">==</code> <code class="sc">'P'</code><code class="p">))</code> <code class="p">{</code>
      <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Now that the TCP header is ours, we can go ahead and load the first seven bytes from the <code>skb</code> struct at the offset of the TCP payload <code>poffset</code>. At this point we can check whether the bytes array is a sequence saying <code>HTTP</code>; then we know that the Layer 7 protocol is HTTP, and we can return 1—otherwise, we return zero.</p>

<p>As you can see, our program is simple. It will basically allow everything, and when receiving an HTTP packet, it will let us know with a debugging message.</p>

<p>You can compile the program with Clang, using the <code>bpf</code> target, as we did before with the socket filter example.<a data-type="indexterm" data-primary="clang utility" data-secondary="compiling BPF classifier program for Traffic Control" id="idm46623551907736"/> We cannot compile this program for Traffic Control in the same way; this will generate an <em>ELF</em> file <code>classifier.o</code> that will be loaded by <code>tc</code> this time and not by our own custom loader:</p>

<pre data-type="programlisting" data-code-language="bash">clang -O2 -target bpf -c classifier.c -o classifier.o</pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46623551903800">
<h5>Traffic Control Return Codes</h5>
<p>From <code>man 8 tc-bpf</code>:</p>
<dl>
<dt><code>TC_ACT_OK (0)</code></dt>
<dd>
<p>Terminates the packet processing pipeline <a data-type="indexterm" data-primary="return codes (Traffic Control)" id="idm46623551898824"/><a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="Traffic Control return codes" id="idm46623551898152"/>and allows the packet to proceed</p>
</dd>
<dt><code>TC_ACT_SHOT (2)</code></dt>
<dd>
<p>Terminates the packet processing pipeline and drops the packet</p>
</dd>
<dt><code>TC_ACT_UNSPEC (-1)</code></dt>
<dd>
<p>Uses the default action configured from <code>tc</code> (similarly as returning –1 from a <span class="keep-together">classifier</span>)</p>
</dd>
<dt><code>TC_ACT_PIPE (3)</code></dt>
<dd>
<p>Iterates to the next action, if available</p>
</dd>
<dt><code>TC_ACT_RECLASSIFY (1)</code></dt>
<dd>
<p>Terminates the packet processing pipeline and starts classification from the beginning <code>else</code></p>
</dd>
</dl>

<p>Everything else is an unspecified return code</p>
</div></aside>

<p>Now we can install the program on the interface we want our program to operate on; in<a data-type="indexterm" data-primary="network interfaces" data-secondary="installing BPF classifier for Traffic Control on eth0" id="idm46623551888728"/> our case, it was <code>eth0</code>.</p>

<p>The first command will replace the default qdisc for the <code>eth0</code> device, and the second one will actually load our <code>cls_bpf</code> classifier into that <code>ingress</code> classful qdisc.<a data-type="indexterm" data-primary="queueing disciplines (qdisc)" data-secondary="ingress classful qdisc" id="idm46623551885160"/> This means that our program will handle all traffic going into that interface. If we want to handle outgoing traffic, we would need to use the <code>egress</code> qdisc instead:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># tc qdisc add dev eth0 handle 0: ingress</code>
<code class="c"># tc filter add dev eth0 ingress bpf obj classifier.o flowid 0:</code></pre>

<p>Our program is loaded now—what we need is to send some HTTP traffic to that interface.</p>

<p>To do that you need any HTTP server<a data-type="indexterm" data-primary="HTTP servers" id="idm46623551842520"/> on that interface. Then you can <code>curl</code> the interface IP.</p>

<p>In case you don’t have one, you <a data-type="indexterm" data-primary="Python" data-secondary="http.server module in Python 3" id="idm46623551835096"/>can obtain a test HTTP server using Python 3 with the <code>http.server</code> module. It will open the port 8000 with a directory listing of the current working directory:</p>

<pre data-type="programlisting" data-code-language="bash">python3 -m http.server</pre>

<p>At this point<a data-type="indexterm" data-primary="curl utility" data-secondary="calling HTTP server" id="idm46623551750216"/> you can call the server with <code>curl</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>curl http://192.168.1.63:8080</pre>

<p>After doing that you should see your HTTP response from the HTTP server. You can now get your debugging messages (created with <code>trace_printk</code>), confirming that<a data-type="indexterm" data-primary="tc tool" data-secondary="tc exec bpf dbg command" id="idm46623551845352"/> using the dedicated <code>tc</code> command:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># tc exec bpf dbg</code></pre>

<p>The output will be something like this:</p>

<pre data-type="programlisting" data-code-language="bash">Running! Hang up with ^C!

         python3-18456 <code class="o">[</code>000<code class="o">]</code> ..s1 283544.114997: 0: Yes! It is HTTP!
         python3-18754 <code class="o">[</code>002<code class="o">]</code> ..s1 283566.008163: 0: Yes! It is HTTP!</pre>

<p>Congratulations! You just made your first BPF Traffic Control classifier.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Instead of using a debugging message like we did in this example, you could use a map to communicate to user-space that the interface just received an HTTP packet. We leave this as an exercise for you to do. If you look at <code>classifier.c</code> in the previous example, you can get an idea of how to do that by looking at how we used the map <code>countmap</code> there.</p>
</div>

<p>At this point, what you might want is to unload the classifier. You can do that by deleting <a data-type="indexterm" data-primary="tc tool" data-secondary="tc qdisc del dev eth0 ingress command" id="idm46623551686360"/>the ingress qdisc that you just attached to the interface:</p>
<pre># tc qdisc del dev eth0 ingress</pre>










<section data-type="sect3" data-pdf-bookmark="Notes on act_bpf and how cls_bpf is different"><div class="sect3" id="idm46623551684776">
<h3>Notes on act_bpf and how cls_bpf is different</h3>

<p>You might have noticed that another object exists for BPF programs called <code>act_bpf</code>. <a data-type="indexterm" data-primary="cls_bpf" data-secondary="Traffic Control classifier program using" data-tertiary="act_bpf versus" id="idm46623551682776"/><a data-type="indexterm" data-primary="act_bpf versus cls_bpf" id="idm46623551681400"/>It turns out that <code>act_bpf</code> is an action, not a classifier. This makes it operationally different because actions are objects attached to filters, and because of this it is not able to perform filtering directly, requiring Traffic Control to consider all the packets first. For this property, it is usually preferable to use the <code>cls_bpf</code> classifier instead of the <code>act_bpf</code> action.</p>

<p>However, because <code>act_bpf</code> can be attached to any classifier, there might be cases for which you find it useful to just reuse a classifier you already have and attach a BPF program to it.<a data-type="indexterm" data-primary="cls_bpf" data-secondary="Traffic Control classifier program using" data-startref="ix_clsbpf" id="idm46623551860200"/><a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="classifier program using cls_bpf" data-startref="ix_TrCtlclassi" id="idm46623551858920"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Differences Between Traffic Control and XDP"><div class="sect2" id="idm46623552385000">
<h2>Differences Between Traffic Control and XDP</h2>

<p>Even though the Traffic Control <code>cls_bpf</code> and XDP programs look very similar, they are pretty different.<a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-secondary="differences between Traffic Control and XDP" id="idm46623551856744"/><a data-type="indexterm" data-primary="XDP programs" data-secondary="differences between Traffic Control programs and" id="idm46623551855704"/>
XDP programs are executed earlier in the ingress data path, before entering into the main kernel network stack, so our program does not have access to a socket buffer struct <code>sk_buff</code> like with <code>tc</code>.<a data-type="indexterm" data-primary="Socket Buffer structure" data-secondary="XDP programs, not having access to sk_buff struct" id="idm46623551853576"/> XDP programs instead take a different structure called <code>xdp_buff</code>, which is an eager representation of the packet without metadata.<a data-type="indexterm" data-primary="xdp_buff struct" id="idm46623551852024"/> All this comes with advantages and disadvantages. For example,  being executed even before the kernel code, XDP programs can drop packets in an efficient way. Compared to Traffic Control programs, XDP programs can be attached only to traffic in ingress to the system.</p>

<p>At this point, you might be asking yourself when it’s an advantage to use one instead of the other. The answer is that because of their nature of not containing all the kernel-enriched data structures and metadata, XDP programs are better for use cases covering OSI layers up to Layer 4. But let’s not spoil all the content of the next <span class="keep-together">chapter</span>!<a data-type="indexterm" data-primary="Traffic Control, BPF-based classifier" data-startref="ix_TrCtl" id="idm46623551849608"/><a data-type="indexterm" data-primary="networking (Linux) and BPF" data-secondary="BPF-based Traffic Control classifier" data-startref="ix_netLiTCclass" id="idm46623551663944"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46623552555096">
<h1>Conclusion</h1>

<p>It should now be pretty clear to you that BPF programs are useful for getting visibility and control at different levels of the networking data path. You’ve seen how to take advantage of them to filter packets using high-level tools that generate a BPF assembly. Then we loaded a program to a network socket, and in the end we attached our programs to the Traffic Control ingress qdisc to do traffic classification using BPF programs. In this chapter we also briefly discussed XDP, but be prepared, because in <a data-type="xref" href="ch07.html#express_data_path_XDP">Chapter 7</a> we cover the topic in its entirety by expanding on how XDP programs are constructed, what kind of XDP programs there are, and how to write and test them.<a data-type="indexterm" data-primary="networking (Linux) and BPF" data-startref="ix_netLi" id="idm46623551659832"/></p>
</div></section>







</div></section></body></html>