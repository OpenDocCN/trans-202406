- en: 'Chapter 14\. A Very Graphic Story: Getting Gui'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0461-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: '**Face it, you need to make GUIs**. If you’re building applications that other
    people are going to use, you *need* a graphical interface. If you’re building
    programs for yourself, you *want* a graphical interface. Even if you believe that
    the rest of your natural life will be spent writing server-side code, where the
    client user interface is a web page, sooner or later you’ll need to write tools,
    and you’ll want a graphical interface. Sure, command-line apps are retro, but
    not in a good way. They’re weak, inflexible, and unfriendly. We’ll spend two chapters
    working on GUIs and learn key Java language features along the way including **Event
    Handling** and **Inner Classes** and **lambdas**. In this chapter, we’ll put a
    button on the screen, and make it do something when you click it. We’ll paint
    on the screen, we’ll display a JPEG image, and we’ll even do some (crude) animation.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with a window
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0462-02.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: '**She’s asked a couple of really good questions.** In a few pages we’ll address
    these questions with an extra-special “No Dumb Questions.”'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: A JFrame is the object that represents a window on the screen. It’s where you
    put all the interface things like buttons, check boxes, text fields, and so on.
    It can have an honest-to-goodness menu bar with menu items. And it has all the
    little windowing icons for whatever platform you’re on, for minimizing, maximizing,
    and closing the window.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'The JFrame looks different depending on the platform you’re on. This is a JFrame
    on an old Mac OS X:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0462-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: Put widgets in the window
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have a JFrame, you can put things (“widgets”) in it by adding them
    to the JFrame. There are a ton of Swing components you can add; look for them
    in the javax.swing package. The most common include JButton, JRadioButton, JCheckBox,
    JLabel, JList, JScrollPane, JSlider, JTextArea, JTextField, and JTable. Most are
    really simple to use, but some (like JTable) can be a bit more complicated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Making a GUI is easy:**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Make a frame (a JFrame)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '`**JFrame frame = new JFrame();**`'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Make a widget (button, text field, etc.)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '`**JButton button = new JButton("click me");**`'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Add the widget to the frame'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**frame.getContentPane().add(button);**`'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You don’t add things to the frame directly. Think of the frame as the trim around
    the window, and you add things to the window pane.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/4.png) Display it (give it a size and make it visible)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your first GUI: a button on a frame'
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0463-01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: '**Let’s see what happens when we run it:**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`%java SimpleGui1`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0463-02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Whoa! That’s a Really Big Button.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The button fills all the available space in the frame. Later we’ll learn to
    control where (and how big) the button is on the frame.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: But nothing happens when I click it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s not exactly true. When you press the button, it shows that “pressed”
    or “pushed in” look (which changes depending on the platform look and feel, but
    it always does *something* to show when it’s being pressed).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The real question is, “How do I get the button to do something specific when
    the user clicks it?”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**We need two things:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) A ***method*** to be called when the user clicks (the
    thing you want to happen as a result of the button click).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) A way to ***know*** when to trigger that method. In
    other words, a way to know when the user clicks the button!'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a user event
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you want the text on the button to change from *click me* to *I’ve
    been clicked* when the user presses the button. First we can write a method that
    changes the text of the button (a quick look through the API will show you the
    method):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But *now* what? How will we *know* when this method should run? ***How will
    we know when the button is clicked?***
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the process of getting and handling a user event is called *event-handling*.
    There are many different event types in Java, although most involve GUI user actions.
    If the user clicks a button, that’s an event. An event that says “The user wants
    the action of this button to happen.” If it’s a “Slow the Tempo” button, the user
    wants the slow-the-music-tempo action to occur. If it’s a Send button on a chat
    client, the user wants the send-my-message action to happen. So the most straightforward
    event is when the user clicked the button, indicating they want an action to occur.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: With buttons, you usually don’t care about any intermediate events like button-is-being-pressed
    and button-is-being-released. What you want to say to the button is, “I don’t
    care how the user plays with the button, how long they hold the mouse over it,
    how many times they change their mind and roll off before letting go, etc. ***Just
    tell me when the user means business!*** In other words, don’t call me unless
    the user clicks in a way that indicates he wants the darn button to do what it
    says it’ll do!”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**First, the button needs to know that we care.**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0465-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: '**Second, the button needs a way to call us back when a button-clicked event
    occurs.**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**If you care about the button’s events, **implement an interface** that says,
    “I’m **listening** for your events.”**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: A **listener interface** is the bridge between the **listener** (you) and **event
    source** (the button).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The Swing GUI components are event sources. In Java terms, an event source is
    an object that can turn user actions (click a mouse, type a key, close a window)
    into events. And like virtually everything else in Java, an event is represented
    as an object. An object of some event class. If you scan through the java.awt.event
    package in the API, you’ll see a bunch of event classes (easy to spot—they all
    have ***Event*** in the name). You’ll find MouseEvent, KeyEvent, WindowEvent,
    ActionEvent, and several others.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: An event ***source*** (like a button) creates an ***event object*** when the
    user does something that matters (like *click* the button). Most of the code you
    write (and all the code in this book) will *receive* events rather than *create*
    events. In other words, you’ll spend most of your time as an event *listener*
    rather than an event *source*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Every event type has a matching listener interface. If you want MouseEvents,
    implement the MouseListener interface. Want WindowEvents? Implement WindowListener.
    You get the idea. And remember your interface rules—to implement an interface
    you *declare* that you implement it (class Dog implements Pet), which means you
    must *write implementation methods* for every method in the interface.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Some interfaces have more than one method because the event itself comes in
    different flavors. If you implement MouseListener, for example, you can get events
    for mousePressed, mouseReleased, mouseMoved, etc. Each of those mouse events has
    a separate method in the interface, even though they all take a MouseEvent. If
    you implement MouseListener, the mousePressed() method is called when the user
    (you guessed it) presses the mouse. And when the user lets go, the mouseReleased()
    method is called. So for mouse events, there’s only one event *object*, MouseEvent,
    but several different event *methods*, representing the different *types* of mouse
    events.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**When you implement a listener interface, you give the button a way to call
    you back. The interface is where the call-back method is declared.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0466-01.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: '**How the listener and source communicate:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0467-01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: '**The Listener**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If your class wants to know about a button’s ActionEvents, you implement the
    ActionListener interface. The button needs to know you’re interested, so you register
    with the button by calling its addActionListener(this) and passing an ActionListener
    reference to it. In our first example, *you* are the ActionListener so you pass
    *this*, but it’s more common to create a specific class to do listen to events.
    The button needs a way to call you back when the event happens, so it calls the
    method in the listener interface. As an ActionListener, you *must* implement the
    interface’s sole method, actionPerformed(). The compiler guarantees it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**The Event Source**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: A button is a source of ActionEvents, so it has to know which objects are interested
    listeners. The button has an addActionListener() method to give interested objects
    (listeners) a way to *tell* the button they’re interested.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: When the button’s addActionListener() runs (because a potential listener invoked
    it), the button takes the parameter (a reference to the listener object) and stores
    it in a list. When the user clicks the button, the button “fires” the event by
    calling the actionPerformed() method on each listener in the list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting a button’s ActionEvent**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Implement the ActionListener interface'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Register with the button (tell it you want to listen
    for events)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![images](Images/3.png) Define the event-handling method (implement the actionPerformed()
    method from the ActionListener interface)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![image](Images/f0468-01.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Listeners, Sources, and Events
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For most of your stellar Java career, *you* will not be the *source* of events.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: (No matter how much you fancy yourself the center of your social universe.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Get used to it. ***Your job is to be a good listener.***
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: (Which, if you do it sincerely, *can* improve your social life.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0469-01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to graphics...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know a little about how events work (we’ll learn more later), let’s
    get back to putting stuff on the screen. We’ll spend a few minutes playing with
    some fun ways to get graphic, before returning to event handling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**Three ways to put things on your GUI:**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) **Put widgets on a frame**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add buttons, menus, radio buttons, etc.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**frame.getContentPane().add(myButton);**`'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The javax.swing package has more than a dozen widget types.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0471-01.png)'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2.png) **Draw 2D graphics on a widget**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a graphics object to paint shapes.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**graphics.fillOval(70,70,100,100);**`'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can paint a lot more than boxes and circles; the Java2D API is full of fun,
    sophisticated graphics methods.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0471-02.png)'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3.png) **Put a JPEG on a widget**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can put your own images on a widget.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`**graphics.drawImage(myPic,10,10,this);**`'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0471-03.png)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Make your own drawing widget
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to put your own graphics on the screen, your best bet is to make
    your own paintable widget. You plop that widget on the frame, just like a button
    or any other widget, but when it shows up, it will have your images on it. You
    can even make those images move, in an animation, or make the colors on the screen
    change every time you click a button.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: It’s a piece of cake.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Make a subclass of JPanel and override one method, paintComponent().**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: All of your graphics code goes inside the paintComponent() method. Think of
    the paintComponent() method as the method called by the system to say, “Hey widget,
    time to paint yourself.” If you want to draw a circle, the paintComponent() method
    will have code for drawing a circle. When the frame holding your drawing panel
    is displayed, paintComponent() is called and your circle appears. If the user
    iconifies/minimizes the window, the JVM knows the frame needs “repair” when it
    gets de-iconified, so it calls paintComponent() again. Anytime the JVM thinks
    the display needs refreshing, your paintComponent() method will be called.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: One more thing, ***you never call this method yourself!*** The argument to this
    method (a Graphics object) is the actual drawing canvas that gets slapped onto
    the *real* display. You can’t get this by yourself; it must be handed to you by
    the system. You’ll see later, however, that you *can* ask the system to refresh
    the display (repaint()), which ultimately leads to paintComponent() being called.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0472-01.png)![image](Images/f0472-02.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: Fun things to do in paintComponent()
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at a few more things you can do in paintComponent(). The most fun,
    though, is when you start experimenting yourself. Try playing with the numbers,
    and check the API for class Graphics (later we’ll see that there’s even *more*
    you can do besides what’s in the Graphics class).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**Display a JPEG**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0473-01.png)![image](Images/f0473-02.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: '**Paint a randomly colored circle on a black background**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0473-03.png)![image](Images/f0473-04.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Behind every good Graphics reference is a Graphics2D object
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The argument to paintComponent() is declared as type Graphics (java.awt.Graphics).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**`public void paintComponent(Graphics g) { }`**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: So the parameter “g” IS-A Graphics object. This means it *could* be a *subclass*
    of Graphics (because of polymorphism). And in fact, it *is*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '***The object referenced by the “g” parameter is actually an instance of the***
    Graphics2D ***class.***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Why do you care? Because there are things you can do with a Graphics2D reference
    that you can’t do with a Graphics reference. A Graphics2D object can do more than
    a Graphics object, and it really is a Graphics2D object lurking behind the Graphics
    reference.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember your polymorphism. The compiler decides which methods you can call
    based on the reference type, not the object type. If you have a Dog object referenced
    by an Animal reference variable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`**Animal a = new Dog();**`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'You CANNOT say:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`**a.bark();**`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though you know it’s really a Dog back there. The compiler looks at “a,”
    sees that it’s of type Animal, and finds that there’s no remote control button
    for bark() in the Animal class. But you can still get the object back to the Dog
    it really *is* by saying:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So the bottom line with the Graphics object is this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**If you need to use a method from the Graphics2D class, you can’t *use* the
    paintComponent parameter (“g”) straight from the method. But you can *cast* it
    with a new Graphics2D variable:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '`**Graphics2D g2d = (Graphics2D) g;**`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Because life’s too short to paint the circle a solid color when there’s a gradient
    blend waiting for you
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0475-01.png)![image](Images/f0475-02.png)![image](Images/f0475-03.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: '**Bullet Points**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: We can get an event. We can paint graphics. But can we paint graphics *when*
    we get an event?
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s hook up an event to a change in our drawing panel. We’ll make the circle
    change colors each time you click the button. Here’s how the program flows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1-circle.png) The frame is built with the two widgets (your
    drawing panel and a button). A listener is created and registered with the button.
    Then the frame is displayed, and it just waits for the user to click.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-01.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2-circle.png) The user clicks the button, and the button creates
    an event object and calls the listener’s event handler.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-02.png)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3-circle.png) The event handler calls repaint() on the frame.
    The system calls paintComponent() on the drawing panel.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/4-circle.png) Voilà! A new color is painted because paintComponent()
    runs again, filling the circle with a random color.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0477-03.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![image](Images/f0478-01.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'GUI layouts: putting more than one widget on a frame'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We cover GUI layouts in the *next* chapter, but we’ll do a quickie lesson here
    to get you going. By default, a frame has five regions you can add to. You can
    add only *one* thing to each region of a frame, but don’t panic! That one thing
    might be a panel that holds three other things including a panel that holds two
    more things and...you get the idea. In fact, we were “cheating” when we added
    a button to the frame using:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0478-02.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: '**The circle changes color each time you click the button.**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0479-01.png)![image](Images/f0479-02.png)![image](Images/f0479-03.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Let’s try it with TWO buttons
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The south button will act as it does now, simply calling repaint on the frame.
    The second button (which we’ll stick in the east region) will change the text
    on a label. (A label is just text on the screen.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: So now we need FOUR widgets
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0480-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: And we need to get TWO events
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uh-oh.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Is that even possible? How do you get *two* events when you have only *one*
    actionPerformed() method?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0480-02.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: How do you get action events for two different buttons when each button needs
    to do something different?
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0483-01.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Inner class to the rescue!
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You *can* have one class nested inside another. It’s easy. Just make sure that
    the definition for the inner class is *inside* the curly braces of the outer class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple inner class:**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0484-01.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: An inner class gets a special pass to use the outer class’s stuff. *Even the
    private stuff.* And the inner class can use those private variables and methods
    of the outer class as if the variables and members were defined in the inner class.
    That’s what’s so handy about inner classes—they have most of the benefits of a
    normal class, but with special access rights.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner class using an outer class variable**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0484-02.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: An inner class instance must be tied to an outer class instance*
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, when we talk about an inner *class* accessing something in the outer
    class, we’re really talking about an *instance* of the inner class accessing something
    in an *instance* of the outer class. But *which* instance?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Can *any* arbitrary instance of the inner class access the methods and variables
    of *any* instance of the outer class? **No!**
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '*An **inner** object must be tied to a specific **outer** object on the heap.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-03.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: '![images](Images/1.png) Make an instance of the outer class'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0485-01.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2.png) Make an instance of the inner class, by using the instance
    of the outer class.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0485-02.png)'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3.png) The outer and inner objects are now intimately linked.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0485-04.png)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '* There’s an exception to this, for a very special case—an inner class defined
    within a static method. But we’re not going there, and you might go your entire
    Java life without ever encountering one of these.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: How to make an instance of an inner class
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you instantiate an inner class from code *within* an outer class, the instance
    of the outer class is the one that the inner object will “bond” with. For example,
    if code within a method instantiates the inner class, the inner object will bond
    to the instance whose method is running.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Code in an outer class can instantiate one of its own inner classes, in exactly
    the same way it instantiates any other class...**`new MyInner()`**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0486-01.png)![image](Images/f0486-02.png)![image](Images/f0486-03.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '**Now we can get the two-button code working**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0487-01.png)![image](Images/f0487-02.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Java Exposed
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0488-01.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: '**This week’s interview: Instance of an Inner Class**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** What makes inner classes important?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Where do I start? We give you a chance to implement the same
    interface more than once in a class. Remember, you can’t implement a method more
    than once in a normal Java class. But using *inner* classes, each inner class
    can implement the *same* interface, so you can have all these *different* implementations
    of the very same interface methods.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Why would you ever* want to implement the same method twice?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Let’s revisit GUI event handlers. Think about it...if you
    want* three *buttons to each have a different event behavior, then use* three
    inner classes, all implementing ActionListener—which means each class gets to
    implement its own actionPerformed method.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** So are event handlers the only reason to use inner classes?'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Oh, gosh no. Event handlers are just an obvious example.
    Anytime you need a separate class but still want that class to behave as if it
    were part of* another *class, an inner class is the best—and sometimes* only—way
    to do it.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *I’m still confused here. If you want the inner class to* behave
    *like it belongs to the outer class, why have a separate class in the first place?
    Why wouldn’t the inner class code just be* in the outer class in the first place?'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *I just* gave *you one scenario, where you need more than
    one implementation of an interface. But even when you’re not using interfaces,
    you might need two different* classes *because those classes represent two different*
    things. It’s good OO.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Whoa. Hold on here. I thought a big part of OO design is about
    reuse and maintenance. You know, the idea that if you have two separate classes,
    they can each be modified and used independently, as opposed to stuffing it all
    into one class yada yada yada. But with an* inner *class, you’re still just working
    with one* real class in the end, right? The enclosing class is the only one that’s
    reusable and separate from everybody else. Inner classes aren’t exactly reusable.
    In fact, I’ve heard them called “Reuseless—useless over and over again.”'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes, it’s true that the inner class is not *as* reusable,
    in fact sometimes not reusable at all, because it’s intimately tied to the instance
    variables and methods of the outer class. But it—'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** —which only proves my point! If they’re not reusable, why bother
    with a separate class? I mean, other than the interface issue, which sounds like
    a workaround to me.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** As I was saying, you need to think about IS-A and polymorphism.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** OK. And I’m thinking about them because...'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Because the outer and inner classes might need to pass*
    different *IS-A tests! Let’s start with the polymorphic GUI listener example.
    What’s the declared argument type for the button’s listener registration method?
    In other words, if you go to the API and check, what kind of* thing (class or
    interface type) do you have to pass to the addActionListener() method?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** You have to pass a listener. Something that implements a particular
    listener interface, in this case ActionListener. Yeah, we know all this. What’s
    your point?'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *My point is that polymorphically, you have a method that
    takes only one particular* type*. Something that passes the IS-A test for ActionListener.
    But—and here’s the big thing—what if your class needs to be an IS-A of something
    that’s a* class type rather than an interface?'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Wouldn’t you have your class just* extend the class you need
    to be a part of? Isn’t that the whole point of how subclassing works? If B is
    a subclass of A, then anywhere an A is expected a B can be used. The whole pass-a-Dog-where-an-Animal-is-the-declared-type
    thing.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes! Bingo! So now what happens if you need to pass the IS-A
    test for two different classes? Classes that aren’t in the same inheritance hierarchy?'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Oh, well you just...hmmm. I think I’m getting it. You can always*
    implement *more than one interface, but you can* extend *only* one *class. You
    can be only one kind of IS-A when it comes to* class types.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *Well done! Yes, you can’t be both a Dog and a Button. But
    if you’re a Dog that needs to sometimes be a Button (in order to pass yourself
    to methods that take a Button), the Dog class (which extends Animal so it can’t
    extend Button) can have an* inner class that acts on the Dog’s behalf as a Button,
    by extending Button, and thus wherever a Button is required, the Dog can pass
    his inner Button instead of himself. In other words, instead of saying x.takeButton(this),
    the Dog object calls x.takeButton(new MyInnerButton()).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Can I get a clear example?'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Remember the drawing panel we used, where we made our own
    subclass of JPanel? Right now, that class is a separate, non-inner, class. And
    that’s fine, because the class doesn’t need special access to the instance variables
    of the main GUI. But what if it did? What if we’re doing an animation on that
    panel, and it’s getting its coordinates from the main application (say, based
    on something the user does elsewhere in the GUI). In that case, if we make the
    drawing panel an inner class, the drawing panel class gets to be a subclass of
    JPanel, while the outer class is still free to be a subclass of something else.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Yes, I see! And the drawing panel isn’t reusable enough to be
    a separate class anyway, since what it’s actually painting is specific to this
    one GUI application.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes! You’ve got it!'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Good. Then we can move on to the nature of the* relationship
    between you and the outer instance.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** What is it with you people? Not enough sordid gossip in a
    serious topic like polymorphism?'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Hey, you have no idea how much the public is willing to pay
    for some good old tabloid dirt. So, someone creates you, and you become instantly
    bonded to the outer object, is that right?'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** Yes, that’s right.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** What about the outer object? Can it be associated with any other
    inner objects?'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** *So now we have it. This is what you* really *wanted. Yes,
    yes. My so-called* “mate” can have as many inner objects as it wants.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** Is that like, serial monogamy? Or can it have them all at the
    same time?'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner object:** All at the same time. There. Satisfied?'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** *Well, it does make sense. And let’s not forget, it was* you
    extolling the virtues of “multiple implementations of the same interface.” So
    it makes sense that if the outer class has three buttons, it would need three
    different inner classes (and thus three different inner class objects) to handle
    the events.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner objects:** You got it!'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**HeadFirst:** One more question. I’ve heard that when lambdas came along,
    you were almost put out of a job?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Inner objects:** Ouch, that really hurts! Okay, full disclosure, there are
    many cases for which a lambda is an easier to read, more concise way to do what
    I do. But inner classes have been around for a long time, and you’re sure to encounter
    us in older code. Plus, those pesky lambdas aren’t better at everything..'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0489-01.png)![image](Images/f0490-01.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Lambdas to the rescue! (again)
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'He’s not wrong! One way to interpret the two highlighted lines of code would
    be:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: “When the `labelButton` *ActionListener gets an event,* `setText("Ouch");`”
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Not only are those two ideas separated from each other in the code, the inner
    class takes FIVE lines of code to invoke the setText method. And of course, everything
    we’ve said about the labelButton code is also true about the colorButton code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Remember a few pages back we said that in order to implement the ActionListener
    interface you had provide code for its actionPerformed method? Hmmm...does that
    ring any bells?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0490-02.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: ActionListener is a Functional Interface
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Remember that a lambda provides an implementation for a functional interface’s
    *one and only* abstract method.**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Since ActionListener is a functional interface, you can replace the inner classes
    we saw on the previous page with lambda expressions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0491-01.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: Lambdas, clearer and more concise
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, maybe not quite yet, but once you get used to reading lambdas, we’re pretty
    sure you’ll agree that they make your code clearer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Using an inner class for animation
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw why inner classes are handy for event listeners, because you get to implement
    the same event-handling method more than once. But now we’ll look at how useful
    an inner class is when used as a subclass of something the outer class doesn’t
    extend. In other words, when the outer class and inner class are in different
    inheritance trees!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to make a simple animation, where the circle moves across the screen
    from the upper left down to the lower right.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-01.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: '**How simple animation works**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Paint an object at a particular x and y coordinate.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0492-02.png)'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/2.png) Repaint the object at a different x and y coordinate.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0492-03.png)'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![images](Images/3.png) Repeat the previous step with changing x and y values
    for as long as the animation is supposed to continue.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What we really want is something like...**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0493-01.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: '**The complete simple animation code**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0494-01.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: '**Did it work?**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: You might not have got the smooth animation that you expected.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: What did we do wrong?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: There’s one little flaw in the paintComponent() method.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**We need to erase what was already there! Or we might get trails.**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix it, all we have to do is fill in the entire panel with the background
    color, before painting the circle each time. The code below adds two lines at
    the start of the method: one to set the color to white (the background color of
    the drawing panel) and the other to fill the entire panel rectangle with that
    color. In English, the code below says, “Fill a rectangle starting at x and y
    of 0 (0 pixels from the left and 0 pixels from the top) and make it as wide and
    as high as the panel is currently.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0495-01.png)![image](Images/f0495-02.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Code Kitchen
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0496-01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: '**Let’s make a music video. We’ll use Java-generated random graphics that keep
    time with the music beats.**'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Along the way we’ll register (and listen for) a new kind of non-GUI event,
    triggered by the music itself.**'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember, this part is all optional. But we think it’s good for you. And you’ll
    like it. And you can use it to impress people.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: (OK, sure, it might work only on people who are really easy to impress, but
    still....)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Listening for a non-GUI event
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, maybe not a music video, but we *will* make a program that draws random
    graphics on the screen with the beat of the music. In a nutshell, the program
    listens for the beat of the music and draws a random graphic rectangle with each
    beat.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'That brings up some new issues for us. So far, we’ve listened for only GUI
    events, but now we need to listen for a particular kind of MIDI event. Turns out,
    listening for a non-GUI event is just like listening for GUI events: you implement
    a listener interface, register the listener with an event source, and then sit
    back and wait for the event source to call your event-handler method (the method
    defined in the listener interface).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to listen for the beat of the music would be to register and
    listen for the actual MIDI events so that whenever the sequencer gets the event,
    our code will get it too and can draw the graphic. But...there’s a problem. A
    bug, actually, that won’t let us listen for the MIDI events *we’re* making (the
    ones for NOTE ON).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have to do a little workaround. There is another type of MIDI event we
    can listen for, called a ControllerEvent. Our solution is to register for ControllerEvents
    and then make sure that for every NOTE ON event, there’s a matching ControllerEvent
    fired at the same “beat.” How do we make sure the ControllerEvent is fired at
    the same time? We add it to the track just like the other events! In other words,
    our music sequence goes like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 1 - NOTE ON, CONTROLLER EVENT
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 2 - NOTE OFF
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 3 - NOTE ON, CONTROLLER EVENT
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: BEAT 4 - NOTE OFF
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: and so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the full program, though, let’s make it a little easier
    to make and add MIDI messages/events since in *this* program, we’re gonna make
    a lot of them.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**What the music art program needs to do:**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Make a series of MIDI messages/events to play random
    notes on a piano (or whatever instrument you choose).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Register a listener for the events.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Start the sequencer playing.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/4.png) Each time the listener’s event handler method is called,
    draw a random rectangle on the drawing panel, and call repaint.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We’ll build it in three iterations:**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Version One: Code that simplifies making and adding
    MIDI events, since we’ll be making a lot of them.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Version Two: Register and listen for the events, but
    without graphics. Prints a message at the command line with each beat.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Version Three: The real deal. Adds graphics to version
    two.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An easier way to make messages/events
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, making and adding messages and events to a track is tedious. For
    each message, we have to make the message instance (in this case, ShortMessage),
    call setMessage(), make a MidiEvent for the message, and add the event to the
    track. In the previous chapter’s code, we went through each step for every message.
    That means eight lines of code just to make a note play and then stop playing!
    Four lines to add a NOTE ON event, and four lines to add a NOTE OFF event.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Things that have to happen for each event:**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![images](Images/1.png) Make a message instance'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**ShortMessage msg = new ShortMessage();**`'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/2.png) Call setMessage() with the instructions'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**msg.setMessage(NOTE_ON, 1, instrument, 0);**`'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/3.png) Make a MidiEvent instance for the message'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**MidiEvent noteOn = new MidiEvent(msg, 1);**`'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![images](Images/4.png) Add the event to the track'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**track.add(noteOn);**`'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Let’s build a static utility method that makes a message and returns a MidiEvent**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0498-02.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: 'Version One: using the new static makeEvent() method'
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s no event handling or graphics here, just a sequence of 15 notes that
    go up the scale. The point of this code is simply to learn how to use our new
    makeEvent() method. The code for the next two versions is much smaller and simpler
    thanks to this method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0499-01.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: 'Version Two: registering and getting ControllerEvents'
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0500-01.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Code that’s different from the previous version is highlighted in gray (and
    we’ve moved the code out of the main() method into its own go() method).**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Version Three: drawing graphics in time with the music'
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final version builds on Version Two by adding the GUI parts. We build a
    frame and add a drawing panel to it, and each time we get an event, we draw a
    new rectangle and repaint the screen. The only other change from Version Two is
    that the notes play randomly as opposed to simply moving up the scale.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The most important change to the code (besides building a simple GUI) is that
    we make the drawing panel implement the ControllerEventListener rather than the
    program itself. So when the drawing panel (an inner class) gets the event, it
    knows how to take care of itself by drawing the rectangle.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Complete code for this version is on the next page.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '**The drawing panel inner class:**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0501-01.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Yours to solve.**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: A bunch of Java hotshots, in full costume, are playing the party game “Who am
    I?” They give you a clue, and you try to guess who they are, based on what they
    say. Assume they always tell the truth about themselves. If they happen to say
    something that could be true for more than one guy, then write down all for whom
    that sentence applies. Fill in the blanks next to the sentence with the names
    of one or more attendees.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Who Am I?
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0504-02.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: '**Tonight’s attendees:**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Any of the charming personalities from this chapter just might show up!**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '| **I got the whole GUI, in my hands.** | ______________________ |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| **Every event type has one of these.** | ______________________ |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| **The listener’s key method.** | ______________________ |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| **This method gives JFrame its size.** | ______________________ |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| **You add code to this method but never call it.** | ______________________
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| **When the user actually does something, it’s an _____ .** | ______________________
    |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| **Most of these are event sources.** | ______________________ |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: '| **I carry data back to the listener.** | ______________________ |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
- en: '| **An addXxxListener( ) method says an object is an _____ .** | ______________________
    |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '| **How a listener signs up.** | ______________________ |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
- en: '| **The method where all the graphics code goes.** | ______________________
    |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| **I’m typically bound to an instance.** | ______________________ |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| **The “g” in (Graphics g) is really of this class.** | ______________________
    |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| **The method that gets paintComponent( ) rolling.** | ______________________
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| **The package where most of the Swingers reside.** | ______________________
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '![image](Images/arr.png) **Answers in [“Who am I?”](#who_am_iquestion_mark_left_parenthesisfr).**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: BE the Compiler
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0505-02.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Java file on this page represents a complete source file. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it, and if it does compile, what would it do?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](Images/arr.png) **Answers in [“BE the Compiler”](#be_the_compiler-id00003).**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0506-01.png)![image](Images/f0506-02.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code. You **may** use the same snippet more than once, and
    you won’t need to use all the snippets. Your ***goal*** is to make a class that
    will compile and run and produce the output listed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The Amazing, Shrinking, Blue Rectangle. This program will produce a blue rectangle
    that will shrink and shrink and disappear into a field of white.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-03.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: '**Note: Each snippet from the pool can be used more than once!**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-04.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: '[PRE6]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![image](Images/arr.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_50).**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solutions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Who am I?
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Exercise”](#exercise-id000023))
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '| **I got the whole GUI, in my hands.** | JFrame |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| **Every event type has one of these.** | listener interface |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| **The listener’s key method.** | actionPerformed( ) |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| **This method gives JFrame its size.** | setSize( ) |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| **You add code to this method but never call it.** | paintComponent( ) |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| **When the user actually does something, it’s an ____ .** | event |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| **Most of these are event sources.** | swing components |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| **I carry data back to the listener.** | event object |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| **An addXxxListener( ) method says an object is an ___ .** | event source
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| **How a listener signs up.** | addXxxListener( ) |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| **The method where all the graphics code goes.** | paintComponent( ) |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| **I’m typically bound to an instance.** | inner class |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| **The “g” in (Graphics g) is really of this class.** | Graphics2D |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| **The method that gets paintComponent( ) rolling.** | repaint( ) |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| **The package where most of the Swingers reside.** | javax.swing |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: BE the Compiler
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the Compiler”](#be_the_compiler-id00003))
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0507-01.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Pool Puzzle”](#pool_puzzle-id00006))
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-01.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Amazing, Shrinking, Blue Rectangle.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0508-01.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
