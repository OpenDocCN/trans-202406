- en: 'Chapter 15\. Work on Your Swing: Using Swing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0509-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Swing is easy.** Unless you actually *care* where things end up on the screen.
    Swing code *looks* easy, but then you compile it, run it, look at it, and think,
    “hey, *that’s* not supposed to go *there*.” The thing that makes it *easy* to
    *code* is the thing that makes it *hard* to *control*—the **Layout Manager**.
    Layout Manager objects control the size and location of the widgets in a Java
    GUI. They do a ton of work on your behalf, but you won’t always like the results.
    You want two buttons to be the same size, but they aren’t. You want the text field
    to be three inches long, but it’s nine. Or one. And *under* the label instead
    of *next* to it. But with a little work, you can get layout managers to submit
    to your will. Learning a little Swing will give you a head start for most GUI
    programming you’ll ever do. Wanna write an Android app? Working through this chapter
    will give you a head start.'
  prefs: []
  type: TYPE_NORMAL
- en: Swing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Component*** is the more correct term for what we’ve been calling a *widget*.
    The *things* you put in a GUI. *The things a user sees and interacts with*. Text
    fields, buttons, scrollable lists, radio buttons, etc., are all components. In
    fact, they all extend `**javax.swing.JComponent**`.'
  prefs: []
  type: TYPE_NORMAL
- en: Components can be nested
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swing, virtually *all* components are capable of holding other components.
    In other words, *you can stick just about anything into anything else*. But most
    of the time, you’ll add *user interactive* components such as buttons and lists
    into *background* components (often called containers) such as frames and panels.
    Although it’s *possible* to put, say, a panel inside a button, that’s pretty weird
    and won’t win you any usability awards.
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of JFrame, though, the distinction between *interactive*
    components and *background* components is artificial. A JPanel, for example, is
    usually used as a background for grouping other components, but even a JPanel
    can be interactive. Just as with other components, you can register for the JPanel’s
    events including mouse clicks and keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A widget is technically a Swing Component. Almost everything you can stick
    in a GUI extends from javax.swing.JComponent.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Four steps to making a GUI (review)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Make a window (a JFrame)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '`**JFrame frame = new JFrame();**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) Make a component (button, text field, etc.)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '`**JButton button = new JButton("click me");**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) Add the component to the frame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**frame.getContentPane().add(BorderLayout.EAST, button);**`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/4.png) Display it (give it a size and make it visible)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '| Put interactive components: | Into background components: |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/f0510-02.png) | ![Images](Images/f0510-03.png) |'
  prefs: []
  type: TYPE_TB
- en: Layout Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0511-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A layout manager is a Java object associated with a particular component, almost
    always a *background* component. The layout manager controls the components contained
    *within* the component the layout manager is associated with. In other words,
    if a frame holds a panel, and the panel holds a button, the panel’s layout manager
    controls the size and placement of the button, while the frame’s layout manager
    controls the size and placement of the panel. The button, on the other hand, doesn’t
    need a layout manager because the button isn’t holding other components.
  prefs: []
  type: TYPE_NORMAL
- en: If a panel holds five things, the size and location of the five things in the
    panel are all controlled by the panel’s layout manager. If those five things,
    in turn, hold *other* things (e.g., if any of those five things are panels or
    other containers that hold other things), then those *other* things are placed
    according to the layout manager of the thing holding them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we say *hold,* we really mean *add* as in, a panel *holds* a button because
    the button was *added* to the panel using something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**myPanel.add(button);**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Layout managers come in several flavors, and each background component can
    have its own layout manager. Layout managers have their own policies to follow
    when building a layout. For example, one layout manager might insist that all
    components in a panel must be the same size, arranged in a grid, while another
    layout manager might let each component choose its own size but stack them vertically.
    Here’s an example of nested layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0511-03.png)'
  prefs: []
  type: TYPE_IMG
- en: How does the layout manager decide?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Different layout managers have different policies for arranging components
    (like, arrange in a grid, make them all the same size, stack them vertically,
    etc.), but the components being laid out do get at least some small say in the
    matter. In general, the process of laying out a background component looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0512-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**A layout scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Make a panel and add three buttons to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) The panel’s layout manager asks each button how big
    that button prefers to be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) The panel’s layout manager uses its layout policies
    to decide whether it should respect all, part, or none of the buttons’ preferences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/4.png) Add the panel to a frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/5.png) The frame’s layout manager asks the panel how big the
    panel prefers to be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/6.png) The frame’s layout manager uses its layout policies
    to decide whether it should respect all, part, or none of the panel’s preferences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different layout managers have different policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some layout managers respect the size the component wants to be. If the button
    wants to be 30 pixels by 50 pixels, that’s what the layout manager allocates for
    that button. Other layout managers respect only part of the component’s preferred
    size. If the button wants to be 30 pixels by 50 pixels, it’ll be 30 pixels by
    however wide the button’s background *panel* is. Still other layout managers respect
    the preference of only the *largest* of the components being laid out, and the
    rest of the components in that panel are all made that same size. In some cases,
    the work of the layout manager can get very complex, but most of the time you
    can figure out what the layout manager will probably do, once you get to know
    that layout manager’s policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Big Three layout managers: border, flow, and box'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**BorderLayout**'
  prefs: []
  type: TYPE_NORMAL
- en: A BorderLayout manager divides a background component into five regions. You
    can add only one component per region to a background controlled by a BorderLayout
    manager. Components laid out by this manager usually don’t get to have their preferred
    size. **BorderLayout is the default layout manager for a frame!**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0513-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**FlowLayout**'
  prefs: []
  type: TYPE_NORMAL
- en: A FlowLayout manager acts kind of like a word processor, except with components
    instead of words. Each component is the size it wants to be, and they’re laid
    out left to right in the order that they’re added, with “word wrap” turned on.
    So when a component won’t fit horizontally, it drops to the next “line” in the
    layout. **FlowLayout is the default layout manager for a panel!**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0513-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**BoxLayout**'
  prefs: []
  type: TYPE_NORMAL
- en: A BoxLayout manager is like FlowLayout in that each component gets to have its
    own size, and the components are placed in the order in which they’re added. But,
    unlike FlowLayout, a BoxLayout manager can stack the components vertically (or
    arrange them horizontally, but usually we’re just concerned with vertically).
    It’s like a FlowLayout but instead of having automatic “component wrapping,” you
    can insert a sort of “component return key” and **force** the components to start
    a new line.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0513-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**BorderLayout cares about five regions: east, west, north, south, and center**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0514-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Let’s add a button to the east region:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0514-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Watch what happens when we give the button more characters...**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0515-01.png)![image](Images/f0515-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Let’s try a button in the NORTH region**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0516-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Now let’s make the button ask to be taller**'
  prefs: []
  type: TYPE_NORMAL
- en: How do we do that? The button is already as wide as it can ever be—as wide as
    the frame. But we can try to make it taller by giving it a bigger font.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0516-03.png)![image](Images/f0516-04.png)![image](Images/f0517-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**But what happens in the center region?**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The center region gets whatever’s left!**'
  prefs: []
  type: TYPE_NORMAL
- en: (except in one special case we’ll look at later)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0517-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**FlowLayout cares about the flow of the components: left to right, top to
    bottom, in the order they were added.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0518-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Let’s add a panel to the east region:**'
  prefs: []
  type: TYPE_NORMAL
- en: A JPanel’s layout manager is FlowLayout, by default. When we add a panel to
    a frame, the size and placement of the panel are still under the BorderLayout
    manager’s control. But anything *inside* the *panel* (in other words, components
    added to the panel by calling `**panel.add(aComponent)**`) are under the panel’s
    FlowLayout manager’s control. We’ll start by putting an empty panel in the frame’s
    east region, and on the next pages we’ll add things to the panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0518-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Let’s add a button to the panel**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0519-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**What happens if we add TWO buttons to the panel?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0520-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**BoxLayout to the rescue!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It keeps components stacked, even if there’s room to put them side by side.**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0521-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Unlike FlowLayout, BoxLayout can force a “new line” to make the components
    wrap to the next line, even if there’s room for them to fit horizontally.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But now you’ll have to change the panel’s layout manager from the default FlowLayout
    to BoxLayout.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0521-02.png)![image](Images/f0521-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Playing with Swing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve learned the basics of layout managers, so now let’s try out a few of
    the most common components: a text field, scrolling text area, checkbox, and list.
    We won’t show you the whole darn API for each of these, just a few highlights
    to get you started. If you do want to find out more, read [*Java Swing*](https://www.oreilly.com/library/view/java-swing-2nd/0596004087/)
    by Dave Wood, Marc Loy, and Robert Eckstein.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0523-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**How to use it**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Get text out of it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.out.println(field.getText());`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) Put text in it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0523-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) Select/Highlight the text in the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/5.png) Put the cursor back in the field (so the user can just
    start typing)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**JTextArea**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike JTextField, JTextArea can have more than one line of text. It takes a
    little configuration to make one, because it doesn’t come out of the box with
    scroll bars or line wrapping. To make a JTextArea scroll, you have to stick it
    in a JScrollPane. A JScrollPane is an object that really loves to scroll and will
    take care of the text area’s scrolling needs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0524-01.png)![image](Images/f0524-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**JTextArea example**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0525-02.png)![image](Images/f0525-01.png)![image](Images/f0526-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Constructor**'
  prefs: []
  type: TYPE_NORMAL
- en: '`JCheckBox check = new JCheckBox("Goes to 11");`'
  prefs: []
  type: TYPE_NORMAL
- en: '**How to use it**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Listen for an item event (when it’s selected or deselected)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '`check.addItemListener(this);`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) Handle the event (and find out whether or not it’s
    selected)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) Select or deselect it in code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![image](Images/f0527-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*JList constructor takes an array of any object type. They don’t have to be
    Strings, but a String representation will appear in the list.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0527-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is just like with JTextArea—you make a JScrollPane (and give it the list),
    and then add the scroll pane (NOT the list) to the panel.
  prefs: []
  type: TYPE_NORMAL
- en: '**How to use it**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Make it have a vertical scrollbar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/2.png) Set the number of lines to show before scrolling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) Restrict the user to selecting only ONE thing at a
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/4.png) Register for list selection events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/5.png) Handle events (find out which thing in the list was
    selected)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![image](Images/f0527-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Code Kitchen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0528-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**This part’s optional. We’re making the full BeatBox, GUI and all. In [Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr),
    Saving Objects, we’ll learn how to save and restore drum patterns. Finally, in
    [Chapter 17](ch17.xhtml#make_a_connection_networking_and_threads), Make a Connection,
    we’ll turn the BeatBox into a working chat client.**'
  prefs: []
  type: TYPE_NORMAL
- en: Making the BeatBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the full code listing for this version of the BeatBox, with buttons
    for starting, stopping, and changing the tempo. The code listing is complete,
    and fully annotated, but here’s the overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Build a GUI that has 256 checkboxes (JCheckBox) that
    start out unchecked, 16 labels (JLabel) for the instrument names, and four buttons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) Register an ActionListener for each of the four buttons.
    We don’t need listeners for the individual checkboxes, because we aren’t trying
    to change the pattern sound dynamically (i.e., as soon as the user checks a box).
    Instead, we wait until the user hits the “start” button, and then walk through
    all 256 checkboxes to get their state and make a MIDI track.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) Set up the MIDI system (you’ve done this before) including
    getting a Sequencer, making a Sequence, and creating a track. We are using a sequencer
    method, setLoopCount(), that allows you to specify how many times you want a sequence
    to loop. We’re also using the sequence’s tempo factor to adjust the tempo up or
    down, and maintain the new tempo from one iteration of the loop to the next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/4.png) When the user hits “start,” the real action begins.
    The event-handling method for the “start” button calls the buildTrackAndStart()
    method. In that method, we walk through all 256 checkboxes (one row at a time,
    a single instrument across all 16 beats) to get their state, and then use the
    information to build a MIDI track (using the handy makeEvent() method we used
    in the previous chapter). Once the track is built, we start the sequencer, which
    keeps playing (because we’re looping it) until the user hits “stop.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0530-01.png)![image](Images/f0531-01.png)![image](Images/f0532-01.png)![image](Images/f0533-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Which code goes with which layout?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Five of the six screens below were made from one of the code fragments on the
    opposite page. Match each of the five code fragments with the layout that fragment
    would produce.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0534-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**![Images](Images/arr.png) Answers in [“GUI-Cross”](#gui-cross_left_parenthesisfrom_page_536r).**'
  prefs: []
  type: TYPE_NORMAL
- en: Code Fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: GUI-Cross
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0536-01.png)![image](Images/f0536-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You can do it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Across**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Artist’s sandbox
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Border’s catchall
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Java look
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Generic waiter
  prefs: []
  type: TYPE_NORMAL
- en: 11\. A happening
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Apply a widget
  prefs: []
  type: TYPE_NORMAL
- en: 15\. JPanel’s default
  prefs: []
  type: TYPE_NORMAL
- en: 16\. Polymorphic test
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Shake it, baby
  prefs: []
  type: TYPE_NORMAL
- en: 21\. Lots to say
  prefs: []
  type: TYPE_NORMAL
- en: 23\. Choose many
  prefs: []
  type: TYPE_NORMAL
- en: 25\. Button’s pal
  prefs: []
  type: TYPE_NORMAL
- en: 26\. Home of actionPerformed
  prefs: []
  type: TYPE_NORMAL
- en: '**Down**'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Swing’s dad
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Frame’s purview
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Help’s home
  prefs: []
  type: TYPE_NORMAL
- en: 6\. More fun than text
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Component slang
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Romulin command
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Arrange
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Border’s top
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Manager’s rules
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Source’s behavior
  prefs: []
  type: TYPE_NORMAL
- en: 15\. Border by default
  prefs: []
  type: TYPE_NORMAL
- en: 18\. User’s behavior
  prefs: []
  type: TYPE_NORMAL
- en: 19\. Inner’s squeeze
  prefs: []
  type: TYPE_NORMAL
- en: 20\. Backstage widget
  prefs: []
  type: TYPE_NORMAL
- en: 22\. Classic Mac look
  prefs: []
  type: TYPE_NORMAL
- en: 24\. Border’s right
  prefs: []
  type: TYPE_NORMAL
- en: '**![Images](Images/arr.png) Answers in [“GUI-Cross”](#gui-cross_left_parenthesisfrom_page_536r).**'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Which code goes with which layout?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Which code goes with which layout?”](#which_code_goes_with_which_layoutquestio))
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Images](Images/f0537-01.png) | ![Images](Images/c.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Images](Images/f0537-03.png) | ![Images](Images/d.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Images](Images/f0537-05.png) | ![Images](Images/e.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Images](Images/f0537-07.png) | ![Images](Images/a.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Images](Images/f0537-09.png) | ![Images](Images/b.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: GUI-Cross
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“GUI-Cross”](#gui_cross))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0538-01.png)![image](Images/f0538-02.png)'
  prefs: []
  type: TYPE_IMG
