- en: Chapter 5\. Working with any
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type systems were traditionally binary affairs: either a language had a fully
    static type system or a fully dynamic one. TypeScript blurs the line, because
    its type system is *optional* and *gradual*. You can add types to parts of your
    program but not others.'
  prefs: []
  type: TYPE_NORMAL
- en: This is essential for migrating existing JavaScript codebases to TypeScript
    bit by bit ([Chapter 8](ch08.html#ch-migrate)). Key to this is the `any` type,
    which effectively disables type checking for parts of your code. It is both powerful
    and prone to abuse. Learning to use `any` wisely is essential for writing effective
    TypeScript. This chapter walks you through how to limit the downsides of `any`
    while still retaining its benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 38: Use the Narrowest Possible Scope for any Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you somehow know from context that `x` is assignable to `Bar` in addition
    to `Foo`, you can force TypeScript to accept this code in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of these, the second form is vastly preferable. Why? Because the `any` type
    is scoped to a single expression in a function argument. It has no effect outside
    this argument or this line. If code after the `processBar` call references `x`,
    its type will still be `Foo`, and it will still be able to trigger type errors,
    whereas in the first example its type is `any` until it goes out of scope at the
    end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stakes become significantly higher if you *return* `x` from this function.
    Look what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: An `any` return type is “contagious” in that it can spread throughout a codebase.
    As a result of our changes to `f`, an `any` type has quietly appeared in `g`.
    This would not have happened with the more narrowly scoped `any` in `f2`.
  prefs: []
  type: TYPE_NORMAL
- en: (This is a good reason to consider including explicit return type annotations,
    even when the return type can be inferred. It prevents an `any` type from “escaping.”
    See discussion in [Item 19](ch03.html#avoid-inferable).)
  prefs: []
  type: TYPE_NORMAL
- en: 'We used `any` here to silence an error that we believed to be incorrect. Another
    way to do this is with `@ts-ignore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This silences an error on the next line, leaving the type of `x` unchanged.
    Try not to lean too heavily on `@ts-ignore`: the type checker usually has a good
    reason to complain. It also means that if the error on the next line changes to
    something more problematic, you won’t know.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also run into situations where you get a type error for just one property
    in a larger object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can silence errors like this by throwing an `as any` around the whole `config`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But this has the side effect of disabling type checking for the other properties
    (`a` and `b`) as well. Using a more narrowly scoped `any` limits the damage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make your uses of `any` as narrowly scoped as possible to avoid undesired loss
    of type safety elsewhere in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never return an `any` type from a function. This will silently lead to the loss
    of type safety for any client calling the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider `@ts-ignore` as an alternative to `any` if you need to silence one
    error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 39: Prefer More Precise Variants of any to Plain any'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `any` type encompasses all values that can be expressed in JavaScript. This
    is a vast set! It includes not just all numbers and strings, but all arrays, objects,
    regular expressions, functions, classes, and DOM elements, not to mention `null`
    and `undefined`. When you use an `any` type, ask whether you really had something
    more specific in mind. Would it be OK to pass in a regular expression or a function?
  prefs: []
  type: TYPE_NORMAL
- en: 'Often the answer is “no,” in which case you might be able to retain some type
    safety by using a more specific type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The latter version, which uses `any[]` instead of `any`, is better in three
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The reference to `array.length` in the function body is type checked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function’s return type is inferred as `number` instead of `any`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calls to `getLength` will be checked to ensure that the parameter is an array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you expect a parameter to be an array of arrays but don’t care about the
    type, you can use `any[][]`. If you expect some sort of object but don’t know
    what the values will be, you can use `{[key: string]: any}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also use the `object` type in this situation, which includes all
    non-primitive types. This is slightly different in that, while you can still enumerate
    keys, you can’t access the values of any of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If this sort of type fits your needs, you might also be interested in the `unknown`
    type. See [Item 42](#never-unknown).
  prefs: []
  type: TYPE_NORMAL
- en: 'Avoid using `any` if you expect a function type. You have several options here
    depending on how specific you want to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these are more precise than `any` and hence preferable to it. Note the
    use of `any[]` as the type for the rest parameter in the last example. `any` would
    also work here but would be less precise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is perhaps the most common use of the `any[]` type.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use `any`, think about whether any JavaScript value is truly permissible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prefer more precise forms of `any` such as `any[]` or `{[id: string]: any}`
    or `() => any` if they more accurately model your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 40: Hide Unsafe Type Assertions in Well-Typed Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many functions whose type signatures are easy to write but whose implementations
    are quite difficult to write in type-safe code. And while writing type-safe implementations
    is a noble goal, it may not be worth the difficulty to deal with edge cases that
    you know don’t come up in your code. If a reasonable attempt at a type-safe implementation
    doesn’t work, use an unsafe type assertion hidden inside a function with the right
    type signature. Unsafe assertions hidden inside well-typed functions are much
    better than unsafe assertions scattered throughout your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to make a function cache its last call. This is a common technique
    for eliminating expensive function calls with frameworks like React.^([1](ch05.html#idm45331652259400))
    It would be nice to write a general `cacheLast` wrapper that adds this behavior
    to any function. Its declaration is easy to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an attempt at an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The error makes sense: TypeScript has no reason to believe that this very loose
    function has any relation to `T`. But you know that the type system will enforce
    that it’s called with the right parameters and that its return value is given
    the correct type. So you shouldn’t expect too many problems if you add a type
    assertion here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And indeed this will work great for any simple function you pass it. There are
    quite a few `any` types hidden in this implementation, but you’ve kept them out
    of the type signature, so the code that calls `cacheLast` will be none the wiser.
  prefs: []
  type: TYPE_NORMAL
- en: '(Is this actually safe? There are a few real problems with this implementation:
    it doesn’t check that the values of `this` for successive calls are the same.
    And if the original function had properties defined on it, then the wrapped function
    would not have these, so it wouldn’t have the same type. But if you know that
    these situations don’t come up in your code, this implementation is just fine.
    This function *can* be written in a type-safe way, but it is a more complex exercise
    that is left to the reader.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shallowEqual` function from the previous example operated on two arrays
    and is easy to type and implement. But the object variation is more interesting.
    As with `cacheLast`, it’s easy to write its type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation requires some care since there’s no guarantee that `a` and
    `b` have the same keys (see [Item 54](ch07.html#iterate-objects)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a bit surprising that TypeScript complains about the `b[k]` access despite
    your having just checked that `k in b` is true. But it does, so you have no choice
    but to cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This type assertion is harmless (since you’ve checked `k in b`), and you’re
    left with a correct function with a clear type signature. This is much preferable
    to scattering iteration and assertions to check for object equality throughout
    your code!
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes unsafe type assertions are necessary or expedient. When you need to
    use one, hide it inside a function with a correct signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 41: Understand Evolving any'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript a variable’s type is generally determined when it is declared.
    After this, it can be *refined* (by checking if it is `null`, for instance), but
    it cannot expand to include new values. There is one notable exception to this,
    however, involving `any` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, you might write a function to generate a range of numbers like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you convert this to TypeScript, it works exactly as you’d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Upon closer inspection, however, it’s surprising that this works! How does TypeScript
    know that the type of `out` is `number[]` when it’s initialized as `[]`, which
    could be an array of any type?
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting each of the three occurrences of `out` to reveal its inferred type
    starts to tell the story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The type of `out` starts as `any[]`, an undifferentiated array. But as we push
    `number` values onto it, its type “evolves” to become `number[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is distinct from narrowing ([Item 22](ch03.html#narrowing)). An array’s
    type can expand by pushing different elements onto it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With conditionals, the type can even vary across branches. Here we show the
    same behavior with a simple value, rather than an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A final case that triggers this “evolving any” behavior is if a variable is
    initially `null`. This often comes up when you set a value in a `try`/`catch`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, this behavior only happens when a variable’s type is implicitly
    `any` with `noImplicitAny` set! Adding an *explicit* `any` keeps the type constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This behavior can be confusing to follow in your editor since the type is only
    “evolved” *after* you assign or push an element. Inspecting the type on the line
    with the assignment will still show `any` or `any[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a value before any assignment to it, you’ll get an implicit any
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Put another way, “evolving” `any` types are only `any` when you *write* to them.
    If you try to *read* from them while they’re still `any`, you’ll get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit `any` types do not evolve through function calls. The arrow function
    here trips up inference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In cases like this, you may want to consider using an array’s `map` and `filter`
    methods to build arrays in a single statement and avoid iteration and evolving
    `any` entirely. See Items [23](ch03.html#all-at-once) and [27](ch03.html#well-typed-libs).
  prefs: []
  type: TYPE_NORMAL
- en: Evolving `any` comes with all the usual caveats about type inference. Is the
    correct type for your array really `(string|number)[]`? Or should it be `number[]`
    and you incorrectly pushed a `string`? You may still want to provide an explicit
    type annotation to get better error checking instead of using evolving `any`.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While TypeScript types typically only *refine*, implicit `any` and `any[]` types
    are allowed to *evolve*. You should be able to recognize and understand this construct
    where it occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For better error checking, consider providing an explicit type annotation instead
    of using evolving `any`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 42: Use unknown Instead of any for Values with an Unknown Type'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you want to write a YAML parser (YAML can represent the same set of
    values as JSON but allows a superset of JSON’s syntax). What should the return
    type of your `parseYAML` method be? It’s tempting to make it `any` (like `JSON.parse`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: But this flies in the face of [Item 38](#narrowest-any)’s advice to avoid “contagious”
    `any` types, specifically by not returning them from functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally you’d like your users to immediately assign the result to another type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the type declarations, though, the `book` variable would quietly get
    an `any` type, thwarting type checking wherever it’s used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A safer alternative would be to have `parseYAML` return an `unknown` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the `unknown` type, it helps to think about `any` in terms of
    assignability. The power and danger of `any` come from two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Any type is assignable to the `any` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `any` type is assignable to any other type.^([2](ch05.html#idm45331650850072))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of “thinking of types as sets of values” ([Item 7](ch02_split_000.html#types-as-sets)),
    `any` clearly doesn’t fit into the type system, since a set can’t simultaneously
    be both a subset and a superset of all other sets. This is the source of `any`’s
    power but also the reason it’s problematic. Since the type checker is set-based,
    the use of `any` effectively disables it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `unknown` type is an alternative to `any` that *does* fit into the type
    system. It has the first property (any type is assignable to `unknown`) but not
    the second (`unknown` is only assignable to `unknown` and, of course, `any`).
    The `never` type is the opposite: it has the second property (can be assigned
    to any other type) but not the first (nothing can be assigned to `never`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to access a property on a value with the `unknown` type is an error.
    So is attempting to call it or do arithmetic with it. You can’t do much with `unknown`,
    which is exactly the point. The errors about an `unknown` type will encourage
    you to add an appropriate type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These errors are more sensible. Since `unknown` is not assignable to other
    types, a type assertion is required. But it is also appropriate: we really do
    know more about the type of the resulting object than TypeScript does.'
  prefs: []
  type: TYPE_NORMAL
- en: '`unknown` is appropriate whenever you know that there will be a value but you
    don’t know its type. The result of `parseYAML` is one example, but there are others.
    In the GeoJSON spec, for example, the `properties` property of a Feature is a
    grab-bag of anything JSON serializable. So `unknown` makes sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A type assertion isn’t the only way to recover a type from an `unknown` object.
    An `instanceof` check will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a user-defined type guard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript requires quite a bit of proof to narrow an `unknown` type: in order
    to avoid errors on the `in` checks, you first have to demonstrate that `val` is
    an object type and that it is non-`null` (since `typeof null === ''object''`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll sometimes see a generic parameter used instead of `unknown`. You could
    have declared the `safeParseYAML` function this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is generally considered bad style in TypeScript, however. It looks different
    than a type assertion, but is functionally the same. Better to just return `unknown`
    and force your users to use an assertion or narrow to the type they want.
  prefs: []
  type: TYPE_NORMAL
- en: '`unknown` can also be used instead of `any` in “double assertions”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: These are functionally equivalent, but the `unknown` form has less risk if you
    do a refactor and break up the two assertions. In that case the `any` could escape
    and spread. If the `unknown` type escapes, it will probably just produce an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final note, you may see code that uses `object` or `{}` in a similar way
    to how `unknown` has been described in this item. They are also broad types but
    are slightly narrower than `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `{}` type consists of all values except `null` and `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `object` type consists of all non-primitive types. This doesn’t include
    `true` or `12` or `"foo"` but does include objects and arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use of `{}` was more common before the `unknown` type was introduced. Uses
    today are somewhat rare: only use `{}` instead of `unknown` if you really do know
    that `null` and `undefined` aren’t possibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `unknown` type is a type-safe alternative to `any`. Use it when you know
    you have a value but do not know what its type is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `unknown` to force your users to use a type assertion or do type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the difference between `{}`, `object`, and `unknown`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 43: Prefer Type-Safe Approaches to Monkey Patching'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most famous features of JavaScript is that its objects and classes
    are “open” in the sense that you can add arbitrary properties to them. This is
    occasionally used to create global variables on web pages by assigning to `window`
    or `document`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'or to attach data to DOM elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This style is particularly common with code that uses jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even attach properties to the prototypes of built-ins, with sometimes
    surprising results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These approaches are generally not good designs. When you attach data to `window`
    or a DOM node, you are essentially turning it into a global variable. This makes
    it easy to inadvertently introduce dependencies between far-flung parts of your
    program and means that you have to think about side effects whenever you call
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding TypeScript introduces another problem: while the type checker knows
    about built-in properties of `Document` and `HTMLElement`, it certainly doesn’t
    know about the ones you’ve added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The most straightforward way to fix this error is with an `any` assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This satisfies the type checker, but, as should be no surprise by now, it has
    some downsides. As with any use of `any`, you lose type safety and language services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The best solution is to move your data out of `document` or the DOM. But if
    you can’t (perhaps you’re using a library that requires it or are in the process
    of migrating a JavaScript application), then you have a few next-best options
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'One is to use an augmentation, one of the special abilities of `interface`
    ([Item 13](ch02_split_001.html#type-vs-interface)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an improvement over using `any` in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: You get type safety. The type checker will flag misspellings or assignments
    of the wrong type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can attach documentation to the property ([Item 48](ch06.html#use-tsdoc)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get autocomplete on the property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a record of precisely what the monkey patch is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a module context (i.e., a TypeScript file that uses `import` / `export`),
    you’ll need to add a `declare global` to make this work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The main issues with using an augmentation have to do with scope. First, the
    augmentation applies globally. You can’t hide it from other parts of your code
    or from libraries. And second, if you assign the property while your application
    is running, there’s no way to introduce the augmentation only after this has happened.
    This is particularly problematic when you patch HTML Elements, where some elements
    on the page will have the property and some will not. For this reason, you might
    want to declare the property to be `string|undefined`. This is more accurate,
    but will make the type less convenient to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach is to use a more precise type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript is OK with the type assertion because `Document` and `MonkeyDocument`
    share properties ([Item 9](ch02_split_000.html#prefer-declarations-to-assertions)).
    And you get type safety in the assignment. The scope issues are also more manageable:
    there’s no global modification of the `Document` type, just the introduction of
    a new type (which is only in scope if you import it). You have to write an assertion
    (or introduce a new variable) whenever you reference the monkey-patched property.
    But you can take that as encouragement to refactor into something more structured.
    Monkey patching shouldn’t be *too* easy!'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prefer structured code to storing data in globals or on the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you must store data on built-in types, use one of the type-safe approaches
    (augmentation or asserting a custom interface).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the scoping issues of augmentations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Are you safe from the problems associated with any types once you’ve added
    type annotations for values with implicit `any` types and enabled `noImplicitAny`?
    The answer is “no”; `any` types can still enter your program in two main ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Explicit* `any` types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you follow the advice of Items [38](#narrowest-any) and [39](#specific-any),
    making your `any` types both narrow and specific, they remain `any` types. In
    particular, types like `any[]` and `{[key: string]: any}` become plain `any`s
    once you index into them, and the resulting `any` types can flow through your
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: From third-party type declarations
  prefs: []
  type: TYPE_NORMAL
- en: 'This is particularly insidious since `any` types from an `@types` declaration
    file enter silently: even though you have `noImplicitAny` enabled and you never
    typed `any`, you still have `any` types flowing through your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the negative effects `any` types can have on type safety and developer
    experience ([Item 5](ch01.html#any)), it’s a good idea to keep track of the number
    of them in your codebase. There are many ways to do this, including the `type-coverage`
    package on npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This means that, of the 10,117 symbols in this project, 9,985 (98.69%) had a
    type other than `any` or an alias to `any`. If a change inadvertently introduces
    an `any` type and it flows through your code, you’ll see a corresponding drop
    in this percentage.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways this percentage is a way of keeping score on how well you’ve followed
    the advice of the other items in this chapter. Using narrowly scoped `any` will
    reduce the number of symbols with `any` types, and so will using more specific
    forms like `any[]`. Tracking this numerically helps you make sure things only
    get better over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even collecting type coverage information once can be informative. Running
    `type-coverage` with the `--detail` flag will print where every `any` type occurs
    in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: These are worth investigating because they’re likely to turn up sources of `any`s
    that you hadn’t considered. Let’s look at a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit `any` types are often the result of choices you made for expediency
    earlier on. Perhaps you were getting a type error that you didn’t want to take
    the time to sort out. Or maybe the type was one that you hadn’t written out yet.
    Or you might have just been in a rush.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type assertions with `any` can prevent types from flowing where they otherwise
    would. Perhaps you’ve built an application that works with tabular data and needed
    a single-parameter function that built up some kind of column description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `utils.buildColumnInfo` function returned `any` at some point. As a reminder,
    you added a comment and an explicit “: any” annotation to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: However, in the intervening months you’ve also added a type for `ColumnInfo`,
    and `utils.buildColumnInfo` no longer returns `any`. The `any` annotation is now
    throwing away valuable type information. Get rid of it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Third-party `any` types can come in a few forms, but the most extreme is when
    you give an entire module an `any` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can import anything from `my-module` without error. These symbols all
    have `any` types and will lead to more `any` types if you pass values through
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since the usage looks identical to a well-typed module, it’s easy to forget
    that you stubbed out the module. Or maybe a coworker did it and you never knew
    in the first place. It’s worth revisiting these from time to time. Maybe there
    are official type declarations for the module. Or perhaps you’ve gained enough
    understanding of the module to write types yourself and contribute them back to
    the community.
  prefs: []
  type: TYPE_NORMAL
- en: Another common source of `any`s with third-party declarations is when there’s
    a bug in the types. Maybe the declarations didn’t follow the advice of [Item 29](ch04.html#loose-accept-strict-produce)
    and declared a function to return a union type when in fact it returns something
    much more specific. When you first used the function this didn’t seem worth fixing
    so you used an `any` assertion. But maybe the declarations have been fixed since
    then. Or maybe it’s time to fix them yourself!
  prefs: []
  type: TYPE_NORMAL
- en: The considerations that led you to use an `any` type might not apply any more.
    Maybe there’s a type you can plug in now where previously you used `any`. Maybe
    an unsafe type assertion is no longer necessary. Maybe the bug in the type declarations
    you were working around has been fixed. Tracking your type coverage highlights
    these choices and encourages you to keep revisiting them.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even with `noImplicitAny` set, `any` types can make their way into your code
    either through explicit `any`s or third-party type declarations (`@types`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider tracking how well-typed your program is. This will encourage you to
    revisit decisions about using `any` and increase type safety over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch05.html#idm45331652259400-marker)) If you are using React, you should
    use the built-in `useMemo` hook, rather than rolling your own.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#idm45331650850072-marker)) With the exception of `never`.
  prefs: []
  type: TYPE_NORMAL
