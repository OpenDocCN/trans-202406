<html><head></head><body><section data-pdf-bookmark="Chapter 2. Predictable Demands" data-type="chapter" epub:type="chapter"><div class="chapter" id="PredictableDemands">&#13;
<h1><span class="label">Chapter 2. </span>Predictable Demands</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="Predictable Demands" data-type="indexterm" id="preddem02"/> foundation of successful application deployment, management, and coexistence on a shared cloud environment is dependent on identifying and declaring the application resource requirements and runtime dependencies. This <em>Predictable Demands</em> pattern indicates how you should declare application requirements, whether they are hard runtime dependencies or resource requirements. Declaring your requirements is essential for Kubernetes to find the right place for your application within the cluster.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902098546688">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>Kubernetes<a data-primary="problems" data-secondary="application requirements, declaring" data-type="indexterm" id="idm45902098668832"/><a data-primary="application requirements, declaring" data-type="indexterm" id="idm45902098667856"/> can manage applications written in different programming languages as long as the application can be run in a container. However, different languages have different resource requirements. Typically, a compiled language runs faster and often requires less memory compared to just-in-time runtimes or interpreted languages. Considering that many modern programming languages in the same category have similar resource requirements, from a resource consumption point of view, more important aspects are the domain, the business logic of an application, and the actual implementation details.</p>&#13;
&#13;
<p>Besides resource requirements, application runtimes also have dependencies on platform-managed capabilities like data storage or application configuration.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902098666448">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>Knowing the runtime requirements for a container is important mainly for two reasons. First, with all the runtime dependencies defined and resource demands envisaged, Kubernetes can make intelligent decisions about where to place a container on the cluster for the most efficient hardware utilization. In an environment with shared resources among a large number of processes with different priorities, the only way to ensure a successful coexistence is to know the demands of every process in advance. However, intelligent placement is only one side of the coin.</p>&#13;
&#13;
<p>Container resource profiles are also essential for<a data-primary="Services" data-secondary="capacity planning" data-type="indexterm" id="idm45902105215136"/> capacity planning. Based on the particular service demands and the total number of services, we can do some capacity planning for different environments and come up with the most cost-effective host profiles to satisfy the entire cluster demand. Service resource profiles and capacity planning go hand in hand for successful cluster management in the long term.</p>&#13;
&#13;
<p>Before diving into resource profiles, let’s look at declaring runtime dependencies.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Runtime Dependencies" data-type="sect2"><div class="sect2" id="idm45902105213520">&#13;
<h2>Runtime Dependencies</h2>&#13;
&#13;
<p>One of the most common<a data-primary="dependencies" data-type="indexterm" id="idm45902105212192"/><a data-primary="runtime dependencies" data-type="indexterm" id="idm45902106051536"/> runtime dependencies is file storage for saving application state. Container<a data-primary="containers" data-secondary="runtime dependencies" data-type="indexterm" id="idm45902106050736"/> filesystems are ephemeral and are lost when a container is shut down. Kubernetes offers volume as a Pod-level storage utility that survives container restarts.</p>&#13;
&#13;
<p>The most straightforward type of volume is<a data-primary="emptyDir volume type" data-type="indexterm" id="idm45902106049280"/> <code>emptyDir</code>, which lives as long as the Pod lives. When the Pod is removed, its content is also lost. The volume needs to be backed by another kind of storage mechanism to survive Pod restarts. If your application needs to read or write files to such long-lived storage, you must declare that dependency explicitly in the container definition using volumes, as shown in <a data-type="xref" href="#ex-dependency-pv">Example 2-1</a>.</p>&#13;
<div data-type="example" id="ex-dependency-pv">&#13;
<h5><span class="label">Example 2-1. </span>Dependency on a PersistentVolume</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">/logs</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">log-volume</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">log-volume</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">persistentVolumeClaim</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_predictable_demands_CO1-1" id="co_predictable_demands_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">claimName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator-log</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_predictable_demands_CO1-1" id="callout_predictable_demands_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Dependency of a PersistentVolumeClaim (PVC) to be present and bound.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The<a data-primary="scheduler" data-secondary="role of" data-type="indexterm" id="idm45902098515408"/> scheduler evaluates the kind of volume a Pod requires, which affects where the Pod gets placed. If the Pod needs a volume that is not provided by any node on the cluster, the Pod is not scheduled at all. Volumes are an example of a runtime dependency that affects what kind of infrastructure a Pod can run and whether the Pod can be scheduled at all.</p>&#13;
&#13;
<p>A similar dependency happens when you ask Kubernetes to expose a container port on a specific port on the host system through<a data-primary="hostPort" data-type="indexterm" id="idm45902098513920"/> <code>hostPort</code>. The usage of a <code>hostPort</code> creates another runtime dependency on the nodes and limits where a Pod can be scheduled. <code>hostPort</code> reserves the port on each node in the cluster and is limited to a maximum of one Pod scheduled per node. Because of port conflicts, you can scale to as many Pods as there are nodes in the Kubernetes cluster.</p>&#13;
&#13;
<p>Configurations<a data-primary="configuration information" data-secondary="declaring application requirements" data-type="indexterm" id="idm45902106367120"/> are another type of dependency. Almost every application needs some configuration information, and the recommended solution offered by Kubernetes is through<a data-primary="ConfigMaps" data-secondary="dependencies on" data-type="indexterm" id="idm45902106366048"/> ConfigMaps. Your services need to have a strategy for consuming settings—either through environment variables or the filesystem. In either case, this introduces a runtime dependency of your container to the named ConfigMaps. If not all of the expected ConfigMaps are created, the containers are scheduled on a node, but they do not start up.</p>&#13;
&#13;
<p>Similar to ConfigMaps, <a data-primary="Secrets" data-secondary="dependencies on" data-type="indexterm" id="idm45902106364592"/>Secrets offer a slightly more secure way of distributing environment-specific configurations to a container. The way to consume a Secret is the same as it is for ConfigMaps, and using a Secret introduces the same kind of dependency from a container to a namespace.</p>&#13;
&#13;
<p>ConfigMaps<a data-primary="Configuration Resource" data-type="indexterm" id="idm45902106363072"/><a data-primary="Configuration Resource" data-secondary="Predictable Demands" data-type="indexterm" id="idm45902106362336"/> and Secrets are explained in more detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#ConfigurationResource">Chapter 20, “Configuration Resource”</a>, and <a data-type="xref" href="#ex-dependency-configmap">Example 2-2</a> shows how these resources are used as runtime &#13;
<span class="keep-together">dependencies.</span></p>&#13;
<div data-type="example" id="ex-dependency-configmap">&#13;
<h5><span class="label">Example 2-2. </span>Dependency on a ConfigMap</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PATTERN</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w">  </code><a class="co" href="#callout_predictable_demands_CO2-1" id="co_predictable_demands_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator-config</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pattern</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_predictable_demands_CO2-1" id="callout_predictable_demands_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Mandatory dependency on the ConfigMap <code>random-generator-config</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>While the creation of ConfigMap and Secret objects are simple deployment tasks we have to perform, cluster nodes provide storage and port numbers. Some of these dependencies limit where a Pod gets scheduled (if anywhere at all), and other dependencies may prevent the Pod from starting up. When designing your containerized applications with such dependencies, always consider the runtime constraints they will create later.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Resource Profiles" data-type="sect2"><div class="sect2" id="idm45902098664640">&#13;
<h2>Resource Profiles</h2>&#13;
&#13;
<p>Specifying<a data-primary="resource profiles" data-type="indexterm" id="idm45902098649616"/> container dependencies such as ConfigMap, Secret, and volumes is straightforward. We need some more thinking and experimentation for figuring out the resource requirements of a container. Compute resources in the context of Kubernetes are defined as something that can be requested by, allocated to, and consumed from a container. The resources are categorized as <em>compressible</em> (i.e., can be throttled, such as CPU or network bandwidth) and <em>incompressible</em> (i.e., cannot be throttled, such as memory).</p>&#13;
&#13;
<p>Making the distinction between compressible and incompressible resources is important. If your containers consume too many compressible resources such as CPU, they are throttled, but if they use too many incompressible resources (such as memory), they are killed (as there is no other way to ask an application to release allocated memory).</p>&#13;
&#13;
<p>Based on the nature and the implementation details of your application, you have to specify the minimum amount of resources that are needed (called <code>requests</code>) and the maximum amount it can grow up to (the <code>limits</code>). Every container definition can specify the amount of CPU and memory it needs in the form of a request and limit. At a high level, the concept of <code>requests</code>/<code>limits</code> is similar to soft/hard limits. For example, similarly, we define heap size for a Java application by using the <code>-Xms</code> and <code>-Xmx</code> command-line options.</p>&#13;
&#13;
<p>The<a data-primary="scheduler" data-secondary="requests amount" data-type="indexterm" id="idm45902106106832"/> <code>requests</code> amount (but not <code>limits</code>) is used by the scheduler when placing Pods to<a data-primary="nodes" data-secondary="resource profiles" data-type="indexterm" id="idm45902099878480"/> nodes. For a given Pod, the scheduler considers only nodes that still have enough capacity to accommodate the Pod and all of its containers by summing up the requested resource amounts. In that sense, the <code>requests</code> field of each container affects where a Pod can be scheduled or not. <a data-type="xref" href="#ex-resource-limits">Example 2-3</a> shows how such limits are specified for a Pod.</p>&#13;
<div class="less_space pagebreak-before" data-type="example" id="ex-resource-limits">&#13;
<h5><span class="label">Example 2-3. </span>Resource limits</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w">        </code><a class="co" href="#callout_predictable_demands_CO3-1" id="co_predictable_demands_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">100m</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">200Mi</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w">          </code><a class="co" href="#callout_predictable_demands_CO3-2" id="co_predictable_demands_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">200Mi</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_predictable_demands_CO3-1" id="callout_predictable_demands_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initial resource request for CPU and memory.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO3-2" id="callout_predictable_demands_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Upper limit until we want our application to grow at max. We don’t specify CPU limits by intention.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The following types of resources can be used as keys in the <code>requests</code> and <code>limits</code> specification:</p>&#13;
<dl>&#13;
<dt><code>memory</code></dt>&#13;
<dd>&#13;
<p>This<a data-primary="memory resource type" data-type="indexterm" id="idm45902103855744"/> type is for the heap memory demands of your application, including volumes of type <code>emptyDir</code> with the configuration <code>medium: Memory</code>. Memory resources are incompressible, so containers that exceed their configured memory limit will trigger the Pod to be evicted; i.e., it gets deleted and recreated potentially on a different node.</p>&#13;
</dd>&#13;
<dt><code>cpu</code></dt>&#13;
<dd>&#13;
<p>The<a data-primary="cpu resource type" data-type="indexterm" id="idm45902099594704"/> <code>cpu</code> type is used to specify the range of needed CPU cycles for your application. However, it is a compressible resource, which means that in an overcommit situation for a node, all assigned CPU slots of all running containers are throttled relative to their specified requests. Therefore, it is highly recommended that you set <code>requests</code> for the CPU resource but <em>no</em> <code>limits</code> so that they can benefit from all excess CPU resources that otherwise would be wasted.</p>&#13;
</dd>&#13;
<dt><code>ephemeral-storage</code></dt>&#13;
<dd>&#13;
<p>Every<a data-primary="ephemeral-storage resource type" data-type="indexterm" id="idm45902099590832"/> node has some filesystem space dedicated for ephemeral storage that holds logs and writable container layers. <code>emptyDir</code> volumes that are not stored in a memory filesystem also use ephemeral storage. With this request and limit type, you can specify the application’s minimal and maximal needs. &#13;
<span class="keep-together"><code>ephemeral-storage</code></span> resources are not compressible and will cause a Pod to be evicted from the node if it uses more storage than specified in its <code>limit</code>.</p>&#13;
</dd>&#13;
<dt><code>hugepage-&lt;size&gt;</code></dt>&#13;
<dd>&#13;
<p><em>Huge pages</em><a data-primary="hugepage resource type" data-type="indexterm" id="idm45902099257200"/> are large, contiguous pre-allocated pages of memory that can be mounted as volumes. Depending on your Kubernetes node configuration, several sizes of huge pages are available, like 2 MB and 1 GB pages. You can specify a request and limit for how many of a certain type of huge pages you want to consume (e.g., <code>hugepages-1Gi: 2Gi</code> for requesting two 1 GB huge pages). Huge pages can’t be overcommitted, so the request and limit must be the same.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Depending on whether you specify the <code>requests</code>, the <code>limits</code>, or both, the platform offers three types of<a data-primary="Pods" data-secondary="Quality of Service (QoS) levels" data-type="indexterm" id="idm45902099254448"/> Quality of Service (QoS):</p>&#13;
<dl>&#13;
<dt>Best-Effort</dt>&#13;
<dd>&#13;
<p>Pods<a data-primary="Quality of Service (QoS)" data-secondary="Best-Effort" data-type="indexterm" id="idm45902099251632"/><a data-primary="Best-Effort Quality of Service" data-type="indexterm" id="idm45902099250608"/> that do not have any requests and limits set for its containers have a QoS of <em>Best-Effort</em>. Such a <em>Best-Effort</em> Pod is considered the lowest priority and is most likely killed first when the node where the Pod is placed runs out of incompressible resources.</p>&#13;
</dd>&#13;
<dt>Burstable</dt>&#13;
<dd>&#13;
<p>A<a data-primary="Quality of Service (QoS)" data-secondary="Burstable" data-type="indexterm" id="idm45902098725024"/><a data-primary="Burstable Quality of Service" data-type="indexterm" id="idm45902098724048"/> Pod that defines an unequal amount for <code>requests</code> and <code>limits</code> values (and <code>limits</code> is larger than <code>requests</code>, as expected) are tagged as <em>Burstable</em>. Such a Pod has minimal resource guarantees but is also willing to consume more resources up to its <code>limit</code> when available. When the node is under incompressible resource pressure, these Pods are likely to be killed if no <em>Best-Effort</em> Pods remain.</p>&#13;
</dd>&#13;
<dt>Guaranteed</dt>&#13;
<dd>&#13;
<p>A<a data-primary="Quality of Service (QoS)" data-secondary="guaranteed" data-type="indexterm" id="idm45902098718848"/><a data-primary="guaranteed Quality of Service" data-type="indexterm" id="idm45902099097008"/> Pod that has an equal amount of <code>request</code> and <code>limit</code> resources belongs to the <em>Guaranteed</em> QoS category. These are the highest-priority Pods and are guaranteed not to be killed before <em>Best-Effort</em> and <em>Burstable</em> Pods. This QoS mode is the best option for your application’s memory resources, as it entails the least surprise and avoids out-of-memory triggered evictions.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>So the resource characteristics you define or omit for the containers have a direct impact on its QoS and define the relative importance of the Pod in the event of resource starvation. Define your Pod resource requirements with this consequence in mind.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902099093264">&#13;
<h1>Recommendations for CPU and Memory Resources</h1>&#13;
<p>While<a data-primary="CPU and memory demands" data-type="indexterm" id="idm45902099091968"/><a data-primary="memory limits" data-type="indexterm" id="idm45902099091232"/> you have many options for declaring the memory and CPU needs of your applications, we and others recommend the following rules:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>For memory, always set <code>requests</code> equal to <code>limits</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>For CPU, set <code>requests</code> but no <code>limits</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>See the blog post <a href="https://oreil.ly/HcMw5">“For the Love of God, Stop Using CPU Limits on Kubernetes”</a> for a more in-depth explanation of why you should not use <code>limits</code> for the CPU, and see the blog post <a href="https://oreil.ly/Lb_N9">“What Everyone Should Know About Kubernetes Memory Limits”</a> for more details about the recommended memory settings.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pod Priority" data-type="sect2"><div class="sect2" id="idm45902105554544">&#13;
<h2>Pod Priority</h2>&#13;
&#13;
<p>We<a data-primary="Pods" data-secondary="priority of" data-type="indexterm" id="idm45902105552848"/><a data-primary="Kubelet" data-secondary="Pod priority" data-type="indexterm" id="Kpodprior02"/> explained how container resource declarations also define Pods’ QoS and affect the order in which the Kubelet kills the container in a Pod in case of resource starvation. Two other related concepts are Pod priority and preemption. <em>Pod priority</em> allows you to indicate the importance of a Pod relative to other Pods, which affects the<a data-primary="scheduler" data-secondary="Pod order" data-type="indexterm" id="idm45902099736528"/> order in which Pods are scheduled. Let’s see that in action in <a data-type="xref" href="#ex-predictable-demands-pod-priority">Example 2-4</a>.</p>&#13;
<div data-type="example" id="ex-predictable-demands-pod-priority">&#13;
<h5><span class="label">Example 2-4. </span>Pod priority</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">scheduling.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PriorityClass</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">high-priority</code><code class="w">  </code><a class="co" href="#callout_predictable_demands_CO4-1" id="co_predictable_demands_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1000</code><code class="w">            </code><a class="co" href="#callout_predictable_demands_CO4-2" id="co_predictable_demands_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="nt">globalDefault</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w">   </code><a class="co" href="#callout_predictable_demands_CO4-3" id="co_predictable_demands_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">This</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">is</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">a</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">very</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">high-priority</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">Pod</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">class</code><code class="w">&#13;
</code><code class="nn">---</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">priorityClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">high-priority</code><code class="w">  </code><a class="co" href="#callout_predictable_demands_CO4-4" id="co_predictable_demands_CO4-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_predictable_demands_CO4-1" id="callout_predictable_demands_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The name of the priority class object.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO4-2" id="callout_predictable_demands_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The priority value of the object.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO4-3" id="callout_predictable_demands_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>globalDefault</code> set to <code>true</code> is used for Pods that do not specify a <code>priorityClassName</code>. Only one PriorityClass can have <code>globalDefault</code> set to <code>true</code>.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO4-4" id="callout_predictable_demands_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The priority class to use with this Pod, as defined in PriorityClass resource.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>We created a PriorityClass, a non-namespaced object for defining an integer-based priority. Our PriorityClass is named <code>high-priority</code> and has a priority of 1,000. Now we can assign this priority to Pods by its name as <code>priorityClassName:</code> &#13;
<span class="keep-together"><code>high-priority</code></span>. PriorityClass is a mechanism for indicating the importance of Pods relative to one another, where the higher value indicates more important Pods.</p>&#13;
&#13;
<p>Pod priority affects the order in which the scheduler places Pods on nodes. First, the priority admission controller uses the <code>priorityClassName</code> field to populate the priority value for new Pods. When multiple Pods are waiting to be placed, the scheduler sorts the queue of pending Pods by highest priority first. Any pending Pod is picked before any other pending Pod with lower priority in the scheduling queue, and if there are no constraints preventing it from scheduling, the Pod gets scheduled.</p>&#13;
&#13;
<p>Here comes the critical part. If there are no nodes with enough capacity to place a Pod, the scheduler can preempt (remove) lower-priority Pods from nodes to free up resources and place Pods with higher priority. As a result, the higher-priority Pod might be scheduled sooner than Pods with a lower priority if all other scheduling requirements are met. This algorithm effectively enables cluster administrators to control which Pods are more critical workloads and place them first by allowing the scheduler to evict Pods with lower priority to make room on a worker node for higher-priority Pods. If a Pod cannot be scheduled, the scheduler continues with the placement of other lower-priority Pods.</p>&#13;
&#13;
<p>Suppose you want your Pod to be scheduled with a particular priority but don’t want to evict any existing Pods. In that case, you can mark a PriorityClass with the field <code>preemptionPolicy: Never</code>. Pods assigned to this priority class will not trigger any eviction of running Pods but will still get scheduled according to their priority value.</p>&#13;
&#13;
<p>Pod QoS (discussed previously) and Pod priority are two orthogonal features that are not connected and have only a little overlap. QoS is used primarily by the Kubelet to preserve node stability when available compute resources are low. The Kubelet first considers QoS and then the PriorityClass of Pods before eviction. On the other hand, the scheduler eviction logic ignores the QoS of Pods entirely when choosing preemption targets. The scheduler attempts to pick a set of Pods with the lowest priority possible that satisfies the needs of higher-priority Pods waiting to be placed.</p>&#13;
&#13;
<p>When Pods have a priority specified, it can have an undesired effect on other Pods that are evicted. For example, while a Pod’s graceful termination policies are respected, the<a data-primary="Singleton Service" data-type="indexterm" id="idm45902105721008"/><a data-primary="Singleton Service" data-secondary="Predictable Demands" data-type="indexterm" id="idm45902105720304"/> PodDisruptionBudget as discussed in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.html#SingletonService">Chapter 10, “Singleton Service”</a>, is not guaranteed, which could break a lower-priority clustered application that relies on a quorum of Pods.</p>&#13;
&#13;
<p>Another concern is a malicious or uninformed user who creates Pods with the highest possible priority and evicts all other Pods. To prevent that, ResourceQuota<a data-primary="ResourceQuota" data-type="indexterm" id="idm45902100033856"/> has been extended to support PriorityClass, and higher-priority numbers are reserved for critical system-Pods that should not usually be preempted or evicted.</p>&#13;
&#13;
<p>In conclusion, Pod priorities should be used with caution because user-specified numerical priorities that guide the scheduler and Kubelet about which Pods to place or to kill are subject to gaming by users. Any change could affect many Pods and could prevent the platform from delivering predictable service-level agreements.<a data-primary="" data-startref="Kpodprior02" data-type="indexterm" id="idm45902100032640"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Project Resources" data-type="sect2"><div class="sect2" id="idm45902100031408">&#13;
<h2>Project Resources</h2>&#13;
&#13;
<p>Kubernetes<a data-primary="project resources" data-type="indexterm" id="idm45902100029760"/> is a self-service platform that enables developers to run applications as they see suitable on the designated isolated environments. However, working in a shared multitenanted platform also requires the presence of specific boundaries and control units to prevent some users from consuming all the platform’s resources. One such tool is ResourceQuota, which provides constraints for limiting the aggregated resource consumption in a namespace. With ResourceQuotas, the cluster administrators can limit the total sum of computing resources<a data-primary="CPU and memory demands" data-type="indexterm" id="idm45902100028896"/> (CPU, memory) and storage consumed. It can also limit the total number of objects (such as ConfigMaps, Secrets, Pods, or Services) created in a namespace. <a data-type="xref" href="#ex-predictable-demands-resourcequota">Example 2-5</a> shows an instance that limits the usage of certain resources. See the official Kubernetes documentation on <a href="https://oreil.ly/TLRMe">Resource Quotas</a> for the full list of supported resources for which you can restrict usage with ResourceQuotas.</p>&#13;
<div data-type="example" id="ex-predictable-demands-resourcequota">&#13;
<h5><span class="label">Example 2-5. </span>Definition of resource constraints</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ResourceQuota</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">object-counts</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w">   </code><a class="co" href="#callout_predictable_demands_CO5-1" id="co_predictable_demands_CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">hard</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">pods</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">4</code><code class="w">            </code><a class="co" href="#callout_predictable_demands_CO5-2" id="co_predictable_demands_CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">limits.memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5Gi</code><code class="w"> </code><a class="co" href="#callout_predictable_demands_CO5-3" id="co_predictable_demands_CO5-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_predictable_demands_CO5-1" id="callout_predictable_demands_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Namespace to which resource constraints are applied.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO5-2" id="callout_predictable_demands_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Allow four active Pods in this namespace.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO5-3" id="callout_predictable_demands_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The sum of all memory limits of all Pods in this namespace must not be more than 5 GB.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Another helpful tool in this area is<a data-primary="LimitRange" data-type="indexterm" id="idm45902099373472"/> LimitRange, which allows you to set resource usage limits for each type of resource. In addition to specifying the minimum and maximum permitted amounts for different resource types and the default values for these resources, it also allows you to control the ratio between the<a data-primary="scheduler" data-secondary="requests amount" data-type="indexterm" id="idm45902099372672"/> <code>requests</code> and <code>limits</code>, also known as the<a data-primary="overcommit level" data-type="indexterm" id="idm45902099370736"/> <em>overcommit level</em>.&#13;
<a data-type="xref" href="#ex-predictable-demands-limitrange">Example 2-6</a> shows a LimitRange and the possible configuration options.</p>&#13;
<div data-type="example" id="ex-predictable-demands-limitrange">&#13;
<h5><span class="label">Example 2-6. </span>Definition of allowed and default resource usage limits</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">LimitRange</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">limits</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">limits</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">min</code><code class="p">:</code><code class="w">                  </code><a class="co" href="#callout_predictable_demands_CO6-1" id="co_predictable_demands_CO6-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">250Mi</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500m</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">max</code><code class="p">:</code><code class="w">                  </code><a class="co" href="#callout_predictable_demands_CO6-2" id="co_predictable_demands_CO6-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2Gi</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">default</code><code class="p">:</code><code class="w">              </code><a class="co" href="#callout_predictable_demands_CO6-3" id="co_predictable_demands_CO6-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500Mi</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500m</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">defaultRequest</code><code class="p">:</code><code class="w">       </code><a class="co" href="#callout_predictable_demands_CO6-4" id="co_predictable_demands_CO6-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">250Mi</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">250m</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">maxLimitRequestRatio</code><code class="p">:</code><code class="w"> </code><a class="co" href="#callout_predictable_demands_CO6-5" id="co_predictable_demands_CO6-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">4</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Container</code><code class="w">       </code><a class="co" href="#callout_predictable_demands_CO6-6" id="co_predictable_demands_CO6-6"><img alt="6" src="assets/6.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_predictable_demands_CO6-1" id="callout_predictable_demands_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Minimum values for requests and limits.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO6-2" id="callout_predictable_demands_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Maximum values for requests and limits.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO6-3" id="callout_predictable_demands_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Default values for limits when no limits are specified.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO6-4" id="callout_predictable_demands_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Default values for requests when no requests are specified.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO6-5" id="callout_predictable_demands_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Maximum ratio limit/request, used to specify the allowed overcommit level. Here, the memory limit must not be larger than twice the memory request, and the CPU limit can be as high as four times the CPU request.</p></dd>&#13;
<dt><a class="co" href="#co_predictable_demands_CO6-6" id="callout_predictable_demands_CO6-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Type can be <code>Container</code>, <code>Pod</code>, (for all containers combined), or &#13;
<span class="keep-together"><code>PersistentVolumeClaim</code></span> (to specify the range for a request persistent volume).</p></dd>&#13;
</dl></div>&#13;
&#13;
<p class="pagebreak-before">LimitRanges help control the container<a data-primary="resource profiles" data-type="indexterm" id="idm45902100253664"/> resource profiles so that no containers require more resources than a cluster node can provide. LimitRanges can also prevent cluster users from creating containers that consume many resources, making the nodes not allocatable for other containers. Considering that the <code>requests</code> (and not <code>limits</code>) are the primary container characteristic the scheduler uses for placing, LimitRequestRatio allows you to control the amount of difference between the <code>requests</code> and <code>limits</code> of containers. A big combined gap between <code>requests</code> and <code>limits</code> increases the chances of overcommitting on the node and may degrade application performance when many containers simultaneously require more resources than initially requested.</p>&#13;
&#13;
<p>Keep in mind that other shared node-level resources such as process IDs (PIDs) can be exhausted before hitting any resource limits. Kubernetes allows you to reserve a number of node PIDs for the system use and ensure that they are never exhausted by user workloads. Similarly, Pod PID limits allow a cluster administrator to limit the number of processes running in a Pod. We are not reviewing these in details here as they are set as<a data-primary="Kubelet" data-secondary="configuration options" data-type="indexterm" id="idm45902100249888"/> Kubelet configurations options by cluster administrators and are not used by application developers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Capacity Planning" data-type="sect2"><div class="sect2" id="idm45902100248544">&#13;
<h2>Capacity Planning</h2>&#13;
&#13;
<p>Considering<a data-primary="capacity planning" data-type="indexterm" id="idm45902100246784"/> that containers may have different resource profiles in different environments, and a varied number of instances, it is evident that capacity planning for a multipurpose environment is not straightforward. For example, for best hardware utilization, on a nonproduction cluster, you may have mainly <em>Best-Effort</em> and <em>Burstable</em> containers. In such a dynamic environment, many containers are starting up and shutting down at the same time, and even if a container gets killed by the platform during resource starvation, it is not fatal. On the production cluster, where we want things to be more stable and predictable, the containers may be mainly of the <em>Guaranteed</em> type, and some may be <em>Burstable</em>. If a container gets killed, that is most likely a sign that the capacity of the cluster should be increased.</p>&#13;
&#13;
<p><a data-type="xref" href="#table-demands-service-example">Table 2-1</a> presents a few services with CPU and memory demands.</p>&#13;
<table id="table-demands-service-example">&#13;
<caption><span class="label">Table 2-1. </span>Capacity planning example</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Pod</th>&#13;
<th>CPU request</th>&#13;
<th>Memory request</th>&#13;
<th>Memory limit</th>&#13;
<th>Instances</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>A</p></td>&#13;
<td><p>500 m</p></td>&#13;
<td><p>500 Mi</p></td>&#13;
<td><p>500 Mi</p></td>&#13;
<td><p>4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>B</p></td>&#13;
<td><p>250 m</p></td>&#13;
<td><p>250 Mi</p></td>&#13;
<td><p>1000 Mi</p></td>&#13;
<td><p>2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>C</p></td>&#13;
<td><p>500 m</p></td>&#13;
<td><p>1000 Mi</p></td>&#13;
<td><p>2000 Mi</p></td>&#13;
<td><p>2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>D</p></td>&#13;
<td><p>500 m</p></td>&#13;
<td><p>500 Mi</p></td>&#13;
<td><p>500 Mi</p></td>&#13;
<td><p>1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Total</strong></p></td>&#13;
<td><p><strong>4000 m</strong></p></td>&#13;
<td><p><strong>5000 Mi</strong></p></td>&#13;
<td><p><strong>8500 Mi</strong></p></td>&#13;
<td><p><strong>9</strong></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Of course, in a real-life scenario, the more likely reason you are using a platform such as Kubernetes is that there are many more services to manage, some of which are about to retire, and some of which are still in the design and development phase. Even if it is a continually moving target, based on a similar approach as described previously, we can calculate the total amount of resources needed for all the services per environment.</p>&#13;
&#13;
<p>Keep in mind that in the different environments, there are different numbers of containers, and you may even need to leave some room for autoscaling, build jobs, infrastructure containers, and more. Based on this information and the infrastructure provider, you can choose the most cost-effective compute instances that provide the required resources.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902099198528">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>Containers are useful not only for process isolation and as a packaging format. With identified resource profiles, they are also the building blocks for successful capacity planning. Perform some early tests to discover the resource needs for each container, and use that information as a base for future capacity planning and prediction.</p>&#13;
&#13;
<p>Kubernetes can help you here with the <em>Vertical Pod Autoscaler</em> (VPA), which monitors the resource consumption of your Pod over time and gives a recommendation for requests and limits. The VPA is described in detail in <a data-type="xref" href="ch29.html#elasticscale-vertical">“Vertical Pod Autoscaling”</a>.</p>&#13;
&#13;
<p>However, more importantly, resource profiles are the way an application communicates with Kubernetes to assist in scheduling and managing decisions.&#13;
If your application doesn’t provide any <code>requests</code> or <code>limits</code>, all Kubernetes can do is treat your containers as opaque boxes that are dropped when the cluster gets full. So it is more or less mandatory for every application to think about and provide these resource declarations.</p>&#13;
&#13;
<p>Now<a data-primary="Declarative Deployment" data-type="indexterm" id="idm45902099193872"/><a data-primary="Declarative Deployment" data-secondary="Predictable Demands" data-type="indexterm" id="idm45902099193136"/> that you know how to size our applications, in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.html#DeclarativeDeployment">Chapter 3, “Declarative Deployment”</a>, you will learn multiple strategies to install and update our applications on Kubernetes.<a data-primary="" data-startref="preddem02" data-type="indexterm" id="idm45902099190752"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902099652480">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/HYIqJ">Predictable Demands Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/c54Gh">Configure a Pod to Use a ConfigMap</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/8bKD5">Kubernetes Best Practices: Resource Requests and Limits</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/a37eO">Resource Management for Pods and Containers</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/RXQD1">Manage HugePages</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/ozlU1">Configure Default Memory Requests and Limits for a Namespace</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/fxRvs">Node-Pressure Eviction</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/FpUoH">Pod Priority and Preemption</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/x07OT">Configure Quality of Service for Pods</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/yORlL">Resource Quality of Service in Kubernetes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/rFSLa">Resource Quotas</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/1bXfO">Limit Ranges</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/lkmMK">Process ID Limits and Reservations</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Yk-Ag">For the Love of God, Stop Using CPU Limits on Kubernetes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/cdJkP">What Everyone Should Know About Kubernetes Memory Limits</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>