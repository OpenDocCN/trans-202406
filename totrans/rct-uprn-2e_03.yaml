- en: 'Chapter 3\. Excel: A Fancy Table Component'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how to create custom React components, compose UI using generic
    DOM components as well as your own custom ones, set properties, maintain state,
    hook into the lifecycle of a component, and optimize performance by not rerendering
    when not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put all of this together (and learn more about React while you’re at it)
    by creating a more powerful component—a data table. Something like an early prototype
    of Microsoft Excel that lets you edit the contents of a data table, and also sort,
    search, and export the data as downloadable files.
  prefs: []
  type: TYPE_NORMAL
- en: Data First
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tables are all about the data, so the fancy table component (why not call it
    `Excel`?) should take an array of data and an array of headers that describe each
    column of data. For testing, let’s grab a list of best-selling books from [Wikipedia](https://en.wikipedia.org/wiki/List_of_best-selling_books):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, how should you go about rendering this data in a table?
  prefs: []
  type: TYPE_NORMAL
- en: Table Headers Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step, just to get the new component off the ground, is to display
    only the headers of the table. Here’s what a bare-bones implementation might look
    like (*03.01.table-th-loop.html* in the book’s repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a working component, here’s how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result of this get-off-the-ground example is shown in [Figure 3-1](#FIG0301).
    There’s a little bit of CSS, which is of no concern for the purposes of this discussion,
    but you can find it in `03.table.css` in the book’s repo.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0301](Images/rur2_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Rendering table headers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `return` part of the component is fairly simple. It looks just like an HTML
    table except for the `headers` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you saw in the previous chapter, you can open curly braces in your JSX and
    put any JavaScript value or expression in there. If this value happens to be an
    array as in the previous case, the JSX parser treats it as if you passed each
    element of the array individually, like `{headers[0]}{headers[1]}...`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example the elements of the `headers` array contain more JSX content
    and this is perfectly fine. The loop before the `return` populates the `headers`
    array with JSX values which, if you were hardcoding the data, would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can have JavaScript expressions in curly braces within JSX and you can nest
    them as deep as you need. This is part of the beauty of React—all the power of
    JavaScript is available to you to create your UI. Loops and conditions all work
    as usual, and you don’t need to learn another “templating” language or syntax
    to build the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Table Headers Loop, a Terse Version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example worked fine (let’s call it “v1” for “version 1”) but let’s
    see how you can accomplish the same with less code. Let’s move the loop inside
    the JSX returned at the end. In essence the whole `render()` method becomes a
    single `return` (see *03.02.table-th-map.html* in the book’s repo).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See how the array of header content is produced by calling `map()` on the data
    passed via `this.props.headers`. A `map()` call takes an input array, executes
    a callback function on each element, and creates a new array.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the callback uses the tersest *arrow functions* syntax.
    If this is a little too cryptic for your taste, let’s call it v2 and explore a
    few other options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s v3: a more verbose `map()` loop using generous indentation and a *function
    expression* instead of an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, a v4 which is a little less verbose, going back to using an arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be formatted with less indentation to v5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can choose your preferred way of iterating over arrays to produce JSX output
    based on personal preference and complexity of the content to be rendered. Simple
    data is conveniently looped over inline in the JSX (v2 through v5). If the type
    of data is a little too much for an inline `map()` you may find it more readable
    to have the content generated at the top of the render function and keep the JSX
    simple, in a way separating data from presentation (v1 is an example). Sometimes
    too many inline expressions can be confusing when keeping track of all closing
    parentheses and curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: As to v2 versus v5, they are the same except v5 has extra parentheses around
    the callback arguments and curly braces wrapping the callback function body. While
    both of these are optional, they make future changes a little easier to parse
    in a diff/code review context or while debugging. For example, adding a new line
    to the function body (maybe a temporary `console.log()`) in v5 is just that simple—adding
    a new line. While in v2 a new line also requires adding curly braces and reformatting
    and reindenting the code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the Console Warning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look in the the browser console when loading the previous two examples
    (*03.01.table-th-loop.html* and *03.01.table-th-map.html*) you can see a warning.
    It states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What is it about and how do you fix it? As the warning message reads, React
    wants you to provide a unique identifier for the array elements so it can update
    them more efficiently later on. To fix the warning, you add a `key` property to
    each header. The values of this new property can be anything as long they are
    unique for each element. Here you can use the index of the array element (0, 1,
    2…):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The keys need to be unique only inside each array loop, not unique in the whole
    React application, so values of 0, 1, and so on are perfectly acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same fix for the inline version (v5) takes the element index from the second
    argument passed to the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding <td> Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a pretty table head, it’s time to add the body. The data
    to be rendered is a two-dimensional array (rows and columns) that looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To pass the data to the `<Excel>`, let’s use a new prop called `initialData`.
    Why “initial” and not just “data”? As touched on briefly in the previous chapter,
    it’s about managing expectations. The caller of your `Excel` component should
    be able to pass data to initialize the table. But later, as the table lives on,
    the data will change, because the user is able to sort, edit, and so on. In other
    words, the *state* of the component will change. So let’s use `this.state.data`
    to keep track of the changes and use `this.props.initialData` to let the caller
    initialize the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering a new `Excel` component would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next you need to add a constructor to set the initial state from the given
    data. The constructor receives `props` as an argument and also needs to call its
    parent’s constructor via `super()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On to rendering `this.state.data`. The data is two-dimensional, so you need
    two loops: one that goes through rows and one that goes through the data (cells)
    for each row. This can be accomplished using two of the same `.map()` loops you
    already know how to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both loops need `key={idx}`, and in this case the name `idx`
    was recycled for use as local variables within each loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete implementation could look like this (and the result is shown in
    [Figure 3-2](#FIG0302)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![rur2 0302](Images/rur2_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Rendering the whole table (*03.05.table-th-td.html*)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prop Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to specify the types of variables you work with (string, number,
    boolean, etc.) doesn’t exist in the JavaScript language. But developers coming
    from other languages, and those working on larger projects with many other developers,
    do miss it. Two popular options exist that allow you to write JavaScript with
    types: Flow and TypeScript. You can certainly use these to write React applications.
    But another option exists, which is limited to only specifying the types of props
    your component expects with *prop types*. They were a part of React itself, initially,
    but have been moved to a separate library as of React v15.5.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prop types allow you to be more specific as to what data `Excel` takes and
    as a result surface an error to the developer early on. You can set up the prop
    types like so (*03.06.table-th-td-prop-types.html*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `headers` prop is expected to be an array of strings and
    `initialData` is expected to be an array where each element is another array of
    string elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this code work you need to grab the library that exposes the `PropTypes`
    global variable, just like you did in the beginning of [Chapter 1](ch01.xhtml#ch1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the HTML, you include the new library together with the other ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can test how it all works by changing `headers`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you load the page (*03.06.table-th-td-prop-types.html* in the repo)
    you can see in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that’s strict!
  prefs: []
  type: TYPE_NORMAL
- en: To explore other `PropTypes`, type **`PropTypes`** in the console (as shown
    in [Figure 3-3](#FIG0303)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0303](Images/rur2_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Exploring `PropTypes`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Can You Improve the Component?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Allowing only string data is a bit too restrictive for a generic Microsoft Excel
    spreadsheet. As an exercise for your own amusement, you can change this example
    to allow more data types (`PropTypes.any`) and then render differently depending
    on the type (e.g., align numbers to the right).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many times have you seen a table on a web page that you wished was sorted
    differently? Luckily, it’s trivial to do this with React. Actually, this is an
    example where React shines, because all you need to do is sort the `data` array
    and all the UI updates are handled for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience and readability, all the sorting logic is in a `sort()` method
    in the `Excel` class. Once you create it, two bits of plumbing are necessary.
    First, add a click handler to the header row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And then bind `this.sort` in the constructor as you did in [Chapter 2](ch02.xhtml#ch2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s implement the `sort()` method. You need to know which column to sort
    by, which can conveniently be retrieved by using the `cellIndex` DOM property
    of the event target (the event target is a table header `<th>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may have rarely seen `cellIndex` used in app development. It’s a property
    defined as early as DOM Level 1 (circa 1998) as “The index of this cell in the
    row” and later on made read-only in DOM Level 2.
  prefs: []
  type: TYPE_NORMAL
- en: You also need a *copy* of the data to be sorted. Otherwise, if you use the array’s
    `sort()` method directly, it modifies the array. Meaning that calling `this.state.data.sort()`
    will modify `this.state`. As you know already, `this.state` should not be modified
    directly, but only through `setState()`.
  prefs: []
  type: TYPE_NORMAL
- en: Various ways exist in JavaScript to make a *shallow copy* of an object or an
    array (arrays are objects in JavaScript, e.g., `Object.assign()`) or using the
    spread operator `{...state}`. However there is no built-in way to do a *deep copy*
    of an object. A quick solution is to encode an object to a JSON string and then
    decode it back to an object. Let’s use this approach for brevity, though be aware
    that it fails if your object/array contains `Date` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the handy `clone()` utility function you make a copy of the array before
    you start manipulating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual sorting is done via a callback to array’s `sort()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this line sets the state with the new, sorted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you click a header, the contents get sorted alphabetically (as shown
    in [Figure 3-4](#FIG0304)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0304](Images/rur2_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Sorting by book title (*03.07.table-sort.html*)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And this is it—you don’t have to touch the UI rendering at all. In the `render()`
    method, you’ve already defined once and for all how the component should look
    given some data. When the data changes, so does the UI; however, this is no longer
    your concern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The example used the ECMAScript *property value shorthands* feature where `this.setState({data})`
    is a shorter way of expressing `this.setState({data: data})` by skipping the key
    when it has the same name as a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Can You Improve the Component?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example above uses pretty simple sorting, just enough to be relevant to
    the React discussion. You can go as fancy as you need, parsing the content to
    see if the values are numeric, with or without a unit of measure and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting UI Cues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The table is nicely sorted, but it’s not clear which column it’s sorted by.
    Let’s update the UI to show arrows based on the column being sorted. And while
    you’re at it, let’s implement descending sorting too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep track of the new state, you need two new properties added to `this.state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.state.sortby`'
  prefs: []
  type: TYPE_NORMAL
- en: The index of the column currently being sorted
  prefs: []
  type: TYPE_NORMAL
- en: '`this.state.descending`'
  prefs: []
  type: TYPE_NORMAL
- en: A boolean to determine ascending versus descending sorting
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor can now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `sort()` function, you have to figure out which way to sort. Default
    is ascending (A to Z), unless the index of the new column is the same as the current
    sort-by column and the sorting is not already descending from a previous click
    on the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need a small tweak to the sorting callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, you need to set the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the descending ordering works. Clicking on the table headers
    sorts the data first in ascending order, then descending, and then toggles between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only remaining task is to update the `render()` function to indicate sorting
    direction. For the currently sorted column, let’s just add an arrow symbol to
    the title. Now the `headers` loop looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The sorting is feature-complete—people can sort by any column, they can click
    once for ascending and once more for descending ordering, and the UI updates with
    the visual cue (as depicted in [Figure 3-5](#FIG0305)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0305](Images/rur2_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Ascending/descending sorting (note the arrow next to “Published”)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Editing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step for the `Excel` component is to give people the option to edit
    the data in the table. One solution could work like so:'
  prefs: []
  type: TYPE_NORMAL
- en: You double-click a cell. `Excel` figures out which cell was clicked and turns
    its content from simple text into an input field prefilled with the content (as
    shown in [Figure 3-6](#FIG0306)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You edit the content (as shown in [Figure 3-7](#FIG0307)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You hit Enter. The input field is gone, and the table is updated with the new
    text (as shown in [Figure 3-8](#FIG0308)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![rur2 0306](Images/rur2_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. Table cell turns into an input field on double-click
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0307](Images/rur2_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Edit the content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0308](Images/rur2_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Content updated on pressing Enter
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Editable Cell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is set up a simple event handler. On double-click, the
    component “remembers” the selected cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note the friendlier, easier-to-read `onDoubleClick`, as opposed to W3C’s `ondblclick`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what `showEditor` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What’s happening here?
  prefs: []
  type: TYPE_NORMAL
- en: 'The function sets the `edit` property of `this.state`. This property is `null`
    when editing is not occurring and then turns into an object with properties `row`
    and `column`, which contain the row index and the column index of the cell being
    edited. So if you double-click the very first cell, `this.state.edit` gets the
    value `{row: 0, column: 0}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To figure out the column index, you use the same `e.target.cellIndex` as before,
    where `e.target` is the `<td>` that was double-clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no `rowIndex` coming for free in the DOM, so you need to do it yourself
    via a `data-` attribute. Each row should have a `data-row` attribute with the
    row index, which you can `parseInt()` to get the index back.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take care of a few prerequisites. First, the `edit` property didn’t exist
    before and should also be initialized in the constructor. While dealing with the
    constructor, let’s bind the `showEditor()` and `save()` methods. The `save()`
    is the one to do the data update once the user is done editing. The updated constructor
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The property `data-row` is something you need so you can keep track of row indexes.
    You can get the index from the array index while looping. Previously you saw how
    `idx` was reused as a local variable by both row and column loops. Let’s rename
    it and use `rowidx` and `columnidx` for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The whole `<tbody>` construction could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s do what the `TODO` says—make an input field when required. The
    whole `render()` function is called again just because of the `setState()` call
    that sets the `edit` property. React rerenders the table, which gives you the
    chance to update the table cell that was double-clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Input Field Cell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the code to replace the `TODO` comment. First, remember the edit
    state for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if the `edit` is set and if so, whether this is the exact cell being
    edited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is the target cell, let’s make a form and an input field with the content
    of the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you see, it’s a form with a single input and the input is prefilled with
    the text content. When the form is submitted, the submission event is trapped
    in the `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Saving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last piece of the editing puzzle is saving the content changes after the
    user is done typing and has submitted the form (via the Enter key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After preventing the default behavior (so the page doesn’t reload), you need
    to get a reference to the input field. The event target `e.target` is the form
    and its first and only child is the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone the data, so you don’t manipulate `this.state` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the piece of data given the new value and the column and row indices
    stored in the `edit` property of the `state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, set the state, which causes rerendering of the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And with this, the table is now editable. For a complete listing, see *03.09.table-editable.html*.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion and Virtual DOM Diffs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, the editing feature is complete. It didn’t take too much code.
    All you needed was to:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep track of which cell to edit via `this.state.edit`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render an input field when displaying the table if the row and column indices
    match the cell the user double-clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the data array with the new value from the input field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as you `setState()` with the new data, React calls the component’s `render()`
    method and the UI magically updates. It may look like it won’t be particularly
    efficient to render the whole table for just one cell’s content change. And in
    fact, React only updates a single cell in the browser’s DOM.
  prefs: []
  type: TYPE_NORMAL
- en: If you open your browser’s dev tools, you can see which parts of the DOM tree
    are updated as you interact with your application. In [Figure 3-9](#FIG0309),
    you can see the dev tools highlighting the DOM change after changing *The Hobbit*’s
    language from English to Elvish.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, React calls your `render()` method and creates a lightweight
    tree representation of the desired DOM result. This is known as a *virtual DOM
    tree*. When the `render()` method is called again (after a call to `setState()`,
    for example), React takes the virtual tree before and after and computes a diff.
    Based on this diff, React figures out the minimum required DOM operations (e.g.,
    `appendChild()`, `textContent`, etc.) to carry on that change into the browser’s
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-9](#FIG0309), there is only one change required to the cell and
    it’s not necessary to rerender the whole table. By computing the minimum set of
    changes and batching DOM operations, React “touches” the DOM lightly, as it’s
    a known problem that DOM operations are slow (compared to pure JavaScript operations,
    function calls, etc.) and are often the bottleneck in rich web applications’ rendering
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0309](Images/rur2_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. Highlighting DOM changes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'React has your back when it comes to performance and updating the UI by:'
  prefs: []
  type: TYPE_NORMAL
- en: Touching the DOM lightly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using event delegation for user interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let’s add a search feature to the `Excel` component that allows users
    to filter the contents of the table. Here’s the plan:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button to toggle the new feature on and off (as in [Figure 3-10](#FIG0309_2)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the search is on, add a row of inputs where each one searches in the corresponding
    column (as in [Figure 3-11](#FIG0310)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a user types in an input box, filter the array of `state.data` to show only
    the matching content (as in [Figure 3-12](#FIG0311)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![rur2 0310](Images/rur2_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. Search button
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0311](Images/rur2_0311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11\. Row of search/filter inputs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0312](Images/rur2_0312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12\. Search results
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: State and UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do is update the constructor by:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a `search` property to the `this.state` object to keep track of whether
    the search feature is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binding two new methods: `this.toggleSearch()` to turn search boxes on and
    off and `this.search()` to do the actual searching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a new class property `this.preSearchData`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the incoming initial data with a consecutive ID to help identify the
    rows when editing contents of filtered data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The cloning and updating of the `initialData` changes the data used in the state
    by adding a sort of *record ID*. This will prove handy when editing data that
    was already filtered. You `map()` the data, adding an additional column which
    is an integer ID.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, `this.state.data` now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This change also requires changes in the `render()` method, namely to use this
    record ID to identify rows, regardless of whether we’re looking at all the data
    or a filtered subset of it (as a result of a search):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Next comes updating the UI with a search button. Where before there was a `<table>`
    as the root, now let’s have a `<div>` with a search button and the same table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the search button label is dynamic, to reflect whether the search
    is on or off (`this.state.search` is `true` or `false`).
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the row of search boxes. You can add it to the increasingly large
    chunk of JSX, or you can have it composed up front and added to a constant which
    is to be included in the main JSX. Let’s go the second route. If the search feature
    is not on, you don’t need to render anything, so `searchRow` is just `null`. Otherwise
    a new table row is created where each cell is an input element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using `(_, idx)` is an illustration of a convention where an unused variable
    in a callback is named with an underscore `_` to signal to the reader of the code
    that it’s not used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The row of search inputs is just another child node before the main `data`
    loop (the one that creates all the table rows and cells). Include `searchRow`
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, that’s all for the UI updates. Let’s take a look at the meat
    of the feature, the “business logic,” if you will: the actual search.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The search feature is going to be fairly simple: call the `Array.prototype.filter()`
    method on the array of data, and return a filtered array with the elements that
    match the search string. The UI still uses `this.state.data` to do the rendering,
    but `this.state.data` is a reduced version of itself.'
  prefs: []
  type: TYPE_NORMAL
- en: You need a reference to the data before the search, so that you don’t lose the
    data forever. This allows the user to go back to the full table or change the
    search string to get different matches. Let’s call this reference `this.preSearchData`.
    Now that there’s data in two places, the `save()` method will need an update,
    so both places are updated should the user decide to edit the data, regardless
    of whether it’s been filtered or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks the “search” button, the `toggleSearch()` function is
    invoked. This function’s task is to turn the search feature on and off. It does
    its task by:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `this.state.search` to `true` or `false` accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When enabling the search, “remembering” the current data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When disabling the search, reverting to the remembered data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how this function can be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to do is implement the `search()` function, which is called
    every time something in the search row changes, meaning the user is typing in
    one of the inputs. Here’s the complete implementation, followed by some more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You get the search string from the change event’s target (which is the input
    box). Let’s call it “needle” as we’re looking for a needle in a haystack of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If there’s no search string (the user erased what they typed), the function
    takes the original, cached data, and this data becomes the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a search string, filter the original data and set the filtered
    results as the new state of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And with this, the search feature is complete. To implement the feature, all
    you needed to do was:'
  prefs: []
  type: TYPE_NORMAL
- en: Add search UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show/hide the new UI upon request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The actual “business logic”: a simple array `filter()` call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, you worry only about the state of your data and let React take care
    of rendering (and all the associated grunt DOM work) whenever the state of the
    data changes.
  prefs: []
  type: TYPE_NORMAL
- en: Update the save() Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously there was only `state.data` to be cloned and updated, but now you
    also have the “remembered” `preSearchData`. If the user is editing (even while
    searching), now the two pieces of data need an update. That’s the whole reason
    for adding a record ID—so you can find the real row even in a filtered state.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the `preSearchData` is just like in the previous `save()` implementation;
    just find the row and column. Updating the state data requires the additional
    step of finding the record ID of the row and matching it to the row currently
    being edited (`this.state.edit.row`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: See *03.10.table-search.html* in the book’s repo for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: Can You Improve the Search?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was a simple working example for illustration. Can you improve the feature?
  prefs: []
  type: TYPE_NORMAL
- en: Try to implement an *additive search* in multiple boxes, filtering the already
    filtered data. If the user types “Eng” in the language row and then searches using
    a different search box, why not search in the search results of the previous search
    only? How would you implement this feature?
  prefs: []
  type: TYPE_NORMAL
- en: Instant Replay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know now, your components worry about their state and let React render
    and rerender whenever appropriate. This means that given the same data (state
    and properties), the application will look exactly the same, no matter what changed
    before or after this particular data state. This gives you a great debugging-in-the-wild
    opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine someone encounters a bug while using your app—they can click a button
    to report the bug without needing to explain what happened. The bug report can
    just send you back a copy of `this.state` and `this.props`, and you should be
    able to re-create the exact application state and see the visual result.
  prefs: []
  type: TYPE_NORMAL
- en: 'An “undo” could be another feature, since React renders your app the same way
    given the same props and state. In fact, the “undo” implementation is somewhat
    trivial: you just need to go back to the previous state.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take that idea a bit further, just for fun. Let’s record each state change
    in the `Excel` component and then replay it. It’s fascinating to watch all your
    actions played back in front of you. The question of *when* the change occurred
    is not that important, so let’s “play” the app state changes at 1-second intervals.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this feature, you need to add a `logSetState()` method which first
    logs the new state to a `this.log` array and then calls `setState()`. Everywhere
    in the code you called `setState()` should now be changed to call `logSetState()`.
    First, search and replace all calls to `setState()` with calls to the new function.
  prefs: []
  type: TYPE_NORMAL
- en: All calls to…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '…become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s move on to the constructor. You need to bind the two new functions,
    `logSetState()` and `replay()`, declare `this.log` array, and assign the initial
    state to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `logSetState` needs to do two things: log the new state and then pass it
    over to `setState()`. Here’s one example implementation where you make a deep
    copy of the state and append it to `this.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all state changes are logged, let’s play them back. To trigger the
    playback, let’s add a simple event listener that captures keyboard actions and
    invokes the `replay()` function. The place for events listeners like this is in
    the `componentDidMount()` lifecycle method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, consider the `replay()` method. It uses `setInterval()` and once per
    second it reads the next object from the log and passes it to `setState()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: And with this, the new feature is complete (*03.11.table-replay.html* in the
    repo). Play around with the component, sort, edit… Then press Alt+Shift+R (or
    Option-Shift-R on Mac) to see the past unfold before you.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Up Event Handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The replay feature needs a bit of cleanup. When this component is the only
    thing happening on the page, cleanup isn’t necessary; in a real application, components
    get added and removed from the DOM more frequently. When removing from the DOM
    a “good citizen” component should clean up after itself. In the example above
    there are two items that need cleaning up: the `keydown` event listener and the
    replay interval callback.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t clean up the `keydown` event listener function, it will linger
    on in memory after the component is gone. And because it’s using `this`, the whole
    `Excel` instance needs to be retained in memory. This is in effect a memory leak.
    Too many of those and the user may run out of memory and your application may
    crash the browser tab. As to the interval, well, the callback function will continue
    executing after the component is gone and cause another memory leak. The callback
    will also attempt to call `setState()` on a non-existing component (which React
    handles gracefully by giving you a warning).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test the latter behavior by removing the component from the DOM while
    the replay is still going. To remove the component from the DOM you can just replace
    it (e.g., run the “Hello world” from [Chapter 1](ch01.xhtml#ch1) in the console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You can also log a timestamp to the console in the interval callback to see
    that it keeps on being executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now when you replace the component during replay, you see an error from React
    and the timestamps of the interval callback still being logged as evidence that
    the callback is still running (as shown in [Figure 3-13](#FIG0313)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0313](Images/rur2_0313.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13\. Memory leak in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similarly, you can test the event listener memory leak by pressing Alt+Shift+R
    after the component has been removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking care of these memory leaks is fairly straightforward. You need to keep
    references to the handlers and intervals/timeouts you want to clean up. Then clean
    them up in `componentWillUnmount()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the event handler, have it as a class method, as opposed to an inline function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `componentDidMount()` becomes the simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For the interval replay ID, have it as a class property as opposed to a local
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to, of course, bind the new method and add the new property in the
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, the cleanup in the `componentWillUnmount()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now all the leaks are plugged (See *03.12.table-replay-clean.html* in the book’s
    repository).
  prefs: []
  type: TYPE_NORMAL
- en: Can You Improve the Replay?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How about implementing an undo/redo feature? Say, when the person uses the Alt+Z
    keyboard shortcut, you go back one step in the state log and on Alt+Shift+Z you
    go forward.
  prefs: []
  type: TYPE_NORMAL
- en: An Alternative Implementation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Is there another way to implement replay/undo functionality without changing
    all your `setState()` calls? Maybe use an appropriate lifecycle method ([Chapter 2](ch02.xhtml#ch2))?
    Try this on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Download the Table Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After all the sorting, editing, and searching, the user is finally happy with
    the state of the data in the table. It would be nice if they could download the
    data, the result of all their labor, to use at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there’s nothing easier in React. All you need to do is grab the current
    `this.state.data` and give it back—for example in JSON or comma-separated value
    (CSV) format.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-14](#FIG0314) shows the end result when a user clicks “Export CSV,”
    downloads the file called *data.csv* (see the bottom left of the browser window),
    and opens this file in Numbers (on a Mac, or Microsoft Excel on a PC or Mac).'
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0314](Images/rur2_0314.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-14\. Export table data to Numbers via CSV
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first thing to do is add new options to the toolbar (where the Search button
    is). Let’s use some HTML magic that forces `<a>` links to trigger file downloads,
    so the new “buttons” have to be links disguised as buttons with some CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, you need `downloadJSON()` and `downloadCSV()` methods. These have
    some repeating logic, so they can be done by a single `download()` function bound
    with the `format` (meaning file type) argument. The `download()` method’s signature
    could be like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor you can bind this method twice, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'All the React work is done. Now for the `download()` function. While exporting
    to JSON is trivial, CSV needs a little bit more work. In essence, it’s just a
    loop over all rows and all cells in a row, producing a long string. Once this
    is done, the function initiates the downloads via the `download` attribute and
    the `href` blob created by `window.URL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is in *03.13.table-download.html* in the repo.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All through the chapter, the `Excel` component had access to the `data` in the
    same file. But what if the data lives elsewhere, on a server, and needs to be
    fetched? There are various solutions to this and you’ll see more later in the
    book, but let’s try one of the simplest—fetching the data in `componentDidMount()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say the `Excel` component is created with an empty `initialData` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The component can gracefully render an intermediate state to let the user know
    that data is coming. In the `render()` method you can have a condition and render
    a different table body if data is not there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: While waiting for the data, the user sees a loading indicator (as in [Figure 3-15](#FIG0315)),
    in this case a simple text, though you can have an animation if you like.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0315](Images/rur2_0315.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-15\. Waiting for the data to be fetched
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s fetch the data. Using the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API),
    make a request to a server and once the response arrives, set the state with the
    new data. You also need to take care of adding the record ID, which was previously
    the job of the constructor. The updated `componentDidMount()` can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The complete code is in *03.14.table-fetch.html* in the repo.
  prefs: []
  type: TYPE_NORMAL
