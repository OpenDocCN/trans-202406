- en: Chapter 4\. Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is a container orchestrator that uses a container runtime to instantiate
    containers inside of Pods. Many Kubernetes clusters with version 1.24 or later
    use the container runtime [containerd](https://containerd.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime used on a Kubernetes node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can fetch information about the container runtime used on any node of a
    Kubernetes cluster. Simply look at the output of the `CONTAINER-RUNTIME` column
    produced by running the command `kubectl get nodes -o wide`. Check the [Kubernetes
    documentation](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)
    to learn more about configuring a container runtime for a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: For the exam, you are expected to understand the practical aspects of defining,
    building, and publishing container images, which this chapter covers. We’ll also
    touch on running a container image inside of a container. For all of those operations,
    we’ll use Docker Engine as the example container runtime though similar functionality
    is provided by other implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The discussion on containers in this book only scratches the surface. There’s
    a lot more information on this topic if you want to fully immerse yourself. I
    can recommend the book [*Docker: Up & Running*](https://learning.oreilly.com/library/view/docker-up/9781098131814/)
    (O’Reilly) by Sean P. Kane and Karl Matthias for a detailed explanation of Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Container Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *container* packages an application into a single unit of software including
    its runtime environment and configuration. This unit of software usually includes
    the operating system, the application’s source code or the binary, its dependencies,
    and other needed system tools. The declared goal of a container is to decouple
    the runtime environment from the application to avoid the “but it works on my
    machine” problem.
  prefs: []
  type: TYPE_NORMAL
- en: The *container runtime engine* is the software component that can run containers
    on a host operating system. Examples include [Docker Engine](https://docs.docker.com/engine/)
    or [containerd](https://containerd.io/). A *container orchestrator* uses a container
    runtime engine to instantiate a container while adding sophisticated features
    like scalability and networking across the workload. Kubernetes is an example
    of container orchestrators. Other tools like [Nomad](https://www.nomadproject.io/use-cases/simple-container-orchestration)
    are capable of scheduling various types of workload including containers.
  prefs: []
  type: TYPE_NORMAL
- en: The process of bundling an application into a container is called *containerization*.
    Containerization works based on instructions defined in a *container file*. The
    Docker community calls this a Dockerfile. The Dockerfile explicitly spells out
    what needs to happen when the software is built. The result of the operation is
    a *container image*.
  prefs: []
  type: TYPE_NORMAL
- en: The container image is usually published to a *container registry* for consumption
    by other stakeholders. [Docker Hub](https://hub.docker.com) is the primary registry
    for container images available for public use. Other public registries like GCR
    and Quay are available. [Figure 4-1](#containerization_process) illustrates the
    concepts in the context of containerizing an application.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0401](Images/ckd2_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Containerization process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To summarize, the Dockerfile is a blueprint of how the software should be packaged,
    the image is the artifact produced by the process, and the container is a running
    instance of the image serving the application. We’ll look at a more concrete example
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Containerizing a Java-Based Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s assume we want to containerize a web application written in Java. The
    application doesn’t write core functionality from scratch but uses the [Spring
    Boot framework](https://oreil.ly/Na9Vb) as an external library. In addition, we
    want to control the runtime behavior with the help of environment variables. For
    example, you may want to provide URLs and credentials to connect to other services
    like a database. We’ll talk through the process step by step and execute the relevant
    Docker commands from the terminal. If you want to follow along, you can download
    a sample application from the project generator [Spring Initializr](https://oreil.ly/bXSA4).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can create the image, we have to write a Dockerfile. The Dockerfile
    can reside in any directory and is a plain-text file. The instructions that follow
    use the Azul JRE distribution of Java 21 as the base image. A base image contains
    the operating system and the necessary tooling, in this case Java.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we include the binary file, an executable Java archive (JAR), into
    the directory `/app` of the image. Finally, we define the Java command that executes
    the program and expose the port 8080 to make the application accessible when run
    in a container. [Example 4-1](#dockerfile_for_building_a_java_application) outlines
    a sample Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Dockerfile for building a Java application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_containers_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the base image.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_containers_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the working directory of a container. Any `RUN`, `CMD`, `ADD`, `COPY`,
    or `ENTRYPOINT` instruction will be executed in the specified working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_containers_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Copies the JAR containing the compiled application code into the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_containers_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the default command that executes when a container starts from an image.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_containers_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Documents the network port(s) the container should listen on.
  prefs: []
  type: TYPE_NORMAL
- en: While writing Dockerfile looks straightforward to beginners, optimizing the
    container image for a small footprint and security aspects isn’t. You can find
    a more detailed list of best practices for writing Dockerfiles in the [Docker
    documentation](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/).
  prefs: []
  type: TYPE_NORMAL
- en: Building the Container Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Dockerfile in place, we can create the image. The following command
    provides the name of the image and the tag. The last argument points to the context
    directory. A context directory contains the Dockerfile as well as any directories
    and files to be included in the image. Here, the context directory is the current
    directory we reside in referenced by “ . ”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Listing Container Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As indicated by the terminal output, the image has been created. You might
    have noticed that the base image has been downloaded as part of the process. The
    generated image can be found in your local Docker Engine cache by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Running the Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to run the application in a container. The `run` command points to
    an image and executes its logic in a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We told the command to forward the port 8080 accessible on localhost to the
    container port 8080 using the `-p` CLI option. The `-d` CLI option runs the container
    in the background, which means it will detach from the container and return to
    the terminal prompt. This means we should now be able to resolve the application’s
    endpoint from the local machine. As the following command shows, a simple `curl`
    to the root context path renders the message “Hello World!”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Listing Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any running containers can be listed to display their runtime properties. The
    following command renders the container started earlier. The output includes the
    container ID for later reference. Add the flag `-a` to render terminated containers
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Interacting with the Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the container has been started, you can interact with it. All you need
    is the container ID. Use the `logs` command to inspect log messages produced by
    the application. Inspecting logs can be helpful for troubleshooting. The following
    command renders the log messages produced by Spring Boot upon container startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can dig deeper into the internals of running containers if the container
    image is packaged with a command-line shell. For example, you may want to inspect
    files consumed or produced by the application. Use the `exec` command to run a
    command in the container. The flag `-it` allows for iterating with the container
    until you are ready to exit out of it. The following command opens an iterative
    bash shell to the running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To leave the interactive bash shell, run the `exit` command. You’ll return to
    the terminal prompt on your host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the Container Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To publish an image to a registry, you’ll have to do some prework. Most registries
    require you to provide a prefix that signifies the username or hostname as part
    of the container image name, which you can achieve with the `tag` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Docker Hub requires you to provide the username. My username is
    `bmuschko` and therefore I have to retag my image before pushing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tag` command does not create a copy of the container image. It simply
    adds another identifier pointing to the existing container image, as shown in
    the following output. The image ID and size of the container image is the same
    for both entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If the registry is protected, you’ll also have to provide the credentials.
    For Docker Hub, we are logging in with username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can push the image to the registry using the `push` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can discover the published container image through the Docker Hub web page,
    as shown in [Figure 4-2](#dockerhub_ui_image). The “Tags” tab lists all available
    tags for the image including their details and quick reference to the `docker`
    command for pulling the image.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0402](Images/ckd2_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Discovering container images on Docker Hub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Anyone with access to the registry can now consume the container image using
    the `pull` command.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and Loading a Container Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of publishing a container image to a container registry, you may want
    to save it to a file. Files can be easily stored and backed up on a shared drive
    and don’t require a container registry. The `save` command saves one or many images
    to a tar archive. The resulting archive file contains all parent layers, and all
    tags + versions. The following command saves the container image to the file `java-hello-world.tar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To load a container image from a tar archive, use the `load` command. The command
    restores both images and tags. The following command loads the container image
    from the file `java-hello-world.tar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The image is now available in the cache, as shown by running the `images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus far you have experienced the most common developer workflows: containerizing
    an application and pushing the image to a registry. There’s far more to learn
    about building and running containers, but that is outside the scope of this book,
    and we won’t dive any deeper here. If you’d like to learn more, a good starting
    point is the [Docker documentation](https://docs.docker.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application developers use containerization to bundle the application code into
    a container image so that it can be deployed to Kubernetes clusters as a single
    unit of runnable software. The containerization process defines, builds, runs,
    and publishes a container image using a container runtime engine. In this chapter,
    we used Docker Engine to demonstrate the process for a Java-based application;
    however, the steps involved would look similar for applications written in a different
    programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gain practical experience with the containerization process
  prefs: []
  type: TYPE_NORMAL
- en: Pods run container images inside of a container. You need to understand how
    to define, build, run, and publish a container image apart from Kubernetes. Practice
    the use of the container runtime engine’s command-line tool to fulfill the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Compare the functionality of different container runtime engines
  prefs: []
  type: TYPE_NORMAL
- en: You should get familiar with Docker Engine specifically for understanding the
    containerization process. At the time of writing, Docker Engine is still the most
    widely used container runtime engine. Branch out by playing around with other
    container runtime engines like containerd or Podman.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarize yourself with other workflows
  prefs: []
  type: TYPE_NORMAL
- en: As an application developer, you will deal with defining, building, and modifying
    container images daily. Container runtime engine support other, less-known features
    and workflows. It can’t hurt to read through the container runtime engine’s documentation
    to gain broader exposure.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_000.xhtml#appendix_a_containers).
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch04/containerized-java-app* of the checked-out
    GitHub repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    Inspect the *Dockerfile*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the container image from the *Dockerfile* with the tag `nodejs-hello-world:1.0.0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run a container with the container image. Make the application available on
    port 80.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute a `curl` or `wget` command against the application’s endpoint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Retrieve the container logs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modify the *Dockerfile* from the previous exercise. Change the base image to
    the tag `20.4-alpine` and the working directory to `/node`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the container image from the *Dockerfile* with the tag `nodejs-hello-world:1.1.0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that container image has been created by listing it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pull the container image `alpine:3.18.2` [available on Docker Hub](https://hub.docker.com/layers/library/alpine/3.18.2/images/sha256-25fad2a32ad1f6f510e528448ae1ec69a28ef81916a004d3629874104f8a7f70?context=explore).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the container image to the file *alpine-3.18.2.tar*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete the container image. Verify the container image is not listable anymore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reinstate the container image from the file *alpine-3.18.2.tar*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that the container image can be listed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
