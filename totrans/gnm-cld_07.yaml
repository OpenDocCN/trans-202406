- en: Chapter 4\. First Steps in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we took you through the essentials of genomics
    and computing technology. Our goal was to make sure you have enough of a grounding
    in both domains regardless of whether you’re coming to this more from one side
    or the other—or perhaps even from another domain altogether; if so, welcome! And
    hang in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'We realize that those first two chapters might have felt very passive since
    there were no hands-on exercises involved. So here’s the good news: you’re finally
    going to get to do some hands-on work. This chapter is all about getting you oriented
    and comfortable with the GCP services that we use throughout this book. First,
    we walk you through creating a GCP account and running simple commands in Google
    Cloud Shell. After that, we show you how to set up your own VM in the cloud, get
    Docker running on it, and set up the environment that you’ll use in [Chapter 5](ch05.xhtml#first_steps_with_gatk)
    to run GATK analyses. Finally, we show you how to configure the IGV to access
    data in Google Cloud Storage. After you have all that set up, you’ll be ready
    to do some actual genomics.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Your Google Cloud Account and First Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can sign up for an account on GCP by navigating to [*https://cloud.google.com*](https://cloud.google.com)
    and following the prompts. We are purposely light on the details here because
    the interface for account setup has been known to change. At a high level, though,
    your goals are to establish a new Google Cloud account, set up a billing account,
    accept the free trial credits (if you’re eligible), and create a new project that
    links to your billing account.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t already have a Google identity of some kind, you can create one
    with your regular email account; you don’t need to use a Gmail account. Keep in
    mind also that if your institution uses G Suite, your work email might already
    be associated with a Google identity even if the domain name is not *gmail.com*.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve signed up, make your way to the [GCP console](https://oreil.ly/T4nVl),
    which provides a web-based graphical interface for managing cloud resources. You
    can access most of the functionality offered in the console through a pure command-line
    interface. In the course of the book, we show you how to do some things through
    the web interface and some through the command line, depending on what we believe
    is most convenient and/or typical.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin by creating your first project, which is necessary to organize your
    work, set up billing, and gain access to GCP services. In the console, go to the
    [“Manage resources”](https://oreil.ly/2oA64) page and then, at the top of the
    page, select Create Project. As shown in [Figure 4-1](#creating_a_new_projectdot),
    you need to give your project a name, which must be unique within the entire GCP.
    You can also select an organization if your Google identity is associated with
    one (which is usually the case if you have an institutional/work G Suite account),
    but if you just created your account, this might not be applicable to you at the
    moment. Having an organization selected means new projects will be associated
    with that organization by default, which allows for central management of projects.
    For the purposes of these instructions, we assume that you’re setting up your
    account for the first time and there isn’t a preexisting organization linked to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project.](Images/gitc_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Creating a new project.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Checking Your Billing Account and Activating Free Credits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you followed the sign-up process outlined in the previous section and activated
    your free trial, the system will have set up billing information for you as part
    of the overall account creation process. You can check your billing information
    in the [Billing section of the console](https://oreil.ly/X8G6K), which you can
    also access at any time from the sidebar menu.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re eligible for the free credits program, one of the panels on the billing
    overview page will summarize the number of credits and days you have left to spend
    them. Note that if yours is displaying a blue Upgrade button, as shown in [Figure 4-2](#the_panel_in_the_billing_console_summar),
    your trial has not yet started and you need to activate it in order to take advantage
    of the program. You might also see a “Free trial status” banner at the top of
    your browser window with a blue Activate button. Someone at GCP is working really
    hard to not let you walk away from free money, so click either of those buttons
    to start the process and receive your free credits.
  prefs: []
  type: TYPE_NORMAL
- en: '![The panel in the Billing console summarizing free trial credits availability.](Images/gitc_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. The panel in the Billing console summarizing free trial credits
    availability.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'More generally, the billing overview page provides summaries of how much money
    (or credits) you have spent so far as well as some basic forecasting. That being
    said, it’s important to understand that the system does not show you costs in
    real time: there is some lag time between the moments when you use chargeable
    resources and when the costs are updated on your billing page.'
  prefs: []
  type: TYPE_NORMAL
- en: Many people who make the move to the cloud report that keeping track of their
    spending is one of the most difficult parts of the process. It’s also the one
    that causes them the most anxiety because it can be very easy to spend large sums
    of money pretty quickly in the cloud if you’re not careful. One feature offered
    by GCP that we find particularly useful in this respect is the “Budgets & alerts”
    settings, as depicted in [Figure 4-3](#budget_and_alert_threshold_administrati).
    This allows you to set email alerts that will notify you (or whoever is the billing
    administrator on your account) when you exceed certain spending thresholds. To
    be clear, this won’t stop anything from running or prevent you from starting any
    new work that would push you over the threshold, but at least it will let you
    know where you stand.
  prefs: []
  type: TYPE_NORMAL
- en: '![Budget and alert threshold administration](Images/gitc_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Budget and alert threshold administration.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To access the billing notifications feature, on the main menu on the GCP console,
    choose Billing, select the billing account you just created, and then look for
    the Budgets and alerts option. After you select it, you will be able to set up
    a new budget using the Create budget form shown in [Figure 4-3](#budget_and_alert_threshold_administrati).
    You can create multiple budgets and set multiple triggers for different percentages
    of the budget if you want warnings as you approach your budget amount. But as
    we just mentioned, keep in mind that it is still only a notification service and
    will not prevent you from incurring additional charges.
  prefs: []
  type: TYPE_NORMAL
- en: Running Basic Commands in Google Cloud Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve established your account, set up billing, and created your project,
    the next step is to log in to your first VM. For our exercises here, we use Google
    Cloud Shell, which does not require any configuration to get started and is completely
    free, although it comes with a few important limitations that we discuss in a
    moment.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in to the Cloud Shell VM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a secure connection to a Cloud Shell VM using the SSH protocol, in
    the upper-right corner of the console, click the terminal icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The terminal icon to open Cloud Shell.](Images/gitc_04in01.png)'
  prefs: []
  type: TYPE_IMG
- en: This launches a new panel in the bottom on the console; if you want, you can
    also pop the terminal out to its own window. This gives you shell access to your
    own Debian-based Linux VM provisioned with modest resources, including 5 GB of
    free storage (mounted at *$HOME*) on a persistent disk. Some basic packages are
    preinstalled and ready to go, including the Google Cloud SDK (aka `gcloud`), which
    provides a rich set of command-line-based tools for interacting with GCP services.
    We’ll use it in a few minutes to try out some basic data management commands.
    In the meantime, feel free to explore this Debian VM, look around, and see what
    tools are installed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be aware that weekly usage quotas limit how much time you can spend running
    the Cloud Shell; as of this writing, it’s 50 hours per week. In addition, if you
    don’t use it regularly (within 120 days, as of this writing), the contents of
    the disk that provides you with free storage might end up being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you log in to Cloud Shell for the first time, it prompts you to specify
    a Project ID using the aforementioned `gcloud` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can find your Project ID on the Home page of the console, as shown in [Figure 4-4](#location_of_the_project_id_in_the_gcp_c).
  prefs: []
  type: TYPE_NORMAL
- en: '![Location of the Project ID in the GCP console.](Images/gitc_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Location of the Project ID in the GCP console.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When you have your Project ID, run the following command in the Cloud Shell,
    substituting your own Project ID for the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that your command prompt now includes your Project ID. It is quite long,
    so going forward, we’ll show only the last character in the prompt—in this case,
    the dollar sign ($)—when we demonstrate running commands. For example, if we list
    the contents of the working directory using the `ls` command, it will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And, hey, there’s already something here: a *README* file, which, as the name
    indicates, really wants you to read it. You can do so by running the `cat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This displays a welcome message that summarizes some usage instructions and
    recommendations for getting help. And with that, you’re ready to use Cloud Shell
    to begin interacting with basic GCP services. Let’s get cracking!
  prefs: []
  type: TYPE_NORMAL
- en: Using gsutil to Access and Manage Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have access to this extremely simple-to-launch and free (if fairly
    limited) VM, let’s use it to see whether we can access the bundle of example data
    provided with this book. The data bundle resides in Google Cloud Storage (GCS),
    which is a form of *object store* (i.e., it’s used for storing files) with units
    of storage called *buckets*. You can view the contents of GCS buckets and perform
    basic management tasks on them via the web through the [storage browser section](https://oreil.ly/sqrkr)
    of the GCP console, but the interface is fairly limited. The more powerful approach
    is to use the `gcloud` tool, `gsutil` (Google Storage Utilities), from the command
    line. You can access buckets through their GCS path, which is just their name
    prefixed with *gs://*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the path for the public storage bucket for this book is *gs://genomics-in-the-cloud*.
    You can list the contents of the bucket by typing the following command in your
    cloud shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There should be a file called *hello.txt*. Let’s use the `gsutil` version of
    the Unix command `cat`, which allows us to read the content of text files to see
    what this *hello.txt* file contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also try copying the file to your storage disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you list the contents of your working directory by using `ls` again, you
    should now have a local copy of the *hello.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While we’re playing with `gsutil`, how about we do something that will be useful
    later: create a storage bucket of your own, so that you can store outputs in GCS.
    You’ll need to substitute `my-bucket` in the command shown here because bucket
    names must be unique across all of GCS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you didn’t change the bucket name or you tried a name that was already taken
    by someone else, you might get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is the case, just try something else that’s more likely to be unique.
    You’ll know it worked when you see the `Creating *name*...` in the output and
    then get back to the prompt without any further complaint from `gsutil`. When
    that’s done, you’re going to create an environment variable that will serve as
    an alias for your bucket name. That way, you’ll save yourself some typing and
    you’ll be able to copy and paste subsequent commands without having to substitute
    the bucket name every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the `echo` command on your new variable to verify that your bucket
    name has been stored properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s get you comfortable with using `gsutil`. First, copy the *hello.txt*
    file to your new bucket. You can do either directly from the original bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can do it from your local copy; for example, if you made modifications
    that you want to save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as one more example of basic file management, you can decide that
    the file should reside in its own directory in your bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `gsutil` commands are set up to be as similar as possible
    to their original Unix counterparts. So, for example, you’ll also be able to use
    `-r` to make the `cp` and `mv` commands recursive to apply to directories. For
    large file transfers, you can use a few cloud-specification optimizations to speed
    up the process, like the `gsutil -m` option, which parallelizes file transfers.
    Conveniently, the system will usually inform you in the terminal output when you
    could take advantage of such optimizations, so you don’t need to go and memorize
    the documentation before getting underway.
  prefs: []
  type: TYPE_NORMAL
- en: '![GCP console storage browser.](Images/gitc_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. GCP console storage browser.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This opens a reasonably simple configuration form. The most important thing
    to do here is to choose a good name because the name you choose must be unique
    across all of Google Cloud—so be creative! If you choose a name that is already
    in use, the system will let you know when you click Continue in the configuration
    form, as demonstrated in [Figure 4-6](#naming_your_bucketdot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Naming your bucket.](Images/gitc_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Naming your bucket.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you have a unique name, the system will let you proceed to the next step
    by expanding the menu options. These allow you to customize the storage location
    and access controls for your bucket, but for the time being, feel free to just
    accept the defaults and click Create. Doing so will take you back to the list
    of buckets, which should at this point include your newly created one. You can
    click its name to view its contents—but of course it’s still empty, so the view
    won’t be particularly exciting, as illustrated in [Figure 4-7](#viewing_the_contents_of_your_bucketdot).
  prefs: []
  type: TYPE_NORMAL
- en: The interface offers a few basic management options like deleting buckets and
    files as well as uploading files and folders. Note that you can even drag and
    drop files and folders from your local machine into the bucket contents window,
    which is stunningly easy (go ahead, try it), but it’s not something you can expect
    to do very often in the course of your genomics work. In the real world, you’re
    more likely to use the `gsutil` command-line utility. One of the advantages of
    using the command-line path is that you can save those commands as a script, for
    provenance and so that your steps can be reproduced if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the contents of your bucket.](Images/gitc_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Viewing the contents of your bucket.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pulling a Docker Image and Spinning Up the Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cloud Shell is the gift that keeps on giving: the Docker application (which
    we introduced in [Chapter 3](ch03.xhtml#computing_technology_basics_for_life_sc))
    comes preinstalled, so you can go ahead and get started with that, too! We’re
    going to use a simple Ubuntu container to illustrate basic Docker functionality.
    Although a Docker image is available for GATK—and that’s what we’re going to use
    for a good chunk of the next few chapters—we’re not going to use it here because
    it’s rather large, so it takes a little while to get going. We wouldn’t actually
    be able to run any realistic analyses with it in the free Cloud Shell because
    of the small amount of CPU and memory resources allocated for this free VM.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first thing to do to learn how to use Docker containers in this context
    is to...well, avoid the online Docker documentation! Seriously. Not because it’s
    bad, but because the majority of those documents are written mainly for people
    who want to run web applications in the cloud. If that’s what *you* want to do,
    more power to you, but you’re reading the wrong book. What we’re providing here
    are tailored instructions that will teach you how to use Docker to run research
    software in containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'As just noted, we’re going to use a very generic example: an image containing
    the Ubuntu Linux OS. It’s an official image that is provided as part of the core
    library in a public container image repository, Docker Hub, so we just need to
    state its name. You’ll see later that images contributed by the community are
    prefixed by the contributor’s username or organization name. While still in your
    Cloud Shell terminal (it doesn’t matter where your working directory is), run
    the following command to retrieve the Ubuntu image from the Docker Hub library
    of official (certified) images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `pull` command fetches the image and saves it to your VM. The version of
    the container image is indicated by its `tag` (which can be anything the image
    creator wants to assign) and by its `sha256` hash (which is based on the image
    contents). By default, the system gives us the latest version that is available
    because we did not specify a particular tag; in a later exercise, you’ll see how
    to request a specific version by its tag. Note that container images are typically
    composed of several modular *slices*, which are pulled separately. They’re organized
    so that the next time you pull a version of the image, the system will skip downloading
    any slices that are unchanged compared to the version you already have.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s start up the container. There are three main options for running it,
    but the tricky thing is that there is usually only one correct way to do it *as
    its author intended*, and it’s difficult to know what that is if the documentation
    doesn’t specify it (which is soooo often the case). Confused? Let’s walk through
    the cases to make this a bit more concrete, and you’ll see why we’re putting you
    through this momentary frustration and mystery—it’s to save you potential misery
    down the road.
  prefs: []
  type: TYPE_NORMAL
- en: First option
  prefs: []
  type: TYPE_NORMAL
- en: Just run it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Result
  prefs: []
  type: TYPE_NORMAL
- en: A short pause, then your command prompt comes back. No output. What happened?
    Docker did in fact spin up the container, but the container wasn’t configured
    to *do* anything under those conditions, so it basically shrugged and shut down
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Second option
  prefs: []
  type: TYPE_NORMAL
- en: 'Run it with a command appended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Result
  prefs: []
  type: TYPE_NORMAL
- en: It echoed `Hello World!`, as requested, and then shut down again. OK, so now
    we know that we can pass commands to the container, and if it’s a command that
    is recognized by something in there, it will be executed. Then, when any and all
    commands have been completed, the container will shut down. A bit lazy, but reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Third option
  prefs: []
  type: TYPE_NORMAL
- en: 'Run it interactively by using the `-it` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Result
  prefs: []
  type: TYPE_NORMAL
- en: 'Aha! A new command prompt (Bash in this case)! But with a different shell symbol:
    `#` instead of `$`. This means that the container is running and you are in it.
    You can now run any command that you would normally use on an Ubuntu system, including
    installing new packages if you like. Try running a few Unix commands such as `ls`
    or `ls -la` to poke around and see what the container can do. Later in the book,
    particularly in [Chapter 12](ch12.xhtml#interactive_analysis_in_jupyter_noteboo),
    we go into some of the implications of this, including practical instructions
    for how to package and redistribute an image you’ve customized in order to share
    your own analysis in a reproducible way.'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re done poking around, type `**exit**` at the command prompt (or press
    Ctrl+D) to terminate the shell. Because this is the main process the container
    was running, terminating it will cause the container to shut down and return to
    the Cloud Shell itself. To be clear, this will shut down the container *and any
    commands that are currently running*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re curious: yes, it is possible to step outside of the container without
    shutting it down; this is called *detaching*. To do so, press Ctrl+P+Q instead
    of using the `exit` command. You’ll then be able to jump back into the container
    at any time—provided that you can identify it. By default, Docker assigns your
    container a universally unique identifier (UUID) as well as a random human-readable
    name (which tend to sound a bit silly). You can run `docker ps` to list currently
    running containers or `docker ps -a` to list containers that have been created.
    This displays a list of containers indexed by their container IDs that should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We’re showing that two entries correspond to the last two invocations of Docker,
    each with a unique identifier, the `CONTAINER ID`. We see the container with ID
    `c2b4f8a0c7a6` that is currently running was named `vigorous_rosalind` and has
    a status of `Up 5 minutes`. You can tell that the other container, `objective_curie`,
    is not running because its status is `Exited (0) 8 minutes ago`. The names we
    see here were randomly assigned (We swear! What are the odds?), so they’re admittedly
    not terribly meaningful. If you have multiple containers running at the same time,
    this can become a bit confusing, so you’ll want a better way to identify them.
    The good news is that you can give them a meaningful name by adding `--name=*meaningful_name*`
    immediately after `docker run` in your initial command, substituting `*meaningful_name*`
    with the name that you want to give the container.
  prefs: []
  type: TYPE_NORMAL
- en: To enter the container, simply run `docker attach *c2b4f8a0c7a6*` (substituting
    your container ID), press Enter, and you will find yourself back at the helm (your
    keyboard might be labeled Return instead of Enter). You can open a second command
    tab in Cloud Shell if you’d like to be able to run commands outside the container
    alongside the work you’re doing inside the container. Note that you can have multiple
    containers running at the same time on a single VM—that’s one of the great advantages
    of the container system—but they will be competing for the CPU and memory resources
    of the VM, which in Cloud Shell are rather minimal. Later in this chapter, we
    show you how to spin up VMs with beefier capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a Volume to Access the Filesystem from Within the Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having completed the previous exercise, you are now able to retrieve and run
    an instance of any container image shared in a public repository. Many commonly
    used bioinformatics tools, including GATK, are available preinstalled in Docker
    containers. The idea is that knowing how to use them out of a Docker container
    means you won’t need to worry about having the correct OS or software environment.
    However, there’s still one trick that we need to show you in order to make that
    really work for you: how to access your machine’s filesystem from within the container
    by *mounting a volume*.'
  prefs: []
  type: TYPE_NORMAL
- en: What does that last bit mean? By default, when you’re inside the container,
    you can’t access any data that resides on the filesystem outside of the container.
    The container is a closed box. There are ways to copy things back and forth between
    the container and your filesystem, but that becomes tedious really fast. So we’re
    going to follow the easier path, which is to establish a link between a directory
    outside the container in a way that makes it appear as if it were within the container.
    In other words, we’re going to poke a hole in the container wall, as shown in
    [Figure 4-8](#mounting_a_volume_or_directory_from_you).
  prefs: []
  type: TYPE_NORMAL
- en: '![Mounting a volume or directory from your Google Cloud Shell into a Docker
    container.](Images/gitc_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8\. Mounting a directory from your Google Cloud Shell VM into a Docker
    container: Ubuntu container used in this chapter (left); GATK container introduced
    in [Chapter 5](ch05.xhtml#first_steps_with_gatk) (right).'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As an example, let’s create a new directory called *book* in our Cloud Shell
    VM’s home directory, and put the *hello.txt* file from earlier inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So this time, let’s run the command to spin up our Ubuntu container by using
    the `-v` argument (where `v` is for volume), which allows us to specify a filesystem
    location and a mount point within the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-v ~/book_data:/home/book` part of the command links the location you
    specified to the path */home/book* directory within the Docker container. The
    `/home` part of the path is a directory that already exists in the container,
    whereas the `book` part can be any name you choose to give it. Now, everything
    in the `book` directory on your filesystem can be accessed from within the Docker
    container’s */home/book* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re using the same name for the mount point as for the actual location
    we’re mounting because it’s more intuitive that way, but you could use a different
    name if you wanted. Note that if you give your mount point the name of a directory
    or file that already exists with that path in the container, it will “squash”
    the existing path, meaning that path will not be accessible for as long as the
    volume is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: A few other Docker tricks are good to know, but for now, this is enough of a
    demonstration of the core Docker functionality that you’re going to use in [Chapter 5](ch05.xhtml#first_steps_with_gatk).
    We go into the details of more sophisticated options as we encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Your Own Custom VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve successfully run some basic file-management commands and got
    the hang of interacting with Docker containers, it’s time to move on to bigger
    and better things. The Google Cloud Shell environment is excellent for quickly
    getting started with some light coding and execution tasks, but the VM allocated
    for Cloud Shell is really underpowered and will definitely not cut the mustard
    when it comes to running real GATK analyses in [Chapter 5](ch05.xhtml#first_steps_with_gatk).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we show you how to set up your own VM in the cloud (sometimes
    called an *instance*) using Google’s Compute Engine service, which allows you
    to select, configure, and run VMs of whatever size you need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Configuring Your VM Instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, go to the [*Compute Engine*](https://oreil.ly/sGeug) or access the page
    through the sidebar menu on the left, as shown in [Figure 4-9](#compute_engine_menu_showing_the_vm_inst).
  prefs: []
  type: TYPE_NORMAL
- en: '![Compute Engine menu showing the VM instances menu item.](Images/gitc_0409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9\. Compute Engine menu showing the VM instances menu item.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click the VM Instances link in this menu to go to an overview of running images.
    If this is a new account, you won’t have any running. Notice at the top that there’s
    an option for Create Instance. Click that, and let’s walk through the process
    of creating a new VM with just the resources you need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the top menu bar, click Create Instance, as shown in [Figure 4-10](#create_an_instance).
    This brings up a configuration form, as shown in [Figure 4-11](#the_vm_instance_configuration_paneldot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Create an instance](Images/gitc_0410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. Create a VM instance.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![The VM instance configuration panel.](Images/gitc_0411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. The VM instance configuration panel.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Follow the step-by-step instructions in the subsections that follow to configure
    the VM. There are tons of options and the process can be quite confusing if you
    don’t have experience with the terminology, so we mapped out the simplest path
    through the configuration form that will allow you to run all of the command exercises
    in the first few chapters of this book. Please make sure that you use exactly
    the same settings as shown here unless you really know what you’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: Name your VM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Give your VM a name; for example, `genomics-book`, as shown in [Figure 4-12](#name_your_vm_instancedot).
    This must be unique within your project, but unlike bucket names, it does not
    need to be unique across GCP. Some people like to use their username so that others
    with access to the project can instantly identify who created the resource.
  prefs: []
  type: TYPE_NORMAL
- en: '![Name your VM instance.](Images/gitc_0412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12\. Name your VM instance.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Choose a region (important!) and zone (not so important)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are different physical locations for the cloud. Like most commercial cloud
    providers, GCP maintains datacenters in many parts of the world and provides you
    with the option to choose which one you want to use. Regions are the top-level
    geographical distinction, with names that are reasonably descriptive (like `us-west2`,
    which refers to a facility in Los Angeles). Each region is further divided into
    two or more zones designated by single letters (`a`, `b`, `c`, etc.), which correspond
    to separate datacenters with their own physical infrastructure (power, network,
    etc.), though in some cases they might share the same building.
  prefs: []
  type: TYPE_NORMAL
- en: This system of regions and zones plays an important role in limiting the impact
    of localized problems like power outages, and all major cloud providers use some
    version of this strategy. For more on this topic, see [this entertaining blog
    post](https://oreil.ly/pZUl6) by Kyle Galbraith about how cloud regions and zones
    (in his case, on AWS) could play an important role in the event of a zombie apocalypse.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ability to choose specific regions and zones for your projects is increasingly
    helpful for dealing with regulatory restrictions on where human-subjects data
    can be stored because it allows you to specify a compliant location for all storage
    and compute resources. However, some parts of the world are not yet well covered
    by cloud services or are covered differently by the various cloud providers, so
    you might need to factor in available datacenter locations when choosing a provider.
  prefs: []
  type: TYPE_NORMAL
- en: To choose a region for your project, you can consult the full list of [available
    Google Cloud regions and zones](https://oreil.ly/D4Iqa) and make a decision based
    on geographic proximity. Alternatively, you can use an online utility that measures
    how close you *effectively* are to each datacenter in terms of network response
    time, like [*http://www.gcping.com*](http://www.gcping.com). For example, if we
    run this test from the small town of Sunderland in western Massachusetts (results
    in [Table 4-1](#geographical_distance_and_response_time)), we find that it takes
    38 milliseconds to get a response from the `us-east4` region located in Northern
    Virginia (698 km away), versus 41 milliseconds from the `northamerica-northeast1`
    region located in Montreal (441 km away). This shows us that geographical proximity
    does not correlate directly with network region proximity. As an even more striking
    example, we find that we are quite a bit “closer” to the `europe-west2` region
    in London (5,353 km away), with a response time of 102 milliseconds, than to the
    `us-west2` region in Los Angeles (4,697 km away) which gives us a response time
    of 180 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Geographical distance and response time from Sunderland, MA
  prefs: []
  type: TYPE_NORMAL
- en: '| Region | Location | Distance (km) | Response (ms) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| us-east4 | Northern Virginia, US | 698 | 38 |'
  prefs: []
  type: TYPE_TB
- en: '| northamerica-northeast1 | Montreal | 441 | 41 |'
  prefs: []
  type: TYPE_TB
- en: '| europe-west2 | London | 5,353 | 102 |'
  prefs: []
  type: TYPE_TB
- en: '| us-west2 | Los Angeles | 4,697 | 180 |'
  prefs: []
  type: TYPE_TB
- en: This brings us back to our VM configuration. For the Region, we’re going to
    be using `us-east4` (Northern Virginia) because it’s closest to the one of us
    who travels least (Geraldine), and for the Zone we just randomly choose `us-east4-a`.
    You need to make sure that you choose *your* region based on the preceding discussion,
    both for your own benefit (it will be faster) and to avoid clobbering that one
    datacenter in Virginia in the unlikely event that all 60,000 registered users
    of the GATK software begin working through these exercises at the same time—though
    that’s one way to test the vaunted “elasticity” of the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Select a machine type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is where you can configure the resources of the VM you’re about to launch.
    You can control RAM as well as CPUs. For some instance types (available under
    Customize) you can even select VMs with GPUs, which are used to accelerate certain
    programs. The hitch is that what you select here will determine how much you’ll
    be billed per second of the VM’s uptime; the bigger and beefier the machine, the
    more it will cost you. The right side of the page should show how the hourly and
    monthly cost changes when you change the machine type. Note also that you’re billed
    for how long the VM is online, not for how much time you spend actually using
    it. We cover strategies for limiting costs later, but keep that in mind!
  prefs: []
  type: TYPE_NORMAL
- en: Here, select `n1-standard-2`; this is a fairly basic machine that’s not going
    to cost much at all, as shown in [Figure 4-13](#selecting_a_machine_typedot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a machine type.](Images/gitc_0413.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13\. Selecting a machine type.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Specify a container? (nope)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re not going to fill this out. This is useful if you want to use a very specific
    setup using a custom container image that you’ve preselected or generated yourself.
    In fact, we could have preconfigured a container for you and skipped a bunch of
    setup that’s coming next. But then you wouldn’t have the opportunity to learn
    how to do those things for yourself, would you? So, for now, let’s just skip this
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Customize the boot disk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like Machine Type, this is another really useful setting. You can define two
    things here: the OS that you want to use and the amount of disk space you want.
    The former is especially important if you need to use a particular type and version
    of OS. And, of course, the latter is important if you don’t want to run out of
    disk space halfway through your analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the system proposes a particular flavor of Linux OS, accompanied
    by a paltry 10 GB of disk space, as shown in [Figure 4-14](#choosing_a_different_boot_diskdot).
    We’re going to need a bigger boat.
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing a different boot disk. ](Images/gitc_0414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-14\. Choosing a boot disk size and image.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To access the settings menu for this, click Change. This opens a new screen
    with a menu of predefined options. You can also make your own custom images, or
    even find more images in [Google Cloud Marketplace](https://oreil.ly/sjiIf).
  prefs: []
  type: TYPE_NORMAL
- en: For our immediate purposes, we prefer Ubuntu 18.04 LTS, which is the most recent
    version of Ubuntu’s long-term release, as of this writing. It might not be as
    bleeding edge as Ubuntu 19.04, but the LTS, which stands for *long-term support*,
    guarantees that it’s being maintained for security vulnerabilities and package
    updates for five years from release. This Ubuntu image has a ton of what we already
    need, ready to go and installed, including various standard Linux tools and the
    GCP SDK command-line tools, which we will rely on quite heavily.
  prefs: []
  type: TYPE_NORMAL
- en: Select Ubuntu in the Operating System menu, then select Ubuntu 18.04 LTS in
    the version menu, as shown in [Figure 4-15](#selecting_a_base_imagedot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a base image.](Images/gitc_0415.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-15\. Selecting a base image.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the bottom of the form, you can change the Boot disk Size to give yourself
    more space. As shown in [Figure 4-16](#setting_the_boot_disk_sizedot), go ahead
    and select 100 GB instead of the default 10 GB (the data we’re going to be working
    with can easily take up a lot of space). You can bump this up quite a bit more,
    depending on your dataset size and needs. Although you can’t easily adjust it
    after the VM launches, you do have the option of adding block storage volumes
    to the running instance after launch—think of it as the cloud equivalent of plugging
    in a USB drive. So if you run out of disk space, you won’t be totally stuck.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting the boot disk size.](Images/gitc_0416.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-16\. Setting the boot disk size.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After you’ve done all this, click Select; this closes the screen and returns
    you to the instance creation form where the “Boot disk” section should match the
    screenshot in [Figure 4-17](#the_updated_boot_disk_selectiondot).
  prefs: []
  type: TYPE_NORMAL
- en: '![The updated boot disk selection.](Images/gitc_0417.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-17\. The updated boot disk selection.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the bottom of the form, click Create. This returns you to the page that lists
    Compute Engine VM instances, including your newly created VM instance. You might
    see a spinning icon in front of its name while the instance is being created and
    booted up, and then a green circle with a checkmark will appear when it is running
    and ready for use, as shown in [Figure 4-18](#viewing_the_vm_statusdot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the VM status.](Images/gitc_0418.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-18\. Viewing the VM status.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And voilà, your VM is ready for action.
  prefs: []
  type: TYPE_NORMAL
- en: Logging into Your VM by Using SSH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways that you can access the VM after it’s running, which
    you can learn about in the GCP documentation. We’re going to show you the simplest
    way to do it, using the Google Cloud console and the built-in SSH terminal. It’s
    hard to beat: as soon as you see a green checkmark in the Google Cloud console,
    you can simply click the SSH option to open a drop-down menu, as illustrated in
    [Figure 4-19](#options_for_sshing_into_your_vm). Select the option “Open in a
    browser window,” and a few seconds later you should see an SSH terminal open to
    this VM.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Options for SSHing into your VM](Images/gitc_0419.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-19\. Options for SSHing into your VM.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This opens a new window with a terminal that allows you to run commands from
    within the VM instance, as shown in [Figure 4-20](#vm_instance_terminaldot). It
    might take a minute to establish the connection.
  prefs: []
  type: TYPE_NORMAL
- en: '![VM instance terminal.](Images/gitc_0420.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-20\. VM instance terminal.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Feel free to look around and get to know your brand-new VM; you’re going to
    spend a lot of time with it in the course of the next few chapters (but, like,
    in a good way).
  prefs: []
  type: TYPE_NORMAL
- en: Checking Your Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re probably itching to run something interesting, but let’s begin by making
    sure your account credentials are set up properly so you can use the GCP command-line
    tools, which come preinstalled on the image we chose. In the SSH terminal, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The line that starts with `[1]` shows you that by default, GCP has you logged
    in under a service account: the domain is *@developer.gserviceaccount.com*. This
    is fine for running tools within your VM, but if you want to be able to manage
    resources, including copying files out to GCS buckets, you need to do so under
    an account with the relevant permissions. It is possible to grant this service
    account all the various permissions that you’ll need for these exercises, but
    that would lead us a bit further into the guts of GCP account administration than
    we’d like to go at this juncture—we want to get you doing genomics work ASAP!
    So instead, let’s just use the original account that you used to create the project
    at the beginning of this chapter, given that it already has those permissions
    as a project owner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To log in with that account, press 2 at the prompt. This triggers some interaction
    with the program; GCP will warn you that using your personal credentials on a
    VM is a security risk because if you give someone else access to the VM, they
    will be able to use your credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution: don’t share access to your personal VM.^([1](ch04.xhtml#ch04fn1))'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type Y for yes, the program will give you a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When you click the link or copy and paste it into your browser, you are presented
    with a Google login page. Log in with the same account you used for the GCP to
    get your authentication code and then copy and paste that back into your terminal
    window. The `gcloud` utility will confirm your login identity and ask you to select
    the project ID you want to use from the list of projects you have access to. It
    will also offer the option to set your preferred compute and storage zone, which
    should match what you set earlier when you created the VM. If you’re not seeing
    what you expect in the project ID list, you can always double-check the [resource
    management page in the GCP console](https://oreil.ly/T50ev).
  prefs: []
  type: TYPE_NORMAL
- en: Copying the Book Materials to Your VM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout the next few chapters, you’re going to run real GATK commands and
    workflows on your VM, so you need to retrieve the example data, source code, and
    a couple of software packages. We’ve bundled most of that in a single place: a
    Cloud Storage bucket called `genomics-in-the-cloud`. The only piece that is separate
    is the source code, which we provide in GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’re going to copy the data bundle from the bucket to your VM using
    `gsutil`, the GCP storage utility that we already used earlier in the Cloud Shell
    portion of this chapter. In your VM’s terminal window, make a new directory called
    `**book**`, and then run the `gsutil` command to copy the book data bundle to
    the storage space associated with your VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will copy about 10 GB of data to your VM’s storage, so it might take a
    few minutes even with the `-m` flag enabling parallel downloads. As you’ll see
    later, it is possible to run some analysis commands directly on files in Cloud
    Storage without copying them first, but we want to keep things as simple as possible
    in the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and retrieve the source code from the [public repository on GitHub](https://oreil.ly/genomics-repo).
    We’re making the code available there because it’s a highly popular platform for
    sharing code under *version control*, and we’re committed to providing long-term
    maintenance for the code we use in the book. To get a copy on your VM, first use
    `cd` to move into the newly created *book* directory and then use the `git clone`
    command to copy the contents of the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a directory (*~book/code*) that includes all the sample code we
    use throughout the book. Not only that, but it will be set up as an active Git
    repository, so you can get the latest changes by running the `git pull` command
    in the code directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With that, you should now have the latest and greatest version of the book code.
    To find out what has changed since the original publication, check out the *README*
    text file in the code directory.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker on Your VM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re going to be working with Docker on your VM, so let’s make sure that
    you can run it. If you simply run the command `docker` in the terminal, you’ll
    get an error message because Docker does not come preinstalled on the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message helpfully points out how to remedy the situation using a
    preinstalled package called `snap`, but we’re actually going to use a slightly
    different way of installing Docker: we’re going to download and run a script from
    the Docker website that will largely automate the installation process. This way,
    you’ll know what to do if you find yourself needing to install Docker somewhere
    that doesn’t have a built-in package manager option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install Docker on the VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This might take a little while to complete, so let’s take that time to examine
    the command in a bit more detail. First, we’re using a convenient little utility
    called `curl` (short for *Client URL*) to download the installation script from
    the Docker website URL we provided, with a few command parameters (`-sSL`) that
    instruct the program to follow any redirection links and save the output as a
    file. Then, we use the pipe character (`|`) to hand that output file over to a
    second command, `sh`, which means “run that script that we just gave you.” The
    first line of output lets you know what it’s doing: `Executing docker install
    script` (we omitted parts of the preceding output for brevity).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it finishes, the script prompts you to run the `usermod` command in the
    example that follows in order to grant yourself the ability to run Docker commands
    without using `sudo` each time. Invoking `sudo docker` can result in output files
    being owned by root, making it difficult to manage or access them later, so it’s
    really important to do this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This does not produce any output; we’ll test in a minute whether it worked
    properly. First, however, you need to log out of your VM and then back in again.
    Doing so will make the system reevaluate your Unix group membership, which is
    necessary for the change you just made to take effect. Simply type `**exit**`
    (or press Ctrl+D) at the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This closes the terminal window to your VM. Go back to the GCP console, find
    your VM in the list of Compute Engine instances, and then click SSH to log back
    in again. This probably feels like a lot of hoops to jump through, but hang in
    there; we’re getting to the good part.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the GATK Container Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re back in your VM, test your Docker installation by pulling the GATK
    container, which we use in the very next chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, the last bit after the container name is the version tag, which
    you can change to get a different version than what we’ve specified here. Note
    that if you change the version, some commands might no longer work. We can’t guarantee
    that all code examples are going to be future-compatible, especially for the newer
    tools, some of which are still under active development. As noted earlier, for
    updated materials, see [this book’s GitHub repository](https://oreil.ly/genomics-repo).
  prefs: []
  type: TYPE_NORMAL
- en: The GATK container image is quite large, so the download might take a little
    while. The good news is that next time you need to pull a GATK image (e.g., to
    get another release), Docker will pull only the components that have been updated,
    so it will go faster.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here we’re pulling the GATK image from the Google Container Repository (GCR)
    because GCR is on the same network as the VM we’re running on, so it will be faster
    than pulling it from Docker Hub. However, if you’re working on a different platform,
    you might find it faster to pull the image from the GATK repository on Docker
    Hub. To do so, change the `us.gcr.io/broad-gatk` part of the image path to just
    `**broadinstitute**`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remember the instructions you followed earlier in this chapter to spin
    up a container with a mounted folder? You’re going to use that again to make the
    `book` directory accessible to the GATK container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to browse the `book` directory that you set up in your
    VM from within the container. It will be located under */home/book*. Finally,
    to double-check that GATK itself is working as expected, try running the command
    `gatk` at the command line from within your running container. If everything is
    working properly, you should see some text output that outlines basic GATK command-line
    syntax and a few configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We discuss what that all means in loving detail in [Chapter 5](ch05.xhtml#first_steps_with_gatk);
    for now, you’re done setting up the environment that you’ll be using to run GATK
    tools over the course of the next three chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping Your VM…to Stop It from Costing You Money
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The VM you just finished setting up is going to come in handy throughout the
    book; you’ll come back to this VM for many of the exercises in the next few chapters.
    However, as long as it’s up and running, it’s costing you either credits or actual
    money. The simplest way to deal with that is to stop it: put it on pause whenever
    you’re not actively using it.'
  prefs: []
  type: TYPE_NORMAL
- en: You can restart it on demand; it just takes a minute or two to get it back up
    and running, and it will retain all environment settings, the history of what
    you ran previously, and whatever data you have in local storage. Note that you
    will be charged a small fee for that storage even while the VM is not running
    and you’re not getting charged for the VM itself. In our opinion, this is well
    worth it for the convenience of being able to come back to your VM after an arbitrary
    amount of time and just pick up your work where you left off.
  prefs: []
  type: TYPE_NORMAL
- en: To stop your VM, in the GCP console, go to the VM instances management page,
    as shown previously. Find your instance and click the vertical three-dot symbol
    on the right to open the menu of controls, and then select Stop, as shown in [Figure 4-21](#stoppingcomma_startingcomma_or_deleting).
    The process might take a couple of minutes to complete, but you can safely navigate
    away from that page. To restart your instance later on, just follow the same steps
    but click Start in the control menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stopping, starting, or deleting your VM instance.](Images/gitc_0421.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-21\. Stopping, starting, or deleting your VM instance.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alternatively, you can delete your VM entirely, but keep in mind that deleting
    the VM will delete all locally stored data too, so make sure you save anything
    you care about to a storage bucket first.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IGV to Read Data from GCS Buckets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just one more small step remains before you move on to the next chapter: we’re
    going to install and configure a genome browser called Integrated Genome Viewer
    (IGV) that can work directly with files in GCP. That will allow you to examine
    sequence data and variant calls without needing to copy the files to your local
    machine.'
  prefs: []
  type: TYPE_NORMAL
- en: First, if you don’t have it installed yet on your local machine, get the [IGV
    program from the website](https://oreil.ly/bEPS_) and follow the installation
    instructions. If you already have a copy, consider updating it to the latest version;
    we are using 2.7.2 (macOS version). Once you have the application open, choose
    View > Preferences from the top menu bar, as shown in [Figure 4-22](#selecting_the_preferences_menu_itemdot).
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting the Preferences menu item.](Images/gitc_0422.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-22\. Selecting the Preferences menu item.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This opens the Preferences pane, shown in [Figure 4-23](#the_igv_preferences_panedot).
  prefs: []
  type: TYPE_NORMAL
- en: In the Preferences pane, Select the “Enable Google access” checkbox, click Save,
    and then quit IGV and reopen it to force a refresh of the top menu bar. You should
    now see a Google menu item that was not there previously; click it and select
    Login, as shown in [Figure 4-24](#selecting_the_google_login_menu_itemdot), to
    set up IGV with your Google account credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '![The IGV Preferences pane.](Images/gitc_0423.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-23\. The IGV Preferences pane.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Selecting the Google Login menu item.](Images/gitc_0424.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-24\. Selecting the Google Login menu item.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This will take you to a Google login page in your web browser; follow the prompts
    to allow IGV to access relevant permissions on your Google account. When this
    is complete, you should see a web page that simply says OK. Let’s switch back
    to IGV and test that it works. From the top-level menu, click Files > Load from
    URL, as shown in [Figure 4-25](#the_quotload_from_urlquot_menu_itemdot), making
    sure not to select one of the other options by mistake (they look similar, so
    it’s easy to get tripped up). Make sure also that the reference drop-down menu
    in the upper-left corner of the IGV window is set to “Human hg19.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re confused about what is different between the human references, see
    the notes in [“The Reference Genome as Common Framework”](ch02.xhtml#the_reference_genome_as_common_framewor)
    about hg19 and GRCh38.
  prefs: []
  type: TYPE_NORMAL
- en: '![The "Load from URL" menu item.](Images/gitc_0425.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-25\. The Load from URL menu item.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, enter the GCS file path for one of the sample BAM files we provide
    in the book data bundle in the dialog window that pops up (e.g., *mother.bam*,
    as shown in [Figure 4-26](#the_quotload_from_urlquot_dialog_boxdot)), and then
    click OK. Remember, you can get a list of files in the bucket by using `gsutil`
    from your VM or from Cloud Shell, or you can browse the contents of the bucket
    by using the [Google Cloud console storage browser](https://oreil.ly/1iQmv). If
    you use the browser interface to get the path to the file, you’ll need to compose
    the GCS file path by stripping off the first part of the URL before the bucket
    name; for instance, remove *https://console.cloud.google.com/storage/browser*
    and replace that with `**gs://**`. Do the same for the BAM’s accompanying index
    file, which should have the same filename and path but ends in *.bai*.^([2](ch04.xhtml#idm45625633939976))
  prefs: []
  type: TYPE_NORMAL
- en: '![The "Load from URL" dialog box.](Images/gitc_0426.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-26\. The Load from URL dialog box.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This will make the data available to you in IGV as a new data track, but by
    default nothing will be loaded in the main viewer. To check that you can view
    data, in the search window, enter the genomic coordinates `**20:9,999,830-10,000,170**`
    and then click Go. These coordinates will take you to the 10 millionth DNA base
    ±170 on the 20th human chromosome, as shown in [Figure 4-27](#igv_view_of_a_bam_file_located_in_a_gcs),
    where you’ll see the left-side edge of the slice of sequence data that we provide
    in this sample file. We explain in detail how to interpret the visual output of
    IGV in [Chapter 5](ch05.xhtml#first_steps_with_gatk), when we use it to investigate
    the result of a real (small) analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '![IGV view of a BAM file located in a GCS bucket.](Images/gitc_0427.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-27\. IGV view of a BAM file located in a GCS bucket.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: IGV retrieves only small slices of data at a time, so the transfer should be
    very fast unless you have a particularly slow internet connection. Do keep in
    mind, however, that GCP, like all commercial cloud providers, will charge an [egress
    fee](https://oreil.ly/rktm2) for transferring data out of the cloud. On the bright
    side, it’s a small fee, proportional to the amount of data you transfer. So the
    cost of viewing slices of data in IGV is trivial—on the order of fractions of
    pennies—and it is definitely preferable to what it would cost to transfer the
    entire file for offline browsing!
  prefs: []
  type: TYPE_NORMAL
- en: You can view the contents of other data files, like VCF files, using the same
    set of operations, as long as the files are stored in a GCP bucket. Unfortunately,
    it means that this won’t work for files that are on the local storage of your
    VM, so anytime you want to examine one of those, you’ll need to copy it to a bucket
    first. You’re going to get really friendly with `gsutil` in no time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, one last thing while you have IGV open: click the little yellow callout
    bubble in the IGV window toolbar, which controls the behavior of the detail viewer,
    as shown in [Figure 4-28](#changing_the_behavior_of_the_detail_vie). Do yourself
    a favor and switch the setting from Show Details on Hover to Show Details on Click.
    Whichever action you choose will trigger the appearance of little dialog that
    gives you detailed information about any part of the data that you either click
    or hover over; for example, for a sequence read, it will give you all the mapping
    information as well as the full sequence and base qualities. You can try it out
    now with the data you just loaded. As you’ll see, the detail display functionality
    in and of itself is very convenient, but the “on Hover” version of this behavior
    can be a bit overwhelming when you’re new to the interface; hence, our recommendation
    to switch to “on Click.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the behavior of the detail viewer from "on Hover" to "on Click."](Images/gitc_0428.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-28\. Changing the behavior of the detail viewer from “on Hover” to
    “on Click.”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Wrap-Up and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we showed you how to get started with GCP resources, from creating
    an account, using the super-basic Cloud Shell, and then graduating to your own
    custom VM. You learned how to manage files in GCS, run Docker containers, and
    administer your VM. Finally, you retrieved the book data and source code, finished
    setting up your custom VM to work with the GATK container, and set up IGV to view
    data stored in buckets. In [Chapter 5](ch05.xhtml#first_steps_with_gatk), we get
    you started with GATK itself, and before you know it, you’ll be running real genomics
    tools on example data in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.xhtml#ch04fn1-marker)) Keep in mind that if you create accounts for
    other users in your GCP project, they will be able to SSH to your VMs as well.
    It is possible to further restrict access to your VMs in a shared project, but
    that is beyond the simple introduction we’re presenting here.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.xhtml#idm45625633939976-marker)) For example, *https://console.cloud.google.com/storage/browser/genomics-in-the-cloud/v1/data/germline/bams/mother.bam*
    becomes *gs://genomics-in-the-cloud/v1/data/germline/bams/mother.bam*.
  prefs: []
  type: TYPE_NORMAL
