<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Storage"><div class="chapter" id="storage">
<h1><span class="label">Chapter 6. </span>Storage</h1>


<p><a data-type="indexterm" data-primary="storage" id="sto_ch"/>When container images are instantiated as containers, the container needs context—context to CPU, memory, and I/O resources. Pods provide the network and the filesystem context for the containers within. The network is provided as the Pod’s virtual IP address, and the filesystem is mounted to the hosting node’s filesystem. Applications running in the container can interact with the filesystem as part of the Pod context. A container’s temporary filesystem is isolated from any other container or Pod and is not persisted beyond a Pod restart. The “Storage” section of the CKA curriculum addresses the technical abstraction in Kubernetes responsible for persisting data beyond a container or Pod restart.</p>

<p>A volume is a Kubernetes capability that persists data beyond a Pod restart. Essentially, a volume is a directory that’s shareable between multiple containers of a Pod. You will learn about the different volume types and the process for defining and mounting a volume in a container.</p>

<p>Persistent volumes are a specific category of the wider concept of volumes. The mechanics for persistent volumes are slightly more complex. The persistent volume is the resource that actually persists the data to an underlying physical storage. The persistent volume claim represents the connecting resource between a Pod and a persistent volume responsible for requesting the storage. Finally, the Pod needs to <em>claim</em> the persistent volume and mount it to a directory path available to the containers running inside of the Pod.</p>

<p>At a high level, this chapter covers the following concepts:</p>

<ul>
<li>
<p>Persistent volume</p>
</li>
<li>
<p>Static versus dynamic provision of persistent volumes</p>
</li>
<li>
<p>Storage Class</p>
</li>
<li>
<p>Configuration options for a persistent volume</p>
</li>
<li>
<p>Persistent volume claim</p>
</li>
<li>
<p>Mounting a persistent volume in a Pod</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="Understanding Volumes"><div class="sect1" id="idm45322717573072">
<h1>Understanding Volumes</h1>

<p><a data-type="indexterm" data-primary="storage" data-secondary="Volumes" id="idm45322717571872"/><a data-type="indexterm" data-primary="Volumes" data-secondary="about" id="idm45322717570896"/>Applications running in a container can use the temporary filesystem to read and write files. In the case of a container crash or a cluster/node restart, the kubelet will restart the container. Any data that had been written to the temporary filesystem is lost and cannot be retrieved anymore. The container effectively starts with a clean slate again.</p>

<p><a data-type="indexterm" data-primary="multi-container Pods" id="idm45322717569568"/><a data-type="indexterm" data-primary="Pods" data-secondary="multi-container" id="idm45322717568864"/>There are many uses cases for wanting to mount a volume in a container. One of the most prominent use cases are <a href="https://oreil.ly/EtTx4">multi-container Pods</a> that use a volume to exchange data between a main application container and a sidecar. <a data-type="xref" href="#tmp_file_system_volume">Figure 6-1</a> illustrates the differences between the temporary filesystem of a container and the use of a volume.</p>

<figure><div id="tmp_file_system_volume" class="figure"><div class="border-box"><img src="Images/ckas_0601.png" alt="ckas 0601" width="1389" height="486"/></div><h6><span class="label">Figure 6-1. </span>A container using the temporary filesystem versus a volume</h6></div></figure>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Volume Types"><div class="sect1" id="idm45322717563760">
<h1>Volume Types</h1>

<p><a data-type="indexterm" data-primary="Volumes" data-secondary="types of" id="idm45322717562480"/>Every volume needs to define a type. The type determines the medium that backs the volume and its runtime behavior. The Kubernetes documentation offers a long list of volume types. Some of the types—for example, <code>azureDisk</code>, <code>awsElasticBlockStore</code>, or <code>gcePersistentDisk</code>—are available only when running the Kubernetes cluster in a specific cloud provider. <a data-type="xref" href="#table_volume_types">Table 6-1</a> shows a reduced list of volume types that I deem to be most relevant to the exam.<a data-type="indexterm" data-primary="ConfigMap type" data-secondary="about" id="idm45322717558704"/><a data-type="indexterm" data-primary="emptyDir type" id="idm45322717557760"/><a data-type="indexterm" data-primary="hostPath type" id="idm45322717557088"/><a data-type="indexterm" data-primary="nfs type" id="idm45322717556416"/><a data-type="indexterm" data-primary="PersistentVolumeClaim type" data-secondary="about" id="idm45322717555744"/><a data-type="indexterm" data-primary="Secret type" data-secondary="about" id="idm45322717554832"/></p>
<table id="table_volume_types">
<caption><span class="label">Table 6-1. </span>Volume types relevant to exam</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>emptyDir</code></p></td>
<td><p>Empty directory in Pod with read/write access. Persisted for only the lifespan of a Pod. A good choice for cache implementations or data exchange between containers of a Pod.</p></td>
</tr>
<tr>
<td><p><code>hostPath</code></p></td>
<td><p>File or directory from the host node’s filesystem.</p></td>
</tr>
<tr>
<td><p><code>configMap</code>, <code>secret</code></p></td>
<td><p>Provides a way to inject configuration data. For practical examples, see <a data-type="xref" href="ch03.xhtml#defining_consuming_configuration_data">“Defining and Consuming Configuration Data”</a>.</p></td>
</tr>
<tr>
<td><p><code>nfs</code></p></td>
<td><p>An existing Network File System (NFS) share. Preserves data after Pod restart.</p></td>
</tr>
<tr>
<td><p><code>persistentVolumeClaim</code></p></td>
<td><p>Claims a persistent volume. Fore more information, see <a data-type="xref" href="#creating_pvc">“Creating PersistentVolumeClaims”</a>.</p></td>
</tr>
</tbody>
</table>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Creating and Accessing Volumes"><div class="sect1" id="idm45322717539056">
<h1>Creating and Accessing Volumes</h1>

<p><a data-type="indexterm" data-primary="Volumes" data-secondary="creating and accessing" id="idm45322717537776"/>Defining a volume for a Pod requires two steps. First, you need to declare the volume itself using the attribute <code>spec.volumes[]</code>. As part of the definition, you provide the name and the type. Just declaring the volume won’t be sufficient, though. Second, the volume needs to be mounted to a path of the consuming container via 
<span class="keep-together"><code>spec.containers.volumeMounts[]</code>.</span> The mapping between the volume and the volume mount occurs by the matching name.</p>

<p>From the YAML manifest stored in the file <code>pod-with-volume.yaml</code> and shown in <a data-type="xref" href="#pod_defining_mounting_volume">Example 6-1</a>, you can see the definition of a volume with type <code>emptyDir</code>. The volume has been mounted to the path <em>/var/logs</em> inside of the container named <code>nginx</code>.</p>
<div id="pod_defining_mounting_volume" data-type="example">
<h5><span class="label">Example 6-1. </span>A Pod defining and mounting a volume</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">business-app</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">logs-volume</code><code class="w"/>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{}</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/logs</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">logs-volume</code><code class="w"/></pre></div>

<p class="pagebreak-before">Let’s create the Pod and see if we can interact with the mounted volume. The following commands open an interactive shell after the Pod’s creation and then navigate to the mount path. You can see that the volume type <code>emptyDir</code> initializes the mount path as an empty directory. New files and directories can be created as needed without limitations:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f pod-with-volume.yaml</strong>
pod/business-app created
<strong>$ kubectl get pod business-app</strong>
NAME           READY   STATUS    RESTARTS   AGE
business-app   1/1     Running   0          43s
<strong>$ kubectl exec business-app -it -- /bin/sh</strong>
# cd /var/logs
# pwd
/var/logs
# ls
# touch app-logs.txt
# ls
app-logs.txt</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Understanding Persistent Volumes"><div class="sect1" id="idm45322717437712">
<h1>Understanding Persistent Volumes</h1>

<p><a data-type="indexterm" data-primary="PersistentVolumes" data-secondary="about" id="idm45322717436336"/><a data-type="indexterm" data-primary="storage" data-secondary="PersistentVolumes" id="sto_pv"/>Data stored on Volumes outlive a container restart. In many applications, the data lives far beyond the lifecycles of the applications, container, Pod, nodes, and even the clusters themselves. Data persistence ensures the lifecycles of the data are decoupled from the lifecycles of the cluster resources. A typical example would be data persisted by a database. That’s the responsibility of a persistent volume. Kubernetes models persist data with the help of two primitives: the PersistentVolume and the PersistentVolumeClaim.</p>

<p>The PersistentVolume is the storage device in a Kubernetes cluster. It is completely decoupled from the Pod and therefore has its own lifecycle. The object captures the source of the storage (e.g., storage made available by a cloud provider). A PersistentVolume is either provided by a Kubernetes administrator or assigned dynamically by mapping to a storage class.</p>

<p>The PersistentVolumeClaim requests the resources of a PersistentVolume—for example, the size of the storage and the access type. In the Pod, you will use the type 
<span class="keep-together"><code>persistentVolumeClaim</code></span> to mount the abstracted PersistentVolume by using the PersistentVolumeClaim.</p>

<p><a data-type="xref" href="#pvc_relationship">Figure 6-2</a> shows the relationship between the Pod, the PersistentVolumeClaim, and the PersistentVolume.</p>

<figure><div id="pvc_relationship" class="figure"><div class="border-box"><img src="Images/ckas_0602.png" alt="ckas 0602" width="1133" height="276"/></div><h6><span class="label">Figure 6-2. </span>Claiming a PersistentVolume from a Pod</h6></div></figure>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Static vs. Dynamic Provisioning"><div class="sect1" id="idm45322717428976">
<h1>Static vs. Dynamic Provisioning</h1>

<p><a data-type="indexterm" data-primary="dynamic provisioning" id="idm45322717427808"/><a data-type="indexterm" data-primary="static provisioning" id="idm45322717427104"/><a data-type="indexterm" data-primary="storage" data-secondary="static vs. dynamic provisioning" id="idm45322717426432"/><a data-type="indexterm" data-primary="PersistentVolumes" data-secondary="static vs. dynamic provisioning" id="idm45322717425520"/>A PersistentVolume can be created statically or dynamically. If you go with the static approach, then you need to create a storage device first and reference it by explicitly creating an object of kind PersistentVolume. The dynamic approach doesn’t require you to create a PersistentVolume object. It will be automatically created from the PersistentVolumeClaim by setting a storage class name using the attribute 
<span class="keep-together"><code>spec.storageClassName</code></span>.</p>

<p>A storage class is an abstraction concept that defines a class of storage device (e.g., storage with slow or fast performance) used for different application types. It’s the job of a Kubernetes administrator to set up storage classes. For a deeper discussion on storage classes, see <a data-type="xref" href="#understanding_storage_class">“Understanding Storage Classes”</a>. For now, we’ll focus on the static provisioning of PersistentVolumes.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Creating PersistentVolumes"><div class="sect1" id="creating_pv">
<h1>Creating PersistentVolumes</h1>

<p><a data-type="indexterm" data-primary="PersistentVolumes" data-secondary="creating" id="idm45322717399392"/><a data-type="indexterm" data-primary="create command" id="idm45322717398192"/><a data-type="indexterm" data-primary="commands" data-secondary="create" id="idm45322717397520"/>When you create a PersistentVolume object yourself, we refer to the approach as static provisioning. A PersistentVolume can be created only by using the manifest-first approach. At this time, <code>kubectl</code> doesn’t allow the creation of a PersistentVolume using the <code>create</code> command. Every PersistentVolume needs to define the storage capacity using <code>spec.capacity</code> and an access mode set via <code>spec.accessModes</code>. See <a data-type="xref" href="#configuring_pv">“Configuration Options for a PersistentVolume”</a> for more information on the configuration options available to a PersistentVolume.</p>

<p><a data-type="xref" href="#yaml_manifest_persistent_volume">Example 6-2</a> creates a PersistentVolume named <code>db-pv</code> with a storage capacity of 1Gi and read/write access by a single node. The attribute <code>hostPath</code> mounts the directory 
<span class="keep-together"><code>/data/db</code></span> from the host node’s filesystem. We’ll store the YAML manifest in the file <code>db-pv.yaml</code>.</p>
<div id="yaml_manifest_persistent_volume" data-type="example" class="less_space pagebreak-before">
<h5><span class="label">Example 6-2. </span>YAML manifest defining a PersistentVolume</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolume</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-pv</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">capacity</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1Gi</code><code class="w"/>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>
<code class="w">  </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/data/db</code><code class="w"/></pre></div>

<p>Upon inspection of the created PersistentVolume, you’ll find most of the information you provided in the manifest. The status <code>Available</code> indicates that the object is ready to be claimed. The reclaim policy determines what should happen with the PersistentVolume after it has been released from its claim. By default, the object will be retained. The following example uses the short-form command <code>pv</code> to avoid having to type <code>persistentvolume</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f db-pv.yaml</strong>
persistentvolume/db-pv created
<strong>$ kubectl get pv db-pv</strong>
NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    \
  CLAIM   STORAGECLASS   REASON   AGE
db-pv   1Gi        RWO            Retain           Available \
                                  10s</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Configuration Options for a PersistentVolume"><div class="sect1" id="configuring_pv">
<h1>Configuration Options for a PersistentVolume</h1>

<p><a data-type="indexterm" data-primary="PersistentVolumes" data-secondary="configuring" id="idm45322717346768"/>A PersistentVolume offers a variety of configuration options that determine their innate runtime behavior. For the exam, it’s important to understand the volume mode, access mode, and reclaim policy configuration options.</p>








<section data-type="sect2" data-pdf-bookmark="Volume Mode"><div class="sect2" id="idm45322717345296">
<h2>Volume Mode</h2>

<p><a data-type="indexterm" data-primary="volume mode" id="idm45322717343888"/>The volume mode handles the type of device. That’s a device either meant to be consumed from the filesystem or backed by a block device. The most common case is a filesystem device. You can set the volume mode using the attribute <code>spec.volumeMode</code>. <a data-type="xref" href="#persistentvolume_volume_modes">Table 6-2</a> shows all available volume modes.<a data-type="indexterm" data-primary="Filesystem type" id="idm45322717341840"/><a data-type="indexterm" data-primary="Block type" id="idm45322717341168"/></p>
<table id="persistentvolume_volume_modes">
<caption><span class="label">Table 6-2. </span>PersistentVolume volume modes</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><span class="keep-together"><code>Filesystem</code></span></p></td>
<td><p>Default. Mounts the volume into a directory of the consuming Pod. Creates a filesystem first if the volume is backed by a block device and the device is empty.</p></td>
</tr>
<tr>
<td><p><code>Block</code></p></td>
<td><p>Used for a volume as a raw block device without a filesystem on it.</p></td>
</tr>
</tbody>
</table>

<p><a data-type="indexterm" data-primary="get pv command" id="idm45322717289328"/><a data-type="indexterm" data-primary="commands" data-secondary="get pv" id="idm45322717288624"/>The volume mode is not rendered by default in the console output of the <code>get pv</code> command. You will need to provide the <code>-o wide</code> command-line option to see the VOLUMEMODE column, as shown here:</p>

<pre data-type="programlisting"><strong>$ kubectl get pv -o wide</strong>
NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    \
CLAIM   STORAGECLASS   REASON   AGE   VOLUMEMODE
db-pv   1Gi        RWO            Retain           Available \
                                19m   Filesystem</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Access Mode"><div class="sect2" id="idm45322717285280">
<h2>Access Mode</h2>

<p><a data-type="indexterm" data-primary="access mode" id="idm45322717283936"/>Each PersistentVolume can express how it can be accessed using the attribute <code>spec.accessModes</code>. For example, you can define that the volume can be mounted only by a single Pod in a read or write mode or that a volume is read-only but accessible from different nodes simultaneously. <a data-type="xref" href="#persistentvolume_access_modes">Table 6-3</a> provides a high-level overview of the available access modes. The short-form notation of the access mode is usually rendered in outputs of specific commands, e.g., <code>get pv</code> or <code>describe pv</code>.<a data-type="indexterm" data-primary="ReadOnlyMany type" id="idm45322717280864"/><a data-type="indexterm" data-primary="ReadWriteOnce type" id="idm45322717280128"/><a data-type="indexterm" data-primary="ReadWriteMany type" id="idm45322717279456"/><a data-type="indexterm" data-primary="ReadWriteOncePod type" id="idm45322717278784"/></p>
<table id="persistentvolume_access_modes">
<caption><span class="label">Table 6-3. </span>PersistentVolume access modes</caption>
<thead>
<tr>
<th>Type</th>
<th>Short Form</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>ReadWriteOnce</code></p></td>
<td><p>RWO</p></td>
<td><p>Read/write access by a single node</p></td>
</tr>
<tr>
<td><p><code>ReadOnlyMany</code></p></td>
<td><p>ROX</p></td>
<td><p>Read-only access by many nodes</p></td>
</tr>
<tr>
<td><p><code>ReadWriteMany</code></p></td>
<td><p>RWX</p></td>
<td><p>Read/write access by many nodes</p></td>
</tr>
<tr>
<td><p><code>ReadWriteOncePod</code></p></td>
<td><p>RWOP</p></td>
<td><p>Read/write access mounted by a single Pod</p></td>
</tr>
</tbody>
</table>

<p>The following command parses the access modes from the PersistentVolume named <code>db-pv</code>. As you can see, the returned value is an array underlining the fact that you can assign multiple access modes at once:</p>
<pre data-type="programlisting">
<strong>$ kubectl get pv db-pv -o jsonpath='{.spec.accessModes}'</strong>
["ReadWriteOnce"]
</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Reclaim Policy"><div class="sect2" id="idm45322717262832">
<h2>Reclaim Policy</h2>

<p><a data-type="indexterm" data-primary="reclaim policy" id="idm45322717261456"/>Optionally, you can also define a reclaim policy for a PersistentVolume. The reclaim policy specifies what should happen to a PersistentVolume object when the bound PersistentVolumeClaim is deleted (see <a data-type="xref" href="#persistentvolume_reclaim_policy">Table 6-4</a>). For dynamically created PersistentVolumes, the reclaim policy can be set via the attribute 
<span class="keep-together"><code>.reclaimPolicy</code></span> in the storage class. for statically created PersistentVolumes, use the attribute 
<span class="keep-together"><code>spec.persistentVolumeReclaimPolicy</code></span> in the PersistentVolume definition .<a data-type="indexterm" data-primary="Delete type" id="idm45322717257616"/><a data-type="indexterm" data-primary="Retain type" id="idm45322717256976"/><a data-type="indexterm" data-primary="Recycle type" id="idm45322717256304"/></p>
<table id="persistentvolume_reclaim_policy">
<caption><span class="label">Table 6-4. </span>PersistentVolume reclaim policies</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>Retain</code></p></td>
<td><p>Default. When PersistentVolumeClaim is deleted, the PersistentVolume is “released” and can be reclaimed.</p></td>
</tr>
<tr>
<td><p><code>Delete</code></p></td>
<td><p>Deletion removes PersistentVolume and its associated storage.</p></td>
</tr>
<tr>
<td><p><code>Recycle</code></p></td>
<td><p>This value is deprecated. You should use one of the values above.</p></td>
</tr>
</tbody>
</table>

<p><a data-type="indexterm" data-primary="" data-startref="sto_pv" id="idm45322717246704"/><a data-type="indexterm" data-primary="PersistentVolumeClaim type" data-secondary="creating" id="idm45322717245728"/><a data-type="indexterm" data-primary="storage" data-secondary="PersistentVolumeClaims" id="idm45322717244720"/>The following command retrieves the assigned reclaim policy of the PersistentVolume named <code>db-pv</code>:</p>
<pre data-type="programlisting">
<strong>$ kubectl get pv db-pv -o jsonpath='{.spec.persistentVolumeReclaimPolicy}'</strong>
Retain
</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Creating PersistentVolumeClaims"><div class="sect1" id="creating_pvc">
<h1>Creating PersistentVolumeClaims</h1>

<p>The next object we’ll need to create is the PersistentVolumeClaim. Its purpose is to bind the PersistentVolume to the Pod. Let’s take a look at the YAML manifest stored in the file <code>db-pvc.yaml</code>, as shown in <a data-type="xref" href="#yaml_manifest_persistent_volume_claim">Example 6-3</a>.</p>
<div id="yaml_manifest_persistent_volume_claim" data-type="example">
<h5><span class="label">Example 6-3. </span>Definition of a PersistentVolumeClaim</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolumeClaim</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-pvc</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">256Mi</code><code class="w"/></pre></div>

<p>What we’re saying here is, “Give me a PersistentVolume that can fulfill the resource request of 256Mi and provides the access mode <code>ReadWriteOnce</code>.” Static provisioning should use an empty string for the attribute <code>spec.storageClassName</code> if you do not want it to automatically assign the default storage class. The binding to an appropriate PersistentVolume happens automatically based on those criteria.</p>

<p class="pagebreak-before">After creating the PersistentVolumeClaim, the status is set as <code>Bound</code>, which means that the binding to the PersistentVolume was successful. Once the associated binding occurs, nothing else can bind to it. The binding relationship is 1-to-1. Nothing else can bind to the PersistentVolume once claimed. The following <code>get</code> command uses the short-form <code>pvc</code> instead of <code>persistentvolumeclaim</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f db-pvc.yaml</strong>
persistentvolumeclaim/db-pvc created
<strong>$ kubectl get pvc db-pvc</strong>
NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
db-pvc   Bound    db-pv    1Gi        RWO                           111s</pre>

<p><a data-type="indexterm" data-primary="describe command" id="idm45322717212608"/><a data-type="indexterm" data-primary="commands" data-secondary="describe" id="idm45322717211904"/>The PersistentVolume has not been mounted by a Pod yet. Therefore, inspecting the details of the object shows <code>&lt;none&gt;</code>. Using the <code>describe</code> command is a good way to verify if the PersistentVolumeClaim was mounted properly:</p>

<pre data-type="programlisting"><strong>$ kubectl describe pvc db-pvc</strong>
...
Used By:       &lt;none&gt;
...</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Mounting PersistentVolumeClaims in a Pod"><div class="sect1" id="mounting_persistent_volume">
<h1>Mounting PersistentVolumeClaims in a Pod</h1>

<p><a data-type="indexterm" data-primary="mounting" data-secondary="PersistentVolumeClaims in Pods" id="idm45322717206864"/><a data-type="indexterm" data-primary="PersistentVolumeClaim type" data-secondary="mounting in Pods" id="idm45322717205872"/><a data-type="indexterm" data-primary="Pods" data-secondary="mounting PersistentVolumeClaims in" id="idm45322717204912"/>All that’s left is to mount the PersistentVolumeClaim in the Pod that wants to consume it. You already learned how to mount a volume in a Pod. The big difference here shown in <a data-type="xref" href="#pod_referencing_persistent_volume_claim">Example 6-4</a> is using <code>spec.volumes[].persistentVolumeClaim</code> and providing the name of the PersistentVolumeClaim.</p>
<div id="pod_referencing_persistent_volume_claim" data-type="example">
<h5><span class="label">Example 6-4. </span>A Pod referencing a PersistentVolumeClaim</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-consuming-pvc</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-storage</code><code class="w"/>
<code class="w">      </code><code class="nt">persistentVolumeClaim</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">claimName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-pvc</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alpine</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app</code><code class="w"/>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"/bin/sh"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">60;</code><code class="nv"> </code><code class="s">done;"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/mnt/data"</code><code class="w"/>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-storage</code><code class="w"/></pre></div>

<p>Let’s assume we stored the configuration in the file <code>app-consuming-pvc.yaml</code>. After creating the Pod from the manifest, you should see the Pod transitioning into the <code>Ready</code> state. The <code>describe</code> command will provide additional information on the volume:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f app-consuming-pvc.yaml</strong>
pod/app-consuming-pvc created
<strong>$ kubectl get pods</strong>
NAME                READY   STATUS    RESTARTS   AGE
app-consuming-pvc   1/1     Running   0          3s
<strong>$ kubectl describe pod app-consuming-pvc</strong>
...
Volumes:
  app-storage:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim \
                in the same namespace)
    ClaimName:  db-pvc
    ReadOnly:   false
...</pre>

<p>The PersistentVolumeClaim now also shows the Pod that mounted it:</p>

<pre data-type="programlisting"><strong>$ kubectl describe pvc db-pvc</strong>
...
Used By:       app-consuming-pvc
...</pre>

<p>You can now go ahead and open an interactive shell to the Pod. Navigating to the mount path at <em>/mnt/data</em> gives you access to the underlying PersistentVolume:</p>

<pre data-type="programlisting"><strong>$ kubectl exec app-consuming-pvc -it -- /bin/sh</strong>
/ # cd /mnt/data
/mnt/data # ls -l
total 0
/mnt/data # touch test.db
/mnt/data # ls -l
total 0
-rw-r--r--    1 root     root             0 Sep 29 23:59 test.db</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Understanding Storage Classes"><div class="sect1" id="understanding_storage_class">
<h1>Understanding Storage Classes</h1>

<p><a data-type="indexterm" data-primary="storage" data-secondary="classes" id="idm45322717022528"/><a data-type="indexterm" data-primary="storage classes" id="idm45322717021552"/>A storage class is a Kubernetes primitive that defines a specific type or “class” of storage. Typical characteristics of a storage can be the type (e.g., fast SSD storage versus a remote cloud storage or the backup policy for a storage). The storage class is used to provision a PersistentVolume dynamically based on its criteria. In practice, this means that you do not have to create the PersistentVolume object yourself. The provisioner assigned to the storage class takes care of it. Most Kubernetes cloud providers come with a list of existing provisioners. Minikube already creates a default storage class named <code>standard</code>, which you can query for with the following command:</p>

<pre data-type="programlisting"><strong>$ kubectl get storageclass</strong>
NAME                 PROVISIONER                RECLAIMPOLICY \
  VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
standard (default)   k8s.io/minikube-hostpath   Delete        \
  Immediate           false                  108d</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Creating Storage Classes"><div class="sect1" id="creating_storage_class">
<h1>Creating Storage Classes</h1>

<p>Storage classes can be created declaratively only with the help of a YAML manifest. At a minimum, you need to declare the provisioner. All other attributes are optional and use default values if not provided upon creation. Most provisioners let you set parameters specific to the storage type. <a data-type="xref" href="#storage_class_gce">Example 6-5</a> defines a storage class on Google Compute Engine denoted by the provisioner <code>kubernetes.io/gce-pd</code>.</p>
<div id="storage_class_gce" data-type="example">
<h5><span class="label">Example 6-5. </span>Definition of a storage class</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">storage.k8s.io/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">StorageClass</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fast</code><code class="w"/>
<code class="nt">provisioner</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubernetes.io/gce-pd</code><code class="w"/>
<code class="nt">parameters</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pd-ssd</code><code class="w"/>
<code class="w">  </code><code class="nt">replication-type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">regional-pd</code><code class="w"/></pre></div>

<p>Say you saved the YAML contents in the file <code>fast-sc.yaml</code>; then the following command will create the object. The storage class can be listed using the <code>get storageclass</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f fast-sc.yaml</strong>
storageclass.storage.k8s.io/fast created
<strong>$ kubectl get storageclass</strong>
NAME                 PROVISIONER                RECLAIMPOLICY \
  VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
fast                 kubernetes.io/gce-pd       Delete        \
  Immediate           false                  4s
...</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Using Storage Classes"><div class="sect1" id="idm45322716954784">
<h1>Using Storage Classes</h1>

<p>Provisioning a PersistentVolume dynamically requires the assignment of the storage class when you create the PeristentVolumeClaim. <a data-type="xref" href="#yaml_manifest_persistent_volume_claim_storage_class">Example 6-6</a> shows the usage of the attribute <code>spec.storageClassName</code> for assigning the storage class named <code>standard</code>.</p>
<div id="yaml_manifest_persistent_volume_claim_storage_class" data-type="example">
<h5><span class="label">Example 6-6. </span>Using a storage class in a PersistentVolumeClaim</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolumeClaim</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-pvc</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w"/>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">512Mi</code><code class="w"/>
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">standard</code><code class="w"/></pre></div>

<p>The corresponding PersistentVolume object will be created only if the storage class can provision a fitting PersistentVolume using its provisioner. It’s important to understand that Kubernetes does not render an error or warning message if it isn’t the case.</p>

<p>The following command renders the created PersistentVolumeClaim and PersistentVolume. As you can see, the name of the dynamically provisioned PersistentVolume is using a hash to ensure a unique naming:</p>

<pre data-type="programlisting"><strong>$ kubectl get pv,pvc</strong>
NAME                                                       CAPACITY \
  ACCESS MODES  RECLAIM POLICY  STATUS  CLAIM           STORAGECLASS \
  REASON  AGE
persistentvolume/pvc-b820b919-f7f7-4c74-9212-ef259d421734   512Mi \
    RWO           Delete          Bound   default/db-pvc  standard \
                  2s

NAME                          STATUS  VOLUME                                  \
CAPACITY  ACCESS MODES  STORAGECLASS  AGE
persistentvolumeclaim/db-pvc  Bound   pvc-b820b919-f7f7-4c74-9212-ef259d421734 \
512Mi     RWO           standard      2s</pre>

<p>The steps for mounting the PersistentVolumeClaim from a Pod are the same as for static and dynamic provisioning. Refer to <a data-type="xref" href="#mounting_persistent_volume">“Mounting PersistentVolumeClaims in a Pod”</a> for more information.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45322716954480">
<h1>Summary</h1>

<p><a data-type="indexterm" data-primary="storage" data-secondary="about" id="idm45322716859072"/>Containers store data in a temporary filesystem, which is empty each time a new Pod is started. Application developers need to persist data beyond the lifecycles of the containers, Pods, node, and cluster. Typical examples include persistent log files or data in a database.</p>

<p>Kubernetes offers the concept of a volume to implement the use case. A Pod mounts a volume to a path in the container. Any data written to the mounted storage will be persisted beyond a container restart. Kubernetes offers a wide range of volume types to fulfill different requirements.</p>

<p>PersistentVolumes even store data beyond a Pod or cluster/node restart. Those objects are decoupled from the Pod’s lifecycle and are therefore represented by a Kubernetes primitive. The PersistentVolumeClaim abstracts the underlying implementation details of a PersistentVolume and acts as an intermediary between the Pod and PersistentVolume. A PersistentVolume can be provisioned statically by creating the object or dynamically with the help of a provisioner assigned to a storage class.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Exam Essentials"><div class="sect1" id="idm45322716856624">
<h1>Exam Essentials</h1>
<dl>
<dt><a data-type="indexterm" data-primary="storage" data-secondary="exam essentials" id="idm45322716854880"/><a data-type="indexterm" data-primary="exam essentials" data-secondary="storage" id="idm45322716853904"/>Understand the need and use cases for a volume</dt>
<dd>
<p>Many production-ready application stacks running in a cloud-native environment need to persist data. Read up on common use cases and explore recipes that describe typical scenarios. You can find some examples in the O’Reilly books <a class="orm:hideurl" href="https://oreil.ly/mQKRj"><em>Kubernetes Patterns</em></a>, <a class="orm:hideurl" href="https://oreil.ly/hcFNA"><em>Kubernetes Best Practices</em></a>, and <a class="orm:hideurl" href="https://oreil.ly/G7V3W"><em>Cloud Native DevOps with Kubernetes</em></a>.</p>
</dd>
<dt>Practice defining and consuming volumes</dt>
<dd>
<p>Volumes are a cross-cutting concept applied in different areas of the exam. Know where to find the relevant documentation for defining a volume and the multitude of ways to consume a volume from a container. Definitely revisit <a data-type="xref" href="ch03.xhtml#defining_consuming_configuration_data">“Defining and Consuming Configuration Data”</a> for a deep dive on how to mount ConfigMaps and Secrets as a volume.</p>
</dd>
<dt>Internalize the mechanics of defining and consuming a PersistentVolume</dt>
<dd>
<p>Creating a PersistentVolume involves a couple of moving parts. Understand the configuration options for PersistentVolumes and PersistentVolumeClaims and how they play together. Try to emulate situations that prevent a successful binding of a PersistentVolumeClaim. Then fix the situation by taking counteractions. Internalize the short-form commands <code>pv</code> and <code>pvc</code> to save precious time during the exam.</p>
</dd>
<dt>Know the differences between static and dynamic provisioning of a PersistentVolume</dt>
<dd>
<p>A PersistentVolume can be created statically by creating the object from a YAML manifest using the <code>create</code> command. Alternatively, you can let Kubernetes provision a PersistentVolume dynamically without your direct involvement. For this to happen, assign a storage class to the PersistentVolumeClaim. The provisioner of the storage class takes care of creating PersistentVolume object for you.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Sample Exercises"><div class="sect1" id="idm45322716800960">
<h1>Sample Exercises</h1>

<p><a data-type="indexterm" data-primary="storage" data-secondary="sample exercises" id="idm45322716799344"/><a data-type="indexterm" data-primary="sample exercises" data-secondary="storage" id="idm45322716798368"/><a data-type="indexterm" data-primary="" data-startref="sto_ch" id="idm45322716797424"/>Solutions to these exercises are available in the <a data-type="xref" href="app01.xhtml#appendix-a">Appendix</a>.</p>
<ol>
<li>
<p>Create a PersistentVolume named <code>logs-pv</code> that maps to the <code>hostPath</code> <em>/tmp/logs</em>. The access mode should be <code>ReadWriteOnce</code> and <code>ReadOnlyMany</code>. Provision a storage capacity of 2Gi. Assign the reclaim policy <code>Delete</code> and an empty string as the storage class. Ensure that the status of the PersistentVolume shows 
<span class="keep-together"><code>Available</code></span>.</p>
</li>
<li>
<p>Create a PersistentVolumeClaim named <code>logs-pvc</code>. The access it uses is 
<span class="keep-together"><code>ReadWriteOnce</code></span>. Request a capacity of 1Gi. Ensure that the status of the PersistentVolume shows <code>Bound</code>.</p>
</li>
<li>
<p>Mount the PersistentVolumeClaim in a Pod running the image <code>nginx</code> at the mount path <em>/var/log/nginx</em>.</p>
</li>
<li>
<p>Open an interactive shell to the container and create a new file named <em>my-nginx.log</em> in <em>/var/log/nginx</em>. Exit out of the Pod.</p>
</li>
<li>
<p>Delete the Pod and PersistentVolumeClaim. What happens to the PersistentVolume?</p>
</li>
<li>
<p>List the available storage classes and identify the default storage class. Note the provisioner.</p>
</li>
<li>
<p>Create a new storage class named <code>custom</code> using the provisioner of the default storage class.</p>
</li>
<li>
<p>Create a PersistentVolumeClaim named <code>custom-pvc</code>. Request a capacity of 500Mi and declare the access mode <code>ReadWriteOnce</code>. Assign the storage class name <code>custom</code>.</p>
</li>
<li>
<p>The PersistentVolume should have been provisioned dynamically. Find out the name and write it to the file named <code>pv-name.txt</code>.</p>
</li>
<li>
<p>Delete the PersistentVolumeClaim. What happens to the PersistentVolume?</p>
</li>

</ol>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45322716794800">
<h5>Interactive Exam Practice</h5>
<p>Get more hands-on training and test your CKA exam readiness by working through our interactive CKA labs. Each step of the lab must be completed correctly before you can move to the next step. If you get stuck, you can view the solution and learn how to complete the step.</p>

<p>The following labs cover material from this chapter:</p>

<ul>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492099154)">Creating a PersistentVolume via Static Binding</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492099161">Creating a PersistentVolume via Dynamic Binding</a></p>
</li>
</ul>
</div></aside>
</div></section>







</div></section></div></body></html>