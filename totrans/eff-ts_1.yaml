- en: Chapter 1\. Getting to Know TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the details, this chapter helps you understand the big picture
    of TypeScript. What is it and how should you think about it? How does it relate
    to JavaScript? Are its types nullable or are they not? What’s this about `any`?
    And ducks?
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript is a bit unusual as a language in that it neither runs in an interpreter
    (as Python and Ruby do) nor compiles down to a lower-level language (as Java and
    C do). Instead, it compiles to another high-level language, JavaScript. It is
    this JavaScript that runs, not your TypeScript. So TypeScript’s relationship with
    JavaScript is essential, but it can also be a source of confusion. Understanding
    this relationship will help you be a more effective TypeScript developer.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s type system also has some unusual aspects that you should be aware
    of. Later chapters cover the type system in much greater detail, but this one
    will alert you to some of the surprises that it has in store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 1: Understand the Relationship Between TypeScript and JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use TypeScript for long, you’ll inevitably hear the phrase “TypeScript
    is a superset of JavaScript” or “TypeScript is a typed superset of JavaScript.”
    But what does this mean, exactly? And what is the relationship between TypeScript
    and JavaScript? Since these languages are so closely linked, a strong understanding
    of how they relate to each is the foundation for using TypeScript well.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is a superset of JavaScript in a syntactic sense: so long as your
    JavaScript program doesn’t have any syntax errors then it is also a TypeScript
    program. It’s quite likely that TypeScript’s type checker will flag some issues
    with your code. But this is an independent problem. TypeScript will still parse
    your code and emit JavaScript. (This is another key part of the relationship.
    We’ll explore this more in [Item 3](#independent).)'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript files use a *.ts* (or *.tsx*) extension, rather than the *.js* (or
    *.jsx*) extension of a JavaScript file. This doesn’t mean that TypeScript is a
    completely different language! Since TypeScript is a superset of JavaScript, the
    code in your *.js* files is already TypeScript. Renaming *main.js* to *main.ts*
    doesn’t change that.
  prefs: []
  type: TYPE_NORMAL
- en: This is enormously helpful if you’re migrating an existing JavaScript codebase
    to TypeScript. It means that you don’t have to rewrite any of your code in another
    language to start using TypeScript and get the benefits it provides. This would
    not be true if you chose to rewrite your JavaScript in a language like Java. This
    gentle migration path is one of the best features of TypeScript. There will be
    much more to say about this topic in [Chapter 8](ch08.html#ch-migrate).
  prefs: []
  type: TYPE_NORMAL
- en: 'All JavaScript programs are TypeScript programs, but the converse is not true:
    there are TypeScript programs which are not JavaScript programs. This is because
    TypeScript adds additional syntax for specifying types. (There are some other
    bits of syntax it adds, largely for historical reasons. See [Item 53](ch07.html#avoid-non-ecma).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, this is a valid TypeScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But when you run this through a program like `node` that expects JavaScript,
    you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `: string` is a type annotation that is specific to TypeScript. Once you
    use one, you’ve gone beyond plain JavaScript (see [Figure 1-1](#ts-vs-js-venn)).'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1-1\. All JavaScript is TypeScript, but not all TypeScript is JavaScript
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is not to say that TypeScript doesn’t provide value for plain JavaScript
    programs. It does! For example, this JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'will throw an error when you run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no type annotations in this program, but TypeScript’s type checker
    is still able to spot the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You didn’t have to tell TypeScript that the type of `city` was `string`: it
    inferred it from the initial value. Type inference is a key part of TypeScript
    and [Chapter 3](ch03.html#ch-inference) explores how to use it well.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the goals of TypeScript’s type system is to detect code that will throw
    an exception at runtime, without having to run your code. When you hear TypeScript
    described as a “static” type system, this is what it refers to. The type checker
    cannot always spot code that will throw exceptions, but it will try.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if your code doesn’t throw an exception, it still might not do what you
    intend. TypeScript tries to catch some of these issues, too. For example, this
    JavaScript program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoops! What went wrong? This program is valid JavaScript (and hence TypeScript).
    And it ran without throwing any errors. But it clearly didn’t do what you intended.
    Even without adding type annotations, TypeScript’s type checker is able to spot
    the error (and offer a helpful suggestion):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: While TypeScript can catch errors even if you don’t provide type annotations,
    it’s able to do a much more thorough job if you do. This is because type annotations
    tell TypeScript what your *intent* is, and this lets it spot places where your
    code’s behavior does not match your intent. For example, what if you’d reversed
    the `capital`/`capitol` spelling mistake in the previous example?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The error that was so helpful before now gets it exactly wrong! The problem
    is that you’ve spelled the same property two different ways, and TypeScript doesn’t
    know which one is right. It can guess, but it may not always be correct. The solution
    is to clarify your intent by explicitly declaring the type of `states`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the errors match the problem and the suggested fix is correct. By spelling
    out our intent, you’ve also helped TypeScript spot other potential problems. For
    instance, had you only misspelled `capitol` once in the array, there wouldn’t
    have been an error before. But with the type annotation, there is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of the Venn diagram, we can add in a new group of programs: TypeScript
    programs which pass the type checker (see [Figure 1-2](#ts-js-typecheck-venn)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 0102](assets/efts_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. All JavaScript programs are TypeScript programs. But only some
    JavaScript (and TypeScript) programs pass the type checker.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the statement that “TypeScript is a superset of JavaScript” feels wrong to
    you, it may be because you’re thinking of this third set of programs in the diagram.
    In practice, this is the most relevant one to the day-to-day experience of using
    TypeScript. Generally when you use TypeScript, you try to keep your code passing
    all the type checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript’s type system *models* the runtime behavior of JavaScript. This
    may result in some surprises if you’re coming from a language with stricter runtime
    checks. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These statements both pass the type checker, even though they are questionable
    and do produce runtime errors in many other languages. But this does model the
    runtime behavior of JavaScript, where both expressions result in the string `"23"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript does draw the line somewhere, though. The type checker flags issues
    in all of these statements, even though they do not throw exceptions at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The guiding principle of TypeScript’s type system is that it should model JavaScript’s
    runtime behavior. But in all of these cases, TypeScript considers it more likely
    that the odd usage is the result of an error than the developer’s intent, so it
    goes beyond simply modeling the runtime behavior. We saw another example of this
    in the `capital`/`capitol` example, where the program didn’t throw (it logged
    `undefined`) but the type checker still flagged an error.
  prefs: []
  type: TYPE_NORMAL
- en: How does TypeScript decide when to model JavaScript’s runtime behavior and when
    to go beyond it? Ultimately this is a matter of taste. By adopting TypeScript
    you’re trusting the judgment of the team that builds it. If you enjoy adding `null`
    and `7` or `[]` and `12`, or calling functions with superfluous arguments, then
    TypeScript might not be for you!
  prefs: []
  type: TYPE_NORMAL
- en: 'If your program type checks, could it still throw an error at runtime? The
    answer is “yes.” Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this, it throws:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript assumed the array access would be within bounds, but it was not.
    The result was an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Uncaught errors also frequently come up when you use the `any` type, which we’ll
    discuss in [Item 5](#any) and in more detail in [Chapter 5](ch05.html#ch-any).
  prefs: []
  type: TYPE_NORMAL
- en: 'The root cause of these exceptions is that TypeScript’s understanding of a
    value’s type and reality have diverged. A type system which can guarantee the
    accuracy of its static types is said to be *sound*. TypeScript’s type system is
    very much not sound, nor was it ever intended to be. If soundness is important
    to you, you may want to look at other languages like Reason or Elm. While these
    do offer more guarantees of runtime safety, this comes at a cost: neither is a
    superset of JavaScript, so migration will be more complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is a superset of JavaScript. In other words, all JavaScript programs
    are already TypeScript programs. TypeScript has some syntax of its own, so TypeScript
    programs are not, in general, valid JavaScript programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript adds a type system that models JavaScript’s runtime behavior and
    tries to spot code which will throw exceptions at runtime. But you shouldn’t expect
    it to flag every exception. It is possible for code to pass the type checker but
    still throw at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While TypeScript’s type system largely models JavaScript behavior, there are
    some constructs that JavaScript allows but TypeScript chooses to bar, such as
    calling functions with the wrong number of arguments. This is largely a matter
    of taste.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 2: Know Which TypeScript Options You’re Using'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does this code pass the type checker?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Without knowing which options you’re using, it’s impossible to say! The TypeScript
    compiler has an enormous set of these, nearly 100 at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'They can be set via the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'or via a configuration file, *tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You should prefer the configuration file. It ensures that your coworkers and
    tools all know exactly how you plan to use TypeScript. You can create one by running
    `tsc --init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of TypeScript’s configuration settings control where it looks for source
    files and what sort of output it generates. But a few control core aspects of
    the language itself. These are high-level design choices that most languages do
    not leave to their users. TypeScript can feel like a very different language depending
    on how it is configured. To use it effectively, you should understand the most
    important of these settings: `noImplicitAny` and `strictNullChecks`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`noImplicitAny` controls whether variables must have known types. This code
    is valid when `noImplicitAny` is off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you mouse over the `add` symbol in your editor, it will reveal what TypeScript
    has inferred about the type of that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `any` types effectively disable the type checker for code involving these
    parameters. `any` is a useful tool, but it should be used with caution. For much
    more on `any`, see [Item 5](#any) and [Chapter 3](ch03.html#ch-inference).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are called *implicit `any`s* because you never wrote the word “any” but
    still wound up with dangerous `any` types. This becomes an error if you set the
    `noImplicitAny` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'These errors can be fixed by explicitly writing type declarations, either `:
    any` or a more specific type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript is the most helpful when it has type information, so you should be
    sure to set `noImplicitAny` whenever possible. Once you grow accustomed to all
    variables having types, TypeScript without `noImplicitAny` feels almost like a
    different language.
  prefs: []
  type: TYPE_NORMAL
- en: For new projects, you should start with `noImplicitAny` on, so that you write
    the types as you write your code. This will help TypeScript spot problems, improve
    the readability of your code, and enhance your development experience (see [Item
    6](ch02_split_000.html#editor)). Leaving `noImplicitAny` off is only appropriate
    if you’re transitioning a project from JavaScript to TypeScript (see [Chapter 8](ch08.html#ch-migrate)).
  prefs: []
  type: TYPE_NORMAL
- en: '`strictNullChecks` controls whether `null` and `undefined` are permissible
    values in every type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is valid when `strictNullChecks` is off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'but triggers an error when you turn `strictNullChecks` on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A similar error would have occurred had you used `undefined` instead of `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you mean to allow `null`, you can fix the error by making your intent explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not wish to permit `null`, you’ll need to track down where it came
    from and add either a check or an assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`strictNullChecks` is tremendously helpful for catching errors involving `null`
    and `undefined` values, but it does increase the difficulty of using the language.
    If you’re starting a new project, try setting `strictNullChecks`. But if you’re
    new to the language or migrating a JavaScript codebase, you may elect to leave
    it off. You should certainly set `noImplicitAny` before you set `strictNullChecks`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to work without `strictNullChecks`, keep an eye out for the dreaded
    “undefined is not an object” runtime error. Every one of these is a reminder that
    you should consider enabling stricter checking. Changing this setting will only
    get harder as your project grows, so try not to wait too long before enabling
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other settings that affect language semantics (e.g., `noImplicitThis`
    and `strictFunctionTypes`), but these are minor compared to `noImplicitAny` and
    `strictNullChecks`. To enable all of these checks, turn on the `strict` setting.
    TypeScript is able to catch the most errors with `strict`, so this is where you
    eventually want to wind up.
  prefs: []
  type: TYPE_NORMAL
- en: Know which options you’re using! If a coworker shares a TypeScript example and
    you’re unable to reproduce their errors, make sure your compiler options are the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TypeScript compiler includes several settings which affect core aspects
    of the language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure TypeScript using *tsconfig.json* rather than command-line options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn on `noImplicitAny` unless you are transitioning a JavaScript project to
    TypeScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `strictNullChecks` to prevent “undefined is not an object”-style runtime
    errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aim to enable `strict` to get the most thorough checking that TypeScript can
    offer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 3: Understand That Code Generation Is Independent of Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a high level, `tsc` (the TypeScript compiler) does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: It converts next-generation TypeScript/JavaScript to an older version of JavaScript
    that works in browsers (“transpiling”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It checks your code for type errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s surprising is that these two behaviors are entirely independent of one
    another. Put another way, the types in your code cannot affect the JavaScript
    that TypeScript emits. Since it’s this JavaScript that gets executed, this means
    that your types can’t affect the way your code runs.
  prefs: []
  type: TYPE_NORMAL
- en: This has some surprising implications and should inform your expectations about
    what TypeScript can and cannot do for you.
  prefs: []
  type: TYPE_NORMAL
- en: Code with Type Errors Can Produce Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because code output is independent of type checking, it follows that code with
    type errors can produce output!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be quite surprising if you’re coming from a language like C or Java
    where type checking and output go hand in hand. You can think of all TypeScript
    errors as being similar to warnings in those languages: it’s likely that they
    indicate a problem and are worth investigating, but they won’t stop the build.'
  prefs: []
  type: TYPE_NORMAL
- en: Code emission in the presence of errors is helpful in practice. If you’re building
    a web application, you may know that there are problems with a particular part
    of it. But because TypeScript will still generate code in the presence of errors,
    you can test the other parts of your application before you fix them.
  prefs: []
  type: TYPE_NORMAL
- en: You should aim for zero errors when you commit code, lest you fall into the
    trap of having to remember what is an expected or unexpected error. If you want
    to disable output on errors, you can use the `noEmitOnError` option in *tsconfig.json*,
    or the equivalent in your build tool.
  prefs: []
  type: TYPE_NORMAL
- en: You Cannot Check TypeScript Types at Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be tempted to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `instanceof` check happens at runtime, but `Rectangle` is a type and so
    it cannot affect the runtime behavior of the code. TypeScript types are “erasable”:
    part of compilation to JavaScript is simply removing all the `interface`s, `type`s,
    and type annotations from your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ascertain the type of shape you’re dealing with, you’ll need some way to
    reconstruct its type at runtime. In this case you can check for the presence of
    a `height` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This works because the property check only involves values available at runtime,
    but still allows the type checker to refine `shape`’s type to `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way would have been to introduce a “tag” to explicitly store the type
    in a way that’s available at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `Shape` type here is an example of a “tagged union.” Because they make it
    so easy to recover type information at runtime, tagged unions are ubiquitous in
    TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some constructs introduce both a type (which is not available at runtime) and
    a value (which is). The `class` keyword is one of these. Making `Square` and `Rectangle`
    classes would have been another way to fix the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This works because `class Rectangle` introduces both a type and a value, whereas
    `interface` only introduced a type.
  prefs: []
  type: TYPE_NORMAL
- en: The `Rectangle` in `type Shape = Square | Rectangle` refers to the *type*, but
    the `Rectangle` in `shape instanceof Rectangle` refers to the *value*. This distinction
    is important to understand but can be quite subtle. See [Item 8](ch02_split_000.html#type-value-space).
  prefs: []
  type: TYPE_NORMAL
- en: Type Operations Cannot Affect Runtime Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you have a value that could be a string or a number and you’d like
    to normalize it so that it’s always a number. Here’s a misguided attempt that
    the type checker accepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the generated JavaScript makes it clear what this function really
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no conversion going on whatsoever. The `as number` is a type operation,
    so it cannot affect the runtime behavior of your code. To normalize the value
    you’ll need to check its runtime type and do the conversion using JavaScript constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: (`as number` is a *type assertion*. For more on when it’s appropriate to use
    these, see [Item 9](ch02_split_000.html#prefer-declarations-to-assertions).)
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Types May Not Be the Same as Declared Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Could this function ever hit the final `console.log`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript usually flags dead code, but it does not complain about this, even
    with the `strict` option. How could you hit this branch?
  prefs: []
  type: TYPE_NORMAL
- en: The key is to remember that `boolean` is the *declared* type. Because it is
    a TypeScript type, it goes away at runtime. In JavaScript code, a user might inadvertently
    call `setLightSwitch` with a value like `"ON"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are ways to trigger this code path in pure TypeScript, too. Perhaps the
    function is called with a value which comes from a network call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You’ve declared that the result of the `/light` request is `LightApiResponse`,
    but nothing enforces this. If you misunderstood the API and `lightSwitchValue`
    is really a `string`, then a string will be passed to `setLightSwitch` at runtime.
    Or perhaps the API changed after you deployed.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript can get quite confusing when your runtime types don’t match the declared
    types, and this is a situation you should avoid whenever you can. But be aware
    that it’s possible for a value to have types other than the ones you’ve declared.
  prefs: []
  type: TYPE_NORMAL
- en: You Cannot Overload a Function Based on TypeScript Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Languages like C++ allow you to define multiple versions of a function that
    differ only in the types of their parameters. This is called “function overloading.”
    Because the runtime behavior of your code is independent of its TypeScript types,
    this construct isn’t possible in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript *does* provide a facility for overloading functions, but it operates
    entirely at the type level. You can provide multiple declarations for a function,
    but only a single implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first two declarations of `add` only provide type information. When TypeScript
    produces JavaScript output, they are removed, and only the implementation remains.
    (If you use this style of overloading, take a look at [Item 50](ch06.html#conditional-overload)
    first. There are some subtleties to be aware of.)
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript Types Have No Effect on Runtime Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because types and type operations are erased when you generate JavaScript, they
    cannot have an effect on runtime performance. TypeScript’s static types are truly
    zero cost. The next time someone offers runtime overhead as a reason to not use
    TypeScript, you’ll know exactly how well they’ve tested this claim!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two caveats to this:'
  prefs: []
  type: TYPE_NORMAL
- en: While there is no *runtime* overhead, the TypeScript compiler will introduce
    *build time* overhead. The TypeScript team takes compiler performance seriously
    and compilation is usually quite fast, especially for incremental builds. If the
    overhead becomes significant, your build tool may have a “transpile only” option
    to skip the type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code that TypeScript emits to support older runtimes *may* incur a performance
    overhead vs. native implementations. For example, if you use generator functions
    and target ES5, which predates generators, then `tsc` will emit some helper code
    to make things work. This may have some overhead vs. a native implementation of
    generators. In any case, this has to do with the emit target and language levels
    and is still independent of the *types*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code generation is independent of the type system. This means that TypeScript
    types cannot affect the runtime behavior or performance of your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible for a program with type errors to produce code (“compile”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript types are not available at runtime. To query a type at runtime, you
    need some way to reconstruct it. Tagged unions and property checking are common
    ways to do this. Some constructs, such as `class`, introduce both a TypeScript
    type and a value that is available at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 4: Get Comfortable with Structural Typing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is inherently duck typed: if you pass a function a value with all
    the right properties, it won’t care how you made the value. It will just use it.
    (“If it walks like a duck and talks like a duck…”) TypeScript models this behavior,
    and it can sometimes lead to surprising results because the type checker’s understanding
    of a type may be broader than what you had in mind. Having a good grasp of structural
    typing will help you make sense of errors and non-errors and help you write more
    robust code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you’re working on a physics library and have a 2D vector type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You write a function to calculate its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you introduce the notion of a named vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculateLength` function will work with `NamedVector`s because they have
    `x` and `y` properties, which are `number`s. TypeScript is smart enough to figure
    this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting is that you never declared the relationship between `Vector2D`
    and `NamedVector`. And you did not have to write an alternative implementation
    of `calculateLength` calculateLength for `NamedVector`s. TypeScript’s type system
    is modeling JavaScript’s runtime behavior ([Item 1](#ts-vs-js)). It allowed `calculateLength`
    to be called with a `NamedVector` because its *structure* was compatible with
    `Vector2D`. This is where the term “structural typing” comes from.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this can also lead to trouble. Say you add a 3D vector type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'and write a function to normalize them (make their length 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you call this function, you’re likely to get something longer than unit
    length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So what went wrong and why didn’t TypeScript catch the error?
  prefs: []
  type: TYPE_NORMAL
- en: The bug is that `calculateLength` operates on 2D vectors but `normalize` operates
    on 3D vectors. So the `z` component is ignored in the normalization.
  prefs: []
  type: TYPE_NORMAL
- en: What’s perhaps more surprising is that the type checker does not catch this
    issue. Why are you allowed to call `calculateLength` with a 3D vector, despite
    its type declaration saying that it takes 2D vectors?
  prefs: []
  type: TYPE_NORMAL
- en: What worked so well with named vectors has backfired here. Calling `calculateLength`
    with an `{x, y, z}` object doesn’t throw an error. So the type checker doesn’t
    complain, either, and this behavior has led to a bug. (If you want this to be
    an error, you have some options. We’ll return to this example in [Item 37](ch04.html#brands).)
  prefs: []
  type: TYPE_NORMAL
- en: As you write functions, it’s easy to imagine that they will be called with arguments
    having the properties you’ve declared *and no others*. This is known as a “sealed”
    or “precise” type, and it cannot be expressed in TypeScript’s type system. Like
    it or not, your types are “open.”
  prefs: []
  type: TYPE_NORMAL
- en: 'This can sometimes lead to surprises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Why is this an error? Since `axis` is one of the keys of `v`, which is a `Vector3D`,
    it should be either `"x"`, `"y"`, or `"z"`. And according to the declaration of
    `Vector3D`, these are all `number`s, so shouldn’t the type of `coord` be `number`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Is this error a false positive? No! TypeScript is correct to complain. The
    logic in the previous paragraph assumes that `Vector3D` is sealed and does not
    have other properties. But it could:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `v` could conceivably have any properties, the type of `axis` is `string`.
    TypeScript has no reason to believe that `v[axis]` is a number because, as you
    just saw, it might not be. Iterating over objects can be tricky to type correctly.
    We’ll return to this topic in [Item 54](ch07.html#iterate-objects), but in this
    case an implementation without loops would be better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Structural typing can also lead to surprises with `class`es, which are compared
    structurally for assignability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Why is `d` assignable to `C`? It has a `foo` property that is a `string`. In
    addition, it has a `constructor` (from `Object.prototype`) that can be called
    with one argument (though it is usually called with zero). So the structures match.
    This might lead to surprises if you have logic in `C`’s constructor and write
    a function that assumes it’s run. This is quite different from languages like
    C++ or Java, where declaring a parameter of type `C` guarantees that it will be
    either `C` or a subclass of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structural typing is beneficial when you’re writing tests. Say you have a function
    that runs a query on a database and processes the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, you could create a mock `PostgresDB`. But a better approach is
    to use structural typing and define a narrower interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can still pass `getAuthors` a `PostgresDB` in production since it has a
    `runQuery` method. Because of structural typing, the `PostgresDB` doesn’t need
    to say that it implements `DB`. TypeScript will figure out that it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you write your tests, you can pass in a simpler object instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript will verify that our test `DB` conforms to the interface. And your
    tests don’t need to know anything about your production database: no mocking libraries
    necessary! By introducing an abstraction (`DB`), we’ve freed our logic (and tests)
    from the details of a specific implementation (`PostgresDB`).'
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of structural typing is that it can cleanly sever dependencies
    between libraries. For more on this, see [Item 51](ch06.html#mirror-types-for-deps).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understand that JavaScript is duck typed and TypeScript uses structural typing
    to model this: values assignable to your interfaces might have properties beyond
    those explicitly listed in your type declarations. Types are not “sealed.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that classes also follow structural typing rules. You may not have
    an instance of the class you expect!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use structural typing to facilitate unit testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 5: Limit Use of the any Type'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript’s type system is *gradual* and *optional*: *gradual* because you
    can add types to your code bit by bit and *optional* because you can disable the
    type checker whenever you like. The key to these features is the `any` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The type checker is right to complain here, but you can silence it just by typing
    `as any`. As you start using TypeScript, it’s tempting to use `any` types and
    type assertions (`as any`) when you don’t understand an error, think the type
    checker is incorrect, or simply don’t want to take the time to write out type
    declarations. In some cases this may be OK, but be aware that `any` eliminates
    many of the advantages of using TypeScript. You should at least understand its
    dangers before you use it.
  prefs: []
  type: TYPE_NORMAL
- en: There’s No Type Safety with any Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, the type declaration says that `age` is a `number`.
    But `any` lets you assign a `string` to it. The type checker will believe that
    it’s a `number` (that’s what you said, after all), and the chaos will go uncaught:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: any Lets You Break Contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you write a function, you are specifying a contract: if the caller gives
    you a certain type of input, you’ll produce a certain type of output. But with
    an `any` type you can break these contracts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The birth date parameter should be a `Date`, not a `string`. The `any` type
    has let you break the contract of `calculateAge`. This can be particularly problematic
    because JavaScript is often willing to implicitly convert between types. A `string`
    will sometimes work where a `number` is expected, only to break in other circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: There Are No Language Services for any Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a symbol has a type, the TypeScript language services are able to provide
    intelligent autocomplete and contextual documentation (as shown in [Figure 1-3](#efts-01in01)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 01in01](assets/efts_01in01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. The TypeScript Language Service is able to provide contextual autocomplete
    for symbols with types.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: but for symbols with an `any` type, you’re on your own ([Figure 1-4](#efts-01in02)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 01in02](assets/efts_01in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. There is no autocomplete for properties on symbols with any types.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Renaming is another such service. If you have a Person type and functions to
    format a person’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: then you can select `first` in your editor, choose “Rename Symbol,” and change
    it to `firstName` (see Figures [1-5](#efts-01in03) and [1-6](#efts-01in04)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 01in03](assets/efts_01in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-5\. Renaming a symbol in vscode.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![img { width: 50% !important; }](assets/efts_01in04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-6\. Choosing the new name. The TypeScript language service ensures
    that all uses of the symbol in the project are also renamed.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This changes the `formatName` function but not the `any` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript’s motto is “JavaScript that scales.” A key part of “scales” is the
    language services, which are a core part of the TypeScript experience (see [Item
    6](ch02_split_000.html#editor)). Losing them will lead to a loss in productivity,
    not just for you but for everyone else working with your code.
  prefs: []
  type: TYPE_NORMAL
- en: any Types Mask Bugs When You Refactor Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you’re building a web application in which users can select some sort
    of item. One of your components might have an `onSelectItem` callback. Writing
    a type for an Item seems like a hassle, so you just use `any` as a stand-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s code that manages that component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Later you rework the selector in a way that makes it harder to pass the whole
    `item` object through to `onSelectItem`. But that’s no big deal since you just
    need the ID. You change the signature in `ComponentProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You update the component and everything passes the type checker. Victory!
  prefs: []
  type: TYPE_NORMAL
- en: …or is it? `handleSelectItem` takes an `any` parameter, so it’s just as happy
    with an Item as it is with an ID. It produces a runtime exception, despite passing
    the type checker. Had you used a more specific type, this would have been caught
    by the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: any Hides Your Type Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The type definition for complex objects like your application state can get
    quite long. Rather than writing out types for the dozens of properties in your
    page’s state, you may be tempted to just use an `any` type and be done with it.
  prefs: []
  type: TYPE_NORMAL
- en: This is problematic for all the reasons listed in this item. But it’s also problematic
    because it hides the design of your state. As [Chapter 4](ch04.html#ch-design)
    explains, good type design is essential for writing clean, correct, and understandable
    code. With an `any` type, your type design is implicit. This makes it hard to
    know whether the design is a good one, or even what the design is at all. If you
    ask a coworker to review a change, they’ll have to reconstruct whether and how
    you changed the application state. Better to write it out for everyone to see.
  prefs: []
  type: TYPE_NORMAL
- en: any Undermines Confidence in the Type System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time you make a mistake and the type checker catches it, it boosts your
    confidence in the type system. But when you see a type error at runtime, that
    confidence takes a hit. If you’re introducing TypeScript on a larger team, this
    might make your coworkers question whether TypeScript is worth the effort. `any`
    types are often the source of these uncaught errors.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript aims to make your life easier, but TypeScript with lots of `any`
    types can be harder to work with than untyped JavaScript because you have to fix
    type errors *and* still keep track of the real types in your head. When your types
    match reality, it frees you from the burden of having to keep type information
    in your head. TypeScript will keep track of it for you.
  prefs: []
  type: TYPE_NORMAL
- en: For the times when you must use `any`, there are better and worse ways to do
    it. For much more on how to limit the downsides of `any`, see [Chapter 5](ch05.html#ch-any).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `any` type effectively silences the type checker and TypeScript language
    services. It can mask real problems, harm developer experience, and undermine
    confidence in the type system. Avoid using it when you can!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
