- en: 'Chapter 14\. Room Databases: *Room with a View*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0569-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Most apps need data that persists.**'
  prefs: []
  type: TYPE_NORMAL
- en: But if you don’t take steps to store this data somewhere, **it will be lost
    forever** as soon as the app is closed down. You usually keep data safe in Androidville
    by ***s*toring it in a database**, so in this chapter, we’ll introduce you to
    the **Room persistence library**. You’ll learn how to **build databases**, **create
    tables,** and **define data access methods** using annotated classes and interfaces.
    You’ll find out how to **use coroutines** to run database code in the background.
    And along the way, you’ll discover how to **transform your live data as soon as
    it changes** with a little help from ***Transformations.map()***.
  prefs: []
  type: TYPE_NORMAL
- en: Most apps need to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly all of the apps that you’ve written so far have used a small amount of
    static data in order to function. The Guessing Game app we built in [Chapter 11](ch11.xhtml#view_modelscolon_model_behavior)
    to [Chapter 13](ch13.xhtml#data_bindingcolon_building_smart_layouts), for example,
    holds an array of `String`s in its view model so that the game can select one
    at random for you to guess.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, however, most apps require more than just static data; they
    need to be able to save data that can change so that it doesn’t get lost when
    the user shuts down the app. A music app might need to store playlists, for example,
    and a game might need to record the user’s progress so that they can go back to
    where they left off.
  prefs: []
  type: TYPE_NORMAL
- en: Apps can persist data using a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, the best way of persisting the user’s data is to use a database,
    so in this chapter, you’re going to learn how to use one by building a Tasks app.
    This app will let the user add tasks to a database, and display a list of all
    the tasks they have already entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the app will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0570-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Before we start building the app, let’s run through how it will be structured.
  prefs: []
  type: TYPE_NORMAL
- en: How the app will be structured
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The app will contain a single activity (named `MainActivity`), which will be
    used to display a fragment named `TasksFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TasksFragment` is the app’s main screen. Its layout file (*fragment_tasks.xml*)
    will include an edit text and a button, which let the user enter a task name and
    insert it into the database. It will also feature a text view, which will display
    all of the tasks that have been entered into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0571-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll also add a view model (named `TasksViewModel`) to the app, which `TasksFragment`
    will use for its business logic. It will include properties and methods that the
    fragment will use to interact with the app’s database. We’ll also enable data
    binding so that `TasksFragment`’s layout has direct access to the view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how these components will interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0571-02.png)'
  prefs: []
  type: TYPE_IMG
- en: To create the database, we’re going to use an Android library called ***Room***.
    So what’s Room?
  prefs: []
  type: TYPE_NORMAL
- en: Room is a database library that sits on top of SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0572-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Behind the scenes, most Android databases use SQLite. SQLite is lightweight,
    stable, fast, and optimized for a single user, and these features make it a good
    choice for Android apps. Writing the code to create, manage, and interact with
    SQLite databases, however, can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, Android Jetpack includes a persistence library named
    ***Room*** that sits on top of SQLite. With Room, you get all the benefits of
    using SQLite, but using simpler code. It provides you with convenient annotations,
    for example, that let you quickly write database code in a way that’s less repetitive
    and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: '****MVVM** is an architectural design pattern that’s used to structure apps.
    It stands for Model-View-ViewModel.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Room apps are usually structured using MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apps that use Room—including the Tasks app—are usually structured using an
    architectural design pattern called ***MVVM***, which stands for Model-View-ViewModel.
    The structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0572-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This structure is similar to the one we used for the Guessing Game app we built,
    except that there’s an extra Model layer for the database. It means that the activity
    and fragment’s UI code is cleanly separated from the business logic that’s held
    in the view model, and the view model is separated from any code that underpins
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn more about how to use the MVVM structure as we build the Tasks
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what we’re going to do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps that we’ll go through to build the Tasks app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set up the basic app.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll create the app, update its *build.gradle* files so that it uses the libraries
    we need, and create the basic activity, fragment, and layout code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0573-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Write the database code.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, we’ll add the code to create a database with a table, along with
    the data access methods needed to interact with the table’s data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0573-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Insert task records.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll create a view model and update the app’s fragment so that we can use the
    app to insert records.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0573-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Display a list of task records.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we’ll update the view model and fragment code so that the app displays
    a list of all the task records held in the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0573-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Create the Tasks project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to use a new project for the Tasks app, so create one now using
    the same steps you used in the previous chapters. Choose the Empty Activity option,
    enter a name of “Tasks” and a package name of “com.hfad.tasks”, and accept the
    default save location. Make sure the language is set to Kotlin and the minimum
    SDK is API 21 so it will run on most Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll update the project’s *build.gradle* files so that they include all
    the features and dependencies that are needed for the app.
  prefs: []
  type: TYPE_NORMAL
- en: Add a variable to the project build.gradle file…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0574-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’re going to use two Room libraries in this chapter, so we’ll add a new variable
    to the project’s *build.gradle* file to specify which version we’ll be using,
    and to keep things consistent. To do this, open the file *Tasks/build.gradle*,
    and add the following lines (in bold) to the `buildscript` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0574-02.png)'
  prefs: []
  type: TYPE_IMG
- en: …and update the app build.gradle file, too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the app’s *build.gradle* file, we need to enable data binding, and add dependencies
    for the view model, live data, and Room libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *Tasks/app/build.gradle*, and add the following lines (in bold)
    to the appropriate sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0574-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Then click on the Sync Now option to sync the changes you’ve made with the rest
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Create TasksFragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The app will include a single fragment named `TasksFragment`, which we’ll use
    to display a list of all the tasks in the database, and to insert new ones.
  prefs: []
  type: TYPE_NORMAL
- en: To create `TasksFragment`, highlight the *com.hfad.tasks* package in the *app/src/main/java*
    folder, then go to File→New→Fragment→Fragment (Blank). Name the fragment “TasksFragment”,
    name its layout “fragment_tasks”, and make sure the language is set to Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0575-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Update TasksFragment.kt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve added `TasksFragment` to the project, make sure that *TasksFragment.kt*
    matches the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0575-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Update fragment_tasks.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also need to update `TasksFragment`’s layout so that it uses data binding,
    and includes views to let us enter new tasks and display a list of existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *fragment_tasks.xml*, and update it so that it matches the code
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0576-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Display TasksFragment in MainActivity’s layout…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use `TasksFragment`, we need to add it to `MainActivity`’s layout
    in a `FragmentContainerView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the file *activity_main.xml* so that it matches the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0577-02.png)'
  prefs: []
  type: TYPE_IMG
- en: …and check the MainActivity.kt code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve updated the layout, open *MainActivity.kt* and make sure its code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0577-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve updated the fragment and activity code, let’s get to work on
    the Room database.
  prefs: []
  type: TYPE_NORMAL
- en: How Room databases are created
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0578-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Room uses a set of annotated classes and interfaces to create and configure
    a SQLite database for your app. It requires three main things:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. A database class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This defines the database, including its name and version number. It’s used
    to get an instance of the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0578-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 2\. Data classes for the tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the data in a database is stored in tables. You define each table using
    a data class, which includes annotations to specify the table’s name and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A Kotlin data class lets you create objects whose main purpose is to hold data.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0578-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 3\. Interfaces for data access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You interact with each table using an interface, which specifies the data access
    methods your app needs. If you need to insert records, for example, you can add
    an `insert()` method to the interface, and to get all records, you can add a `getAll()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0578-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Room uses these three things to generate all the code your app needs to create
    the SQLite database, its tables, and any data access methods.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few pages, we’re going to show you how to write the code for these
    three components by defining a database for the Tasks app. We’ll begin by defining
    its table.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll store tasks data in a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said before, all of a database’s data is stored in one or more tables.
    Each table is made up of rows and columns, where each row is a record, and each
    column holds a single piece of data, like a number or piece of text.
  prefs: []
  type: TYPE_NORMAL
- en: You create a separate table for each type of data you want to hold. A calendar
    app, for example, might have a table to record events, and a weather app might
    include a table for its locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to store task records in the Tasks app, so we’re going to create a
    table named “task_table”. The table will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0579-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You define tables with an annotated data class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You specify any tables you want the database to include by defining a data class
    for each table. The data class needs to include a property for each of the table’s
    columns, and you use annotations to tell Room how the table should be configured.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0579-03.png)'
  prefs: []
  type: TYPE_IMG
- en: To see how this works, we’re going to define a data class named `Task`, which
    we’ll use to create a table in the Tasks app’s database.
  prefs: []
  type: TYPE_NORMAL
- en: Create the Task data class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin by creating the data class. Highlight the *com.hfad.tasks* package
    in the *app/src/main/java* folder, then go to File→New→Kotlin Class/File. Name
    the file “Task” and choose the Class option.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve created the file, update its code so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0579-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Specify a table name with @Entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve created the `Task` data class, we need to add annotations to
    tell Room how to configure the table. We’ll begin with the table name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You name a table by adding an `**@Entity**` annotation to the data class, specifying
    the table name. We want to give the table in the Tasks app a name of “task_table”,
    and the code to do so looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0580-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Specify the primary key with @PrimaryKey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll specify the table’s primary key. This is used to uniquely identify
    a single record, and can’t contain any duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Tasks app, we’ll use the `taskId` property for `task_table`’s primary
    key, and we’ll get the table to autogenerate its values so that they’re unique.
    This is done using a `**@PrimaryKey**` annotation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0580-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Specify column names with @ColumnInfo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final thing we’ll do is specify column names for the `taskName` and `taskDone`
    properties. This is done using the `**@ColumnInfo**` annotation like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0580-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the `@ColumnInfo` annotation is *only needed if you want the column
    name to be different to the property name*. If you omit the annotation, Room will
    give the column the same name as the property.
  prefs: []
  type: TYPE_NORMAL
- en: That’s everything that we need to know to complete the `Task` data class. We’ll
    show you the full code on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for Task.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for the `Task` data class; update the code for *Task.kt*
    so that it includes the changes shown (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0581-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Room uses this file to create a table named `task_table` with an autogenerated
    primary key named `taskId`, and two extra columns named `task_name` and `task_done`.
    Here’s what the table looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0581-03.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ll find out how Room adds this table to the database when we write the database
    class a few pages ahead. First, we’ll define some database access methods so that
    the app can insert, read, update, and delete the table’s data.
  prefs: []
  type: TYPE_NORMAL
- en: Use an interface to specify data operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You specify how the app will access the table’s data by creating an annotated
    interface. This interface defines a DAO—or *Data Access Object*—which includes
    all the methods the app needs to insert, read, update, and delete the data.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, we’ll create a new interface named `TaskDao`, which the
    Tasks app will use to interact with `task_table`’s data.
  prefs: []
  type: TYPE_NORMAL
- en: Create the TaskDao interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin by creating the interface. Highlight the *com.hfad.tasks* package
    in the *app/src/main/java* folder, then go to File→New→Kotlin Class/File. Name
    the file “TaskDao” and choose the Interface option.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0582-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you’ve created the file, make sure that its code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0582-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Use @Dao to mark the interface for data access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to tell Room that the `TaskDao` interface defines data access
    methods. This is done by marking the interface with an `**@Dao**` annotation like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0582-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you’ve annotated the interface with `@Dao`, you add annotated methods that
    the app will use to interact with the data. If you want the app to insert records,
    for example, you need to add a method for this to the interface, and if you want
    it to get records, you need to add this method too.
  prefs: []
  type: TYPE_NORMAL
- en: The great news is that Room provides four annotations—`@Insert`, `@Update`,
    `@Delete`, and `@Query`—that make adding these methods a breeze. Let’s find out
    how these are used by adding some data access methods to `TaskDao`.
  prefs: []
  type: TYPE_NORMAL
- en: Use @Insert to insert a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first data access method we’ll define is an `insert()` method, which the
    app will use to insert a task into `task_table`. The method will have one parameter—a
    `Task`—for the task we want to insert. We’ll also mark the method with an `**@Insert**`
    annotation, which tells Room that the method is used to insert records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for the `insert()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0583-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When Room sees an `@Insert` annotation, it automatically generates all the
    code the app needs to insert a record into the table so that you don’t have to
    write it yourself. For the `insert()` method above, for example, it generates
    all the code needed to insert a `Task` object’s data into `task_table` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0583-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Any methods marked with `@Insert` can accept one or more entity objects for
    their arguments—objects whose type is marked with `@Entity`. `@Insert` methods
    can also accept collections of entity objects. The following method, for example,
    will insert all the tasks that are included in the `List<Task>` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0583-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Use @Update to update a record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Room can also generate all the code that’s needed to update one or more existing
    records in the table. This is done by adding a method to the DAO interface that’s
    marked with `**@Update**`. The following `update()` method, for example, generates
    all the code that’s needed to update an existing task record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0583-05.png)'
  prefs: []
  type: TYPE_IMG
- en: When called, this method updates the record with a matching `taskId` so that
    its data matches the `Task` object’s property values.
  prefs: []
  type: TYPE_NORMAL
- en: Use @Delete to delete a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s also a `**@Delete**` annotation that’s used to mark any methods that
    need to delete specific records from the table. To delete a single task record,
    for example, you could use a method defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0584-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code that Room generates for this method will delete the record with a
    matching `taskId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0584-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Use @Query for everything else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any other data access methods are marked with `@Query`. This annotation lets
    you define a SQL statement (using `SELECT`, `INSERT`, `UPDATE`, or `DELETE`) that
    will be run when the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’re not going to teach you how to use SQL in this book, but if you want to
    learn more, we suggest reading Head First SQL by Lynn Beighley.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Tasks app, for example, we can use the following code to define a method
    named `get()` to return a live data `Task` for the record with a matching `taskId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0584-05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also define a `getAll()` method, which will return a live data `List`
    of all the records held in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0584-06.png)'
  prefs: []
  type: TYPE_IMG
- en: As these methods return live data objects, the app can use them to be notified
    when the data changes. We’ll use this feature later in the chapter to keep the
    list of task records displayed in `TasksFragment` up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: You now know everything that’s needed to complete the code for `TaskDao`. We’ll
    show you the full code on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for TaskDao.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0585-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the full code for the `TaskDao` interface; update the code for *TaskDao.kt*
    so that it includes the changes shown (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0585-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve now written the code for the `Task` data class (which defines a table)
    and the `TaskDao` interface (which specifies the data access methods). Next, we’ll
    learn how to define the actual database.
  prefs: []
  type: TYPE_NORMAL
- en: Create a TaskDatabase abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You define the app’s database by creating an abstract class. The abstract class
    specifies the database name and version number, and any classes or interfaces
    that define the tables and data access methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the Tasks app, we’re going to define the database using an abstract class
    named `TaskDatabase`. Highlight the *com.hfad.tasks* package in the *app/src/main/java*
    folder, then go to File→New→Kotlin Class/File. Name the file “TaskDatabase” and
    choose the Class option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TaskDatabase` class needs to extend `RoomDatabase`, so update the code
    for *TaskDatabase.kt* so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0586-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Annotate the class with @Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to mark the class with `**@Database**`, which tells Room that
    it defines a database. Here’s the code to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0586-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the `**@Database**` annotation includes three attributes: `**entities**`,
    `**version**`, and `**exportSchema**`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`entities` specifies any classes—marked with `@Entity`—that define the tables
    you want Room to add to the database. For the Tasks app, this is the `Task` data
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: '`version` is an `Int` that specifies the database version. In this case, it’s
    1, as this is the first version of the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `exportSchema` tells Room whether to export the database schema into
    a folder so that you can record its version history. Here, we’re setting it to
    *false*.
  prefs: []
  type: TYPE_NORMAL
- en: Add properties for any DAO interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we need to specify any interfaces (marked with `@Dao`) that will be used
    for data access. This is done by adding a property for each interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Tasks app, for example, we’ve defined a single DAO interface named `TaskDao`,
    so we need to add a new `taskDao` property to the `TaskDatabase` code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0587-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Create and return an instance of the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final thing we need is a `getInstance()` method that will create the database
    and return an instance of it. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0587-03.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything that we need for the `TaskDatabase` class. We’ll show you
    the full code on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for TaskDatabase.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for the `TaskDatabase` abstract class; update the code
    for *TaskDatabase.kt* so that it includes the changes shown (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0588-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve now written all the database code needed by the Tasks app. Before we build
    the rest of the app, try the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0591-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Earlier in the chapter, we said we were going to structure the Tasks app using
    the MVVM (or Model-View-ViewModel) architecture pattern. Here’s a reminder of
    what this kind of structure looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0591-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve completed all the Model code…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve written all the database code that the app needs by creating its
    entity, DAO, and database definition files (`Task`, `TaskDao`, and `TaskDatabase`).
    Writing all the database code means that we’ve now completed the Model part of
    the app’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: …so let’s move on to the ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next thing we’ll work on is the ViewModel part. To do this, we’ll create
    a view model—named `TasksViewModel`—which will hold `TasksFragment`’s business
    logic. The view model will include methods that will use `TaskDao` to insert records
    into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We want to display a list of the tasks held in the database as well, but for
    now, we’re going to focus on inserting records.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and create `TasksViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Create TasksViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create `TasksViewModel`, highlight the *com.hfad.tasks* package in the *app/src/main/java*
    folder, then go to File→New→Kotlin Class/File. Name the file “TasksViewModel”
    and choose the Class option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to update the view model code so that `TasksFragment` can use it
    to insert new task records. To do this, the code needs three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A reference to a TaskDao object**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`TasksViewModel` will use this object to interact with the database, so we’ll
    pass it to the view model in its constructor.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A String property that holds the name of the new task**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user enters a new task name, `TasksFragment` will update this property
    with its value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**An addTask() method, which TasksFragment will call**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method will create a new `Task` object, set its name, and insert it into
    the database by calling `TaskDao`’s `insert()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The basic view model code for these three things looks like this; update the
    code for *TasksViewModel.kt* so that it matches the code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0592-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Before `TasksFragment` can call the `addTask()` method, however, there’s one
    more change we need to make.
  prefs: []
  type: TYPE_NORMAL
- en: Database operations can run in slooooow-moooo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some tasks in Androidville, such as inserting records into a database, are potentially
    quite time-consuming. For this reason, the Room persistence library insists that
    ***any data access operations must be performed on a background thread*** so they
    don’t block Android’s main thread and hold up the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically, there’s a setting you can use to override this, but it’s way better
    to run tasks such as this on a background thread so they don’t hold up the rest
    of the app.
  prefs: []
  type: TYPE_NORMAL
- en: As we’re developing Android apps using Kotlin, we’re going to use ***coroutines***
    to make sure all of `TaskDao`’s data access methods run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use coroutines to run data access code in the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may already know, a coroutine is like a lightweight thread that lets
    you run multiple pieces of code asynchronously. Using coroutines means that you
    can launch a background job—such as inserting records into a database—without
    the rest of the code having to wait around for it to complete. This gives your
    user a more fluid experience, so it’s not like trying to watch YouTube on Thanksgiving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing your data access code to use coroutines is pretty straightforward.
    You simply have to make these two changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A coroutine is a piece of suspendable code that can be run in the background.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Mark each of the DAO’s data access methods with suspend.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This turns each method into a coroutine that’s run in the background and can
    be suspended, for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0593-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Launch the DAO’s coroutines in the background.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To call `TaskDao`’s `insert()` method from `TasksViewModel`, for example, you’d
    use the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0593-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '***These changes are needed for all data access methods except for ones that
    return live data.*** Room already uses a background thread for methods that return
    live data objects, which means you don’t need to make any extra changes to your
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update the code for `TaskDao` and `TasksViewModel` so they use coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Mark TaskDao’s methods with suspend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is mark all of `TaskDao`’s data access methods
    that don’t use live data with `suspend`. This means that we need to apply this
    change to all of its methods except for `get()` and `getAll()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for *TaskDao.kt*; update the code so that it includes
    the changes shown here (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0594-02.png)![image](Images/f0594-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Marking methods with suspend turns each one into a suspendable coroutine.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That’s all the code that we need to turn `TaskDao`’s methods into coroutines
    that can run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Launch the insert() method in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We next need to update `TasksViewModel`’s `addTask()` method so that it launches
    `TaskDao`’s `insert()` method as a coroutine. The code to do this is shown below,
    so update *TasksViewModel.kt* to include the changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0595-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This change means that each time the `addTask()` method gets called, it will
    use `TaskDao`’s `insert()` method (a coroutine) to insert records in the background.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now written all the code we need for the Task app’s view model. Next,
    we’ll add a `TasksViewModel` object to `TasksFragment` so that it can access the
    view model’s properties and methods, and let the user insert task records.
  prefs: []
  type: TYPE_NORMAL
- en: TasksViewModel needs a view model factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in [Chapter 11](ch11.xhtml#view_modelscolon_model_behavior),
    you add a view model to fragment code by asking the view model provider to provide
    one. The view model provider will return the fragment’s current view model object
    if one exists, or create a new one if it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: If the view model includes a no-argument constructor, the view model provider
    can create an instance of it with no extra help. But if the constructor has arguments,
    it needs the assistance of a view model factory.
  prefs: []
  type: TYPE_NORMAL
- en: In the Tasks app, we need the view model provider to get a `TasksViewModel`
    object. Since `TasksViewModel`’s constructor requires a `TaskDao` argument, we
    must first define a `TasksViewModelFactory` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0596-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Create TasksViewModelFactory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the factory, highlight the *com.hfad.tasks* package in the *app/src/main/java*
    folder, then go to File→New→Kotlin Class/File. Name the file “TasksViewModelFactory”
    and choose the Class option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TasksViewModelFactory` code is almost identical to the view model factory
    code you wrote in [Chapter 11](ch11.xhtml#view_modelscolon_model_behavior), so
    update *TasksViewModelFactory.kt* so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0596-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve written the view model factory, let’s use it to add a `TasksViewModel`
    object to `TasksFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: TasksViewModelFactory needs a TaskDao
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add a `TasksViewModel` to `TasksFragment`, we need to create a `TasksViewModelFactory`
    object and pass it to the view model provider. The provider will then use the
    factory to create the view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a problem: `TasksViewModelFactory`’s constructor requires a `TaskDao`
    argument, so we need to get one of these before we can create the `TasksViewModelFactory`
    object. `TaskDao`, however, is an interface, not a concrete class, so how can
    we get a `TaskDao` object?'
  prefs: []
  type: TYPE_NORMAL
- en: The TaskDatabase code has a TaskDao property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we wrote the code for `TaskDatabase`, we included two key things: a `TaskDao`
    property named `taskDao`, and a `getInstance()` method to return an instance of
    the database. Here’s a reminder of what that code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0597-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To get a reference to a `TaskDao` object in the `TasksFragment` code, we can
    therefore call `TaskDatabase`’s `getInstance()` method, and access its `taskDao`
    property. The code to do so looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0597-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The above code gets a reference to the current application, builds the database
    if it doesn’t already exist, and returns an instance of it. It then assigns its
    `TaskDao` object to a local variable named `dao`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to get a reference to a `TaskDao` object, we can update
    the `TasksFragment` code to create a `TasksViewModelFactory` object, which we’ll
    use to get a `TasksViewModel`. Let’s see what the code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The updated code for TasksFragment.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The updated `TasksViewModel` code is shown below. As you can see, it now includes
    code to get a `TaskDao` object and create a `TasksViewModelFactory`. The code
    then passes the factory to the view model provider, which uses it to get an instance
    of `TasksViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the code in *TasksFragment.kt* so that it includes these changes (in
    bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0598-02.png)'
  prefs: []
  type: TYPE_IMG
- en: TasksFragment can use data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve added a `TasksViewModel` object to `TasksFragment`, we can make
    the fragment use its properties and methods to insert a record into the database.
    We’ll do this using data binding, which will give the layout direct access to
    the view model’s properties and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up data binding, we first need to add a data binding variable to the
    fragment’s layout, so we’ll add the code shown here (in bold) to the `<data>`
    section of *fragment_tasks.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0599-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ll then assign the fragment’s `viewModel` property to the data binding variable
    by adding the line shown below (in bold) to `TasksFragment`’s `onCreateView()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0599-03.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll show you the full code for both files a few pages ahead. First, let’s
    update *fragment_tasks.xml* so that it uses its `viewModel` variable to insert
    records into the database.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use data binding to insert a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To insert a new task record into the database, we need to do two things: set
    `TasksViewModel`’s `newTaskName` property to the name of the new task, and call
    its `addTask()` method. We can do both of these in `TasksFragment`’s layout with
    data binding.'
  prefs: []
  type: TYPE_NORMAL
- en: Set TasksViewModel’s newTaskName property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set the view model’s `newTaskName` property, we’ll bind it to the `task_name`
    edit text in the fragment’s layout. The code to do so looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0600-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that we’re using `**@=**` to bind the property to the edit text instead
    of `@`. The `@=` means that the edit text can update the property it’s bound to:
    in this case `newTaskName`.'
  prefs: []
  type: TYPE_NORMAL
- en: Call TasksViewModel’s addTask() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To insert the task, we’ll use data binding to make the layout’s Save Task button
    call the view model’s `addTask()` method when clicked. You’re already familiar
    with how to do this, so here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0600-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Those are all the code changes we need to make to *fragment_tasks.xml* for it
    to insert a record into the database. Let’s see what the full code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The full fragment_tasks.xml code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for `TasksFragment`’s layout; make sure that the code
    in *fragment_tasks.xml* includes the changes shown (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0601-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The full TasksFragment.kt code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0602-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before running the app, we also need to make sure that `TasksFragment` includes
    all the code that’s needed to set the layout’s data binding variable. Here’s the
    full code; update *TasksFragment.kt* (if you haven’t already done so) to include
    the changes below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0602-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s go through what happens when the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the code runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TasksFragment calls TaskDatabase.getInstance(), which builds the database
    if it doesn’t already exist.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It names the database `tasks_database`, and uses the `Task` data class to create
    a table named `task_table`. It then returns an instance of the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0603-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**TasksFragment gets the database instance’s TaskDao object, and uses it to
    create a TasksViewModelFactory.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view model provider uses the newly created `TasksViewModelFactory` object
    to create a `TasksViewModel`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0603-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**TasksFragment sets the layout’s viewModel data binding variable to the TasksViewModel
    object.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0603-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The user enters a task name in the layout’s edit text view.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout uses data binding to set the view model’s `newTaskName` property
    to this value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0604-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The user clicks on the Save Task button.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This uses data binding to call the `TaskViewModel` object’s `addTask()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0604-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The addTask() method creates a new Task object, and sets its taskName property
    to the value of newTaskName.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0604-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The addTask() method calls TaskDao’s insert() method.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This inserts a record for the `Task` object’s data into the database table.
    The table autogenerates a value for the `taskId` primary key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0604-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, `TasksFragment` is displayed in `MainActivity`. When we
    try entering two new tasks, nothing seems to happen when we click on the Save
    Task button.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0605-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the button has added the new task records to the database, but we
    can’t yet see them. To see these records in the app, we need to make further changes.
  prefs: []
  type: TYPE_NORMAL
- en: A bunch of components, in full costume, are playing a party game, “Who am I?”
    They’ll give you a clue—you try to guess who they are based on what they say.
    Assume they always tell the truth about themselves. Fill in the blanks to the
    right to identify the attendees. Also, for each attendee, write down whether the
    component is part of the Model, View, or ViewModel layer of the app’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0606-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Tonight’s attendees:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0606-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '|   | **Name** | **Model, View, or ViewModel?** |'
  prefs: []
  type: TYPE_TB
- en: '| I take care of what the app’s screens look like. | ______________ | ______________
    |'
  prefs: []
  type: TYPE_TB
- en: '| I persist data after the app’s shut down. | ______________ | ______________
    |'
  prefs: []
  type: TYPE_TB
- en: '| I have a lifecycle, but I can’t exist on my own. | ______________ | ______________
    |'
  prefs: []
  type: TYPE_TB
- en: '| I’m used for business logic. | ______________ | ______________ |'
  prefs: []
  type: TYPE_TB
- en: '| Room uses me to create a table. | ______________ | ______________ |'
  prefs: []
  type: TYPE_TB
- en: '| I have a lifecycle, and I’m a type of context. | ______________ | ______________
    |'
  prefs: []
  type: TYPE_TB
- en: '| I help you interact with the data in the database. | ______________ | ______________
    |'
  prefs: []
  type: TYPE_TB
- en: '![Images](Images/arr.png) **Answers in [“![Images](Images/common05.png) Mixed
    Messages Solution”](#mixed_messages_solution).**'
  prefs: []
  type: TYPE_NORMAL
- en: TasksFragment needs to display records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0607-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ve now learned how to build an app that inserts records into a Room database.
    The next thing we’ll do is update the app so that `TasksFragment` displays a list
    of all the records that have been inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the new version of `TasksFragment` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0607-02.png)'
  prefs: []
  type: TYPE_IMG
- en: To do this, we’ll use `TaskDao`’s `getAll()` method to get all of the task records
    from the database. We’ll then display them in `TasksFragment`’s text view by formatting
    them as a single `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Use getAll() to get all tasks from the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll begin by adding a property named `tasks` to `TasksViewModel`, which will
    hold a list of all the tasks in the database. We’ll add the tasks to the property
    by setting it to `TaskDao`’s `getAll()` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0608-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you may remember, we defined the `getAll()` method in *TaskDao.kt* using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0608-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the method returns a `LiveData<List<Task>>` object: a live
    data list of `Task` objects. This means that `TasksViewModel`’s `tasks` property
    also has a type of `LiveData<List<Task>>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0608-05.png)'
  prefs: []
  type: TYPE_IMG
- en: As the `tasks` property uses live data, it always includes the user’s latest
    changes. If a new task is added to `task_table`, for example, the `tasks` property’s
    value is automatically updated to include the new record.
  prefs: []
  type: TYPE_NORMAL
- en: Using live data in this way is good news for the Tasks app because we can use
    it to display a list of tasks in `TasksFragment` that’s always up-to-date. Before
    we can do this, however, there’s one more thing we need to learn about.
  prefs: []
  type: TYPE_NORMAL
- en: A LiveData<List<Task>> is a more complex type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0609-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we introduced you to data binding, we showed you how to bind a view to
    a `String` or number, including live data values. We were able to do this because
    `String`s and numbers are simple objects that can easily be displayed in a text
    view.
  prefs: []
  type: TYPE_NORMAL
- en: This time, however, the situation is different. The `tasks` property’s type
    is `LiveData<List<Task>>`, which is much more complex than, say, `LiveData<String>`.
    Because of this, we can’t simply bind the layout’s text view to the `tasks` property
    directly because the text view wouldn’t know how to display it.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s the solution?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0609-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Use Transformations.map() to transform live data objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use data binding to display the user’s tasks, we first need to
    transform the `LiveData<List<Task>>` into something simpler that the text view
    knows how to display. To do this, we’ll create a new property named `tasksString`,
    which will hold a `LiveData<String>` version of the `tasks` property.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create the `LiveData<String>` using the `**Transformations.map()**` method.
    This method accepts a `LiveData` argument, and a lambda that specifies how the
    live data object should be transformed. It then returns a new `LiveData` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transform the `tasks` property into a `LiveData<String>`, for example, we
    could use the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transformations.map() observes a LiveData object and transforms it into another
    type of LiveData object.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where `formatTasks()` is a method (which we need to write) that formats the
    `tasks` property’s list of tasks as a `String`. The `Transformations.map()` method
    then wraps this `String` in a `LiveData` object, so that it returns a `LiveData<String>`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Transformations.map()` method observes the `LiveData` object that’s passed
    to it, and executes the lambda each time it’s notified of changes. This means
    that in the above code, `tasksString` will ***automatically include any new task
    records the user enters***.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few pages, we’re going to add the `tasksString` property to `TasksViewModel`,
    and then use data binding to display its value in `TasksFragment`’s layout. This
    approach means that we’ll be able to display all of the user’s tasks in a text
    view that always stays up-to-date.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0609-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s update the TasksViewModel code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll begin by updating the `TasksViewModel` code so that it includes the new
    `tasks` and `tasksString` properties. We’ll also add two methods—`formatTasks()`
    and `formatTask()`—to help us transform the `LiveData<List<Task>>` into a `LiveData<String>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for `TasksViewModel`, so update *TasksViewModel.kt* so
    that it includes the changes below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0610-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll bind the tasksString property to the layout’s text view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we’ll use data binding to bind the `tasks` text view in `TasksFragment`’s
    layout to the `tasksString` property in `TasksViewModel`. Here’s the code to do
    this; update *fragment_tasks.xml* to include this change (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0611-02.png)![image](Images/f0612-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s the only change we need to make to *fragment_tasks.xml* in order for
    it to display a `String` of the user’s tasks. Before we take the app for a test
    drive, however, there’s just one more tweak we need to make.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make the layout respond to live data updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know, the `tasksString` property is a `LiveData<String>`, which
    means that it automatically includes any updates that are made to the records
    held in the database. If the user inserts a new record, for example, its data
    gets added to `tasksString`’s value.
  prefs: []
  type: TYPE_NORMAL
- en: As we’re using data binding to display the value of the `tasksString` property
    in the `tasks` text view, we need to make sure that the layout gets notified whenever
    the `tasksString` property’s value gets updated. Doing so means that the text
    view will display any new records as soon as they’re inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already learned how to make a layout respond to live data updates: by
    setting the layout’s lifecycle owner in the fragment code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We therefore need to update the code for `TasksFragment` so that it includes
    this line. We’ll show you the full code on the next page, and then go through
    what happens when the app runs.
  prefs: []
  type: TYPE_NORMAL
- en: The full TasksFragment.kt code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for TasksFragment; update *TasksFragment.kt*: to include
    the extra line (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0613-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What happens when the code runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TasksFragment creates a TasksViewModelFactory object, which the view model
    provider uses to create a TasksViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0614-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The TasksViewModel’s tasks property is set to TaskDao’s getAll() method,
    which returns a LiveData<List<Task>>.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It holds a live data list of all the task records from the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0614-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**TasksViewModel’s tasksString property uses the Transformations.map() method
    to transform the tasks property’s value into a LiveData<String>.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It returns the `tasks` property’s records formatted as a single `String`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0614-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The layout’s text view uses data binding to display tasksString’s value.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0615-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The user enters a new task record into the database.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `TasksViewModel`’s `tasks` property is automatically updated (using live
    data) to include the new record.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0615-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The tasksString property responds to the tasks property’s update.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As it uses live data, it automatically includes the new record in its `String`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0615-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The layout responds to the tasksString property’s update.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The record the user just entered is included in the text view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0615-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, `TasksFragment` is displayed as before, but this time,
    it shows us the tasks we entered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter a new task, it gets added to the list of tasks as soon as we click
    on the Save Task button.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0616-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You’ve now learned how to build an app that uses the MVVM pattern
    to interact with a Room database. The user’s records get saved to the database
    so that they persist when the app gets closed, and the app displays any new records
    as soon as they’re inserted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/common05.png) Mixed Messages'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some view model code is listed below, but the `refresh()` method’s code is missing.
    Your challenge is to match each candidate block of code (on the left) with the
    `result` property’s final value if the candidate code were added to the `refresh()`
    method, and the method was called once. Not all the values will be used, and some
    values may be used more than once.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0617-01.png)![image](Images/f0617-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/common05.png) Mixed Messages Solution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some view model code is listed below, but the `refresh()` method’s code is missing.
    Your challenge is to match each candidate block of code (on the left), with the
    `result` property’s final value if the candidate code were added to the `refresh()`
    method, and the method was called once. Not all the values will be used, and some
    values may be used more than once.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0618-01.png)![image](Images/f0618-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A bunch of components, in full costume, are playing a party game, “Who am I?”
    They’ll give you a clue—you try to guess who they are based on what they say.
    Assume they always tell the truth about themselves. Fill in the blanks to the
    right to identify the attendees. Also, for each attendee, write down whether the
    component is part of the Model, View, or ViewModel layer of the app’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0619-01.png)![image](Images/f0619-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Your Android Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/tools.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You’ve got [Chapter 14](#room_databasescolon_room_with_a_view) under your
    belt and now you’ve added the Room persistence library to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0620-01.png)'
  prefs: []
  type: TYPE_IMG
