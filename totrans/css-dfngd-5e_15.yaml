- en: Chapter 15\. Text Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because text is so important, many CSS properties affect it in one way or another.
    But didn’t we just cover that in [Chapter 14](ch14.html#fonts)? Not exactly: we
    covered only fonts—the importing and usage of typefaces. Text styles are different.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, so what is the difference between text and fonts? At the simplest level,
    *text* is the content, and *fonts* are used to display that content. Fonts provide
    the shape for the letters. Text is the styling around those shapes. Using text
    properties, you can affect the position of text in relation to the rest of the
    line, superscript it, underline it, and change the capitalization. You can affect
    the size, color, and placement of text decorations.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation and Inline Alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with a discussion of how you can affect the inline positioning of
    text within a line. Think of these basic actions as the same types of steps you
    might take to create a newsletter or write a report.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, CSS was based on concepts of *horizontal* and *vertical*. To better
    support all languages and writing directions, CSS now uses the terms *block direction*
    and *inline direction*. If your primary language is Western-derived, you’re accustomed
    to a block direction of top to bottom, and an inline direction of left to right.
  prefs: []
  type: TYPE_NORMAL
- en: The *block direction* is the direction in which block elements are placed by
    default in the current writing mode. In English, for example, the block direction
    is top to bottom, or vertical, as one paragraph (or other text element) is placed
    beneath the one before. Some languages have vertical text, like Mongolian. When
    text is vertical, the block direction is horizontal.
  prefs: []
  type: TYPE_NORMAL
- en: The *inline direction* is the direction in which inline elements are written
    within a block. To again take English as an example, the inline direction is left
    to right, or horizontal. In languages like Arabic and Hebrew, the inline direction
    is right to left instead. To reuse the example from the preceding paragraph, Mongolian’s
    inline direction is top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s reconsider English for a moment. A plain page of English text, displayed
    on a screen, has a vertical block direction (from top to bottom) and a horizontal
    inline direction (from left to right). But if the page is rotated 90 degrees counterclockwise
    by using CSS Transforms, suddenly the block direction is horizontal and the inline
    direction is vertical. (And bottom to top, at that.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can still find a lot of English-centric blog posts and other CSS-related
    documentation on the web using the terms *vertical* and *horizontal* when talking
    about writing directions. When you do, mentally translate them to *block* and
    *inline* as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most paper books we read in Western languages format paragraphs of text with
    the first line indented, and no blank line between paragraphs. If you want to
    re-create that look, CSS provides the property `text-indent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `text-indent`, the first line of any element can be indented by a given
    length, even if that length is negative. A common use for this property is to
    indent the first line of a paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This rule will cause the first line of any paragraph to be indented 3 ems, as
    shown in [Figure 15-1](#text_indenting).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1501](assets/css5_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Text indenting
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In general, you can apply `text-indent` to any element that generates a block
    box, and the indentation will occur along the inline direction. You can’t apply
    it to inline elements or replaced elements such as images. However, if you have
    an image within the first line of a block-level element, it will be shifted over
    with the rest of the text in the line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to “indent” the first line of an inline element, you can create
    the effect with left padding or a margin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set negative values for `text-indent` to create a *hanging indent*,
    where the first line hangs out to one side of the rest of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful when setting a negative value for `text-indent`; the first few words
    may be chopped off by the edge of the browser window if you aren’t careful. To
    avoid display problems, we recommend you use a margin or padding to accommodate
    the negative indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Any unit of length, including percentage values, may be used with `text-indent`.
    In the following case, the percentage refers to the width of the parent element
    of the element being indented. In other words, if you set the indent value to
    `10%`, the first line of an affected element will be indented by 10% of its parent
    element’s width, as shown in [Figure 15-2](#text_indenting_with_percentages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1502](assets/css5_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. Text indenting with percentages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that because `text-indent` is inherited, some browsers, like the Yandex
    browser, inherit the computed values, while Safari, Firefox, Edge, and Chrome
    inherit the declared value. In the following, both bits of text will be indented
    5 ems in Yandex and 10% of the current element’s width in other browsers, because
    the value of `5em` is inherited by the paragraph from its parent `<div>` in Yandex
    and older versions of WebKit, whereas most evergreen browsers inherit the declared
    value of 10%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As of late 2022, two keywords are being considered for addition to `text-indent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hanging`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inverts the indentation effect; that is, `text-indent: 3em hanging` would indent
    all the lines of text *except* the first line. This is similar to the negative-value
    indentation discussed previously, but without risking cutting off text, because
    instead of pulling the first line out of the content box, all the lines but the
    first are indented away from the edge of the content box.'
  prefs: []
  type: TYPE_NORMAL
- en: '`each-line`'
  prefs: []
  type: TYPE_NORMAL
- en: Indents the first line of the element plus any line that starts after a forced
    line break, such as that caused by a `<br>`, but not lines that follow a soft
    line break.
  prefs: []
  type: TYPE_NORMAL
- en: 'When supported, either keyword can be used in conjunction with a length or
    percentage, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Aligning Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even more basic than `text-indent` is the property `text-align`, which affects
    the way the lines of text in an element are aligned with respect to one another.
  prefs: []
  type: TYPE_NORMAL
- en: The quickest way to understand how these values work is to examine [Figure 15-3](#selected_behaviors_of_the_text-align_pro),
    which demonstrates the most widely used values. The values `left`, `right`, and
    `center` cause the text within elements to be aligned exactly as described by
    these words in horizontal languages like English or Arabic, regardless of the
    language’s inline direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1503](assets/css5_1503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-3\. Selected behaviors of the `text-align` property
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default value of `text-align` is `start`, which is the equivalent of `left`
    in LTR languages, and `right` in RTL languages. In vertical languages. `left`
    and `right` are mapped to the start or end edge, respectively. This is illustrated
    in [Figure 15-4](#left_comma_right_comma_and_center_in_ver).
  prefs: []
  type: TYPE_NORMAL
- en: Because `text-align` applies only to block-level elements such as paragraphs,
    there’s no way to center an anchor within its line without aligning the rest of
    the line (nor would you want to, since that would likely cause text overlap).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may expect, `center` causes each line of text to be centered within
    the element. If you’ve ever come across the long-ago deprecated `<CENTER>` element,
    you may be tempted to believe that `text-align: center` is the same. It is actually
    quite different. The `<CENTER>` element affected not only text, but also centered
    whole elements, such as tables. The `text-align` property does not control the
    alignment of elements, only their inline content.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1504](assets/css5_1504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-4\. Left, right, and center in vertical writing modes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Start and end alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remembering that CSS was based on concepts of *horizontal* and *vertical*,
    the initial default value was originally “a nameless value that acts as *left*
    if *direction* is *ltr*, *right* if *direction* is *rtl*.” The default value now
    has a name: `start`, which is the equivalent of `left` in LTR languages, and `right`
    in RTL languages.'
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `start` means that text is aligned to the start edge of
    its line box. In LTR languages like English, that’s the left edge; in RTL languages
    such as Arabic, it’s the right edge. In vertical languages, it will be the top
    or bottom, depending on the writing direction. The upshot is that the default
    value is much more aware of the document’s language direction while leaving the
    default behavior the same in the vast majority of existing cases.
  prefs: []
  type: TYPE_NORMAL
- en: In a like manner, `end` aligns text with the end edge of each line box—the right
    edge in LTR languages, the left edge in RTL languages, and so forth. [Figure 15-5](#start_and_end_alignment-id1)
    shows the effects of these values.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1505](assets/css5_1505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-5\. Start and end alignment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Justified text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An often-overlooked alignment value is `justify`, which raises some issues of
    its own. In justified text, both ends of a line of text (except the last line,
    which can be set with `text-align-last`) are placed at the inner edges of the
    parent element, as shown in [Figure 15-6](#justified_text-id1). Then, the spacing
    between words and letters is adjusted so that the words are distributed evenly
    throughout the line. Justified text is common in the print world (for example,
    in this book), but under CSS, a few extra considerations come into play.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1506](assets/css5_1506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-6\. Justified text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The user agent determines how justified text should be stretched or distributed
    to fill the space between the left and right edges of the parent. Some browsers,
    for example, might add extra space only between words, while others might distribute
    the extra space between letters (although the CSS specification states that “user
    agents may not further increase or decrease the inter-character space” if the
    property `letter-spacing` has been assigned a length value). Other user agents
    may reduce space on some lines, thus mashing the text together a bit more than
    usual.
  prefs: []
  type: TYPE_NORMAL
- en: The value `justify-all` sets full justification for both `text-align` and `text-align-last`
    (covered in an upcoming section).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As of mid-2022, the `justify-all` value is not supported by any browser, even
    though nearly all of them support `text-align: justify` and `text-align-last:
    justify`. This gap in support remains a mystery as of press time, but is solved
    in most browsers with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Parent matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have one more value to cover: `match-parent`. If you declare `text-align:
    match-parent`, and the inherited value of `text-align` is `start` or `end`, the
    alignment of the `match-parent` element will be calculated with respect to the
    parent element’s horizontal or vertical, rather than inline, direction.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could force any English element’s text alignment to match the
    alignment of a parent element, regardless of its writing direction, as in the
    following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Aligning the Last Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times you might want to align the text in the very last line of an element
    differently than you did the rest of the content. For example, with `text-align:
    justify`, the last line defaults to `text-align: start`. You might ensure a left-aligned
    last line in an otherwise fully justified block of text, or choose to swap from
    left to center alignment. For those situations, you can use `text-align-last`.'
  prefs: []
  type: TYPE_NORMAL
- en: As with `text-align`, the quickest way to understand how these values work is
    to examine [Figure 15-7](#differently_aligned_last_lines).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1507](assets/css5_1507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-7\. Differently aligned last lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The last lines of the elements are aligned independently of the rest of the
    elements, according to the elements’ `text-align-last` values.
  prefs: []
  type: TYPE_NORMAL
- en: A close study of [Figure 15-7](#differently_aligned_last_lines) will reveal
    that there’s more at play than just the last lines of block-level elements. In
    fact, `text-align-last` applies to any line of text that immediately precedes
    a forced line break, whether or not that line break is triggered by the end of
    an element. Thus, a line break created by a `<br>` tag will make the line of text
    immediately before that break use the value of `text-align-last`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting wrinkle arises with `text-align-last`: if the first line of
    text in an element is also the last line of text in the element, the value of
    `text-align-last` takes precedence over the value of `text-align`. Thus, the following
    styles will result in a centered paragraph, not a start-aligned paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Word Spacing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `word-spacing` property is used to modify interword spacing, accepting a
    positive or negative length. This length is *added* to the standard space between
    words. Therefore, the default value of `normal` is the same as setting a value
    of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you supply a positive length value, the space between words will increase.
    Setting a negative value for `word-spacing` brings words closer together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating these settings has the effect shown in [Figure 15-8](#changing_the_space_between_words).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1508](assets/css5_1508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-8\. Changing the space between words
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In CSS terms, a *word* is any string of nonwhitespace characters that is surrounded
    by whitespace of some kind. This means `word-spacing` is unlikely to work in any
    languages that employ pictographs, or non-Roman writing styles. This is also why
    the em dashes in the previous example’s text don’t get space around them. From
    the CSS point of view, “spaces—as” is a single word.
  prefs: []
  type: TYPE_NORMAL
- en: Use caution. The `word-spacing` property allows you to create very unreadable
    documents, as [Figure 15-9](#really_wide_word_spacing) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1509](assets/css5_1509.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-9\. Really wide word spacing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Letter Spacing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the issues you encounter with `word-spacing` also occur with `letter-spacing`.
    The only real difference between the two is that `letter-spacing` modifies the
    space between characters or letters.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `word-spacing` property, the permitted values of `letter-spacing`
    include any length, though character-relative lengths like `em` (rather than root-relative
    lengths like `rem`) are recommended to ensure that the spacing is proportional
    to the font size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default keyword is `normal`, which has the same effect as `letter-spacing:
    0`. Any length value you enter will increase or decrease the space between letters
    by that amount. [Figure 15-10](#various_kinds_of_letter_spacing) shows the results
    of the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1510](assets/css5_1510.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-10\. Various kinds of letter spacing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a page uses fonts with features like ligatures, and those features are enabled,
    altering letter or word spacing can effectively disable them. Browsers will not
    recalculate ligatures or other joins when letter spacing is altered.
  prefs: []
  type: TYPE_NORMAL
- en: Spacing and Alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to remember that space between words may be altered by the value
    of the property `text-align`. If an element is justified, the spaces between letters
    and words may be altered to fit the text along the full width of the line. This
    may in turn alter the spacing declared using `word-spacing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a length value is assigned to `letter-spacing`, that value cannot be changed
    by `text-align`; but if the value of `letter-spacing` is `normal`, inter-character
    spacing may be changed to justify the text. CSS does not specify how the spacing
    should be calculated, so user agents use their own algorithms. To prevent `text-align`
    from altering letter spacing while keeping the default letter spacing, declare
    `letter-spacing: 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that computed values are inherited, so child elements with larger or smaller
    text will have the same word or letter spacing as their parent element. You cannot
    define a scaling factor for `word-spacing` or `letter-spacing` to be inherited
    in place of the computed value (in contrast with `line-height`). As a result,
    you may run into problems such as those shown in [Figure 15-11](#inherited_letter_spacing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1511](assets/css5_1511.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-11\. Inherited letter spacing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As `inherit` inherits the ancestor’s letter-spacing computed length, the only
    way to achieve letter spacing that’s in proportion to the size of the text is
    to set it explicitly on each element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And the same goes for word spacing.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical Alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered alignment along the inline direction, let’s move on to
    the vertical alignment of inline elements along the block direction—things like
    superscripting and vertical alignment (vertical with respect to the line of text,
    if the text is laid out horizontally). Since the construction of lines is a complex
    topic that merits its own small book, we’ll just stick to a quick overview here.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the Height of Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The distance between lines can be affected by changing the height of a line.
    Note that *height* here is with respect to the line of text itself, assuming that
    the longer axis of a line is *width*, even if it’s written vertically. The property
    names we cover from here will reveal a strong bias toward Western languages and
    their writing directions; this is an artifact of the early days of CSS, when Western
    languages were the only ones that could be easily represented.
  prefs: []
  type: TYPE_NORMAL
- en: The `line-height` property refers to the distance between the baselines of lines
    of text rather than the size of the font, and it determines the amount by which
    the height of each element’s box is increased or decreased. In the most basic
    cases, specifying `line-height` is a way to increase (or decrease) the vertical
    space between lines of text, but this is a misleadingly simple way of looking
    at how `line-height` works. This property controls the *leading*, which is the
    extra space between lines of text above and beyond the font’s size. In other words,
    the difference between the value of `line-height` and the size of the font is
    the leading.
  prefs: []
  type: TYPE_NORMAL
- en: When applied to a block-level element, `line-height` defines the *minimum* distance
    between text baselines within that element. Note that it defines a minimum, not
    an absolute value. Baselines of text can wind up being pushed farther apart than
    the value of `line-height`, for example, if a line contains an inline image or
    form control that is taller than the declared line height. The `line-height` property
    does not affect layout for replaced elements like images, but it still applies
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you learned in [Chapter 6](ch06.html#basic-visual-formatting), every element
    in a line of text generates a *content area*, which is determined by the size
    of the font. This content area, in turn, generates an *inline box* that is, in
    the absence of any other factors, exactly equal to the content area. The leading
    generated by `line-height` is one of the factors that increase or decrease the
    height of each inline box.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the leading for a given element, subtract the computed value of
    `font-size` from the computed value of `line-height`. That value is the total
    amount of leading. And remember, it can be a negative number. The leading is then
    divided in half, and each half-leading is applied to the top and bottom of the
    content area. The result is the inline box for that element. In this way, each
    line of text is centered within the line height as long as the height of the line
    isn’t forced beyond its minimum height by a replaced element or other factor.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s say `font-size` (and therefore the content area) is 14
    pixels tall, and `line-height` is computed to 18 pixels. The difference (4 pixels)
    is divided in half, and each half is applied to the top and bottom of the content
    area. This effectively centers the content by creating an inline box that is 18
    pixels tall, with 2 extra pixels above and below the content area. This sounds
    like a roundabout way to describe how `line-height` works, but there are excellent
    reasons for the description.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the inline boxes have been generated for a given line of content,
    they are then considered in the construction of the line box. A line box is exactly
    as tall as needed to enclose the top of the tallest inline box and the bottom
    of the lowest inline box. [Figure 15-12](#line_box_diagram) shows a diagram of
    this process.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1512](assets/css5_1512.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-12\. Line-box diagram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Assigning values to line-height
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now consider the possible values of `line-height`. If you use the default
    value of `normal`, the user agent must calculate the space between lines. Values
    can vary by user agent, but the `normal` default is generally around 1.2 times
    the size of the font, which makes line boxes taller than the value of `font-size`
    for a given element.
  prefs: []
  type: TYPE_NORMAL
- en: Many values are simple length measures (e.g., `18px` or `2em` ), but <*`number`*>
    values with no length unit are preferable in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be aware that even if you use a valid length measurement, such as `4cm`, the
    browser (or the operating system) may be using an incorrect metric for real-world
    measurements, so the line height may not show up as exactly 4 centimeters on your
    monitor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `em`, `ex`, and percentage values are calculated with respect to the `font-size`
    of the element. The results of the following CSS and HTML are shown in [Figure 15-13](#simple_calculations_with_the_line-height):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1513](assets/css5_1513.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-13\. Simple calculations with the `line-height` property
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding line-height and inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the `line-height` is inherited by one block-level element from another,
    things get a bit trickier. The `line-height` values inherit from the parent element
    as computed from the parent, not the child. The results of the following markup
    are shown in [Figure 15-14](#small_line-height_comma_large_font-size). It probably
    wasn’t what the author had in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1514](assets/css5_1514.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-14\. Small line-height, large font-size, slight problem
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Why are the lines so close together? Because the computed `line-height` value
    of `10px` was inherited by the paragraph from its parent `<div>`. One solution
    to the small `line-height` problem depicted in [Figure 15-14](#small_line-height_comma_large_font-size)
    is to set an explicit `line-height` for every element, but that’s not very practical.
    A better alternative is to specify a number, which actually sets a scaling factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When you specify a number with no length unit, you cause the scaling factor
    to be an inherited value instead of a computed value. The number will be applied
    to the element and all of its child elements so that each element has a `line-height`
    calculated with respect to its own `font-size` (see [Figure 15-15](#using_line-height_factors_to_overcome_in)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1515](assets/css5_1515.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-15\. Using `line-height` factors to overcome inheritance problems
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you have a basic grasp of how lines are constructed, let’s talk about
    vertically aligning elements relative to the line box—that is, displacing them
    along the block direction.
  prefs: []
  type: TYPE_NORMAL
- en: Vertically Aligning Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever used the elements `<sup>` and `<sub>` (the superscript and subscript
    elements), or used the deprecated `align` attribute with an image, you’ve done
    some rudimentary vertical alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because of the property name `vertical-align`, this section will use the terms
    *vertical* and *horizontal* to refer to the block and inline directions of the
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vertical-align` property accepts any one of eight keywords, a percentage
    value, or a length value. The keywords are a mix of the familiar and unfamiliar:
    `baseline` (the default value), `sub`, `super`, `bottom`, `text-bottom`, `middle`,
    `top`, and `text-top`. We’ll examine how each keyword works in relation to inline
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember: `vertical-align` does *not* affect the alignment of content within
    a block-level element, just the alignment of inline content within a line of text
    or a table cell. This may change in the future, but as of mid-2022, proposals
    to widen its scope have yet to move forward.'
  prefs: []
  type: TYPE_NORMAL
- en: Baseline alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `vertical-align: baseline` forces the baseline of an element to align
    with the baseline of its parent. Browsers, for the most part, do this anyway,
    since you’d probably expect the bottoms of all text elements in a line to be aligned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a vertically aligned element doesn’t have a baseline—that is, if it’s an
    image, a form input, or another replaced element—then the bottom of the element
    is aligned with the baseline of its parent, as [Figure 15-16](#baseline_alignment_of_an_image)
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1516](assets/css5_1516.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-16\. Baseline alignment of an image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This alignment rule is important because it causes some web browsers to always
    put a replaced element’s bottom edge on the baseline, even if the line includes
    no other text. For example, let’s say you have an image in a table cell all by
    itself. The image may actually be on a baseline, but in some browsers, the space
    below the baseline causes a gap to appear beneath the image. Other browsers will
    “shrink-wrap” the image with the table cell, and no gap will appear. The gap behavior
    is correct, despite its lack of appeal to most authors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See the deeply aged and yet somehow still relevant article [“Images, Tables,
    and Mysterious Gaps”](https://meyerweb.com/eric/articles/devedge/img-table-gaps)
    (2002) for a more detailed explanation of gap behavior and ways to work around
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Superscripting and subscripting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The declaration `vertical-align: sub` causes an element to be subscripted,
    meaning that its baseline (or bottom, if it’s a replaced element) is lowered with
    respect to its parent’s baseline. The specification doesn’t define the distance
    the element is lowered, so it may vary depending on the user agent.'
  prefs: []
  type: TYPE_NORMAL
- en: The `super` value is the opposite of `sub`; it raises the element’s baseline
    (or bottom of a replaced element) with respect to the parent’s baseline. Again,
    the distance the text is raised depends on the user agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the values `sub` and `super` do *not* change the element’s font size,
    so subscripted or superscripted text will not become smaller (or larger). Instead,
    any text in the sub- or superscripted element will, by default, be the same size
    as text in the parent element, as illustrated by [Figure 15-17](#superscript_and_subscript_alignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1517](assets/css5_1517.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-17\. Superscript and subscript alignment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you wish to make super- or subscripted text smaller than the text of its
    parent element, you can do so by using the `font-size` property.
  prefs: []
  type: TYPE_NORMAL
- en: Top and bottom alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `vertical-align: top` option aligns the top of the element’s inline box
    with the top of the line box. Similarly, `vertical-align: bottom` aligns the bottom
    of the element’s inline box with the bottom of the line box. Thus, the following
    markup results in [Figure 15-18](#top_and_bottom_alignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1518](assets/css5_1518.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-18\. Top and bottom alignment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second line of the first paragraph contains two inline elements whose top
    edges are aligned with each other. They’re also well above the baseline of the
    text. The second paragraph shows the inverted case: two images whose bottoms are
    aligned and are well below the baseline of their line. This is because in both
    cases, the sizes of the elements in the line have increased the line’s height
    beyond what the font’s size would normally create.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want instead to align elements with the top or bottom edge of just the
    text in the line, `text-top` and `text-bottom` are the values you seek. For the
    purposes of these values, replaced elements, or any other kinds of nontext elements,
    are ignored. Instead, a *default* text box is considered. This default box is
    derived from the `font-size` of the parent element. The bottom of the aligned
    element’s inline box is then aligned with the bottom of the default text box.
    Thus, given the following markup, you get a result like the one shown in [Figure 15-19](#text-top_and_bottom_alignment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1519](assets/css5_1519.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-19\. Text-top and -bottom alignment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Middle alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value `middle` is usually (but not always) applied to images. It does not
    have the exact effect you might assume, given its name. The `middle` value aligns
    the middle of an inline element’s box with a point that is `0.5ex` above the baseline
    of the parent element, where `1ex` is defined relative to the `font-size` for
    the parent element. [Figure 15-20](#precise_detail_of_middle_alignment) shows
    this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1520](assets/css5_1520.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-20\. Precise detail of middle alignment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since most user agents treat `1ex` as one-half em, `middle` usually aligns the
    vertical midpoint of an element with a point one-quarter em above the parent’s
    baseline, though this is not a defined distance and so can vary from one user
    agent to another.
  prefs: []
  type: TYPE_NORMAL
- en: Percentages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Percentages don’t let you simulate `align="middle"` for images. Instead, setting
    a percentage value for `vertical-align` raises or lowers the baseline of the element
    (or the bottom edge of a replaced element) by the amount declared, with respect
    to the parent’s baseline. (The percentage you specify is calculated as a percentage
    of `line-height` for the element, *not* its parent.) Positive percentage values
    raise the element, and negative values lower it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on how the text is raised or lowered, it can appear to be placed
    in adjacent lines, as shown in [Figure 15-21](#percentages_and_fun_effects), so
    take care when using percentage values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1521](assets/css5_1521.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-21\. Percentages and fun effects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Length alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let’s consider vertical alignment with a specific length. The `vertical-align`
    option is very basic: it shifts an element up or down by the declared distance.
    Thus, `vertical-align: 5px;` will shift an element upward 5 pixels from its unaligned
    placement. Negative length values shift the element downward.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to realize that vertically aligned text does not become part
    of another line, nor does it overlap text in other lines. Consider [Figure 15-22](#inline_alignments_can_cause_lines_to),
    in which some vertically aligned text appears in the middle of a paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1522](assets/css5_1522.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-22\. Vertical alignments can cause lines to get taller
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, any vertically aligned element can affect the height of the
    line. Recall the description of a line box, which is exactly as tall as necessary
    to enclose the top of the tallest inline box and the bottom of the lowest inline
    box. This includes inline boxes that have been shifted up or down by vertical
    alignment.
  prefs: []
  type: TYPE_NORMAL
- en: Text Transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the alignment properties covered, let’s look at ways to manipulate the
    capitalization of text by using the property `text-transform`.
  prefs: []
  type: TYPE_NORMAL
- en: The default value `none` leaves the text alone and uses whatever capitalization
    exists in the source document. As their names imply, `uppercase` and `lowercase`
    convert text into all upper- or lowercase characters. The `full-width` value forces
    the writing of a character inside a square, as if on a typographical grid.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Accessibility note: some screen readers will read all-uppercase text one letter
    at a time, as if spelling out an acronym, even if the source text is lowercase
    or mixed-case and the uppercasing is only enforced via CSS. For this reason, uppercasing
    text via CSS should be approached with caution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `capitalize` value capitalizes only the first letter of each word
    (where a *word* is defined as a string of adjacent characters surrounded by whitespace).
    [Figure 15-23](#various_kinds_of_text_transformation) illustrates each of these
    settings in a variety of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1523](assets/css5_1523.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-23\. Various kinds of text transformation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As noted in [Chapter 6](ch06.html#basic-visual-formatting), *CJK* stands for
    *Chinese/Japanese/Korean*. CJK characters take up the majority of the entire Unicode
    code space, including approximately 70,000 Han characters. You may sometimes come
    across the abbreviation *CJKV*, which adds *Vietnamese* to the mix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different user agents may have different ways of deciding where words begin
    and, as a result, which letters are capitalized. For example, the text “heading-one”
    in the `<h1>` element, shown in [Figure 15-23](#various_kinds_of_text_transformation),
    could be rendered in one of two ways: “Heading-one” or “Heading-One.” CSS does
    not say which is correct, so either is possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have also noticed that the last letter in the `<h1>` element in [Figure 15-23](#various_kinds_of_text_transformation)
    is still uppercase. This is correct: when applying a `text-transform` of `capitalize`,
    CSS requires user agents to make sure only the first letter of each word is capitalized.
    They can ignore the rest of the word.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a property, `text-transform` may seem minor, but it’s very useful if you
    suddenly decide to capitalize all your `<h1>` elements. Instead of individually
    changing the content of all your `<h1>` elements, you can just use `text-transform`
    to make the change for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantages of using `text-transform` are twofold. First, you need to write
    only a single rule to make this change, rather than changing the `<h1>` itself.
    Second, if you decide later to switch from all capitals back to initial capitals,
    the change is even easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `capitalize` is a simple letter substitution at the beginning
    of each “word.” CSS doesn’t check for grammar, so common headline-capitalization
    conventions, such as leaving articles (*a*, *an*, *the*) all lowercase, won’t
    be enforced.
  prefs: []
  type: TYPE_NORMAL
- en: Different languages have different rules for which letters should be capitalized.
    The `text-transform` property takes into account language-specific case mappings.
  prefs: []
  type: TYPE_NORMAL
- en: The `full-width` option forces the writing of a character inside a square. Most
    characters you can type on a keyboard come in both normal width and full width,
    with different Unicode code points. The full-width version is used when `full-width`
    is set and supported to mix them smoothly with Asian ideographic characters, allowing
    ideograms and Latin scripts to be aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Generally used with `<ruby>` annotation text, `full-size-kana` converts all
    small Kana characters to the equivalent full-size Kana, to compensate for legibility
    issues at the small font sizes typically used in Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: Text Decoration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next we come to the topic of text decorations, and how we can affect them with
    various properties. The simplest text decoration, and the one that can be controlled
    the most, is an underline. CSS also supports overlines, line-throughs, and even
    the wavy underlines you see in word processing programs to flag errors of spelling
    or grammar.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the various individual properties, and then tie it all up with
    a shorthand property, `text-decoration`, that covers them all.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Line Placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the property `text-decoration-line`, you can set the location of one or
    more line decorations on a run of text. The most familiar decoration may be underlining,
    thanks to all the hyperlinks out there, but CSS has three possible visible decoration
    line values (plus an unsupported fourth that wouldn’t draw a line at all even
    if it *was* supported).
  prefs: []
  type: TYPE_NORMAL
- en: 'The values are relatively self-documenting: `underline` places a line under
    the text, where *under* means “below the text in the block direction.” The `overline`
    value is the mirror image, putting the line above the text in the block direction.
    The `line-through` value draws a line through the middle of the text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what these decorations look like in practice. The following code
    is illustrated in [Figure 15-24](#various_kinds_of_text_decoration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1524](assets/css5_1524.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-24\. Various kinds of text decoration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The value `none` turns off any decoration that might otherwise have been applied
    to an element. For example, links are usually underlined by default. If you want
    to suppress the underlining of hyperlinks, you can use the following CSS rule
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you explicitly turn off link underlining with this sort of rule, the only
    visual difference between the anchors and normal text will be their color (at
    least by default, though there’s no ironclad guarantee that there will be a difference
    in their colors). Relying on color alone as the difference between regular text
    and links within that text is not enough to differentiate links from the rest
    of the text, negatively impacting user experience and making your content inaccessible
    to many users.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bear in mind that many users will be annoyed when they realize you’ve turned
    off link underlining, especially within blocks of text. If your links aren’t underlined,
    users will have a hard time finding hyperlinks in your documents, and finding
    them can be next to impossible for users with one form or another of color blindness.
  prefs: []
  type: TYPE_NORMAL
- en: That’s really all there is to `text-decoration-line`. The more veteran among
    you may recognize this is what `text-decoration` itself used to do, but times
    have moved on and there’s much, much more we can do with decorations besides just
    place them, so these values were shifted to `text-decoration-line`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the color of a text decoration will match the color of the text.
    If you need to change that, `text-decoration-color` is here to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any valid color value for `text-decoration-color`, including the
    keyword `currentcolor` (which is the default). Suppose you want to make it clear
    that stricken text really is stricken. That would go something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Thus, not only will the elements shown get a line-through decoration, but the
    line will also be colored red. The text itself will not be red unless you change
    that as well by using the `color` property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember to keep the color contrast between decorations and the base text sufficiently
    high to remain accessible. It’s also generally a bad idea to use color alone to
    convey meaning, as in “check the links with red underlines for more information!”
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Thickness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the property `text-decoration-thickness`, you can change the stroke thickness
    of a text decoration to something beefier, or possibly less beefy, than usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplying a length value sets the thickness of the decoration to that length;
    thus, `text-decoration-thickness: 3px` sets the decoration to be 3 pixels thick,
    no matter how big or small the text itself might be. A better approach is generally
    to use an em-based value or jump straight to using a percentage value, since percentages
    are calculated with respect to the value of `1em` for the element. Thus, `text-decoration-thickness:
    10%` would yield a decoration thickness of 1.6 pixels in a font whose computed
    font size is 16 pixels, but 4 pixels for a 40-pixel font size. The following code
    shows a few examples, which are illustrated in [Figure 15-25](#various_decoration_thicknesses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1525](assets/css5_1525.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-25\. Various decoration thicknesses
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The keyword `from-font` is interesting because it allows the browser to consult
    the font file to see whether it defines a preferred decoration thickness; if it
    does, the browser uses that thickness. If the font file doesn’t recommend a thickness,
    the browser falls back to the `auto` behavior and picks whatever thickness it
    thinks appropriate, using inscrutable reasoning known only to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, we’ve shown a lot of straight, single lines. If you’re yearning for
    something beyond that hidebound approach, `text-decoration-style` provides alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact result will depend on the value you pick and the browser you use
    to view the results, but the renderings of these decoration styles should be at
    least similar to those shown in [Figure 15-26](#various_decoration_styles), which
    is the output of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1526](assets/css5_1526.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-26\. Various decoration styles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We increased the decoration thickness for [Figure 15-26](#various_decoration_styles)
    in order to improve legiblility; the default sizing can make some of the more
    complex decorations, like `dotted`, difficult to see.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Text Decoration Shorthand Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you just want to set a text decoration’s position, color, thickness, and
    style in one handy declaration, `text-decoration` is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `text-decoration` shorthand property, you can bring everything into
    one place, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful, though: if you have two different decorations matched to the same
    element, the value of the rule that wins out will completely replace the value
    of the loser. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Given these rules, any `<h2>` element with a class of `stricken` will have only
    a wavy line-through decoration. The doubled underline and overline decorations
    are lost, since shorthand values replace one another instead of accumulating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that because of the way the decoration properties work, you can set
    the color and style only once per element, even if you have multiple decorations.
    For example, the following is valid, setting both the under- and overlines to
    be green and dotted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you instead want the overline to be a different color than the underline,
    or set each to have its own style, you’d need to apply each to a separate element,
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Offsetting Underlines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Along with all the `text-decoration` properties, a related property allows
    you to change the distance between an underline (and *only* an underline) and
    the text that the underline decorates: `text-underline-offset`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wish that, say, underlines on hyperlinks were a little farther away
    from the text’s baseline, so that they’re a little more obvious to the user. Setting
    a length value like `3px` will put the underline 3 pixels below the text’s baseline.
    See [Figure 15-27](#various_underline_offsets) for the results of the following
    CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1527](assets/css5_1527.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-27\. Various underline offsets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As illustrated in [Figure 15-27](#various_underline_offsets), the value defines
    an offset from the text’s baseline, either positive (downward along the block
    axis) or negative (upward along the block axis).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `text-decoration-thickness`, percentage values for `text-underline-offset`
    are calculated with respect to the value of `1em` for the element. Thus, `text-underline-offset:
    10%` would cause an offset of 1.6 pixels in a font whose computed font size is
    16 pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, only Firefox supports percentage values for `text-underline-offset`,
    which is odd given that percentage values are a percent of 1 em in the element’s
    font. The workaround is to use em length values, such as 0.1em for 10%.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping Ink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An unaddressed aspect of the past few sections has been: how exactly do browsers
    draw decorations over text, and more precisely, decide when to “skip over” parts
    of the text? This is known as *skipping ink*, and the approach a browser takes
    can be altered with the property `text-decoration-skip-ink`.'
  prefs: []
  type: TYPE_NORMAL
- en: When ink skipping is turned on, the decoration is interrupted wherever it would
    cross over the shapes of the text. Usually, this means a small gap between the
    decoration and the text glyphs. See [Figure 15-28](#ink-skipping_approaches) for
    a close-up illustration of the differences in ink-skipping approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1528](assets/css5_1528.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-28\. Ink-skipping approaches
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The three values are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auto` (the default)'
  prefs: []
  type: TYPE_NORMAL
- en: The browser *may* interrupt under- and overlines where the line would cross
    the text glyphs, with a little space between the line and the glyphs. Furthermore,
    browsers *should* consider the glyphs used for the text, since some glyphs may
    call for ink skipping while others may not.
  prefs: []
  type: TYPE_NORMAL
- en: '`all`'
  prefs: []
  type: TYPE_NORMAL
- en: Browsers *must* interrupt under- and overlines where the line would cross the
    text glyphs, with a little space between the line and the glyphs. However, as
    of mid-2022, only Firefox supports this value.
  prefs: []
  type: TYPE_NORMAL
- en: '`none`'
  prefs: []
  type: TYPE_NORMAL
- en: The browser *must not* interrupt under- and overlines where the line would cross
    the text glyphs, but instead draw a continuous line even though it may be drawn
    over parts of the text glyphs.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 15-28](#ink-skipping_approaches), `auto` can sometimes mean
    differences depending on the language, font, or based on other factors. You’re
    really just telling the browser to do whatever it thinks is best.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While this property’s name begins with the label `text-decoration-`, it is *not*
    a property covered by the `text-decoration` shorthand property. That’s why it’s
    being discussed here, after the shorthand, and not before.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Weird Decorations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s look into the unusual side of `text-decoration`. The first oddity
    is that `text-decoration` is *not* inherited. No inheritance implies that any
    decoration lines drawn with the text—whether under, over, or through it—will always
    be the same color. This is true even if the descendant elements are a different
    color, as depicted in [Figure 15-29](#color_consistency_in_underlines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1529](assets/css5_1529.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-29\. Color consistency in underlines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Why is this so? Because the value of `text-decoration` is not inherited, the
    `<strong>` element assumes a default value of `none`. Therefore, the `<strong>`
    element has *no* underline. Now, there is very clearly a line under the `<strong>`
    element, so it seems silly to say that it has none. Nevertheless, it doesn’t.
    What you see under the `<strong>` element is the paragraph’s underline, which
    is effectively “spanning” the `<strong>` element. You can see it more clearly
    if you alter the styles for the boldfaced element, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The result is identical to the one shown in [Figure 15-29](#color_consistency_in_underlines),
    since all you’ve done is to explicitly declare what was already the case. In other
    words, there is no way to “turn off” the decoration generated by a parent element.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way to change the color of a decoration without violating the specification.
    As you’ll recall, setting a text decoration on an element means that the entire
    element has the same color decoration, even if child elements have different colors.
    To match the decoration color with an element, you must explicitly declare its
    decoration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In [Figure 15-30](#overcoming_the_default_behavior_of_under), the `<strong>`
    element is set to be gray and to have an underline. The gray underline visually
    “overwrites” the parent’s black underline, so the decoration’s color matches the
    color of the `<strong>` element. The black underline is still there; the gray
    underline is just hiding it. If you move the gray underline with `text-underline-offset`
    or make the parent’s `text-decoration-thickness` wider than its child, both underlines
    will be visible.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1530](assets/css5_1530.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-30\. Overcoming the default behavior of underlines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When `text-decoration` is combined with `vertical-align`, even stranger things
    can happen. [Figure 15-31](#correct_comma_although_strange_comma_dec) shows one
    of these oddities. Since the `<sup>` element has no decoration of its own, but
    it is elevated within an overlined element, the overline should cut through the
    middle of the `<sup>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1531](assets/css5_1531.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-31\. Correct, although strange, decorative behavior
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But not all browsers do this. As of mid-2022, Chrome pushes the overline up
    so it is drawn across the top of the superscript, whereas others do not.
  prefs: []
  type: TYPE_NORMAL
- en: Text Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recent addition to CSS is `text-rendering`, which is actually an SVG property
    that’s treated as CSS by supporting user agents. It lets you indicate what the
    user agent should prioritize when displaying text.
  prefs: []
  type: TYPE_NORMAL
- en: The values `optimizeSpeed` and `optimizeLegibility` indicate that drawing speed
    should be favored over the use of legibility features like kerning and ligatures
    (for `optimizeSpeed`) or that such legibility features should be used even if
    that slows text rendering (for `optimizeLegibility`).
  prefs: []
  type: TYPE_NORMAL
- en: The precise legibility features that are used with `optimizeLegibility` are
    not explicitly defined, and the text rendering often depends on the operating
    system on which the user agent is running, so the exact results may vary. [Figure 15-32](#optimized_legibility)
    shows text optimized for speed and then optimized for legibility.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1532](assets/css5_1532.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-32\. Different optimizations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see in [Figure 15-32](#optimized_legibility), the differences between
    the two optimizations are objectively rather small, but they can have a noticeable
    impact on readability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some user agents will always optimize for legibility, even when optimizing for
    speed. This is likely an effect of rendering speeds having gotten so fast in the
    past few years.
  prefs: []
  type: TYPE_NORMAL
- en: The value `geometricPrecision`, on the other hand, directs the user agent to
    draw the text as precisely as possible, such that it could be scaled up or down
    with no loss of fidelity. You might think that this is always the case, but not
    so. Some fonts change kerning or ligature effects at different text sizes, for
    example, providing more kerning space at smaller sizes and tightening up the kerning
    space as the size is increased. With `geometricPrecision`, those hints are ignored
    as the text size changes. If it helps, think of it as the user agent drawing the
    text as though all the text is a series of SVG paths, not font glyphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even by the usual standard of web standards, the value `auto` is pretty vaguely
    defined in SVG:'
  prefs: []
  type: TYPE_NORMAL
- en: The user agent shall make appropriate trade-offs to balance speed, legibility
    and geometric precision, but with legibility given more importance than speed
    and geometric precision.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That’s it: user agents get to do what they think is appropriate, leaning toward
    legibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Text Shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you just really need your text to cast a shadow, like when text overlaps
    a multicolored background. That’s where `text-shadow` comes in. The syntax might
    look a little wacky at first, but it should become clear enough with just a little
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: The default is to not have a drop shadow for text. Otherwise, you can define
    one or more shadows. Each shadow is defined by an optional color and three length
    values, the last of which is also optional.
  prefs: []
  type: TYPE_NORMAL
- en: The color sets the shadow’s color so it’s possible to define green, purple,
    or even white shadows. If the color is omitted, the shadow defaults to the color
    keyword `currentcolor`, making it the same color as the text itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using `currentcolor` as a default color may seem counterintuitive, as you might
    think shadows are purely decorative, but shadows can be used to improve legibility.
    A small shadow can make very thin text more legible. Defaulting to `currentcolor`
    allows adding thickness via a shadow that will always match the color of the text.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to improving accessibility by making thin text thicker, shadows
    can be used to improve color contrast with a multicolored background. For example,
    if you have white text on a mostly dark black-and-white photo, adding a black
    shadow to the white text makes the edges of the white text visible even if the
    text is laid over white portions of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two length values determine the offset distance of the shadow from
    the text; the first is the horizontal offset, and the second is the vertical offset.
    To define a solid, unblurred green shadow offset 5 pixels to the right and half
    an em down from the text, as shown in [Figure 15-33](#simple_shadows), you could
    write either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative lengths cause the shadow to be offset to the left and upward from
    the original text. The following, also shown in [Figure 15-33](#simple_shadows),
    places a light-blue shadow 5 pixels to the left and half an em above the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1533](assets/css5_1533.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-33\. Simple shadows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While the offset may make the text take more visual space, shadows have no effect
    on line height and therefore no impact on the box model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional third length value defines a blur radius for the shadow. The *blur
    radius* is defined as the distance from the shadow’s outline to the edge of the
    blurring effect. A radius of 2 pixels would result in blurring that fills the
    space between the shadow’s outline and the edge of the blurring. The exact blurring
    method is not defined, so different user agents might employ different effects.
    As an example, the following styles are rendered as shown in [Figure 15-34](#dropping_shadows_all_over):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1534](assets/css5_1534.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-34\. Dropping shadows all over
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Large numbers of text shadows, or text shadows with very large blur values,
    can create performance slowdowns, particularly when animated in low-power and
    CPU-constrained situations such as mobile devices. Test thoroughly before deploying
    public designs that use text shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Text Emphasis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to call out text is by adding emphasis marks to each character.
    This is more common in ideographic languages like Chinese or Mongolian, but these
    marks can be added to any language’s text with CSS. CSS has three text-emphasis
    properties similar to those for text decorations, and then a shorthand that conflates
    two of them.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Emphasis Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important of the three properties sets the type of emphasis mark, allowing
    you to pick from a list of common types or supply your own mark as a text string.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, text has no emphasis marks, or `none`. Alternatively, emphasis
    marks can be one of five shapes: `dot`, `circle`, `double-circle`, `triangle`,
    or `sesame`. Those shapes can be set as `filled`, which is the default; or `open`,
    which renders them as unfilled outlines. These are summarized in [Table 15-1](#predefined_emphasis_marks),
    and examples are shown in [Figure 15-35](#various_emphasis_marks).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. The predefined emphasis marks
  prefs: []
  type: TYPE_NORMAL
- en: '| Shape | `filled` | `open` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sesame | ![](assets/sesame_filled.png) (U+FE45) | ![](assets/sesame_open.png)
    (U+FE46) |'
  prefs: []
  type: TYPE_TB
- en: '| Dot | • (U+2022) | ◦ (U+25E6) |'
  prefs: []
  type: TYPE_TB
- en: '| Circle | ● (U+25CF) | ○ (U+25CB) |'
  prefs: []
  type: TYPE_TB
- en: '| Double-circle | ◉ (U+25C9) | ◎ (U+25CE) |'
  prefs: []
  type: TYPE_TB
- en: '| Triangle | ▲ (U+25B2) | △ (U+25B3) |'
  prefs: []
  type: TYPE_TB
- en: The sesame is the most common mark used in vertical writing modes; the circle
    is the usual default in horizontal writing modes.
  prefs: []
  type: TYPE_NORMAL
- en: If the emphasis marks will not fit into the current text line’s height, they
    will cause the height of that line of text to be increased until they fit without
    overlapping other lines. Unlike text decorations and text shadows, text emphasis
    marks *do* affect the line height.
  prefs: []
  type: TYPE_NORMAL
- en: 'If none of the predefined marks work in your specific situation, you can supply
    your own character as a string (a single character in single or double quotes).
    However, be careful: if the string is more than a single character, it may be
    reduced to the first character in the string by the browser. Thus, `text-emphasis-style:
    ''cool''` may result in the browser displaying only the `c` as a mark, as shown
    in [Figure 15-35](#various_emphasis_marks). Furthermore, the string symbols may
    or may not be rotated to match writing direction in vertical languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of setting emphasis marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: A key difference between text emphasis and text decoration is that unlike decoration,
    emphasis is inherited. In other words, if you set a style of `filled sesame` on
    a paragraph, and that paragraph has child elements like links, those child elements
    will inherit the `filled sesame` value.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that every glyph (character or other symbol) gets its
    own mark, and these marks are centered on the glyph. Thus, in proportional fonts
    like those seen in [Figure 15-35](#various_emphasis_marks), the marks will have
    different separations between them depending on which two glyphs are next to each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1535](assets/css5_1535.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-35\. Various emphasis marks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The CSS specification recommends that emphasis marks be half the size of the
    text’s font size, as if they were given `font-size: 50%`. They should otherwise
    use the same text styles as the text; thus, if the text is boldfaced, the emphasis
    marks should be as well. They should also use the text’s color, unless overridden
    with the next property we’ll cover.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing Emphasis Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you wish to have emphasis marks be a different color than the text they’re
    marking, `text-emphasis-color` is here for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value, as is often the case with color-related properties, is `currentcolor`.
    That ensures that emphasis marks will match the color of the text by default.
    To change it, you can do things like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Placing Emphasis Marks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thus far, we’ve shown emphasis marks in specific positions: above each glyph
    in horizontal text, and to the right of each glyph in vertical text. These are
    the default CSS values, but not always the preferred placement. The `text-emphasis-position`
    property allows you to change where marks are placed.'
  prefs: []
  type: TYPE_NORMAL
- en: The values `over` and `under` are applied only when the typographic mode is
    horizontal. Similarly, `right` and `left` are used only when the typographic mode
    is vertical.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be important in some Eastern languages. For example, Chinese, Japanese,
    Korean, and Mongolian all prefer to have marks to the right when the text is written
    vertically. They diverge on horizontal text: Chinese prefers marks below the text,
    and the rest prefer above the text, when it’s horizontal. Thus you might write
    something like this in a stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This would override the default `over right` when the text is marked as being
    Chinese, applying `under right` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using the text-emphasis Shorthand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A shorthand option exists for the `text-emphasis` properties, but it brings
    together only style and color.
  prefs: []
  type: TYPE_NORMAL
- en: The reason `text-emphasis-position` is not included in the `text-emphasis` shorthand
    is so that it can (indeed must) be inherited separately. Therefore, the style
    and color of the marks can be changed via `text-emphasis` without overriding the
    position in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, each character or ideogram or other glyph—what CSS calls
    a *typographic character unit*—gets its own emphasis mark. That is roughly correct,
    but exceptions occur. The following character units do *not* get emphasis marks:'
  prefs: []
  type: TYPE_NORMAL
- en: Word separators such as spaces, or any other Unicode separator character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation characters, such as commas, full stops, and parentheses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode symbols corresponding to control codes, or any unassigned characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Text Drawing Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Browsers are supposed to use a specific order to draw the text decorations,
    shadows, and emphasis marks we’ve discussed previously, along with the text itself.
    These are drawn in the following order, from bottommost (furthest away from the
    user) to topmost (closest to the user):'
  prefs: []
  type: TYPE_NORMAL
- en: Shadows (`text-shadow`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underlines (`text-decoration`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overlines (`text-decoration`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Emphasis marks (`text-emphasis`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Line-through (`text-decoration`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, the drop shadows of the text are placed behind everything else. Underlines
    and overlines go behind the text. Emphasis marks and line-throughs go on top of
    the text. Note that if you have top text-emphasis marks and an overline, the emphasis
    marks will be drawn on top of the overline, obfuscating the overline where they
    overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered a variety of ways to style, decorate, and otherwise enhance
    the text, let’s talk about the property `white-space`, which affects the user
    agent’s handling of space, newline, and tab characters within the document source.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `white-space` property, you can affect how a browser treats the
    whitespace between words and lines of text. To a certain extent, default HTML
    handling already does this: it collapses any whitespace down to a single space.
    So given the following markup, the rendering in a web browser would show only
    one space between each word and ignore the line feed in the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can explicitly set this default behavior with the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This rule tells the browser to do as browsers have always done: discard extra
    whitespace. Given this value, line-feed characters (carriage returns) are converted
    into spaces, and any sequence of more than one space in a row is converted to
    a single space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you set `white-space` to `pre`, however, the whitespace in an affected
    element is treated as though the elements were HTML `<pre>` elements; whitespace
    is *not* ignored, as shown in [Figure 15-36](#honoring_the_spaces_in_markup):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1536](assets/css5_1536.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-36\. Honoring the spaces in markup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With a `white-space` value of `pre`, the browser will pay attention to extra
    spaces and even carriage returns. In this respect, any element can be made to
    act like a `<pre>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite value is `nowrap`, which prevents text from wrapping within an
    element, except wherever you use a `<br>` element. When text can’t wrap and it
    gets too wide for its container, a horizontal scrollbar will appear by default
    (this can be changed using the `overflow` property). The effects of the following
    markup are shown in [Figure 15-37](#suppressing_line_wrapping_with_the_white):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1537](assets/css5_1537.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-37\. Suppressing line wrapping with the `white-space` property
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If an element is set to `pre-wrap`, text within that element has whitespace
    sequences preserved, but text lines are wrapped normally. With this value, generated
    linebreaks as well as those found in the source markup are both honored.
  prefs: []
  type: TYPE_NORMAL
- en: The `pre-line` value is the opposite of `pre-wrap` and causes whitespace sequences
    to collapse as in normal text but honors new lines.
  prefs: []
  type: TYPE_NORMAL
- en: The `break-spaces` value is similar to `pre-wrap`, except that all whitespace
    is preserved, even at the end of the line, with a line-break opportunity after
    each whitespace character. These spaces take up space and do not hang, and thus
    affect the box’s intrinsic sizes (min-content size and max-content size).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-2](#white-space_properties) summarizes the behaviors of the various
    `white-space` properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-2\. `white-space` properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Whitespace | Line feeds | Auto line wrapping | Trailing whitespace
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pre-line` | Collapsed | Honored | Allowed | Removed |'
  prefs: []
  type: TYPE_TB
- en: '| `normal` | Collapsed | Ignored | Allowed | Removed |'
  prefs: []
  type: TYPE_TB
- en: '| `nowrap` | Collapsed | Ignored | Prevented | Removed |'
  prefs: []
  type: TYPE_TB
- en: '| `pre` | Preserved | Honored | Prevented | Preserved |'
  prefs: []
  type: TYPE_TB
- en: '| `pre-wrap` | Preserved | Honored | Allowed | Hanging |'
  prefs: []
  type: TYPE_TB
- en: '| `break-spaces` | Preserved | Honored | Allowed | Wrap |'
  prefs: []
  type: TYPE_TB
- en: 'Consider the following markup, which has line-feed (e.g., return) characters
    to break lines, plus the end of each line has several extra space characters that
    aren’t visible in the markup. The results are illustrated in [Figure 15-38](#three_different_ways_to_handle_whitespace):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1538](assets/css5_1538.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-38\. Three ways to handle whitespace
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the third paragraph has a blank line between the first and second
    lines of text. This is because a line wrap was performed between two adjacent
    blank spaces at the end of the line in the source markup. This didn’t happen for
    `pre-wrap` or `pre-line`, because those `white-space` values don’t allow hanging
    space to create line-wrap opportunities. The `break-spaces` value does.
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace impacts several properties, including `tab-size`, which has no effect
    when the `white-space` property is set to a value in which whitespace is not maintained;
    and `overflow-wrap`, which has an effect only when `white-space` allows wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Tab Sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since whitespace is preserved in some values of `white-space`, it stands to
    reason that tabs (i.e., Unicode code point 0009) will be displayed as, well, tabs.
    But how many spaces should each tab equal? That’s where `tab-size` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when whitespace is preserved, as with `white-space` values of `pre`,
    `pre-wrap`, and `break-spaces`, any tab character will be treated the same as
    eight spaces in a row, including any effects from `letter-spacing` and `word-spacing`.
    You can alter that by using a different integer value. Thus, `tab-size: 4` will
    cause each tab to be rendered as if it were four spaces in a row. Negative values
    are not allowed for `tab-size`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a length value is supplied, each tab is rendered using that length. For
    example, `tab-size: 10px` will cause a sequence of three tabs to be rendered as
    30 pixels of whitespace. Some effects of `tab-size` are illustrated in [Figure 15-39](#differing_tab_lengths).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1539](assets/css5_1539.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-39\. Differing tab lengths
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that `tab-size` is effectively ignored when the value of `white-space`
    causes whitespace to be collapsed (see [Table 15-2](#white-space_properties)).
    The value will still be computed in such cases, but there will be no visible effect
    no matter how many tabs appear in the source.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping and Hyphenation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling whitespace is all well and good, but it’s a lot more common to want
    to influence the way the visible characters are handled when it comes to line
    wrapping. A few properties can influence where line wrapping is allowed, as well
    as enable hyphenation support.
  prefs: []
  type: TYPE_NORMAL
- en: Hyphenation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hyphens can be very useful when displaying long words and short line lengths,
    such as blog posts on mobile devices and portions of *The Economist*. Authors
    can always insert their own hyphenation hints by using the Unicode character *U+00AD
    SOFT HYPHEN* (or, in HTML, `&shy;`), but CSS also offers a way to enable hyphenation
    without littering up the document with hints.
  prefs: []
  type: TYPE_NORMAL
- en: With the default value of `manual`, hyphens are inserted only where manually
    inserted hyphenation markers occur in the document, such as U+00AD or `&shy;`.
    Otherwise, no hyphenation occurs. The value `none`, on the other hand, suppresses
    any hyphenation, even if manual break markers are present; thus, U+00AD and `&shy;`
    are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `<wbr>` element does not introduce a hyphen at the line-break point. To
    make a hyphen appear only at the end of a line, use the soft hyphen character
    entity (`&shy;`) instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The far more interesting (and potentially inconsistent) value is `auto`, which
    permits the browser to insert hyphens and break words at “appropriate” places
    inside words, even where no manually inserted hyphenation breaks exist. But what
    constitutes a *word*? And, under what circumstances is it appropriate to hyphenate
    a word? Both are language dependent. User agents are supposed to prefer manually
    inserted hyphen breaks to automatically determined breaks, but there are no guarantees.
    An illustration of hyphenation, or the suppression thereof, in the following example
    is shown in [Figure 15-40](#hyphenation_results):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1540](assets/css5_1540.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-40\. Hyphenation results
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because hyphenation is language dependent, and because the CSS specifications
    do not define precise (or even vague) rules for user agents, hyphenation may differ
    by browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do choose to hyphenate, be careful about the elements to which you apply
    the hyphenation. The `hyphens` property is inherited, so declaring `body {hyphens:
    auto;}` will apply hyphenation to everything in your document—including text areas,
    code samples, block quotes, and so on. Blocking automatic hyphenation at the level
    of those elements is probably a good idea, using rules that are something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It’s usually a good idea to suppress hyphenation in code samples and code blocks,
    especially in languages that use hyphens in things like property and value names.
    (Ahem.) Similar logic holds for keyboard input text—you likely don’t want a stray
    dash getting into your Unix command-line examples! And so on down the line. If
    you decide that you want to hyphenate some of these elements, just remove them
    from the selector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is strongly advised to set the `lang` attribute on HTML elements to enable
    hyphenation support and improve accessibility. As of mid-2022, `hyphens` is supported
    in Firefox for 30+ languages, Safari supports many European languages, but Chrome-related
    browsers support only English.
  prefs: []
  type: TYPE_NORMAL
- en: Hyphens can be suppressed by the effects of other properties. For example, `word-break`
    affects the way soft wrapping of text is calculated in various languages, determining
    whether line breaks appear where text would otherwise overflow its content box.
  prefs: []
  type: TYPE_NORMAL
- en: Word Breaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a run of text is too long to fit into a single line, it is *soft wrapped*.
    This is in contrast to *hard wraps*, which include line-feed characters and `<br>`
    elements. Where the text is soft wrapped is determined by the user agent, but
    `word-break` lets authors influence that decision making.
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `normal` means that text should be wrapped as it always
    has been. In practical terms, this means that text is broken between words, though
    the definition of a word varies by language. In Latin-derived languages like English,
    this is almost always a space between letter sequences (e.g., words) or at hyphens.
    In ideographic languages like Japanese, each symbol can be a complete word, so
    breaks can occur between any two symbols. In other ideographic languages, though,
    the soft-wrap points may be limited to appear between sequences of symbols that
    are not space separated. Again, that’s all by default and is the way browsers
    have handled text for years.
  prefs: []
  type: TYPE_NORMAL
- en: If you apply the value `break-all`, soft wrapping can (and will) occur between
    any two characters, even if they are in the middle of a word. With this value,
    no hyphens are shown, even if the soft wrapping occurs at a hyphenation point
    (see [“Hyphenation”](#hyphenation)). Note that values of the `line-break` property
    (described next) can affect the behavior of `break-all` in ideographic text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `keep-all` value, on the other hand, suppresses soft wrapping between characters,
    even in ideographic languages where each symbol is a word. Thus, in Japanese,
    a sequence of symbols with no whitespace will not be soft wrapped, even if this
    means the text line will exceed the length of its element. (This behavior is similar
    to `white-space: pre`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-41](#altering_word_breaking_behavior) shows a few examples of `word-break`
    values, and [Table 15-3](#word-breaking_behavior) summarizes the effects of each
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1541](assets/css5_1541.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-41\. Altering word-breaking behavior
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Table 15-3\. Word-breaking behavior
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Non-CJK | CJK | Hyphenation permitted |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `normal` | As usual | As usual | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `break-all` | After any character | After any character | No |'
  prefs: []
  type: TYPE_TB
- en: '| `keep-all` | As usual | Around sequences | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'As noted previously, the value `break-word` has been deprecated, although it
    is supported by all known browsers as of mid-2022\. When used, it has the same
    effect as `{word-break: normal; overflow-wrap: anywhere;}`, even if `overflow-wrap`
    has a different value. (We’ll cover `overflow-wrap` in [“Wrapping Text”](#wrapping_text).)'
  prefs: []
  type: TYPE_NORMAL
- en: Line Breaking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your interests run to CJK text, then in addition to `word-break`, you will
    also want to get to know `line-break`.
  prefs: []
  type: TYPE_NORMAL
- en: As you just saw, `word-break` can affect the way lines of text are soft wrapped
    in CJK text. The `line-break` property also affects such soft wrapping, specifically
    how wrapping is handled around CJK-specific symbols and around non-CJK punctuation
    (such as exclamation points, hyphens, and ellipses) that appears in text declared
    to be CJK.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, `line-break` applies to certain CJK characters all the time,
    regardless of the content’s declared language. If you throw some CJK characters
    into a paragraph of English text, `line-break` will still apply to them, but not
    to anything else in the text. Conversely, if you declare content to be in a CJK
    language, `line-break` will continue to apply to those CJK characters *plus* a
    number of non-CJK characters within the CJK text. These include punctuation marks,
    currency symbols, and a few other symbols.
  prefs: []
  type: TYPE_NORMAL
- en: No authoritative list exists of which characters are affected and which are
    not, but [the specification](http://w3.org/TR/css3-text/#line-break) provides
    a list of recommended symbols and behaviors around those symbols.
  prefs: []
  type: TYPE_NORMAL
- en: The default value `auto` allows user agents to soft wrap text as they like,
    and more importantly lets user agents vary line breaking based on the situation.
    For example, the user agent can use looser line-breaking rules for short lines
    of text and stricter rules for long lines. In effect, `auto` allows the user agent
    to switch among the `loose`, `normal`, and `strict` values as needed, possibly
    even on a line-by-line basis within a single element.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perhaps infer that those other values have the following general meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loose`'
  prefs: []
  type: TYPE_NORMAL
- en: This value imposes the “least restrictive” rules for wrapping text, and is meant
    for use when line lengths are short, such as in newspapers.
  prefs: []
  type: TYPE_NORMAL
- en: '`normal`'
  prefs: []
  type: TYPE_NORMAL
- en: This value imposes the “most common” rules for wrapping text. What exactly “most
    common” means is not precisely defined, though there is the aforementioned list
    of recommended behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '`strict`'
  prefs: []
  type: TYPE_NORMAL
- en: This value imposes the “most stringent” rules for wrapping text. Again, this
    is not precisely defined.
  prefs: []
  type: TYPE_NORMAL
- en: '`anywhere`'
  prefs: []
  type: TYPE_NORMAL
- en: This value creates a line-breaking opportunity around every typographic unit,
    including whitespace and punctuation marks. A soft wrap can even happen in the
    middle of a word, and hyphenation is not applied in such circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After all that information about hyphenation and soft wrapping, what happens
    when text overflows its container anyway? That’s what `overflow-wrap` addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Originally called `word-wrap`, the `overflow-wrap` property applies to inline
    elements, setting whether the browser should insert line breaks within otherwise
    unbreakable strings in order to prevent text from overflowing its line box. In
    contrast to `word-break`, `overflow-wrap` will create a break only if an entire
    word cannot be placed on its own line without overflowing.
  prefs: []
  type: TYPE_NORMAL
- en: This property is less straightforward than it first appears, because its primary
    effect is to change how word wrapping and minimum-content sizing (which we haven’t
    even had a chance to discuss yet) interact in trying to avoid overflow at the
    ends of text lines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `overflow-wrap` property can operate only if the value of `white-space`
    allows line wrapping. If it does not (e.g., with the value `pre`), `overflow-wrap`
    has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: If the default value of `normal` is in effect, wrapping happens as normal—between
    words or as directed by the language. If a word is longer than the width of the
    element containing it, the word will “spill out” of the element box, just as on
    the classic CSS IS AWESOME coffee mug. (Google it if you haven’t seen it before.
    It’s worth the chuckle.)
  prefs: []
  type: TYPE_NORMAL
- en: If the `break-word` value is applied, wrapping can happen in the middle of words,
    with no hyphen placed at the site of the wrapping, but this will happen so that
    line lengths will be as wide as the element’s width. In other words, if the `width`
    property of the element is given the value `min-content`, the “minimum content”
    calculations will assume that content strings must be as long as possible.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, when `anywhere` is set, the “minimum content” calculations will
    take line-wrapping opportunities into account. This means, in effect, that the
    minimum-content width will be the width of the widest character in the element’s
    content. Only when two skinny characters are next to each other will they have
    a chance to be on the same line together, and in a monospace font every line of
    text will be a single character. [Figure 15-42](#overflow_wrapping) illustrates
    the difference between these three values.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1542](assets/css5_1542.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-42\. Overflow wrapping for `width: min-content`'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the value of `width` is something other than `min-content`, then `break-word`
    and `anywhere` will have the same results. Really, the only difference between
    the two values is that with `anywhere`, soft-wrap opportunities introduced by
    the word break are considered when calculating min-content intrinsic sizes. With
    `break-word`, they are not considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `overflow-wrap: break-word` may appear very similar to `word-break: break-all`,
    they are not the same. To see why, compare the second box in [Figure 15-42](#overflow_wrapping)
    to the top-middle box in [Figure 15-41](#altering_word_breaking_behavior). As
    it shows, `overflow-wrap` kicks in only if content actually overflows; thus, when
    there is an opportunity to use whitespace in the source to wrap lines, `overflow-wrap`
    will take it. By contrast, `word-break: break-all` will cause wrapping when content
    reaches the wrapping edge, regardless of any whitespace that comes earlier in
    the line.'
  prefs: []
  type: TYPE_NORMAL
- en: Once upon a time there was a property called `word-wrap` that did exactly what
    `overflow-wrap` does. The two are so identical that the specification explicitly
    states that user agents “must treat `word-wrap` as an alternate name for the `overflow-wrap`
    property, as if it were a shorthand of `overflow-wrap`.”
  prefs: []
  type: TYPE_NORMAL
- en: Writing Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we discussed inline direction and introduced the topic of reading direction.
    You’ve already seen numerous benefits of including the `lang` attribute in your
    HTML, from being able to style based on language selectors, to allowing the user
    agent to hyphenate. Generally, you should let the user agent handle the direction
    of text based on the language attribute, but CSS does provide properties for the
    rare occasions when an override is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Writing Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The property used for specifying one of five available writing modes is, of
    all things, `writing-mode`. This property sets the block-flow direction of the
    element, which determines how boxes are stacked together.
  prefs: []
  type: TYPE_NORMAL
- en: The default value, `horizontal-tb`, means “a horizontal inline direction, and
    a top-to-bottom block direction.” This covers all Western and some Middle Eastern
    languages, which may differ in the direction of their horizontal writing. The
    other two values offer a vertical inline direction, and either an RTL or LTR block
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: The `sideways-rl` and `sideways-lr` values take horizontal text and turn its
    flow “sideways,” with the direction the text runs either going right to left (for
    `sidewyas-rl`) or left to right (for `sideways-lr`). The difference between these
    values and the vertical values is that the text is turned whichever way is necessary
    to make the text read naturally.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-43](#writing_modes) illustrates all five values.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1543](assets/css5_1543.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-43\. Writing modes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how the lines are strung together in the two `vertical-` examples. If
    you tilt your head to the right, the text in `vertical-rl` is at least readable.
    The text in `vertical-lr`, on the other hand, is difficult to read because it
    appears to flow from bottom to top, at least when arranging English text. This
    is not a problem in languages that use `vertical-lr` flow, such as forms of Japanese.
  prefs: []
  type: TYPE_NORMAL
- en: In vertical writing modes, the block direction is horizontal, which means vertical
    alignment of inline elements causes them to move horizontally. This is illustrated
    in [Figure 15-44](#writing_modes_vertical_align).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1544](assets/css5_1544.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-44\. Writing modes and “vertical” alignment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All the super- and subscript elements cause horizontal shifts, both of themselves
    and the placement of the lines they occupy, even though the property used to move
    them is `vertical-align`. As described earlier, the vertical displacement is with
    respect to the line box, where the box’s baseline is defined as horizontal—even
    when it’s being drawn vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Confused? It’s OK. Writing modes are likely to confuse you, because they’re
    such a different way of thinking *and* because old assumptions in the CSS specification
    clash with the new capabilities. If vertical writing modes had been supported
    from the outset, `vertical-align` would likely have a different name—`inline-align`
    or something like that. (Maybe one day that will happen.)
  prefs: []
  type: TYPE_NORMAL
- en: Changing Text Orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve settled on a writing mode, you may decide you want to change the
    orientation of characters within those lines of text. You might want to do this
    for various reasons, not the least of which is using different writing systems
    that are commingled, such as Japanese text with English words or numbers mixed
    in. In these cases, `text-orientation` is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `text-orientation` property affects the way characters are oriented. What
    that means is best illustrated by the following styles, rendered in [Figure 15-45](#writing_modes_text_orientation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1545](assets/css5_1545.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-45\. Text orientation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Across the top of [Figure 15-45](#writing_modes_text_orientation) is a basically
    unstyled paragraph of mixed Japanese and English text. Below that are three copies
    of that paragraph, using the writing mode `vertical-lr`. In the first, `text-orientation:
    mixed` writes the horizontal-script characters (the English) sideways, and the
    vertical-script characters (the Japanese) upright. In the second, all characters
    are `upright`, including the English characters. In the third, all characters
    are `sideways`, including the Japanese characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of mid-2022, `sideways` is not supported by Chromium browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only relevant to vertical writing modes, the `text-combine-upright` property
    enables displaying a subset of characters upright within vertical text. This can
    be useful when mixing languages or pieces of languages, such as embedding Arabic
    numerals in CJK text, but may have other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, this property lets you say whether characters may sit next to each
    other horizontally while being part of a vertical line of text. Your choices are
    whether to allow this for all characters or for only a few numeric digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works: as a line of vertical text is laid out, the browser can
    consider whether the width of two characters, sitting next to each other, is less
    than or equal to the value of `1em` for the text. If so, they may be placed next
    to each other, effectively putting two characters into the space of one. If not,
    the first character is placed alone, and the process continues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As of mid-2022, this can lead to characters being very, very squished. For
    an example, consider the following markup and CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the paragraphs are written using `writing-mode: vertical-rl`, but some
    are set to `text-combine-upright: all`, and others are not. The last paragraph
    is not set to `all`, but the `<span>` elements within it have been. [Figure 15-46](#various_types_of_upright_combination)
    shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1546](assets/css5_1546.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-46\. Various types of upright combination
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Lest you think a bug is at work here, the results are consistent across browsers
    (as of mid-2022). The second and fourth columns have every single character, whether
    Chinese ideographs or Arabic numerals, squished horizontally to fit on a single
    line.
  prefs: []
  type: TYPE_NORMAL
- en: A way around this is to break up the text with child elements, as shown in the
    fifth and sixth columns. In the first, numbers are surrounded with `<span>` elements,
    which break up the fitting process. This works as long as no run of text has too
    many characters; beyond two or three symbols, the text becomes progressively more
    difficult to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sixth column shows a way to hack around the problem: apply `text-combine-upright:
    all` to only the `<span>` elements, which are already used to wrap the Arabic
    numerals, by giving each `<span>` a `class` value of `combine`. In that case,
    the `.combine` rule will apply only to the `<span>` elements, not all the text
    in the paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `digits` value is supposed to make possible without the need
    for all the extra markup. Theoretically, you could get the same result as that
    shown in the sixth column of [Figure 15-46](#various_types_of_upright_combination)
    by applying the following CSS to the paragraph that has no `<span>` elements in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, as of mid-2022, no browser supports this behavior, unless you count Internet
    Explorer 11 using the alternate property name `-ms-text-combine-horizontal`.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Direction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Harking back to the days of CSS2, a pair of properties could be used to affect
    the direction of text by changing the inline baseline direction: `direction` and
    `unicode-bidi`. These should generally not be used today, but are covered here
    in case you come across them in legacy code.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The CSS specification explicitly warns *against* using `direction` and `unicode-bidi`
    in CSS when applied to HTML documents. To quote: “Because HTML [user agents] can
    turn off CSS styling, we recommend…the HTML `dir` attribute and `<bdo>` element
    to ensure correct bidirectional layout in the absence of a style sheet.”'
  prefs: []
  type: TYPE_NORMAL
- en: The `direction` property affects the writing direction of text in a block-level
    element, the direction of table-column layout, the direction in which content
    horizontally overflows its element box, and the position of the last line of a
    fully justified element. For inline elements, direction applies only if the property
    `unicode-bidi` is set to either `embed` or `bidi-override` (see the following
    description of `unicode-bidi`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `ltr` is the default, it is expected that if a browser is displaying
    RTL text, the value will be changed to `rtl`. Thus, a browser might carry an internal
    rule stating something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The real rule would be longer and encompass all RTL languages, not just Arabic
    and Hebrew, but it illustrates the point.
  prefs: []
  type: TYPE_NORMAL
- en: While CSS attempts to address writing direction, Unicode has a much more robust
    method for handling directionality. With the property `unicode-bidi`, CSS authors
    can take advantage of some of Unicode’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we’ll simply quote the value descriptions from the CSS 2.1 specification,
    which do a good job of capturing the essence of each value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`normal`'
  prefs: []
  type: TYPE_NORMAL
- en: The element does not open an additional level of embedding with respect to the
    bidirectional algorithm. For inline-level elements, implicit reordering works
    across element boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: '`embed`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the element is inline-level, this value opens an additional level of embedding
    with respect to the bidirectional algorithm. The direction of this embedding level
    is given by the `direction` property. Inside the element, reordering is done implicitly.
    This corresponds to adding a “left-to-right embedding” character (U+202A; for
    `direction: ltr`) or a “right-to-left embedding” character (U+202B; for `direction:
    rtl`) at the start of the element and a “pop directional formatting” character
    (U+202C) at the end of the element.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bidi-override`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates an override for inline-level elements. For block-level elements,
    this creates an override for inline-level descendants not within another block.
    This means that, inside the element, reordering is strictly in sequence according
    to the `direction` property; the implicit part of the bidirectional algorithm
    is ignored. This corresponds to adding a “left-to-right override” character (U+202D;
    for `direction: ltr`) or “right-to-left override” character (U+202E; for `direction:
    rtl`) at the start of the element and a “pop directional formatting” character
    (U+202C) at the end of the element.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even without altering the font face, we have many ways to change the appearance
    of text. In addition to classic effects such as underlining, CSS enables you to
    draw lines over text or through it, change the amount of space between words and
    letters, indent the first line of a paragraph (or other block-level element),
    align text in various ways, exert influence over the hyphenation and line breaking
    of text, and much more. You can even alter the amount of space between lines of
    text. CSS also supports languages other than those that are written left to right,
    top to bottom. Given that so much of the web is text, the strength of these properties
    makes a great deal of sense.
  prefs: []
  type: TYPE_NORMAL
