- en: Chapter 15\. Text Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because text is so important, many CSS properties affect it in one way or another.
    But didn’t we just cover that in [Chapter 14](ch14.html#fonts)? Not exactly: we
    covered only fonts—the importing and usage of typefaces. Text styles are different.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: OK, so what is the difference between text and fonts? At the simplest level,
    *text* is the content, and *fonts* are used to display that content. Fonts provide
    the shape for the letters. Text is the styling around those shapes. Using text
    properties, you can affect the position of text in relation to the rest of the
    line, superscript it, underline it, and change the capitalization. You can affect
    the size, color, and placement of text decorations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Indentation and Inline Alignment
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with a discussion of how you can affect the inline positioning of
    text within a line. Think of these basic actions as the same types of steps you
    might take to create a newsletter or write a report.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Originally, CSS was based on concepts of *horizontal* and *vertical*. To better
    support all languages and writing directions, CSS now uses the terms *block direction*
    and *inline direction*. If your primary language is Western-derived, you’re accustomed
    to a block direction of top to bottom, and an inline direction of left to right.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The *block direction* is the direction in which block elements are placed by
    default in the current writing mode. In English, for example, the block direction
    is top to bottom, or vertical, as one paragraph (or other text element) is placed
    beneath the one before. Some languages have vertical text, like Mongolian. When
    text is vertical, the block direction is horizontal.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The *inline direction* is the direction in which inline elements are written
    within a block. To again take English as an example, the inline direction is left
    to right, or horizontal. In languages like Arabic and Hebrew, the inline direction
    is right to left instead. To reuse the example from the preceding paragraph, Mongolian’s
    inline direction is top to bottom.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Let’s reconsider English for a moment. A plain page of English text, displayed
    on a screen, has a vertical block direction (from top to bottom) and a horizontal
    inline direction (from left to right). But if the page is rotated 90 degrees counterclockwise
    by using CSS Transforms, suddenly the block direction is horizontal and the inline
    direction is vertical. (And bottom to top, at that.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can still find a lot of English-centric blog posts and other CSS-related
    documentation on the web using the terms *vertical* and *horizontal* when talking
    about writing directions. When you do, mentally translate them to *block* and
    *inline* as needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Indenting Text
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most paper books we read in Western languages format paragraphs of text with
    the first line indented, and no blank line between paragraphs. If you want to
    re-create that look, CSS provides the property `text-indent`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `text-indent`, the first line of any element can be indented by a given
    length, even if that length is negative. A common use for this property is to
    indent the first line of a paragraph:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This rule will cause the first line of any paragraph to be indented 3 ems, as
    shown in [Figure 15-1](#text_indenting).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1501](assets/css5_1501.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Text indenting
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In general, you can apply `text-indent` to any element that generates a block
    box, and the indentation will occur along the inline direction. You can’t apply
    it to inline elements or replaced elements such as images. However, if you have
    an image within the first line of a block-level element, it will be shifted over
    with the rest of the text in the line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to “indent” the first line of an inline element, you can create
    the effect with left padding or a margin.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set negative values for `text-indent` to create a *hanging indent*,
    where the first line hangs out to one side of the rest of the element:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Be careful when setting a negative value for `text-indent`; the first few words
    may be chopped off by the edge of the browser window if you aren’t careful. To
    avoid display problems, we recommend you use a margin or padding to accommodate
    the negative indentation:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Any unit of length, including percentage values, may be used with `text-indent`.
    In the following case, the percentage refers to the width of the parent element
    of the element being indented. In other words, if you set the indent value to
    `10%`, the first line of an affected element will be indented by 10% of its parent
    element’s width, as shown in [Figure 15-2](#text_indenting_with_percentages):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![css5 1502](assets/css5_1502.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. Text indenting with percentages
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that because `text-indent` is inherited, some browsers, like the Yandex
    browser, inherit the computed values, while Safari, Firefox, Edge, and Chrome
    inherit the declared value. In the following, both bits of text will be indented
    5 ems in Yandex and 10% of the current element’s width in other browsers, because
    the value of `5em` is inherited by the paragraph from its parent `<div>` in Yandex
    and older versions of WebKit, whereas most evergreen browsers inherit the declared
    value of 10%:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As of late 2022, two keywords are being considered for addition to `text-indent`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`hanging`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Inverts the indentation effect; that is, `text-indent: 3em hanging` would indent
    all the lines of text *except* the first line. This is similar to the negative-value
    indentation discussed previously, but without risking cutting off text, because
    instead of pulling the first line out of the content box, all the lines but the
    first are indented away from the edge of the content box.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`each-line`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Indents the first line of the element plus any line that starts after a forced
    line break, such as that caused by a `<br>`, but not lines that follow a soft
    line break.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'When supported, either keyword can be used in conjunction with a length or
    percentage, such as the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Aligning Text
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even more basic than `text-indent` is the property `text-align`, which affects
    the way the lines of text in an element are aligned with respect to one another.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The quickest way to understand how these values work is to examine [Figure 15-3](#selected_behaviors_of_the_text-align_pro),
    which demonstrates the most widely used values. The values `left`, `right`, and
    `center` cause the text within elements to be aligned exactly as described by
    these words in horizontal languages like English or Arabic, regardless of the
    language’s inline direction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1503](assets/css5_1503.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 15-3\. Selected behaviors of the `text-align` property
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default value of `text-align` is `start`, which is the equivalent of `left`
    in LTR languages, and `right` in RTL languages. In vertical languages. `left`
    and `right` are mapped to the start or end edge, respectively. This is illustrated
    in [Figure 15-4](#left_comma_right_comma_and_center_in_ver).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Because `text-align` applies only to block-level elements such as paragraphs,
    there’s no way to center an anchor within its line without aligning the rest of
    the line (nor would you want to, since that would likely cause text overlap).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may expect, `center` causes each line of text to be centered within
    the element. If you’ve ever come across the long-ago deprecated `<CENTER>` element,
    you may be tempted to believe that `text-align: center` is the same. It is actually
    quite different. The `<CENTER>` element affected not only text, but also centered
    whole elements, such as tables. The `text-align` property does not control the
    alignment of elements, only their inline content.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1504](assets/css5_1504.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Figure 15-4\. Left, right, and center in vertical writing modes
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Start and end alignment
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remembering that CSS was based on concepts of *horizontal* and *vertical*,
    the initial default value was originally “a nameless value that acts as *left*
    if *direction* is *ltr*, *right* if *direction* is *rtl*.” The default value now
    has a name: `start`, which is the equivalent of `left` in LTR languages, and `right`
    in RTL languages.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `start` means that text is aligned to the start edge of
    its line box. In LTR languages like English, that’s the left edge; in RTL languages
    such as Arabic, it’s the right edge. In vertical languages, it will be the top
    or bottom, depending on the writing direction. The upshot is that the default
    value is much more aware of the document’s language direction while leaving the
    default behavior the same in the vast majority of existing cases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In a like manner, `end` aligns text with the end edge of each line box—the right
    edge in LTR languages, the left edge in RTL languages, and so forth. [Figure 15-5](#start_and_end_alignment-id1)
    shows the effects of these values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1505](assets/css5_1505.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 15-5\. Start and end alignment
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Justified text
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An often-overlooked alignment value is `justify`, which raises some issues of
    its own. In justified text, both ends of a line of text (except the last line,
    which can be set with `text-align-last`) are placed at the inner edges of the
    parent element, as shown in [Figure 15-6](#justified_text-id1). Then, the spacing
    between words and letters is adjusted so that the words are distributed evenly
    throughout the line. Justified text is common in the print world (for example,
    in this book), but under CSS, a few extra considerations come into play.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1506](assets/css5_1506.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 15-6\. Justified text
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The user agent determines how justified text should be stretched or distributed
    to fill the space between the left and right edges of the parent. Some browsers,
    for example, might add extra space only between words, while others might distribute
    the extra space between letters (although the CSS specification states that “user
    agents may not further increase or decrease the inter-character space” if the
    property `letter-spacing` has been assigned a length value). Other user agents
    may reduce space on some lines, thus mashing the text together a bit more than
    usual.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The value `justify-all` sets full justification for both `text-align` and `text-align-last`
    (covered in an upcoming section).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As of mid-2022, the `justify-all` value is not supported by any browser, even
    though nearly all of them support `text-align: justify` and `text-align-last:
    justify`. This gap in support remains a mystery as of press time, but is solved
    in most browsers with the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Parent matching
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have one more value to cover: `match-parent`. If you declare `text-align:
    match-parent`, and the inherited value of `text-align` is `start` or `end`, the
    alignment of the `match-parent` element will be calculated with respect to the
    parent element’s horizontal or vertical, rather than inline, direction.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could force any English element’s text alignment to match the
    alignment of a parent element, regardless of its writing direction, as in the
    following example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Aligning the Last Line
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times you might want to align the text in the very last line of an element
    differently than you did the rest of the content. For example, with `text-align:
    justify`, the last line defaults to `text-align: start`. You might ensure a left-aligned
    last line in an otherwise fully justified block of text, or choose to swap from
    left to center alignment. For those situations, you can use `text-align-last`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: As with `text-align`, the quickest way to understand how these values work is
    to examine [Figure 15-7](#differently_aligned_last_lines).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1507](assets/css5_1507.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Figure 15-7\. Differently aligned last lines
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The last lines of the elements are aligned independently of the rest of the
    elements, according to the elements’ `text-align-last` values.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: A close study of [Figure 15-7](#differently_aligned_last_lines) will reveal
    that there’s more at play than just the last lines of block-level elements. In
    fact, `text-align-last` applies to any line of text that immediately precedes
    a forced line break, whether or not that line break is triggered by the end of
    an element. Thus, a line break created by a `<br>` tag will make the line of text
    immediately before that break use the value of `text-align-last`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting wrinkle arises with `text-align-last`: if the first line of
    text in an element is also the last line of text in the element, the value of
    `text-align-last` takes precedence over the value of `text-align`. Thus, the following
    styles will result in a centered paragraph, not a start-aligned paragraph:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Word Spacing
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `word-spacing` property is used to modify interword spacing, accepting a
    positive or negative length. This length is *added* to the standard space between
    words. Therefore, the default value of `normal` is the same as setting a value
    of `0`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'If you supply a positive length value, the space between words will increase.
    Setting a negative value for `word-spacing` brings words closer together:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Manipulating these settings has the effect shown in [Figure 15-8](#changing_the_space_between_words).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1508](assets/css5_1508.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Figure 15-8\. Changing the space between words
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In CSS terms, a *word* is any string of nonwhitespace characters that is surrounded
    by whitespace of some kind. This means `word-spacing` is unlikely to work in any
    languages that employ pictographs, or non-Roman writing styles. This is also why
    the em dashes in the previous example’s text don’t get space around them. From
    the CSS point of view, “spaces—as” is a single word.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Use caution. The `word-spacing` property allows you to create very unreadable
    documents, as [Figure 15-9](#really_wide_word_spacing) illustrates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1509](assets/css5_1509.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 15-9\. Really wide word spacing
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Letter Spacing
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the issues you encounter with `word-spacing` also occur with `letter-spacing`.
    The only real difference between the two is that `letter-spacing` modifies the
    space between characters or letters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: As with the `word-spacing` property, the permitted values of `letter-spacing`
    include any length, though character-relative lengths like `em` (rather than root-relative
    lengths like `rem`) are recommended to ensure that the spacing is proportional
    to the font size.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The default keyword is `normal`, which has the same effect as `letter-spacing:
    0`. Any length value you enter will increase or decrease the space between letters
    by that amount. [Figure 15-10](#various_kinds_of_letter_spacing) shows the results
    of the following markup:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![css5 1510](assets/css5_1510.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: Figure 15-10\. Various kinds of letter spacing
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a page uses fonts with features like ligatures, and those features are enabled,
    altering letter or word spacing can effectively disable them. Browsers will not
    recalculate ligatures or other joins when letter spacing is altered.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Spacing and Alignment
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to remember that space between words may be altered by the value
    of the property `text-align`. If an element is justified, the spaces between letters
    and words may be altered to fit the text along the full width of the line. This
    may in turn alter the spacing declared using `word-spacing`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'If a length value is assigned to `letter-spacing`, that value cannot be changed
    by `text-align`; but if the value of `letter-spacing` is `normal`, inter-character
    spacing may be changed to justify the text. CSS does not specify how the spacing
    should be calculated, so user agents use their own algorithms. To prevent `text-align`
    from altering letter spacing while keeping the default letter spacing, declare
    `letter-spacing: 0`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that computed values are inherited, so child elements with larger or smaller
    text will have the same word or letter spacing as their parent element. You cannot
    define a scaling factor for `word-spacing` or `letter-spacing` to be inherited
    in place of the computed value (in contrast with `line-height`). As a result,
    you may run into problems such as those shown in [Figure 15-11](#inherited_letter_spacing):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![css5 1511](assets/css5_1511.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Figure 15-11\. Inherited letter spacing
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As `inherit` inherits the ancestor’s letter-spacing computed length, the only
    way to achieve letter spacing that’s in proportion to the size of the text is
    to set it explicitly on each element, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And the same goes for word spacing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Vertical Alignment
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered alignment along the inline direction, let’s move on to
    the vertical alignment of inline elements along the block direction—things like
    superscripting and vertical alignment (vertical with respect to the line of text,
    if the text is laid out horizontally). Since the construction of lines is a complex
    topic that merits its own small book, we’ll just stick to a quick overview here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the Height of Lines
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The distance between lines can be affected by changing the height of a line.
    Note that *height* here is with respect to the line of text itself, assuming that
    the longer axis of a line is *width*, even if it’s written vertically. The property
    names we cover from here will reveal a strong bias toward Western languages and
    their writing directions; this is an artifact of the early days of CSS, when Western
    languages were the only ones that could be easily represented.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The `line-height` property refers to the distance between the baselines of lines
    of text rather than the size of the font, and it determines the amount by which
    the height of each element’s box is increased or decreased. In the most basic
    cases, specifying `line-height` is a way to increase (or decrease) the vertical
    space between lines of text, but this is a misleadingly simple way of looking
    at how `line-height` works. This property controls the *leading*, which is the
    extra space between lines of text above and beyond the font’s size. In other words,
    the difference between the value of `line-height` and the size of the font is
    the leading.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: When applied to a block-level element, `line-height` defines the *minimum* distance
    between text baselines within that element. Note that it defines a minimum, not
    an absolute value. Baselines of text can wind up being pushed farther apart than
    the value of `line-height`, for example, if a line contains an inline image or
    form control that is taller than the declared line height. The `line-height` property
    does not affect layout for replaced elements like images, but it still applies
    to them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a line
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you learned in [Chapter 6](ch06.html#basic-visual-formatting), every element
    in a line of text generates a *content area*, which is determined by the size
    of the font. This content area, in turn, generates an *inline box* that is, in
    the absence of any other factors, exactly equal to the content area. The leading
    generated by `line-height` is one of the factors that increase or decrease the
    height of each inline box.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: To determine the leading for a given element, subtract the computed value of
    `font-size` from the computed value of `line-height`. That value is the total
    amount of leading. And remember, it can be a negative number. The leading is then
    divided in half, and each half-leading is applied to the top and bottom of the
    content area. The result is the inline box for that element. In this way, each
    line of text is centered within the line height as long as the height of the line
    isn’t forced beyond its minimum height by a replaced element or other factor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s say `font-size` (and therefore the content area) is 14
    pixels tall, and `line-height` is computed to 18 pixels. The difference (4 pixels)
    is divided in half, and each half is applied to the top and bottom of the content
    area. This effectively centers the content by creating an inline box that is 18
    pixels tall, with 2 extra pixels above and below the content area. This sounds
    like a roundabout way to describe how `line-height` works, but there are excellent
    reasons for the description.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the inline boxes have been generated for a given line of content,
    they are then considered in the construction of the line box. A line box is exactly
    as tall as needed to enclose the top of the tallest inline box and the bottom
    of the lowest inline box. [Figure 15-12](#line_box_diagram) shows a diagram of
    this process.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1512](assets/css5_1512.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: Figure 15-12\. Line-box diagram
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Assigning values to line-height
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now consider the possible values of `line-height`. If you use the default
    value of `normal`, the user agent must calculate the space between lines. Values
    can vary by user agent, but the `normal` default is generally around 1.2 times
    the size of the font, which makes line boxes taller than the value of `font-size`
    for a given element.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Many values are simple length measures (e.g., `18px` or `2em` ), but <*`number`*>
    values with no length unit are preferable in many situations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be aware that even if you use a valid length measurement, such as `4cm`, the
    browser (or the operating system) may be using an incorrect metric for real-world
    measurements, so the line height may not show up as exactly 4 centimeters on your
    monitor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The `em`, `ex`, and percentage values are calculated with respect to the `font-size`
    of the element. The results of the following CSS and HTML are shown in [Figure 15-13](#simple_calculations_with_the_line-height):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![css5 1513](assets/css5_1513.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Figure 15-13\. Simple calculations with the `line-height` property
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding line-height and inheritance
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the `line-height` is inherited by one block-level element from another,
    things get a bit trickier. The `line-height` values inherit from the parent element
    as computed from the parent, not the child. The results of the following markup
    are shown in [Figure 15-14](#small_line-height_comma_large_font-size). It probably
    wasn’t what the author had in mind:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![css5 1514](assets/css5_1514.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Figure 15-14\. Small line-height, large font-size, slight problem
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Why are the lines so close together? Because the computed `line-height` value
    of `10px` was inherited by the paragraph from its parent `<div>`. One solution
    to the small `line-height` problem depicted in [Figure 15-14](#small_line-height_comma_large_font-size)
    is to set an explicit `line-height` for every element, but that’s not very practical.
    A better alternative is to specify a number, which actually sets a scaling factor:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you specify a number with no length unit, you cause the scaling factor
    to be an inherited value instead of a computed value. The number will be applied
    to the element and all of its child elements so that each element has a `line-height`
    calculated with respect to its own `font-size` (see [Figure 15-15](#using_line-height_factors_to_overcome_in)):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![css5 1515](assets/css5_1515.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Figure 15-15\. Using `line-height` factors to overcome inheritance problems
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you have a basic grasp of how lines are constructed, let’s talk about
    vertically aligning elements relative to the line box—that is, displacing them
    along the block direction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Vertically Aligning Text
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve ever used the elements `<sup>` and `<sub>` (the superscript and subscript
    elements), or used the deprecated `align` attribute with an image, you’ve done
    some rudimentary vertical alignment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because of the property name `vertical-align`, this section will use the terms
    *vertical* and *horizontal* to refer to the block and inline directions of the
    text.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vertical-align` property accepts any one of eight keywords, a percentage
    value, or a length value. The keywords are a mix of the familiar and unfamiliar:
    `baseline` (the default value), `sub`, `super`, `bottom`, `text-bottom`, `middle`,
    `top`, and `text-top`. We’ll examine how each keyword works in relation to inline
    elements.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember: `vertical-align` does *not* affect the alignment of content within
    a block-level element, just the alignment of inline content within a line of text
    or a table cell. This may change in the future, but as of mid-2022, proposals
    to widen its scope have yet to move forward.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Baseline alignment
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `vertical-align: baseline` forces the baseline of an element to align
    with the baseline of its parent. Browsers, for the most part, do this anyway,
    since you’d probably expect the bottoms of all text elements in a line to be aligned.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'If a vertically aligned element doesn’t have a baseline—that is, if it’s an
    image, a form input, or another replaced element—then the bottom of the element
    is aligned with the baseline of its parent, as [Figure 15-16](#baseline_alignment_of_an_image)
    shows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![css5 1516](assets/css5_1516.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Figure 15-16\. Baseline alignment of an image
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This alignment rule is important because it causes some web browsers to always
    put a replaced element’s bottom edge on the baseline, even if the line includes
    no other text. For example, let’s say you have an image in a table cell all by
    itself. The image may actually be on a baseline, but in some browsers, the space
    below the baseline causes a gap to appear beneath the image. Other browsers will
    “shrink-wrap” the image with the table cell, and no gap will appear. The gap behavior
    is correct, despite its lack of appeal to most authors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See the deeply aged and yet somehow still relevant article [“Images, Tables,
    and Mysterious Gaps”](https://meyerweb.com/eric/articles/devedge/img-table-gaps)
    (2002) for a more detailed explanation of gap behavior and ways to work around
    it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Superscripting and subscripting
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The declaration `vertical-align: sub` causes an element to be subscripted,
    meaning that its baseline (or bottom, if it’s a replaced element) is lowered with
    respect to its parent’s baseline. The specification doesn’t define the distance
    the element is lowered, so it may vary depending on the user agent.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The `super` value is the opposite of `sub`; it raises the element’s baseline
    (or bottom of a replaced element) with respect to the parent’s baseline. Again,
    the distance the text is raised depends on the user agent.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the values `sub` and `super` do *not* change the element’s font size,
    so subscripted or superscripted text will not become smaller (or larger). Instead,
    any text in the sub- or superscripted element will, by default, be the same size
    as text in the parent element, as illustrated by [Figure 15-17](#superscript_and_subscript_alignment):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![css5 1517](assets/css5_1517.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: Figure 15-17\. Superscript and subscript alignment
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you wish to make super- or subscripted text smaller than the text of its
    parent element, you can do so by using the `font-size` property.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Top and bottom alignment
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `vertical-align: top` option aligns the top of the element’s inline box
    with the top of the line box. Similarly, `vertical-align: bottom` aligns the bottom
    of the element’s inline box with the bottom of the line box. Thus, the following
    markup results in [Figure 15-18](#top_and_bottom_alignment):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![css5 1518](assets/css5_1518.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: Figure 15-18\. Top and bottom alignment
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second line of the first paragraph contains two inline elements whose top
    edges are aligned with each other. They’re also well above the baseline of the
    text. The second paragraph shows the inverted case: two images whose bottoms are
    aligned and are well below the baseline of their line. This is because in both
    cases, the sizes of the elements in the line have increased the line’s height
    beyond what the font’s size would normally create.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want instead to align elements with the top or bottom edge of just the
    text in the line, `text-top` and `text-bottom` are the values you seek. For the
    purposes of these values, replaced elements, or any other kinds of nontext elements,
    are ignored. Instead, a *default* text box is considered. This default box is
    derived from the `font-size` of the parent element. The bottom of the aligned
    element’s inline box is then aligned with the bottom of the default text box.
    Thus, given the following markup, you get a result like the one shown in [Figure 15-19](#text-top_and_bottom_alignment):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![css5 1519](assets/css5_1519.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 15-19\. Text-top and -bottom alignment
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Middle alignment
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value `middle` is usually (but not always) applied to images. It does not
    have the exact effect you might assume, given its name. The `middle` value aligns
    the middle of an inline element’s box with a point that is `0.5ex` above the baseline
    of the parent element, where `1ex` is defined relative to the `font-size` for
    the parent element. [Figure 15-20](#precise_detail_of_middle_alignment) shows
    this in more detail.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1520](assets/css5_1520.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 15-20\. Precise detail of middle alignment
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since most user agents treat `1ex` as one-half em, `middle` usually aligns the
    vertical midpoint of an element with a point one-quarter em above the parent’s
    baseline, though this is not a defined distance and so can vary from one user
    agent to another.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Percentages
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Percentages don’t let you simulate `align="middle"` for images. Instead, setting
    a percentage value for `vertical-align` raises or lowers the baseline of the element
    (or the bottom edge of a replaced element) by the amount declared, with respect
    to the parent’s baseline. (The percentage you specify is calculated as a percentage
    of `line-height` for the element, *not* its parent.) Positive percentage values
    raise the element, and negative values lower it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on how the text is raised or lowered, it can appear to be placed
    in adjacent lines, as shown in [Figure 15-21](#percentages_and_fun_effects), so
    take care when using percentage values:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![css5 1521](assets/css5_1521.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Figure 15-21\. Percentages and fun effects
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Length alignment
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let’s consider vertical alignment with a specific length. The `vertical-align`
    option is very basic: it shifts an element up or down by the declared distance.
    Thus, `vertical-align: 5px;` will shift an element upward 5 pixels from its unaligned
    placement. Negative length values shift the element downward.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to realize that vertically aligned text does not become part
    of another line, nor does it overlap text in other lines. Consider [Figure 15-22](#inline_alignments_can_cause_lines_to),
    in which some vertically aligned text appears in the middle of a paragraph.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1522](assets/css5_1522.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 15-22\. Vertical alignments can cause lines to get taller
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, any vertically aligned element can affect the height of the
    line. Recall the description of a line box, which is exactly as tall as necessary
    to enclose the top of the tallest inline box and the bottom of the lowest inline
    box. This includes inline boxes that have been shifted up or down by vertical
    alignment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Text Transformation
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the alignment properties covered, let’s look at ways to manipulate the
    capitalization of text by using the property `text-transform`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The default value `none` leaves the text alone and uses whatever capitalization
    exists in the source document. As their names imply, `uppercase` and `lowercase`
    convert text into all upper- or lowercase characters. The `full-width` value forces
    the writing of a character inside a square, as if on a typographical grid.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Accessibility note: some screen readers will read all-uppercase text one letter
    at a time, as if spelling out an acronym, even if the source text is lowercase
    or mixed-case and the uppercasing is only enforced via CSS. For this reason, uppercasing
    text via CSS should be approached with caution.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `capitalize` value capitalizes only the first letter of each word
    (where a *word* is defined as a string of adjacent characters surrounded by whitespace).
    [Figure 15-23](#various_kinds_of_text_transformation) illustrates each of these
    settings in a variety of ways:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![css5 1523](assets/css5_1523.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Figure 15-23\. Various kinds of text transformation
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As noted in [Chapter 6](ch06.html#basic-visual-formatting), *CJK* stands for
    *Chinese/Japanese/Korean*. CJK characters take up the majority of the entire Unicode
    code space, including approximately 70,000 Han characters. You may sometimes come
    across the abbreviation *CJKV*, which adds *Vietnamese* to the mix.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Different user agents may have different ways of deciding where words begin
    and, as a result, which letters are capitalized. For example, the text “heading-one”
    in the `<h1>` element, shown in [Figure 15-23](#various_kinds_of_text_transformation),
    could be rendered in one of two ways: “Heading-one” or “Heading-One.” CSS does
    not say which is correct, so either is possible.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have also noticed that the last letter in the `<h1>` element in [Figure 15-23](#various_kinds_of_text_transformation)
    is still uppercase. This is correct: when applying a `text-transform` of `capitalize`,
    CSS requires user agents to make sure only the first letter of each word is capitalized.
    They can ignore the rest of the word.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'As a property, `text-transform` may seem minor, but it’s very useful if you
    suddenly decide to capitalize all your `<h1>` elements. Instead of individually
    changing the content of all your `<h1>` elements, you can just use `text-transform`
    to make the change for you:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The advantages of using `text-transform` are twofold. First, you need to write
    only a single rule to make this change, rather than changing the `<h1>` itself.
    Second, if you decide later to switch from all capitals back to initial capitals,
    the change is even easier:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Remember that `capitalize` is a simple letter substitution at the beginning
    of each “word.” CSS doesn’t check for grammar, so common headline-capitalization
    conventions, such as leaving articles (*a*, *an*, *the*) all lowercase, won’t
    be enforced.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Different languages have different rules for which letters should be capitalized.
    The `text-transform` property takes into account language-specific case mappings.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The `full-width` option forces the writing of a character inside a square. Most
    characters you can type on a keyboard come in both normal width and full width,
    with different Unicode code points. The full-width version is used when `full-width`
    is set and supported to mix them smoothly with Asian ideographic characters, allowing
    ideograms and Latin scripts to be aligned.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Generally used with `<ruby>` annotation text, `full-size-kana` converts all
    small Kana characters to the equivalent full-size Kana, to compensate for legibility
    issues at the small font sizes typically used in Ruby.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Text Decoration
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next we come to the topic of text decorations, and how we can affect them with
    various properties. The simplest text decoration, and the one that can be controlled
    the most, is an underline. CSS also supports overlines, line-throughs, and even
    the wavy underlines you see in word processing programs to flag errors of spelling
    or grammar.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the various individual properties, and then tie it all up with
    a shorthand property, `text-decoration`, that covers them all.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Line Placement
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the property `text-decoration-line`, you can set the location of one or
    more line decorations on a run of text. The most familiar decoration may be underlining,
    thanks to all the hyperlinks out there, but CSS has three possible visible decoration
    line values (plus an unsupported fourth that wouldn’t draw a line at all even
    if it *was* supported).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The values are relatively self-documenting: `underline` places a line under
    the text, where *under* means “below the text in the block direction.” The `overline`
    value is the mirror image, putting the line above the text in the block direction.
    The `line-through` value draws a line through the middle of the text.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what these decorations look like in practice. The following code
    is illustrated in [Figure 15-24](#various_kinds_of_text_decoration):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![css5 1524](assets/css5_1524.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 15-24\. Various kinds of text decoration
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The value `none` turns off any decoration that might otherwise have been applied
    to an element. For example, links are usually underlined by default. If you want
    to suppress the underlining of hyperlinks, you can use the following CSS rule
    to do so:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you explicitly turn off link underlining with this sort of rule, the only
    visual difference between the anchors and normal text will be their color (at
    least by default, though there’s no ironclad guarantee that there will be a difference
    in their colors). Relying on color alone as the difference between regular text
    and links within that text is not enough to differentiate links from the rest
    of the text, negatively impacting user experience and making your content inaccessible
    to many users.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bear in mind that many users will be annoyed when they realize you’ve turned
    off link underlining, especially within blocks of text. If your links aren’t underlined,
    users will have a hard time finding hyperlinks in your documents, and finding
    them can be next to impossible for users with one form or another of color blindness.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: That’s really all there is to `text-decoration-line`. The more veteran among
    you may recognize this is what `text-decoration` itself used to do, but times
    have moved on and there’s much, much more we can do with decorations besides just
    place them, so these values were shifted to `text-decoration-line`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Color
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the color of a text decoration will match the color of the text.
    If you need to change that, `text-decoration-color` is here to help.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any valid color value for `text-decoration-color`, including the
    keyword `currentcolor` (which is the default). Suppose you want to make it clear
    that stricken text really is stricken. That would go something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Thus, not only will the elements shown get a line-through decoration, but the
    line will also be colored red. The text itself will not be red unless you change
    that as well by using the `color` property.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember to keep the color contrast between decorations and the base text sufficiently
    high to remain accessible. It’s also generally a bad idea to use color alone to
    convey meaning, as in “check the links with red underlines for more information!”
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Thickness
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the property `text-decoration-thickness`, you can change the stroke thickness
    of a text decoration to something beefier, or possibly less beefy, than usual.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplying a length value sets the thickness of the decoration to that length;
    thus, `text-decoration-thickness: 3px` sets the decoration to be 3 pixels thick,
    no matter how big or small the text itself might be. A better approach is generally
    to use an em-based value or jump straight to using a percentage value, since percentages
    are calculated with respect to the value of `1em` for the element. Thus, `text-decoration-thickness:
    10%` would yield a decoration thickness of 1.6 pixels in a font whose computed
    font size is 16 pixels, but 4 pixels for a 40-pixel font size. The following code
    shows a few examples, which are illustrated in [Figure 15-25](#various_decoration_thicknesses):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![css5 1525](assets/css5_1525.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: Figure 15-25\. Various decoration thicknesses
  id: totrans-257
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The keyword `from-font` is interesting because it allows the browser to consult
    the font file to see whether it defines a preferred decoration thickness; if it
    does, the browser uses that thickness. If the font file doesn’t recommend a thickness,
    the browser falls back to the `auto` behavior and picks whatever thickness it
    thinks appropriate, using inscrutable reasoning known only to itself.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Setting Text Decoration Style
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, we’ve shown a lot of straight, single lines. If you’re yearning for
    something beyond that hidebound approach, `text-decoration-style` provides alternatives.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact result will depend on the value you pick and the browser you use
    to view the results, but the renderings of these decoration styles should be at
    least similar to those shown in [Figure 15-26](#various_decoration_styles), which
    is the output of the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![css5 1526](assets/css5_1526.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Figure 15-26\. Various decoration styles
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We increased the decoration thickness for [Figure 15-26](#various_decoration_styles)
    in order to improve legiblility; the default sizing can make some of the more
    complex decorations, like `dotted`, difficult to see.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Using the Text Decoration Shorthand Property
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you just want to set a text decoration’s position, color, thickness, and
    style in one handy declaration, `text-decoration` is the way to go.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `text-decoration` shorthand property, you can bring everything into
    one place, like so:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Be careful, though: if you have two different decorations matched to the same
    element, the value of the rule that wins out will completely replace the value
    of the loser. Consider the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Given these rules, any `<h2>` element with a class of `stricken` will have only
    a wavy line-through decoration. The doubled underline and overline decorations
    are lost, since shorthand values replace one another instead of accumulating.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that because of the way the decoration properties work, you can set
    the color and style only once per element, even if you have multiple decorations.
    For example, the following is valid, setting both the under- and overlines to
    be green and dotted:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you instead want the overline to be a different color than the underline,
    or set each to have its own style, you’d need to apply each to a separate element,
    something like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Offsetting Underlines
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Along with all the `text-decoration` properties, a related property allows
    you to change the distance between an underline (and *only* an underline) and
    the text that the underline decorates: `text-underline-offset`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wish that, say, underlines on hyperlinks were a little farther away
    from the text’s baseline, so that they’re a little more obvious to the user. Setting
    a length value like `3px` will put the underline 3 pixels below the text’s baseline.
    See [Figure 15-27](#various_underline_offsets) for the results of the following
    CSS:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![css5 1527](assets/css5_1527.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: Figure 15-27\. Various underline offsets
  id: totrans-283
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As illustrated in [Figure 15-27](#various_underline_offsets), the value defines
    an offset from the text’s baseline, either positive (downward along the block
    axis) or negative (upward along the block axis).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `text-decoration-thickness`, percentage values for `text-underline-offset`
    are calculated with respect to the value of `1em` for the element. Thus, `text-underline-offset:
    10%` would cause an offset of 1.6 pixels in a font whose computed font size is
    16 pixels.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, only Firefox supports percentage values for `text-underline-offset`,
    which is odd given that percentage values are a percent of 1 em in the element’s
    font. The workaround is to use em length values, such as 0.1em for 10%.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Skipping Ink
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An unaddressed aspect of the past few sections has been: how exactly do browsers
    draw decorations over text, and more precisely, decide when to “skip over” parts
    of the text? This is known as *skipping ink*, and the approach a browser takes
    can be altered with the property `text-decoration-skip-ink`.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: When ink skipping is turned on, the decoration is interrupted wherever it would
    cross over the shapes of the text. Usually, this means a small gap between the
    decoration and the text glyphs. See [Figure 15-28](#ink-skipping_approaches) for
    a close-up illustration of the differences in ink-skipping approaches.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1528](assets/css5_1528.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Figure 15-28\. Ink-skipping approaches
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The three values are defined as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`auto` (the default)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The browser *may* interrupt under- and overlines where the line would cross
    the text glyphs, with a little space between the line and the glyphs. Furthermore,
    browsers *should* consider the glyphs used for the text, since some glyphs may
    call for ink skipping while others may not.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '`all`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Browsers *must* interrupt under- and overlines where the line would cross the
    text glyphs, with a little space between the line and the glyphs. However, as
    of mid-2022, only Firefox supports this value.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`none`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The browser *must not* interrupt under- and overlines where the line would cross
    the text glyphs, but instead draw a continuous line even though it may be drawn
    over parts of the text glyphs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 15-28](#ink-skipping_approaches), `auto` can sometimes mean
    differences depending on the language, font, or based on other factors. You’re
    really just telling the browser to do whatever it thinks is best.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-301
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While this property’s name begins with the label `text-decoration-`, it is *not*
    a property covered by the `text-decoration` shorthand property. That’s why it’s
    being discussed here, after the shorthand, and not before.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Weird Decorations
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s look into the unusual side of `text-decoration`. The first oddity
    is that `text-decoration` is *not* inherited. No inheritance implies that any
    decoration lines drawn with the text—whether under, over, or through it—will always
    be the same color. This is true even if the descendant elements are a different
    color, as depicted in [Figure 15-29](#color_consistency_in_underlines):'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![css5 1529](assets/css5_1529.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: Figure 15-29\. Color consistency in underlines
  id: totrans-308
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Why is this so? Because the value of `text-decoration` is not inherited, the
    `<strong>` element assumes a default value of `none`. Therefore, the `<strong>`
    element has *no* underline. Now, there is very clearly a line under the `<strong>`
    element, so it seems silly to say that it has none. Nevertheless, it doesn’t.
    What you see under the `<strong>` element is the paragraph’s underline, which
    is effectively “spanning” the `<strong>` element. You can see it more clearly
    if you alter the styles for the boldfaced element, like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The result is identical to the one shown in [Figure 15-29](#color_consistency_in_underlines),
    since all you’ve done is to explicitly declare what was already the case. In other
    words, there is no way to “turn off” the decoration generated by a parent element.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a way to change the color of a decoration without violating the specification.
    As you’ll recall, setting a text decoration on an element means that the entire
    element has the same color decoration, even if child elements have different colors.
    To match the decoration color with an element, you must explicitly declare its
    decoration, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In [Figure 15-30](#overcoming_the_default_behavior_of_under), the `<strong>`
    element is set to be gray and to have an underline. The gray underline visually
    “overwrites” the parent’s black underline, so the decoration’s color matches the
    color of the `<strong>` element. The black underline is still there; the gray
    underline is just hiding it. If you move the gray underline with `text-underline-offset`
    or make the parent’s `text-decoration-thickness` wider than its child, both underlines
    will be visible.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1530](assets/css5_1530.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
- en: Figure 15-30\. Overcoming the default behavior of underlines
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When `text-decoration` is combined with `vertical-align`, even stranger things
    can happen. [Figure 15-31](#correct_comma_although_strange_comma_dec) shows one
    of these oddities. Since the `<sup>` element has no decoration of its own, but
    it is elevated within an overlined element, the overline should cut through the
    middle of the `<sup>` element:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![css5 1531](assets/css5_1531.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Figure 15-31\. Correct, although strange, decorative behavior
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But not all browsers do this. As of mid-2022, Chrome pushes the overline up
    so it is drawn across the top of the superscript, whereas others do not.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Text Rendering
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recent addition to CSS is `text-rendering`, which is actually an SVG property
    that’s treated as CSS by supporting user agents. It lets you indicate what the
    user agent should prioritize when displaying text.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The values `optimizeSpeed` and `optimizeLegibility` indicate that drawing speed
    should be favored over the use of legibility features like kerning and ligatures
    (for `optimizeSpeed`) or that such legibility features should be used even if
    that slows text rendering (for `optimizeLegibility`).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The precise legibility features that are used with `optimizeLegibility` are
    not explicitly defined, and the text rendering often depends on the operating
    system on which the user agent is running, so the exact results may vary. [Figure 15-32](#optimized_legibility)
    shows text optimized for speed and then optimized for legibility.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1532](assets/css5_1532.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: Figure 15-32\. Different optimizations
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see in [Figure 15-32](#optimized_legibility), the differences between
    the two optimizations are objectively rather small, but they can have a noticeable
    impact on readability.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some user agents will always optimize for legibility, even when optimizing for
    speed. This is likely an effect of rendering speeds having gotten so fast in the
    past few years.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The value `geometricPrecision`, on the other hand, directs the user agent to
    draw the text as precisely as possible, such that it could be scaled up or down
    with no loss of fidelity. You might think that this is always the case, but not
    so. Some fonts change kerning or ligature effects at different text sizes, for
    example, providing more kerning space at smaller sizes and tightening up the kerning
    space as the size is increased. With `geometricPrecision`, those hints are ignored
    as the text size changes. If it helps, think of it as the user agent drawing the
    text as though all the text is a series of SVG paths, not font glyphs.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Even by the usual standard of web standards, the value `auto` is pretty vaguely
    defined in SVG:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The user agent shall make appropriate trade-offs to balance speed, legibility
    and geometric precision, but with legibility given more importance than speed
    and geometric precision.
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'That’s it: user agents get to do what they think is appropriate, leaning toward
    legibility.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Text Shadows
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you just really need your text to cast a shadow, like when text overlaps
    a multicolored background. That’s where `text-shadow` comes in. The syntax might
    look a little wacky at first, but it should become clear enough with just a little
    practice.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The default is to not have a drop shadow for text. Otherwise, you can define
    one or more shadows. Each shadow is defined by an optional color and three length
    values, the last of which is also optional.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The color sets the shadow’s color so it’s possible to define green, purple,
    or even white shadows. If the color is omitted, the shadow defaults to the color
    keyword `currentcolor`, making it the same color as the text itself.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Using `currentcolor` as a default color may seem counterintuitive, as you might
    think shadows are purely decorative, but shadows can be used to improve legibility.
    A small shadow can make very thin text more legible. Defaulting to `currentcolor`
    allows adding thickness via a shadow that will always match the color of the text.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: In addition to improving accessibility by making thin text thicker, shadows
    can be used to improve color contrast with a multicolored background. For example,
    if you have white text on a mostly dark black-and-white photo, adding a black
    shadow to the white text makes the edges of the white text visible even if the
    text is laid over white portions of the image.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two length values determine the offset distance of the shadow from
    the text; the first is the horizontal offset, and the second is the vertical offset.
    To define a solid, unblurred green shadow offset 5 pixels to the right and half
    an em down from the text, as shown in [Figure 15-33](#simple_shadows), you could
    write either of the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Negative lengths cause the shadow to be offset to the left and upward from
    the original text. The following, also shown in [Figure 15-33](#simple_shadows),
    places a light-blue shadow 5 pixels to the left and half an em above the text:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![css5 1533](assets/css5_1533.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: Figure 15-33\. Simple shadows
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While the offset may make the text take more visual space, shadows have no effect
    on line height and therefore no impact on the box model.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional third length value defines a blur radius for the shadow. The *blur
    radius* is defined as the distance from the shadow’s outline to the edge of the
    blurring effect. A radius of 2 pixels would result in blurring that fills the
    space between the shadow’s outline and the edge of the blurring. The exact blurring
    method is not defined, so different user agents might employ different effects.
    As an example, the following styles are rendered as shown in [Figure 15-34](#dropping_shadows_all_over):'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![css5 1534](assets/css5_1534.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: Figure 15-34\. Dropping shadows all over
  id: totrans-353
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  id: totrans-354
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Large numbers of text shadows, or text shadows with very large blur values,
    can create performance slowdowns, particularly when animated in low-power and
    CPU-constrained situations such as mobile devices. Test thoroughly before deploying
    public designs that use text shadows.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Text Emphasis
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to call out text is by adding emphasis marks to each character.
    This is more common in ideographic languages like Chinese or Mongolian, but these
    marks can be added to any language’s text with CSS. CSS has three text-emphasis
    properties similar to those for text decorations, and then a shorthand that conflates
    two of them.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Setting Emphasis Style
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important of the three properties sets the type of emphasis mark, allowing
    you to pick from a list of common types or supply your own mark as a text string.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, text has no emphasis marks, or `none`. Alternatively, emphasis
    marks can be one of five shapes: `dot`, `circle`, `double-circle`, `triangle`,
    or `sesame`. Those shapes can be set as `filled`, which is the default; or `open`,
    which renders them as unfilled outlines. These are summarized in [Table 15-1](#predefined_emphasis_marks),
    and examples are shown in [Figure 15-35](#various_emphasis_marks).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. The predefined emphasis marks
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '| Shape | `filled` | `open` |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| Sesame | ![](assets/sesame_filled.png) (U+FE45) | ![](assets/sesame_open.png)
    (U+FE46) |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| Dot | • (U+2022) | ◦ (U+25E6) |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| Circle | ● (U+25CF) | ○ (U+25CB) |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| Double-circle | ◉ (U+25C9) | ◎ (U+25CE) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| Triangle | ▲ (U+25B2) | △ (U+25B3) |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: The sesame is the most common mark used in vertical writing modes; the circle
    is the usual default in horizontal writing modes.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: If the emphasis marks will not fit into the current text line’s height, they
    will cause the height of that line of text to be increased until they fit without
    overlapping other lines. Unlike text decorations and text shadows, text emphasis
    marks *do* affect the line height.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'If none of the predefined marks work in your specific situation, you can supply
    your own character as a string (a single character in single or double quotes).
    However, be careful: if the string is more than a single character, it may be
    reduced to the first character in the string by the browser. Thus, `text-emphasis-style:
    ''cool''` may result in the browser displaying only the `c` as a mark, as shown
    in [Figure 15-35](#various_emphasis_marks). Furthermore, the string symbols may
    or may not be rotated to match writing direction in vertical languages.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of setting emphasis marks:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: A key difference between text emphasis and text decoration is that unlike decoration,
    emphasis is inherited. In other words, if you set a style of `filled sesame` on
    a paragraph, and that paragraph has child elements like links, those child elements
    will inherit the `filled sesame` value.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that every glyph (character or other symbol) gets its
    own mark, and these marks are centered on the glyph. Thus, in proportional fonts
    like those seen in [Figure 15-35](#various_emphasis_marks), the marks will have
    different separations between them depending on which two glyphs are next to each
    other.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1535](assets/css5_1535.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: Figure 15-35\. Various emphasis marks
  id: totrans-377
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The CSS specification recommends that emphasis marks be half the size of the
    text’s font size, as if they were given `font-size: 50%`. They should otherwise
    use the same text styles as the text; thus, if the text is boldfaced, the emphasis
    marks should be as well. They should also use the text’s color, unless overridden
    with the next property we’ll cover.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Changing Emphasis Color
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you wish to have emphasis marks be a different color than the text they’re
    marking, `text-emphasis-color` is here for you.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value, as is often the case with color-related properties, is `currentcolor`.
    That ensures that emphasis marks will match the color of the text by default.
    To change it, you can do things like the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Placing Emphasis Marks
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thus far, we’ve shown emphasis marks in specific positions: above each glyph
    in horizontal text, and to the right of each glyph in vertical text. These are
    the default CSS values, but not always the preferred placement. The `text-emphasis-position`
    property allows you to change where marks are placed.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The values `over` and `under` are applied only when the typographic mode is
    horizontal. Similarly, `right` and `left` are used only when the typographic mode
    is vertical.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be important in some Eastern languages. For example, Chinese, Japanese,
    Korean, and Mongolian all prefer to have marks to the right when the text is written
    vertically. They diverge on horizontal text: Chinese prefers marks below the text,
    and the rest prefer above the text, when it’s horizontal. Thus you might write
    something like this in a stylesheet:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This would override the default `over right` when the text is marked as being
    Chinese, applying `under right` instead.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Using the text-emphasis Shorthand
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A shorthand option exists for the `text-emphasis` properties, but it brings
    together only style and color.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The reason `text-emphasis-position` is not included in the `text-emphasis` shorthand
    is so that it can (indeed must) be inherited separately. Therefore, the style
    and color of the marks can be changed via `text-emphasis` without overriding the
    position in the process.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, each character or ideogram or other glyph—what CSS calls
    a *typographic character unit*—gets its own emphasis mark. That is roughly correct,
    but exceptions occur. The following character units do *not* get emphasis marks:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Word separators such as spaces, or any other Unicode separator character
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation characters, such as commas, full stops, and parentheses
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode symbols corresponding to control codes, or any unassigned characters
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Text Drawing Order
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Browsers are supposed to use a specific order to draw the text decorations,
    shadows, and emphasis marks we’ve discussed previously, along with the text itself.
    These are drawn in the following order, from bottommost (furthest away from the
    user) to topmost (closest to the user):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Shadows (`text-shadow`)
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underlines (`text-decoration`)
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overlines (`text-decoration`)
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual text
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Emphasis marks (`text-emphasis`)
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Line-through (`text-decoration`)
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, the drop shadows of the text are placed behind everything else. Underlines
    and overlines go behind the text. Emphasis marks and line-throughs go on top of
    the text. Note that if you have top text-emphasis marks and an overline, the emphasis
    marks will be drawn on top of the overline, obfuscating the overline where they
    overlap.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered a variety of ways to style, decorate, and otherwise enhance
    the text, let’s talk about the property `white-space`, which affects the user
    agent’s handling of space, newline, and tab characters within the document source.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `white-space` property, you can affect how a browser treats the
    whitespace between words and lines of text. To a certain extent, default HTML
    handling already does this: it collapses any whitespace down to a single space.
    So given the following markup, the rendering in a web browser would show only
    one space between each word and ignore the line feed in the elements:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can explicitly set this default behavior with the following declaration:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This rule tells the browser to do as browsers have always done: discard extra
    whitespace. Given this value, line-feed characters (carriage returns) are converted
    into spaces, and any sequence of more than one space in a row is converted to
    a single space.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you set `white-space` to `pre`, however, the whitespace in an affected
    element is treated as though the elements were HTML `<pre>` elements; whitespace
    is *not* ignored, as shown in [Figure 15-36](#honoring_the_spaces_in_markup):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![css5 1536](assets/css5_1536.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
- en: Figure 15-36\. Honoring the spaces in markup
  id: totrans-416
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With a `white-space` value of `pre`, the browser will pay attention to extra
    spaces and even carriage returns. In this respect, any element can be made to
    act like a `<pre>` element.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite value is `nowrap`, which prevents text from wrapping within an
    element, except wherever you use a `<br>` element. When text can’t wrap and it
    gets too wide for its container, a horizontal scrollbar will appear by default
    (this can be changed using the `overflow` property). The effects of the following
    markup are shown in [Figure 15-37](#suppressing_line_wrapping_with_the_white):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![css5 1537](assets/css5_1537.png)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
- en: Figure 15-37\. Suppressing line wrapping with the `white-space` property
  id: totrans-421
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If an element is set to `pre-wrap`, text within that element has whitespace
    sequences preserved, but text lines are wrapped normally. With this value, generated
    linebreaks as well as those found in the source markup are both honored.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: The `pre-line` value is the opposite of `pre-wrap` and causes whitespace sequences
    to collapse as in normal text but honors new lines.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: The `break-spaces` value is similar to `pre-wrap`, except that all whitespace
    is preserved, even at the end of the line, with a line-break opportunity after
    each whitespace character. These spaces take up space and do not hang, and thus
    affect the box’s intrinsic sizes (min-content size and max-content size).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-2](#white-space_properties) summarizes the behaviors of the various
    `white-space` properties.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-2\. `white-space` properties
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Whitespace | Line feeds | Auto line wrapping | Trailing whitespace
    |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
- en: '| `pre-line` | Collapsed | Honored | Allowed | Removed |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
- en: '| `normal` | Collapsed | Ignored | Allowed | Removed |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
- en: '| `nowrap` | Collapsed | Ignored | Prevented | Removed |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
- en: '| `pre` | Preserved | Honored | Prevented | Preserved |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
- en: '| `pre-wrap` | Preserved | Honored | Allowed | Hanging |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
- en: '| `break-spaces` | Preserved | Honored | Allowed | Wrap |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: 'Consider the following markup, which has line-feed (e.g., return) characters
    to break lines, plus the end of each line has several extra space characters that
    aren’t visible in the markup. The results are illustrated in [Figure 15-38](#three_different_ways_to_handle_whitespace):'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![css5 1538](assets/css5_1538.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
- en: Figure 15-38\. Three ways to handle whitespace
  id: totrans-438
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the third paragraph has a blank line between the first and second
    lines of text. This is because a line wrap was performed between two adjacent
    blank spaces at the end of the line in the source markup. This didn’t happen for
    `pre-wrap` or `pre-line`, because those `white-space` values don’t allow hanging
    space to create line-wrap opportunities. The `break-spaces` value does.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace impacts several properties, including `tab-size`, which has no effect
    when the `white-space` property is set to a value in which whitespace is not maintained;
    and `overflow-wrap`, which has an effect only when `white-space` allows wrapping.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Setting Tab Sizes
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since whitespace is preserved in some values of `white-space`, it stands to
    reason that tabs (i.e., Unicode code point 0009) will be displayed as, well, tabs.
    But how many spaces should each tab equal? That’s where `tab-size` comes in.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when whitespace is preserved, as with `white-space` values of `pre`,
    `pre-wrap`, and `break-spaces`, any tab character will be treated the same as
    eight spaces in a row, including any effects from `letter-spacing` and `word-spacing`.
    You can alter that by using a different integer value. Thus, `tab-size: 4` will
    cause each tab to be rendered as if it were four spaces in a row. Negative values
    are not allowed for `tab-size`.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'If a length value is supplied, each tab is rendered using that length. For
    example, `tab-size: 10px` will cause a sequence of three tabs to be rendered as
    30 pixels of whitespace. Some effects of `tab-size` are illustrated in [Figure 15-39](#differing_tab_lengths).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1539](assets/css5_1539.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
- en: Figure 15-39\. Differing tab lengths
  id: totrans-446
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that `tab-size` is effectively ignored when the value of `white-space`
    causes whitespace to be collapsed (see [Table 15-2](#white-space_properties)).
    The value will still be computed in such cases, but there will be no visible effect
    no matter how many tabs appear in the source.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping and Hyphenation
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling whitespace is all well and good, but it’s a lot more common to want
    to influence the way the visible characters are handled when it comes to line
    wrapping. A few properties can influence where line wrapping is allowed, as well
    as enable hyphenation support.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Hyphenation
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hyphens can be very useful when displaying long words and short line lengths,
    such as blog posts on mobile devices and portions of *The Economist*. Authors
    can always insert their own hyphenation hints by using the Unicode character *U+00AD
    SOFT HYPHEN* (or, in HTML, `&shy;`), but CSS also offers a way to enable hyphenation
    without littering up the document with hints.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: With the default value of `manual`, hyphens are inserted only where manually
    inserted hyphenation markers occur in the document, such as U+00AD or `&shy;`.
    Otherwise, no hyphenation occurs. The value `none`, on the other hand, suppresses
    any hyphenation, even if manual break markers are present; thus, U+00AD and `&shy;`
    are ignored.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-453
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `<wbr>` element does not introduce a hyphen at the line-break point. To
    make a hyphen appear only at the end of a line, use the soft hyphen character
    entity (`&shy;`) instead.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: 'The far more interesting (and potentially inconsistent) value is `auto`, which
    permits the browser to insert hyphens and break words at “appropriate” places
    inside words, even where no manually inserted hyphenation breaks exist. But what
    constitutes a *word*? And, under what circumstances is it appropriate to hyphenate
    a word? Both are language dependent. User agents are supposed to prefer manually
    inserted hyphen breaks to automatically determined breaks, but there are no guarantees.
    An illustration of hyphenation, or the suppression thereof, in the following example
    is shown in [Figure 15-40](#hyphenation_results):'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![css5 1540](assets/css5_1540.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
- en: Figure 15-40\. Hyphenation results
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because hyphenation is language dependent, and because the CSS specifications
    do not define precise (or even vague) rules for user agents, hyphenation may differ
    by browser.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do choose to hyphenate, be careful about the elements to which you apply
    the hyphenation. The `hyphens` property is inherited, so declaring `body {hyphens:
    auto;}` will apply hyphenation to everything in your document—including text areas,
    code samples, block quotes, and so on. Blocking automatic hyphenation at the level
    of those elements is probably a good idea, using rules that are something like
    this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It’s usually a good idea to suppress hyphenation in code samples and code blocks,
    especially in languages that use hyphens in things like property and value names.
    (Ahem.) Similar logic holds for keyboard input text—you likely don’t want a stray
    dash getting into your Unix command-line examples! And so on down the line. If
    you decide that you want to hyphenate some of these elements, just remove them
    from the selector.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-464
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is strongly advised to set the `lang` attribute on HTML elements to enable
    hyphenation support and improve accessibility. As of mid-2022, `hyphens` is supported
    in Firefox for 30+ languages, Safari supports many European languages, but Chrome-related
    browsers support only English.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Hyphens can be suppressed by the effects of other properties. For example, `word-break`
    affects the way soft wrapping of text is calculated in various languages, determining
    whether line breaks appear where text would otherwise overflow its content box.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Word Breaking
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a run of text is too long to fit into a single line, it is *soft wrapped*.
    This is in contrast to *hard wraps*, which include line-feed characters and `<br>`
    elements. Where the text is soft wrapped is determined by the user agent, but
    `word-break` lets authors influence that decision making.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `normal` means that text should be wrapped as it always
    has been. In practical terms, this means that text is broken between words, though
    the definition of a word varies by language. In Latin-derived languages like English,
    this is almost always a space between letter sequences (e.g., words) or at hyphens.
    In ideographic languages like Japanese, each symbol can be a complete word, so
    breaks can occur between any two symbols. In other ideographic languages, though,
    the soft-wrap points may be limited to appear between sequences of symbols that
    are not space separated. Again, that’s all by default and is the way browsers
    have handled text for years.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: If you apply the value `break-all`, soft wrapping can (and will) occur between
    any two characters, even if they are in the middle of a word. With this value,
    no hyphens are shown, even if the soft wrapping occurs at a hyphenation point
    (see [“Hyphenation”](#hyphenation)). Note that values of the `line-break` property
    (described next) can affect the behavior of `break-all` in ideographic text.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'The `keep-all` value, on the other hand, suppresses soft wrapping between characters,
    even in ideographic languages where each symbol is a word. Thus, in Japanese,
    a sequence of symbols with no whitespace will not be soft wrapped, even if this
    means the text line will exceed the length of its element. (This behavior is similar
    to `white-space: pre`.)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-41](#altering_word_breaking_behavior) shows a few examples of `word-break`
    values, and [Table 15-3](#word-breaking_behavior) summarizes the effects of each
    value.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1541](assets/css5_1541.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
- en: Figure 15-41\. Altering word-breaking behavior
  id: totrans-474
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Table 15-3\. Word-breaking behavior
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Non-CJK | CJK | Hyphenation permitted |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
- en: '| `normal` | As usual | As usual | Yes |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
- en: '| `break-all` | After any character | After any character | No |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
- en: '| `keep-all` | As usual | Around sequences | Yes |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
- en: 'As noted previously, the value `break-word` has been deprecated, although it
    is supported by all known browsers as of mid-2022\. When used, it has the same
    effect as `{word-break: normal; overflow-wrap: anywhere;}`, even if `overflow-wrap`
    has a different value. (We’ll cover `overflow-wrap` in [“Wrapping Text”](#wrapping_text).)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Line Breaking
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your interests run to CJK text, then in addition to `word-break`, you will
    also want to get to know `line-break`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: As you just saw, `word-break` can affect the way lines of text are soft wrapped
    in CJK text. The `line-break` property also affects such soft wrapping, specifically
    how wrapping is handled around CJK-specific symbols and around non-CJK punctuation
    (such as exclamation points, hyphens, and ellipses) that appears in text declared
    to be CJK.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: In other words, `line-break` applies to certain CJK characters all the time,
    regardless of the content’s declared language. If you throw some CJK characters
    into a paragraph of English text, `line-break` will still apply to them, but not
    to anything else in the text. Conversely, if you declare content to be in a CJK
    language, `line-break` will continue to apply to those CJK characters *plus* a
    number of non-CJK characters within the CJK text. These include punctuation marks,
    currency symbols, and a few other symbols.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`line-break`始终适用于某些CJK字符，而不管内容声明的语言是什么。如果你在英文文本段落中加入一些CJK字符，`line-break`仍然会适用于它们，但不适用于文本中的其他任何内容。相反，如果声明内容为CJK语言，`line-break`将继续适用于该CJK文本中的这些CJK字符，*以及*CJK文本中的一些非CJK字符。这些包括标点符号、货币符号和其他一些符号。
- en: No authoritative list exists of which characters are affected and which are
    not, but [the specification](http://w3.org/TR/css3-text/#line-break) provides
    a list of recommended symbols and behaviors around those symbols.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 没有权威的字符受影响和不受影响的列表，但[规范](http://w3.org/TR/css3-text/#line-break)提供了一份推荐符号及其周围行为的列表。
- en: The default value `auto` allows user agents to soft wrap text as they like,
    and more importantly lets user agents vary line breaking based on the situation.
    For example, the user agent can use looser line-breaking rules for short lines
    of text and stricter rules for long lines. In effect, `auto` allows the user agent
    to switch among the `loose`, `normal`, and `strict` values as needed, possibly
    even on a line-by-line basis within a single element.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值`auto`允许用户代理根据需要自由换行文本，并且更重要的是让用户代理根据情况变化线路断开。例如，用户代理可以对短文本使用较松的换行规则，对长文本使用较严格的规则。实际上，`auto`允许用户代理在需要时在`loose`、`normal`和`strict`值之间切换，甚至可能在单个元素内逐行切换。
- en: 'You can perhaps infer that those other values have the following general meanings:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你可以推断出其他值有以下一般含义：
- en: '`loose`'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`loose`'
- en: This value imposes the “least restrictive” rules for wrapping text, and is meant
    for use when line lengths are short, such as in newspapers.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值施加了“最不限制性”的文本换行规则，适用于行长度较短的情况，例如报纸。
- en: '`normal`'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`normal`'
- en: This value imposes the “most common” rules for wrapping text. What exactly “most
    common” means is not precisely defined, though there is the aforementioned list
    of recommended behaviors.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值施加了“最常见”的文本换行规则。什么是“最常见”并没有明确定义，尽管有前面提到的推荐行为列表。
- en: '`strict`'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`strict`'
- en: This value imposes the “most stringent” rules for wrapping text. Again, this
    is not precisely defined.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值施加了“最严格”的文本换行规则。再次强调，这并没有明确定义。
- en: '`anywhere`'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`anywhere`'
- en: This value creates a line-breaking opportunity around every typographic unit,
    including whitespace and punctuation marks. A soft wrap can even happen in the
    middle of a word, and hyphenation is not applied in such circumstances.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值在每个排版单元周围创建一个换行机会，包括空格和标点符号。软换行甚至可以发生在一个单词的中间，并且在这种情况下不会应用连字符。
- en: Wrapping Text
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本换行
- en: After all that information about hyphenation and soft wrapping, what happens
    when text overflows its container anyway? That’s what `overflow-wrap` addresses.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了连字符和软换行的所有信息之后，如果文本仍然溢出其容器会发生什么？这就是`overflow-wrap`要解决的问题。
- en: Originally called `word-wrap`, the `overflow-wrap` property applies to inline
    elements, setting whether the browser should insert line breaks within otherwise
    unbreakable strings in order to prevent text from overflowing its line box. In
    contrast to `word-break`, `overflow-wrap` will create a break only if an entire
    word cannot be placed on its own line without overflowing.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 最初被称为`word-wrap`，`overflow-wrap`属性适用于内联元素，设置浏览器是否应插入换行符以防止文本溢出其行框。与`word-break`相反，`overflow-wrap`仅在整个单词无法单独放置在一行上而不溢出时才会创建换行。
- en: This property is less straightforward than it first appears, because its primary
    effect is to change how word wrapping and minimum-content sizing (which we haven’t
    even had a chance to discuss yet) interact in trying to avoid overflow at the
    ends of text lines.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性不像它表面看起来的那么直接，因为它的主要效果是改变单词换行和最小内容大小（我们甚至还没有讨论过）在尝试避免文本行末溢出时的交互作用。
- en: Note
  id: totrans-501
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `overflow-wrap` property can operate only if the value of `white-space`
    allows line wrapping. If it does not (e.g., with the value `pre`), `overflow-wrap`
    has no effect.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`white-space`的值允许换行时，`overflow-wrap`属性才能起作用。如果不允许（例如，值为`pre`），`overflow-wrap`就没有效果。
- en: If the default value of `normal` is in effect, wrapping happens as normal—between
    words or as directed by the language. If a word is longer than the width of the
    element containing it, the word will “spill out” of the element box, just as on
    the classic CSS IS AWESOME coffee mug. (Google it if you haven’t seen it before.
    It’s worth the chuckle.)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: If the `break-word` value is applied, wrapping can happen in the middle of words,
    with no hyphen placed at the site of the wrapping, but this will happen so that
    line lengths will be as wide as the element’s width. In other words, if the `width`
    property of the element is given the value `min-content`, the “minimum content”
    calculations will assume that content strings must be as long as possible.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, when `anywhere` is set, the “minimum content” calculations will
    take line-wrapping opportunities into account. This means, in effect, that the
    minimum-content width will be the width of the widest character in the element’s
    content. Only when two skinny characters are next to each other will they have
    a chance to be on the same line together, and in a monospace font every line of
    text will be a single character. [Figure 15-42](#overflow_wrapping) illustrates
    the difference between these three values.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1542](assets/css5_1542.png)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-42\. Overflow wrapping for `width: min-content`'
  id: totrans-507
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the value of `width` is something other than `min-content`, then `break-word`
    and `anywhere` will have the same results. Really, the only difference between
    the two values is that with `anywhere`, soft-wrap opportunities introduced by
    the word break are considered when calculating min-content intrinsic sizes. With
    `break-word`, they are not considered.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'While `overflow-wrap: break-word` may appear very similar to `word-break: break-all`,
    they are not the same. To see why, compare the second box in [Figure 15-42](#overflow_wrapping)
    to the top-middle box in [Figure 15-41](#altering_word_breaking_behavior). As
    it shows, `overflow-wrap` kicks in only if content actually overflows; thus, when
    there is an opportunity to use whitespace in the source to wrap lines, `overflow-wrap`
    will take it. By contrast, `word-break: break-all` will cause wrapping when content
    reaches the wrapping edge, regardless of any whitespace that comes earlier in
    the line.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Once upon a time there was a property called `word-wrap` that did exactly what
    `overflow-wrap` does. The two are so identical that the specification explicitly
    states that user agents “must treat `word-wrap` as an alternate name for the `overflow-wrap`
    property, as if it were a shorthand of `overflow-wrap`.”
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Writing Modes
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we discussed inline direction and introduced the topic of reading direction.
    You’ve already seen numerous benefits of including the `lang` attribute in your
    HTML, from being able to style based on language selectors, to allowing the user
    agent to hyphenate. Generally, you should let the user agent handle the direction
    of text based on the language attribute, but CSS does provide properties for the
    rare occasions when an override is necessary.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Setting Writing Modes
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The property used for specifying one of five available writing modes is, of
    all things, `writing-mode`. This property sets the block-flow direction of the
    element, which determines how boxes are stacked together.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The default value, `horizontal-tb`, means “a horizontal inline direction, and
    a top-to-bottom block direction.” This covers all Western and some Middle Eastern
    languages, which may differ in the direction of their horizontal writing. The
    other two values offer a vertical inline direction, and either an RTL or LTR block
    direction.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: The `sideways-rl` and `sideways-lr` values take horizontal text and turn its
    flow “sideways,” with the direction the text runs either going right to left (for
    `sidewyas-rl`) or left to right (for `sideways-lr`). The difference between these
    values and the vertical values is that the text is turned whichever way is necessary
    to make the text read naturally.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-43](#writing_modes) illustrates all five values.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1543](assets/css5_1543.png)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
- en: Figure 15-43\. Writing modes
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how the lines are strung together in the two `vertical-` examples. If
    you tilt your head to the right, the text in `vertical-rl` is at least readable.
    The text in `vertical-lr`, on the other hand, is difficult to read because it
    appears to flow from bottom to top, at least when arranging English text. This
    is not a problem in languages that use `vertical-lr` flow, such as forms of Japanese.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: In vertical writing modes, the block direction is horizontal, which means vertical
    alignment of inline elements causes them to move horizontally. This is illustrated
    in [Figure 15-44](#writing_modes_vertical_align).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1544](assets/css5_1544.png)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
- en: Figure 15-44\. Writing modes and “vertical” alignment
  id: totrans-523
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All the super- and subscript elements cause horizontal shifts, both of themselves
    and the placement of the lines they occupy, even though the property used to move
    them is `vertical-align`. As described earlier, the vertical displacement is with
    respect to the line box, where the box’s baseline is defined as horizontal—even
    when it’s being drawn vertically.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Confused? It’s OK. Writing modes are likely to confuse you, because they’re
    such a different way of thinking *and* because old assumptions in the CSS specification
    clash with the new capabilities. If vertical writing modes had been supported
    from the outset, `vertical-align` would likely have a different name—`inline-align`
    or something like that. (Maybe one day that will happen.)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Changing Text Orientation
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve settled on a writing mode, you may decide you want to change the
    orientation of characters within those lines of text. You might want to do this
    for various reasons, not the least of which is using different writing systems
    that are commingled, such as Japanese text with English words or numbers mixed
    in. In these cases, `text-orientation` is the answer.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'The `text-orientation` property affects the way characters are oriented. What
    that means is best illustrated by the following styles, rendered in [Figure 15-45](#writing_modes_text_orientation):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![css5 1545](assets/css5_1545.png)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
- en: Figure 15-45\. Text orientation
  id: totrans-531
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Across the top of [Figure 15-45](#writing_modes_text_orientation) is a basically
    unstyled paragraph of mixed Japanese and English text. Below that are three copies
    of that paragraph, using the writing mode `vertical-lr`. In the first, `text-orientation:
    mixed` writes the horizontal-script characters (the English) sideways, and the
    vertical-script characters (the Japanese) upright. In the second, all characters
    are `upright`, including the English characters. In the third, all characters
    are `sideways`, including the Japanese characters.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-533
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of mid-2022, `sideways` is not supported by Chromium browsers.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Combining Characters
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only relevant to vertical writing modes, the `text-combine-upright` property
    enables displaying a subset of characters upright within vertical text. This can
    be useful when mixing languages or pieces of languages, such as embedding Arabic
    numerals in CJK text, but may have other applications.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, this property lets you say whether characters may sit next to each
    other horizontally while being part of a vertical line of text. Your choices are
    whether to allow this for all characters or for only a few numeric digits.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works: as a line of vertical text is laid out, the browser can
    consider whether the width of two characters, sitting next to each other, is less
    than or equal to the value of `1em` for the text. If so, they may be placed next
    to each other, effectively putting two characters into the space of one. If not,
    the first character is placed alone, and the process continues.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'As of mid-2022, this can lead to characters being very, very squished. For
    an example, consider the following markup and CSS:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'All of the paragraphs are written using `writing-mode: vertical-rl`, but some
    are set to `text-combine-upright: all`, and others are not. The last paragraph
    is not set to `all`, but the `<span>` elements within it have been. [Figure 15-46](#various_types_of_upright_combination)
    shows the result.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1546](assets/css5_1546.png)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
- en: Figure 15-46\. Various types of upright combination
  id: totrans-544
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Lest you think a bug is at work here, the results are consistent across browsers
    (as of mid-2022). The second and fourth columns have every single character, whether
    Chinese ideographs or Arabic numerals, squished horizontally to fit on a single
    line.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: A way around this is to break up the text with child elements, as shown in the
    fifth and sixth columns. In the first, numbers are surrounded with `<span>` elements,
    which break up the fitting process. This works as long as no run of text has too
    many characters; beyond two or three symbols, the text becomes progressively more
    difficult to comprehend.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'The sixth column shows a way to hack around the problem: apply `text-combine-upright:
    all` to only the `<span>` elements, which are already used to wrap the Arabic
    numerals, by giving each `<span>` a `class` value of `combine`. In that case,
    the `.combine` rule will apply only to the `<span>` elements, not all the text
    in the paragraph.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `digits` value is supposed to make possible without the need
    for all the extra markup. Theoretically, you could get the same result as that
    shown in the sixth column of [Figure 15-46](#various_types_of_upright_combination)
    by applying the following CSS to the paragraph that has no `<span>` elements in
    it:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Sadly, as of mid-2022, no browser supports this behavior, unless you count Internet
    Explorer 11 using the alternate property name `-ms-text-combine-horizontal`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Direction
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Harking back to the days of CSS2, a pair of properties could be used to affect
    the direction of text by changing the inline baseline direction: `direction` and
    `unicode-bidi`. These should generally not be used today, but are covered here
    in case you come across them in legacy code.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-553
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The CSS specification explicitly warns *against* using `direction` and `unicode-bidi`
    in CSS when applied to HTML documents. To quote: “Because HTML [user agents] can
    turn off CSS styling, we recommend…the HTML `dir` attribute and `<bdo>` element
    to ensure correct bidirectional layout in the absence of a style sheet.”'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: The `direction` property affects the writing direction of text in a block-level
    element, the direction of table-column layout, the direction in which content
    horizontally overflows its element box, and the position of the last line of a
    fully justified element. For inline elements, direction applies only if the property
    `unicode-bidi` is set to either `embed` or `bidi-override` (see the following
    description of `unicode-bidi`).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `ltr` is the default, it is expected that if a browser is displaying
    RTL text, the value will be changed to `rtl`. Thus, a browser might carry an internal
    rule stating something like the following:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The real rule would be longer and encompass all RTL languages, not just Arabic
    and Hebrew, but it illustrates the point.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: While CSS attempts to address writing direction, Unicode has a much more robust
    method for handling directionality. With the property `unicode-bidi`, CSS authors
    can take advantage of some of Unicode’s capabilities.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we’ll simply quote the value descriptions from the CSS 2.1 specification,
    which do a good job of capturing the essence of each value:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '`normal`'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The element does not open an additional level of embedding with respect to the
    bidirectional algorithm. For inline-level elements, implicit reordering works
    across element boundaries.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '`embed`'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'If the element is inline-level, this value opens an additional level of embedding
    with respect to the bidirectional algorithm. The direction of this embedding level
    is given by the `direction` property. Inside the element, reordering is done implicitly.
    This corresponds to adding a “left-to-right embedding” character (U+202A; for
    `direction: ltr`) or a “right-to-left embedding” character (U+202B; for `direction:
    rtl`) at the start of the element and a “pop directional formatting” character
    (U+202C) at the end of the element.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '`bidi-override`'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates an override for inline-level elements. For block-level elements,
    this creates an override for inline-level descendants not within another block.
    This means that, inside the element, reordering is strictly in sequence according
    to the `direction` property; the implicit part of the bidirectional algorithm
    is ignored. This corresponds to adding a “left-to-right override” character (U+202D;
    for `direction: ltr`) or “right-to-left override” character (U+202E; for `direction:
    rtl`) at the start of the element and a “pop directional formatting” character
    (U+202C) at the end of the element.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even without altering the font face, we have many ways to change the appearance
    of text. In addition to classic effects such as underlining, CSS enables you to
    draw lines over text or through it, change the amount of space between words and
    letters, indent the first line of a paragraph (or other block-level element),
    align text in various ways, exert influence over the hyphenation and line breaking
    of text, and much more. You can even alter the amount of space between lines of
    text. CSS also supports languages other than those that are written left to right,
    top to bottom. Given that so much of the web is text, the strength of these properties
    makes a great deal of sense.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
