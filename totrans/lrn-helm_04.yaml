- en: Chapter 4\. Building a Chart
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。构建一个图表
- en: Charts are at the heart of Helm. In addition to installing them into a Kubernetes
    cluster or managing the instances of charts you’ve installed, you can build new
    charts or alter existing ones. In the next three chapters we will cover a lot
    of details about charts including creating them, the elements inside them, templating
    Kubernetes manifests, testing charts, dependencies, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图表是Helm的核心。除了将它们安装到Kubernetes集群中或管理已安装的图表实例外，您还可以创建新图表或更改现有图表。在接下来的三章中，我们将详细介绍有关图表的许多细节，包括创建图表、图表内的元素、为Kubernetes清单编写模板、测试图表、依赖关系等。
- en: In this chapter you will learn how to create a new chart and learn about the
    many parts of a chart. This will include the use of several built-in commands
    that can help you in the chart development process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何创建一个新图表，并了解图表的许多部分。这将包括使用几个内置命令来帮助您进行图表开发过程。
- en: Charts are the packages Helm works with. They are conceptually similar to Debian
    packages used by APT or Formula used by Homebrew for macOS. The conceptual similarity
    is where the similarities end. Charts are designed to target Kubernetes as a platform
    that has its own unique style. At the heart of charts are templates to generate
    Kubernetes manifests that can be installed and managed in a cluster.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 图表是Helm处理的包。它们在概念上类似于APT用于Debian包或Homebrew用于macOS的Formula。但概念上的相似之处仅此而已。图表旨在针对具有其独特风格的平台Kubernetes。图表的核心是模板，用于生成可以在集群中安装和管理的Kubernetes清单。
- en: Before we dig into templates in [Chapter 5](ch05.xhtml#developing_templates),
    let’s start by creating a basic fully functional chart. To do that we will cover
    an example chart named *anvil*. Using that chart you will learn about using Helm
    to generate a chart, the structure of charts and files within them, packaging
    charts, and linting charts. Reference the online source for this chart at [*https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil*](https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论[第5章](ch05.xhtml#developing_templates)中的模板之前，让我们先创建一个基本的完全功能图表。为此，我们将涵盖一个名为*anvil*的示例图表。通过使用这个图表，您将了解如何使用Helm生成图表、图表及其内部文件的结构、打包图表以及检查图表的问题。有关此图表的在线来源，请参考[*https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil*](https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil)。
- en: The Chart Creation Command
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表创建命令
- en: Helm includes the `create` command to make it easy for you to create a chart
    of your own, and it’s a great way to get started. This command creates a new Nginx
    chart, with a name of your choice, following best practices for a chart layout.
    Since Kubernetes clusters can have different methods to expose an application,
    this chart makes the way Nginx is exposed to network traffic configurable so it
    can be exposed in a wide variety of clusters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Helm包括`create`命令，使您能够轻松创建自己的图表，这是一个很好的起点。该命令会创建一个新的Nginx图表，您可以自行命名，遵循图表布局的最佳实践。由于Kubernetes集群可以使用不同的方法来公开应用程序，因此该图表使得Nginx如何暴露给网络流量可配置，以便在各种集群中进行公开。
- en: The `create` command creates a chart for you, with all the required chart structure
    and files. These files are documented to help you understand what is needed, and
    the templates it provides showcase multiple Kubernetes manifests working together
    to deploy an application. In addition, you can install and test this chart right
    out of the box.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`命令会为您创建一个图表，并包含所有所需的图表结构和文件。这些文件被记录下来，帮助您了解所需内容，提供的模板展示了多个Kubernetes清单如何协同工作以部署应用程序。此外，您可以立即安装和测试此图表。'
- en: 'Throughout this chapter we will look at an example application named *anvil*.
    It is a simple application that will show you the structure of a chart and provide
    you the chance to alter a chart for a different application. To create the new
    chart, run the following command from a command prompt:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将看一个名为*anvil*的示例应用程序。这是一个简单的应用程序，将向您展示图表的结构，并为您提供改变不同应用程序的图表的机会。要创建新图表，请从命令提示符中运行以下命令：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a new chart as a subdirectory of your current directory with
    the name *anvil*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录的子目录下创建一个名为*anvil*的新图表。
- en: 'The new chart is a directory containing a number of files and folders. This
    does not include every file and folder—you will discover some more in the next
    couple chapters. These are the basic ones needed for a functioning chart:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 新图表是一个包含多个文件和文件夹的目录。这并不包括每个文件和文件夹——您将在接下来的几章中发现更多内容。这些是实现图表功能所需的基本文件。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO1-1)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_building_a_chart_CO1-1)'
- en: The *Chart.yaml* file contains metadata and some functionality controls for
    the chart.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chart.yaml* 文件包含图表的元数据和一些功能控制。'
- en: '[![2](Images/2.png)](#co_building_a_chart_CO1-2)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_building_a_chart_CO1-2)'
- en: Dependent charts can optionally be held in the *charts* directory. Chart dependencies
    are covered in [Chapter 6](ch06.xhtml#advanced_charts). For now this will be an
    empty directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖图表可以选择性地存放在*charts*目录中。图表依赖关系在[第 6 章](ch06.xhtml#advanced_charts)中介绍。目前这将是一个空目录。
- en: '[![3](Images/3.png)](#co_building_a_chart_CO1-3)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_building_a_chart_CO1-3)'
- en: Templates used to generate Kubernetes manifests are stored in the *templates*
    directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成 Kubernetes 清单的模板存储在*templates*目录中。
- en: '[![4](Images/4.png)](#co_building_a_chart_CO1-4)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_building_a_chart_CO1-4)'
- en: The *NOTES.txt* file is a special template. When a chart is installed, the *NOTES.txt*
    template is rendered and displayed rather than being installed into a cluster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*NOTES.txt* 文件是一个特殊的模板。安装图表时，会渲染并显示*NOTES.txt*模板，而不是将其安装到集群中。'
- en: '[![5](Images/5.png)](#co_building_a_chart_CO1-5)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_building_a_chart_CO1-5)'
- en: Templates can include tests that are not installed as part of the `install`
    or `upgrade` commands. This chart includes a test that is used by the `helm test`
    command. Testing is covered in [Chapter 6](ch06.xhtml#advanced_charts).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以包含测试，这些测试不会作为`install`或`upgrade`命令的一部分安装。此图表包含一个通过`helm test`命令使用的测试。有关测试的详细信息，请参阅[第 6
    章](ch06.xhtml#advanced_charts)。
- en: '[![6](Images/6.png)](#co_building_a_chart_CO1-6)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_building_a_chart_CO1-6)'
- en: Default values passed to the templates when Helm is rendering the manifests
    are in the *values.yaml* file. When you instantiate a chart, these values can
    be overridden.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 渲染清单时传递给模板的默认值存储在*values.yaml*文件中。在实例化图表时，可以覆盖这些值。
- en: 'You can install this newly created chart without any modifications by running
    the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令安装此新创建的图表，无需任何修改：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this command Helm will create an instance of the chart running
    in the cluster with the name *myapp*. It will install it using the currently configured
    connection and context you use for Kubernetes. Helm is using the same configuration
    you’re using when you use `kubectl`, the command-line application for Kubernetes.
    In that command the final argument of *anvil* is the directory where the chart
    is located.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时，Helm 将在集群中使用当前配置的连接和上下文创建一个名为*myapp*的图表实例。Helm 使用的配置与你使用`kubectl`命令行应用程序时的配置相同。在该命令中，*anvil*的最后一个参数是图表所在目录。
- en: 'The output from this command includes content generated by rendering the *NOTES.txt*
    template, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出包含通过渲染*NOTES.txt*模板生成的内容，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `NOTES` section contains information on connecting to the application. Depending
    on the values you pass into the chart when it is instantiated, this information
    can be very different. This chart can be configured to use a ClusterIP, NodePort,
    LoadBalancer, and Ingress to expose an application. By default, a ClusterIP is
    used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOTES` 部分包含有关连接到应用程序的信息。根据实例化图表时传递的值，此信息可能会有所不同。此图表可以配置为使用 ClusterIP、NodePort、LoadBalancer
    和 Ingress 公开应用程序。默认情况下使用 ClusterIP。'
- en: If you follow the directions in the notes you will see the default Nginx web
    page to show you it’s running, as shown in [Figure 4-1](#chapter_5_nginx).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按照备注中的说明进行操作，您将看到默认的 Nginx 网页，以展示它正在运行，如[图 4-1](#chapter_5_nginx)所示。
- en: '![Nginx](Images/lehe_0401.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Nginx](Images/lehe_0401.png)'
- en: Figure 4-1\. Default Nginx web page when you visit the running application
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 访问运行中应用程序时显示的默认 Nginx 网页
- en: 'The methods to expose the application are tied to built-in Kubernetes resource
    types rather than features of the application. That makes them portable to your
    custom applications. The methods to expose applications include:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 公开应用程序的方法与内置的 Kubernetes 资源类型相关，而不是应用程序的功能。这使它们可以轻松移植到您的自定义应用程序中。公开应用程序的方法包括：
- en: ClusterIP
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterIP
- en: A configuration option on the Kubernetes `Service` resource type that exposes
    the service on a cluster-level internal IP address.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes `Service` 资源类型的配置选项，用于在集群级内部 IP 地址上公开服务。
- en: NodePort
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: NodePort
- en: An alternative option for Kubernetes `Service` resources that exposes the service
    on a static port of each node. A ClusterIP is automatically created as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes `Service` 资源的替代选项，用于在每个节点的静态端口上公开服务。同时会自动创建 ClusterIP。
- en: LoadBalancer
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: LoadBalancer
- en: A Kubernetes `Service` configuration option that exposes an application externally
    using a load balancer provided by the hosting provider.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes `Service` 配置选项，使用主机提供商提供的负载均衡器在外部公开应用程序。
- en: Ingress
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress
- en: Ingress resources are additional resources to `Service`s that expose a service
    over HTTP and HTTPS. An Ingress Controller, such as ingress-nginx, is required
    for this to work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 资源是 `Service` 的附加资源，通过 HTTP 和 HTTPS 公开服务。要使其工作，需要一个 Ingress 控制器，比如 ingress-nginx。
- en: 'If you installed this chart into your cluster to test it, you can delete the
    instance from your cluster by running the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了这个图表到你的集群来测试它，你可以通过运行以下命令从你的集群中删除该实例：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When the chart is installed the image used for Nginx, by default, is the latest
    version of the image from the [Docker Official Images](https://oreil.ly/YghQP).
    If the Kubernetes cluster you are working with does not have access to *hub.docker.com*
    you won’t be able to install the image. You would need to set the image to one
    your cluster has access to.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当图表安装时，Nginx 使用的镜像默认是来自 [Docker Official Images](https://oreil.ly/YghQP) 的最新版本。如果你所使用的
    Kubernetes 集群无法访问 *hub.docker.com*，你将无法安装该镜像。你需要将镜像设置为你的集群可以访问的镜像。
- en: Now that a working chart has been scaffolded, let’s take a look at what’s inside
    and modify it for the Anvil application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一个可工作的图表已经被搭建好了，让我们来看看里面有什么，并修改为 Anvil 应用程序。
- en: The Chart.yaml File
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chart.yaml 文件
- en: Look inside the *anvil* directory and you’ll find a file named *Chart.yaml*.
    The *Chart.yaml* file tells Helm and other tools about your chart. Other tools
    include Kubeapps (an on-premise catalog and application installer), the Artifact
    Hub (a listing of cloud native artifacts), and many others.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *anvil* 目录中查看，你会找到一个名为 *Chart.yaml* 的文件。*Chart.yaml* 文件告诉 Helm 和其他工具有关你的图表的信息。其他工具包括
    Kubeapps（本地目录和应用程序安装程序）、Artifact Hub（云原生工件列表）等等。
- en: When you open the *Chart.yaml* file, you will see the contents shown in [Example 4-1](#chapter_5_generated_chart_yaml).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开 *Chart.yaml* 文件时，你将看到示例 [Example 4-1](#chapter_5_generated_chart_yaml)
    中显示的内容。
- en: Example 4-1\. The generated Chart.yaml file
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 生成的 Chart.yaml 文件
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO2-1)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_building_a_chart_CO2-1)'
- en: The `apiVersion` tells Helm what structure the chart is using. An `apiVerison`
    of `v2` is designed for Helm v3.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion` 告诉 Helm 图表使用的结构。`apiVersion` 的值为 `v2` 是为 Helm v3 设计的。'
- en: '[![2](Images/2.png)](#co_building_a_chart_CO2-2)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_building_a_chart_CO2-2)'
- en: The name is used to identify the chart in various places.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 名称用于在各个地方标识图表。
- en: '[![3](Images/3.png)](#co_building_a_chart_CO2-3)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_building_a_chart_CO2-3)'
- en: Charts can have many versions. Helm uses the version information to order and
    identify charts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图表可以有多个版本。Helm 使用版本信息来排序和识别图表。
- en: This *Chart.yaml* file contains numerous keys, of which only three are required.
    The `apiVersion` property tells Helm which version of a chart this is. Helm v3
    can work with charts whose `apiVersion` is `v1` or `v2`. `v1` charts are those
    designed to work with previous versions of Helm. If your charts are designed to
    work with Helm v3 or newer you should set this to `v2`. The value of `name` is
    typically used as part of the name for Kubernetes resources. This means names
    are limited to lowercase alphanumeric, `-`, and `.` characters and must start
    and end with an alphanumeric character. Names are typically lowercase alphanumeric
    characters. The final required key is `version`, containing the version of the
    chart. Versions are expected to follow Semantic Versioning, which was covered
    in [Chapter 2](ch02.xhtml#Using_Helm).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *Chart.yaml* 文件包含许多键，其中只有三个是必需的。`apiVersion` 属性告诉 Helm 这是哪个版本的图表。Helm v3
    可以处理 `apiVersion` 是 `v1` 或 `v2` 的图表。`v1` 图表是设计用于 Helm 的早期版本。如果你的图表设计用于 Helm v3
    或更新版本，你应该将其设置为 `v2`。`name` 的值通常用作 Kubernetes 资源名称的一部分。这意味着名称仅限于小写字母数字、`-` 和 `.`
    字符，并且必须以字母数字字符开头和结尾。名称通常为小写字母数字字符。最后一个必需的键是 `version`，包含图表的版本。版本应遵循语义化版本控制，这在
    [Chapter 2](ch02.xhtml#Using_Helm) 中有所涵盖。
- en: You might notice that the style of a *Chart.yaml* file is similar but mildly
    different from those of Kubernetes manifests. *Chart.yaml* files are not the same
    format as custom resources but do contain some of the same properties. The original
    *Chart.yaml* files were designed back in 2015, long before Kubernetes custom resource
    definitions existed. While Helm has progressed in major versions, it has maintained
    a certain amount of backward compatibility over time to not disrupt users too
    much. This has led to differences between the *Chart.yaml* file format and Kubernetes
    manifests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 *Chart.yaml* 文件的样式与 Kubernetes 清单文件类似但略有不同。*Chart.yaml* 文件与自定义资源的格式不同，但包含一些相同的属性。最初设计
    *Chart.yaml* 文件是在 Kubernetes 自定义资源定义出现之前的 2015 年。尽管 Helm 在主要版本上有所进展，但随着时间的推移，它保持了一定程度的向后兼容性，以避免过度打扰用户。这导致了
    *Chart.yaml* 文件格式与 Kubernetes 清单之间的差异。
- en: '*Chart.yaml* files also contain descriptive information, which is useful as
    it’s presented in user interfaces. The `description` field in [Example 4-1](#chapter_5_generated_chart_yaml)
    is one such field, but you can add additional fields, such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chart.yaml* 文件还包含描述信息，这在用户界面中呈现时非常有用。[示例 4-1](#chapter_5_generated_chart_yaml)
    中的 `description` 字段就是这样一个字段，但你可以添加额外的字段，比如以下内容：'
- en: '`home` is a URL to the chart or projects homepage.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home` 是图表或项目主页的 URL。'
- en: '`icon` is an image (e.g., PNG or SVG file) in the form of a URL.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icon` 是一个图像（如 PNG 或 SVG 文件），以 URL 形式表示。'
- en: '`maintainers` contains a list of maintainers. Each maintainer on the list can
    have a name, email, and URL.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maintainers` 包含维护者列表。列表中的每个维护者可以有姓名、电子邮件和 URL。'
- en: '`keywords` can hold a list of keywords about the project.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keywords` 可以包含有关项目的关键字列表。'
- en: '`sources` is for a list of URLs to source code for the project or chart.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sources` 是项目或图表源代码的 URL 列表。'
- en: A full description of the properties in the *Chart.yaml* file are available
    in [Appendix A](app01.xhtml#appendix_a_chart_api_versions), for reference.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chart.yaml* 文件中属性的完整描述可以参考 [附录 A](app01.xhtml#appendix_a_chart_api_versions)。'
- en: 'The generated *Chart.yaml* file can be modified for the Anvil application.
    The following modifications update the required fields, add some descriptive files,
    and remove comments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 *Chart.yaml* 文件可以用于修改 Anvil 应用程序。以下修改更新了所需字段，添加了一些描述性文件并删除了注释：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One property that was in the generated *Chart.yaml* file but is not in the one
    for Anvil is `type`. Anvil is an application which is the default value for the
    `type` field, so the `type` field is not required. The other type of chart is
    a library chart, which is covered in [Chapter 7](ch07.xhtml#chart_repositories).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 *Chart.yaml* 文件中的一个属性，但在 Anvil 的文件中没有的是 `type`。Anvil 是一个应用程序，`type` 字段的默认值是应用程序，因此
    `type` 字段不是必需的。另一种类型的图表是库图表，详细说明在 [第 7 章](ch07.xhtml#chart_repositories) 中。
- en: The `appVersion` property is unique. It is both descriptive and regularly used
    within the templates. The `appVersion` property represents the version of the
    primary or combined application. For example, if the application being packaged
    was WordPress, it would be the version of WordPress.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`appVersion` 属性是独特的。它既是描述性的，也经常在模板中使用。`appVersion` 属性代表主要或组合应用程序的版本。例如，如果打包的应用程序是
    WordPress，则它将是 WordPress 的版本。'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `icon` property is a URL, and that can include data URLs. [Data URLs](https://oreil.ly/1gj45)
    enable you to embed small files in URL form. This is especially useful if the
    logo is a small SVG file. If a chart may be run in air-gapped on-premise environments
    or you do not want user interfaces constantly downloading a file from your web
    server, a data URL is a useful choice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`icon` 属性是一个 URL，可以包含数据 URL。[数据 URL](https://oreil.ly/1gj45) 允许你在 URL 形式中嵌入小文件。如果
    logo 是一个小的 SVG 文件，这尤其有用。如果图表可能在空隔离的本地环境中运行，或者你不希望用户界面不断从你的 Web 服务器下载文件，数据 URL
    是一个有用的选择。'
- en: Modifying Templates
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改模板
- en: In order to modify this chart for the Anvil application or your own custom application,
    you will need to understand and modify templates. Out of the box, the templates
    created by the `helm create` command run Nginx as a stateless application. In
    the example we are working through, Nginx will need to be replaced with Anvil.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改这个图表以适应 Anvil 应用程序或你自己的定制应用程序，你需要理解并修改模板。默认情况下，`helm create` 命令创建的模板将 Nginx
    作为一个无状态应用程序运行。在我们正在处理的示例中，Nginx 将需要被 Anvil 替换。
- en: 'Helm is written in the Go programming language, and Go includes template packages.
    Helm leverages the text template package as the foundation for its templates.
    This template language is similar to other template languages and includes loops,
    if/then logic, functions, and more. An example template of a YAML file follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是用 Go 编程语言编写的，Go 包含模板包。Helm 利用文本模板包作为其模板的基础。这种模板语言类似于其他模板语言，包括循环、if/then
    逻辑、函数等。下面是一个 YAML 文件的示例模板：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this YAML file there is a key name of `product`. The value is generated using
    a template. `{{` and `}}` are the opening and closing brackets to enter and exit
    template logic. There are three parts to the template logic separated by a `|`.
    This is called a pipeline, and it works the same way as a pipeline in Unix-based
    systems. The value or output of a function on the left is passed in as the last
    argument to the next item in the pipeline. In this case, the pipeline starts with
    the value from the property in `.Values.product`. This comes from the data object
    passed in when the templates are rendered. The value of this data is piped as
    the last argument to the `default` function, which is one of the functions provided
    by Helm. If the value passed in is empty, the `default` function uses the default
    value of `"rocket"`, ensuring there is a value. This is then sent to the `quote`
    function, which ensures the string is wrapped in quotes before writing it to the
    template.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 YAML 文件中，有一个名为 `product` 的键。该值是使用模板生成的。`{{` 和 `}}` 是进入和退出模板逻辑的开头和结尾括号。模板逻辑由三部分组成，通过
    `|` 分隔。这称为管道，在类 Unix 系统中的管道中起作用。左侧函数的值或输出作为管道中下一个项目的最后一个参数传递。在这种情况下，管道从 `.Values.product`
    属性中的值开始。这来自在渲染模板时传递的数据对象。将此数据的值作为最后一个参数传递给 `default` 函数，这是 Helm 提供的函数之一。如果传入的值为空，则
    `default` 函数使用默认值 `"rocket"`，确保有一个值。然后将其发送到 `quote` 函数，该函数确保字符串在写入模板之前被包装在引号中。
- en: The `.` at the start of `.Values.product` is important. This is considered the
    root object in the current scope. `.Values` is a property on the root object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.Values.product` 开头的 `.` 很重要。这被认为是当前作用域中的根对象。`.Values` 是根对象上的一个属性。
- en: The Deployment
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Helm charts can hold templates for any Kubernetes resource type you might use.
    That includes `StatefulSet`s, `Job`s, `PersistentVolumeClaim`s, `Service`s, and
    much more. The chart created with `helm create` is designed to run a stateless
    service as a Kubernetes Deployment. The example application we are using here
    for Anvil is a stateless application, which means it will work well as a deployment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表可以包含任何你可能使用的 Kubernetes 资源类型的模板。这包括 `StatefulSet`、`Job`、`PersistentVolumeClaim`、`Service`
    等等。使用 `helm create` 创建的图表旨在作为 Kubernetes 部署运行无状态服务。我们在这里使用的示例应用程序是无状态应用程序，这意味着它将作为部署工作得很好。
- en: 'To understand the `Deployment` template, we can take a look at the *deployment.yaml*
    file in the *templates* directory of the chart. The following is the templated
    version of the `Deployment` up to the `spec` section:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 `Deployment` 模板，我们可以查看图表的 *templates* 目录中的 *deployment.yaml* 文件。以下是 `Deployment`
    的模板版本，包括 `spec` 部分：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This looks very similar to the start of a Kubernetes manifest. It has an `apiVersion`,
    the `kind`, and `metadata`. Once you get into the `metadata` you’ll notice the
    templating begins.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常类似于 Kubernetes 清单的开头。它具有 `apiVersion`、`kind` 和 `metadata`。一旦进入 `metadata`，你会注意到开始进行模板化。
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you are unfamiliar with the structure of Kubernetes Deployments, you can
    read about them in the [Kubernetes documentation](https://oreil.ly/aIuIE).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Kubernetes 部署的结构不熟悉，可以在 [Kubernetes 文档](https://oreil.ly/aIuIE) 中阅读相关内容。
- en: The `include` template function enables including the output of one template
    in another template, and this works in pipelines. The first argument to the `include`
    function is the name of the template to use. The `.` passed in as the second argument
    is the root object. This is passed in so the properties and functions on the root
    object can be used within the called template.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 模板函数可以在一个模板中包含另一个模板的输出，这在管道中起作用。`include` 函数的第一个参数是要使用的模板的名称。作为第二个参数传入的
    `.` 是根对象。这样传入是为了在调用的模板中可以使用根对象上的属性和函数。'
- en: '*anvil.fullname* and *anvil.labels* are two reusable templates included in
    the chart via the *_helpers.tpl* file. (The _ at the start of the name causes
    it to bubble up to the top of directory listings so you can easily find it among
    your templates; Helm does not render them into Kubernetes manifests but does make
    templates in them available for use.) *anvil.fullname* provides a name based on
    the name chosen when the chart is instantiated, and *anvil.labels* provides labels
    following Kubernetes best practices. The functions are covered in more depth in
    [Chapter 5](ch05.xhtml#developing_templates).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*anvil.fullname* 和 *anvil.labels* 是通过 *_helpers.tpl* 文件在图表中包含的两个可重用模板。（名称开头的下划线会使它在目录列表中排在顶部，因此您可以轻松找到它，尽管
    Helm 不会将它们渲染为 Kubernetes 清单，但确实使这些模板可供使用。）*anvil.fullname* 提供基于实例化图表时选择的名称，而 *anvil.labels*
    遵循 Kubernetes 最佳实践提供标签。这些函数在 [第 5 章](ch05.xhtml#developing_templates) 中有更详细的介绍。'
- en: 'After the `metadata` section of the template is the `spec` section, which reads
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的 `metadata` 部分之后是 `spec` 部分，内容如下：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO3-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_building_a_chart_CO3-1)'
- en: The location and version of the container image is configurable via values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的位置和版本可以通过值进行配置。
- en: The `spec` section completes the deployment. Most of this section is filling
    in data with the properties on `.Values`. There are a few elements that are hardcoded,
    such as the ports used to expose the application. Anvil is exposed over HTTP on
    port 80, so we do not need to change the port. If your containers are exposed
    on different ports, you will need to make changes here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分完成了部署。大部分内容填充在 `.Values` 的属性中。有一些元素是硬编码的，例如用于公开应用程序的端口。Anvil 在端口 80
    上通过 HTTP 公开，因此我们不需要更改端口。如果您的容器公开在不同的端口上，您需要在这里进行更改。'
- en: The value of `image` for the container is set using values. You won’t find the
    location of the image hardcoded here. This is useful for those cases where the
    image location needs to be set to a different location when a chart is instantiated.
    It means we need to change the location in the default values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的 `image` 值是使用值设置的。您不会在这里找到硬编码的镜像位置。这对于在实例化图表时需要将镜像位置设置为不同位置的情况非常有用。这意味着我们需要在默认值中更改位置。
- en: The properties on `.Values` are computed based on a number of factors. The default
    values and starting point are based on the values provided by the *values.yaml*
    file in the chart. The *values.yaml* file is covered in the next section. These
    values can be overridden by values passed in when the chart is instantiated. The
    *helm* CLI has flags to pass in values directly (i.e., `--set`, `--set-file`,
    and `--set-string`) or to pass in a file with values (i.e., `-f` or `--values`).
    The values are merged together, with those being passed in later taking precedence.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Values` 上的属性是基于多个因素计算的。默认值和起点基于图表中 *values.yaml* 文件提供的值。*values.yaml* 文件将在下一节中介绍。这些值可以被在实例化图表时传入的值覆盖。*helm*
    CLI 有用于直接传递值的标志（即 `--set`、`--set-file` 和 `--set-string`），或者传递一个包含值的文件（即 `-f` 或
    `--values`）。这些值被合并在一起，后传入的值优先。'
- en: Templates are a large topic and typically make up the bulk of a chart. [Chapter 5](ch05.xhtml#developing_templates)
    is dedicated to templates.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一个广泛的主题，通常占据图表的大部分。[第 5 章](ch05.xhtml#developing_templates) 专门讨论模板。
- en: Using the Values File
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Values 文件
- en: When someone instantiates an application in a Kubernetes cluster from a chart,
    they don’t need to supply all the values used in the templates. If they did, it
    would provide for a difficult user experience. This is where the *values.yaml*
    file comes in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人在 Kubernetes 集群中从图表实例化应用程序时，并不需要提供模板中使用的所有值。如果他们这样做了，会导致用户体验困难。这就是 *values.yaml*
    文件的作用所在。
- en: Charts include a *values.yaml* file that sits alongside the *Chart.yaml* file
    in the root of a chart. The *values.yaml* file contains the default values used
    by the chart, and it is a form of documentation for the custom values that can
    be passed into a chart.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图表包括一个 *values.yaml* 文件，与根目录中的 *Chart.yaml* 文件并列。*values.yaml* 文件包含图表使用的默认值，并且它是可以传递给图表的自定义值的一种形式文档化。
- en: '*values.yaml* is an unstructured YAML file. There are some common and useful
    practices, which will be covered shortly, but nothing is required in the format
    of the YAML. This enables chart creators to provide a structure and information
    that works well for them. A *values.yaml* file can contain numerous things, from
    simple substitution for Kubernetes manifest properties to elements needed for
    application-specific business logic.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*values.yaml*是一个非结构化的YAML文件。有一些常见和有用的做法，很快将介绍，但格式中没有必需的内容。这使图表创建者能够提供适合他们的结构和信息。*values.yaml*文件可以包含许多内容，从用于Kubernetes清单属性的简单替换到需要特定于应用程序的业务逻辑元素。'
- en: Container Images
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像
- en: 'The opening part of the *values.yaml* file created by `helm create` contains
    the image information along with some opening documentation and information on
    replicas:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm create`创建的*values.yaml*文件的开头部分包含有关图像信息以及一些开头文档和副本信息：'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO4-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_building_a_chart_CO4-1)'
- en: The location of the image. It has been updated to reflect the location of Anvil.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的位置。已更新以反映Anvil的位置。
- en: '[![2](Images/2.png)](#co_building_a_chart_CO4-2)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_building_a_chart_CO4-2)'
- en: A policy of `IfNotPresent` means that the image will be cached in the Kubernetes
    cluster by the version being used. `Always` is another option that bypasses the
    cache and always downloads from the repository.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`IfNotPresent`策略意味着将使用正在使用的版本在Kubernetes集群中缓存镜像。`Always`是另一个选项，它会绕过缓存并始终从存储库下载。'
- en: '[![3](Images/3.png)](#co_building_a_chart_CO4-3)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_building_a_chart_CO4-3)'
- en: By default this chart uses the `appVersion` as the tag. If an image tag is specified,
    it is used instead of the `appVersion`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此图表使用`appVersion`作为标记。如果指定了镜像标记，则使用它而不是`appVersion`。
- en: '[![4](Images/4.png)](#co_building_a_chart_CO4-4)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_building_a_chart_CO4-4)'
- en: A list of pull secrets is used when credentials are needed to access a container
    registry location that is protected with a username and password.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要凭据访问受用户名和密码保护的容器注册表位置时，使用拉取凭据列表。
- en: This chart and the values represent an application bundled as a single image.
    The patterns used in the *values.yaml* file are designed with that in mind. For
    example, there is only one image location. If your applications have multiple
    images, each image would have a section containing much of the information here.
    This includes `replicaCount`, which is the number of `replicas` Kubernetes will
    use when the `Deployment` is created.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表及其值代表打包为单个镜像的应用程序。在*values.yaml*文件中使用的模式考虑到这一点。例如，只有一个镜像位置。如果您的应用程序有多个镜像，则每个镜像将有一个包含大部分信息的部分。这包括`replicaCount`，这是创建`Deployment`时Kubernetes将使用的副本数。
- en: The `image` section contains details about the image. The `repository` contains
    the location of the image to use while the `pullPolicy` tells Kubernetes how often
    to fetch or cache the images. If a moving tag, such as `stable`, is used, the
    `pullPolicy` should be set to `Always` so that changes are picked up. Since a
    version is being used, the default `pullPolicy` is set to `IfNotPresent` so that
    a cached version can be used if available. The `tag` property provides an opportunity
    to set a tag that is different from the `appVersion` set in the *Chart.yaml* file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`部分包含有关镜像的详细信息。`repository`包含要使用的镜像位置，而`pullPolicy`告诉Kubernetes多久获取或缓存镜像。如果使用像`stable`这样的移动标签，则应将`pullPolicy`设置为`Always`，以便捕获更改。由于正在使用版本，因此默认的`pullPolicy`设置为`IfNotPresent`，以便在可用时可以使用缓存版本。`tag`属性提供了设置与*Chart.yaml*文件中设置的`appVersion`不同的标记的机会。'
- en: You might notice there is no method to set a digest when fetching an image.
    Digests can be different when images are in different repositories. For example,
    if the Anvil image were copied from Docker Hub to Quay, another image repository,
    the digest would change for the same image even if the tag and content remained
    the same. [Chapter 5](ch05.xhtml#developing_templates) provides an example of
    adding in support for a digest to a chart, if that is desired.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到在获取镜像时没有设置摘要的方法。当图像位于不同的存储库中时，摘要可能不同。例如，如果将Anvil镜像从Docker Hub复制到Quay，另一个图像存储库，则对于相同的图像，即使标签和内容保持不变，摘要也会更改。如果需要，在图表中添加对摘要的支持的示例将在[第5章](ch05.xhtml#developing_templates)中提供。
- en: If you need to pull an image from a container registry with access controls,
    Kubernetes needs to know how to do that. This happens through the use of pull
    secrets. `imagePullSecrets` allows you to list the names of pull secrets with
    access to private registries. Reference the [documentation for creating a pull
    secret](https://oreil.ly/BL-VO).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要从带有访问控制的容器注册表中拉取图像，Kubernetes需要知道如何执行此操作。这通过使用拉取密钥来完成。`imagePullSecrets`允许您列出具有访问私有注册表权限的拉取密钥的名称。参考[创建拉取密钥的文档](https://oreil.ly/BL-VO)。
- en: 'The generated chart has some security considerations built in that can be enabled
    or otherwise configured. A service account for the chart instance is created by
    default, while the other options are opt-in. The following is what is generated
    by `helm` `create`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表中内置了一些安全考虑，可以启用或者进行其他配置。图表实例的服务账户默认创建，而其他选项则是自选的。以下是`helm create`生成的内容：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will notice that most of the properties in the configuration are comments
    and are inactive. When the chart is rendered with the values as comments, there
    is no value for those properties. The value is empty. By having a structure and
    values as comments the chart is documenting the structure and default values that
    can be used but isn’t turning on those features.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到配置中的大多数属性都是注释并且是非活动状态的。当图表以注释值渲染时，这些属性没有值。值为空。通过将结构和值作为注释，图表记录了结构和默认值，可以使用但没有打开这些功能。
- en: Exposing Services
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公开服务
- en: 'The next section of the *values.yaml* file deals with exposing the application
    for others to consume:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*values.yaml*文件的下一部分处理将应用程序暴露给其他人消费的问题：'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In Kubernetes there are two built-in objects you can use to expose applications.
    The first is a `Service`. The `service` property will let you select the type
    of `Service` being used. While `ClusterIP` is used by default, other options such
    as `NodePort` and `LoadBalancer` can be used. The few lines of YAML in the `service`
    section are paired with the generated *service.yaml* template to create a full
    Service manifest to upload to Kubernetes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，有两个内置对象可以用来公开应用程序。第一个是`Service`。`service`属性允许您选择使用的`Service`类型。默认情况下使用`ClusterIP`，还可以使用其他选项，如`NodePort`和`LoadBalancer`。在`service`部分的少量YAML行与生成的*service.yaml*模板配对，用于创建上传到Kubernetes的完整Service清单。
- en: 'The second built-in object is the `Ingress` manifest, which can be paired with
    a `Service`, and the chart has the capability to generate them. `Ingress` configuration
    provides a means to show off a common pattern found in charts: the use of an `enabled`
    property to turn features on and off. In this case `ingress.enabled` is set to
    `false`. When Helm renders the templates and sees a value of false, the `Ingress`
    manifest is skipped. This is due to the use of an `if` logic statement in the
    `Ingress` template found in the generated *ingress.yaml* file.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个内置对象是`Ingress`清单，可以与一个`Service`配对，而且图表有能力生成它们。`Ingress`配置提供了展示图表中常见模式的一种方式：使用`enabled`属性来控制功能的开启和关闭。在这种情况下，`ingress.enabled`被设置为`false`。当Helm渲染模板并看到false的值时，`Ingress`清单将被跳过。这是由于在生成的*ingress.yaml*文件中`Ingress`模板中使用了`if`逻辑语句。
- en: Resource Limits
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源限制
- en: 'When you run applications in production, it is a good practice to set resource
    limits. This prevents, for example, a memory leak in one container from disrupting
    other containers. When a chart author creates a chart that others are going to
    use, they may not know where it will be installed and how many resources will
    be available there. Could this be installed on a laptop by a developer or someone
    testing out the chart? Or, might this be installed on large production servers?
    To handle this variance in environment, the recommendation is to put in resource
    limits and then turn them into comments. This can be found in the next section
    of the *values.yaml* file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行应用程序时，设置资源限制是一个好习惯。例如，防止一个容器中的内存泄漏影响其他容器。当图表作者创建一个他人将要使用的图表时，他们可能不知道它将安装在何处以及那里会有多少资源可用。这可能会安装在开发人员的笔记本电脑上，或者在大型生产服务器上安装？为了处理环境中的这种变化，建议设置资源限制，然后将其转换为注释。这可以在*values.yaml*文件的下一部分找到：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Those who install applications use these numbers as recommendations when they
    instantiate a chart. These numbers are the default values that have been set for
    a simple Nginx setup as it was generated. They work for the Anvil application.
    If your application will need different values, you will need to update these.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 安装应用程序的人使用这些数字作为实例化图表时的推荐值。这些数字是为一个简单的 Nginx 设置而设置的默认值。它们适用于 Anvil 应用程序。如果你的应用程序需要不同的值，你需要更新这些值。
- en: 'Workloads have the ability to specify details about where they are executed
    in a cluster by the settings node selector, tolerations, and affinity. Although
    these more advanced features are often not used, it is a good idea to include
    them in a chart for those who need them. The generated *values.yaml* file and
    templates take this into account. The following example has generated YAML keys
    for these advanced features. The values are empty by default with an expectation
    that the person who installs the chart will set values as appropriate for their
    installation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 工作负载有能力通过设置节点选择器、容忍性和亲和性来指定它们在集群中执行的详细信息。尽管这些高级特性经常不被使用，但将它们包含在图表中对于那些需要它们的人是一个好主意。生成的
    *values.yaml* 文件和模板考虑了这一点。以下示例生成了这些高级特性的 YAML 键。默认情况下，这些值为空，期望安装图表的人根据他们的安装情况设置适当的值：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Packaging the Chart
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包图表
- en: 'You can package the files and directories of a chart into a single archive
    file. This is useful for many reasons, including:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将图表的文件和目录打包到单个存档文件中。这对许多情况都很有用，包括：
- en: For distribution to other people. One of the powerful aspects of a package manager
    is where someone with knowledge of running an application packages it up so that
    others, who don’t have intimate knowledge of the platform or application, can
    run it.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发给其他人。包管理器的一个强大之处在于，了解如何运行应用程序的人能够打包它，以便其他没有平台或应用程序详细知识的人也能运行它。
- en: When a version of an application needs to be taken through a multienvironment
    test process. An example of this process is where there are development, quality
    assurance (QA), and production environments and the application needs to pass
    QA prior to going into production.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个应用程序的版本需要经过多环境测试流程时。这种流程的一个示例是存在开发、质量保证（QA）和生产环境，应用程序需要在进入生产之前通过 QA。
- en: When developing a multiservice application and developers need to run services
    built or otherwise handled by others as part of their development setup.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当开发多服务应用程序时，开发人员需要在其开发设置中运行由其他人构建或处理的服务。
- en: In each of these situations it is often simpler to pass around a single file
    for the chart than a directory structure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，将图表作为单个文件传递比传递目录结构通常更为简单。
- en: Chart versions bring another wrinkle to the way you distribute and consume charts.
    You or someone consuming your chart may need to use different versions of the
    chart. This is why it’s useful to store and share different versions using chart
    repositories or Open Container Initiative (OCI) registries, covered in [Chapter 7](ch07.xhtml#chart_repositories).
    In these environments, storing and sharing many files in a collection of directory
    structures for each version is far from simple.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图表版本带来了分发和消费图表的另一个考虑因素。你或者消费你的图表的人可能需要使用图表的不同版本。因此，使用图表仓库或开放容器倡议（OCI）注册表来存储和共享不同版本是很有用的，详见[第7章](ch07.xhtml#chart_repositories)。在这些环境中，为每个版本存储和共享多个文件的目录结构远非简单。
- en: Helm has the ability to build a chart archive. Each chart archive is a gzipped
    TAR file with the extension *.tgz*. Any tool that can create, extract, and otherwise
    work on gzipped TAR files will work with Helm’s chart archives.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 能够构建图表存档。每个图表存档都是一个带有扩展名 *.tgz* 的经过 gzip 压缩的 TAR 文件。任何能够创建、提取和处理 gzip 压缩的
    TAR 文件的工具都可以与 Helm 的图表存档一起使用。
- en: 'When Helm generates the archive files, they are named using a pattern of *`chart
    name`-`version`.tgz*. Helm expects this same pattern when consuming them. The
    *`chart name`* is the name you will find inside the *Chart.yaml* file and the
    *`version`* is the chart version. This enables multiple versions of the same chart
    to be stored alongside each other. You can package Anvil as an archive by running:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Helm 生成存档文件时，它们的命名模式为 *`chart name`-`version`.tgz*。Helm 在处理这些存档时期望使用相同的模式。*`chart
    name`* 是你在 *Chart.yaml* 文件中找到的名称，*`version`* 是图表的版本。这样可以使相同图表的多个版本并存。你可以通过运行以下命令将
    Anvil 打包为存档文件：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case `anvil` is the path to the location where the *anvil* chart source
    is located. By default, the `helm package` command will place the archive in the
    directory you were in when you ran the command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`anvil`是位于*anvil*图表源位置的路径。默认情况下，当您运行命令时，`helm package`命令将把存档放置在您所在的目录中。
- en: 'There are some useful flags you can use when packaging a chart:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包图表时，您可以使用一些有用的标志：
- en: '`--dependency-update` (`-u`)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`--dependency-update` (`-u`)'
- en: Tells Helm to update the dependent charts prior to creating the archive. This
    will update the *Chart.lock* file and place a copy of the dependent charts in
    the *chart* directory. Dependencies are covered in more detail in [Chapter 6](ch06.xhtml#advanced_charts).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建存档之前，告诉Helm更新依赖图表。这将更新*Chart.lock*文件并将依赖图表的副本放置在*chart*目录中。有关详细信息，请参阅[第6章](ch06.xhtml#advanced_charts)。
- en: '`--destination` (`-d`)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`--destination` (`-d`)'
- en: Enables you to set the location to put the chart archive if it is different
    from the current working directory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您设置放置图表存档的位置，如果该位置与当前工作目录不同的话。
- en: '`--app-version`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`--app-version`'
- en: Can be used to set the `appVersion` property of the *Chart.yaml* file. This
    is especially useful if you create new releases of the chart for each new release
    of your application running within the container and there is no other change
    to the chart. Automation can use a flag like this as part of the process to build
    the new version.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于设置*Chart.yaml*文件的`appVersion`属性。如果您为容器内运行的应用程序的每个新版本创建图表的新版本而且没有其他更改，则特别有用。自动化过程可以使用类似此标志作为构建新版本的一部分。
- en: '`--version`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`--version`'
- en: Updates the chart’s version. This is useful if you’re updating the `appVersion`
    using the command line as part of the process to package a chart.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更新图表的版本。如果您正在使用命令行更新`appVersion`作为打包图表过程的一部分，则这很有用。
- en: Flags for Pretty Good Privacy (PGP) signing charts
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 用于Pretty Good Privacy（PGP）签署图表的标志
- en: Helm charts can be cryptographically signed and verified. The `package` command
    has flags for the signing portion of the process, while commands like `install`
    and `upgrade` have flags for the verification portion of the process. [Chapter 6](ch06.xhtml#advanced_charts)
    covers this process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表可以进行加密签名和验证。`package`命令具有用于签名过程的标志，而`install`和`upgrade`等命令具有用于验证过程的标志。有关此过程的详细信息，请参阅[第6章](ch06.xhtml#advanced_charts)。
- en: 'Sometimes you will have files in a chart directory that you do not want to
    include in the chart archive. Optionally, in a chart directory there can be a
    *.helmignore* file. This is similar to a *.gitignore* file for Git. The `helm
    create` command used earlier created one with the following contents:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会在图表目录中有不想包含在图表存档中的文件。在图表目录中，可以选择有一个*.helmignore*文件。这类似于Git的*.gitignore*文件。之前使用的`helm
    create`命令创建了一个具有以下内容的文件：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Many of these extensions and patterns may look familiar because they come from
    various version control systems and code editors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展和模式中的许多可能看起来很熟悉，因为它们来自各种版本控制系统和代码编辑器。
- en: When the chart archive is created, you usually don’t want to include elements
    like your version control system data. The *.helmignore* file provides a place
    to specify what to skip. This file needs to be at the top level of the chart.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建图表存档时，通常不希望包含版本控制系统数据等元素。*.helmignore*文件提供了一个地方来指定要跳过的内容。此文件需要位于图表的顶层目录中。
- en: Helm is designed to work with the archive files the same way it works with directory
    structures. Commands like `helm install` and `helm lint`, which will be covered
    shortly, can be passed an archive file the same way they can be passed a directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Helm旨在与存档文件的方式相同地与目录结构一起工作。像`helm install`和`helm lint`这样的命令可以传递一个存档文件，方式与传递目录相同，稍后会详细介绍。
- en: Linting Charts
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linting Charts
- en: When developing charts, especially when working with YAML templates, it can
    be easy to make a mistake or miss something. To help you catch errors, bugs, style
    issues, and other suspicious elements, the Helm client includes a linter. This
    linter can be used during chart development and as part of any testing processes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发图表时，特别是在使用YAML模板时，很容易出错或遗漏某些内容。为帮助您捕捉错误、漏洞、样式问题和其他可疑元素，Helm客户端包含一个linter。此linter可用于图表开发以及任何测试过程的一部分。
- en: 'To use the linter, use the `lint` command on a chart as a directory or a packaged
    archive:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用linter，请在作为目录或打包存档的图表上使用`lint`命令：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line is the command you run, while the following lines are output
    by Helm. In this case there were no issues. You could use this command on an archive
    file like the one in the previous section. To do that, change the `anvil` argument,
    set to the directory location for the chart, to the archive file *anvil-0.1.0.tgz*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是您运行的命令，而以下几行是 Helm 输出的内容。在这种情况下，未发现任何问题。您可以在像前一节中的存档文件上使用此命令。为此，请将 `anvil`
    参数更改为图表的目录位置，并设置为存档文件 *anvil-0.1.0.tgz*。
- en: 'This command is able to lint multiple charts in a single command. For example,
    if you had a second chart called *mychart* and wanted to lint it alongside *anvil*,
    you could run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令能够在单个命令中检查多个图表。例如，如果您有第二个名为 *mychart* 的图表，并希望与 *anvil* 一起进行检查，您可以运行以下命令：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The three levels of actionable feedback about charts Helm provides are info,
    warning, and errors. Info-level feedback is informational; charts can be installed
    with info-level feedback. Info-level feedback causes Helm to have an exit code
    of 0\. Error-level feedback means there is a problem with the chart. If a chart
    generates an Invalid manifest for Kubernetes, such as YAML being invalid, Helm
    will generate an error. Errors cause Helm to have a nonzero exit code, which is
    useful to catch issues in automated testing tools. In the middle are warning messages.
    These messages address findings that may cause issues. By default, warning messages
    cause Helm to have an exit code of 0, but Helm adds a `--strict` flag that causes
    the exit codes to be nonzero. You can choose how to handle these in automation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供的有关图表的三个可操作反馈级别是信息、警告和错误。信息级反馈是信息性的；可以使用信息级反馈安装图表。信息级反馈使 Helm 的退出代码为
    0。错误级反馈意味着图表存在问题。如果图表生成了 Kubernetes 的无效清单，比如 YAML 无效，Helm 将生成错误。错误会导致 Helm 的退出代码为非零，这对于捕获自动化测试工具中的问题非常有用。中间是警告消息。这些消息涉及可能导致问题的发现。默认情况下，警告消息会使
    Helm 的退出代码为 0，但 Helm 添加了一个 `--strict` 标志，使退出代码为非零。您可以选择如何在自动化中处理这些消息。
- en: In this case there were no issues found with the *anvil* chart. A default chart,
    created by `helm create`, will have a single info message about a missing `icon`
    property in the *Chart.yaml* file. This is an info-level notice so that people
    are aware it is missing. The missing icon will not affect the operation of the
    chart, but it will affect the way it is displayed in user interfaces.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*anvil* 图表没有发现任何问题。由 `helm create` 创建的默认图表会有一个关于 *Chart.yaml* 文件中缺少 `icon`
    属性的信息提示。这是一个信息级别的通知，以便人们知道它确实缺少。缺少图标不会影响图表的操作，但会影响其在用户界面中的显示方式。
- en: Conclusion
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Creating a simple chart for your application is straightforward when you use
    the `helm create` command. Even when your applications are more complicated, the
    structure of charts is able to accommodate them, and the `helm create` command
    can help you. With a few minor modifications made in this chapter you can install
    the Anvil chart using `helm install` and see the custom application running in
    your cluster. You can use this same flow to create your own charts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `helm create` 命令创建应用程序的简单图表时，过程非常简单。即使您的应用程序更复杂，图表的结构也能够容纳它们，并且 `helm create`
    命令可以帮助您。通过本章中进行的一些小修改，您可以使用 `helm install` 安装 Anvil 图表，并在群集中查看自定义应用程序运行情况。您可以使用相同的流程创建自己的图表。
- en: In the next chapter you will learn about creating templates with an emphasis
    on how the template language works and how you can apply it to Kubernetes templates
    stored in charts. Templates are usually the largest part of a chart where you
    will spend the most time. Understanding what you have available to you when you
    create templates will make the process of developing them faster and easier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解如何创建模板，重点介绍模板语言的工作原理以及如何将其应用于存储在图表中的 Kubernetes 模板。模板通常是图表中最大的部分，您在创建模板时将花费最多的时间。了解您在创建模板时可用的内容将使开发过程更快、更轻松。
