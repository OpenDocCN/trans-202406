- en: Chapter 4\. Building a Chart
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Charts are at the heart of Helm. In addition to installing them into a Kubernetes
    cluster or managing the instances of charts you’ve installed, you can build new
    charts or alter existing ones. In the next three chapters we will cover a lot
    of details about charts including creating them, the elements inside them, templating
    Kubernetes manifests, testing charts, dependencies, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you will learn how to create a new chart and learn about the
    many parts of a chart. This will include the use of several built-in commands
    that can help you in the chart development process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Charts are the packages Helm works with. They are conceptually similar to Debian
    packages used by APT or Formula used by Homebrew for macOS. The conceptual similarity
    is where the similarities end. Charts are designed to target Kubernetes as a platform
    that has its own unique style. At the heart of charts are templates to generate
    Kubernetes manifests that can be installed and managed in a cluster.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Before we dig into templates in [Chapter 5](ch05.xhtml#developing_templates),
    let’s start by creating a basic fully functional chart. To do that we will cover
    an example chart named *anvil*. Using that chart you will learn about using Helm
    to generate a chart, the structure of charts and files within them, packaging
    charts, and linting charts. Reference the online source for this chart at [*https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil*](https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The Chart Creation Command
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm includes the `create` command to make it easy for you to create a chart
    of your own, and it’s a great way to get started. This command creates a new Nginx
    chart, with a name of your choice, following best practices for a chart layout.
    Since Kubernetes clusters can have different methods to expose an application,
    this chart makes the way Nginx is exposed to network traffic configurable so it
    can be exposed in a wide variety of clusters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The `create` command creates a chart for you, with all the required chart structure
    and files. These files are documented to help you understand what is needed, and
    the templates it provides showcase multiple Kubernetes manifests working together
    to deploy an application. In addition, you can install and test this chart right
    out of the box.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter we will look at an example application named *anvil*.
    It is a simple application that will show you the structure of a chart and provide
    you the chance to alter a chart for a different application. To create the new
    chart, run the following command from a command prompt:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will create a new chart as a subdirectory of your current directory with
    the name *anvil*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The new chart is a directory containing a number of files and folders. This
    does not include every file and folder—you will discover some more in the next
    couple chapters. These are the basic ones needed for a functioning chart:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO1-1)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The *Chart.yaml* file contains metadata and some functionality controls for
    the chart.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_building_a_chart_CO1-2)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Dependent charts can optionally be held in the *charts* directory. Chart dependencies
    are covered in [Chapter 6](ch06.xhtml#advanced_charts). For now this will be an
    empty directory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_building_a_chart_CO1-3)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Templates used to generate Kubernetes manifests are stored in the *templates*
    directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_building_a_chart_CO1-4)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The *NOTES.txt* file is a special template. When a chart is installed, the *NOTES.txt*
    template is rendered and displayed rather than being installed into a cluster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_building_a_chart_CO1-5)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Templates can include tests that are not installed as part of the `install`
    or `upgrade` commands. This chart includes a test that is used by the `helm test`
    command. Testing is covered in [Chapter 6](ch06.xhtml#advanced_charts).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_building_a_chart_CO1-6)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Default values passed to the templates when Helm is rendering the manifests
    are in the *values.yaml* file. When you instantiate a chart, these values can
    be overridden.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install this newly created chart without any modifications by running
    the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this command Helm will create an instance of the chart running
    in the cluster with the name *myapp*. It will install it using the currently configured
    connection and context you use for Kubernetes. Helm is using the same configuration
    you’re using when you use `kubectl`, the command-line application for Kubernetes.
    In that command the final argument of *anvil* is the directory where the chart
    is located.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from this command includes content generated by rendering the *NOTES.txt*
    template, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `NOTES` section contains information on connecting to the application. Depending
    on the values you pass into the chart when it is instantiated, this information
    can be very different. This chart can be configured to use a ClusterIP, NodePort,
    LoadBalancer, and Ingress to expose an application. By default, a ClusterIP is
    used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: If you follow the directions in the notes you will see the default Nginx web
    page to show you it’s running, as shown in [Figure 4-1](#chapter_5_nginx).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Nginx](Images/lehe_0401.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Default Nginx web page when you visit the running application
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The methods to expose the application are tied to built-in Kubernetes resource
    types rather than features of the application. That makes them portable to your
    custom applications. The methods to expose applications include:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: ClusterIP
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: A configuration option on the Kubernetes `Service` resource type that exposes
    the service on a cluster-level internal IP address.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: NodePort
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: An alternative option for Kubernetes `Service` resources that exposes the service
    on a static port of each node. A ClusterIP is automatically created as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: LoadBalancer
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes `Service` configuration option that exposes an application externally
    using a load balancer provided by the hosting provider.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Ingress
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Ingress resources are additional resources to `Service`s that expose a service
    over HTTP and HTTPS. An Ingress Controller, such as ingress-nginx, is required
    for this to work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'If you installed this chart into your cluster to test it, you can delete the
    instance from your cluster by running the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When the chart is installed the image used for Nginx, by default, is the latest
    version of the image from the [Docker Official Images](https://oreil.ly/YghQP).
    If the Kubernetes cluster you are working with does not have access to *hub.docker.com*
    you won’t be able to install the image. You would need to set the image to one
    your cluster has access to.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Now that a working chart has been scaffolded, let’s take a look at what’s inside
    and modify it for the Anvil application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The Chart.yaml File
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look inside the *anvil* directory and you’ll find a file named *Chart.yaml*.
    The *Chart.yaml* file tells Helm and other tools about your chart. Other tools
    include Kubeapps (an on-premise catalog and application installer), the Artifact
    Hub (a listing of cloud native artifacts), and many others.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: When you open the *Chart.yaml* file, you will see the contents shown in [Example 4-1](#chapter_5_generated_chart_yaml).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. The generated Chart.yaml file
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO2-1)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The `apiVersion` tells Helm what structure the chart is using. An `apiVerison`
    of `v2` is designed for Helm v3.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_building_a_chart_CO2-2)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The name is used to identify the chart in various places.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_building_a_chart_CO2-3)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Charts can have many versions. Helm uses the version information to order and
    identify charts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: This *Chart.yaml* file contains numerous keys, of which only three are required.
    The `apiVersion` property tells Helm which version of a chart this is. Helm v3
    can work with charts whose `apiVersion` is `v1` or `v2`. `v1` charts are those
    designed to work with previous versions of Helm. If your charts are designed to
    work with Helm v3 or newer you should set this to `v2`. The value of `name` is
    typically used as part of the name for Kubernetes resources. This means names
    are limited to lowercase alphanumeric, `-`, and `.` characters and must start
    and end with an alphanumeric character. Names are typically lowercase alphanumeric
    characters. The final required key is `version`, containing the version of the
    chart. Versions are expected to follow Semantic Versioning, which was covered
    in [Chapter 2](ch02.xhtml#Using_Helm).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that the style of a *Chart.yaml* file is similar but mildly
    different from those of Kubernetes manifests. *Chart.yaml* files are not the same
    format as custom resources but do contain some of the same properties. The original
    *Chart.yaml* files were designed back in 2015, long before Kubernetes custom resource
    definitions existed. While Helm has progressed in major versions, it has maintained
    a certain amount of backward compatibility over time to not disrupt users too
    much. This has led to differences between the *Chart.yaml* file format and Kubernetes
    manifests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 *Chart.yaml* 文件的样式与 Kubernetes 清单文件类似但略有不同。*Chart.yaml* 文件与自定义资源的格式不同，但包含一些相同的属性。最初设计
    *Chart.yaml* 文件是在 Kubernetes 自定义资源定义出现之前的 2015 年。尽管 Helm 在主要版本上有所进展，但随着时间的推移，它保持了一定程度的向后兼容性，以避免过度打扰用户。这导致了
    *Chart.yaml* 文件格式与 Kubernetes 清单之间的差异。
- en: '*Chart.yaml* files also contain descriptive information, which is useful as
    it’s presented in user interfaces. The `description` field in [Example 4-1](#chapter_5_generated_chart_yaml)
    is one such field, but you can add additional fields, such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chart.yaml* 文件还包含描述信息，这在用户界面中呈现时非常有用。[示例 4-1](#chapter_5_generated_chart_yaml)
    中的 `description` 字段就是这样一个字段，但你可以添加额外的字段，比如以下内容：'
- en: '`home` is a URL to the chart or projects homepage.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home` 是图表或项目主页的 URL。'
- en: '`icon` is an image (e.g., PNG or SVG file) in the form of a URL.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icon` 是一个图像（如 PNG 或 SVG 文件），以 URL 形式表示。'
- en: '`maintainers` contains a list of maintainers. Each maintainer on the list can
    have a name, email, and URL.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maintainers` 包含维护者列表。列表中的每个维护者可以有姓名、电子邮件和 URL。'
- en: '`keywords` can hold a list of keywords about the project.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keywords` 可以包含有关项目的关键字列表。'
- en: '`sources` is for a list of URLs to source code for the project or chart.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sources` 是项目或图表源代码的 URL 列表。'
- en: A full description of the properties in the *Chart.yaml* file are available
    in [Appendix A](app01.xhtml#appendix_a_chart_api_versions), for reference.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chart.yaml* 文件中属性的完整描述可以参考 [附录 A](app01.xhtml#appendix_a_chart_api_versions)。'
- en: 'The generated *Chart.yaml* file can be modified for the Anvil application.
    The following modifications update the required fields, add some descriptive files,
    and remove comments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 *Chart.yaml* 文件可以用于修改 Anvil 应用程序。以下修改更新了所需字段，添加了一些描述性文件并删除了注释：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: One property that was in the generated *Chart.yaml* file but is not in the one
    for Anvil is `type`. Anvil is an application which is the default value for the
    `type` field, so the `type` field is not required. The other type of chart is
    a library chart, which is covered in [Chapter 7](ch07.xhtml#chart_repositories).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 *Chart.yaml* 文件中的一个属性，但在 Anvil 的文件中没有的是 `type`。Anvil 是一个应用程序，`type` 字段的默认值是应用程序，因此
    `type` 字段不是必需的。另一种类型的图表是库图表，详细说明在 [第 7 章](ch07.xhtml#chart_repositories) 中。
- en: The `appVersion` property is unique. It is both descriptive and regularly used
    within the templates. The `appVersion` property represents the version of the
    primary or combined application. For example, if the application being packaged
    was WordPress, it would be the version of WordPress.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`appVersion` 属性是独特的。它既是描述性的，也经常在模板中使用。`appVersion` 属性代表主要或组合应用程序的版本。例如，如果打包的应用程序是
    WordPress，则它将是 WordPress 的版本。'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `icon` property is a URL, and that can include data URLs. [Data URLs](https://oreil.ly/1gj45)
    enable you to embed small files in URL form. This is especially useful if the
    logo is a small SVG file. If a chart may be run in air-gapped on-premise environments
    or you do not want user interfaces constantly downloading a file from your web
    server, a data URL is a useful choice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`icon` 属性是一个 URL，可以包含数据 URL。[数据 URL](https://oreil.ly/1gj45) 允许你在 URL 形式中嵌入小文件。如果
    logo 是一个小的 SVG 文件，这尤其有用。如果图表可能在空隔离的本地环境中运行，或者你不希望用户界面不断从你的 Web 服务器下载文件，数据 URL
    是一个有用的选择。'
- en: Modifying Templates
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改模板
- en: In order to modify this chart for the Anvil application or your own custom application,
    you will need to understand and modify templates. Out of the box, the templates
    created by the `helm create` command run Nginx as a stateless application. In
    the example we are working through, Nginx will need to be replaced with Anvil.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改这个图表以适应 Anvil 应用程序或你自己的定制应用程序，你需要理解并修改模板。默认情况下，`helm create` 命令创建的模板将 Nginx
    作为一个无状态应用程序运行。在我们正在处理的示例中，Nginx 将需要被 Anvil 替换。
- en: 'Helm is written in the Go programming language, and Go includes template packages.
    Helm leverages the text template package as the foundation for its templates.
    This template language is similar to other template languages and includes loops,
    if/then logic, functions, and more. An example template of a YAML file follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this YAML file there is a key name of `product`. The value is generated using
    a template. `{{` and `}}` are the opening and closing brackets to enter and exit
    template logic. There are three parts to the template logic separated by a `|`.
    This is called a pipeline, and it works the same way as a pipeline in Unix-based
    systems. The value or output of a function on the left is passed in as the last
    argument to the next item in the pipeline. In this case, the pipeline starts with
    the value from the property in `.Values.product`. This comes from the data object
    passed in when the templates are rendered. The value of this data is piped as
    the last argument to the `default` function, which is one of the functions provided
    by Helm. If the value passed in is empty, the `default` function uses the default
    value of `"rocket"`, ensuring there is a value. This is then sent to the `quote`
    function, which ensures the string is wrapped in quotes before writing it to the
    template.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The `.` at the start of `.Values.product` is important. This is considered the
    root object in the current scope. `.Values` is a property on the root object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The Deployment
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm charts can hold templates for any Kubernetes resource type you might use.
    That includes `StatefulSet`s, `Job`s, `PersistentVolumeClaim`s, `Service`s, and
    much more. The chart created with `helm create` is designed to run a stateless
    service as a Kubernetes Deployment. The example application we are using here
    for Anvil is a stateless application, which means it will work well as a deployment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the `Deployment` template, we can take a look at the *deployment.yaml*
    file in the *templates* directory of the chart. The following is the templated
    version of the `Deployment` up to the `spec` section:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This looks very similar to the start of a Kubernetes manifest. It has an `apiVersion`,
    the `kind`, and `metadata`. Once you get into the `metadata` you’ll notice the
    templating begins.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are unfamiliar with the structure of Kubernetes Deployments, you can
    read about them in the [Kubernetes documentation](https://oreil.ly/aIuIE).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The `include` template function enables including the output of one template
    in another template, and this works in pipelines. The first argument to the `include`
    function is the name of the template to use. The `.` passed in as the second argument
    is the root object. This is passed in so the properties and functions on the root
    object can be used within the called template.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '*anvil.fullname* and *anvil.labels* are two reusable templates included in
    the chart via the *_helpers.tpl* file. (The _ at the start of the name causes
    it to bubble up to the top of directory listings so you can easily find it among
    your templates; Helm does not render them into Kubernetes manifests but does make
    templates in them available for use.) *anvil.fullname* provides a name based on
    the name chosen when the chart is instantiated, and *anvil.labels* provides labels
    following Kubernetes best practices. The functions are covered in more depth in
    [Chapter 5](ch05.xhtml#developing_templates).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*anvil.fullname* 和 *anvil.labels* 是通过 *_helpers.tpl* 文件在图表中包含的两个可重用模板。（名称开头的下划线会使它在目录列表中排在顶部，因此您可以轻松找到它，尽管
    Helm 不会将它们渲染为 Kubernetes 清单，但确实使这些模板可供使用。）*anvil.fullname* 提供基于实例化图表时选择的名称，而 *anvil.labels*
    遵循 Kubernetes 最佳实践提供标签。这些函数在 [第 5 章](ch05.xhtml#developing_templates) 中有更详细的介绍。'
- en: 'After the `metadata` section of the template is the `spec` section, which reads
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的 `metadata` 部分之后是 `spec` 部分，内容如下：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO3-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_building_a_chart_CO3-1)'
- en: The location and version of the container image is configurable via values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的位置和版本可以通过值进行配置。
- en: The `spec` section completes the deployment. Most of this section is filling
    in data with the properties on `.Values`. There are a few elements that are hardcoded,
    such as the ports used to expose the application. Anvil is exposed over HTTP on
    port 80, so we do not need to change the port. If your containers are exposed
    on different ports, you will need to make changes here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec` 部分完成了部署。大部分内容填充在 `.Values` 的属性中。有一些元素是硬编码的，例如用于公开应用程序的端口。Anvil 在端口 80
    上通过 HTTP 公开，因此我们不需要更改端口。如果您的容器公开在不同的端口上，您需要在这里进行更改。'
- en: The value of `image` for the container is set using values. You won’t find the
    location of the image hardcoded here. This is useful for those cases where the
    image location needs to be set to a different location when a chart is instantiated.
    It means we need to change the location in the default values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的 `image` 值是使用值设置的。您不会在这里找到硬编码的镜像位置。这对于在实例化图表时需要将镜像位置设置为不同位置的情况非常有用。这意味着我们需要在默认值中更改位置。
- en: The properties on `.Values` are computed based on a number of factors. The default
    values and starting point are based on the values provided by the *values.yaml*
    file in the chart. The *values.yaml* file is covered in the next section. These
    values can be overridden by values passed in when the chart is instantiated. The
    *helm* CLI has flags to pass in values directly (i.e., `--set`, `--set-file`,
    and `--set-string`) or to pass in a file with values (i.e., `-f` or `--values`).
    The values are merged together, with those being passed in later taking precedence.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`.Values` 上的属性是基于多个因素计算的。默认值和起点基于图表中 *values.yaml* 文件提供的值。*values.yaml* 文件将在下一节中介绍。这些值可以被在实例化图表时传入的值覆盖。*helm*
    CLI 有用于直接传递值的标志（即 `--set`、`--set-file` 和 `--set-string`），或者传递一个包含值的文件（即 `-f` 或
    `--values`）。这些值被合并在一起，后传入的值优先。'
- en: Templates are a large topic and typically make up the bulk of a chart. [Chapter 5](ch05.xhtml#developing_templates)
    is dedicated to templates.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是一个广泛的主题，通常占据图表的大部分。[第 5 章](ch05.xhtml#developing_templates) 专门讨论模板。
- en: Using the Values File
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Values 文件
- en: When someone instantiates an application in a Kubernetes cluster from a chart,
    they don’t need to supply all the values used in the templates. If they did, it
    would provide for a difficult user experience. This is where the *values.yaml*
    file comes in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人在 Kubernetes 集群中从图表实例化应用程序时，并不需要提供模板中使用的所有值。如果他们这样做了，会导致用户体验困难。这就是 *values.yaml*
    文件的作用所在。
- en: Charts include a *values.yaml* file that sits alongside the *Chart.yaml* file
    in the root of a chart. The *values.yaml* file contains the default values used
    by the chart, and it is a form of documentation for the custom values that can
    be passed into a chart.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图表包括一个 *values.yaml* 文件，与根目录中的 *Chart.yaml* 文件并列。*values.yaml* 文件包含图表使用的默认值，并且它是可以传递给图表的自定义值的一种形式文档化。
- en: '*values.yaml* is an unstructured YAML file. There are some common and useful
    practices, which will be covered shortly, but nothing is required in the format
    of the YAML. This enables chart creators to provide a structure and information
    that works well for them. A *values.yaml* file can contain numerous things, from
    simple substitution for Kubernetes manifest properties to elements needed for
    application-specific business logic.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*values.yaml*是一个非结构化的YAML文件。有一些常见和有用的做法，很快将介绍，但格式中没有必需的内容。这使图表创建者能够提供适合他们的结构和信息。*values.yaml*文件可以包含许多内容，从用于Kubernetes清单属性的简单替换到需要特定于应用程序的业务逻辑元素。'
- en: Container Images
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像
- en: 'The opening part of the *values.yaml* file created by `helm create` contains
    the image information along with some opening documentation and information on
    replicas:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm create`创建的*values.yaml*文件的开头部分包含有关图像信息以及一些开头文档和副本信息：'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_building_a_chart_CO4-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_building_a_chart_CO4-1)'
- en: The location of the image. It has been updated to reflect the location of Anvil.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的位置。已更新以反映Anvil的位置。
- en: '[![2](Images/2.png)](#co_building_a_chart_CO4-2)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_building_a_chart_CO4-2)'
- en: A policy of `IfNotPresent` means that the image will be cached in the Kubernetes
    cluster by the version being used. `Always` is another option that bypasses the
    cache and always downloads from the repository.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`IfNotPresent`策略意味着将使用正在使用的版本在Kubernetes集群中缓存镜像。`Always`是另一个选项，它会绕过缓存并始终从存储库下载。'
- en: '[![3](Images/3.png)](#co_building_a_chart_CO4-3)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_building_a_chart_CO4-3)'
- en: By default this chart uses the `appVersion` as the tag. If an image tag is specified,
    it is used instead of the `appVersion`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此图表使用`appVersion`作为标记。如果指定了镜像标记，则使用它而不是`appVersion`。
- en: '[![4](Images/4.png)](#co_building_a_chart_CO4-4)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_building_a_chart_CO4-4)'
- en: A list of pull secrets is used when credentials are needed to access a container
    registry location that is protected with a username and password.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要凭据访问受用户名和密码保护的容器注册表位置时，使用拉取凭据列表。
- en: This chart and the values represent an application bundled as a single image.
    The patterns used in the *values.yaml* file are designed with that in mind. For
    example, there is only one image location. If your applications have multiple
    images, each image would have a section containing much of the information here.
    This includes `replicaCount`, which is the number of `replicas` Kubernetes will
    use when the `Deployment` is created.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表及其值代表打包为单个镜像的应用程序。在*values.yaml*文件中使用的模式考虑到这一点。例如，只有一个镜像位置。如果您的应用程序有多个镜像，则每个镜像将有一个包含大部分信息的部分。这包括`replicaCount`，这是创建`Deployment`时Kubernetes将使用的副本数。
- en: The `image` section contains details about the image. The `repository` contains
    the location of the image to use while the `pullPolicy` tells Kubernetes how often
    to fetch or cache the images. If a moving tag, such as `stable`, is used, the
    `pullPolicy` should be set to `Always` so that changes are picked up. Since a
    version is being used, the default `pullPolicy` is set to `IfNotPresent` so that
    a cached version can be used if available. The `tag` property provides an opportunity
    to set a tag that is different from the `appVersion` set in the *Chart.yaml* file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`部分包含有关镜像的详细信息。`repository`包含要使用的镜像位置，而`pullPolicy`告诉Kubernetes多久获取或缓存镜像。如果使用像`stable`这样的移动标签，则应将`pullPolicy`设置为`Always`，以便捕获更改。由于正在使用版本，因此默认的`pullPolicy`设置为`IfNotPresent`，以便在可用时可以使用缓存版本。`tag`属性提供了设置与*Chart.yaml*文件中设置的`appVersion`不同的标记的机会。'
- en: You might notice there is no method to set a digest when fetching an image.
    Digests can be different when images are in different repositories. For example,
    if the Anvil image were copied from Docker Hub to Quay, another image repository,
    the digest would change for the same image even if the tag and content remained
    the same. [Chapter 5](ch05.xhtml#developing_templates) provides an example of
    adding in support for a digest to a chart, if that is desired.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到在获取镜像时没有设置摘要的方法。当图像位于不同的存储库中时，摘要可能不同。例如，如果将Anvil镜像从Docker Hub复制到Quay，另一个图像存储库，则对于相同的图像，即使标签和内容保持不变，摘要也会更改。如果需要，在图表中添加对摘要的支持的示例将在[第5章](ch05.xhtml#developing_templates)中提供。
- en: If you need to pull an image from a container registry with access controls,
    Kubernetes needs to know how to do that. This happens through the use of pull
    secrets. `imagePullSecrets` allows you to list the names of pull secrets with
    access to private registries. Reference the [documentation for creating a pull
    secret](https://oreil.ly/BL-VO).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated chart has some security considerations built in that can be enabled
    or otherwise configured. A service account for the chart instance is created by
    default, while the other options are opt-in. The following is what is generated
    by `helm` `create`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will notice that most of the properties in the configuration are comments
    and are inactive. When the chart is rendered with the values as comments, there
    is no value for those properties. The value is empty. By having a structure and
    values as comments the chart is documenting the structure and default values that
    can be used but isn’t turning on those features.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Services
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next section of the *values.yaml* file deals with exposing the application
    for others to consume:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In Kubernetes there are two built-in objects you can use to expose applications.
    The first is a `Service`. The `service` property will let you select the type
    of `Service` being used. While `ClusterIP` is used by default, other options such
    as `NodePort` and `LoadBalancer` can be used. The few lines of YAML in the `service`
    section are paired with the generated *service.yaml* template to create a full
    Service manifest to upload to Kubernetes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The second built-in object is the `Ingress` manifest, which can be paired with
    a `Service`, and the chart has the capability to generate them. `Ingress` configuration
    provides a means to show off a common pattern found in charts: the use of an `enabled`
    property to turn features on and off. In this case `ingress.enabled` is set to
    `false`. When Helm renders the templates and sees a value of false, the `Ingress`
    manifest is skipped. This is due to the use of an `if` logic statement in the
    `Ingress` template found in the generated *ingress.yaml* file.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Resource Limits
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run applications in production, it is a good practice to set resource
    limits. This prevents, for example, a memory leak in one container from disrupting
    other containers. When a chart author creates a chart that others are going to
    use, they may not know where it will be installed and how many resources will
    be available there. Could this be installed on a laptop by a developer or someone
    testing out the chart? Or, might this be installed on large production servers?
    To handle this variance in environment, the recommendation is to put in resource
    limits and then turn them into comments. This can be found in the next section
    of the *values.yaml* file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Those who install applications use these numbers as recommendations when they
    instantiate a chart. These numbers are the default values that have been set for
    a simple Nginx setup as it was generated. They work for the Anvil application.
    If your application will need different values, you will need to update these.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Workloads have the ability to specify details about where they are executed
    in a cluster by the settings node selector, tolerations, and affinity. Although
    these more advanced features are often not used, it is a good idea to include
    them in a chart for those who need them. The generated *values.yaml* file and
    templates take this into account. The following example has generated YAML keys
    for these advanced features. The values are empty by default with an expectation
    that the person who installs the chart will set values as appropriate for their
    installation:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Packaging the Chart
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can package the files and directories of a chart into a single archive
    file. This is useful for many reasons, including:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: For distribution to other people. One of the powerful aspects of a package manager
    is where someone with knowledge of running an application packages it up so that
    others, who don’t have intimate knowledge of the platform or application, can
    run it.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a version of an application needs to be taken through a multienvironment
    test process. An example of this process is where there are development, quality
    assurance (QA), and production environments and the application needs to pass
    QA prior to going into production.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When developing a multiservice application and developers need to run services
    built or otherwise handled by others as part of their development setup.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each of these situations it is often simpler to pass around a single file
    for the chart than a directory structure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Chart versions bring another wrinkle to the way you distribute and consume charts.
    You or someone consuming your chart may need to use different versions of the
    chart. This is why it’s useful to store and share different versions using chart
    repositories or Open Container Initiative (OCI) registries, covered in [Chapter 7](ch07.xhtml#chart_repositories).
    In these environments, storing and sharing many files in a collection of directory
    structures for each version is far from simple.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Helm has the ability to build a chart archive. Each chart archive is a gzipped
    TAR file with the extension *.tgz*. Any tool that can create, extract, and otherwise
    work on gzipped TAR files will work with Helm’s chart archives.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'When Helm generates the archive files, they are named using a pattern of *`chart
    name`-`version`.tgz*. Helm expects this same pattern when consuming them. The
    *`chart name`* is the name you will find inside the *Chart.yaml* file and the
    *`version`* is the chart version. This enables multiple versions of the same chart
    to be stored alongside each other. You can package Anvil as an archive by running:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case `anvil` is the path to the location where the *anvil* chart source
    is located. By default, the `helm package` command will place the archive in the
    directory you were in when you ran the command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some useful flags you can use when packaging a chart:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`--dependency-update` (`-u`)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Tells Helm to update the dependent charts prior to creating the archive. This
    will update the *Chart.lock* file and place a copy of the dependent charts in
    the *chart* directory. Dependencies are covered in more detail in [Chapter 6](ch06.xhtml#advanced_charts).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`--destination` (`-d`)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Enables you to set the location to put the chart archive if it is different
    from the current working directory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`--app-version`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Can be used to set the `appVersion` property of the *Chart.yaml* file. This
    is especially useful if you create new releases of the chart for each new release
    of your application running within the container and there is no other change
    to the chart. Automation can use a flag like this as part of the process to build
    the new version.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`--version`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Updates the chart’s version. This is useful if you’re updating the `appVersion`
    using the command line as part of the process to package a chart.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Flags for Pretty Good Privacy (PGP) signing charts
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Helm charts can be cryptographically signed and verified. The `package` command
    has flags for the signing portion of the process, while commands like `install`
    and `upgrade` have flags for the verification portion of the process. [Chapter 6](ch06.xhtml#advanced_charts)
    covers this process.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you will have files in a chart directory that you do not want to
    include in the chart archive. Optionally, in a chart directory there can be a
    *.helmignore* file. This is similar to a *.gitignore* file for Git. The `helm
    create` command used earlier created one with the following contents:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Many of these extensions and patterns may look familiar because they come from
    various version control systems and code editors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: When the chart archive is created, you usually don’t want to include elements
    like your version control system data. The *.helmignore* file provides a place
    to specify what to skip. This file needs to be at the top level of the chart.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Helm is designed to work with the archive files the same way it works with directory
    structures. Commands like `helm install` and `helm lint`, which will be covered
    shortly, can be passed an archive file the same way they can be passed a directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Linting Charts
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing charts, especially when working with YAML templates, it can
    be easy to make a mistake or miss something. To help you catch errors, bugs, style
    issues, and other suspicious elements, the Helm client includes a linter. This
    linter can be used during chart development and as part of any testing processes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the linter, use the `lint` command on a chart as a directory or a packaged
    archive:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line is the command you run, while the following lines are output
    by Helm. In this case there were no issues. You could use this command on an archive
    file like the one in the previous section. To do that, change the `anvil` argument,
    set to the directory location for the chart, to the archive file *anvil-0.1.0.tgz*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is able to lint multiple charts in a single command. For example,
    if you had a second chart called *mychart* and wanted to lint it alongside *anvil*,
    you could run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The three levels of actionable feedback about charts Helm provides are info,
    warning, and errors. Info-level feedback is informational; charts can be installed
    with info-level feedback. Info-level feedback causes Helm to have an exit code
    of 0\. Error-level feedback means there is a problem with the chart. If a chart
    generates an Invalid manifest for Kubernetes, such as YAML being invalid, Helm
    will generate an error. Errors cause Helm to have a nonzero exit code, which is
    useful to catch issues in automated testing tools. In the middle are warning messages.
    These messages address findings that may cause issues. By default, warning messages
    cause Helm to have an exit code of 0, but Helm adds a `--strict` flag that causes
    the exit codes to be nonzero. You can choose how to handle these in automation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In this case there were no issues found with the *anvil* chart. A default chart,
    created by `helm create`, will have a single info message about a missing `icon`
    property in the *Chart.yaml* file. This is an info-level notice so that people
    are aware it is missing. The missing icon will not affect the operation of the
    chart, but it will affect the way it is displayed in user interfaces.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a simple chart for your application is straightforward when you use
    the `helm create` command. Even when your applications are more complicated, the
    structure of charts is able to accommodate them, and the `helm create` command
    can help you. With a few minor modifications made in this chapter you can install
    the Anvil chart using `helm install` and see the custom application running in
    your cluster. You can use this same flow to create your own charts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter you will learn about creating templates with an emphasis
    on how the template language works and how you can apply it to Kubernetes templates
    stored in charts. Templates are usually the largest part of a chart where you
    will spend the most time. Understanding what you have available to you when you
    create templates will make the process of developing them faster and easier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
