- en: Chapter 15\. Troubleshooting Pods and Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When operating an application in a production Kubernetes cluster, failures are
    almost inevitable. You can’t completely leave this job up to the Kubernetes administrator—it’s
    your responsibility as an application developer to be able to troubleshoot issues
    for the Kubernetes objects you designed and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at troubleshooting strategies that can help with
    identifying the root cause of an issue so that you can take action and correct
    the failure appropriately. The strategies discussed here start with the high-level
    perspective of a Kubernetes object and then drill into more detail as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most cases, creating a Pod is no issue. You simply emit the `run`, `create`,
    or `apply` commands to instantiate the Pod. If the YAML manifest is formed properly,
    Kubernetes accepts your request, so the assumption is that everything works as
    expected. To verify the correct behavior, the first thing you’ll want to do is
    to check the Pod’s high-level runtime information. The operation could involve
    other Kubernetes objects like a Deployment responsible for rolling out multiple
    replicas of a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving High-Level Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To retrieve the information, run either the `kubectl get pods` command for just
    the Pods running in the namespace or the `kubectl get all` command to retrieve
    the most prominent object types in the namespace (which includes Deployments).
    You will want to look at the columns `READY`, `STATUS`, and `RESTARTS`. In the
    optimal case, the number of ready containers matches the number of containers
    you defined in the `spec`. For a single-container Pod, the `READY` column would
    say 1/1.
  prefs: []
  type: TYPE_NORMAL
- en: The status should say `Running` to indicate that the Pod entered the proper
    life cycle state. Be aware that it’s totally possible that a Pod renders a `Running`
    state, but the application isn’t actually working properly. If the number of restarts
    is greater than 0, then you might want to check the logic of the liveness probe
    (if defined) and identify the reason a restart was necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Pod observes the status `ErrImagePull` and makes 0/1 containers
    available to incoming traffic. In short, this Pod has a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After working with Kubernetes for a while, you’ll automatically recognize common
    error conditions. [Table 15-1](#common_pod_error_statuses) lists some of those
    error statuses and explains how to fix them.
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. Common Pod error statuses
  prefs: []
  type: TYPE_NORMAL
- en: '| Status | Root cause | Potential fix |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ImagePullBackOff` or `ErrImagePull` | Image could not be pulled from registry.
    | Check correct image name, check that image name exists in registry, verify network
    access from node to registry, ensure proper authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `CrashLoopBackOff` | Application or command run in container crashes. | Check
    command executed in container, ensure that image can properly execute (e.g., by
    creating a container with Docker). |'
  prefs: []
  type: TYPE_TB
- en: '| `CreateContainerConfigError` | ConfigMap or Secret referenced by container
    cannot be found. | Check correct name of the configuration object, verify the
    existence of the configuration object in the namespace. |'
  prefs: []
  type: TYPE_TB
- en: Inspecting Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might not encounter any of those error statuses. But there’s still a chance
    of the Pod having a configuration issue. You can retrieve detailed information
    about the Pod using the `kubectl describe pod` command to inspect its events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output belongs to a Pod that tries to mount a Secret that doesn’t
    exist. Instead of rendering a specific error message, the Pod gets stuck with
    the status `ContainerCreating`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another helpful command is `kubectl get events`. The output of the command
    lists the events across all Pods for a given namespace. You can use additional
    command-line options to further filter and sort events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes troubleshooting won’t be enough. You may have to dig into the application
    runtime behavior and configuration in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Using Port Forwarding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In production environments, you’ll operate an application in multiple Pods controlled
    by a ReplicaSet. It’s not unusual that one of those replicas experiences a runtime
    issue. Instead of troubleshooting the problematic Pod from a temporary Pod from
    within the cluster, you can also forward the traffic to a Pod through a tunneled
    HTTP connection. This is where the [`port-forward` command](https://kubernetes.io/docs/reference/kubectl/generated/kubectl_port-forward/)
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate the behavior. The following command creates a new Deployment
    running nginx in three replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting Pod will have unique names derived from the name of the Deployment.
    Say the Pod `nginx-595dff4799-ph4js` has an issue you want to troubleshoot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `port-forward` command forwards HTTP connections from a local port to a
    port exposed by a Pod. This exemplary command forwards port 2500 on your local
    machine to the container port 80 running in the Pod `nginx-595dff4799-ph4js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `port-forward` command does not return. You have to open another terminal
    to perform calls to the Pod via port forwarding. The following command simply
    checks if the Pod is accessible from your local machine using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP response code 200 clearly shows that we can access the Pod from outside
    of the cluster. The `port-forward` command is not meant to run for a long time.
    Its primary purpose is for testing or troubleshooting a Pod without having to
    expose it with the help of a Service.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can interact with the container for a deep-dive into the application’s runtime
    environment. The next sections will discuss how to inspect logs, open an interactive
    shell to a container, and debug containers that do not provide a shell.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The commands described in the following sections apply to init and sidecar containers
    as well. Use the `-c` or `--container` command line flag to target a specific
    container if you are running more than a single one. See [Chapter 8](ch08.xhtml#multi_container_pods)
    for more information on multi-container Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When troubleshooting a Pod, you can retrieve the next level of details by downloading
    and inspecting its logs. You may or may not find additional information that points
    to the root cause of a misbehaving Pod, but it’s definitely worth a look. The
    YAML manifest shown in [Example 15-1](#pod_failing_shell) defines a Pod running
    a shell command.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-1\. A Pod running a failing shell command
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the object, the Pod fails with the status `CrashLoopBackOff`.
    Running the `logs` command reveals that the command run in the container has an
    issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `logs` command provides two helpful options. The option `-f` streams the
    logs, meaning you’ll see new log entries as they’re being produced in real time.
    The option `--previous` gets the logs from the previous instantiation of a container,
    which is helpful if the container has been restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Opening an Interactive Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If any of the previous commands don’t point you to the root cause of the failing
    Pod, it’s time to open an interactive shell to a container. As an application
    developer, you’ll know best what behavior to expect from the application at runtime.
    Inspect the running processes by using the Unix or Windows utility tools, depending
    on the image run in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Say you encounter a situation where a Pod seems to work properly on the surface,
    as shown in [Example 15-2](#pod_current_date).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2\. A Pod periodically writing the current date to a file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the Pod, you check the status. It says `Running`; however, when
    making a request to the application, the endpoint reports an error. Next, you
    check the logs. The log output renders an error message that points to a nonexistent
    directory. Apparently, the directory that the application needs hasn’t been set
    up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exec` command opens an interactive shell to further investigate the issue.
    In the following code, we’re using the Unix tools `mkdir`, `cd`, and `ls` inside
    of the running container to fix the problem. Obviously, the better mitigation
    strategy is to create the directory from the application or provide an instruction
    in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Interacting with a Distroless Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some images run in containers are designed to be very minimal for security reasons.
    For example, the [Google distroless](https://github.com/GoogleContainerTools/distroless)
    images don’t have any Unix utility tools preinstalled. You can’t even open a shell
    to a container, as it doesn’t come with a shell.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating security best practices for container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shipping container images with accessible shells and running with the `root`
    user is commonly discouraged as these aspects can be used as potential attack
    vectors. Check out the [CKS certification](https://training.linuxfoundation.org/certification/certified-kubernetes-security-specialist/)
    to learn more about security concerns in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: One of Google’s distroless images is `k8s.gcr.io/pause:3.1`, shown in [Example 15-3](#pod_ephemeral_container).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3\. Running a distroless image
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following `exec` command, the image doesn’t provide a
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes offers the concept of [ephemeral containers](https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/).
    Those containers are meant to be disposable and have no resilience features like
    probes. You can deploy an ephemeral container for troubleshooting minimal containers
    that would usually not allow the use of the `exec` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes 1.18 introduced a new `debug` command that can inject an ephemeral
    container to a running Pod for debugging purposes. The following command adds
    the ephemeral container running the image `busybox` to the Pod named `minimal-pod`
    and opens an interactive shell for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting Resource Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying software to a Kubernetes cluster is only the start of operating an
    application long term. Developers need to understand their applications’ resource
    consumption patterns and behaviors, with the goal of providing a scalable and
    reliable service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Kubernetes world, monitoring tools like [Prometheus](https://prometheus.io/)
    and [Datadog](https://www.datadoghq.com/) help with collecting, processing, and
    visualizing information over time. The exam does not expect you to be familiar
    with third-party monitoring, logging, tracing, and aggregation tools; however,
    it is helpful to have a basic understanding of the underlying Kubernetes infrastructure
    responsible for collecting usage metrics. The following are examples of typical
    metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of nodes in the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health status of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node performance metrics such as CPU, memory, disk space, network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod-level performance metrics such as CPU and memory consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This responsibility falls to the [metrics server](https://github.com/kubernetes-sigs/metrics-server),
    a cluster-wide aggregator of resource usage data. As shown in [Figure 15-1](#metrics-server),
    kubelets running on nodes collect metrics and send them to the metrics server.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1501](Images/ckd2_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Data collection for the metrics server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The metrics server stores data in memory and does not persist data over time.
    If you are looking for a solution that keeps historical data, then you need to
    look into commercial options. Refer to the documentation for more information
    on its [installation process](https://github.com/kubernetes-sigs/metrics-server?tab=readme-ov-file#installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using Minikube as your practice environment, [enabling the metrics-server
    add-on](https://kubernetes.io/docs/tutorials/hello-minikube/#enable-addons) is
    straightforward using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now query for metrics of cluster nodes and Pods with the `top` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It takes a couple of minutes after the installation of the metrics server before
    it has gathered information about resource consumption. Rerun the `kubectl top`
    command if you receive an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed strategies for approaching failed or misbehaving Pods. The main
    goal is to diagnose the root cause of a failure and then fix it by taking the
    right action. Troubleshooting Pods doesn’t have to be hard. With the right `kubectl`
    commands in your tool belt, you can rule out root causes one by one to get a clearer
    picture.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes ecosystem provides a lot of options for collecting and processing
    metrics of your cluster over time. Among those options are commercial monitoring
    tools like Prometheus and Datadog. Many of those tools use the metrics server
    as the source of truth for those metrics. We also briefly touched on the installation
    process and the `kubectl top` command for retrieving metrics from the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Know how to debug Pod objects
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we mainly focused on troubleshooting problematic Pods and containers.
    Practice all relevant `kubectl` commands that can help with diagnosing issues.
    Refer to the [Kubernetes documentation](https://kubernetes.io/docs/tasks/debug/debug-application/)
    to learn more about debugging other Kubernetes resource types.
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to retrieve and interpret resource metrics
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring a Kubernetes cluster is an important aspect of successfully operating
    in a real-world environment. You should read up on commercial monitoring products
    and which data the metrics server can collect. You can assume that the exam environment
    provides you with an installation of the metrics server. Learn how to use the
    `kubectl top` command to render Pod and node resource metrics and how to interpret
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_011.xhtml#appendix_a_troubleshooting_pods_containers).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will practice your troubleshooting skills by inspecting
    a misconfigured Pod. Navigate to the directory *app-a/ch15/troubleshooting* of
    the checked-out GitHub repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Pod from the YAML manifest in the file *pod.yaml*. Check the Pod’s
    status. Do you see any issue?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Render the logs of the running container and identify an issue. Shell into the
    container. Can you verify the issue based on the rendered log message?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suggest solutions that can fix the root cause of the issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will inspect the metrics collected by the metrics server. Navigate to the
    directory *app-a/ch15/stress-test* of the checked-out GitHub repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    The current directory contains the YAML manifests for three Pods, *stress-1-pod.yaml*,
    *stress-2-pod.yaml*, and *stress-3-pod.yaml*. Inspect those manifest files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the namespace `stress-test` and the Pods inside of the namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the data available through the metrics server to identify which of the Pods
    consumes the most memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Prerequisite:* You will need to install the metrics server if you want to
    be able to inspect actual resource metrics. You can find [installation instructions](https://github.com/kubernetes-sigs/metrics-server#installation)
    on the project’s GitHub page.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
