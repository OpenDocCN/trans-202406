- en: Chapter 2\. Network Security Testing Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Security testing* is a broad term that means a lot of different things. Often,
    penetration testing is done remotely, over the network. Not all security testing
    is penetration testing, though. Sometimes, development teams may want applications
    tested, including web applications. These web applications may include a number
    of network services. Sometimes, you may be testing not only networked applications
    but devices. Both the application and the device may need to be stress-tested
    to ensure it can handle types of traffic or even large volumes of traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how network protocol stacks are defined is essential if you want
    to perform any sort of network-based security testing. One way of defining protocols
    and, more specifically, their interactions, is using the Open Systems Interconnection
    (OSI) model. Using the OSI model, we can break the communications into different
    functional elements and see clearly where different pieces of information are
    added to the network packets as they are being created. Additionally, you can
    see the interaction from system to system across the functional elements.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing is not only about generating a lot of traffic and sending it
    at an application or device. In some cases, you may stress an application or device
    by sending it data that isn’t expected. Applications, even applications running
    on limited-use devices (think Internet of Things like thermostats, locks, light
    switches), have an expectation about the type and structure of data that would
    be received. Sending something other than what was expected may cause an application
    failure. This is something useful to know. This is another type of stress testing,
    since you are stressing the logic of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This is part of the reason why understanding how communications protocols are
    constructed. Performing network security testing requires understsanding how the
    different layers of the communications model come together. Once you have done
    that, you can think about how you want to approach security testing. Of course,
    it’s also helpful to understand what security testing is, so let’s start there
    then we can get into how the communications stacks work.
  prefs: []
  type: TYPE_NORMAL
- en: Security Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When many people hear the term *security testing*, they may think of penetration
    testing where the goal is to get into systems and acquire the highest privileges
    possible. Security testing isn’t entirely about popping boxes. In fact, you might
    suggest that the majority of security testing isn’t penetration testing. There
    are just so many areas of protecting systems and software that aren’t related
    to what would commonly be thought of as penetration testing. Before we start talking
    about what we can do with Kali Linux when it comes to network security testing,
    we should go over what security is so you can better understand what testing means
    in this context.
  prefs: []
  type: TYPE_NORMAL
- en: 'When professionals, and certainly certification organizations, talk about security,
    they make reference to what is commonly known as the *triad*. Some will add elements,
    but at the core of information security are three fundamentals: confidentiality,
    integrity, and availability. Anything that may impact one of these aspects of
    systems or software impacts the security of that software or system. Security
    testing will or should take all of those aspects into consideration and not the
    limited view that a penetration test may provide insight into.'
  prefs: []
  type: TYPE_NORMAL
- en: As you may know, the triad is can be represented as an equilateral triangle.
    The triangle is equilateral because all three elements are considered to have
    equal weight. Additionally, if any of the elements are lost, you no longer have
    a triangle. You can see a common representation in [Figure 2-1](#the_cia_triad),
    where all three sides are the same length. Every one of these elements is considered
    crucial for information to be considered reliable and trustworthy. These days,
    because businesses and people rely so heavily on information that is stored digitally,
    it’s essential that information be available, be confidential when necessary,
    and have integrity.
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig1.png](assets/lklx_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. The CIA triad
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Most businesses run on secrets. People also have secrets: their social security
    number, passwords they use, tax information, medical information, and a variety
    of other pieces of data. Businesses need to protect their intellectual property,
    for one thing. They may have many trade secrets that could have negative impacts
    on the business if the information were to get out of the organization. Keeping
    this information secret, regardless of what it is, is *confidentiality*. Anytime
    information can be retrieved by anyone who doesn’t have permission to retrieve
    it, confidentiality has been breached. This is the primary element that has been
    impacted in countless thefts of data, from Target, to the Office of Personnel
    Management, to Equifax and Sony. When consumer information is stolen, the confidentiality
    of that information has been compromised. Modern ransomware attacks also impact
    confidentiality. Attackers will steal data with the threat of releasing it publicly.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, we expect that when we store something, it will be the same when
    we go to retrieve it. Corrupted or altered data may be caused by various factors,
    which may not necessarily be malicious in nature. Just because we talk about security
    doesn’t always mean we are talking about malicious behavior. Certainly, the cases
    I mentioned previously were malicious. However, bad or failing memory can cause
    data corruption on a disk. I say this from personal experience. Similarly, failing
    hard drives or other storage media can cause data corruption. Of course, in some
    cases malicious and deliberate actions will lead to corrupted or incorrect data.
    When that information has been corrupted, no matter the cause, it’s a failure
    or breach of integrity. *Integrity* is entirely about something being in a state
    you reasonably expect it to be in. Consider ransomware again. When data has been
    encrypted by an attacker, it has lost its integrity since it’s not in the state
    it was when the user last accessed it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s consider *availability*. If I kick the plug to your computer
    out of the wall, likely falling to the floor and maybe hitting my head in the
    process, your computer will become unavailable (as long as we are talking about
    a desktop system and not a system with a battery). Similarly, if you have a network
    cable and the clip has come off such that the connector won’t stay in the wall
    jack or in the network interface card, your system will be unavailable on the
    network. This may impact you, of course, and your ability to do your job, but
    it may also impact others if they need anything that’s on your computer. Anytime
    there is a server failure, that’s an impact to availability. If an attacker can
    cause a service or entire operating system to fail, even temporarily, that’s an
    impact to availability, which can have serious ramifications to the business.
    It may mean consumers can’t get to advertised services. It may mean a lot of expenditure
    in manpower and other resources to keep the services running and available, as
    in the case of the banks that were hit with enormous, sustained, and lengthy denial-of-service
    attacks. While the attempt at an availability failure wasn’t successful, there
    was an impact to the business in fighting it. One more visit to the house of ransomware
    to say that encrypted data when you don’t have the decryption key is an availability
    problem. If it’s not readable, it’s not available, at least in a usable form.
  prefs: []
  type: TYPE_NORMAL
- en: This raises the issue of the limitations of the CIA triad. Donn Parker proposed
    three additional properties of information security to add to the three properties
    of the CIA triad. According to Parker, security also extends to Control, Authenticity,
    and Utility. Control is about possession. If I have posssession of a resource,
    I am in control of it. Authenticity is about verification. Is the item in question
    what it is supposed to be? This includes the source of material, including emails.
    Digital signatures are ways of verifying authenticity. Finally, utility is whether
    something is useful. This is perhaps a better term for when data has been encrypted
    by a ransomware threat actor. Technically, the files are available, they just
    aren’t very useful in the form they are in.
  prefs: []
  type: TYPE_NORMAL
- en: Testing anything related to these elements is security testing, no matter what
    form that testing may take. When it comes to network security testing, we may
    be testing service fragility, encryption strength, and other factors. What we
    will be looking at when we talk about network testing is a set of stress-testing
    tools to start with. We will also look at other tools that are sometimes known
    to cause network failures. While a lot of bugs in the network stacks of operating
    systems were likely fixed years ago, you may sometimes run into lighter weight,
    fragile devices that may be attached to the network. These devices may be more
    susceptible to these sorts of attacks. These devices may include printers, Voice
    over IP phones, thermostats, refrigerators, and nearly countless other devices
    that are being connected, more and more, to networks these days.
  prefs: []
  type: TYPE_NORMAL
- en: Network Security Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We live by the network; we die by the network. How much of your personal information
    is currently either stored outright or at least available by way of the internet,
    whether your information is stored on a device on your local network, the enterprise
    network of your employer or somewhere else on the internet, a place commonly called
    *the cloud*? When we live our lives expecting everything to be available and accessible
    by way of the network, it’s essential that we assure that our devices are capable
    of sustaining attack.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we do any testing at all, we need to talk about the importance of monitoring.
    If you are doing any of the testing we are talking about for your company or a
    customer, ideally you aren’t taking anything down deliberately unless you have
    been asked to. However, no matter how careful you are, there is always the possibility
    that something bad may happen and services or systems may get knocked over. This
    is why it’s essential to communicate with the people who own the systems so they
    can keep an eye on their systems and services. Businesses are not going to want
    to impact their customers, so they will often want staff to be available to restart
    services or systems if that’s necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some companies may want to test their operations staff, meaning they expect
    you to do what you can to infiltrate and knock over systems and services, without
    doing any long-term or permanent damage. This is commonly called red teaming.
    In this case, you wouldn’t communicate with anyone but the management who hired
    you. In most cases, though, companies are going to want to make sure they keep
    their production environment operational. If part of the operations staff or its
    management is in on it, trying to see whether they are able to detect the infiltration,
    the testing is called purple teaming. The operations staff is the blue team, the
    attack team is the red team. You put the two together, you get a purple team.
  prefs: []
  type: TYPE_NORMAL
- en: If the operations staff is involved, they will want to have some sort of monitoring
    in place. This could be watching logs, which is generally advisable. However,
    logs are not always reliable. After all, if you are able to crash a service, the
    service may not have long enough to write anything useful to the logs before failing.
    This does not mean, though, that you should discount logs. Keep in mind that the
    purpose of security testing is to help improve the security posture of the company
    you are working for. The logs may be essential to get hints as to what is happening
    with the process before it fails. Services may not fail in the sense that the
    process stops, but sometimes the service may not behave as expected. This is where
    logs can be important, to get a sense of what the application was trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: There may be a watchdog in place. Watchdogs are sometimes used to ensure that
    a process stays up. Should the process fail, the PID would no longer appear in
    the process table, and the watchdog would know to restart that process. This same
    sort of watchdog capability can be used to determine whether the process has failed.
    Even if you don’t want the process restarted, just keeping an eye on the process
    table to see whether the process has failed will be an indicator if something
    has happened to the process.
  prefs: []
  type: TYPE_NORMAL
- en: With the older init system initialization, you could use the /etc/inittab file
    to specify processes that should be restarted on crashing. With the modern system
    initialization software systemd, you can configure services to automatically restart
    if they crash. This is done in the configuration file with the setting *Restart=*.
    You could set this parameter to *always* or maybe *on-failure*. Not all applications,
    though, are services. You could turn anything into a service by creating a systemd
    configuration file and starting/stopping the service using *systemctl*. You may
    not want to go through that process, though. You could use something like a Python
    script to automatically restart a process when it crashes. The script here generates
    a message when the process fails, then starts it up again. You just need to provide
    the executable name on the command line when you run the script.
  prefs: []
  type: TYPE_NORMAL
- en: +import sys from datetime import datetime import subprocess
  prefs: []
  type: TYPE_NORMAL
- en: 'cmd = sys.argv[1] retcode = 1 while retcode != 0: prog = subprocess.run(cmd)
    retcode = prog.returncode if retcode != 0: print(“Program failed at “, datetime.now())'
  prefs: []
  type: TYPE_NORMAL
- en: Runaway processes can start chewing up processor resources. As a result, looking
    at processor utilization and memory utilization is essential. This can be done
    using open source monitoring utilities. You can also use commercial software or,
    in the case of Windows or macOS, built-in operating system utilities for the monitoring.
    One popular monitoring program is Nagios Core. On one of my \ systems, I have
    Nagios Core installed. There is a commercial version of Nagios, which has long
    been an open source monitoring solution, but Nagios Core is still free and is
    available in many distribution repositories, including Ubuntu and Kali. In [Figure 2-2](#monitoring_resources),
    you can see the Services page, which shows the status of services on the host
    Nagios Core is running on. Without any additional configuration, Nagios monitors
    the number of processes, processor utilization, and service state of both the
    SSH and HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig2.png](assets/lklx_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Monitoring resources
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you aren’t getting the cooperation, for whatever reason, of the operations
    staff, and you don’t have direct access to the systems under test, you may need
    to be able to track at least the service state remotely. When you are using some
    of the network test tools that we’ll be talking about here, they may stop getting
    responses from the service being tested. This may or may not be a result of the
    service failing. It could be a problem with the monitoring or it could be some
    security mechanism in place to shut down network abuses. Manually verifying the
    service to ensure it is down is important.
  prefs: []
  type: TYPE_NORMAL
- en: Essential to Reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are testing and you notice that a service has failed, make sure you
    have noted, to the best of your ability, where the failure occurred. Telling a
    customer or your employer that a service failed isn’t very helpful because they
    won’t know how to fix it. Keeping detailed notes will help you when you get to
    reporting so you can tell them exactly what you were doing when the service failed
    if they need to be able to recreate it in order to resolve the problem. Specific
    times may allow them to find details in the logs, which can help them pinpoint
    the underlying issue.
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing can be done using a tool like *netcat* or even the *telnet* client.
    When you connect to a service port by using one of these tools, you will get an
    indication as to whether the service is responsive. This, of course, relies on
    you testing a network service rather than a local application. Doing this manual
    verification, especially if it’s done from a separate system to rule out being
    blocked or blacklisted, can help to rule out false positives. Ultimately, a lot
    of security testing can come down to ruling out false positives that result from
    the different tools that we use. Monitoring and validation are essential to make
    sure that what you are presenting to your employer or customer is valid as well
    as actionable. Remember, you are trying to help them improve their security posture,
    not just point out where things are broken.
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Donkey in the movie *Shrek* suggests, layers are important. Actually, Shrek
    says that ogres have layers, and Donkey says cakes have layers, but Shrek likens
    ogres to onions, and cake is better than onions. Plus, I still hear Eddie Murphy
    as Donkey saying cakes have layers. None of which is really the point, of course.
    Except for cake. Cake may be the point—because when we talk about networks and
    communications between systems, we usually talk about layers. If you think about
    a seven-layer cake, with thin layers of cake, you may be able to envision the
    way we think about networks. Plus, in order to envision the best process, you’d
    need to envision two slices of cake. Two slices of cake have to be better than
    one slice of cake, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-3](#osi_model_showing_system_to_system_communication) shows a simple
    representation of the seven layers of the OSI model and how each layer communicates
    with the same layer on remote systems. You can imagine that the lines between
    each of the layers is really icing and maybe jam, just to make it more interesting.
    Plus, the jam will help the layers adhere to one another since it’s sticky. Each
    layer on every system you are communicating with is exactly the same, so when
    you are sending a message from one slice of cake to the other slice of cake, it’s
    the matching layer from the sending cake to the receiving cake.'
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig3.png](assets/lklx_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. OSI model showing system-to-system communication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s think about it this way. Our first layer at the very bottom is the *physical
    layer*, so we can think of that as pistachio. Our pistachio (physical) layer is
    where we connect to the network or, in this case, the plate that the cake sits
    on. As with cake, nothing is between the physical layer of the system and the
    network. You take your network interface and plug a cable into it, connecting
    it on the other end into a jack. That’s all the physical layer. In our cake, the
    pistachio sits directly on the plate, with nothing between.
  prefs: []
  type: TYPE_NORMAL
- en: Our next layer, which has to pass through icing and jam so the operating system
    can distinguish between one layer and another, is dulce de leche (think caramel
    made from milk). This is our *data layer*. The addressing of this layer is done
    using the media access control (MAC) address. This address includes 3 bytes that
    belong to the vendor (sometimes referred to as the *organizationally unique identifier*,
    or OUI). The other 3 bytes, since the entire MAC address is 6 bytes long, are
    the unique identifier for your network interface. The two components together
    are the MAC address. Any communication on your local network has to happen at
    this layer. If I want to talk to you from my dulce de leche to your dulce de leche
    (because who else would understand dulce de leche but another dulce de leche),
    I would need to use the MAC address because it’s the only address that your network
    interface and my network interface understand. The address is physically wired
    into the interface itself, which is why it’s sometimes called the physical address.
    In [Example 2-1](#EX_2_1), you can see a MAC address in the second column from
    the output of the program *ifconfig*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. MAC address
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The next layer we come across, again crossing through our icing and jam to clearly
    distinguish one from the other, is Nilla wafer (vanilla), and our *network layer*.
    At the Nilla wafer layer (network), we address using IP addresses. This is also
    the address that enables us to pass outside our local network. The MAC address
    never passes outside the local network. The IP address does, though. Since we
    can communicate with different bakeries, all having cakes designed exactly like
    ours, using IP addresses, this is the layer that enables routing. It’s the routing
    address that allows us to get directions from one bakery to another by using the
    IP address. [Example 2-2](#EX_2_2) shows an IP address, which is comprised of
    4 bytes, sometimes known as *octets* because they are each 8 bits long. This is
    a version 4 IP address. Version 6 IP addresses are 16 bytes (128 bits) long, represented
    as hexadecimal values. As with the earlier example, this is from the output of
    *ifconfig*. You can see both IPv4 and IPv6 addresses here.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. IP address
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The fourth layer in our cake is the teaberry layer (*transport*). Yes, it’s
    going to be a strangely flavored cake, but stay with me. Plus, if you don’t know
    what teaberry is, you should find it. Teaberry gum is very good. So, the teaberry
    layer gives us ports. This is another form of addressing. Think about it this
    way. Once you get to the bakery, you need to know which shelf you are looking
    for. This is the same sort of thing with ports. Once you have found your bakery
    with the IP address, you then need to find the shelf in the bakery, which is your
    port. The port will connect you to a service (program) that is running and has
    attached itself to that shelf (port). There are well-known ports that particular
    services run on. These are registered, and while the services (e.g., web server)
    can bind to a different port and listen on that, the well-known port is common
    because it’s what everyone knows to look for.
  prefs: []
  type: TYPE_NORMAL
- en: At layer five, it becomes challenging, simply because this layer is not always
    well understood. The fifth layer is strawberry, because we need some fruit in
    our cake, even if it’s just fruit flavoring. This is the *session layer*. The
    session layer is all about coordinating long-standing communications to make sure
    everything is synchronized. You can think about it as the session layer making
    sure that when you and I are eating our slices of cake at the same time (communicating),
    we are going at the same pace, so we start and finish at the same time. If we
    need to stop and take a drink of water, the session layer will make sure we do
    that at the same time. If we want to drink milk rather than water, the session
    layer will make sure that we are completely in sync so that we can start and finish
    at the same time and essentially look the same while we are eating. Because it’s
    all about how it looks.
  prefs: []
  type: TYPE_NORMAL
- en: Which brings us to the peanut butter layer, because what’s a cake without peanut
    butter? Especially if we have jam in our cake. This is the *presentation layer*.
    The presentation layer takes care of making everything look okay and correct.
    The presentation layer will make sure that there aren’t crumbs all over the place,
    for instance, making sure that what you are putting in your mouth actually looks
    like cake.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the amaretto layer. This is the *application layer*. Ultimately,
    this is the layer that sits closest to the eater (user). This takes what comes
    out of the presentation layer and gets it to the user in a way that it can be
    consumed as the user expects it to be consumed. One element of the cake analogy
    here that’s important is that when you use your fork to get a mouthful, you cut
    through the layers from amaretto down to pistachio. That’s how you load it onto
    the fork. When it’s consumed, however, it goes into your mouth pistachio end first.
    This is the same way we send and receive data messages. They are constructed from
    the application layer down and sent along. When they are received, they are *consumed*
    from the physical layer up, pulling off the headers at each layer to expose the
    next layer.
  prefs: []
  type: TYPE_NORMAL
- en: As we are working on network testing, we may be working at different layers
    of our cake. This is why it’s important to understand what each layer is. You
    need to understand the expectations of each layer so you can determine whether
    the behavior you are seeing is correct. We will be dealing with testing across
    multiple layers as we go forward, but generally each tool we will look at will
    target a specific layer. Network communication is about consuming the entire cake,
    but sometimes we need to focus our efforts (taste buds) on a specific layer to
    make sure that it tastes correctly all by itself, outside the context of the rest
    of the cake, even if we have to consume the entire cake to get that layer.
  prefs: []
  type: TYPE_NORMAL
- en: Stress Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some software, and even hardware, has a hard time handling enormous loads. There
    are many reasons for this. In the case of hardware, such as devices that are purpose
    built or devices that fall into the category of Internet of Things (IoT), there
    may be several reasons that it can’t survive a lot of traffic. The processor that’s
    built into the network interface could be underpowered because the design of the
    overall device never expected to see a lot of traffic. The application could be
    written poorly, and even if it is built into the hardware, a poorly designed application
    can still cause problems. As a result, it’s important for security testers to
    ensure that the infrastructure systems they are responsible for will not simply
    fall over when something bad happens.
  prefs: []
  type: TYPE_NORMAL
- en: It may be easy to think of stress testing as flooding attacks. However, there
    are other ways to stress applications. One way is to send the application unexpected
    data that it may not know how to handle. There are techniques to handle this sort
    of attack, so we’re going to focus primarily on overwhelming systems here and
    deal with fuzzing attacks, where we deliberately generate bogus data, later. Having
    said that, though, in some cases network stacks in embedded devices may not be
    able to handle traffic that doesn’t look like it’s supposed to.
  prefs: []
  type: TYPE_NORMAL
- en: Ethics Warning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to ensure that the systems you are working on—especially when there
    could be damage or disruption, and just about everything we will be talking about
    has that potential—are either yours or systems you have permission to be testing.
    It’s unethical at a minimum and likely even illegal to be testing any system you
    don’t own or have permission to be testing. Testing, no matter how simple it may
    seem to be, always has the potential to cause damage. Get your permission in writing,
    always!
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, any failure resulting from a stress test is a problem with availability.
    If the system crashes, no one can get to anything. If the application fails, the
    service isn’t available to users. What you are performing is a denial-of-service
    attack. As a result, it’s important to be careful when performing these sorts
    of attacks. There are definitely ethical implications, as noted earlier, but there
    are also very real possibilities to cause damage, including significant outage
    to customer-facing services. More on that in a moment. A simple way to do stress
    testing is to use a tool like *hping3*. This fabulous tool can be used to craft
    packets on the command line. Essentially, you tell *hping3* what you want different
    fields to be set to, and it will create the packet the way you want.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that you need to always specify all of the fields. You can
    specify what you want, and *hping3* will fill the rest of the fields in the IP
    and transport headers as normal. *hping3* is capable of flooding by not bothering
    to wait for any responses or even bothering to use any waiting periods. The tool
    will send out as much traffic as it can, as fast as it can. You can see the output
    from the tool in [Example 2-3](#EX_2_3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Using hping3 for flooding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using sudo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous versions of Kali and back to BackTrack before it, you logged in
    as the root user. There was no separate user account created during installation.
    This meant everything ran as the root user by default, which is a serious security
    no-no. Currently, Kali has you create a regular user account. Just as with other
    Linux distributions, to perform tasks that require administrative privileges,
    like packet crafting as *hping3* does, you need to use the *sudo* command.
  prefs: []
  type: TYPE_NORMAL
- en: When I ran this, I was connected to my Kali system remotely. As soon as I started
    it up, I tried to kill it because I had the output I was looking for. However,
    the system was cramming packets down the wire (and getting responses) as fast
    as it could. This made it hard to get the Ctrl-C I was trying to send to my Kali
    system, meaning *hping3* wasn’t dying—it was just merrily sending a lot of packets
    out into the network (fortunately, I used my local network to test on, rather
    than trying to test someone else’s system). The operating system and network were
    otherwise engaged, so there was no response for a long period of time. In [Example 2-5](#EX_2_5),
    I am using *hping3* to send SYN messages to port 80\. This is a SYN flood. In
    this example, I’m not only testing the ability of the system to handle the flood
    at the network stack (operating system) with just the capability of the hardware
    and operating system to respond to the traffic, but also testing the transport
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: The operating system has to hold out a small chunk of memory with Transport
    Control Protocol (TCP) connections. Years ago, the number of slots available for
    these initial messages, called *half-open connections*, wasn’t very large. The
    expectation was that the connecting system was well-behaved and it would complete
    the connection, at which point it was up to the application to manage. Once the
    number of slots available to take half-open connections is exhausted, no new connections,
    including connections from legitimate clients, will be accepted. These days, most
    systems are far more capable of handling SYN floods. The operating system will
    just handle these inbound, half-open connections and dispose of them using a variety
    of techniques, including reducing the timeout period during which the connection
    is allowed to be half-open.
  prefs: []
  type: TYPE_NORMAL
- en: This test uses SYN messages (*-S*) to port 80 (*-p 80*). The idea is that we
    should get a SYN/ACK message back as the second stage of the three-way handshake.
    I don’t have to specify a protocol because that’s accomplished by just saying
    that I want to send a SYN message. TCP is the only protocol that has the SYN message.
    Finally, I tell *hping3* that I want it to use flood mode (*--flood*). Other command-line
    flags will do the same thing by specifying the interleave rate (the amount of
    time to wait before sending the next message). This way is easier to remember
    and also pretty explicit.
  prefs: []
  type: TYPE_NORMAL
- en: hping and hping3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The program *hping* has been through a few versions, as you can likely guess
    from the use of the 3 at the end. This tool is commonly available across multiple
    Linux distributions. You may call the program by *hping* on some systems, while
    on others, you may need to specify the version number—*hping2* or *hping3*, for
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '*hping3* is also useful for packet crafting testing, where you create packets
    that just shouldn’t exist in the real world to see whether the target system can
    handle it. Almost any kind of packet mangling attack you can think of is possible
    with this tool. As an example, there has been a denial of service attack called
    a LAND attack, which is short for local area network denial of service. In this
    attack, you send a SYN message to a device with the source address the same as
    the destination. If the network stack on the receiving end is unable to recognize
    this, the system will send a SYN/ACK back to the destination, which is itself.
    This could result in an endless loop of messages on the network interface. In
    the late 1990s, many operating systems were vulnerable to this and it could result
    in operating system crashes. While it was largely fixed in operating systems,
    there have been services that have been discovered to be vulnerable. Additionally,
    a lot of organizations have legacy operating systems that may still be susceptible
    and sometimes devices may be vulnerable, depending on the embedded OS. Mostly,
    though, demonstrating the LAND attack, as seen in [Example 2-4](#EX_2_4), shows
    some of what *hping3* can do. You will also see the packet capture showing some
    of the messages that were generated to show the source and destination addresses
    are the same. The tool itself generates no output because no responses are ever
    received. The -a flag you see here will spoof a source address.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Using hping3 for a LAND attack
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All of the TCP flags are available to be altered in anyway you would like. However,
    you are not limited to simple things like TCP SYN messages. You can also send
    UDP messages. [Example 2-5](#EX_2_5) shows an example of a UDP message. In this
    example, the source port is set to 0, which would not be a port that should be
    used. It would be unusual to see it in normal traffic. You can also see we have
    set the source address to be random. This is something you should be very careful
    of, however. Keep in mind that when you send out messages with a random source
    address, the responses to whatever you send will be sent to that random source
    address. If you are watching the network traffic, you will see the responses coming
    from the hosts on the internet that the responses to your messages were sent to.
    Confused yet? Just be careful about the network traffic you are sending because
    if you are connected in anyway to the internet, that traffic will get out and
    it may cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Using hping3 for UDP messages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Testing at the lower layers of the network stack using tools like *hping3* can
    lead to turning up issues on systems, especially on more fragile devices. Looking
    higher up in the network stack, though, Kali Linux has numerous tools that will
    tackle different services. When you think about the internet, what service springs
    to mind first? Spotify? Facebook? Twitter? Instagram? All of these are offered
    over HTTP, so you’re interacting, often, with a web server. Not surprisingly,
    we can take on testing web servers. This is different from the application running
    on the web server, which is a different thing altogether and something we’ll take
    on much later. In the meantime, we want to make sure that web servers themselves
    will stay up.
  prefs: []
  type: TYPE_NORMAL
- en: Although Kali comes with tests for other protocols including the Session Initiation
    Protocol (SIP) and the Real-time Transport Protocol (RTP), both used for Voice
    over IP (VoIP). SIP uses a set of HTTP-like protocol commands to interact between
    servers and endpoints. When an endpoint wants to initiate a call, it sends an
    INVITE request. In order to get the INVITE to the recipient, it will need to be
    sent through multiple servers or proxies. Since VoIP is a mission-critical application
    in enterprises that use it, it can be essential to determine whether the devices
    in the network are capable of withstanding a large number of requests.
  prefs: []
  type: TYPE_NORMAL
- en: SIP can use either TCP or User Datagram Protocol (UDP) as a transport, though
    earlier versions of the protocol favored UDP as the transport protocol. As a result,
    some tools, particularly if they are older, will lean toward using UDP. Modern
    implementations not only support TCP but also support Transport Layer Security
    (TLS) to ensure the headers can’t be read. Keep in mind that SIP is based on HTTP,
    which means all the headers and other information are text-based, unlike H.323,
    another VoIP protocol, which is binary and can’t generally be read visually without
    something to do a protocol decode. The tool *inviteflood* uses UDP as the transport
    protocol, without the ability to switch to TCP. This does, though, have the benefit
    of allowing the flood to happen faster because there is no time waiting for the
    connection to be established. In [Example 2-6](#EX_2_6), you can see a run of
    *inviteflood*. This is not installed by default on Kali Linux, so you would need
    to install it before you can use it. You’ll note the old date referenced with
    the version. This is the still the most recent version.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. SIP invite flood
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can break down what is happening on the command line. First, we specify the
    interface that *inviteflood* is supposed to use to send the messages out. Next,
    is the username. Since SIP is a VoIP protocol, it’s possible that this may be
    a number, like a phone number. In this case, I am targeting a SIP server that
    was configured with usernames. Following the username is the domain for the username.
    This may be an IP address, depending on how the target server is configured. If
    you don’t know the domain for the users, you could try using the IP address of
    the target system. In that case, you’d have the same value twice, since the target
    is the next value on the command line. At the end is the number of requests to
    send. That 150,000 requests took seconds to send off, meaning that the server
    was capable of supporting a large volume of requests per second.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to other matters, we need to talk about IPv6\. While it isn’t
    necessarily used as a transport protocol from your network to any other network,
    it can be used. If you were to connect to Google, for instance, it would still
    be done over IPv4 from your network more than likely. I mention Google in particular
    because Google publishes an IPv6 address through its Domain Name System (DNS)
    servers. It is far from the only one, but it was definitely one of the early companies
    that did. Beyond being able to send IPv6 through the internet, though, you may
    very well be using IPv6 on local networks. Even though IPv6 is approaching 30
    years old as of this writing, it has not had the same run-in time that IPv4 has
    had—and it took decades to chase some of the most egregious bugs out of various
    IPv4 implementations. This is all to say that in spite of the time that operating
    system vendors like Microsoft and the Linux team have put into development and
    testing, it’s possible that some devices may have issues with IPv6 implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Kali includes IPv6 testing tool suites. There are two of them, and each suite
    has a good-sized collection of tools because in the end, IPv6 includes more than
    just changes to addressing. A complete implementation of IPv6 includes addressing,
    host configuration, security, multicasting, large datagrams, router processing,
    and a few other differences. Since these are different functional areas, multiple
    scripts are necessary to handle those areas.
  prefs: []
  type: TYPE_NORMAL
- en: The way IPv6 behaves on the local network has changed. Instead of the Address
    Resolution Protocol (ARP) being used to identify neighbors on the local network,
    IPv6 replaces and enhances that functionality through new Internet Control Message
    Protocol (ICMP) messages. Coming with IPv6 is the Neighbor Discovery Protocol,
    which is used to help a system connecting to the network by providing details
    about the local network. ICMPv6 has been enhanced with the Router Solicitation
    and Router Advertisement messages as well as the Neighbor Solicitation and Neighbor
    Advertisement messages. These four messages help a system to get situated on a
    network with all the relevant information needed, including the local gateway
    and domain name servers used on that network.
  prefs: []
  type: TYPE_NORMAL
- en: We will be able to test some of these features to determine how a system might
    perform under load but also by manipulating the messages in ways that may cause
    the target system to misbehave. The tools *na6*, *ns6*, *ra6*, and *rs6* all focus
    on sending arbitrary messages to the network by using the different ICMPv6 messages
    indicated previously. Whereas most systems will provide reasonable information
    to the network, to the best of their knowledge and configuration, these tools
    allow us to inject potentially broken messages out to the network to see how systems
    behave with such messages. In addition to those programs, the suite provides *tcp6*,
    which can be used to send arbitrary TCP messages out to the network, allowing
    the possibility of TCP-based attacks.
  prefs: []
  type: TYPE_NORMAL
- en: hping and hping3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tools referenced here are available in the package *ipv6toolkit*. This is
    not installed in the default installation of Kali Linux, however.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that can be used for stress testing in Kali Linux is *t50*. This
    supports multiple protocols, including TCP, UDP, RIP, IGMP, OSPF, and several
    others. In addition to being able to send protocol-specific messages, *t50* supports
    flooding mode, though not all protocols support flooding. [Example 2-7](#EX_2_7)
    shows not only a list of protocols supported by *t50* but also the use of *t50*
    to flood IGMP version 1 messages.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Using t50 to flood IGMP messages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: No matter what sort of stress testing you are doing, it’s important to keep
    as many notes as possible so you can provide detailed information as to what was
    going on when a failure occurred. Monitoring and logging are important here.
  prefs: []
  type: TYPE_NORMAL
- en: Denial-of-Service Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Denial of service is not the same as stress testing. The objective may be different
    when it comes to the two sets of tools being used. Stress testing is commonly
    done by development tools to be able to provide performance metrics. It is used
    to determine the functionality of a program or system under stress—​whether it’s
    the stress of volume or the stress of malformed messages. There is a fine line,
    though. In some cases, stress testing will cause a failure of the application
    or the operating system. This will result in a denial-of-service attack. However,
    stress testing may also just lead to CPU or memory spikes. These are also valuable
    findings, since this would be an opportunity to improve the programming. CPU or
    memory spikes are bugs, and bugs should be eradicated. What we are looking at
    in this section will be programs that are specifically developed for the purpose
    of knocking over services.
  prefs: []
  type: TYPE_NORMAL
- en: Slowloris attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much like the SYN flood that intends to fill up the partial connection queue,
    there are attacks that will do similar things to a web server. Applications don’t
    necessarily have unlimited resources at their disposal. Often there are caps on
    the connections the application server will take on. This depends on how the application
    is designed, and not all web servers are susceptible to these attacks. One thing
    to note here is that embedded devices often have limited resources when it comes
    to their memory and processor. Think about any device that has a web server for
    remote management—​your wireless access point, your cable modem/router, a printer.
    These devices have web servers to make management easier, but the primary purpose
    of these devices isn’t to provide web services; it’s to act as a wireless access
    point, a cable modem/router, or a printer. The resources for these devices will
    be primarily applied to the device’s intended function.
  prefs: []
  type: TYPE_NORMAL
- en: These devices are one place to use this sort of testing, because they simply
    won’t expect a lot of connections. This means that an attack such as Slowloris
    may be able to take these servers offline, denying service to anyone else who
    may try to connect. The Slowloris attack is designed to hold a lot of connections
    open to a web server. The difference between this attack and a flooding attack
    is this is a slow play attack. It’s not a flood. Instead, the attack tool holds
    the connection open by sending small amounts of data over a long period of time.
    The server will maintain these connections as long as the attack tool continues
    to send even small amounts of data partial requests that never quite get completed.
  prefs: []
  type: TYPE_NORMAL
- en: Slowloris is not the only type of attack that goes after web servers, though.
    In recent years, there have been a few vulnerabilities that go after web servers.
    Another one is Apache Killer, which sends bytes in chunks that overlap. The web
    server, in trying to put the chunks together, eventually runs out of memory trying
    to make it work correctly. This was a vulnerability found in both the 1.x and
    2.x versions of Apache.
  prefs: []
  type: TYPE_NORMAL
- en: One program that Kali has available is *slowhttptest*. Using *slowhttptest*,
    you can launch one of four HTTP attacks at your target. The first is a slow headers
    attack, otherwise known as Slowloris (as noted previously). The second is a slow
    body attack, otherwise known as R-U-Dead-Yet. The range attack, known as Apache
    Killer, is also available, as is a slow read attack. All of these are essentially
    the reverse of the flooding attacks discussed earlier in that they accomplish
    the denial of service with a limited number of network messages. In [Example 2-8](#EX_2_7b),
    the default slow headers attack (Slowloris) was run against Apache on my Kali
    box. No traffic has left my system, and you can see that after the 26th second,
    the test ended with no connections left available. Of course, this was a simply
    configured web server with very few threads configured. A web application with
    multiple web servers available to manage load would survive considerably longer,
    if they were available at all.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. slowhttp output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Apache server targeted here uses multiple child processes and multiple
    threads to handle requests. Caps are set in the Apache configuration: the default
    here is 2 servers, a thread limit of 64, 25 threads per child, and a maximum of
    150 request workers. As soon as the number of connections available was maxed
    out by *slowhttptest*, the number of Apache processes was 54 on this system. That
    would be 53 child processes and a master or parent process. To handle the number
    of connections required for the requests being made, Apache spawned multiple children
    and would have had multiple threads per child. That’s a lot of processes that
    have been started up. Considering that the Apache server that was running was
    completely up-to-date at the time of this writing, it seems clear that these types
    of attacks can be successful, in spite of how many years they have been around.
    Of course, as noted earlier, that entirely depends on the architecture of the
    site under test.'
  prefs: []
  type: TYPE_NORMAL
- en: SSL-based stress testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another resource-based attack that isn’t about bandwidth, but instead is about
    processor utilization, targets the processing requirements for encryption. For
    a long time, e-commerce sites have used Secure Sockets Layer (SSL) or Transport
    Layer Security (TLS) to maintain encryption between the client and the server
    in order to ensure the privacy of all communication. While it’s often still referred
    to as SSL/TLS, SSL has been deprecated since 2015\. TLS has been in use for longer
    than SSL was. As a result, you’ll see it referred to as TLS here, since that’s
    what we’re using. These days, many servers use TLS as a matter of course. If you
    attempt to search at Google, you will see that it is encrypted by default. Similarly,
    many other large sites, such as Microsoft and Apple, encrypt all traffic by default.
    If you try to visit the site by using an unencrypted uniform resource locator
    (URL) by specifying *http://* instead of *https://*, you would find that the server
    converts the connection automatically to *https* for you.
  prefs: []
  type: TYPE_NORMAL
- en: The thing about TLS, though, is that encryption requires processing power. Modern
    processors are more than capable of keeping up with normal encryption loads, especially
    as modern encryption algorithms are generally efficient with processor utilization.
    However, any server that uses TLS incurs some processing overhead. First, the
    messages that are sent from the server are generally larger, which means that
    it takes more processing to encrypt those larger messages than the comparably
    small messages originating from a client. Additionally, the client system is probably
    sending only a few messages at a time whereas the server is expected to be encrypting
    messages to a number of concurrent clients, which may all have multiple concurrent
    connections going to the server. The load primarily comes from the creation of
    the keys that are needed to encrypt the session.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities exist in Kali to target outdated services and capabilities. The
    problem is that some of these long superseded programs still remain in service
    in a lot of places. As a result, it’s still important to be able to test them.
    One of those services is the SSL encryption. The final denial-of-service testing
    program we’ll look at here targets servers that use SSL. SSL should no longer
    be in use, having been supplanted by technology that doesn’t have the vulnerabilities
    that SSL had, but that’s not to say that you won’t run across one. The program
    *thc-ssl-dos* targets servers based on the idea that encryption is computationally
    expensive, especially on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-9](#EX_2_8) shows a run of *thc-ssl-dos* against a server that has
    been configured to use SSL. However, the issues with SSL have been known for so
    long that the underlying libraries often have SSL disabled. In spite of running
    against an older installation, you can see that the program was unable to achieve
    a complete SSL handshake. However, if you were to find a server that did have
    SSL configured, you would be able to test whether it was vulnerable to a denial
    of service.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. SSL DoS using thc-ssl-dos utility
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This *failure* highlights one of the challenges of doing security testing:
    finding vulnerabilities can be hard. Exploiting known vulnerabilities can also
    be hard. This is one reason that modern attacks commonly use social engineering
    to make use of humans and their tendency toward trust and behaviors that can lead
    to exploitation—often technical vulnerabilities are harder to exploit than manipulating
    people. This does not mean that these nonhuman issues are not possible given the
    number of vulnerabilities discovered and announced on a regular basis. See [Bugtraq](http://seclists.org/bugtraq/)
    and the [Common Vulnerabilities and Exposures project](http://cve.mitre.org/)
    for evidence of this.'
  prefs: []
  type: TYPE_NORMAL
- en: DHCP attacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Dynamic Host Configuration Protocol (DHCP) has a test program called *DHCPig*,
    which is another consumption attack, designed to exhaust resources available in
    a DHCP server. This is sometimes called a DHCP starvation attack, since the goal
    is to make it impossible for other consumers to “eat” from the DHCP server. Since
    the DHCP server hands out IP addresses and other IP configuration, it would be
    a problem for enterprises if their workers weren’t able to obtain addresses. While
    it’s not uncommon for the DHCP server to hand out addresses with long leases (the
    period of time a client can use the address without having to renew it) a lot
    of DHCP servers have short lease times. A short lease time is important when everyone
    is mobile. As users come on and off the network regularly, sometimes staying for
    short periods of time, having clients hang onto leases can also consume those
    resources. What this means, though, is that when clients have short leases, a
    tool like *DHCPig* can grab expiring leases before the client can get them, leaving
    the clients out in the cold without an address and unable to do anything on the
    network. Running *DHCPig* is as simple as running the Python script *dhcpig* and
    specifying the interface that is on the network you want to test against.
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, a DHCP starvation attack can be used by an attacker to help
    get control of network traffic. The attacker launches a DHCP starvation attack,
    consuming all the available IP addresses. At the same time, the attacker starts
    up their own DHCP server that maybe points systems to a DNS server controlled
    by the attacker. Maybe it points the default router to a system controlled by
    the attacker so all network traffic going off-net will pass through the attacker’s
    system. In [Example 2-10](#EX_2_9), you can see the use of *dhcpig* to consume
    all the available leases from the local DHCP server.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Using dhcpig
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using Scapy to Build Packets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are looking for complete programmatic access to network packet creation,
    you can use the tool Scapy. Scapy is a library that provides access to network
    protocols so you can create a packet to look anyway you would like it to. While
    you can use Scapy to write Python scripts, you can also use the command line interface
    with the *scapy* tool. You can write Python in the *scapy* tool in real-time,
    meaning it executes as you are writing it. [Example 2-11](#EX_2_10) shows the
    use of *scapy* to build a TCP segment on top of an IP packet since *scapy* allows
    you to layer the creation of the messages. Once the packet has been defined, you
    can send it, but there are several ways to send it. You’ll see three of them in
    [Example 2-11](#EX_2_10).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. Using scapy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because we are using a programmatic interface, we are not restricted to just
    using numeric values for different fields. Instead, we can generate random values.
    This example uses random values on the TCP source and destination ports, which
    is probably not a valuable packet to create and send, but it demonstrates the
    use of generating random values. We have the ability to generate full integers
    or we can generate short integers, which would be required if we had a field size
    of 16 bits, such as that for the port value. As indicated, we have control over
    all the fields in the protocols. This doesn’t show the Ethernet layer, but we
    could add that in if we wanted to. You could, for instance, set the media access
    control (MAC) address to the system you want to set it to but change the IP address
    to see how the system handles it.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to sending and receiving, we can just send it, as you can see
    in the first send example. You can also use sr(), which is send and receive, but
    you don’t get the details from the response. Finally, shown is sr1(), which is
    the function used if you want to see the full packet details from the received
    message after the send. This assumes that you will actually get a response, depending
    on what sort of packet you have created. With send(), you can also add a loop
    parameter to tell *scapy* you want the packet to be sent until you type a Ctrl-C
    character to stop it. For our packet, p, you can send it with a loop with *send(p,
    loop=1)*.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have full control over the packet and its parameters, we can also
    manipulate both the source and destination IP address, as shown in [Example 2-12](#EX_2_11),
    where we recreate the LAND attack referenced earlier. In this case, we don’t get
    a response, as you can see. That’s because the source IP address is not our address
    and the network stack on the receiving system is sending it back to the system
    that has that IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. Using scapy for LAND attack
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can, of course, also use *scapy* to send legitimate messages and it handles
    a lot of different protocols. Because a common protocol is HTTP, we can use *scapy*
    to create a web request and send it. There are two approaches shown in [Example 2-13](#EX_2_12).
    The first is to use a socket directly with the HTTP text to be sent. It gets added
    to the packet creation syntax you’ve seen before. In other words, the text just
    gets added as payload. The second approach is to load the *http* layer so we can
    use HTTP methods. We’ll create a request using *HTTP()/HTTPRequest()*, which creates
    all the necessary data we need. We haven’t added any parameters to HTTPRequest,
    though we could use Method, which defaults to GET, as well as Path, to specify
    which resource we want to retrieve from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13\. Using scapy for HTTP messages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This barely scrapes the surface of what is possible with *scapy*. As said already,
    this provides us easy ways to programmatically script network messages, getting
    full control over the different elements of the protocols. You could easily send
    broken messages using *scapy*. For example, you don’t have to use a standard request
    known by HTTP servers. You can create your own request verb, just to see how the
    server responds to it. When it comes to binary-based protocols like IP or TCP,
    where it’s clearly blocked out byte sequences, you are going to be limited in
    what you can send. You wouldn’t be able to send *AAAAAAAAAAA* in the destination
    address. First, the destination address for IPv4 is only 4 bytes. We are trying
    to send 11 bytes, which will fill up the destination address with 41414141\. This
    translates to 65.65.65.65\. We don’t get a lot out of that. Each byte is only
    going to support values of 0-255, so you need to get a little creative if you
    want to play with these binary-based protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve had the ability to encrypt traffic over internet connections for over
    20 years now. Encryption, like so much else that’s information security related,
    is a moving target. When the first version of SSL was released by Netscape in
    1995, one version had already been discarded because of identified problems with
    it. The second version didn’t last long before identified problems with it forced
    a third version, released the following year in 1996\. Both SSLv2 and SSLv3 were
    both determined to be prohibited as a result of the problems with the way they
    handle encryption.
  prefs: []
  type: TYPE_NORMAL
- en: Network traffic that is encrypted follows a process that is not as simple as
    just taking a message, encrypting it, and sending it along, though that’s a part
    of the overall process. Encryption relies on keys. The most sensitive part of
    any encryption process is always the key. A message that is encrypted is valuable
    only if it can be decrypted, of course. If I were to send you an encrypted message,
    you would need the key to be able to decrypt it. This is where the challenge starts
    to come in.
  prefs: []
  type: TYPE_NORMAL
- en: There are two means of handling keys. The first is *asymmetric encryption*.
    This is where there are two keys, one for encryption and one for decryption. You
    may also hear this referred to as *public key encryption*. The idea is that everyone
    has two keys—​a public key and a private key. The public key is something everyone
    can have. In fact, it works only if everyone has the ability to access everyone
    else’s public key. Encrypting a message using a public key means that the message
    can be decrypted only by using the private key. The two keys are mathematically
    related and based on calculations using large numbers. This all seems like a reasonable
    approach, right? The problem with asymmetric encryption is that it is computationally
    hard.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to *symmetric encryption*. With symmetric encryption, as you may
    have guessed, we have a single key. The same key encrypts and decrypts. Symmetric
    key encryption is computationally easier. However, symmetric key encryption has
    two problems. The first is that the longer a symmetric key is used, the more vulnerable
    to attack it is. This is because an attacker can gather a large volume of ciphertext
    (the result of feeding plain text into an encryption algorithm) and start performing
    analysis on it in the hopes of deriving the key. Once the key has been identified,
    any traffic encrypted with that key can be easily decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second and more important problem is that after we have a key, how do we
    both get it? This works, after all, only if both of us have the key. So, how do
    we both have the key if we are not physically proximate? And if we are physically
    proximate, do we need to encrypt messages between us? We could have met at some
    point and shared the key, but that means that we are stuck using the key until
    we meet again and can create a new key so we both have it. The longer we use the
    same key without meeting again brings us to problem #1 noted previously.'
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, two mathematicians solved this problem, though they were not
    the first. They were just the first who could publish their work. Those whose
    work came first worked for government agencies who were not allowed to share the
    work they were doing with anyone. Whitfield Diffie and Martin Hellman came up
    with the idea of having both sides independently derive the key. Essentially,
    we both start with a value that is shared. This can be safely shared unencrypted
    because it’s what happens to it after that matters. We both take this initial
    value and apply a secret value using a mathematical formula that we both know.
    Again, it doesn’t matter whether this is public because it’s the secret value
    that matters. We share each other’s result from our individual computations and
    then reapply our secret values to the other’s result. In this way, we will have
    both gone through the same mathematical process from a single starting point,
    so we will both have the same key in the end.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for going through all of this is that in practice, all of these mechanisms
    are used. The Diffie-Hellman key exchanged is used along with public-key cryptography
    to derive a session key, which is a symmetric key. This means that the session
    uses a less computationally intensive key and algorithm to do the heavy lifting
    of encrypting and decrypting the bulk of the communication between the server
    and the client.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, SSL is no longer used as the cryptographic protocol. Instead,
    TLS is the current protocol used. It has been through a few versions itself, again
    demonstrating the challenges of encryption. The current version is 1.2, while
    1.3 is in draft stage at the moment. Each version introduces fixes and updates
    based on continuing research in breaking the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: One way to determine whether a server you are testing is using outdated protocols
    is to use a tool like *sslscan*. This program probes the server to identify what
    encryption algorithms are in use. This is easy to determine, because as part of
    the handshake with the server, it will provide a list of ciphers that are supported
    for the client to select from. So, all *sslscan* needs to do is initiate an encrypted
    session with the server to get all the information needed. [Example 2-14](#EX_2_13)
    shows the results of testing an Apache server with encryption configured.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. Running sslscan against local system
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*sslscan* will determine whether the server is vulnerable to Heartbleed, a
    vulnerability that was identified and that targeted server/client encryption,
    leading to the exposure of keys to malicious users. Most important, though, *sslscan*
    will give us the list of ciphers supported. In the list, labeled “Supported Server
    Cipher(s)”, which has been edited for length, you will see multiple columns with
    information that may not mean a lot to you. The first column is easily readable.
    It indicates whether the protocol and cipher suite are accepted and whether they
    are preferred. The first preferred cipher suite is for TLS version 1.3 with a
    256-bit AES key. You will note that each of the versions of TLS has its own preferred
    cipher suite. There are only two versions of TLS which are in use, so there are
    only two preferred ciphers. The second column is the protocol and version. SSL
    is not enabled on this server at all, as a result of support for SSL having been
    removed from the underlying libraries. The next column is the key strength.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Key sizes can’t be compared except within the same algorithm. Rivest-Shamir-Adleman
    (RSA) is an asymmetric encryption algorithm and has key sizes that are multiples
    of 1,024\. AES is a symmetric encryption algorithm and has key sizes of 128 and
    256\. That doesn’t mean that RSA is orders of magnitude stronger than AES, because
    they use the key in different ways. Even comparing algorithms that are the same
    type (asymmetric versus symmetric) is misleading because the algorithms will use
    the keys in entirely different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next column is the cipher suite. You will note that it’s called a *cipher
    suite* because it takes into account multiple algorithms that have different purposes.
    Let’s take this listing as an example: DHE-RSA-AES256-GCM-SHA384\. The first part,
    DHE, indicates that we are using Ephemeral Diffie-Hellman for key exchange. The
    second part is RSA, which stands for Rivest-Shamir-Adleman, the three men who
    developed the algorithm. RSA is an asymmetric-key algorithm. This is used to authenticate
    the parties, since the keys are stored in certificates that also include identification
    information about the server. If the client also has a certificate, there can
    be mutual authentication. Otherwise, the client can authenticate the server based
    on the hostname the client intended to go to and the hostname that is listed in
    the certificate. Asymmetric encryption is also used to encrypt keys that are being
    sent between the client and the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I am using the words *client* and *server* a lot through this discussion, and
    it’s useful for you to understand what these words mean. In any conversation over
    a network, there is always a client and a server. This does not mean that the
    server is an actual server sitting in a data center. What it means is that there
    is a service that is being consumed. The client is always the side originating
    the conversation, and the server is always the one responding. That makes it easy
    to “see” the two parties—​who originated and who responded to the origination.
  prefs: []
  type: TYPE_NORMAL
- en: The next part is the symmetric encryption algorithm. This suggests that the
    Advanced Encryption Standard (AES) is being offered with a key size of 256 bits.
    It’s worth noting here that AES is not an algorithm itself but a standard. The
    algorithm has its own name. For decades, the standard in use was the Data Encryption
    Standard, based on the Lucifer cipher developed at IBM by Horst Feistel and his
    colleagues. In the 1990s it was determined that DES was a bit long in the tooth
    and would soon be breakable. A search for a new algorithm was undertaken, resulting
    in the algorithm Rijndael being selected as the foundation for the Advanced Encryption
    Standard. Initially, AES used a key size of 128 bits. It’s only been relatively
    recently that the key strength is commonly increased to 256.
  prefs: []
  type: TYPE_NORMAL
- en: AES is the algorithm used for encrypting the session. This means a 256-bit key
    is used for the session key. It is the key that was derived and shared at the
    beginning of the session. If the session were to last long enough, the session
    key may be regenerated to protect against key derivation attacks. As noted before,
    the key is used by both sides of the conversation for encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: The GCM part is Galois/Counter Mode, which is a way block ciphers operate to
    provide data integrity and confidentiality. Encrypted data is associated with
    a tag that is generated at the time the data is encrypted. This tag is used to
    verify that neither the data nor the tag have been tampered with at all.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll notice the algorithm SHA384\. This is the Secure Hash Algorithm
    using 384 bits for the length of the hash value. SHA is a cryptographic algorithm
    that is used to verify that no data has changed. You may be familiar with the
    Message Digest 5 (MD5) algorithm that does the same thing. The difference is the
    length of the output. With MD5, the length of the output is always 32 characters,
    which is 128 bits (only 4 bits out of every byte are used). This has been generally
    replaced with SHA1 or higher. SHA1 generates 40 characters, or 160 bits (again,
    only 4 bits out of every byte are used). In our case, we are using SHA384, which
    generates 96 hexadecimal characters, since it would be 48 bytes with each byte
    being represented by two hexadecimal characters. No matter the length of the data,
    the output length is always the same. This value is sent from one side to the
    other as a way of determining whether the data has changed. If even a single bit
    is different, the value of the hash—​the word used for the output of the SHA or
    MD5 algorithm—​will be different.
  prefs: []
  type: TYPE_NORMAL
- en: All of these algorithms work together to make up the protocol of TLS (and previously
    SSL). To accomplish effective encryption that is protected against compromise,
    all of these algorithms are necessary. We need to be able to derive a session
    key. We need to be able to authenticate the parties and share information using
    encryption before we have generated our session key. We need to have a session
    key and an algorithm to encrypt and then decrypt our session data. Finally, we
    need to make sure that nothing has been tampered with. What you see in the example
    is a collection of strong encryption suites.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to see something like 3DES in the output, you would have an example
    of a server that was susceptible to attacks against the session key. This could
    result in the key being compromised, which would result in the ciphertext being
    decrypted into plain text in the hands of someone for whom it was not meant. Additionally,
    though it was breezed over earlier, a tool like *sslscan* can verify that the
    protocols used are not vulnerable to attack using known exploits.
  prefs: []
  type: TYPE_NORMAL
- en: You may on rare occasions see NULL in the place where we have seen AES384\.
    This means that the request is that no encryption is used. There are reasons for
    this. You may not care so much about protecting the contents of the transmissions,
    but you may care very much that you know who you are talking to and that the data
    hasn’t been modified in transit. So, you ask for no encryption so as not to incur
    any overhead from the encryption, but you get the benefit of the other parts of
    the cipher suite selected.
  prefs: []
  type: TYPE_NORMAL
- en: The war over encryption never ends. Even now research is being done to identify
    vulnerabilities that can be exploited in the encryption algorithms and protocols
    in use. You will see differences in the suites listed in your testing output over
    time as stronger keys begin to be used and new algorithms are developed.
  prefs: []
  type: TYPE_NORMAL
- en: Packet Captures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are performing network testing, you will find it useful to be able to
    see what is being transmitted over the network. To see what is sent, we need to
    use a program that captures packets. In fairness, though, what we are doing is
    capturing frames. The reason I say that is each layer of the network stack has
    a different term for the bundle of data that includes that layer. Keep in mind
    that headers are tacked on as we move down the network stack, so the last set
    of headers added is the layer 2 headers. The protocol data unit (PDU) at that
    layer is the frame. When we get up to layer 3, we are talking about a packet.
    Layer 4 has datagrams or segments, depending on the protocol used there.
  prefs: []
  type: TYPE_NORMAL
- en: Years ago, capturing packets was an expensive proposition, because it required
    a special network interface that could be put into promiscuous mode. The reason
    it’s called that is because by default, network interfaces look at the MAC address.
    The network interface knows its own address because it is attached to the hardware.
    If the address of an inbound frame matches the MAC address, the frame is forwarded
    up to the operating system. Similarly, if the MAC address is the broadcast address,
    the frame is forwarded up. In promiscuous mode, all comers are welcome. This means
    that all frames, whether they are addressed for this particular system or not,
    are forwarded up to the operating system. Being able to look at only frames addressed
    to that interface is nice and valuable, but it’s far more valuable to be able
    to see all frames that come across a network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Modern network interfaces typically support not only things like full duplex
    and auto-negotiation but also promiscuous mode. This means we don’t need protocol
    analyzers anymore (as the hardware that could do this work was often called) because
    every system is capable of being a protocol analyzer. All we need is to know how
    to grab the frames and then peer into them to see what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Using tcpdump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While other operating systems have had other packet capture programs, like Solaris
    had *snoop*, the de facto packet capture program these days, especially on Linux
    systems, is *tcpdump* if all you have is access to a command line. We will take
    a look at a GUI a little later, but there is a lot of value in learning about
    *tcpdump*. You won’t always have access to a full desktop with a GUI. In many
    cases, you will have only a console or just an SSH session that you can use to
    run command-line programs. As a result, *tcpdump* will become a good friend. As
    an example, I used it earlier to verify that the protocol being used by our SIP
    testing program was really just using UDP and not using TCP. It has a lot of value
    in understanding what is going on with a program that isn’t otherwise telling
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start looking at options, let’s take a look at the output from *tcpdump*.
    Being able to read what is happening by looking at the output takes some getting
    used to. When we run *tcpdump* without any options, we get a short summary of
    the packets that are passing through. [Example 2-15](#EX_2_14) is a sample of
    *tcpdump* output.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. tcpdump output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first column in the output in [Example 2-15](#EX_2_14) is the timestamp.
    This is not anything that has been determined from the packet itself, since time
    is not transmitted as part of any of the headers. What we get is the time as the
    hours, minutes, seconds, and fractions of seconds after midnight. In other words,
    it’s the time of day down to a fraction of a second. The second field is the transport
    protocol. We don’t get the layer 2 protocol because it’s determined by the network
    interface, so it goes without saying. In order to know the layer 2 protocol, you
    need to know something about your network interface. Commonly, the layer 2 protocol
    will be Ethernet.
  prefs: []
  type: TYPE_NORMAL
- en: The next set of data is the two endpoints of the conversation. This includes
    not only the IP addresses but also the port information. So, *binkley.lan* is
    the source of the first packet, and *testwifi.here* is the destination. Without
    telling it not to, *tcpdump* will convert IP addresses to hostnames. To disable
    that function, you would need to provide an *-n* on the command line. This would
    speed up your capture and lower the number of packets captured, since your system
    won’t be doing a DNS lookup for every frame that comes by.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that along with each IP address is another value. From our source
    address, *binkley.lan.57137*, the 57137 is a port number. This is the source port,
    and on the receiving side, you can see *testwifi.here.domain*. This means that
    *testwifi.here* is receiving a message on the port used by domain name servers.
    Again, just as in the hostname versus IP address, if you don’t want *tcpdump*
    to do a lookup on the port number, based on well-known port numbers, you can add
    *-n* to the command line, and *tcpdump* will just present you numeric information.
    In this case *.domain* translates to *.53*, which is the numeric value. We know
    that this is a UDP message because it tells us after the destination information.
  prefs: []
  type: TYPE_NORMAL
- en: Primarily, what you see in [Example 2-15](#EX_2_14) are DNS requests and responses.
    This is a result of having *tcpdump* doing reverse DNS lookups to determine the
    hostname associated with the IP address. The remainder of each line from *tcpdump*
    output is a description of the packet. In the case of a TCP message, you may see
    the flags that are set in the TCP header or you may see sequence number information.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we’ll take a look at more verbose output by using the *-v* flag.
    *tcpdump* supports multiple *-v* flags, depending on the level of verbosity you
    are looking for. We’ll also take a look at using the *-n* flag to see what it
    looks like without any address lookup. [Example 2-16](#EX_2_15) shows the more
    verbose output.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-16\. Verbose output for tcpdump
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output looks largely the same except that this is all numbers with no hostnames
    or port names. This is a result of using the *-n* flag when running *tcpdump*.
    You will still see the two endpoints of each conversation identified by IP address
    and port number. What you get with *-v* is more details from the headers. You
    will see that checksums are verified as correct (or incorrect). You will also
    see other fields including the time-to-live value and the IP identification value.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we switch to *-vvv* for the most verbosity, you aren’t going to get
    a complete packet decode for analysis. We can, though, use *tcpdump* to capture
    packets and write them out to a file. What we need to talk about is the *snap
    length*. This is the snapshot length, or the amount of each packet that is captured
    in bytes. By default, tcpdump grabs 262144 bytes. You may be able to set that
    value lower. Setting the value to 0 says that *tcpdump* should grab the maximum
    size. In effect, this tells *tcpdump* to set the snap length to the default value
    of 262144\. To write the packet capture out, we need to use the *-w* flag and
    specify a file. Once we’ve done that, we have a packet capture (pcap) file that
    we can import into any tool that will read these files. We’ll take a look at one
    of those tools a little later.
  prefs: []
  type: TYPE_NORMAL
- en: Berkeley Packet Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important feature of *tcpdump*, which will serve us well shortly, is
    the Berkeley Packet Filter (BPF). This set of fields and parameters allows us
    to limit the packets that we are grabbing. On a busy network, grabbing packets
    can result in a lot of data on your disk in a short period of time. If you have
    an idea of what you are looking for ahead of time, you can create a filter to
    capture only what you are going to be looking at. This can also make it quite
    a bit easier to visually parse through what you have captured, saving you a lot
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: A basic filter is to specify which protocol you want to capture. As an example,
    I could choose to capture only TCP or UDP packets. I might also say I want to
    capture only IP or other protocols. In [Example 2-17](#EX_2_16), you can see a
    capture of ICMP-only packets. You will notice that in order to apply a filter,
    I just put it on the end of the command line. What results is the display of only
    ICMP packets. Everything still comes into the interface and is sent up to *tcpdump*,
    but it then determines what to display or write out to a file, if that’s what
    you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17\. tcpdump using BPF
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing I can do with these filters is use Boolean logic; I can use logic
    operators to be able to develop complex filters. Let’s say, for instance, that
    I want to capture web traffic. One way I could do that would be to say *tcp and
    port 80*: I am grabbing all TCP packets that have the port as 80\. You’ll notice
    that I don’t mention source or destination with respect to the port number. I
    certainly can. I could use src port 80 or dst port 80\. However, if I don’t specify
    source or destination, I get both ends of the conversation. When a message goes
    out with port 80 as its destination, when the receiving system replies, the port
    numbers get swapped. Port 80 on the response becomes the source port. If I were
    to capture only src port 80, I wouldn’t get any of the messages in the other direction.
    This may be exactly what you are looking for, of course, but it’s something to
    keep in mind. You may find that you need to indicate a range of ports to be grabbed.
    You could use the port-range primitive to capture a range of ports, like 80–88,
    for example.'
  prefs: []
  type: TYPE_NORMAL
- en: The language used for BPF provides a lot of capability. If you need really complex
    filters, you can certainly look up the syntax for BPF and examples that may provide
    you something specific that you are looking for. What I have often found is that
    specifying the port is valuable. Also, I often know the host I want to capture
    traffic from. In that case, I would use *host 192.168.86.35* to grab only traffic
    with that IP address. Again, I have not specified either source or destination
    for the address. I could by specifying src host or dst host. If I don’t indicate,
    I get both directions of the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Developing even a simple understanding of BPF will help you focus what you are
    looking at down to data that is relevant. When we start looking at packet captures,
    you will see how complex a job it can be to do packet analysis because there are
    just so many frames that contain a lot of detail to look over.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have your packet capture file, you will probably want to do some analysis.
    One of the best tools for that is Wireshark. Of course, Wireshark can also capture
    packets itself and generate pcap files if you want to store the capture for later
    analysis or for analysis by someone else. The major advantage to Wireshark, though,
    is providing a way to really dig deep into the contents of the packet. Rather
    than spending time walking through what Wireshark looks like or how we can use
    Wireshark for capturing packets, let’s jump into breaking apart a packet using
    Wireshark. [Figure 2-4](#header-fields-in-wireshark) shows the IP and TCP headers
    from an HTTP packet.
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig4.png](assets/lklx_02in01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Header fields in Wireshark
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see from just this image that Wireshark provides far more details than
    we were getting from *tcpdump*. This is one area where GUIs have a significant
    advantage. There is just more room here and a better way to present the amount
    of data in each of these headers. Each field in the header is presented on its
    own line so it’s clear what is happening. You’ll also see here that some of the
    fields can be broken out even more. The flags field, for example, can be broken
    open to see the details. This is because the flags field is really a series of
    bits, so if you want, you can open that field by clicking the arrow (or triangle)
    and you will be able to see the value of each of the bits. Of course, you can
    also see what is set just by looking at the line we have presented by Wireshark
    because it has done the work for us. For this frame, the Don’t Fragment bit is
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage to using a tool like Wireshark is that we can more easily
    get to the contents of the packet. By finding a frame that we are interested in
    because it’s part of a conversation that we think has some value, we just need
    to select Follow TCP Stream. What we will get, in addition to only the frames
    that are part of that conversation, is a window showing the ASCII decode of the
    payloads from all of the frames. You can see this in [Figure 2-5](#follow-tcp-stream-output).
    Wireshark also color-codes the output. Red is the client messages, and blue is
    the server messages. You will also get a brief summary at the bottom of the window
    indicating how much of the conversation was the client’s and how much was the
    server’s.
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig5.png](assets/lklx_02in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Follow TCP stream output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Wireshark has the same filtering capabilities that we had with *tcpdump*. In
    the case of Wireshark, we can apply the filter as a capture filter, meaning we
    will capture only packets that match the filter, or we can apply the filter as
    a display filter to be applied to packets already captured. Wireshark will provide
    a lot of help when it comes to filtering. When you start typing in the filter
    box at the top of the screen, Wireshark will start trying to autocomplete. It
    will also indicate whether you have a valid filter by color-coding the box red
    when you have an invalid filter, and green when it’s valid. Wireshark has the
    ability to get to about every field or property of the protocols it knows about.
    As an example, we could filter on the type of HTTP response code that was seen.
    This may be valuable if you generated an error and you want to look at the conversation
    that led to the error.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark will also do a lot of analysis for us. As an example, when we were
    fragmenting packets earlier using *fragroute*, Wireshark would have colored frames
    that weren’t right. If a packet’s checksum didn’t match, for instance, the frames
    belonging to that packet would have been colored black. Any error in the protocol
    where the packet is malformed would result in a frame that was colored red. Similarly,
    TCP resets will get a frame colored red. A warning would be colored yellow and
    may result from an application generating an unusual error code. You may also
    see yellow if there are connection problems. If you want to save a little time,
    you can use the Analyze menu and select Expert Info to see the entire list of
    frames that have been flagged. You can see a sample of this view in [Figure 2-6](#expert-information-output).
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig6.png](assets/lklx_02in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Expert information output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Wireshark has so many capabilities; we aren’t even skimming the surface of what
    it can do. A lot of what you may find it useful for is just to see the headers
    for each protocol broken out in a way that you can easily read them. This will
    help you see what is happening if you run into issues with your testing. One other
    feature I should mention is the statistics menu. Wireshark will provide graphs
    and different views of the data you have captured. One such view is the protocol
    hierarchy, as you can see in [Figure 2-7](#protocol-hierarchy-in-wireshark).
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig7.png](assets/lklx_02in04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Protocol hierarchy in Wireshark
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The protocol hierarchy view is good for, among other things, quickly identifying
    protocols that you don’t recognize. It also helps you to determine which protocols
    are the most used. If you believe, for instance, that you are using a lot of UDP-based
    attacks, but UDP is a small fraction of the total number of messages sent, you
    may want to do some further investigation.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark comes installed out of the box, so to speak, with Kali Linux. However,
    it can also be installed on other operating systems such as Windows and macOS
    as well as other Linux distributions. I can’t emphasize enough the value of this
    particular tool and the amount of work it can save after you get the hang of using
    it. Being able to completely decode application layer protocols so it can give
    you a little summary of what is happening with the application can be invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: There is a challenge with the use of encrypted traffic for almost all websites
    today, but it is possible to get around that. You can add encryption keys into
    the Preferences but it’s a lot of work ensuring that you have the right keys for
    the communications streams you want to decode. For everything not encrypted, you
    can do full protocol decodes and you can always look at headers to see who is
    communicating with whom.
  prefs: []
  type: TYPE_NORMAL
- en: Poisoning Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges we have is that most networks are switched. The device
    you are connecting to sends messages only to the network port where your recipient
    is located. In the old days, we used hubs. Whereas a switch is a unicast device,
    a hub is a broadcast device. Any message that came into a hub was sent out to
    all other ports in the hub, letting the endpoints figure out who the frame belonged
    to, based on the MAC address. There was no intelligence in the hub at all. It
    was simply a repeater.
  prefs: []
  type: TYPE_NORMAL
- en: A switch changes all that. The switch reads the layer 2 header to determine
    the destination MAC address. It knows the port where the system that owns that
    MAC address is. It determines this by watching traffic coming into each port.
    The source MAC address gets attached to the port. The switch will commonly store
    these mappings in content addressable memory (CAM). Rather than having to scan
    through an entire table, the switch looks up the details by referring directly
    to the MAC address. This is the content that becomes the address the switch refers
    to in order to get the port information.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this relevant here? Because you will sometimes want to collect information
    from a system that you don’t have access to. If you owned the network and had
    access to the switch, you may be able to configure the switch to forward traffic
    from one or more ports to another port. This would be a mirror, rather than a
    redirection. The recipient gets the traffic, but also a monitoring device or someone
    capturing traffic for analysis would get the packets.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the messages you need if you can’t get legitimate access to them,
    you can use a spoofing attack. In a *spoofing attack*, you pretend to be someone
    you are not in order to get traffic. There are a couple of ways to do that, and
    we’ll take a look at these different attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Ethics Warning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While spoofing attacks are used by attackers, they are not something that you
    should be doing on a network you are testing, unless it falls into the scope of
    what you have said you would test against. There is the possibility of data loss
    using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: ARP Spoofing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Address Resolution Protocol (ARP) is a simple protocol. The assumption is
    when your system needs to communicate on the network but it has only the IP address
    and not the MAC address, it will send out a request (who-has) to the network.
    The system that has that IP address will respond (is-at) by filling in the MAC
    address for its system. Your system then knows the MAC address for the target
    system and can send the message it’s been holding to the correct destination.
  prefs: []
  type: TYPE_NORMAL
- en: To be efficient, your system will cache that mapping. In fact, it will cache
    any mapping that it sees go by. ARP assumes that the only time a system will indicate
    that it owns an IP address is when someone has asked. As it turns out, though,
    that’s not the case. If I were to have my system send out an ARP response (is-at)
    saying that I owned your IP address and that anyone trying to get to that IP address
    should send to my MAC address, I would get messages destined for you. By sending
    out an ARP response indicating your IP address is at my MAC address, I put myself
    into the middle of the communication flow.
  prefs: []
  type: TYPE_NORMAL
- en: This is only single-direction, though. If I end up spoofing your IP address
    with my MAC address, I’m getting only messages that were supposed to go to you.
    To get the other end of the conversation, I would need to spoof other addresses.
    You may, for example, spoof the local gateway in order to capture messages to
    and from you and the internet. This takes care of only getting the messages to
    me. I have to also get the messages back out to the intended targets, or the communication
    just stops because no one is getting messages they expect to get. This requires
    my system to forward the initial message out to the intended target.
  prefs: []
  type: TYPE_NORMAL
- en: Since ARP caches do time out, if I don’t keep having my system sending these
    messages, eventually the cache will time out and then I won’t get the messages
    I want anymore. This means that I need to keep sending out these messages, called
    gratuitous ARP messages. A *gratuitous ARP message* is one that hasn’t been requested
    but offered nonetheless. There are legitimate reasons for this behavior, but they
    aren’t common.
  prefs: []
  type: TYPE_NORMAL
- en: While other tools can be used for this, we can use the program Ettercap. Ettercap
    has two modes of functioning. The first is a curses-style interface, meaning it
    runs in a console but isn’t strictly command line. It presents a character-based
    GUI. The other one is a full Windows-based GUI. [Figure 2-8](#using-ettercap)
    shows Ettercap after our target hosts have been selected and the ARP poisoning
    has been started. To start the spoofing attack, I scanned for hosts to get all
    of the MAC addresses on the network. Then, I selected the two targets and started
    the ARP spoofing attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![images/Ch2Fig8.png](assets/lklx_02in05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Using Ettercap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The reason for having two targets is to make sure to get both sides of a conversation.
    If I poison only one party, I will get only half of the conversation. I assume
    that what I want to gather is communication between my target and the internet.
    As a result, I set my target as one host and the router on my network as the second
    host. If I needed to acquire traffic between two systems on my network, I would
    select those. One would be in Target 1, and the other would be in Target 2\. In
    [Example 2-18](#EX_2_17), you can see what an ARP poison attack looks like from
    a packet capture. You will see the two ARP replies where the IP addresses belong
    to my targets. I included a portion of the *ifconfig* output on my system so you
    can see that the MAC address caught in the packet capture is the MAC address of
    my system, where I was running the ARP spoofing attack.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-18\. tcpdump showing ARP poison attack
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once I have an ARP spoofing attack in place, I can capture entire conversations
    by using *tcpdump* or Wireshark. Keep in mind that this sort of attack works on
    only the local network. This is because the MAC address is a layer 2 address so
    it stays on the local network and doesn’t cross over any layer 3 boundary (moving
    from one network to another). Ettercap also supports other layer 2 attacks like
    DHCP poisoning and ICMP redirect attacks. Any of these may be ways to ensure you
    are grabbing traffic from other systems on your local network.
  prefs: []
  type: TYPE_NORMAL
- en: DNS Spoofing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One solution to the issue of needing to capture traffic that may be outside
    the local network is using a DNS spoofing attack. In this attack, you interfere
    with a DNS lookup to ensure that when your target attempts to resolve a hostname
    into an IP address, the target gets the IP address of a system you control. This
    type of attack is sometimes called a *cache poisoning attack*. The reason for
    this is that what you may do is exploit a DNS server close to your target. This
    would generally be a caching server, meaning it looks up addresses from authoritative
    servers on your behalf and then caches the answer for a period of time determined
    by the authoritative server.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have access to the caching server, you can modify the cache that’s
    in place to direct your targets to systems that you control. You can also include
    any entries that don’t exist by editing the cache. This would impact anyone who
    used that caching server. This process has the benefit of working outside the
    local network but has the disadvantage of requiring you to compromise a remote
    DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps easier, though still requiring you to be on the local network, is the
    program *dnsspoof*. When a system sends out a DNS request to a server, it expects
    a response from that server. The request includes an identifier so it is protected
    against attackers sending blind responses. If the attacker can see the request
    go out, though, it can capture the identifier and include it in a response that
    has the IP address belonging to the attacker. *dnsspoof* was written by Dug Song
    many years ago, at a time when it may have been less likely that you would be
    on a switched network. If you are on a switched network, you would have to go
    through the extra step of grabbing the DNS messages in order to see the request.
    This program is not installed by default, but can be installed as part of the
    package *dsniff*.
  prefs: []
  type: TYPE_NORMAL
- en: Running *dnsspoof* is easy, even if preparing for running it may not be. You
    need a hosts file mapping IP addresses to hostnames. This takes the form of single-line
    entries with the IP address followed by spaces and then the hostname that is meant
    to be associated with that IP address. Once you have the hosts file, you can run
    *dnsspoof*, as you can see in [Example 2-19](#EX_2_14b).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-19\. Using dnsspoof
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that at the end of the command line, I have included BPF to focus
    the packets that are captured. Without this, the output would default to looking
    only datagrams captured to UDP port 53 if they do not originate from the system
    you are running *dnsspoof* on. You can use BPF just as you would with *tcpdump*
    to see a broader set of traffic. I removed the part that didn’t capture traffic
    from the local system and included my own BPF in order to run tests locally. You’ll
    see any request matching your BPF parameters get printed when they come in. This
    output is similar to what you might see from *tcpdump*.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why you’d bother to take the extra step of using *dnsspoof*
    if you have to use Ettercap or *arpspoof* (another ARP spoofing utility, though
    this one was written by Dug Song and included in the same suite of tools as *dnsspoof*).
    What you can do with *dnsspoof* that you can’t do with just ARP spoofing is directing
    a system to actually visit another IP address, thinking they are going to somewhere
    legitimate. You could create a rogue web server, for example, making it look like
    the real server but including some malicious code to gather data or infect the
    target. This is not the only purpose for doing DNS spoofing, but is a popular
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically, attacks against systems will happen over the network. Although not
    all attacks go after network protocols, there are enough that do that it’s worth
    spending some time understanding the network elements and the protocols associated
    with the different layers. Here are some key points to take away from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Security testing is about finding deficiencies in confidentiality, integrity,
    and availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network stack based on the OSI model is physical, data, network, transport,
    session, presentation, and application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stress testing can reveal impacts to at least availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption can make it difficult to observe network connections, but weak encryption
    can reveal issues with confidentiality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing attacks can provide a way to observe and capture network traffic from
    remote sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing packets using tools like tcpdump and Wireshark can provide insights
    into what’s happening with applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali provides tools that are useful for network security testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quiz Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1) What tool would you use to help you with spoofing attacks that would help
    you capture packets from other systems? a) Wireshark b) Dhcpig c) Scapy d) EttercapSS
  prefs: []
  type: TYPE_NORMAL
- en: 2) Which layer of the OSI model is where the IP address is? a) Data link b)
    Network c) Transport d) Application
  prefs: []
  type: TYPE_NORMAL
- en: 3) Which encryption element is used to mutually derive encryption keys? a) AES
    b) DES c) SHA384 d) Diffie-Hellman
  prefs: []
  type: TYPE_NORMAL
- en: 4) If you wanted to perform a SYN flood against a network target, which of these
    tools would you be most likely to use? a) Hping b) Dhcpig c) Ettercap d) Slowhttp
  prefs: []
  type: TYPE_NORMAL
- en: 5) What security property would be impacted if you were to cause a network device
    to fail if you were performing network testing? a) Confidentiality b) Integrity
    c) Availability d) Authenticity
  prefs: []
  type: TYPE_NORMAL
- en: 6) What might be the outcome of running *slowhttptest*? a) Web server failure
    b) Compromised credentials c) Obtaining cookies d) Stealing data
  prefs: []
  type: TYPE_NORMAL
- en: 7) What do you call an application that watches a process to ensure the process
    stays running? a) System manager b) Application manager c) Watchdog d) Log monitor
  prefs: []
  type: TYPE_NORMAL
- en: 8) What BPF syntax would you use to capture only unencrypted web packets with
    192.168.10.250 as an address? a) host 192.168.10.250 and web b) host 192.168.10.250
    and port 80 c) ip 192.168.10.250 and port 80 d) ip 192.168.10.250 and port 443
  prefs: []
  type: TYPE_NORMAL
- en: 9) What function would you use to send and receive using Scapy, printing details
    from the packet header that has been received? a) sendrecv() b) send() c) sr()
    d) sr1()
  prefs: []
  type: TYPE_NORMAL
- en: 10) If you wanted to make sure devices on a network obtained IP configuration
    that you controlled, what tool could you use to help you? a) Scapy b) Ettercap
    c) Dhcpig d) Wireshark
  prefs: []
  type: TYPE_NORMAL
- en: Useful Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dug Song’s [dsniff Page](https://monkey.org/~dugsong/dsniff/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ric Messier’s [“TCP/IP” video](http://bit.ly/tcp-ip-video) (Infinite Skills,
    2013)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*TCP/IP Network Administration*, 3e](http://bit.ly/tcp-ip-network-admin-3e),
    by Craig Hunt (O’Reilly, 2010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
