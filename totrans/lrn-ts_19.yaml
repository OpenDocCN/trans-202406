- en: Chapter 15\. Type Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditionals, maps
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With great power over types
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: comes great confusion
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TypeScript gives us awesome levels of power to define types in the type system.
    Even the logical modifiers from [Chapter 10, “Generics”](ch10.xhtml#generics_chapter)
    pale in comparison to the capabilities of the type operations in this chapter.
    Once you’ve completed this chapter, you’ll be able to mix, match, and modify types
    based on other types—giving you powerful ways to represent types in the type system.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Most of these fancy types are techniques you generally don’t want to use very
    frequently. You’ll want to understand them for the cases where they are useful,
    but beware: they can be difficult to read through when overused. Have fun!'
  prefs: []
  type: TYPE_NORMAL
- en: Mapped Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript provides syntax for creating a new type based on the properties
    of another type: in other words, *mapping* from one type to another. A *mapped
    type* in TypeScript is a type that takes in another type and performs some operation
    on each property of that type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapped types create a new type by creating a new property under each key in
    a set of keys. They use a syntax similar to index signatures, but instead of using
    a static key type with `:` like `[i: string]`, they use a computed type from the
    other type with `in` like `[K in OriginalType]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One common use case for mapped types is to create an object whose keys are
    each of the string literals in an existing union type. This `AnimalCounts` type
    creates a new object type where the keys are each of the values from the `Animals`
    union type and each of the values is `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Mapped types based on existing literals of unions are a convenient way to save
    space in declaring big interfaces. But mapped types really shine when they can
    act on other types and even add or remove modifiers from members.
  prefs: []
  type: TYPE_NORMAL
- en: Mapped Types from Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mapped types commonly act on existing types using the `keyof` operator to grab
    the keys of that existing type. By instructing a type to map over the keys of
    an existing type, we can *map* from that existing type to a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `AnimalCounts` type ends up being the same as the `AnimalCounts` type
    from before by mapping from the `AnimalVariants` type to a new equivalent one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The new type keys mapped over a `keyof`—named `K` in the previous snippets—are
    known to be keys of the original type. That means each mapped type member value
    is allowed to reference the original type’s corresponding member value under the
    same key.
  prefs: []
  type: TYPE_NORMAL
- en: If the original object is `SomeName` and the mapping is `[K in keyof SomeName]`,
    then each member in the mapped type would be able to refer to the equivalent `SomeName`
    member’s value as `SomeName[K]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `NullableBirdVariants` type takes an original `BirdVariants` type and
    adds `| null` to each member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Instead of painstakingly copying each field from an original type to any number
    of other types, mapped types let you define a set of members once and re-create
    new versions of them en masse as many times as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Mapped types and signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 7, “Interfaces”](ch07.xhtml#interfaces), I introduced that TypeScript
    provides two ways of declaring interface members as functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Method* syntax, like `member(): void`: declaring that a member of the interface
    is a function intended to be called as a member of the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Property* syntax, like `member: () => void`: declaring that a member of the
    interface is equal to a standalone function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapped types don’t distinguish between method and property syntaxes on object
    types. Mapped types treat methods as properties on original types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ResearcherProperties` type contains both the `property` and `method`
    members of `Researcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The distinction between methods and properties does not show up very often in
    most practical TypeScript code. It’s rare to find a practical use of a mapped
    type that takes in a class type.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mapped types can also change the access control modifiers—`readonly` and `?`
    optionality—on the original type’s members. `readonly` or `?` can be placed on
    members of mapped types using the same syntax as typical interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `ReadonlyEnvironmentalist` type makes a version of the `Environmentalist`
    interface with all members given `readonly`, while `OptionalReadonlyConservationist`
    goes one step further and makes another version that adds `?` to all the `ReadonlyEnvironmentalist`
    members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `OptionalReadonlyEnvironmentalist` type could alternately be written with
    `readonly [K in keyof Environmentalist]?: Environmentalist[K]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing modifiers is done by adding a `-` before the modifier in a new type.
    Instead of writing `readonly` or `?:`, you can write `-readonly` or `-?:`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Conservationist` type contains `?` optional and/or `readonly` members
    that are made writable in `WritableConservationist` and then also required in
    `RequiredWritableConservationist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `RequiredWritableConservationist` type could alternately be written with
    `-readonly [K in keyof Conservationist]-?:` `Conservationist[K]`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Mapped Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The full power of mapped types comes from combining them with generics, allowing
    a single kind of mapping to be reused across different types. Mapped types are
    able to access the `keyof` any type name in their scope, including a type parameter
    on the mapped type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Generic mapped types are frequently useful for representing how data morphs
    as it flows through an application. For example, it may be desirable for an area
    of the application to be able to take in values of existing types but not be allowed
    to modify the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `MakeReadonly` generic type takes in any type and creates a new version
    with the `readonly` modifier added to all its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another transform developers commonly need to represent is a function that takes
    in any amount of an interface and returns a fully filled-out instance of that
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `MakeOptional` type and `createGenusData` function allow for
    providing any amount of the `GenusData` interface and getting back an object with
    the defaults filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Some operations done by generic mapped types are so useful that TypeScript provides
    utility types for them out-of-the-box. Making all properties optional, for example,
    is achievable using the built-in `Partial<T>` type. You can find a list of those
    built-in types on [*https://www.typescriptlang.org/docs/handbook/utility-types.html*](https://www.typescriptlang.org/docs/handbook/utility-types.html).
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mapping existing types to other types is nifty, but we haven’t yet added logical
    conditions into the type system. Let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript’s type system is an example of a *logic programming language*. It
    allows creating new constructs (types) based on logically checking previous types.
    It does so with the concept of a *conditional type*: a type that resolves to one
    of two possible types, based on an existing type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional type syntax looks like ternaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The logical check in a conditional type is always on whether the left type *extends*,
    or is assignable to, the right type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `CheckStringAgainstNumber` conditional type checks whether `string
    extends number`—or in other words, whether the `string` type is assignable to
    the `number` type. It’s not, so the resultant type is the “if false” case: `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Much of the rest of this chapter will involve combining other type system features
    with conditional types. As the code snippets get more complex, remember: each
    conditional type is purely a piece of boolean logic. Each takes in some type and
    results in one of two possible results.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Conditional Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional types are able to check any type name in their scope, including
    a type parameter on the conditional type itself. That means you can write reusable
    generic types to create new types based on any other types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turning the previous `CheckStringAgainstNumber` type into a generic `CheckAgainstNumber`
    gives a type that is either `true` or `false` based on whether the previous type
    is assignable to `number`. `string` is still not true, while `number` and `0 |
    1` both are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `CallableSetting` type is a little more useful. It takes in a
    generic `T` and checks whether `T` is a function. If `T` is, then the resultant
    type is `T`—as with `GetNumbersSetting` where `T` is `() => number[]`. Otherwise,
    the resultant type is a function that returns `T`, as with `StringSetting` where
    `T` is `string`, and so the resultant type is `() => string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Conditional types are also able to access members of provided types with the
    object member lookup syntax. They can use that information both in their `extends`
    clause and/or in the resultant types.
  prefs: []
  type: TYPE_NORMAL
- en: One pattern used by JavaScript libraries that lends itself well to conditional
    generic types is to change the return type of a function based on an options object
    provided to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, many database functions or equivalents might use a property like
    `throwIfNotFound` to change the function to throw an error instead of returning
    `undefined` if a value isn’t found. The following `QueryResult` type models that
    behavior by resulting in the more narrow `string` instead of `string | undefined`
    if the options’ `throwIfNotFound` is specifically known to be `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By combining a conditional type with a generic type parameter, that `retrieve`
    function is more precise in telling the type system how it will change its program’s
    control flow.
  prefs: []
  type: TYPE_NORMAL
- en: Type Distributivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conditional types *distribute* over unions, meaning their resultant type will
    be a union of applying that conditional type to each of the constituents (types
    in the union type). In other words, `ConditionalType<T | U>` is the same as `Conditional<T>
    | Conditional<U>`.
  prefs: []
  type: TYPE_NORMAL
- en: Type distributivity is a mouthful to explain but is important for how conditional
    types behave with unions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `ArrayifyUnlessString` type that converts its type parameter
    `T` to an array unless `T extends string`. `HalfArrayified` is equivalent to `string
    | number[]` because `ArrayifyUnlessString<string | number>` is the same as `ArrayifyUnlessString<string>
    | ArrayifyUnlessString<number>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If TypeScript’s conditional types didn’t distribute across unions, `HalfArrayified`
    would be `(string | number)[]` because `string | number` is not assignable to
    `string`. In other words, conditional types apply their logic to each constituent
    of a union type, not the whole union type.
  prefs: []
  type: TYPE_NORMAL
- en: Inferred Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Accessing members of provided types works well for information stored as a member
    of a type, but it can’t capture other information such as function parameters
    or return types. Conditional types are able to access arbitrary portions of their
    condition by using an `infer` keyword within their extends clause. Placing the
    `infer` keyword and a new name for a type within an extends clause means that
    new type will be available inside the conditional type’s true case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ArrayItems` type takes in a type parameter `T` and checks whether the
    `T` is an array of some new `Item` type. If it is, the resultant type is `Item`;
    if not, it’s `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inferred types can work to create recursive conditional types too. The `ArrayItems`
    type seen previously could be extended to retrieve the item type of an array of
    any dimensionality recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that while `ArrayItems<string[][]>` resulted in `string[]`, `ArrayItemsRecursive<string[][]>`
    resulted in `string`. That ability for generic types to be recursive allows them
    to keep applying modifications—such as retrieving the element type of an array
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Mapped Conditional Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mapped types apply a change to every member of an existing type. Conditional
    types apply a change to a single existing type. Put together, they allow for applying
    conditional logic to each member of a generic template type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `MakeAllMembersFunctions` type turns each nonfunction member of a type
    into a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Mapped conditional types are a convenient way to modify all properties of an
    existing type using some logical check.
  prefs: []
  type: TYPE_NORMAL
- en: never
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4, “Objects”](ch04.xhtml#objects), I introduced the `never` type,
    a bottom type, which means it can have no possible values and can’t be reached.
    Adding a `never` type annotation in the right place can tell TypeScript to be
    more aggressive about detecting never-hit code paths in the type system as well
    as in the previous examples of runtime code.
  prefs: []
  type: TYPE_NORMAL
- en: never and Intersections and Unions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way of describing the `never` bottom type is that it’s a type that
    can’t exist. That gives `never` some interesting behaviors with `&` intersection
    and `|` union types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`never` in an `&` intersection type reduces the intersection type to just `never`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never` in a `|` union type is ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These `NeverIntersection` and `NeverUnion` types illustrate those behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the behavior of being ignored in union types makes `never` useful
    for filtering out values from conditional and mapped types.
  prefs: []
  type: TYPE_NORMAL
- en: never and Conditional Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generic conditional types commonly use `never` to filter out types from unions.
    Because `never` is ignored in unions, the result of a generic conditional on a
    union of types will only be those that are not `never`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `OnlyStrings` generic conditional type filters out types that aren’t strings,
    so the `RedOrBlue` type filters out `0` and `null` from the union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`never` is also commonly combined with inferred conditional types when making
    type utilities for generic types. Type inferences with `infer` have to be in the
    true case of a conditional type, so if the false case is never meant to be used,
    `never` is a suitable type to put there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `FirstParameter` type takes in a function type `T`, checks if it’s a function
    with an `arg: infer Arg`, and returns that `Arg` if so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using `never` in the false case of the conditional type allowed `FirstParameter`
    to extract the type of the function’s first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: never and Mapped Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `never` behavior in unions makes it useful for filtering out members in
    mapped types too. It’s possible to filter out keys of an object using the following
    three type system features:'
  prefs: []
  type: TYPE_NORMAL
- en: '`never` is ignored in unions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapped types can map members of types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional types can be used to turn types into `never` if a condition is met.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting the three of those together, we can create a mapped type that changes
    each member of the original type either to the original key or to `never`. Asking
    for the members of that type with `[keyof T]`, then, produces a union of all those
    mapped type results, filtering out `never`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `OnlyStringProperties` type turns each `T[K]` member into either
    the `K` key if that member is a string, or `never` if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Another way of reading the `OnlyStringProperties<T>` type is that it filters
    out all non-`string` properties (switches them to `never`), then gives back all
    the remaining keys (`[keyof T]`).
  prefs: []
  type: TYPE_NORMAL
- en: Template Literal Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve covered a lot on conditional and/or mapped types now. Let’s switch to
    less logic-intensive types and focus on strings for a while instead. So far I’ve
    brought up two strategies for typing string values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The primitive `string` type: for when the value can be any string in the world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Literal types such as `""` and `"abc"`: for when the value can only be that
    one type (or a union of them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes, however, you may want to indicate that a string matches some string
    pattern: part of the string is known, but part of it is not. Enter *template literal
    types*, a TypeScript syntax for indicating that a string type adheres to a pattern.
    They look like template literal strings—hence their name—but with primitive types
    or unions of primitive types interpolated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This template literal type indicates that the string must start with `"Hello"`
    but can end with any string (`string`). Names that start with `"Hello"` such as
    `"Hello, world!"` match, but not `"World! Hello!"` or `"hi"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: String literal types—and unions of them—may be used in the type interpolation
    instead of the catchall `string` primitive to restrict template literal types
    to more narrow patterns of strings. Template literal types can be quite useful
    for describing strings that must match a restricted set of allowed strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `BrightnessAndColor` matches only strings that start with a `Brightness`,
    end with a `Color`, and have a `-` hyphen in-between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Without template literal types, we would have had to laboriously write out all
    four combinations of `Brightness` and `Color`. That would get cumbersome if we
    added more string literals to either of them!
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript allows template literal types to contain any primitives (other than
    `symbol`) or a union thereof: `string`, `number`, `bigint`, `boolean`, `null`,
    or `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ExtolNumber` type allows any string that starts with `"much "`, includes
    a string that looks like a number, and ends with `"wow"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Intrinsic String Manipulation Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To assist in working with string types, TypeScript provides a small set of
    intrinsic (meaning: they’re built into TypeScript) generic utility types that
    take in a string and apply some operation to the string. As of TypeScript 4.7.2,
    there are four:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Uppercase`: Converts a string literal type to uppercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lowercase`: Converts a string literal type to lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Capitalize`: Converts a first character of string literal type to uppercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uncapitalize`: Converts a first character of string literal type to lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these can be used as a generic type that takes in a string. For example,
    using `Capitalize` to capitalize the first letter in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These intrinsic string manipulation types can be quite useful for manipulating
    property keys on object types.
  prefs: []
  type: TYPE_NORMAL
- en: Template Literal Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template literal types are a half-way point between the primitive `string` and
    string literals, which means they’re still strings. They can be used in any other
    place where you’d be able to use string literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use them as the index signature in a mapped type. This
    `ExistenceChecks` type has a key for every string in `DataKey`, mapped with `check${Capitalize<DataKey>}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Remapping Mapped Type Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript allows you to create new keys for members of mapped types based on
    the original members using template literal types. Placing the `as` keyword followed
    by a template literal type for the index signature in a mapped typed changes the
    resultant type’s keys to match the template literal type. Doing so allows the
    mapped type to have a different key for each mapped property while still referring
    to the original value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `DataEntryGetters` is a mapped type whose keys are `getLocation`, `getName`,
    and `getYear`. Each key is mapped to a new key with a template literal type. Each
    mapped value is a function whose return type is a `DataEntry` using the original
    `K` key as a type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Key remappings can be combined with other type operations to create mapped types
    that are based on existing type shapes. One fun combination is using `keyof typeof`
    on an existing object to make a mapped type off that object’s type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ConfigGetter` type is based on the `config` type, but each field is a
    function that returns the original config, and the keys are modified from the
    original key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in JavaScript, object keys may be type `string` or `Symbol`—and `Symbol`
    keys aren’t usable as template literal types because they’re not primitives. If
    you try to use a remapped template literal type key in a generic type, TypeScript
    will issue a complaint that `symbol` can’t be used in a template literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To get around that restriction, you can use a `string &` intersection type
    to enforce that only types that can be strings are used. Because `string & symbol`
    results in `never`, the whole template string will reduce to `never` and TypeScript
    will ignore it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript’s behavior of filtering out `never` types from unions is proving
    itself useful yet again!
  prefs: []
  type: TYPE_NORMAL
- en: Type Operations and Complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is twice as hard as writing the code in the first place. Therefore,
    if you write the code as cleverly as possible, you are, by definition, not smart
    enough to debug it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brian Kernighan
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The type operations described in this chapter are among the most powerful, cutting-edge
    type system features in any programming language today. Most developers are not
    yet familiar enough with them to be able to debug errors in significantly complex
    uses of them. Industry-standard development tools such as IDE features I cover
    in [Chapter 12, “Using IDE Features”](ch12.xhtml#using_ide_features) aren’t generally
    made for visualizing multilayered type operations used with each other.
  prefs: []
  type: TYPE_NORMAL
- en: If you do find a need to use type operations, please—for the sake of any developer
    who has to read your code, including a future you—try to keep them to a minimum
    if possible. Use readable names that help readers understand the code as they
    read it. Leave descriptive comments for anything you think future readers might
    struggle with.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you unlocked the true power of TypeScript by operating on
    types in its type system:'
  prefs: []
  type: TYPE_NORMAL
- en: Using mapped types to transform existing types into new ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing logic into type operations with conditional types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how `never` interacts with intersections, unions, conditional types,
    and mapped types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing patterns of string types using template literal types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining template literal types and mapped types to modify type keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/type-operations*](https://learningtypescript.com/type-operations).
  prefs: []
  type: TYPE_NORMAL
- en: When you’re lost in the type system, what do you use?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A mapped type!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
