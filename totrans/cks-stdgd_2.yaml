- en: Chapter 2\. Cluster Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first domain of the exam deals with concerns related to Kubernetes cluster
    setup and configuration. In this chapter, we’ll only drill into the security-specific
    aspects and not the standard responsibilities of a Kubernetes administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using network policies to restrict Pod-to-Pod communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running CIS benchmark tooling to identify security risks for cluster components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an Ingress object with TLS support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting node ports, API endpoints, and GUI access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying platform binaries against their checksums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Network Policies to Restrict Pod-to-Pod Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a microservice architecture to function in Kubernetes, a Pod needs to be
    able to reach another Pod running on the same or on a different node without Network
    Address Translation (NAT). Kubernetes assigns a unique IP address to every Pod
    upon creation from the Pod CIDR range of its node. The IP address is ephemeral
    and therefore cannot be considered stable over time. Every restart of a Pod leases
    a new IP address. It’s recommended to use Pod-to-Service communication over Pod-to-Pod
    communication so that you can rely on a consistent network interface.
  prefs: []
  type: TYPE_NORMAL
- en: The IP address assigned to a Pod is unique across all nodes and namespaces.
    This is achieved by assigning a dedicated subnet to each node when registering
    it. When creating a new Pod on a node, the IP address is leased from the assigned
    subnet. This is handled by the Container Network Interface (CNI) plugin. As a
    result, Pods on a node can communicate with all other Pods running on any other
    node of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Network policies act similarly to firewall rules, but for Pod-to-Pod communication.
    Rules can include the direction of network traffic (ingress and/or egress) for
    one or many Pods within a namespace or across different namespaces, as well as
    their targeted ports. For a deep-dive coverage on the basics of network policies,
    refer to the book [*Certified Kubernetes Application Developer (CKAD) Study Guide*](https://learning.oreilly.com/library/view/certified-kubernetes-application/9781492083726)
    (O’Reilly) or the [Kubernetes documentation](https://oreil.ly/WChde). The CKS
    exam primarily focuses on restricting cluster-level access with network policies.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the rules of network policies correctly can be challenging. The page
    [networkpolicy.io](https://networkpolicy.io) provides a visual editor for network
    policies that renders a graphical representation in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: Attacker Gains Access to a Pod'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say you are working for a company that operates a Kubernetes cluster with three
    worker nodes. Worker node 1 currently runs two Pods as part of a microservices
    architecture. Given Kubernetes default behavior for Pod-to-Pod network communication,
    Pod 1 can talk to Pod 2 unrestrictedly and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 2-1](#pod-to-pod-communication-attacker), an attacker
    gained access to Pod 1\. Without defining network policies, the attacker can simply
    talk to Pod 2 and cause additional damage. This vulnerability isn’t restricted
    to a single namespace. Pods 3 and 4 can be reached and compromised as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0201](assets/ckss_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. An attacker who gained access to Pod 1 has network access to other
    Pods
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Observing the Default Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll set up three Pods to demonstrate the unrestricted Pod-to-Pod network communication
    in practice. As you can see in [Example 2-1](#setup-network-policy), the YAML
    manifest defines the Pods named `backend` and `frontend` in the namespace `g04`.
    The `other` Pod lives in the `default` namespace. Observe the label assignment
    for the namespace and Pods. We will reference them a little bit later in this
    chapter when defining network policies.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. YAML manifest for three Pods in different namespaces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by creating the objects from the existing YAML manifest using the declarative
    `kubectl apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s verify that the namespace `g04` runs the correct Pods. Use the `-o wide`
    CLI option to determine the virtual IP addresses assigned to the Pods. The `backend`
    Pod uses the IP address 10.0.0.43, and the `frontend` Pod uses the IP address
    10.0.0.193:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `default` namespace handles a single Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `frontend` Pod can talk to the `backend` Pod as no communication restrictions
    have been put in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `other` Pod residing in the `default` namespace can communicate with the
    `backend` Pod without problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll talk about restricting Pod-to-Pod network communication
    to a maximum level with the help of deny-all network policy rules. We’ll then
    open up ingress and/or egress communication only for the kind of network communication
    required for the microservices architecture to function properly.
  prefs: []
  type: TYPE_NORMAL
- en: Denying Directional Network Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to restrict Pod-to-Pod network traffic is with the principle of
    least privilege. Least privilege means that Pods should communicate with the lowest
    privilege for network communication. You’d usually start by disallowing traffic
    in any direction and then opening up the traffic needed by the application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The [Kubernetes documentation](https://oreil.ly/PZOGf) provides a couple of
    helpful YAML manifest examples. [Example 2-2](#deny-ingress-network-policy) shows
    a network policy that denies ingress traffic to all Pods in the namespace `g04`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. A default deny-all ingress network policy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Selecting all Pods is denoted by the value `{}` assigned to the `spec.podSelector`
    attribute. The value attribute `spec.policyTypes` defines the denied direction
    of traffic. For incoming traffic, you can add `Ingress` to the array. Outgoing
    traffic can be specified by the value `Egress`. In this particular example, we
    disallow all ingress traffic. Egress traffic is still permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the “deny-all” network policy have been saved in the file `deny-all-ingress-network-policy.yaml`.
    The following command creates the object from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see how this changed the runtime behavior for Pod-to-Pod network communication.
    The `frontend` Pod cannot talk to the `backend` Pod anymore, as observed by running
    the same `wget` command we used earlier. The network call times out after one
    second, as defined by the CLI option `--timeout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, Pods running in a different namespace cannot connect to the `backend`
    Pod anymore either. The following `wget` command makes a call from the `other`
    Pod running in the `default` namespace to the IP address of the `backend` Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This call times out as well.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Fine-Grained Incoming Traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network policies are additive. To grant more permissions for network communication,
    simply create another network policy with more fine-grained rules. Say we wanted
    to allow ingress traffic to the `backend` Pod only from the `frontend` Pod that
    lives in the same namespace. Ingress traffic from all other Pods should be denied
    independently of the namespace they are running in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network policies heavily work with label selection to define rules. Identify
    the labels of the `g04` namespace and the Pod objects running in the same namespace
    so we can use them in the network policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The label assignment for the namespace `g04` includes the key-value pair `app=orion`.
    The Pod `backend` label set includes the key-value pair `tier=backend`, and the
    `frontend` Pod the key-value pair `tier=frontend`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new network policy that allows the `frontend` Pod to talk to the `backend`
    Pod only on port 3000\. No other communication should be allowed. The YAML manifest
    representation in [Example 2-3](#ingress-network-policy) shows the full network
    policy definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Network policy that allows ingress traffic
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the network policy has been stored in the file `backend-ingress-network-policy.yaml`.
    Create the object from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `frontend` Pod can now talk to the `backend` Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Pods running outside of the `g04` namespace still can’t connect to the `backend`
    Pod. The `wget` command times out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Applying Kubernetes Component Security Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing an on-premises Kubernetes cluster gives you full control over the configuration
    options applied to cluster components, such as the API server, etcd, the kubelet,
    and others. It’s not uncommon to simply go with the default configuration settings
    used by `kubeadm` when creating the cluster nodes. Some of those default settings
    may expose cluster components to unnecessary attack opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening the security measures of a cluster is a crucial activity for any Kubernetes
    administrator seeking to minimize attack vectors. You can either perform this
    activity manually if you are aware of the best practices, or use an automated
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The [Center for Internet Security (CIS)](https://www.cisecurity.org) is a not-for-profit
    organization that publishes cybersecurity best practices. Part of their best practices
    portfolio is the [Kubernetes CIS Benchmark](https://oreil.ly/CUe_D), a catalog
    of best practices for Kubernetes environments. You will find a detailed list of
    recommended security settings for cluster components on their web page.
  prefs: []
  type: TYPE_NORMAL
- en: CIS benchmarking for cloud provider Kubernetes environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes CIS Benchmark is geared toward a self-managed installation of
    Kubernetes. Cloud provider Kubernetes environments, such as Amazon Elastic Kubernetes
    Service (EKS) and Google Kubernetes Engine (GKE), provide a managed control plane
    accompanied by their own command line tools. Therefore, the security recommendations
    made by the Kubernetes CIS Benchmark may be less fitting. Some tools, like kube-bench,
    discussed next, provide verification checks specifically for cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Using kube-bench
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the tool [kube-bench](https://oreil.ly/y3mbO) to check Kubernetes
    cluster components against the CIS Benchmark best practices in an automated fashion.
    Kube-bench can be executed in a variety of ways. For example, you can install
    it as a platform-specific binary in the form of an RPM or Debian file. The most
    convenient and direct way to run the verification process is by running kube-bench
    in a Pod directly on the Kubernetes cluster. For that purpose, create a Job object
    with the help of a YAML manifest checked into the GitHub repository of the tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the Job from the file `job-master.yaml`, or `job-node.yaml`
    depending on whether you want to inspect a control plane node or a worker node.
    The following command runs the verification checks against the control plane node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon Job execution, the corresponding Pod running the verification process
    can be identified by its name in the `default` namespace. The Pod’s name starts
    with the prefix `kube-bench`, then appended with the type of the node plus a hash
    at the end. The following output uses the Pod named `kube-bench-master-8f6qh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait until the Pod transitions into the “Completed” status to ensure that all
    verification checks have finished. You can have a look at the benchmark result
    by dumping the logs of the Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it may be more convenient to write the verification results to a
    file. You can redirect the output of the `kubectl logs` command to a file, e.g.,
    with the command `kubectl logs kube-bench-master-8f6qh > control-plane-kube-bench-results.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The kube-bench Verification Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The produced verification result can be lengthy and detailed, but it consists
    of these key elements: the type of the inspected node, the inspected components,
    a list of passed checks, a list of failed checks, a list of warnings, and a high-level
    summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cluster_setup_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The inspected node, in this case the control plane node.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cluster_setup_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A passed check. Here, the file permissions of the API server configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_cluster_setup_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A warning message that prompts you to manually check the value of an argument
    provided to the API server executable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_cluster_setup_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A failed check. For example, the flag `--kubelet-certificate-authority` should
    be set for the API server executable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_cluster_setup_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The remediation action to take to fix a problem. The number, e.g., 1.2.1, of
    the failure or warning corresponds to the number assigned to the remediation action.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_cluster_setup_CO1-11)'
  prefs: []
  type: TYPE_NORMAL
- en: The summary of all passed and failed checks plus warning and informational messages.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing Detected Security Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The list of reported warnings and failures can be a bit overwhelming at first.
    Keep in mind that you do not have to fix them all at once. Some checks are merely
    guidelines or prompts to verify an assigned value for a configuration. The following
    steps walk you through the process of eliminating a warning message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration files of the control plane components can be found in the
    directory `/etc/kubernetes/manifests` on the host system of the control plane
    node. Say you wanted to fix the warning 1.2.12 reported by kube-bench:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As proposed by the remediation action, you are supposed to edit the configuration
    file for the API server and add the value `AlwaysPullImages` to the list of admission
    plugins. Go ahead and edit the file `kube-apiserver.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After appending the value `AlwaysPullImages` to the argument `--enable-admission-plugins`,
    the result could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the changes to the file. The Pod running the API server in the `kube-system`
    namespace will be restarted automatically. The startup process can take a couple
    of seconds. Therefore, executing the following command may take a while to succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to delete the existing Job object before you can verify the changed
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The verification check 1.2.12 now reports a passed result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Ingress with TLS Termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ingress routes HTTP and/or HTTPS traffic from outside of the cluster to one
    or many Services based on a matching URL context path. You can see its functionality
    in action in [Figure 2-2](#ingress_traffic_routing).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0202](assets/ckss_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Managing external access to the Services via HTTP(S)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Ingress has been configured to accept HTTP and HTTPS traffic from outside
    of the cluster. If the caller provides the context path `/app`, then the traffic
    is routed to Service 1\. If the caller provides the context path `/api`, then
    the traffic is routed to Service 2\. It’s important to point out that the communication
    typically uses unencrypted HTTP network communication as soon as it passes the
    Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the Ingress API resource is a part of the CKAD and CKA exam, we are
    not going to discuss the basics anymore here. For a detailed discussion, refer
    to the information in the [*Certified Kubernetes Administrator (CKA) Study Guide*](https://oreil.ly/cka-study-guide)
    or the [Kubernetes documentation](https://oreil.ly/wmk2s).
  prefs: []
  type: TYPE_NORMAL
- en: The role of an Ingress controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember that an Ingress cannot work without an Ingress controller. The Ingress
    controller evaluates the collection of rules defined by an Ingress that determine
    traffic routing. One example of a production-grade Ingress controller is the [F5
    NGINX Ingress Controller](https://oreil.ly/jOo6P) or [AKS Application Gateway
    Ingress Controller](https://oreil.ly/ckuqf). You can find other options listed
    in the [Kubernetes documentation](https://oreil.ly/BXx8e). If you are using minikube,
    make sure to [enable the Ingress add-on](https://oreil.ly/11QAA).
  prefs: []
  type: TYPE_NORMAL
- en: The primary focus of the CKS lies on setting up Ingress objects with TLS termination.
    Configuring the Ingress for HTTPS communication relieves you from having to deal
    with securing the network communication on the Service level. In this section
    of the book, you will learn how to create a TLS certificate and key, how to feed
    the certificate and key to a TLS-typed Secret object, and how to configure an
    Ingress object so that it supports HTTPS communication.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Ingress Backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of an Ingress, a *backend* is the combination of Service name
    and port. Before creating the Ingress, we’ll take care of the Service, a Deployment,
    and the Pods running nginx so we can later on demonstrate the routing of HTTPS
    traffic to an actual application. All of those objects are supposed to exist in
    the namespace `t75`. [Example 2-4](#ingress-setup) defines all of those resources
    in a single YAML manifest file `setup.yaml` as a means to quickly create the Ingress
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. YAML manifest for exposing nginx through a Service
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the objects from the YAML file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly verify that the objects have been created properly, and the Pods
    have transitioned into the “Running” status. Upon executing the `get all` command,
    you should see a Deployment named `nginx-deployment` that controls three replicas,
    and a Service named `accounting-service` of type `ClusterIP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the Service endpoint from another Pod running on the same node should
    result in a successful response from the nginx Pod. Here, we are using the `wget`
    command to verify the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '****With those objects in place and functioning as expected, we can now concentrate
    on creating an Ingress with TLS termination.****  ****## Creating the TLS Certificate
    and Key'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to generate a TLS certificate and key before we can create a TLS
    Secret. To do this, we will use the OpenSSL command. The resulting files are named
    `accounting.crt` and `accounting.key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For use in production environments, you’d generate a key file and use it to
    obtain a TLS certificate from a certificate authority (CA). For more information
    on creating a TLS certification and key, see the [OpenSSL documentation](https://oreil.ly/sETSb).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the TLS-Typed Secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to create a Secret is with the help of an imperative command.
    This method of creation doesn’t require you to manually base64-encode the certificate
    and key values. The encoding happens automatically upon object creation. The following
    command uses the Secret option `tls` and assigns the certificate and key file
    name with the options `--cert` and `--key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 2-5](#tls-secret) shows the YAML representation of a TLS Secret if
    you want to create the object declaratively.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. A Secret using the type `kubernetes.io/tls`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to assign the values for the attributes `tls.crt` and `tls.key` as
    single-line, base64-encoded values. To produce the base64-encoded value, simply
    point the `base64` command to the file name you want to convert the contents for.
    The following example base64-encoded the contents of the file `accounting.crt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Ingress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the imperative method to create the Ingress with the help of a
    one-liner command shown in the following snippet. Crafting the value of the `--rule`
    argument is hard to get right. You will likely have to refer to the `--help` option
    for the `create ingress` command as it requires a specific expression. The information
    relevant to creating the connection between Ingress object and the TLS Secret
    is the appended argument `tls=accounting-secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 2-6](#ingress-tls-termination) shows a YAML representation of an Ingress.
    The attribute for defining the TLS information is `spec.tls[]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. A YAML manifest for defining a TLS-terminated Ingress
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the Ingress object with the imperative or declarative approach,
    you should be able to find it in the namespace `t75`. As you can see in the following
    output, the port 443 is listed in the “PORT” column, indicating that TLS termination
    has been enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Describing the Ingress object shows that the backend could be mapped to the
    path `/` and will route traffic to the Pod via the Service named `accounting-service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Calling the Ingress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the behavior on a local Kubernetes cluster on your machine, you need
    to first find out the IP address of a node. The following command reveals the
    IP address in a minikube environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you’ll need to add the IP address to the hostname mapping to your `/etc/hosts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now send HTTPS requests to the Ingress using the assigned domain name
    and receive an HTTP response code 200 in return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]****  ****# Protecting Node Metadata and Endpoints'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes clusters expose ports used to communicate with cluster components.
    For example, the API server uses the port 6443 by default to enable clients like
    `kubectl` to talk to it when executing commands.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes documentation lists those ports in [“Ports and Protocols”](https://oreil.ly/iN993).
    The following two tables show the default port assignments per node.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-1](#control-plane-node-ports) shows the default inbound ports on the
    cluster node.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Inbound control plane node ports
  prefs: []
  type: TYPE_NORMAL
- en: '| Port range | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 6643 | Kubernetes API server |'
  prefs: []
  type: TYPE_TB
- en: '| 2379–2380 | etcd server client API |'
  prefs: []
  type: TYPE_TB
- en: '| 10250 | Kubelet API |'
  prefs: []
  type: TYPE_TB
- en: '| 10259 | kube-scheduler |'
  prefs: []
  type: TYPE_TB
- en: '| 10257 | kube-controller-manager |'
  prefs: []
  type: TYPE_TB
- en: Many of those ports are configurable. For example, you can modify the API server
    port by providing a different value with the flag `--secure-port` in the configuration
    file `/etc/kubernetes/manifests/kube-apiserver.yaml`, as [documented](https://oreil.ly/TTzAz)
    for the cluster component. For all other cluster components, please refer to their
    corresponding documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-2](#worker-node-ports) lists the default inbound ports on a worker
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Inbound worker node ports
  prefs: []
  type: TYPE_NORMAL
- en: '| Port range | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10250 | Kubelet API |'
  prefs: []
  type: TYPE_TB
- en: '| 30000–32767 | NodePort Services |'
  prefs: []
  type: TYPE_TB
- en: To secure the ports used by cluster components, set up firewall rules to minimize
    the attack surface area. For example, you could decide not to expose the API server
    to anyone outside of the intranet. Clients using `kubectl` would only be able
    to run commands against the Kubernetes cluster if logged into the VPN, making
    the cluster less vulnerable to attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud provider Kubernetes clusters (e.g., on AWS, Azure, or Google Cloud) expose
    so-called metadata services. Metadata services are APIs that can provide sensitive
    data like an authentication token for consumption from VMs or Pods without any
    additional authorization. For the CKS exam, you need to be aware of those node
    endpoints and cloud provider metadata services. Furthermore, you should have a
    high-level understanding of how to protect them from unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: A Compromised Pod Can Access the Metadata Server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 2-3](#metadata-server-attacker) shows an attacker who gained access
    to a Pod running on a node within a cloud provider Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0203](assets/ckss_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. An attacker who gained access to the Pod has access to metadata
    server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Access to the metadata server has not been restricted in any form. The attacker
    can retrieve sensitive information, which could open other possibilities of intrusion.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Metadata Server Access with Network Policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s pick one of the cloud providers that exposes a metadata endpoint. In AWS,
    the metadata server can be reached with the IP address 169.254.169.254, as described
    in the [AWS documentation](https://oreil.ly/6DsIx). The endpoints exposed can
    provide access to EC2 instance metadata. For example, you can retrieve the local
    IP address of an instance to manage a connection to an external application or
    to contact the instance with the help of a script. See the corresponding [documentation
    page](https://oreil.ly/Bwdej) for calls to those endpoints made with the curl
    command line tool.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent any Pod in a namespace from reaching the IP address of the metadata
    server, set up a network policy that allows egress traffic to all IP addresses
    except 169.254.169.254\. [Example 2-7](#deny-egress-metadata-server) demonstrates
    a YAML manifest with such a rule set.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. A default deny-all egress to IP address 169.254.169.254 network
    policy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once the network policy has been created, Pods in the namespace `a12` should
    not be able to reach the metadata endpoints anymore. For detailed examples that
    use the endpoints via `curl`, see the relevant [AWS documentation](https://oreil.ly/fQ07b).
  prefs: []
  type: TYPE_NORMAL
- en: Protecting GUI Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `kubectl` tool isn’t the only user interface (UI) for managing a cluster.
    While `kubectl` allows for fine-grained operations, most organizations prefer
    a more convenient graphical user interface (GUI) for managing the objects of a
    cluster. You can choose from a variety of options. The [Kubernetes Dashboard](https://oreil.ly/ABDQo)
    is a free, web-based application. Other GUI dashboards for Kubernetes like [Portainer](https://oreil.ly/i_FJv)
    go beyond the basic functionality by adding tracing of events or visualizations
    of hardware resource consumption. In this section, we’ll focus on the Kubernetes
    Dashboard as it is easy to install and configure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Gains Access to the Dashboard Functionality'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes Dashboard runs as a Pod inside of the cluster. Installing the
    Dashboard also creates a Service of type `ClusterIP` that only allows access to
    the endpoint from within the cluster. To make the Dashboard accessible to end
    users, you’d have to expose the Service outside of the cluster. For example, you
    could switch to a `NodePort` Service type or stand up an Ingress. [Figure 2-4](#dashboard-attacker)
    illustrates the high-level architecture of deploying and accessing the Dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0204](assets/ckss_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. An attacker who gained access to the Dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As soon as you expose the Dashboard to the outside world, attackers can potentially
    gain access to it. Without the right security settings, objects can be deleted,
    modified, or used for malicious purposes. The most prominent victim of such an
    attack was Tesla, which in 2018 fell prey to hackers who gained access to its
    unprotected Dashboard to mine cryptocurrencies. Since then, newer versions of
    the Dashboard changed default settings to make it more secure from the get-go.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Kubernetes Dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing the Kubernetes Dashboard is straightforward. You can create the
    relevant objects with the help of the YAML manifest available in the project’s
    GitHub repository. The following command installs all necessary objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Rendering metrics in Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may also want to install the [metrics server](https://oreil.ly/3Rtkl) if
    you are interested in inspecting resource consumption metrics as part of the Dashboard
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the objects created by the manifest in the `kubernetes-dashboard`
    namespace. Among them are Deployments, Pods, and Services. The following command
    lists all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the Kubernetes Dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `kubectl proxy` command can help with temporarily creating a proxy that
    allows you to open the Dashboard in a browser. This functionality is only meant
    for troubleshooting purposes and is not geared toward production environments.
    You can find information about the `proxy` command in the [documentation](https://oreil.ly/gGsqX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Open the browser with the URL [*http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy*](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy).
    The Dashboard will ask you to provide an authentication method and credentials.
    The recommended way to configure the Dashboard is through bearer tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a User with Administration Privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can authenticate in the login screen, you need to create a ServiceAccount
    and ClusterRoleBinding object that grant admin permissions. Start by creating
    the file `admin-user-serviceaccount.yaml` and populate it with the contents shown
    in [Example 2-8](#admin-user-serviceaccount).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Service account for admin permissions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next, store the contents of [Example 2-9](#admin-user-clusterrolebinding) in
    the file `admin-user-⁠clusterrole​bind⁠ing.yaml` to map the ClusterRole named
    `cluster-admin` to the ServiceAccount.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. ClusterRoleBinding for admin permissions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create both objects with the following declarative command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now create the bearer token of the admin user with the following command.
    The command will generate a token for the provided ServiceAccount object and render
    it on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Expiration of a service account token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, this token will expire after 24 hours. That means that the token
    object will be deleted automatically once the “time to live” (TTL) has passed.
    You can change the TTL of a token by providing the command line option `--ttl`.
    For example, a value of `40h` will expire the token after 40 hours. A value of
    `0` indicates that the token should never expire.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the output of the command and paste it into the “Enter token” field of
    the login screen, as shown in [Figure 2-5](#dashboard-login-screen-token).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0205](assets/ckss_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. The usage of the token in the Dashboard login screen
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Pressing the “Sign in” button will bring you to the Dashboard shown in [Figure 2-6](#dashboard-overview).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0206](assets/ckss_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. The Dashboard view of Pods in a specific namespace
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can now manage end user and cluster objects without any restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a User with Restricted Privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to create a user with cluster-wide
    administrative permissions. Most users of the Dashboard only need a restricted
    set of permissions, though. For example, developers implementing and operating
    cloud-native applications will likely only need a subset of administrative permissions
    to perform their tasks on a Kubernetes cluster. Creating a user for the Dashboard
    with restricted privileges consists of a three-step approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a ServiceAccount object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a ClusterRole object that defines the permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a ClusterRoleBinding that maps the ClusterRole to the ServiceAccount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the process is very similar to the one we went through for the
    admin user. Step 2 is new, as we need to be specific about which permissions we
    want to grant. The YAML manifests that follow will model a user working as a developer
    that should only be allowed read-only permissions (e.g., getting, listing, and
    watching resources).
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating the file `restricted-user-serviceaccount.yaml` and populate
    it with the contents shown in [Example 2-10](#restricted-user-serviceaccount).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. Service account for restricted permissions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The ClusterRole in [Example 2-11](#restricted-user-clusterrole) only allows
    getting, listing, and watching resources. All other operations are not permitted.
    Store the contents in the file `restricted-user-clusterrole.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. ClusterRole for restricted permissions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Last, map the ServiceAccount to the ClusterRole in the file `restricted-user-clusterrolebinding.yaml`,
    as shown in [Example 2-12](#restricted-user-clusterrolebinding).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. ClusterRoleBinding for restricted permissions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Create all objects with the following declarative command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the bearer token of the restricted user with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Operations that are not allowed for the logged-in user will not be rendered
    as disabled options in the GUI. You can still select the option; however, an error
    message is rendered. [Figure 2-7](#dashboard-forbidden-operation) illustrates
    the behavior of the Dashboard if you try to delete a Pod via the user that doesn’t
    have the permissions to perform the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0207](assets/ckss_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. An error message rendered when trying to invoke a permitted operation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Avoiding Insecure Configuration Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Securing the Dashboard in production environments involves the usage of [execution
    arguments](https://oreil.ly/gS1hE) necessary for properly configuring authentication
    and authorization. By default, login functionality is enabled and the HTTPS endpoint
    will be exposed on port 8443\. You can provide TLS certificates with the `--tls-cert-file`
    and `--tls-cert-key` command line options if you don’t want them to be auto-generated.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid setting the command line arguments `--insecure-port` to expose an HTTP
    endpoint and `--enable-insecure-login` to enable serving the login page over HTTP
    instead of HTTPS. Furthermore, make sure you *don’t* use the option `--enable-skip-login`
    as it would allow circumventing an authentication method by simply clicking a
    Skip button in the login screen.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Kubernetes Platform Binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes project publishes client and server binaries with every release.
    The client binary refers to the executable `kubectl`. Server binaries include
    `kubeadm`, as well as the executable for the API server, the scheduler, and the
    kubelet. You can find those files under the “tags” sections of the [Kubernetes
    GitHub repository](https://oreil.ly/vHpAV) or on the release page at [*https://dl.k8s.io*](https://dl.k8s.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Injected Malicious Code into Binary'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The executables `kubectl` and `kubeadm` are essential for interacting with Kubernetes.
    `kubectl` lets you run commands against the API server, e.g., for managing objects.
    `kubeadm` is necessary for upgrading cluster nodes from one version to another.
    Say you are in the [process of upgrading the cluster version](https://oreil.ly/hTJ57)
    from 1.23 to 1.24\. As part of the process, you will need to upgrade the `kubeadm`
    binary as well. The official upgrade documentation is very specific about what
    commands to use for upgrading the binary.
  prefs: []
  type: TYPE_NORMAL
- en: Say an attacker managed to modify the `kubeadm` executable for version 1.24
    and coaxed you into thinking that you need to download that very binary from a
    location where the malicious binary was placed. As shown in [Figure 2-8](#binary-attacker),
    you’d expose yourself to running malicious code every time you invoke the modified
    `kubeadm` executable. For example, you may be sending credentials to a server
    outside of your cluster, which would open new ways to infiltrate your Kubernetes
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0208](assets/ckss_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. An attacker who injected malicious code into a binary
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Verifying a Binary Against Hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can verify the validity of a binary with the help of a hash code like MD5
    or SHA. Kubernetes publishes SHA256 hash codes for each binary. You should run
    through a hash validation for individual binaries before using them for the first
    time. Should the generated hash code not match with the one you downloaded, then
    there’s something off with the binary. The binary may have been modified by a
    third party or you didn’t use the hash code for the correct binary type or version.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the corresponding hash code for a binary from [*https://dl.k8s.io*](https://dl.k8s.io).
    The full URL for a hash code reflects the version, operating system, and architecture
    of the binary. The following list shows example URLs for platform binaries compatible
    with Linux AMD64:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl`: [*https://dl.k8s.io/v1.26.1/bin/linux/amd64/kubectl.sha256*](https://dl.k8s.io/v1.26.1/bin/linux/amd64/kubectl.sha256)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubeadm`: [*https://dl.k8s.io/v1.26.1/bin/linux/amd64/kubeadm.sha256*](https://dl.k8s.io/v1.26.1/bin/linux/amd64/kubeadm.sha256)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubelet`: [*https://dl.k8s.io/v1.26.1/bin/linux/amd64/kubelet.sha256*](https://dl.k8s.io/v1.26.1/bin/linux/amd64/kubelet.sha256)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-apiserver`: [*https://dl.k8s.io/v1.26.1/bin/linux/amd64/kube-apiserver.sha256*](https://dl.k8s.io/v1.26.1/bin/linux/amd64/kube-apiserver.sha256)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You’ll have to use an operating system-specific hash code validation tool to
    check the validity of a binary. You may have to install the tool if you do not
    have it available on your machine yet. The following commands show the usage of
    the tool for different operating systems, as explained in the [Kubernetes documentation](https://oreil.ly/2FmVm):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux: `echo "$(cat kubectl.sha256) kubectl" | sha256sum --check`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MacOSX: `echo "$(cat kubectl.sha256) kubectl" | shasum -a 256 --check`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows with Powershell: `$($(CertUtil -hashfile .\kubectl.exe SHA256)[1] -replace
    " ", "") -eq $(type .\kubectl.exe.sha256)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following commands demonstrate downloading the `kubeadm` binary for version
    1.26.1 and its corresponding SHA256 hash file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation tool `shasum` can verify if the checksum matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The previous command returned with an “OK” message. The binary file wasn’t tampered
    with. Any other message indicates a potential security risk when executing the
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain “cluster setup” dials in on security aspects relevant to setting
    up a Kubernetes cluster. Even though you might be creating a cluster from scratch
    with `kubeadm`, that doesn’t mean you are necessarily following best practices.
    Using kube-bench to detect potential security risks is a good start. Fix the issues
    reported on by the tool one by one. You may also want to check client and server
    binaries against their checksums to ensure that they haven’t been modified by
    an attacker. Some organizations use a Dashboard to manage the cluster and its
    objects. Ensure that authentication and authorization for the Dashboard restrict
    access to a small subset of stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: An important security aspect is network communication. Pod-to-Pod communication
    is unrestricted by default. Have a close look at your application architecture
    running inside of Kubernetes. Only allow directional network traffic from and
    to Pods to fulfill the requirements of your architecture. Deny all other network
    traffic. When exposing the application outside of the cluster, make sure that
    Ingress objects have been configured with TLS termination. This will ensure that
    the data is encrypted both ways so that attackers cannot observe sensitive information
    like passwords sent between a client and the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the purpose and effects of network policies
  prefs: []
  type: TYPE_NORMAL
- en: By default, Pod-to-Pod communication is unrestricted. Instantiate a default
    deny rule to restrict Pod-to-Pod network traffic with the principle of least privilege.
    The attribute `spec.podSelector` of a network policy selects the target Pod the
    rules apply to based on label selection. The ingress and egress rules define Pods,
    namespaces, IP addresses, and ports for allowing incoming and outgoing traffic.
    Network policies can be aggregated. A default deny rule may disallow ingress and/or
    egress traffic. An additional network policy can open up those rules with a more
    fine-grained definition.
  prefs: []
  type: TYPE_NORMAL
- en: Practice the use of kube-bench to detect cluster component vulnerabilities
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes CIS Benchmark is a set of best practices for recommended security
    settings in a production Kubernetes environment. You can automate the process
    of detecting security risks with the help of the tool kube-bench. The generated
    report from running kube-bench describes detailed remediation actions to fix a
    detected issue. Learn how to interpret the results and how to mitigate the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to configure Ingress with TLS termination
  prefs: []
  type: TYPE_NORMAL
- en: An Ingress can be configured to send and receive encrypted data by exposing
    an HTTPS endpoint. For this to work, you need to create a TLS Secret object and
    assign it a TLS certificate and key. The Secret can then be consumed by the Ingress
    using the attribute `spec.tls[]`.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to configure GUI elements for secure access
  prefs: []
  type: TYPE_NORMAL
- en: GUI elements, such as the Kubernetes Dashboard, provide a convenient way to
    manage objects. Attackers can cause harm to your cluster if the application isn’t
    protected from unauthorized access. For the exam, you need to know how to properly
    set up RBAC for specific stakeholders. Moreover, you are expected to have a rough
    understanding of security-related command line arguments. Practice the installation
    process for the Dashboard, learn how to tweak its command line arguments, and
    understand the effects of setting permissions for different users.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to detect modified platform binaries
  prefs: []
  type: TYPE_NORMAL
- en: Platform binaries like `kubectl` and `kubeadm` can be verified against their
    corresponding hash code. Know where to find the hash file and how to use a validation
    tool to identify if the binary has been tempered with.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: Create a network policy that denies egress traffic to any domain outside of
    the cluster. The network policy applies to Pods with the label `app=backend` and
    also allows egress traffic for port 53 for UDP and TCP to Pods in any other namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Pod named `allowed` that runs the `busybox:1.36.0` image on port 80
    and assign it the label `app=frontend`. Make a `curl` call to `http://google.com`.
    The network call should be allowed, as the network policy doesn’t apply to the
    Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another Pod named `denied` that runs the `busybox:1.36.0` image on port
    80 and assign it the label `app=backend`. Make a `curl` call to `http://google.com`.
    The network call should be blocked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the Kubernetes Dashboard or make sure that it is already installed.
    In the namespace `kubernetes-dashboard`, create a ServiceAccount named `observer-user`.
    Moreover, create the corresponding ClusterRole and ClusterRoleBinding. The ServiceAccount
    should only be allowed to view Deployments. All other operations should be denied.
    As an example, create the Deployment named `deploy` in the `default` namespace
    with the following command: `kubectl create deployment deploy --image=nginx --replicas=3`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a token for the ServiceAccount named `observer-user` that will never
    expire. Log into the Dashboard using the token. Ensure that only Deployments can
    be viewed and not any other type of resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the binary file of the API server with version 1.26.1 on Linux AMD64\.
    Download the SH256 checksum file for the API-server executable of version 1.23.1\.
    Run the OS-specific verification tool and observe the result.****
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
