- en: Chapter 8\. Volumes and Configuration Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *volume* in Kubernetes is a directory accessible to all containers running
    in a pod, with the additional guarantee that the data is preserved across restarts
    of individual containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can distinguish between a few types of volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Node-local* ephemeral volumes, such as `emptyDir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic *networked* volumes, such as `nfs` or `cephfs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cloud provider–specific* volumes, such as `AWS EBS` or `AWS EFS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Special-purpose* volumes, such as `secret` or `configMap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which volume type you choose depends entirely on your use case. For example,
    for a temporary scratch space, an `emptyDir` would be fine, but when you need
    to make sure your data survives node failures, you’ll want to look into more resilient
    alternatives or cloud provider–specific solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Exchanging Data Between Containers via a Local Volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have two or more containers running in a pod and want to be able to exchange
    data via filesystem operations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a local volume of type `emptyDir`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The starting point is the following pod manifest, *exchangedata.yaml*, which
    has two containers (`c1` and `c2`) that each mount the local volume `xchange`
    into their filesystem, using different mount points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can launch the pod, `exec` into it, create data from one container,
    and read it out from the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A local volume is backed by the node on which the pod and its containers are
    running. If the node goes down or you have to carry out maintenance on it (see
    [Recipe 12.9](ch12.html#drain_nodes)), then the local volume is gone and all the
    data is lost.
  prefs: []
  type: TYPE_NORMAL
- en: There are some use cases where local volumes are fine—​for example, for some
    scratch space or when the canonical state is obtained from somewhere else, such
    as an S3 bucket—​but in general you’ll want to use a persistent volume or one
    backed by networked storage (see [Recipe 8.4](#pv_minikube)).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes documentation on [volumes](https://oreil.ly/82P1u)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2 Passing an API Access Key to a Pod Using a Secret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an admin, you want to provide your developers with an API access key in a
    secure way; that is, without sharing it in clear text in your Kubernetes manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a local volume of type [`secret`](https://oreil.ly/bX6ER).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you want to give your developers access to an external service that
    is accessible via the passphrase `open sesame`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a text file called *passphrase* that holds the passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the [secret](https://oreil.ly/cCddB), using the *passphrase* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From an admin point of view, you’re all set now, and it’s time for your developers
    to consume the secret. So let’s switch hats and assume you’re a developer and
    want to use the passphrase from within a pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would consume the secret, for example, by mounting it as a volume into
    your pod and then reading it out as a normal file. Create and save the following
    manifest, called *ppconsumer.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the pod and take a look at its logs, where you would expect to see
    the `ppconsumer` secret file mounted as */tmp/access/passphrase*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the passphrase from within the running container, simply read out
    the *passphrase* file in */tmp/access*, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secrets exist in the context of a namespace, so you need to take that into account
    when setting them up and/or consuming them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access a secret from a container running in a pod via one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A volume (as shown in the Solution, where the content is stored in a `tmpfs`
    volume)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using the secret as an environment variable](https://oreil.ly/Edsr5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, note that the size of a secret is limited to 1 MiB.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`kubectl create secret` deals with three types of secrets, and depending on
    your use case, you might want to choose different ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The `docker-registry` type is for use with a Docker registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `generic` type is what we used in the Solution; it creates a secret from
    a local file, directory, or literal value (you need to base64-encode it yourself).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `tls` you can create, for example, a secure SSL certificate for ingress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl describe` doesn’t show the content of the secret in plain text. This
    avoids “over-the-shoulder” password grabs. You can, however, easily decode it
    manually since it’s not encrypted, only base64-encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this command, the first line retrieves a YAML representation of the secret,
    and the second line with the `grep` pulls out the line `passphrase: b3BlbiBzZXNhbWU=`
    (note the leading whitespace here). Then, the `cut` extracts the content of the
    passphrase, and the `awk` command gets rid of the leading whitespace. Finally,
    the `base64` command turns it into the original data again.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have the option to encrypt secrets at rest by using the `--encryption-provider-config`
    option when launching the `kube-apiserver`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes documentation on [secrets](https://oreil.ly/cCddB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes documentation on [encrypting confidential data at rest](https://oreil.ly/kAmrN)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3 Providing Configuration Data to an Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to provide configuration data to an application without storing it
    in the container image or hardcoding it into the pod specification.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a config map. These are first-class Kubernetes resources with which you
    can provide configuration data to a pod via environment variables or a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to create a configuration with the key `siseversion` and
    the value `0.9`. It’s as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use the config map in a deployment—​say, in a manifest file with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this YAML manifest as *nginxpod.yaml* and then use `kubectl` to create
    the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then list the pod’s container environment variables with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve just shown how to pass in the configuration as an environment variable.
    However, you can also mount it into the pod as a file, using a volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have the following config file, *example.cfg*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a config map that holds the config file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use the config map just as you would any other volume. The following
    is the manifest file for a pod named `oreilly`; it uses the `busybox` image and
    just sleeps for 3,600 seconds. In the `volumes` section, there is a volume named
    `oreilly` that uses the config map `configfile` we just created. This volume is
    then mounted at the path `/oreilly` inside the container. Hence, the file will
    be accessible within the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the pod, you can verify that the *example.cfg* file is indeed
    inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For a complete example of how to create a config map from a file, see [Recipe
    11.7](ch11.html#prom_minikube).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Configure a Pod to Use a ConfigMap”](https://oreil.ly/R1FgU) in the Kubernetes
    documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.4 Using a Persistent Volume with Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t want to lose data on a disk your container uses—​that is, you want
    to make sure it survives a restart of the hosting pod.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a persistent volume (PV). In the case of Minikube, you can create a PV of
    type `hostPath` and mount it just like a normal volume into the container’s filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the PV `hostpathpv` in a manifest called *hostpath-pv.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you can create the PV, however, you need to prepare the directory */tmp/pvdata*
    on the node—​that is, the Minikube instance itself. You can get into the node
    where the Kubernetes cluster is running using `minikube ssh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you’ve prepared the directory on the node, you can create the PV from
    the manifest file *hostpath-pv.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, you would carry out these steps in an admin role. You would
    define PVs and make them available to developers on the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re in a position to use the PV in a pod, from a developer’s perspective.
    This is done via a *persistent volume claim* (PVC), so called because, well, you
    literally claim a PV that fulfills certain characteristics, such as size or storage
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a manifest file called *pvc.yaml* that defines a PVC, asking for 200
    MB of space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, launch the PVC and verify its state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the status of the PV `hostpathpv` has changed from `Available` to
    `Bound`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it’s time to consume the data from the PV in a container, this time
    via a deployment that mounts it in the filesystem. So, create a file called *nginx-using-pv.yaml*
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And launch the deployment, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the PV is in use via the PVC you created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the data actually has arrived, you could now create a service
    (see [Recipe 5.1](ch05.html#simple_service)) along with an `Ingress` object (see
    [Recipe 5.5](ch05.html#ingress)) and then access it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Well done! You’ve (as an admin) provisioned a persistent volume and (as a developer)
    claimed it via a persistent volume claim and used it from a deployment in a pod
    by mounting it into the container filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Solution, we used a persistent volume of type `hostPath`. In a production
    setting, you would not want to use this but rather ask your cluster administrator
    nicely to provision a networked volume backed by NFS or an Amazon Elastic Block
    Store (EBS) volume to make sure your data sticks around and survives single-node
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that PVs are cluster-wide resources; that is, they are not namespaced.
    However, PVCs are namespaced. You can claim PVs from specific namespaces using
    namespaced PVCs.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes [persistent volumes documentation](https://oreil.ly/IMCId)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Configure a Pod to Use a PersistentVolume for Storage”](https://oreil.ly/sNDkp)
    in the Kubernetes documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5 Understanding Data Persistency on Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Minikube to deploy a stateful application in Kubernetes. Specifically,
    you would like to deploy a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `PersistentVolumeClaim` object (see [Recipe 8.4](#pv_minikube)) in your
    pod definition and/or the template for your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First you need to make a request for a specific amount of storage. The following
    *data.yaml* manifest makes a request for 1 GB of storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On Minikube, create this PVC and immediately see how a persistent volume is
    created to match this claim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to use this claim in your pod. In the `volumes` section of
    the pod manifest, define a volume by name with a PVC type and a reference to the
    PVC you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `volumeMounts` field, you’ll mount this volume at a specific path inside
    your container. For MySQL, you mount it at `/var/lib/mysql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Minikube is configured out of the box with a default storage class that defines
    a default persistent volume provisioner. This means that when a persistent volume
    claim is created, Kubernetes will dynamically create a matching persistent volume
    to fill that claim.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what happened in the Solution. When you created the persistent volume
    claim called `data`, Kubernetes automatically created a persistent volume to match
    that claim. If you look a bit deeper at the default storage class on Minikube,
    you will see the provisioner type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This specific storage class is using a storage provisioner that creates persistent
    volumes of type `hostPath`. You can see this by looking at the manifest of the
    PV that got created to match the claim you created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the host volume created holds the database `data`, you can connect
    to Minikube and list the files in the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, you now have data persistence. If the pod dies (or you delete it), your
    data will still be available.
  prefs: []
  type: TYPE_NORMAL
- en: In general, storage classes allow the cluster administrator to define the various
    types of storage they might provide. For the developers, this abstracts the type
    of storage and lets them use PVCs without having to worry about the storage provider
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kubernetes persistent volume claim documentation](https://oreil.ly/8CRZI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes storage class documentation](https://oreil.ly/32-fw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.6 Storing Encrypted Secrets in Version Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to store all your Kubernetes manifests in version control and safely
    share them (even publicly), including secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use [sealed-secrets](https://oreil.ly/r-83j). Sealed-secrets is a Kubernetes
    controller that decrypts one-way encrypted secrets and creates in-cluster `Secret`
    objects (see [Recipe 8.2](#special_volumes)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, install the `v0.23.1` release of the sealed-secrets controller
    from the [release page](https://oreil.ly/UgMpf):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be that you have a new custom resource and a new pod running
    in the `kube-system` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next, download the corresponding release of the `kubeseal` binary from the [release
    page](https://oreil.ly/UgMpf). This tool will allow you to encrypt your secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on macOS (amd64), do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You are now ready to start using sealed-secrets. First, generate a generic
    secret manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the `kubeseal` command to generate the new custom `SealedSecret` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `SealedSecret` object using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can now store *sealedsecret.json* safely in version control.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you create the `SealedSecret` object, the controller will detect it, decrypt
    it, and generate the corresponding secret.
  prefs: []
  type: TYPE_NORMAL
- en: Your sensitive information is encrypted into a `SealedSecret` object, which
    is a custom resource (see [Recipe 15.4](ch15.html#writing_crd)). The `SealedSecret`
    is safe to store under version control and share, even publicly. Once a `SealedSecret`
    is created on the Kubernetes API server, only the private key stored in the sealed-secret
    controller can decrypt it and create the corresponding `Secret` object (which
    is only base64-encoded). Nobody else, including the original author, can decrypt
    the original `Secret` from the `Se⁠al⁠ed​Se⁠cr⁠et`.
  prefs: []
  type: TYPE_NORMAL
- en: While users cannot decrypt the original `Secret` from the `SealedSecret`, they
    may be able to access the unsealed `Secret` from the cluster. You should configure
    RBAC to forbid low-privilege users from reading `Secret` objects from namespaces
    that they have restricted access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list the `SealedSecret` objects in the current namespace using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The sealed-secrets project on GitHub](https://oreil.ly/SKVWq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angus Lees’s article [“Sealed Secrets: Protecting Your Passwords Before They
    Reach Kubernetes”](https://oreil.ly/Ie3nB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
