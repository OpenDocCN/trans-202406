- en: Chapter 14\. MySQL in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “No need to worry, it’s in the cloud” is a phrase we often hear. It reminds
    us of a story about a woman who was worried that, after her iPhone drowned in
    the toilet, she’d lost all her years’ worth of family and travel photos. To her
    surprise, when she bought a new phone, the device “recovered” all the photos.
    She was using the iCloud backup solution from Apple to back up her device content
    to the cloud. (The other surprise may have been the service subscription bill
    she hadn’t realized she was paying.)
  prefs: []
  type: TYPE_NORMAL
- en: As computer engineers, we don’t have the luxury of taking risks with regard
    to whether our data will be recovered or not. Cloud storage is a scalable and
    reliable solution. In this chapter, we will look at a few options that companies
    have for using MySQL in the cloud. These range from database-as-a-service (DBaaS)
    options that are easily scalable and provide automatic backup and high availability
    features to more traditional choices like EC2 instances, which provide more fine-grained
    control. In general, startup companies, where the core business is not technology,
    prefer to use DBaaS options since they are easier to implement and work with.
    On the other hand, companies that need more strict control over their data might
    prefer to use an EC2 instance or their own cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Database-as-a-Service (DBaaS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DBaaS is an outsourcing option where companies pay a cloud provider to launch
    and maintain a cloud database for them. Payment is usually per-usage, and the
    data owners can access their application data as they please. A DBaaS provides
    the same functionalities as a standard relational or non-relational database.
    It’s often a good solution for companies trying to avoid configuring, maintaining,
    and upgrading their databases and servers (although this is not always true).
    DBaaS lives in the realm of software-as-a-service (SaaS), like platform-as-a-service
    (PaaS) and infrastructure-as-a-service (IaaS), where products like databases become
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon RDS for MySQL/MariaDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most popular DBaaS is Amazon RDS for MySQL. Getting started with RDS is
    almost like configuring a new car on a website. You choose the main product and
    add the options you want until it looks the way you like and then launch. [Figure 14-1](#FIG-RDS-PRODUCT)
    shows the products available. In this case, we will go for MySQL (the MariaDB
    version has similar settings for deployment).
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1401](Images/lm2e_1401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1\. Choosing the product
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can also choose the version—here, we’ve selected 8.0.21\. Next, we need to
    set the master user (similar to `root`) and its password. Make sure to pick a
    strong password, especially if you will expose your database to the world. [Figure 14-2](#FIG-RDS-ROOT)
    shows how to define the username and the password for the master user.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1402](Images/lm2e_1402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2\. Configuring the master user’s username and password
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next is the instance size, which will impact directly on the final price. We
    will pick a top-level configuration to give you an idea of how costly using a
    DBaaS can be. [Figure 14-3](#FIG-RDS-INSTACE-SIZE) shows the instance classes
    that are available; there are several options, with varying costs.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1403](Images/lm2e_1403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-3\. Choosing an instance class
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another option that can directly affect the billing is the storage options.
    Naturally, higher performance (more IOPS) and more storage lead to a higher cost.
    [Figure 14-4](#FIG-RDS-STORAGE) illustrates the choices. You can also select whether
    to enable autoscaling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next option is an important choice: do you want to use multi-AZ deployment
    or not? The multi-AZ option is all about high availability. When you provision
    a multi-AZ DB instance, Amazon RDS automatically creates a primary DB instance
    and synchronously replicates the data to a standby instance in a different Availability
    Zone (AZ). The AZs are physically distinct and have independent infrastructure,
    which increases overall availability.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to use multi-AZ deployment, RDS will install a single instance.
    In the event of failure, it will spin up a new one and remount its data volume.
    This process takes some time, during which your database will not be available.
    Even big cloud providers are not bulletproof, and disasters can happen, so having
    a standby server is always recommended. [Figure 14-5](#FIG-RDS-AZ) shows how to
    configure the replica.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1404](Images/lm2e_1404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-4\. Configuring storage size and its IOPS performance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![lm2e 1405](Images/lm2e_1405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-5\. Configuring a standby replica
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The next part is setting up a general networking configuration. We recommend
    configuring RDS to use a private network, which only the application servers and
    developers’ IPs can access. [Figure 14-6](#FIG-RDS-NETWORK) shows the network
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1406](Images/lm2e_1406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-6\. Configuring the network settings
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, alas, come the estimated costs. [Figure 14-7](#FIG-RDS-COSTS) shows
    how much you will pay per month for your configured choices.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1407](Images/lm2e_1407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-7\. The bill can reach the stars under certain configurations!
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Google Cloud SQL for MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google Cloud SQL offers managed database services comparable to Amazon RDS (and
    Azure), but with slight differences. The Google Cloud options for MySQL are more
    straightforward because there are fewer options to choose from. For example, you
    cannot choose between MySQL and MariaDB, or choose the MySQL minor version (only
    the major version). As shown in Figure 14-8, you can get started by either creating
    a new instance or migrating an existing database to Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1408](Images/lm2e_1408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-8\. Google Cloud SQL
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When creating a new instance, you have to fill in a few options. The first step
    is to choose the product. [Figure 14-9](#FIG-GOOGLE-PRODUCT) show the options
    available for MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1409](Images/lm2e_1409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-9\. Choosing the product
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After picking MySQL, you’ll need to specify the instance name, `root` password,
    database version, and location. [Figure 14-10](#FIG-GOOGLE-SQL-OPTION1) shows
    how to configure these settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1410](Images/lm2e_1410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-10\. Setting basic configuration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next are the settings that can impact the performance, and of course, the cost—it’s
    crucial to find the right balance here. [Figure 14-11](#FIG-GOOGLE-SQL-OPTION2)
    shows the storage, memory, and CPU options available.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1411](Images/lm2e_1411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-11\. Configuring the machine type and storage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now the instance is ready to launch in the Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Azure SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last of the top three cloud service providers is Azure SQL. [Figure 14-12](#FIG-AZURE-INTRO)
    shows the database products available in Azure. You’ll want to select “Azure Database
    for MySQL servers.”
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1412](Images/lm2e_1412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-12\. Choosing MySQL in Azure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Azure offers two options, to go with a simple server or a more robust solution
    with high availability in the setup. [Figure 14-13](#FIG-AZURE-OPTION) shows the
    difference between the two options.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1413](Images/lm2e_1413.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-13\. Choosing a single server or a flexible server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Those choices are followed by similar configurations regarding the service performance
    and costs. [Figure 14-14](#FIG-AZURE-MYSQLCONFIG) shows the MySQL managed services
    options.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1414](Images/lm2e_1414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-14\. Configuring our MySQL managed service instance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Amazon Aurora
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon Aurora is a MySQL- and PostgreSQL-compatible relational database solution
    provided by Amazon under a commercial license. It offers similar features to MySQL,
    plus a few extra features developed by Amazon.
  prefs: []
  type: TYPE_NORMAL
- en: Two of these features are worth mentioning. First is Aurora Parallel Query (PQ),
    a feature that parallelizes some of the I/O and computation involved in processing
    data-intensive queries.
  prefs: []
  type: TYPE_NORMAL
- en: Aurora PQ works by doing a full table scan (the storage level performs the parallel
    reads). When we use a parallel query, the query does not use the InnoDB buffer
    pool. Instead, it pushes query processing down to the storage layer and parallelizes
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage is that moving the processing closer to the data reduces network
    traffic and latency. However, the feature is not a silver bullet and does not
    work well for all cases—it works best for analytical queries that need to run
    over large portions of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PQ feature is not available for all AWS instances. For instances that support
    this feature, their instance class determines the number of parallel queries that
    can be active at a given time. The following instances are the ones that support
    the PQ feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.r*.large`: 1 concurrent parallel query session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.r*.xlarge`: 2 concurrent parallel query sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.r*.2xlarge`: 4 concurrent parallel query sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.r*.4xlarge`: 8 concurrent parallel query sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.r*.8xlarge`: 16 concurrent parallel query sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.r4.16xlarge`: 16 concurrent parallel query sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other notable feature is the Amazon Aurora Global Database, designed for
    applications with a global footprint. It allows a single Aurora database to span
    multiple AWS regions, with fast replication to enable low-latency global reads
    and disaster recovery from region-wide outages. The Aurora Global Database uses
    storage-based replication using the dedicated Amazon infrastructure across its
    data centers worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Cloud Instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *cloud instance* is nothing but a virtual server. The different cloud providers
    have different names for these: Amazon Elastic Compute Cloud (EC2) instances,
    Google Compute Engine instances, and Azure Virtual Machines.'
  prefs: []
  type: TYPE_NORMAL
- en: All of them offer different instance types according to the user’s business
    needs, varying from shallow, basic configurations to astounding limits. For example,
    the Compute Engine `m2-megamem-416` machine type is a monster that has 416 CPUs
    and 5,888 GB of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL installation process for these instances is the standard one described
    in [Chapter 1](ch01.xhtml#CH1_INSTALL). In this case, the most significant advantage
    of using cloud instances compared to DBaaS solutions is the freedom of customizing
    MySQL and the operating system according to your needs without the limitations
    that managed databases have.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most recent option available to deploy MySQL instances is Kubernetes. Kubernetes
    and the OpenShift platform have added a way to manage containerized systems, including
    database clusters. The management is achieved by controllers declared in configuration
    files. These controllers provide automation to create objects, such as a container
    or a group of containers called a *pod*, to listen for a specific event and perform
    a task.
  prefs: []
  type: TYPE_NORMAL
- en: This automation adds complexity to the container-based architecture and stateful
    applications, such as databases. A Kubernetes *operator* is a particular type
    of controller introduced to simplify complex deployments. The operator extends
    the Kubernetes API with custom resources.
  prefs: []
  type: TYPE_NORMAL
- en: There are many good books written on how Kubernetes works. To keep this section
    as concise as possible, we will discuss the significant components relevant to
    the Percona Kubernetes Operator. For a quick introduction to Kubernetes, you can
    check out the [documentation](https://oreil.ly/WdWsD) from the Linux Foundation.
    [Figure 14-15](#FIG-PXB-COMPONENT) shows the Percona XtraDB Cluster components
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: '![lm2e 1415](Images/lm2e_1415.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-15\. The Percona XtraDB Cluster components in Kubernetes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following section describes how to deploy the Percona Kubernetes Operator
    for Percona XtraDB Cluster, which is considered production-ready. Other operators
    are also available. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Oracle](https://oreil.ly/wOjgy) provides a Kubernetes Operator for MySQL InnoDB
    Cluster. At the time of this writing, the operator is in a preview state, so it
    is not recommended for production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MariaDB](https://oreil.ly/BkCF9) has an operator, but at the time of writing
    it is in the alpha stage, so please check its maturity before using it in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Presslabs](https://oreil.ly/pgAdN) has released an operator that deploys MySQL
    instances along with orchestrator and backup functionalities. This operator is
    production-ready.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Percona XtraDB Cluster in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will walk you through the steps of deploying a Kubernetes cluster
    in the Google Cloud using the Google Cloud SDK and the [Percona Kubernetes Operator
    for PXC](https://oreil.ly/olzY9):'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Google Cloud SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The SDK provides tools and libraries for interacting with Google Cloud products
    and services. [Download the binary appropriate for your platform](https://oreil.ly/czdsU)
    and install it. Here’s an example for macOS:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Install `kubectl` with `gcloud`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With `gcloud` installed, install the `kubectl` component using the following
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the Kubernetes cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create the Kubernetes cluster, first you need to authenticate in the Google
    Cloud service:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once authenticated, create the cluster. The command accepts a lot of parameters,
    but in this case, we will go with the basics to create a Kubernetes cluster:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The account needs to have the necessary privileges to create the cluster. Also,
    you need to replace the project and cluster names used here with your own names.
    You may also be required to edit the zone location, set to `us-central1-b` in
    this example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The parameters used here are just a small subset of everything available—you
    can see all the options by running `gcloud container clusters --help`. For this
    case, we’ve just requested a cluster with three nodes of `*n1-standard-4*` type
    instances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This process may take a while, especially if there are a lot of nodes. The
    output will look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And we can check the pods of our Kubernetes cluster in the Google Cloud:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is also possible to use the Google Cloud interface to deploy the cluster,
    as shown in [Figure 14-16](#GCLOUD-INTERFACE).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![lm2e 1416](Images/lm2e_1416.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 14-16\. From the main menu, select Kubernetes Engine, then Clusters
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: To create a new cluster, choose the CREATE option shown at the top of [Figure 14-17](#GCLOUD-CREATE-K8).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![lm2e 1417](Images/lm2e_1417.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 14-17\. Create the Kubernetes cluster by clicking CREATE
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: The final step is to install the PXC operator. The [documentation](https://oreil.ly/fBJq3)
    for deploying the operator has very detailed instructions. We’ll follow the recommended
    steps here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, configure Cloud Identity and Access Management (Cloud IAM) to control
    access to the cluster. The following command will give you the ability to create
    Roles and RoleBindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The return statement confirms the creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a namespace and set the context for the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, clone the repository and change to the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the operator with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the following confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator has been started, and you can confirm this by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create the Percona XtraDB Cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This step can take some time. After that, you will see all the pods running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'During the previous steps, the operator has generated several secrets, including
    the password for the `root` user, which you will need to access the cluster. To
    get the generated secrets, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual password is base64-encoded, so you’ll need to run the following
    command to get the `root` password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the password, to check connectivity with the cluster you
    can create a client pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then connect to MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the operator comes with HAProxy, which is a load balancer (we will
    discuss load balancing in the next chapter).
  prefs: []
  type: TYPE_NORMAL
