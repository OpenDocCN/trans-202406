- en: Chapter 3\. Workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about [workloads in Kubernetes](https://oreil.ly/Uz1gG), we mean
    the API resource types that run an application. Those API resource types include
    a Deployment, ReplicaSet, StatefulSet, DaemonSet, Job, CronJob, and of course
    the Pod. The curriculum of the CKA is very specific about the types of workload
    you need to be familiar with. The exam will include only the Deployment, ReplicaSet,
    and Pod. You will need to understand replication and rollout features managed
    by a Deployment and understand the API primitives for injecting configuration
    data into a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This chapter will use the concept of a volume. Take a look through [Chapter 6](ch06.xhtml#storage)
    for more information if you’re not familiar with Kubernetes’ persistent storage
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic understanding of Deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment rollout and rollback functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual and automatic scaling of the replicas controlled by a ReplicaSet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConfigMap and Secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Workloads with Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kubernetes, a workload is executed in a Pod. There are various API resources
    that manage one or many Pods. In this section, we’ll concentrate on the API resources
    Deployment and ReplicaSet, which are most relevant to the exam. Moreover, we’ll
    briefly touch on the StatefulSet, which manages workloads that hold state.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central API resource for running an application in a container is the Pod.
    Using a single instance of a Pod to operate an application has its flaws. It represents
    a single point of failure as all traffic targeting the application is funneled
    to this Pod. This behavior is specifically problematic when the load increases
    due to higher demand (e.g., during peak shopping season for an e-commerce application
    or when a central microservice like an authentication provider is used by an increasing
    number of other microservices within the system). Another important aspect of
    running an application in a Pod is failure tolerance. A Pod will not be rescheduled
    in the case of a node failure and therefore can lead to a system outage for end
    users. In this section, we’ll talk about the Kubernetes mechanics that support
    aspects such as application scalability and failure tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: A *ReplicaSet* is a Kubernetes API resource that controls multiple, identical
    instances of a Pod running the application, so-called replicas. It has the capability
    of scaling the number of replicas up or down on demand. Moreover, it knows how
    to roll out a new version of the application across all replicas.
  prefs: []
  type: TYPE_NORMAL
- en: A *Deployment* abstracts the functionality of ReplicaSet and manages it internally.
    In practice, this means that you do not have to create, modify, or delete ReplicaSet
    objects yourself. The Deployment keeps a history of application versions and can
    roll back to an older version to counteract a blocking or potentially costly production
    issue. Furthermore, it offers the capability of scaling the number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-1](#deployment_replicaset) illustrates the relationship between a
    Deployment, a ReplicaSet, and its controlled replicas.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0301](Images/ckas_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Relationship between a Deployment and a ReplicaSet
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following sections will explain how to manage Deployments, including scaling
    and rollout features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a Deployment using the imperative command `create deployment`.
    The command offers a range of options, some of which are mandatory. At a minimum,
    you need to provide the name of the Deployment and the container image that should
    be used by the replicas. The default number of replicas created is 1; however,
    you can define a higher number of replicas using the option `--replicas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the command in action. The following command creates the Deployment
    named `app-cache`, which runs the object cache [Memcached](https://memcached.org)
    inside of the container on four replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The mapping between the Deployment and the replicas it controls happens through
    label selection. When you run the imperative command, `kubectl` already sets up
    the mapping for you. [Example 3-1](#yaml_manifest_deployment) shows the label
    selection in the YAML manifest. This YAML manifest can be used to create a Deployment
    declaratively or by inspecting the live object created by the previous imperative
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. A YAML manifest for a Deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When created by the imperative command, `app` is the label key the Deployment
    uses by default. You can find this key in three different places in the YAML output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`metadata.labels`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spec.selector.matchLabels`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spec.template.metadata.labels`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For label selection to work properly, the assignment of `spec.selector.matchLabels`
    and `spec.template.metadata` needs to match, as shown in [Figure 3-2](#deployment_label_selection).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0302](Images/ckas_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Deployment label selection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The values of `metadata.labels` is irrelevant for mapping the Deployment to
    the Pod template. As you can see in [Figure 3-2](#deployment_label_selection),
    the label assignment to `metadata.labels` has been changed deliberately to `deploy:
    app-cache` to underline that it is not important for the Deployment to Pod template
    selection.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing Deployments and Their Pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can inspect a Deployment after its creation by using the `get deployments`
    command. The output of the command renders the important details of its replicas,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can observe the following column titles relevant to the replicas controlled
    by the Deployment in [Table 3-1](#runtime_replica_information).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Runtime replica information when listing deployments
  prefs: []
  type: TYPE_NORMAL
- en: '| Column Title | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| READY | Lists the number of replicas available to end users in the format
    of <ready>/<desired>. The number of desired replicas corresponds to the value
    of `spec.replicas`. |'
  prefs: []
  type: TYPE_TB
- en: '| UP-TO-DATE | Lists the number of replicas that have been updated to achieve
    the desired state. |'
  prefs: []
  type: TYPE_TB
- en: '| AVAILABLE | Lists the number of replicas available to end users. |'
  prefs: []
  type: TYPE_TB
- en: 'The Pods controlled by the Deployment can be identified by the naming prefix
    in their names. In the case of the previously created Deployment, the Pods’ names
    start with `app-cache-`. The hash following the prefix is autogenerated and assigned
    to the name upon creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Deployment Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can render the details of a Deployment. Those details include the label
    selection criteria that can be extremely valuable when troubleshooting a misconfigured
    Deployment. The following output provides the full gist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that the output contains a reference to a ReplicaSet.
    The purpose of a ReplicaSet is to *replicate* a set of identical Pods. You do
    not need to deeply understand the core functionality of a ReplicaSet for the exam.
    Just be aware that the ReplicaSet is automatically created by a Deployment and
    uses the Deployment’s name as a prefix for the ReplicaSet similar to the Pods
    it controls. In the case of the previous Deployment named `app-cache`, the name
    of the ReplicaSet is `app-cache-596bc5586d`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Deployment takes full charge of the creation and deletion of the objects
    it controls, Pods and ReplicaSets. When you delete a Deployment, the corresponding
    objects are deleted as well. Say you are dealing with the following set of objects
    shown in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `delete deployment` command for a cascading deletion of its managed
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Performing Rolling Updates and Rollbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rollout and rollback capabilities are built into certain API resources. Once
    the definition of the Pod template in a Deployment has been changed, Kubernetes
    knows how to apply the change to all Pods managed by the object. In this section,
    we’ll talk about both scenarios: deploying a new version of an application and
    reverting to an old version of an application.'
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Out a New Revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployments make it very easy to roll out a new version of the application to
    all replicas it controls. Say you want to upgrade the version of Memcached from
    1.6.8 to 1.6.10 to benefit from the latest features and bug fixes. All you need
    to do is to change the desired state of the object by updating the Pod template.
    The Deployment takes care of updating all replicas to the new version one by one.
    This process is called a *rolling update*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any time, you can modify the live object using the command `edit deployment`.
    Alternatively, the command `set image` offers a quick and convenient way to change
    the image of a Deployment, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The flag `--record` is optional and defaults to the value `false`. If provided
    without a value or set to the value `true`, the command used for the change will
    be recorded. Internally, the `set image` command preserves the change cause by
    assigning the annotation with the key `kubernetes.io/change-cause` to the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the current status of a rollout while in progress. The command
    to use is `rollout status`. The output gives you an indication of the number of
    replicas that have already been updated since emitting the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes keeps track of the changes you make to a Deployment over time in
    the rollout history. Every change is represented by a so-called *revision*. You
    can check the rollout history by running the following command. You will see two
    revisions listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first revision was recorded for the original state of the Deployment when
    you created the object. The second revision was added for changing the image tag.
    Note that the column “CHANGE-CAUSE” renders the command used for the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a more detailed view on the revision, run the following command. You
    can see that the image uses the value `memcached:1.6.10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Rolling Back to a Previous Revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Problems may arise in production that require swift action. For example, say
    that the container image that you just rolled out contains a crucial bug. Kubernetes
    gives you the option to roll back to one of the previous revisions in the rollout
    history. You can achieve this by using the `rollout undo` command. To pick a specific
    revision, provide the command-line option `--to-revision`. The command rolls back
    to the previous revision if you do not provide the option. Here, we are rolling
    back to revision 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, Kubernetes performs a rolling update to all replicas with the
    revision 1\. Checking the rollout history now lists revision 3\. Given that we
    rolled back to revision 1, there’s no more need to keep that entry as a duplicate.
    Kubernetes simply turns revision 1 into 3 and removes 1 from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Scaling Workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability is one of Kubernetes’ built-in capabilities. We’ll learn how to
    manually scale the number of replicas as a reaction to increased load on the application.
    Furthermore, we’ll talk about the API resource Horizontal Pod Autoscaler, which
    allows to automatically scale the managed set of Pods based on resource thresholds
    like CPU and memory.
  prefs: []
  type: TYPE_NORMAL
- en: Manually Scaling a Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scaling the number of replicas controlled by a Deployment up or down is a straightforward
    process. You can either manually edit the live object using `edit deployment`
    and change the value of the attribute `spec.replicas` or use the imperative `scale
    deployment` command. The following command increases the number of replicas from
    four to six:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can observe the creation of replicas in real time. If you are fast enough,
    you might still see the change of status for the newly created Pods turning from
    `ContainerCreating` to `Running`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Manually scaling the number of replicas takes a little bit of guesswork. You
    will still have to monitor the load on your system to see if your number of replicas
    is sufficient to handle the incoming traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Manually Scaling a StatefulSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another API resource that can be scaled manually is the StatefulSet. StatefulSets
    are meant for managing stateful applications by a set of Pods (e.g., databases).
    Similar to a Deployment, the StatefulSet defines a Pod template; however, each
    of its replicas guarantees a unique and persistent identity. Similar to a Deployment,
    a StatefulSet uses a ReplicaSet to manage the replicas.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to discuss StatefulSets in more detail, but you can read more
    about them in the [documentation](https://oreil.ly/dXJhh). The reason we are discussing
    the StatefulSet API resource here is that it can be manually scaled in a similar
    fashion as the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we’d deal with the YAML definition for a StatefulSet and a Service
    that run and expose a Redis database, as illustrated in [Example 3-2](#yaml_manifest_statefulset_service).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. A YAML manifest for a StatefulSet and Service
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After its creation, listing the StatefulSet shows the number of replicas in
    the “READY” column. As you can see in the following output, we set the number
    of replicas to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scale` command we explored in the context of a Deployment works here as
    well. In the following command, we scale the number of replicas from one to three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to mention that the process for scaling down a StatefulSet requires
    all replicas to be in a healthy state. Any long-term, unresolved issues in Pods
    controlled by a StatefulSet can lead to a situation that can result in the application
    becoming unavailable to end users.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling a Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to scale a Deployment is with the help of a Horizontal Pod Autoscaler
    (HPA). The HPA is an API primitive that defines rules for automatically scaling
    the number of replicas under certain conditions. The only currently supported
    scaling condition in the stable API version of an HPA is CPU utilization. At runtime,
    the HPA checks the metrics collected by the [metrics server](https://oreil.ly/Lmamb)
    to determine if the average maximum CPU usage across all replicas of a Deployment
    is less than or greater than the defined threshold. [Figure 3-3](#autoscaling_deployment)
    shows a high-level architecture diagram involving an HPA.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0303](Images/ckas_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Autoscaling a Deployment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating Horizontal Pod Autoscalers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `autoscale deployment` command to create an HPA for an existing
    Deployment. The option `--cpu-percent` defines the average maximum CPU usage threshold.
    The options `--min` and `--max` provide the minimum number of replicas to scale
    down to and the maximum number of replicas the HPA can create to handle the increased
    load, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous command is a great shortcut for creating an HPA for a Deployment.
    The YAML manifest representation of the HPA object looks like [Example 3-3](#yaml_manifest_hpa).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. A YAML manifest for an HPA
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Listing Horizontal Pod Autoscalers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The short-form command for a Horizontal Pod Autoscaler is `hpa`. Listing all
    of the HPA objects transparently describes their current state: the usage of CPU
    utilization and the number of replicas at this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If the Pod template of the Deployment does not define CPU resource requirements
    or if the CPU metrics cannot be retrieved from the metrics server, the left value
    of the column “TARGETS” says <unknown>. [Example 3-4](#cpu_resource_requirements_pod_template)
    sets the resource requirements for the Pod template so that the HPA can work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. Setting CPU resource requirements for Pod template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once traffic hits the replicas, the current CPU usage is reflected in a percentage
    as shown in the following output. Here the average maximum CPU utilization is
    15%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Horizontal Pod Autoscaler Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The event log of a HPA can provide additional insight into the rescaling activities.
    Rendering the HPA details can be a great tool for overseeing when the number of
    replicas was scaled up or down, as well as their scaling conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using the Beta API Version of an Horizontal Pod Autoscaler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes 1.12 introduced the beta API version `autoscaling/v2beta2` for a
    HPA, which became a final API named `autoscaling/v2` with Kubernetes 1.23\. The
    YAML manifest of the API resource models observed metrics in a more generic way.
    As you can see in [Example 3-5](#autoscaler_hpa), we are inspecting CPU and memory
    utilization to determine if the replicas of a Deployment need to be scaled up
    or down.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. A YAML manifest for a HPA using v2
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that the HPA determines the currently used resources, we’ll set the
    memory resource requirements for the Pod template as well, as shown in [Example 3-6](#memory_resource_requirements_pod_template).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. Setting memory resource requirements for Pod template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing the HPA renders both metrics in the “TARGETS” column, as in the output
    of the `get` command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Defining and Consuming Configuration Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s common to encounter an application that evaluates environment variables
    to control its runtime behavior. For example, the application may define an environment
    variable that points to the URL of an external service, or it could inject an
    API key used to authenticate with another microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring environment variables for a container is easy. You simply list them
    as key-value pairs under the attribute `spec.containers[].env[]`. [Example 3-7](#environment_variables_container)
    defines the environment variables `MEMCACHED_CONNECTIONS` and `MEMCACHED_THREADS`
    for the container named `memcached`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7\. Environment variables set for a container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If those environment variables become a common commodity across multiple Pod
    manifests within the same namespace, there’s no way around copy-pasting the definition.
    For that particular use case, Kubernetes introduced the concept of configuration
    data represented by dedicated API resources.
  prefs: []
  type: TYPE_NORMAL
- en: Those API resources are called ConfigMap and Secret. Both define a set of key-values
    pairs and can be injected into a container as environment variables or mounted
    as a volume. [Figure 3-4](#configuration_data) illustrates the options.
  prefs: []
  type: TYPE_NORMAL
- en: Values of a Secret are only encoded
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets expect the value of each entry to be Base64-encoded. Base64 encodes
    only a value, but it doesn’t encrypt it. Therefore, anyone with access to its
    value can decode it without problems. A Secret is distributed only to the nodes
    running Pods that actually require access to it. Moreover, Secrets are stored
    in memory and are never written to physical storage.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0304](Images/ckas_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Configuration data in Kubernetes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating a ConfigMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a ConfigMap by emitting the imperative `create configmap` command.
    This command requires you to provide the source of the data as an option. Kubernetes
    distinguishes the four different options shown in [Table 3-2](#source_options_configmap).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Source options for data parsed by a ConfigMap
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-literal` | `--from-literal=locale=en_US` | Literal values, which
    are key-value pairs as plain text |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-env-file` | `--from-env-file=config.env` | A file that contains key-value
    pairs and expects them to be environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=app-config.json` | A file with arbitrary contents
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=config-dir` | A directory with one or many files
    |'
  prefs: []
  type: TYPE_TB
- en: It’s easy to confuse the options `--from-env-file` and `--from-file`. The option
    `--from-env-file` expects a file that contains environment variables in the format
    `KEY=value` separated by a new line. The key-value pairs follow typical naming
    conventions for environment variables (e.g., the key is uppercased, and individual
    words are separated by an underscore character). Historically, this option has
    been used to process [Docker Compose `.env` file](https://oreil.ly/Sd85f), though
    you can use it for any other file containing environment variables. This option
    does not enforce or normalize the typical naming conventions for environment variables.
    The option `--from-file` points to a file or directory containing *any* arbitrary
    content. It’s an appropriate option for files with structured configuration data
    to be read by an application (e.g., a properties file, a JSON file, or an XML
    file).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows the creation of a ConfigMap in action. We are simply
    providing the key-value pairs as literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The resulting YAML object looks like the one shown in [Example 3-8](#configmap_yaml_manifest).
    As you can see, the object defines the key-value pairs in a section named `data`.
    A ConfigMap does not have a `spec` section.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-8\. ConfigMap YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Consuming a ConfigMap as Environment Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the ConfigMap created, you can now inject its key-value pairs as environment
    variables into a container. [Example 3-9](#injecting_configmap_environment_variables)
    shows the use of `spec.containers[].envFrom[].configMapRef` to reference the ConfigMap
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-9\. Injecting ConfigMap key-value pairs into the container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the Pod from the YAML manifest, you can inspect the environment
    variables available in the container by running the `env` Unix command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Mounting a ConfigMap as a Volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to configure applications at runtime is by processing a machine-readable
    configuration file. Say we have decided to store the database configuration in
    a JSON file named `db.json` with the structure shown in [Example 3-10](#json_file_database_information).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-10\. A JSON file used for configuring database information
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we are not dealing with literal key-value pairs, we need to provide
    the option `--from-file` when creating the ConfigMap object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The Pod mounts the ConfigMap as a volume to a specific path inside of the container.
    The assumption is that the application will read the configuration file when starting
    up. [Example 3-11](#mounting_configmap_volume) demonstrates the YAML definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-11\. Mounting a ConfigMap as a volume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the correct behavior, open an interactive shell to the container.
    As you can see in the following commands, the directory `/etc/config` contains
    a file with the key we used in the ConfigMap. The content represents the JSON
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Secret
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a Secret with the imperative command `create secret`. In addition,
    a mandatory subcommand needs to be provided that determines the type of the Secret.
    [Table 3-3](#options_creating_secret) lists the different types.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. Options for creating a Secret
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `generic` | Creates a secret from a file, directory, or literal value. |'
  prefs: []
  type: TYPE_TB
- en: '| `docker-registry` | Creates a secret for use with a Docker registry. |'
  prefs: []
  type: TYPE_TB
- en: '| `tls` | Creates a TLS secret. |'
  prefs: []
  type: TYPE_TB
- en: The most commonly used Secret type is `generic`. The options for a generic Secret
    are exactly the same as for a ConfigMap, as shown in [Table 3-4](#source_options_data_secret).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-4\. Source options for data parsed by a Secret
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-literal` | `--from-literal=password=secret` | Literal values, which
    are key-value pairs as plain text |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-env-file` | `--from-env-file=config.env` | A file that contains key-value
    pairs and expects them to be environment variables |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=id_rsa=~/.ssh/id_rsa` | A file with arbitrary
    contents |'
  prefs: []
  type: TYPE_TB
- en: '| `--from-file` | `--from-file=config-dir` | A directory with one or many files
    |'
  prefs: []
  type: TYPE_TB
- en: 'To demonstrate the functionality, let’s create a Secret of type `generic`.
    The command sources the key-value pairs from the literals provided as a command-line
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When created using the imperative command, a Secret will automatically Base64-encode
    the provided value. This can be observed by taking a look at the produced YAML
    manifest. You can see in [Example 3-12](#secret_base64_encoded_values) that the
    value `s3cre!` has been turned into `czNjcmUh`, the Base64-encoded equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-12\. A Secret with Base64-encoded values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you start with the YAML manifest to create the Secret object, you will need
    to create the Base64-encoded value yourself. A Unix tool that does the job is
    `base64`. The following command achieves exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can also use one of the specialized [Secret types](https://oreil.ly/e1Cfz)
    to avoid having to provide a Base64-encoded value. The type `kubernetes.io/basic-auth`
    is meant for basic authentication and expects the keys `username` and `password`.
    The created object from this definition automatically Base64-encodes the values
    for both keys. [Example 3-13](#secret_type_basic_auth) illustrates a YAML manifest
    for a Secret with type `kubernetes.io/basic-auth`. Notice that the attribute defining
    the key-value pairs is called `stringData` instead of `data` as used by the `Opaque`
    Secret type.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-13\. Usage of the Secret type kubernetes.io/basic-auth
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Consuming a Secret as Environment Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consuming a Secret as environment variable works similar to the way you’d do
    it for ConfigMaps. Here, you’d use the YAML expression `spec.containers[].envFrom[].secretRef`
    to reference the name of the Secret. [Example 3-14](#injecting_secret_container)
    injects the Secret named `secret-basic-auth` as environment variables into the
    container named `backend`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-14\. Injecting Secret key-value pairs into the container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the environment variables in the container reveals that the Secret
    values do not have to be decoded. That’s something Kubernetes does automatically.
    Therefore, the running application doesn’t need to implement custom logic to decode
    the value. Note that Kubernetes does not verify nor normalize the typical naming
    conventions of environment variables, as you can see in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Mounting a Secret as a Volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate mounting a Secret as a volume, we’ll create a new Secret of
    type `kubernetes.io/ssh-auth`. This Secret type captures the value of an SSH private
    key that you can view using the command `cat ~/.ssh/id_rsa`. To process the SSH
    private key file with the `create secret` command, it needs to be available as
    a file with the name `ssh-privatekey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Mounting the Secret as a volume follows the two-step approach: define the volume
    first and then reference it as a mount path for one or many containers. The volume
    type is called `secret` as used in [Example 3-15](#mounting_secret_volume).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-15\. Mounting a Secret as a volume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find the file named `ssh-privatekey` in the mount path `/var/app`.
    To verify, open an interactive shell and render the file contents. The contents
    of the file are not Base64-encoded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The workload portion covered by the CKA includes the API resources Deployment,
    ReplicaSet, and Pod. A Deployment controls a ReplicaSet responsible for managing
    multiple, identical Pods, so-called replicas. The number of replicas can be scaled
    up or down using the Deployment manually or automatically with the help of a Horizontal
    Pod Autoscaler. Any changes made to the replica template defined by the Deployment
    will be rolled out to the replicas. As an end user, you can inspect the rollout
    history, the current rollout status, and its progress.
  prefs: []
  type: TYPE_NORMAL
- en: Application runtime behavior can be controlled either by injecting configuration
    data as environment variables or by mounting a volume to a path. In Kubernetes,
    this configuration data is represented by the API resources ConfigMap and Secret
    in the form of key-value pairs. A ConfigMap is meant for plain-text data, and
    a Secret encodes the values in Base64 to obfuscate the values. Secrets are usually
    a better fit for sensitive information like credentials and SSH private keys.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Know how to scale a Deployment and roll out updates
  prefs: []
  type: TYPE_NORMAL
- en: Deployments have superior management capabilities for a set of Pods. Using them
    should be preferred over creating, updating, and deleting individual Pods. You
    need to be familiar with all aspects of a Deployment, which includes manually
    scaling the number of replicas or autoscaling them with the help of a Horizontal
    Pod Autoscaler. The rollout history keeps track of the revisions made to a Pod
    template. You can roll out new revisions or roll back to a previous revision.
    Practice those techniques and the effect it has on the replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Practice the creation and usage of ConfigMaps and Secrets
  prefs: []
  type: TYPE_NORMAL
- en: Configuration data can be injected into a Pod using a ConfigMap or a Secret.
    Practice the creation of those objects using the imperative and declarative approach
    by providing different data sources (e.g., literal values, files, and directories).
    Secrets offer specialized types. Try the different ways those can be set up. You
    need to be proficient with the different ways of injecting the data defined by
    ConfigMaps and Secrets into a container.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: Create a Deployment named `nginx` that uses the image `nginx:1.17.0`. Set two
    replicas to begin with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale the Deployment to seven replicas using the `scale` command. Ensure that
    the correct number of Pods exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Horizontal Pod Autoscaler named `nginx-hpa` for the Deployment with
    an average utilization of CPU to 65% and an average utilization of memory to 1Gi.
    Set the minimum number of replicas to 3 and the maximum number of replicas to
    20.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the Pod template of the Deployment to use the image `nginx:1.21.1`. Make
    sure that the changes are recorded. Inspect the revision history. How many revisions
    should be rendered? Roll back to the first revision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Secret named `basic-auth` of type `kubernetes.io/basic-auth`. Assign
    the key-value pairs `username=super` and `password=my-s8cr3t`. Mount the Secret
    as a volume with the path `/etc/secret` and read-only permissions to the Pods
    controlled by the Deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
