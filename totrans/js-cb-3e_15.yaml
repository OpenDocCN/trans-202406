- en: Chapter 13\. Fetching Remote Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to receive and process data in the browser, without refreshing a
    page, is one of JavaScript’s super powers. Real-time data trackers, chat applications,
    social media feed updates, and much more, are all made possible through JavaScript’s
    ability to make a request to a server and update content on the page. In this
    chapter, we’ll cover how to make and process those requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may also hear the term “AJAX,” which is an abbreviation for Asynchronous
    JavaScript and XML. Although originally coined in reference to retrieving XML,
    AJAX has become a generalized term for retrieving and sending data to a remote
    server from a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting Remote Data with Fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to request remote data from a server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the Fetch API, which allows you to make requests and manipulate the response.
    To make a simple request, pass a URL as a `fetch` parameter, which returns the
    response as a promise. The following example requests the URL, parses the JSON
    response, and logs the response to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, use the `async/await` syntax with `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Fetch API provides a means for sending and retrieving data from a remote
    source. When working in a web browser environment, this means that data can be
    retrieved without refreshing the page. As a web user, you may experience these
    types of requests frequently. The Fetch API can be used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Load additional items in a social media feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form autocomplete suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Like” a social media post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update form field values based on a previous response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submit a form without navigating away from the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an item to a shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may imagine, the list can go on and on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fetch()` method accepts two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`url` (mandatory)'
  prefs: []
  type: TYPE_NORMAL
- en: The URL to which you are making a request
  prefs: []
  type: TYPE_NORMAL
- en: '`options`'
  prefs: []
  type: TYPE_NORMAL
- en: An object of options when making the request
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible `options` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`body`'
  prefs: []
  type: TYPE_NORMAL
- en: The body content of a request
  prefs: []
  type: TYPE_NORMAL
- en: '`cache`'
  prefs: []
  type: TYPE_NORMAL
- en: The cache mode of the request (`default`, `no-store`, `reload`, `no-cache`,
    `force-cache`, or `only-if-cached`)
  prefs: []
  type: TYPE_NORMAL
- en: '`credentials`'
  prefs: []
  type: TYPE_NORMAL
- en: The request credentials of the request (`omit`, `same-origin`, or `include`)
  prefs: []
  type: TYPE_NORMAL
- en: '`headers`'
  prefs: []
  type: TYPE_NORMAL
- en: Headers included with the request
  prefs: []
  type: TYPE_NORMAL
- en: '`integrity`'
  prefs: []
  type: TYPE_NORMAL
- en: A subresource integrity value, used for verify resources
  prefs: []
  type: TYPE_NORMAL
- en: '`keepalive`'
  prefs: []
  type: TYPE_NORMAL
- en: Set to `true` for the request to outlive the page
  prefs: []
  type: TYPE_NORMAL
- en: '`method`'
  prefs: []
  type: TYPE_NORMAL
- en: The request method (`GET`, `POST`, `PUT`, or `DELETE`)
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`'
  prefs: []
  type: TYPE_NORMAL
- en: The mode of the request (`cors`, `no-cors`, or `same-origin`)
  prefs: []
  type: TYPE_NORMAL
- en: '`redirect`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets behavior for redirects (`follow`, `error`, or `manual`)
  prefs: []
  type: TYPE_NORMAL
- en: '`referrer`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the value of the referrer header (`about:client`, the current URL, or an
    empty string)
  prefs: []
  type: TYPE_NORMAL
- en: '`referrerPolicy`'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the referrer policy (`no-referrer`, `no-referrer-when-downgrade`,
    `same-origin`, `origin`, `strict-origin`, `origin-when-cross-origin`, `strict-origin-when-cross-origin`,
    or `unsafe-url`)
  prefs: []
  type: TYPE_NORMAL
- en: '`signal`'
  prefs: []
  type: TYPE_NORMAL
- en: '`AbortController` object to abort request'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the previous example, only the `url` parameter is required. When
    passed only a URL, the `fetch` method will perform a `GET` request. The following
    example demonstrates how to use the options object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`fetch` makes use of JavaScript promises. The initial promise returns a `Response`
    object, which contains the full HTTP response, including the body, headers, status
    code, redirect information, cors type, and URL. With the response returned, you
    can then use an additional parsing method to parse the body of the request. In
    the example, I’m using the `json()` method to parse the body as JSON. Here are
    the possible parsing methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrayBuffer()`'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the body as an `ArrayBuffer`
  prefs: []
  type: TYPE_NORMAL
- en: '`blob()`'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the body as a `Blob`
  prefs: []
  type: TYPE_NORMAL
- en: '`json()`'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the body as JSON
  prefs: []
  type: TYPE_NORMAL
- en: '`text()`'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the body as a UTF-8 string
  prefs: []
  type: TYPE_NORMAL
- en: '`formData()`'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the body as a `FormData()` object
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `fetch`, you can handle errors based on the server’s status response.
    In `async/await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For more robust error handling, you can wrap the entire `fetch` request in
    a `try/catch` block, which will allow you to handle any additional errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Errors can be handled similarly when using the the JavaScript `then` promise
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve worked with AJAX requests in the past, you may have used the `XMLHttpRequest`
    (XHR) method (covered in [“Using XMLHttpRequest”](#xhr)). Due to its promise-based
    syntax, simpler syntax, and broad browser support, the Fetch API is now the recommended
    method for making these requests. `fetch` is supported in all modern browsers
    (Chrome, Edge, Firefox, Safari), however it is not supported in Internet Explorer.
    If your application needs to support older versions of Internet Explorer, you
    may choose to use XHR (`XMLHttpRequest`) or make use of a [fetch polyfill](https://github.com/github/fetch)
    alongside a [promise polyfill](https://github.com/taylorhakes/promise-polyfill).
  prefs: []
  type: TYPE_NORMAL
- en: Using XMLHttpRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application needs to request remote data while supporting older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `XMLHttpRequest` (XHR) in place of `fetch`. The following is an XHR `GET`
    request, which mirrors the example demonstrated in [“Requesting Remote Data with
    Fetch”](#fetch):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` is the original syntax for making remote data requests. Though
    XML is in the name, it can be used to request all sorts of data. In the previous
    example, I’m making a request for JSON data. So how does `XMLHttpRequest` differ
    from `fetch`?'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetch` makes heavy use of JavaScript promises, while `XMLHttpRequest` is based
    around the `XMLHttpRequest()` constructor function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` is supported in all browsers, including older versions of
    Internet Explorer. `fetch` will not work without a polyfill (which is based on
    `XMLHttpRequest`) in Internet Explorer 11 or older, as well as some versions of
    modern auto-updating browsers from 2017 or earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` defaults to sending cookies to the server with each request,
    while `fetch` requires that the `credentials` option be explicitly set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` supports tracking upload progress, while, at the time of writing,
    `fetch` only supports download progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch` does not support timeouts, leaving the length of the request up to
    the user’s browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though the rest of this chapter will make use of the modern `fetch` syntax,
    `XMLHttpRequest` continues to be a reasonable choice due to its browser support
    and differentiating features, particularly when working with legacy applications.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting a Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to submit a form from the client.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make a `POST` request of a `FormData` object, using `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example code, I am selecting an HTML form element using `getElementById`
    and storing the URL to `POST` the form to as a variable. In this case, I am POSTing
    the form to a local development server, as shown in [Example 13-1](#form-server).
    I’ve then added an event listener to the form and prevented the default form submission
    behavior, so that I can instead perform a JavaScript `POST` request using `fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete HTML Markup and JavaScript is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript’s `FormData` provides a means for easily creating key/value pairs
    of all the form data. This works with text-based form elements, as demonstrated
    in the example, as well as with file uploads. First, use the `FormData` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also manipulate the data contained in the `FormData` with some helpful
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormData.append(key, value)` or `FormData.append(key, blob, filename)`'
  prefs: []
  type: TYPE_NORMAL
- en: Appends new data to the form
  prefs: []
  type: TYPE_NORMAL
- en: '`FormData.delete(key)`'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes a field
  prefs: []
  type: TYPE_NORMAL
- en: '`FormData.set(key, value)`'
  prefs: []
  type: TYPE_NORMAL
- en: Appends new data, removing a duplicate key, if present
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you would add an additional field to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the `POST` request will now be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to work with the form values, using the `get` and `has`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormData.get(key)`'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the value of a specific key
  prefs: []
  type: TYPE_NORMAL
- en: '`FormData.has(key)`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks for a value with a given key and returns a Boolean
  prefs: []
  type: TYPE_NORMAL
- en: 'While `FormData` is incredibly useful, it is not the only value type of a `POST`
    body. The following types can be sent in a POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: A string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An encoded string, such as JSON or XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `URLSearchParams` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Blob` or `BufferSource` of binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [“Populating a Selection List from the Server”](#selection-list) I will demonstrate
    how to send a JSON `POST` request with `fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, [Example 13-1](#form-server) is an example Node.js Express server
    that processes the request:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-1\. Express form server example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We cover Express in detail in [Chapter 21](ch21.html#ch21).
  prefs: []
  type: TYPE_NORMAL
- en: Populating a Selection List from the Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on a user’s actions with another form element, you want to populate a
    selection list with values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capture the `change` event for the form element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event handler function, make a `fetch` request as a `POST` with the
    form data as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Populate the selection list with the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Populating a `select` or other form element based on a choice made by the user
    is a common user interface interaction. Instead of populating a `select` element
    with many options, or building a set of 10 or 20 radio buttons, you can capture
    the user’s choice in another form element, query a server application based on
    the value, and build the other form elements based on the value—all without leaving
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 13-2](#creating_an_on-demand_select) demonstrates a simple page that
    captures the change event for a select element, makes a fetch request with the
    value of the selected value, and populates a new selection list by parsing the
    returned data. In the example, the data is returned as an array, and new options
    are created with the returned text having both an option label and option value.
    Before populating the `select` element, its length is set to 0\. This is a quick
    and easy way to truncate the `select` element—removing all existing options and
    starting fresh.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 13-2\. Creating an on-demand `select` list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The example uses a Node application to populate the selection list, but could
    be written in any server-side programming language. Node is covered in detail
    in [Part III](part03.html#part3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Progressively building form elements isn’t necessary in all applications, but
    it is a great way to ensure a more effective form in cases where the data can
    change, or the form is complex.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Returned JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to safely create a JavaScript object from JSON. You also want to replace
    the numeric representation of true and false (1 and 0, respectively) with their
    Boolean counterparts (`true` and `false`).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parse the object with the `JSON.parse` capability. To transform the numeric
    values to their Boolean counterparts, create a *reviver* function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To figure out how to create JSON, think about how you create an object literal
    and just translate it into a string (with some caveats).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the object is an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'the JSON notation would be equivalent to the literal notation for the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of double quotes (`""`) rather than single, which are not allowed
    in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re working with an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'the JSON notation would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice in JSON how the property names are in quotes, but the values are only
    quoted when they’re strings. In addition, if the object contains other objects,
    such as an array, it’s also transformed into its JSON equivalent. However, the
    object *cannot* contain methods. If it does, an error is thrown. JSON works with
    data only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON static object isn’t complex, as it only provides two methods: `stringify()`
    and `parse()`. The `parse()` method takes two arguments: a JSON-formatted string
    and an optional `reviver` function. This function takes a key/value pair as parameters,
    and returns either the original value or a modified result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the solution, the JSON-formatted string is an object with three properties:
    a string, a numeric, and a third property, which has a numeric value but is really
    a Boolean with a numeric representation—0 is false, 1 is true.'
  prefs: []
  type: TYPE_NORMAL
- en: To transform all 0, 1 values into `false`, `true`, a function is provided as
    the second argument to `JSON.parse()`. It checks each property of the object to
    see if it is a numeric. If it is, the function checks to see if the value is 0
    or 1\. If the value is 0, the return value is set to `false`; if 1, the return
    value is set to `true`; otherwise, the original value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to transform incoming JSON-formatted data is essential, especially
    if you’re processing the result of an AJAX request or JSONP response. You can’t
    always control the structure of the data you get from a service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are restrictions on the JSON: strings must be double quoted, and there
    are no hexadecimal values and no tabs in strings.'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching and Parsing XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to retrieve a remote XML file and parse its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `fetch` along with the `DomParser` API, which provides the ability to parse
    XML from a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to use `fetch` to request the XML file. In this example
    I’m requesting the XML feed of the *New York Times*'' home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use `DOMParser` to parse the returned XML string, and then use the DOM
    methods to query the document for data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using `fetch` to retrieve XML, the document is returned as plain text.
    You can then use the `DOMParser` API to enable DOM methods to query the document
    and process the results.
  prefs: []
  type: TYPE_NORMAL
- en: '`DOMParser` enables you to interact with the XML content using DOM querying
    methods such as `getElementsByTagName`. `DOMParser` requires two arguments. The
    first argument is the string to be parsed. The second argument is a `mimeType`,
    which specifies the document type. The `mimeType` options are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`text/html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`application/xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applicatiom/xhtml+html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image/svg+xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example extends the XML parser to use DOM query selectors to
    output the names of the latest articles to a web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Sending Binary Data and Loading into an Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to request a server-side image as binary data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting binary data via a `fetch` request is a matter of setting the response
    type to *`blob`* and then manipulating the data when returned. In the solution,
    the data is then converted and loaded into an `img` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A benefit of the CORS specification is support for binary data (also known
    as *typed arrays*) in fetch requests. The key requirement to a binary request
    is to set the response type to one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arraybuffer`'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed-length raw binary data buffer
  prefs: []
  type: TYPE_NORMAL
- en: '`blob`'
  prefs: []
  type: TYPE_NORMAL
- en: File-like immutable raw data
  prefs: []
  type: TYPE_NORMAL
- en: In the solution, I used the `URL.createObjectURL()` method to convert the `blob`
    to a DOMString (generally mapped to JavaScript String) with the URL of the passed
    object. The URL is assigned to the `img` element’s `src` property.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it would be just as simple to assign the URL of the PNG file to the
    `src` attribute in the first place. However, the ability to manipulate binary
    data is a necessity with various technologies, such as Web Workers and WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing HTTP Cookies Across Domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access a resource from another domain as a *credentialed* request,
    including HTTP cookies and any authentication information.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changes have to be made in both the client and the server applications to support
    credentialed requests. In the following example, the client application is served
    at *somedomain.com* while the server is at *api.example.com*. Because these are
    different domains, by default credentialed requests would not be shared from the
    client to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the client, we have to test the `credentials` property on the `fetch` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the server, the `Access-Control-Allow-Controls` header value must be set
    to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When using Express, I recommend using the [CORS middleware](https://oreil.ly/vNPPC).
    We cover Express in detail in [Chapter 21](ch21.html#ch21).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sharing information across domains is referred to as Cross-Origin Resource Sharing
    or CORS. For security reasons, browsers restrict information shared across domains,
    such as cookies and credential headers. Being able to send HTTP cookies or send
    authentication headers across domains is possible by configuring CORS extension,
    as long as both the client and the server signal agreement.
  prefs: []
  type: TYPE_NORMAL
- en: 'If using `XMLHttpRequest` on the client in place of `fetch`, set the `withCredentials`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using Websockets to Establish a Two-Way Communication Between Client and Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to initiate two-way, real-time communication between a server and web
    page client.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSockets allows you to support bidirectional communication between the client
    and server. The client creates a new WebSockets object, passing in the URI for
    the WebSockets server. Notice that the `ws:` protocol is used in place of `http`
    or `https`. When the client gets a message, it converts the message text to an
    object, retrieves the number counter, increments it, and then uses it in the object’s
    string member.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the client print outs every other number, starting
    with 2\. State is maintained between the client and server by passing the string
    to be printed out within the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the server, I’m using the `ws` Node module. Once the server is created,
    it starts the communication with the client by sending through a JavaScript object
    with two members: a number counter and a string. The object must first be converted
    to string. The code listens for both an incoming message and a `close` event.
    When it gets an incoming message, it increments the counter and sends the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bidirectional communication, also known as *full-duplex* communication, is two-way
    communication that can occur at the same time. Think of it as a two-way road,
    with traffic going both ways. All modern browsers support the WebSockets specification,
    and as you can see, it’s extremely easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage to WebSockets, other than being unbelievably easy to work with
    in browsers, is its ability to traverse both proxies and firewalls, something
    that isn’t trivial or even possible with other bidirectional communication techniques,
    such as long polling. And to ensure that applications are secure, user agents
    such as Chrome and Firefox prohibit mixed content (i.e., using both HTTP and HTTPS).
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets supports binary data, as well as text. And as the examples demonstrated,
    you can transmit JSON by calling `JSON.stringify()` on the object before sending,
    and `JSON.parse()` on the string in the receiving end.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the website for more information on [WebSockets](https://www.websocket.org).
  prefs: []
  type: TYPE_NORMAL
- en: Long Polling a Remote Data Source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You would like to keep a connection open with a server so that the client is
    immediately updated with new information, but the server does not use WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use long polling, a technique where the client maintains a connection to the
    server by using an asynchronous `fetch` function that calls itself after a response.
    At its most basic, client-side long polling looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be improved by adding some error handling, which when an error is
    received will wait a specified amount of time and then attempt to poll the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Long polling a server involves making a request and maintaining a connection
    to that server until a response is sent. Once the client receives the response,
    it immediately reconnects to the server and waits for a new response. The process
    can be broken down in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Client sends request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client stays connected to server while it waits for a response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Server sends a response to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Client reconnects to the server and the process repeats itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I find that a chat program is a helpful way to think about long polling. Imagine
    a chat program where we have two users who are chatting with each other, Riley
    and Harlow. Each of them is connected to a the server. When Riley sends a message,
    the server sends a response to Harlow’s browser, which immediately reconnects
    and waits for the next message.
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of long polling is in the number of open connections that the
    server can maintain. Node was designed to handle many concurrent connections,
    while some languages have limitations. All languages are limited by the hardware
    of the server itself. Though long polling is a simple and effective method maintaining
    a connection, WebSockets (as covered in [“Using Websockets to Establish a Two-Way
    Communication Between Client and Server”](#establishing_two_way_communication))
    is a more efficient means of two-way communication between the client and server.
  prefs: []
  type: TYPE_NORMAL
