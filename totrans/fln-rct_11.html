<html><head></head><body><section data-pdf-bookmark="Chapter 10. React Alternatives" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch10">&#13;
<h1><span class="label">Chapter 10. </span>React Alternatives</h1>&#13;
&#13;
&#13;
<p>In the previous chapter, we covered the emerging topic of React Server&#13;
Components (RSCs) in depth. We explored how they work, when to use them,&#13;
and why they require powerful tools such as next-generation bundlers,&#13;
routers, and more. We further differentiated between server components&#13;
and server rendering, and even implemented a bare-bones RSCs renderer from&#13;
scratch in order to understand the underlying mechanism for ourselves.</p>&#13;
&#13;
<p>As we transition into exploring alternatives to React, this&#13;
understanding of the role and function of frameworks and server&#13;
components will provide valuable context. Each library we’ll&#13;
discuss in this chapter also ships with its associated frameworks, and&#13;
many of the principles and trade-offs we’ve covered in React will apply&#13;
to these ecosystems as well.</p>&#13;
&#13;
<p>As we pivot our attention from React and its ecosystem, let’s delve into&#13;
some popular alternatives in the frontend development ecosystem: Vue.js,&#13;
Angular, Svelte, Solid, and Qwik. Each library and framework&#13;
introduces its own reactivity model and ways of thinking about UI&#13;
development. Understanding these different models can broaden our&#13;
perspective and give us more tools to solve problems in our projects.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Vue.js" data-type="sect1"><div class="sect1" id="id152">&#13;
<h1>Vue.js</h1>&#13;
&#13;
<p>Vue.js<a data-primary="Vue.js" data-type="indexterm" id="ix_Vuejs.10.27.7"/><a data-primary="frameworks" data-secondary="Vue.js" data-type="indexterm" id="ix_frameworksVuejs.10.27.7"/> is a popular JavaScript framework for building user interfaces.&#13;
Developed by Evan You, an ex-Google engineer who worked on AngularJS&#13;
projects, Vue.js seeks to extract the good parts of Angular, but in a&#13;
lighter, more maintainable, and less opinionated package.</p>&#13;
&#13;
<p>One of Vue’s most distinctive features is the unobtrusive reactivity&#13;
system. Component state<a data-primary="state management" data-secondary="Vue.js" data-type="indexterm" id="id1084"/> consists of reactive JavaScript objects. When&#13;
you modify them, the view updates. It makes state management simple and&#13;
intuitive, but it’s also important to understand how it works to avoid&#13;
some common gotchas.</p>&#13;
&#13;
<p>In Vue’s reactivity model, it intercepts the reading and writing of&#13;
object properties. Vue 2 used getter/setters exclusively due to browser&#13;
support limitations, but in Vue 3, proxies are used for reactive objects&#13;
and getter/setters are used for refs. From the Vue docs, here’s some&#13;
pseudocode that illustrates how they work:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">function</code> <code class="nx">reactive</code><code class="p">(</code><code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="p">{</code>&#13;
    <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">track</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code>&#13;
      <code class="k">return</code> <code class="nx">target</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">target</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code>&#13;
      <code class="nx">trigger</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">key</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">})</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">ref</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">refObject</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">get</code> <code class="nx">value</code><code class="p">()</code> <code class="p">{</code>&#13;
      <code class="nx">track</code><code class="p">(</code><code class="nx">refObject</code><code class="p">,</code> <code class="s1">'value'</code><code class="p">)</code>&#13;
      <code class="k">return</code> <code class="nx">value</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">set</code> <code class="nx">value</code><code class="p">(</code><code class="nx">newValue</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">value</code> <code class="o">=</code> <code class="nx">newValue</code>&#13;
      <code class="nx">trigger</code><code class="p">(</code><code class="nx">refObject</code><code class="p">,</code> <code class="s1">'value'</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">refObject</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is somewhat oversimplified, but here we demonstrate a simplistic reactive system utilizing proxies. The <code>reactive</code> function<a data-primary="reactive function, Vue.js" data-type="indexterm" id="id1085"/> takes an object and returns a proxy of that object, which intercepts <code>get</code> and <code>set</code> operations. On a <code>get</code> operation, it calls the <code>track</code> function<a data-primary="track function, Vue.js" data-type="indexterm" id="id1086"/> and returns the requested property. On a <code>set</code> operation, it updates the value and calls the <code>trigger</code> function<a data-primary="trigger function, Vue.js" data-type="indexterm" id="id1087"/>.</p>&#13;
&#13;
<p>The <code>ref</code> function<a data-primary="ref function, Vue.js" data-type="indexterm" id="id1088"/>, on the other hand, encapsulates a value within an object and provides reactive <code>get</code> and <code>set</code> operations for that value, similar to the proxy but with a different structure, ensuring that the <code>track</code> and <code>trigger</code> functions are called appropriately during access or modification.</p>&#13;
&#13;
<p>This is a very simple example of a reactive system, but it demonstrates the basic principles of Vue’s reactivity model. This reactivity model can even be used to update the DOM. We can implement simple “reactive rendering” like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">ref</code><code class="p">,</code> <code class="nx">watchEffect</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"vue"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">count</code> <code class="o">=</code> <code class="nx">ref</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
<code class="nx">watchEffect</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="sb">`count is: </code><code class="si">${</code><code class="nx">count</code><code class="p">.</code><code class="nx">value</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// updates the DOM</code>&#13;
<code class="nx">count</code><code class="p">.</code><code class="nx">value</code><code class="o">++</code><code class="p">;</code></pre>&#13;
&#13;
<p>In fact, this is pretty close to how a Vue component keeps the state and&#13;
the DOM in sync—each component instance creates a reactive effect to&#13;
render and update the DOM<a data-primary="Document Object Model (DOM)" data-secondary="Vue.js method of updating" data-type="indexterm" id="id1089"/>. Of course, Vue components use much more&#13;
efficient ways to update the DOM than <code>innerHTML</code>, but this should be&#13;
enough to give you a basic idea of how it works.</p>&#13;
&#13;
<p>The <code>ref()</code>, <code>computed()</code>, and <code>watchEffect()</code> APIs are all part of Vue’s&#13;
Composition API.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Signals" data-type="sect2"><div class="sect2" id="id153">&#13;
<h2>Signals</h2>&#13;
&#13;
<p>Quite a few other frameworks have introduced reactivity primitives<a data-primary="reactive primitives" data-type="indexterm" id="id1090"/><a data-primary="scalars" data-type="indexterm" id="id1091"/>&#13;
similar to <code>refs</code> from Vue’s Composition API<a data-primary="Composition API, Vue.js" data-type="indexterm" id="id1092"/>, under the <a data-primary="signals" data-secondary="Vue.js" data-type="indexterm" id="id1093"/>term “signals”&#13;
that we’ll discuss in this &#13;
<span class="keep-together">chapter.</span></p>&#13;
&#13;
<p>Fundamentally, signals are the same kind of reactivity primitive as Vue&#13;
<code>refs</code>. It’s a value container that provides dependency tracking on&#13;
access, and side-effect triggering on mutation. This&#13;
reactivity-primitive-based paradigm isn’t a particularly new concept in&#13;
the frontend world: it dates back to implementations like Knockout&#13;
observables and Meteor Tracker from more than a decade ago. Vue Options<a data-primary="Vue Options API" data-type="indexterm" id="id1094"/>&#13;
API and the React state management library MobX<a data-primary="MobX library" data-type="indexterm" id="id1095"/> are also based on the&#13;
same principles but hide the primitives behind object properties.</p>&#13;
&#13;
<p>Although not a necessary trait for something to qualify as signals,&#13;
today the concept is often discussed alongside the rendering model where&#13;
updates are performed through fine-grained subscriptions. Due to the use&#13;
of virtual DOM<a data-primary="virtual DOM (vDOM)" data-secondary="Vue.js" data-type="indexterm" id="id1096"/>, Vue currently relies on compilers to achieve similar&#13;
optimizations. However, Vue is also exploring a new Solid-inspired&#13;
compilation strategy (Vapor Mode) that does not rely on virtual DOM and&#13;
takes more advantage of Vue’s built-in reactivity system.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simplicity" data-type="sect2"><div class="sect2" id="id154">&#13;
<h2>Simplicity</h2>&#13;
&#13;
<p>Vue’s biggest strength is its simplicity. It’s incredibly easy to get&#13;
started with Vue: you can simply include the Vue library in your HTML&#13;
file in a <code>&lt;script&gt;</code> tag and start writing Vue components. Vue also&#13;
provides a CLI tool for scaffolding new projects, which can be a great&#13;
way to get started with a more complex application.</p>&#13;
&#13;
<p>While we’ve only scratched the surface of Vue.js here, it’s clear that&#13;
Vue’s combination of a powerful reactivity system, a template-based&#13;
syntax, and a well-structured component model make it a compelling&#13;
option for many developers<a data-startref="ix_Vuejs.10.27.7" data-type="indexterm" id="id1097"/><a data-startref="ix_frameworksVuejs.10.27.7" data-type="indexterm" id="id1098"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Angular" data-type="sect1"><div class="sect1" id="id155">&#13;
<h1>Angular</h1>&#13;
&#13;
<p>Angular<a data-primary="AngularJS" data-type="indexterm" id="ix_Angular.10.143.8"/><a data-primary="frameworks" data-secondary="AngularJS" data-type="indexterm" id="ix_frameworksAngular.10.143.8"/>, developed and maintained by Google, is another well-known&#13;
player in the world of JavaScript frameworks. Angular is a complete,&#13;
opinionated framework, providing its own solutions for a wide range of&#13;
frontend concerns, from rendering and state management to routing and&#13;
form handling.</p>&#13;
&#13;
<p>Angular introduces a different reactivity model than React. Instead of a&#13;
virtual DOM diffing and reconciliation process, Angular uses a system&#13;
known as change detection.</p>&#13;
&#13;
<p>In Angular, every component gets a change detector responsible for&#13;
checking the component’s view for changes using a library called&#13;
Zone.js. Before we proceed, let’s talk about this in a little bit more&#13;
detail.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Change Detection" data-type="sect2"><div class="sect2" id="id156">&#13;
<h2>Change Detection</h2>&#13;
&#13;
<p>Change detection<a data-primary="change detection, AngularJS" data-type="indexterm" id="id1099"/> is the process through which Angular checks to see&#13;
whether your application state<a data-primary="state management" data-secondary="Angular’s change detection" data-type="indexterm" id="id1100"/> has changed, and if any DOM needs to be&#13;
updated. At a high level, Angular walks your components from top to&#13;
bottom, looking for changes. Angular runs its change detection mechanism&#13;
periodically so that changes to the data model are reflected in an&#13;
application’s view. Change detection can be triggered either manually or&#13;
through an asynchronous event.</p>&#13;
&#13;
<p>Change detection is highly optimized and performant, but it can still&#13;
cause slowdowns if the application runs it too frequently. This change&#13;
detection system is a powerful and flexible tool, and Angular provides&#13;
several strategies out of the box for fine-tuning its behavior to&#13;
optimize performance for different scenarios.</p>&#13;
&#13;
<p>Angular also uses a template syntax, like Vue, but it provides even more&#13;
powerful directives and constructs for manipulating the DOM, such as&#13;
<code>*ngIf</code> for conditionally rendering elements and <code>*ngFor</code> for rendering&#13;
lists. This is different from React, which uses JSX with in-place&#13;
JavaScript expressions to render dynamic data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Signals" data-type="sect2"><div class="sect2" id="id157">&#13;
<h2>Signals</h2>&#13;
&#13;
<p>Angular<a data-primary="signals" data-secondary="AngularJS" data-type="indexterm" id="id1101"/> is undergoing some fundamental changes by foregoing&#13;
dirty-checking and introducing its own implementation of a reactivity&#13;
primitive. The Angular Signal API looks like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">count</code> <code class="o">=</code> <code class="nx">signal</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
<code class="nx">count</code><code class="p">();</code> <code class="c1">// access the value</code>&#13;
<code class="nx">count</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code> <code class="c1">// set new value</code>&#13;
<code class="nx">count</code><code class="p">.</code><code class="nx">update</code><code class="p">((</code><code class="nx">v</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">v</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code> <code class="c1">// update based on previous value</code>&#13;
&#13;
<code class="c1">// mutate deep objects with same identity</code>&#13;
<code class="kr">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="nx">signal</code><code class="p">({</code> <code class="nx">count</code><code class="o">:</code> <code class="mi">0</code> <code class="p">});</code>&#13;
<code class="nx">state</code><code class="p">.</code><code class="nx">mutate</code><code class="p">((</code><code class="nx">o</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">o</code><code class="p">.</code><code class="nx">count</code><code class="o">++</code><code class="p">;</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Compared to Vue refs, Angular’s getter-based API style provides some&#13;
interesting trade-offs when used in Vue components:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>()</code> is slightly less verbose than <code>.value</code>, but updating the value is&#13;
more verbose.</p>&#13;
</li>&#13;
<li>&#13;
<p>There is no ref-unwrapping: accessing values always requires <code>()</code>. This&#13;
makes value access consistent everywhere. This also means you can pass&#13;
raw signals down as component props.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Angular is something of a Swiss Army knife, providing a wide range of&#13;
tools for building complex applications. Its opinionated nature can be&#13;
both a strength, in terms of the consistency and structure it brings to&#13;
a codebase, and a limitation, in terms of flexibility and the learning&#13;
curve for developers new to the framework<a data-startref="ix_Angular.10.143.8" data-type="indexterm" id="id1102"/><a data-startref="ix_frameworksAngular.10.143.8" data-type="indexterm" id="id1103"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Svelte" data-type="sect1"><div class="sect1" id="id158">&#13;
<h1>Svelte</h1>&#13;
&#13;
<p>Svelte<a data-primary="Svelte" data-type="indexterm" id="ix_Svelte.10.219.7"/> is a radical new approach to building user interfaces. Unlike&#13;
traditional frameworks, Svelte is a compiler<a data-primary="compilers" data-type="indexterm" id="id1104"/><a data-primary="declarative programming" data-secondary="Svelte’s reactivity model" data-type="indexterm" id="id1105"/> that transforms your&#13;
declarative components into efficient imperative code that surgically&#13;
updates the DOM. As a result, you’re able to write high-performance,&#13;
reactive web applications with less code.</p>&#13;
&#13;
<p>Svelte’s reactivity model is incredibly simple, yet powerful. Reactive&#13;
statements in Svelte are written with a simple syntax that’s reminiscent&#13;
of spreadsheet formulas. Here’s a basic Svelte component:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="kd">let</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">increment</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mf">1</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
&#13;
<code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>{count}<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">button</code> <code class="na">on:click</code><code class="o">=</code><code class="s">{increment}</code><code class="p">&gt;</code>&#13;
  Click me&#13;
<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In this example, the <code>{count}</code> syntax in the markup will automatically&#13;
update whenever the <code>count</code> variable changes. This is similar to React’s&#13;
JSX, but with one key &#13;
<span class="keep-together">difference:</span> in Svelte, this reactivity is&#13;
automatic. You don’t need to call a setter function or use any special&#13;
API to update the DOM<a data-primary="Document Object Model (DOM)" data-secondary="Svelte’s compiler update approach" data-type="indexterm" id="id1106"/>; you just assign to the variable, and Svelte takes&#13;
care of the rest.</p>&#13;
&#13;
<p>Svelte also offers a reactive statement syntax that allows you to&#13;
compute values based on your reactive data:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="kd">let</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="kd">let</code><code class="w"> </code><code class="nx">doubleCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="nx">$</code><code class="o">:</code><code class="w"> </code><code class="nx">doubleCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">2</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">increment</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">count</code><code class="w"> </code><code class="o">+=</code><code class="w"> </code><code class="mf">1</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
&#13;
<code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>{doubleCount}<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">button</code> <code class="na">on:click</code><code class="o">=</code><code class="s">{increment}</code><code class="p">&gt;</code>&#13;
  Click me&#13;
<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In this example, <code>doubleCount</code> will automatically be updated whenever&#13;
<code>count</code> changes. This is reminiscent of computed properties in Vue, but&#13;
with an arguably simpler &#13;
<span class="keep-together">syntax.</span></p>&#13;
&#13;
<p>The compiler approach taken by Svelte has several advantages. It&#13;
typically results in faster runtime performance because there’s no&#13;
virtual DOM diffing and patching step. Instead, Svelte generates code&#13;
that updates the DOM directly.</p>&#13;
&#13;
<p>However, this approach also comes with trade-offs. The compiler-centric&#13;
nature of Svelte means that some dynamic capabilities offered by&#13;
virtual DOM-based frameworks, like dynamic component types, can be more&#13;
cumbersome or verbose to express. Also, because the Svelte ecosystem is&#13;
smaller and younger than those of React, Vue, and Angular, there may be&#13;
fewer resources, libraries, and community solutions available.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Runes" data-type="sect2"><div class="sect2" id="id159">&#13;
<h2>Runes</h2>&#13;
&#13;
<p>Runes<a data-primary="runes, in Svelte" data-type="indexterm" id="ix_runesinSvelte.10.292.6"/> are symbols that influence the Svelte compiler. Whereas Svelte&#13;
today uses <code>let</code>, <code>=</code>, the <code>export</code> keyword, and the <code>$:</code> label to mean&#13;
specific things, runes<a data-primary="function syntax, runes in Svelte" data-type="indexterm" id="id1107"/> use <em>function syntax</em> to achieve the same things&#13;
and more.</p>&#13;
&#13;
<p>For example, to declare a piece of reactive state, we can use the&#13;
<code>$state</code> rune:</p>&#13;
<pre class="fr" data-code-language="diff" data-type="programlisting"><code>&lt;script&gt;</code><code class="w">&#13;
</code><span><code class="gd">-   let count = 0;</code></span><code class="w">&#13;
</code><code class="gi">+   let count = $state(0);</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w"> </code><code>   function increment() {</code><code class="w">&#13;
</code><code class="w"> </code><code>       count += 1;</code><code class="w">&#13;
</code><code class="w"> </code><code>   }</code><code class="w">&#13;
</code><code>&lt;/script&gt;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code>&lt;button on:click={increment}&gt;</code><code class="w">&#13;
</code><code class="w"> </code><code>   clicks: {count}</code><code class="w">&#13;
</code><code>&lt;/button&gt;</code></pre>&#13;
&#13;
<p>As applications grow in complexity, figuring out which values are&#13;
reactive and which aren’t can get tricky. And the current heuristic only&#13;
works for <code>let</code> declarations at the top level of a component, which can&#13;
cause confusion. Having code behave one way inside <em>.svelte</em> files and&#13;
another way inside <em>.js</em> can make it hard to refactor code, for example, if&#13;
you need to turn something into a store so that you can use it in&#13;
multiple places.</p>&#13;
&#13;
<p>With runes, reactivity extends beyond the boundaries of your <em>.svelte</em>&#13;
files. Suppose we wanted to encapsulate our counter logic in a way that&#13;
could be reused between components. Today, you would use a custom store&#13;
in a <em>.js</em> or <em>.ts</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">writable</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"svelte/store"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">createCounter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">subscribe</code><code class="p">,</code> <code class="nx">update</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">writable</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">subscribe</code><code class="p">,</code>&#13;
    <code class="nx">increment</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">update</code><code class="p">((</code><code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">+</code> <code class="mi">1</code><code class="p">),</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because this implements the <em>store contract</em>—the returned value has a&#13;
<code>subscribe</code> method—we can reference the store value by prefixing the&#13;
store name with <code>$</code>:</p>&#13;
<pre class="fr" data-code-language="diff" data-type="programlisting"><code>&lt;script&gt;</code><code class="w">&#13;
</code><code class="gi">+   import { createCounter } from './counter.js';</code><code class="w">&#13;
</code><code class="gi">+</code><code class="w">&#13;
</code><code class="gi">+   const counter = createCounter();</code><code class="w">&#13;
</code><span><code class="gd">-   let count = 0;</code></span><code class="w">&#13;
</code><span><code class="gd">-</code></span><code class="w">&#13;
</code><span><code class="gd">-   function increment() {</code></span><code class="w">&#13;
</code><span><code class="gd">-       count += 1;</code></span><code class="w">&#13;
</code><span><code class="gd">-   }</code></span><code class="w">&#13;
</code><code>&lt;/script&gt;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><span><code class="gd">-&lt;button on:click={increment}&gt;</code></span><code class="w">&#13;
</code><span><code class="gd">-   clicks: {count}</code></span><code class="w">&#13;
</code><code class="gi">+&lt;button on:click={counter.increment}&gt;</code><code class="w">&#13;
</code><code class="gi">+   clicks: {$counter}</code><code class="w">&#13;
</code><code>&lt;/button&gt;</code></pre>&#13;
&#13;
<p>This works, but it’s pretty weird! The store API can get rather unwieldy&#13;
when you start doing more complex things. With runes, things get much&#13;
simpler:</p>&#13;
<pre class="fr" data-code-language="diff" data-type="programlisting"><code class="gd">-import { writable } from 'svelte/store';</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code>export function createCounter() {</code><code class="w">&#13;
</code><span><code class="gd">-   const { subscribe, update } = writable(0);</code></span><code class="w">&#13;
</code><code class="gi">+   let count = $state(0);</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w"> </code><code>   return {</code><code class="w">&#13;
</code><span><code class="gd">-       subscribe,</code></span><code class="w">&#13;
</code><span><code class="gd">-       increment: () =&gt; update((n) =&gt; n + 1)</code></span><code class="w">&#13;
</code><code class="gi">+       get count() { return count },</code><code class="w">&#13;
</code><code class="gi">+       increment: () =&gt; count += 1</code><code class="w">&#13;
</code><code class="w"> </code><code>  };</code><code class="w">&#13;
</code><code>}</code></pre>&#13;
&#13;
<pre class="fr" data-code-language="diff" data-type="programlisting"><code>&lt;script&gt;</code><code class="w">&#13;
</code><code class="w"> </code><code>   import { createCounter } from './counter.js';</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w"> </code><code>   const counter = createCounter();</code><code class="w">&#13;
</code><code>&lt;/script&gt;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code>&lt;button on:click={counter.increment}&gt;</code><code class="w">&#13;
</code><span><code class="gd">-   clicks: {$counter}</code></span><code class="w">&#13;
</code><code class="gi">+   clicks: {counter.count}</code><code class="w">&#13;
</code><code>&lt;/button&gt;</code></pre>&#13;
&#13;
<p>Note that we’re using a <code>get</code> property in the returned object, so that&#13;
<code>counter.count</code> always refers to the current value rather than the value&#13;
at the time the function was called.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Runtime reactivity" data-type="sect3"><div class="sect3" id="id160">&#13;
<h3>Runtime reactivity</h3>&#13;
&#13;
<p>Today, Svelte<a data-primary="compile-time reactivity, Svelte" data-type="indexterm" id="id1108"/> uses <em>compile-time reactivity</em>. This means that if you&#13;
have some code that uses the <code>$:</code> label to rerun automatically when&#13;
dependencies change, those dependencies are determined when Svelte&#13;
compiles your component:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">export</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nx">width</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">export</code><code class="w"> </code><code class="kd">let</code><code class="w"> </code><code class="nx">height</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// the compiler knows it should recalculate `area`</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// when either `width` or `height` change...</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">$</code><code class="o">:</code><code class="w"> </code><code class="nx">area</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">width</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">height</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="c1">// ...and that it should log the value of `area`</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// when _it_ changes</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">$</code><code class="o">:</code><code class="w"> </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">area</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>This works well…until it doesn’t. Suppose we refactored the code as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// @errors: 7006 2304</code>&#13;
<code class="kr">const</code> <code class="nx">multiplyByHeight</code> <code class="o">=</code> <code class="p">(</code><code class="nx">width</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">width</code> <code class="o">*</code> <code class="nx">height</code><code class="p">;</code>&#13;
<code class="nx">$</code><code class="o">:</code> <code class="nx">area</code> <code class="o">=</code> <code class="nx">multiplyByHeight</code><code class="p">(</code><code class="nx">width</code><code class="p">);</code></pre>&#13;
&#13;
<p>Because the <code>$: area = ...</code> declaration can only see <code>width</code>, it won’t&#13;
be recalculated when <code>height</code> changes. As a result, code is hard to&#13;
refactor, and understanding the intricacies of when Svelte chooses to&#13;
update which values can become rather tricky beyond a certain level of&#13;
complexity.</p>&#13;
&#13;
<p>Svelte 5 introduces the <code>$derived</code> and <code>$effect</code> runes, which instead&#13;
determine the dependencies of their expressions when they are evaluated:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">width</code><code class="p">,</code><code class="w"> </code><code class="nx">height</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">$props</code><code class="p">();</code><code class="w"> </code><code class="c1">// instead of `export let`</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">area</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">$derived</code><code class="p">(</code><code class="nx">width</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="nx">height</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="nx">$effect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">area</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">});</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>As with <code>$state</code>, <code>$derived</code> and <code>$effect</code> can also be used in your <em>.js</em> and <em>.ts</em> files.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Signal boost" data-type="sect3"><div class="sect3" id="id161">&#13;
<h3>Signal boost</h3>&#13;
&#13;
<p>Like every other framework, Svelte has come to the realization that&#13;
Knockout was right all along.</p>&#13;
&#13;
<p>Svelte 5’s reactivity is powered<a data-primary="signals" data-secondary="Svelte" data-type="indexterm" id="id1109"/> by <em>signals</em>, which are essentially&#13;
what Knockout was doing in 2010. More recently, signals have been&#13;
popularized by Solid (more on this later) and adopted by a multitude of&#13;
other frameworks. In Svelte 5, signals are an under-the-hood&#13;
implementation detail rather than something you interact with directly<a data-startref="ix_Svelte.10.219.7" data-type="indexterm" id="id1110"/><a data-startref="ix_runesinSvelte.10.292.6" data-type="indexterm" id="id1111"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solid" data-type="sect1"><div class="sect1" id="id162">&#13;
<h1>Solid</h1>&#13;
&#13;
<p>Solid<a data-primary="Solid" data-type="indexterm" id="ix_Solid.10.475.6"/> is a declarative JavaScript<a data-primary="JavaScript" data-secondary="Solid library" data-type="indexterm" id="ix_JavaScriptSolidlibrary.10.475.34"/> library for building user interfaces.&#13;
It’s similar to React in that it provides a <a data-primary="component-based architecture" data-secondary="Solid" data-type="indexterm" id="id1112"/>component model base, but&#13;
Solid is based on <a data-primary="reactive primitives" data-type="indexterm" id="id1113"/><a data-primary="scalars" data-type="indexterm" id="id1114"/>reactive primitives. Instead of using a virtual DOM,&#13;
Solid uses a fine-grained reactivity system to automatically track&#13;
dependencies and update the DOM directly, which can result in more&#13;
efficient updates.</p>&#13;
&#13;
<p>Here’s an example of a simple Solid component:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">createSignal</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"solid-js"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">Component</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">createSignal</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;{</code><code class="nx">count</code><code class="p">()}&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="p">()</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, <code>createSignal</code> creates a <a data-primary="createSignal() API, Solid" data-type="indexterm" id="id1115"/>reactive primitive, similar to&#13;
<code>useState</code> in React. The key difference is that <code>count</code> is a function&#13;
that returns the current value and implicitly registers the dependency&#13;
for the reactive context. When <code>setCount</code> is called, it triggers an&#13;
update for any part of the UI that depends on <code>count</code> without&#13;
reinvoking the function components.</p>&#13;
&#13;
<p>To contrast this with React, in React the component, <code>Component</code> in this&#13;
case, would be reinvoked, including all of the logic inside its block.&#13;
Thus, the <code>count</code> value itself is not reactive. In Solid, the&#13;
<code>Component</code> function is never reinvoked, but the <code>count</code> value itself is&#13;
reactive and changes whenever <code>setCount</code> is called. This is called&#13;
fine-grained reactivity, and it is directly opposite to React’s&#13;
coarse-grained reactivity.</p>&#13;
&#13;
<p>Solid’s fine-grained reactivity system means that it can minimize&#13;
unnecessary updates and avoid the need for a diffing step, resulting in&#13;
very high performance. However, because it’s a relatively new and less&#13;
widely used library, it may not have as many resources and community&#13;
solutions available as some of the more established options.</p>&#13;
&#13;
<p>Solid’s <code>createSignal()</code> API design emphasizes read/write segregation.&#13;
Signals are exposed as a read-only getter and a separate setter:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">createSignal</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
<code class="nx">count</code><code class="p">();</code> <code class="c1">// access the value</code>&#13;
<code class="nx">setCount</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code> <code class="c1">// update the value</code></pre>&#13;
&#13;
<p>Notice how the <code>count</code> signal can be passed down without the setter.&#13;
This ensures that the state can never be mutated unless the setter is&#13;
also explicitly exposed.</p>&#13;
&#13;
<p>Solid reinvigorated the discussion around signals<a data-primary="signals" data-secondary="Solid" data-type="indexterm" id="id1116"/>, and the concept has&#13;
been adopted by many other frameworks and libraries as we’ve seen previously.&#13;
Everything we’ve previously mentioned about signals comes from the work&#13;
of Ryan Carniato<a data-primary="Carniato, Ryan" data-type="indexterm" id="id1117"/>, the author of Solid, who somehow single-handedly&#13;
managed to change the entire frontend ecosystem by bringing back a&#13;
concept from 2010<a data-startref="ix_Solid.10.475.6" data-type="indexterm" id="id1118"/><a data-startref="ix_JavaScriptSolidlibrary.10.475.34" data-type="indexterm" id="id1119"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Qwik" data-type="sect1"><div class="sect1" id="id163">&#13;
<h1>Qwik</h1>&#13;
&#13;
<p>Qwik<a data-primary="Qwik" data-type="indexterm" id="ix_Qwik.10.545.5"/><a data-primary="frameworks" data-secondary="Qwik" data-type="indexterm" id="ix_frameworksQwik.10.545.5"/> is a unique framework designed to optimize the loading of web pages&#13;
and prioritize user interaction and responsiveness. Unlike traditional&#13;
frameworks, it views web pages as a collection of components that can be&#13;
independently loaded over the network and interacted with on demand.&#13;
This approach significantly reduces the initial load time of the page,&#13;
enhancing the overall user experience.</p>&#13;
&#13;
<p>Web applications and sites built with Qwik ship with exceedingly small&#13;
and constant initial amounts of JavaScript<a data-primary="JavaScript" data-secondary="Qwik’s loading system" data-type="indexterm" id="id1120"/> (~1 kB). The amount of initial&#13;
JavaScript loaded by a Qwik site is constant, as it is the Qwik loader.&#13;
This is why Qwik is known in some circles as “the O(1) framework,”&#13;
meaning it has a constant load time regardless of the size of the&#13;
application.</p>&#13;
&#13;
<p>Initially, Qwik loads a bare minimum amount of JavaScript, but then loads&#13;
components and other behaviors as they are needed. This approach allows&#13;
Qwik to prioritize the loading of the most important components first,&#13;
resulting in a faster initial load time and a more responsive user&#13;
experience.</p>&#13;
&#13;
<p>An essential feature of Qwik is resumability<a data-primary="resumability" data-type="indexterm" id="id1121"/>. We covered resumability&#13;
crudely in our chapter on server-side React (<a data-type="xref" href="ch06.html#ch06">Chapter 6</a>), but to recap:&#13;
resumability is a process through which a server rendered snapshot of the&#13;
initial state of the page is sent to the client. As the user opens the&#13;
page, they interact with this static snapshot until they need more&#13;
interactivity. Then, various behaviors load on demand as users continue.&#13;
This mechanism provides an instant interaction opportunity for the user,&#13;
a characteristic that is not prevalent in many other frameworks.</p>&#13;
&#13;
<p>Resumability is far superior to hydration (also covered in <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>)&#13;
because it does not require rendering components twice. It also avoids&#13;
the “uncanny valley” of user interfaces where a website is not&#13;
interactive for a period of time after the initial server rendered&#13;
markup has made it to the browser and before the JavaScript has loaded&#13;
and hydrated the page. Qwik is instant on.</p>&#13;
&#13;
<p>When comparing Qwik to other popular frameworks such as React, Vue,&#13;
Svelte, or Solid, several differences emerge. While React and Vue also&#13;
adopt a component-based approach, if we’re not careful and intentional&#13;
about code splitting, we can send the entire JavaScript bundle for the&#13;
application to the client up front, sometimes getting into the megabyte&#13;
zone. This process can lead to longer initial load times, especially for&#13;
large applications. On the other hand, Qwik only loads the components<a data-primary="component-based architecture" data-secondary="Qwik" data-type="indexterm" id="id1122"/>&#13;
and event handlers as they are needed, resulting in faster initial load&#13;
times and a more responsive user experience. Qwik is also clever about&#13;
prefetching, and does so for lazy-loaded elements such that everything&#13;
is prefetched on initial load but only parsed and executed on demand.</p>&#13;
&#13;
<p>Qwik, like Svelte and Solid, focuses on performance, but achieves this&#13;
in different ways. Svelte compiles the components to highly efficient&#13;
imperative code that manipulates the DOM directly, while Solid uses a&#13;
reactive fine-grained reactivity model for its components. While&#13;
also using reactive primitives, Qwik focuses on optimizing component loading and making sure the most important ones are&#13;
available as soon as possible.</p>&#13;
&#13;
<p>In terms of developer experience, Qwik offers a simple and intuitive API&#13;
that makes it easy to define and work with components. Qwik components&#13;
are nearly identical to React components in terms of syntax and&#13;
structure, since they are also expressed with JSX<a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="Qwik’s use of" data-type="indexterm" id="id1123"/> (or TSX). This&#13;
similarity makes it easy for developers to get started with Qwik,&#13;
especially if they’re already familiar with React.</p>&#13;
&#13;
<p>Moreover, Qwik has interoperability with React<a data-primary="React" data-secondary="Qwik’s interoperability with" data-type="indexterm" id="id1124"/><a data-primary="qwikify utility" data-type="indexterm" id="id1125"/>, allowing developers to&#13;
use React components in Qwik applications via a <code>qwikify</code> utility. This&#13;
interoperability is a significant advantage for developers who want to&#13;
use Qwik but also want to take advantage of the rich ecosystem of React&#13;
libraries and tools.</p>&#13;
&#13;
<p>Qwik presents a novel approach to modern web development with its&#13;
component-based and event-driven architecture. Its focus on resumability&#13;
and prioritized loading sets it apart from other frameworks like React,&#13;
Vue, Svelte, and Solid. While each of these tools has its strengths and&#13;
use cases, Qwik’s unique features make it an exciting addition to the&#13;
landscape of web development frameworks. It could be the right choice&#13;
for developers and teams looking for a performant, user-centric, and&#13;
efficient way to build their web applications.</p>&#13;
&#13;
<p>The only drawback of Qwik is that it is still fairly new and does not&#13;
have quite as mature of an ecosystem as React, Vue, or Angular. However,&#13;
it is gaining traction and has a growing community of developers and&#13;
contributors. As Qwik continues to evolve, it will be interesting to see&#13;
how it compares to other frameworks and how it can be used to build even&#13;
more powerful applications<a data-startref="ix_Qwik.10.545.5" data-type="indexterm" id="id1126"/><a data-startref="ix_frameworksQwik.10.545.5" data-type="indexterm" id="id1127"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Common Patterns" data-type="sect1"><div class="sect1" id="id260">&#13;
<h1>Common Patterns</h1>&#13;
&#13;
<p>All of these technologies—React, Angular, Qwik, Solid, and Svelte—are&#13;
solutions for creating rich, interactive user interfaces for the web.&#13;
Though they vary in their philosophies, methodologies, and&#13;
implementation details, they share several commonalities that reflect&#13;
their shared purpose.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Component-Based Architecture" data-type="sect2"><div class="sect2" id="id164">&#13;
<h2>Component-Based Architecture</h2>&#13;
&#13;
<p>One of the primary commonalities among these frameworks and libraries is&#13;
the adoption of a component-based architecture<a data-primary="component-based architecture" data-seealso="client components; server components" data-type="indexterm" id="id1128"/>. In a component-based&#13;
architecture, UIs are broken down into individual pieces, or components,&#13;
each of which is responsible for a specific part of the user interface.</p>&#13;
&#13;
<p>Components encapsulate their own state and logic, and they can be&#13;
composed together to build complex UIs. This modularity promotes code&#13;
reuse, separation of concerns, and improved maintainability. In each of&#13;
these frameworks, components can be functional, and they can often be&#13;
composed, extended, or decorated to create more complex components.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Declarative Syntax" data-type="sect2"><div class="sect2" id="id165">&#13;
<h2>Declarative Syntax</h2>&#13;
&#13;
<p>React, Angular, Qwik, Solid, and Svelte all employ a declarative<a data-primary="declarative programming" data-type="indexterm" id="id1129"/> syntax&#13;
for defining UIs. In a declarative approach, developers specify what the&#13;
UI should look like for a given state, and the framework takes care of&#13;
updating the UI to match that state. This abstracts away the imperative&#13;
DOM manipulations that can make UI development tedious and error prone.</p>&#13;
&#13;
<p>All these technologies provide their own flavor of a templating language&#13;
for writing declarative UIs. React, Qwik, and Solid use JSX; Angular&#13;
uses its own HTML-based template syntax; and Svelte has its HTML-inspired&#13;
language.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Updates" data-type="sect2"><div class="sect2" id="id190">&#13;
<h2>Updates</h2>&#13;
&#13;
<p>All these libraries and frameworks provide a mechanism to respond to&#13;
updates<a data-primary="updates" data-secondary="approaches of different libraries and frameworks" data-type="indexterm" id="id1130"/> in the application state and alter the UI accordingly. React and&#13;
Vue use a virtual DOM diffing algorithm to make these updates. Svelte,&#13;
on the other hand, compiles components to imperative code that updates&#13;
the DOM directly. Angular uses a change detection mechanism based on&#13;
Zones and observables.</p>&#13;
&#13;
<p>Soon, it’ll pretty much be React using vDOM and everyone else using some&#13;
variety of signals.</p>&#13;
&#13;
<p>Despite the different methods, the goal is the same: to efficiently&#13;
update the UI in response to state changes, abstracting away the complex&#13;
DOM manipulation and allowing developers to focus on the application&#13;
logic.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lifecycle Methods" data-type="sect2"><div class="sect2" id="id166">&#13;
<h2>Lifecycle Methods</h2>&#13;
&#13;
<p>React, Angular, Solid, and Svelte provide lifecycle methods<a data-primary="lifecycle methods" data-seealso="hooks" data-type="indexterm" id="id1131"/><a data-primary="hooks" data-type="indexterm" id="id1132"/> or hooks,&#13;
which are functions that get called at different stages in a component’s&#13;
life, such as when it’s first created, when it’s updated, and when it’s&#13;
about to be removed from the DOM. Developers can use these methods to&#13;
run side effects, clean up resources, or make updates based on changes&#13;
in props.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ecosystem and Tooling" data-type="sect2"><div class="sect2" id="id167">&#13;
<h2>Ecosystem and Tooling</h2>&#13;
&#13;
<p>Each of these frameworks and libraries is supported by a rich ecosystem<a data-primary="ecosystems and tooling" data-type="indexterm" id="id1133"/>&#13;
of tools, libraries, and resources. They all have support for modern&#13;
JavaScript features and tooling, including ES6 syntax, modules, and&#13;
build tools like Webpack and Babel. They also have excellent TypeScript&#13;
support, allowing developers to write type-safe code and take advantage&#13;
of TypeScript’s powerful features.</p>&#13;
&#13;
<p>Most of these technologies also come with or have available&#13;
sophisticated developer tools that can aid in debugging and application&#13;
profiling. React’s and Angular’s developer tools extensions for popular&#13;
browsers are excellent examples of such tooling.</p>&#13;
&#13;
<p>While React, Angular, Qwik, Solid, and Svelte have their unique&#13;
strengths and philosophies, they share these common goals: providing a&#13;
component-based architecture, enabling the creation of declarative UIs,&#13;
offering reactivity to state changes, simplifying event handling,&#13;
providing lifecycle methods or similar concepts, and supporting a rich&#13;
ecosystem and modern JavaScript tooling. This shared set of features and&#13;
concepts is a testament to the evolution of web development toward more&#13;
modular, declarative, and reactive paradigms.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="React Is Not Reactive" data-type="sect1"><div class="sect1" id="id168">&#13;
<h1>React Is Not Reactive</h1>&#13;
&#13;
<p>The term “reactive” has been used to describe many things in the world&#13;
of programming, but it’s often used to describe systems that&#13;
automatically update in response to changes in data. The paradigm of&#13;
reactive programming<a data-primary="reactive programming" data-type="indexterm" id="ix_reactiveprogramming.10.717.21"/><a data-primary="React" data-secondary="versus reactive programming" data-secondary-sortas="reactive programming" data-type="indexterm" id="ix_Reactversusreactiveprogramming.10.717.21"/> is fundamentally about building systems that&#13;
respond to changes, and automatically propagating those changes through&#13;
the system. This is why frameworks like Vue.js and Svelte are often&#13;
described as being reactive. However, React does not follow the&#13;
traditional model of reactivity, and its approach is distinctly&#13;
different.</p>&#13;
&#13;
<p>React was introduced as a library for building user interfaces in a&#13;
declarative way—<em>declarative</em> meaning that those of us writing React&#13;
merely describe <em>what</em> we want, and React deals with the <em>how</em>. It&#13;
allows developers to describe the UI based on the current application&#13;
state, and React takes care of updating the UI whenever the state&#13;
changes. This description might sound like React is reactive, but&#13;
when you delve deeper into the implementation details, it becomes&#13;
apparent that React’s model is quite distinct from the traditional&#13;
reactive programming model.</p>&#13;
&#13;
<p>To understand why React isn’t reactive in the traditional sense,&#13;
let’s first look at what traditional reactivity looks like in a system.&#13;
In a traditional reactive system, dependencies<a data-primary="dependency tracking" data-type="indexterm" id="id1134"/> between computations are&#13;
automatically tracked as your code runs. When a reactive dependency&#13;
changes, all computations that depend on it are automatically rerun to&#13;
reflect this change. This is typically done using techniques such as&#13;
data-binding, observables, or signals and slots.</p>&#13;
&#13;
<p>Signals<a data-primary="signals" data-type="indexterm" id="id1135"/> for example, are a reactive primitive that can be used to create&#13;
reactive values: on read, the reader of the signal subscribes to it, and&#13;
on write, all subscribers are notified. This is reactivity 101.</p>&#13;
&#13;
<p>React uses a different approach to manage state<a data-primary="state management" data-secondary="React’s approach" data-type="indexterm" id="id1136"/> and its updates. Instead&#13;
of automatically tracking dependencies and propagating changes, React&#13;
introduces a more explicit mechanism for updating the state—the&#13;
<code>useState</code> hook. When state changes, instead of immediately rendering&#13;
updates, React schedules a rerender, and during that rerender, the&#13;
entire component function is run again with the new state.</p>&#13;
&#13;
<p>What that means is in the case of this counter:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Counter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="kd">function</code> <code class="nx">increment</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">increment</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Increment</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">Counter</code><code class="p">;</code></pre>&#13;
&#13;
<p>When <code>setCount</code> is called, the <code>Counter</code> function is reinvoked,&#13;
including the <code>useState</code> hook. This is different from the traditional&#13;
reactive model, where instead of reinvoking the entire function, only&#13;
the reactive portions of the UI would be updated, in this case, the&#13;
<code>{count}</code> inside of <code>&lt;p&gt;</code>. This is called coarse-grained reactivity, and it&#13;
is directly opposed to the fine-grained reactivity model of signals.</p>&#13;
&#13;
<p>React is often identified with the following equation:</p>&#13;
<pre>v = f(s)</pre>&#13;
&#13;
<p>That is, the view is equal to a function of its state. This equation&#13;
itself describes React’s nonreactive nature: the view is a function of&#13;
the state, but it’s not automatically updated when the state changes.&#13;
Instead, the view is updated when the function is re-executed with the&#13;
new state.</p>&#13;
&#13;
<p>This is where React’s virtual DOM diffing and reconciliation process<a data-primary="virtual DOM (vDOM)" data-secondary="diffing and reconciliation summary" data-type="indexterm" id="id1137"/>&#13;
comes in. When a component’s state or props change, React rerenders the&#13;
component, creating a new virtual DOM subtree. It then diffs this new&#13;
subtree with the old one, computes the minimal set of actual DOM&#13;
mutations needed, and applies those mutations to the DOM.</p>&#13;
&#13;
<p>This model of explicitly setting state and rerendering, as opposed to&#13;
automatic reactive propagation of changes, allows for more&#13;
predictability: React, if anthropomorphized, would say, “Tell me your&#13;
state expectations and I’ll take care of it.” It enables features like&#13;
batching of state updates and makes it easier to reason about the state&#13;
of the application at any point in time because the state update and the&#13;
resulting UI update are linked in a single, atomic operation.</p>&#13;
&#13;
<p>However, this also means that React components are less reactive in&#13;
the traditional sense. They don’t automatically react to changes in&#13;
data. Instead, they explicitly describe what the UI should look like for&#13;
a given state, and it’s up to React to apply any necessary updates when&#13;
the state changes through re-executing functions instead of the&#13;
appropriate values just updating in place.</p>&#13;
&#13;
<p>While React’s approach is not reactive in the sense of automatically&#13;
tracking and propagating changes, it still provides a highly effective&#13;
mechanism for building dynamic, interactive user interfaces. The use of&#13;
state and props to control rendering provides a clear and predictable&#13;
model for understanding how changes propagate through the application,&#13;
and the virtual DOM system efficiently manages updates to the actual&#13;
DOM.</p>&#13;
&#13;
<p>In the end, whether or not React’s approach is considered reactive&#13;
comes down to semantics. If you define reactivity as the automatic&#13;
propagation of changes through a system, then no, React is not reactive.&#13;
But if you define reactivity as the ability of a system to respond to&#13;
changes in state in a predictable and controlled manner, then yes, React&#13;
can certainly be considered reactive.</p>&#13;
&#13;
<p>Looking at React and other frameworks/libraries, it’s clear that there&#13;
isn’t a one-size-fits-all approach to managing state and reactivity in&#13;
UI development. Each tool has its strengths and trade-offs and is suited&#13;
to different use cases. Understanding these differences is crucial when&#13;
choosing the right tool for the job and can also help in writing more&#13;
effective and efficient code, regardless of the framework or library&#13;
you’re using.</p>&#13;
&#13;
<p>React’s model of handling state and updates provides an excellent&#13;
balance between control and convenience. The explicit state update&#13;
mechanism allows developers to reason about their application state more&#13;
easily, while the reconciliation and diffing algorithm efficiently&#13;
applies updates to the DOM. Despite not being traditionally&#13;
“reactive,” React’s approach has proven to be incredibly effective for&#13;
building complex user interfaces.</p>&#13;
&#13;
<p>There’s no denying that reactive programming models offer some&#13;
compelling benefits, particularly when it comes to automatically&#13;
managing dependencies and updates. But as we’ve seen, React’s approach&#13;
offers its own set of advantages, providing a high degree of control and&#13;
predictability.</p>&#13;
&#13;
<p>For completionists, we’ll now look at how the same counter would&#13;
look in Solid<a data-primary="Solid" data-type="indexterm" id="id1138"/>, a framework that uses a reactive model:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createSignal</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"solid"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Counter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">createSignal</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="kd">function</code> <code class="nx">increment</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">count</code><code class="p">()}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">increment</code><code class="p">()}</code><code class="o">&gt;</code><code class="nx">Increment</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">Counter</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this example, <code>count</code> is a reactive property of the component’s data.&#13;
When we first read <code>count</code> by calling <code>count()</code> in place inside our&#13;
<code>&lt;p&gt;</code> elements, we implicitly subscribe that portion of our JSX to&#13;
the reactive value of <code>count</code>.</p>&#13;
&#13;
<p>Then, when we call <code>increment()</code> later, which then calls <code>setCount</code>,&#13;
<code>setCount</code> updates the value and notifies all subscribers that the value&#13;
changed, prompting them to update. This is a bit analogous to the&#13;
pub/sub pattern, where a subscriber subscribes to a publisher, and&#13;
the publisher notifies all subscribers.</p>&#13;
&#13;
<p>The result is fine-grained reactivity: that is, the function component&#13;
itself, <code>Counter</code>, is never called more than once, but the fine-grained,&#13;
small reactive values are.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Example 2: Dependent Values" data-type="sect2"><div class="sect2" id="id169">&#13;
<h2>Example 2: Dependent Values</h2>&#13;
&#13;
<p>Consider a component that displays a list of items and the count of&#13;
those items. In a reactive system like Svelte<a data-primary="Svelte" data-type="indexterm" id="id1139"/>, the count would&#13;
automatically update whenever the list changes:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">script</code><code class="o">&gt;</code>&#13;
  <code class="kd">let</code> <code class="nx">items</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'Apple'</code><code class="p">,</code> <code class="s1">'Banana'</code><code class="p">,</code> <code class="s1">'Cherry'</code><code class="p">];</code>&#13;
  <code class="nx">$</code><code class="o">:</code> <code class="nx">count</code> <code class="o">=</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>&#13;
<code class="o">&lt;</code><code class="err">/script&gt;</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code> <code class="nx">items</code><code class="o">:&lt;</code><code class="err">/p&gt;</code>&#13;
<code class="o">&lt;</code><code class="nx">ul</code><code class="o">&gt;</code>&#13;
  <code class="p">{</code><code class="err">#</code><code class="nx">each</code> <code class="nx">items</code> <code class="nx">as</code> <code class="nx">item</code> <code class="p">(</code><code class="nx">item</code><code class="p">)}</code>&#13;
    <code class="o">&lt;</code><code class="nx">li</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">item</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/li&gt;</code>&#13;
  <code class="p">{</code><code class="err">/each}</code>&#13;
<code class="o">&lt;</code><code class="err">/ul&gt;</code></pre>&#13;
&#13;
<p>Here, <code>$: count = items.length;</code> declares a reactive statement. Whenever&#13;
<code>items</code> changes, the <code>count</code> is automatically recalculated.</p>&#13;
&#13;
<p>In React, this looks a bit different:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">ItemList</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">items</code><code class="p">,</code> <code class="nx">setItems</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">([</code><code class="s2">"Apple"</code><code class="p">,</code> <code class="s2">"Banana"</code><code class="p">,</code> <code class="s2">"Cherry"</code><code class="p">]);</code>&#13;
  <code class="kr">const</code> <code class="nx">count</code> <code class="o">=</code> <code class="nx">items</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// ... update items somewhere ...</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code> <code class="nx">items</code><code class="o">:&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ul</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
          <code class="o">&lt;</code><code class="nx">li</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">}</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">item</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/li&gt;</code>&#13;
        <code class="p">))}</code>&#13;
      <code class="o">&lt;</code><code class="err">/ul&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">ItemList</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this React component, <code>count</code> is not a reactive value that&#13;
automatically updates when <code>items</code> changes. Instead, it’s a value&#13;
derived from the current state during the render phase. When <code>items</code>&#13;
changes, we need to call <code>setItems</code> to update the state and cause a&#13;
rerender, at which point <code>count</code> is recalculated not because <code>count</code> is&#13;
reactive, but because the <code>ItemList</code> function component is reinvoked<a data-startref="ix_reactiveprogramming.10.717.21" data-type="indexterm" id="id1140"/><a data-startref="ix_Reactversusreactiveprogramming.10.717.21" data-type="indexterm" id="id1141"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Future of React" data-type="sect1"><div class="sect1" id="id191">&#13;
<h1>The Future of React</h1>&#13;
&#13;
<p>Given the widespread<a data-primary="React" data-secondary="future of" data-type="indexterm" id="ix_Reactfutureof.10.954.21"/> adoption of reactive primitives like signals across&#13;
the entire frontend ecosystem, some would presume that React would&#13;
eventually adopt a similar approach. However, the React team has&#13;
expressed that they are “not excited” about signals and opt for an&#13;
alternative approach to arrive at similar performance benefits that&#13;
signals provide.</p>&#13;
&#13;
<p>To understand this a little better, let’s recap some of the things we’ve&#13;
learned about React through an example. Consider this component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code>&#13;
<code class="p">{</code> <code class="nx">ComponentWithExpensiveChildren</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./ExpensiveComponent"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Counter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="kd">function</code> <code class="nx">increment</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">increment</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Increment</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ComponentWithExpensiveChildren</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">Counter</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this very, very contrived example, we have a component that contains&#13;
state called <code>Counter</code> with some children:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A <code>&lt;p&gt;</code> element that displays the current count</p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>&lt;button&gt;</code> element that increments the count</p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>&lt;ComponentWithExpensiveChildren&gt;</code> component that renders some&#13;
expensive children with a lot of computation</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Now, let’s say we click the button to increment the count. What happens?&#13;
The <code>Counter</code> function is called/reinvoked/rerendered along with all&#13;
its children. This is React’s default behavior. This means that&#13;
the <code>&lt;ComponentWithExpensiveChildren&gt;</code> component is rerendered even&#13;
though it doesn’t need to be: its props or state hasn’t changed!</p>&#13;
&#13;
<p>This coarse-grained reactivity makes React less performant than it could&#13;
be. However, this is quite an easy fix: we just include <code>memo</code> at the&#13;
right time and in the right place:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code><code class="p">,</code> <code class="nx">memo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">ComponentWithExpensiveChildren</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./ComponentWithExpensiveChildren"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Counter</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="kd">function</code> <code class="nx">increment</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">increment</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Increment</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">MemoizedComponentWithExpensiveChildren</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">MemoizedComponentWithExpensiveChildren</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(</code>&#13;
  <code class="nx">ComponentWithExpensiveChildren</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">Counter</code><code class="p">;</code></pre>&#13;
&#13;
<p>This works, as long as we remember to use <code>memo</code> everywhere we need to.&#13;
Indeed, this provides the same fine-grained reactivity as signals.&#13;
However, it’s not as convenient as signals, because we have to remember&#13;
to use <code>memo</code> everywhere we need to.</p>&#13;
&#13;
<p>Many of us at this point may be thinking that signals<a data-primary="signals" data-secondary="React’s reluctance to adopt" data-type="indexterm" id="id1142"/> could easily solve&#13;
this problem, but the React team at Meta believes that signals, like&#13;
<code>memo</code>, may be an implementation detail that everyday developers who use&#13;
React ought not have to think about. They hearken back to the initial&#13;
value proposition of React: “declaratively describe your UI, let React&#13;
do the rest.” The React team believes that the superior way is where&#13;
developers don’t concern ourselves with signals, <code>memo</code>, or any details,&#13;
but that React should be able to figure out the optimal way to render&#13;
the UI.</p>&#13;
&#13;
<p>To this end, the team is working on a new piece of software to do just&#13;
that: React &#13;
<span class="keep-together">Forget.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="React Forget" data-type="sect2"><div class="sect2" id="id170">&#13;
<h2>React Forget</h2>&#13;
&#13;
<p>Forget<a data-primary="Forget" data-type="indexterm" id="id1143"/><a data-primary="React Forget" data-type="indexterm" id="id1144"/> is a toolchain for React similar to a linter that has its <code>--fix</code>&#13;
flag enabled: it enforces the rules of React and then automatically&#13;
transforms React code to be optimal through intelligently memoizing&#13;
values that will not change throughout the lifecycle of an&#13;
application—like <code>ComponentWithExpensiveChildren</code>.</p>&#13;
&#13;
<p>Because of the rules of React, the Forget compiler can predict these&#13;
values and memoize them for us. This is a similar approach to what&#13;
Svelte does, but instead of compiling to imperative code, Forget&#13;
compiles to more performant React code.</p>&#13;
&#13;
<p>What are these rules of React? Let’s recap:</p>&#13;
<ol>&#13;
<li>&#13;
<p>React components are expected to be pure functions.</p>&#13;
</li>&#13;
<li>&#13;
<p>Some hooks and custom event handlers are not required to be pure.</p>&#13;
</li>&#13;
<li>&#13;
<p>Forbidden actions within pure functions include:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Mutating variables/objects not newly created within the function</p>&#13;
</li>&#13;
<li>&#13;
<p>Reading properties that may change</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Allowed actions include:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Reading props or state</p>&#13;
</li>&#13;
<li>&#13;
<p>Throwing errors</p>&#13;
</li>&#13;
<li>&#13;
<p>Mutating newly created objects/bindings</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Lazy initialization is an exception allowing mutation for the purpose&#13;
of &#13;
<span class="keep-together">initialization.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Objects or closures created during render should not be mutated after&#13;
render completes, except mutable objects stored in state.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Because of these rules, the Forget compiler can predict which values&#13;
will not change throughout the lifecycle of an application and memoize&#13;
them for us. The result? Highly optimized, highly performant React code&#13;
that rivals the performance of other libraries that use signals.</p>&#13;
&#13;
<p>At the time of writing, Forget is in evaluation at Meta and exceeding&#13;
expectations in use on Instagram and WhatsApp. It is not yet open&#13;
source, but the React team is considering releasing it as open source software in the near&#13;
future.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Forget versus signals" data-type="sect3"><div class="sect3" id="id171">&#13;
<h3>Forget versus signals</h3>&#13;
&#13;
<p>Because Forget isn’t yet open source, it’s somewhat challenging to&#13;
comment on its trade-offs with any amount of authority. However, we can&#13;
posit that if Forget indeed memoizes<a data-primary="memoization" data-secondary="and Forget" data-secondary-sortas="Forget" data-type="indexterm" id="id1145"/><a data-primary="Forget" data-type="indexterm" id="id1146"/><a data-primary="React Forget" data-type="indexterm" id="id1147"/> everything that doesn’t change,&#13;
fine-grained reactivity from signals may still be superior to&#13;
coarse-grained reactivity with React Forget, because signals live in a&#13;
parallel universe outside of the component hierarchy.</p>&#13;
&#13;
<p>Thus, when an update happens, React will still have to walk the entire&#13;
component tree and compare the new and old values of each component’s&#13;
props to determine which components need to be rerendered. This is not&#13;
the case with signals, where only the reactive portions of the UI are&#13;
updated without needing to walk a tree. This preliminary data does&#13;
suggest that even with Forget, React may still be slower than libraries&#13;
where signals are the default, but it is too early to tell<a data-startref="ix_Reactfutureof.10.954.21" data-type="indexterm" id="id1148"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chapter Review" data-type="sect1"><div class="sect1" id="id261">&#13;
<h1>Chapter Review</h1>&#13;
&#13;
<p>This chapter began with a recap of <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>, where we covered the use of&#13;
RSCs in detail. We then delved into the vast&#13;
landscape of JavaScript frameworks beyond React, including Angular, Vue,&#13;
Svelte, Solid, and Qwik, aiming to understand the differences and&#13;
similarities among these libraries and frameworks.</p>&#13;
&#13;
<p>We started with a look at Vue.js, and explored how it uses a&#13;
declarative approach for building UIs and promotes a strong separation&#13;
of concerns through its component-based architecture.</p>&#13;
&#13;
<p>Next, we took a dive into Angular, Svelte, Solid, and Qwik,&#13;
exploring their unique features and philosophies. We looked at how they&#13;
use reactive primitives to automatically update the UI in response to&#13;
changes in data, and how they differ from React in this regard.</p>&#13;
&#13;
<p>After the individual examinations, we drew comparisons among these UI&#13;
libraries, underlining their strengths, weaknesses, and overlaps. We&#13;
looked at their reactivity models, architectural choices, development&#13;
experience, and performance characteristics. Through code examples, we&#13;
showed the unique qualities of each, helping us to understand their&#13;
differences better.</p>&#13;
&#13;
<p>We also examined the concept of reactivity and how it is implemented&#13;
differently across various libraries. Interestingly, we discussed how&#13;
React is not reactive in the traditional sense, as it follows a&#13;
coarser approach where a change in state leads to a rerender, unlike&#13;
the fine-grained reactivity model found in libraries like Vue or Svelte.</p>&#13;
&#13;
<p>Finally, we looked at the future of React and how it might evolve in the&#13;
coming years. We discussed the React team’s approach to reactivity and&#13;
how it differs from the traditional reactive programming model. We also&#13;
looked at the Forget compiler, a toolchain for React that automatically&#13;
optimizes React code by memoizing values that don’t change throughout&#13;
the lifecycle of an application.</p>&#13;
&#13;
<p>Let’s finally land the plane.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect1"><div class="sect1" id="id262">&#13;
<h1>Review Questions</h1>&#13;
&#13;
<p>Here is a list of questions to help you track your understanding of the concepts covered in this chapter. If you can answer all of them confidently, great! That’s a sign you’re learning from this book. If you cannot, it might be worth rereading this &#13;
<span class="keep-together">chapter.</span></p>&#13;
<ol>&#13;
<li>&#13;
<p>How does the reactivity model differ among React, Vue, Svelte,&#13;
Solid, and Angular? What are the implications of these differences on&#13;
the performance and development experience of these&#13;
libraries/frameworks?</p>&#13;
</li>&#13;
<li>&#13;
<p>Discuss the unique approach of Qwik in maximizing performance. How does this differ from the approach of other UI libraries/frameworks we’ve discussed?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are the core strengths and weaknesses of each UI&#13;
library/framework discussed in this chapter? How might these strengths&#13;
and weaknesses influence the choice of library/framework for a&#13;
particular project?</p>&#13;
</li>&#13;
<li>&#13;
<p>React is not reactive in the traditional sense. Explain this&#13;
statement in detail, comparing it with the “push-based” reactivity&#13;
model found in libraries like Vue or Svelte.</p>&#13;
</li>&#13;
<li>&#13;
<p>What’s React Forget? How does it work? How does it compare to signals?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up Next" data-type="sect1"><div class="sect1" id="id263">&#13;
<h1>Up Next</h1>&#13;
&#13;
<p>As we draw closer to the conclusion of this comprehensive journey&#13;
through the world of React and its ecosystem, we’re preparing to&#13;
synthesize all that we’ve learned. In the next and final chapter, we’ll&#13;
be stepping back and reflecting on the whole landscape.</p>&#13;
&#13;
<p>We’ll be wrapping up this book and providing a holistic view of where we&#13;
stand today and what we can anticipate tomorrow. In doing so, we’ll be&#13;
drawing on all the technical knowledge and insights that we’ve gathered&#13;
throughout the course of this book.</p>&#13;
&#13;
<p>From understanding the inner workings of React’s reconciler and diving&#13;
into asynchrony, to tackling server components and understanding various&#13;
React frameworks, to comparing React with its peers—all this was done&#13;
with a purpose. Now, we’re ready to connect the dots, to see the bigger&#13;
picture, and to chart the path forward.</p>&#13;
&#13;
<p>So, are you ready to take a leap into the future of React and frontend&#13;
development? Stay tuned for the grand finale!</p>&#13;
</div></section>&#13;
</div></section></body></html>