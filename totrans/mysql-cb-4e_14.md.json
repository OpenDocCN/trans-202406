["```\nmysql> `SELECT @@sql_mode;`\n+------------+\n| @@sql_mode |\n+------------+\n|            |\n+------------+\n1 row in set (0,00 sec)\nmysql> `CREATE TABLE t (i INT, c CHAR(6), d DATE);`\n```", "```\nmysql> `INSERT INTO t (i,c,d) VALUES('-1x','too-long string!','1999-02-31');`\nmysql> `SHOW WARNINGS;`\n+---------+------+--------------------------------------------+\n| Level   | Code | Message                                    |\n+---------+------+--------------------------------------------+\n| Warning | 1265 | Data truncated for column 'i' at row 1     |\n| Warning | 1265 | Data truncated for column 'c' at row 1     |\n| Warning | 1264 | Out of range value for column 'd' at row 1 |\n+---------+------+--------------------------------------------+\nmysql> `SELECT * FROM t;`\n+------+--------+------------+\n| i    | c      | d          |\n+------+--------+------------+\n|   -1 | too-lo | 0000-00-00 |\n+------+--------+------------+\n```", "```\nmysql> `SET sql_mode = 'STRICT_ALL_TABLES';`\nmysql> `INSERT INTO t (i,c,d) VALUES('-1x','too-long string!','1999-02-31');`\nERROR 1265 (01000): Data truncated for column 'i' at row 1\n```", "```\nmysql> `SET sql_mode = 'STRICT_ALL_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE';`\n```", "```\nmysql> `SET sql_mode = 'TRADITIONAL';`\nmysql> `SELECT @@sql_mode\\G`\n*************************** 1\\. row ***************************\n@@sql_mode: STRICT_TRANS_TABLES,STRICT_ALL_TABLES,NO_ZERO_IN_DATE,\n            NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,TRADITIONAL,\n            NO_ENGINE_SUBSTITUTION\n```", "```\nmysql> `SET GLOBAL sql_mode = '`*`mode_value`*`';`\n```", "```\nmysql> `CREATE` `TABLE` `even` `(`\n    -> `even_value` `INT` `CHECK``(``even_value` `%` `2` `=` `0``)`\n    -> `)` `ENGINE``=``InnoDB``;`\nQuery OK, 0 rows affected (0.03 sec)\n```", "```\nmysql> `INSERT` `INTO` `even` `VALUES``(``2``)``;`\nQuery OK, 1 row affected (0.01 sec)\n```", "```\nmysql> `INSERT` `INTO` `even` `VALUES``(``1``)``;`\nERROR 3819 (HY000): Check constraint 'even_chk_1' is violated.\n```", "```\nmysql> `CREATE` `TABLE` `even_100` `(`\n    -> `even_value` `INT` `CHECK``(``even_value` `%` `2` `=` `0``)` `CHECK``(``even_value` `<` `100``)`\n    -> `)` `ENGINE``=``InnoDB``;`\nQuery OK, 0 rows affected (0.02 sec)\n```", "```\nmysql> `INSERT` `INTO` `even_100` `VALUES``(``101``)``;`\nERROR 3819 (HY000): Check constraint 'even_100_chk_1' is violated.\nmysql> `INSERT` `INTO` `even_100` `VALUES``(``102``)``;`\nERROR 3819 (HY000): Check constraint 'even_100_chk_2' is violated.\n```", "```\nALTER TABLE patients ADD CONSTRAINT date_check \nCHECK((date_departed IS NULL) OR (date_departed >= date_arrived));\n```", "```\nmysql> `INSERT` `INTO` `patients` `(``national_id``,` `name``,` `surname``,` `gender``,` `age``,` `diagnosis``,` \n    -> `date_arrived``,` `date_departed``)`\n    -> `VALUES``(``'34GD429520'``,` `'John'``,` `'Doe'``,` `'M'``,` `45``,` `'Data Phobia'``,`\n    -> `'2020-07-20'``,` `'2020-05-31'``)``;`\nERROR 3819 (HY000): Check constraint 'date_check' is violated.\n```", "```\nCREATE TABLE `groceries` (\n  `id` int NOT NULL,\n  `name` varchar(255) DEFAULT NULL,\n  `forbidden_after` time DEFAULT NULL,\n  `forbidden_before` time DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB;\n```", "```\nCREATE TABLE groceries_order_items\n(\n  order_id INT NOT NULL,\n  groceries_id INT NOT NULL,\n  quantity INT DEFAULT 0,\n  PRIMARY KEY (order_id,groceries_id)\n) ENGINE=InnoDB;\n```", "```\nCREATE TRIGGER check_time\nBEFORE INSERT ON groceries_order_items\nFOR EACH ROW BEGIN\nDECLARE forbidden_after_val TIME; ![1](Images/1.png)\nDECLARE forbidden_before_val TIME;\nDECLARE name_val VARCHAR(255);\nDECLARE message VARCHAR(400);\n\nSELECT forbidden_after, forbidden_before, name ![2](Images/2.png)\nINTO forbidden_after_val, forbidden_before_val, name_val\nFROM groceries WHERE id = NEW.groceries_id;\n\nIF (forbidden_after_val IS NOT NULL AND TIME(NOW()) >= forbidden_after_val) ![3](Images/3.png)\n  OR (forbidden_before_val IS NOT NULL AND TIME(NOW()) <= forbidden_before_val)\nTHEN\n  SET message=CONCAT('It is forbidden to buy ', name_val,\n      ' between ', forbidden_after_val, ' and ', forbidden_before_val); ![4](Images/4.png)\n  SIGNAL SQLSTATE '45000' ![5](Images/5.png)\n    SET MESSAGE_TEXT = message;\nEND IF;\nEND;\n```", "```\nmysql> `SELECT` `CURRENT_TIME``(``)``;`\n+----------------+ | CURRENT_TIME() |\n+----------------+ | 03:01:40       |\n+----------------+ 1 row in set (0.00 sec)\nmysql> `INSERT` `INTO` `groceries_order_items` `VALUES``(``1``,``3``,``1``)``;` `-- cheese`\nQuery OK, 1 row affected (0.03 sec)\n\nmysql> `INSERT` `INTO` `groceries_order_items` `VALUES``(``1``,``8``,``3``)``;` `-- water`\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> `INSERT` `INTO` `groceries_order_items` `VALUES``(``1``,``7``,``6``)``;` `-- beer`\nERROR 1644 (45000): It is forbidden to buy beer between 22:00:00 and 06:00:00\nmysql> `INSERT` `INTO` `groceries_order_items` `VALUES``(``1``,``6``,``1``)``;` `-- wine`\nERROR 1644 (45000): It is forbidden to buy wine between 22:00:00 and 06:00:00\n```", "```\nmysql> `SELECT` `CURRENT_TIME``(``)``;`\n+----------------+ | CURRENT_TIME() |\n+----------------+ | 14:00:35       |\n+----------------+ 1 row in set (0.00 sec)\n\nmysql> `INSERT` `INTO` `groceries_order_items` `VALUES``(``1``,``7``,``6``)``;` `-- beer`\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> `INSERT` `INTO` `groceries_order_items` `VALUES``(``1``,``6``,``1``)``;` `-- wine`\nQuery OK, 1 row affected (0.01 sec)\n```", "```\n#!/usr/bin/python3\n# loop.py: Typical input-processing loop.\n\n# Assumes tab-delimited, linefeed-terminated input lines.\n\nimport sys\n\nfor line in sys.stdin:\n    line = line.rstrip()\n    # split line at tabs, preserving all fields\n    values = line.split(\"\\t\")\n    for val in values: # iterate through fields in line\n        # ... test val here ...\n        pass\n```", "```\np = re.compile('^\\+?\\d+$')\n  s = p.search(val)\n  valid = s and (s.group(0) != '0')\n```", "```\nvalid = is_positive_integer (val);\n```", "```\ndef is_positive_integer(val):\n  p = re.compile('^\\+?\\d+$')\n  s = p.search(val)\n  return s and (s.group(0) != '0')\n```", "```\nimport cookbook_utils as cu\n```", "```\npattern = re.compile(*`pat`*)\n```", "```\nit_matched = pattern.match(val)    # pattern match\n```", "```\nit_matched = re.match(*`pat`*, val)    # pattern match\n```", "```\nit_matched = re.match(*`pat`*, val, re.I)   # case-insensitive match\n```", "```\nno_match = not re.match(*`pat`*, val)     # negated pattern match\n```", "```\nval = re.sub(*`pat`*, *`replacement`*, val)    # substitution\nval = re.sub(*`pat`*, *`replacement`*, val, flags = re.I)   # case-insensitive substitution\nval = re.sub(*`pat`*, *`replacement`*, val, count = 1)   # substitution of the first match\nval = re.sub(*`pat`*, *`replacement`*, val, count = 1, flags = re.I)  \n             # case-insensitive and the first match\n```", "```\nval = re.sub('^\\s+', '', val)   # trim leading whitespace\nval = re.sub('\\s+$', '', val)   # trim trailing whitespace\n```", "```\nval = trim_whitespace (val)\n```", "```\nmatch = re.match('^(\\d+)(.*)$', '2021-04-25')\nif match:\n  first_part = match.group(1) # this is the year, 2021\n  the_rest = match.group(2)   # this is the rest of the date, -04-25\n```", "```\n^-?\\d+\\.?$\n```", "```\n^\\d{1,2}:\\d{2}\\s*(AM|PM)?$\n```", "```\n^\\d{1,2}:\\d{2}\\s*(?:AM|PM)?$\n```", "```\nmatch = re.match('^(\\d+)', val)\nif match:\n  val = match.group(1)\n```", "```\n0123456789012345\n0123 4567 8901 2345\n0123-4567-8901-2345\n```", "```\n^[- \\d]+\n```", "```\nval = re.sub('\\D', '', val)\nvalid = len(val) == 16\n```", "```\n^\\d{4}-\\d{2}-\\d{2}$\n```", "```\n^\\d{4}[-/]\\d{2}[-/]\\d{2}$\n```", "```\n^\\d{4}\\D\\d{2}\\D\\d{2}$\n```", "```\n^\\d+\\D\\d+\\D\\d+$\n```", "```\n^\\d{2,4}?\\D\\d{1,2}\\D\\d{1,2}$\n```", "```\n^\\d{2}-\\d{2}-\\d{2}$\n```", "```\nmatch = re.match('^(\\d{2,4})\\D(\\d{1,2})\\D(\\d{1,2})$', val)\nif match:\n  (year, month, day) = (match.group(1), match.group(2), match.group(3))\n```", "```\ndef is_iso_date(val):\n  m = re.match('^(\\d{2,4})\\D(\\d{1,2})\\D(\\d{1,2})$', val)\n  return [int(m.group(1)),  int(m.group(2)), int(m.group(3))] if m else None\n```", "```\nref = cu.is_iso_date(val)\nif ref is not None:\n  # val matched ISO format pattern;\n  # check its subparts using ref[0] through ref[2]\n  pass\nelse:\n  # val didn't match ISO format pattern\n  pass\n```", "```\nval = re.sub('^(\\d+)\\D(\\d+)\\D(\\d+)$', r'\\3-\\1-\\2', val)\n```", "```\n^\\d{2}:\\d{2}:\\d{2}$\n```", "```\n^\\d{1,2}:\\d{2}(:\\d{2})?$\n```", "```\nm = re.match('^(\\d{1,2}):(\\d{2})(?::(\\d{2}))?$', val)\n(hour, min, sec) = (m.group(1), m.group(2), m.group(3))\nsec = '00' if sec is None else sec # seconds missing; use 00\nval = hour + ':' + min + ':' + sec\n```", "```\nm = re.match('^(\\d{1,2})\\D(\\d{2})\\D(\\d{2})(?:\\s*(AM|PM))?$', val, flags = re.I)\n(hour, min, sec) = (m.group(1), m.group(2), m.group(3))\n# supply missing seconds\nsec = '00' if sec is None else sec \nif int(hour) == 12 and (m.group(4) is None or m.group(4).upper() == \"AM\"):\n  hour = '00' # 12:xx:xx AM times are 00:xx:xx\nelif int(hour) < 12 and (m.group(4) is not None) and m.group(4).upper() == \"PM\":\n  hour = int(hour) + 12 # PM times other than 12:xx:xx\nreturn [hour, min, sec] # return hour, minute, second\n```", "```\n.@.\n```", "```\n^[^@ ]+@[^@ ]+$\n```", "```\n^[^@ ]+@[^@ .]+\\.[^@ .]+\n```", "```\nre.compile('^(https?://|ftp://|mailto:)', flags=re.I)\n```", "```\nmysql> `SELECT COLUMN_TYPE FROM INFORMATION_SCHEMA.COLUMNS`\n    -> `WHERE TABLE_SCHEMA = 'cookbook' AND TABLE_NAME = 'profile'`\n    -> `AND COLUMN_NAME = 'color';`\n```", "```\n+----------------------------------------------------+\n| COLUMN_TYPE                                        |\n+----------------------------------------------------+\n| enum('blue','red','green','brown','black','white') |\n+----------------------------------------------------+\n```", "```\nvalid = True ↩\nif list(map(lambda v: v.upper(), members)).count(val.upper()) > 0 ↩\nelse False\n```", "```\ndef check_enum_value(conn, db_name, tbl_name, col_name, val):\n  valid = 0 \n  info = get_enumorset_info(conn, db_name, tbl_name, col_name)\n  if info is not None and info['type'].upper() == 'ENUM':\n    # use case-insensitive comparison because default collation\n    # (utf8mb4_0900_ai_ci) is case-insensitive (adjust if you use\n    # a different collation)\n    valid = 1 ↩\n    if list(map(lambda v: v.upper(), info['values'])).count(val.upper()) > 0 ↩\n    else 0\n  return valid\n```", "```\ninfo = get_enumorset_info(conn, db_name, tbl_name, col_name)\nmembers={}\n# convert dictionary key to consistent lettercase\nfor v in info['values']:\n  members[v.lower()] = 1\n```", "```\nvalid = 1 if val.lower() in members else 0\n```", "```\ndef check_set_value(conn, db_name, tbl_name, col_name, val):\n  valid = 0 \n  info = get_enumorset_info(conn, db_name, tbl_name, col_name)\n  if info is not None and info['type'].upper() == 'SET':\n    if val == \"\": \n      return 1 # empty string is legal element\n    # use case-insensitive comparison because default collation\n    # (utf8mb4_0900_ai_ci) is case-insensitive (adjust if you use\n    # a different collation)\n    valid = 1  # assume valid until we find out otherwise\n    for v in val.split(','):\n      if list(map(lambda x: x.upper(), info['values'])).count(v.upper()) <= 0:\n        valid = 0 \n        break\n  return valid\n```", "```\nvalid = 1 # assume valid until we find out otherwise\nfor v in val.split(\",\"):\n  if v.lower() not in members:\n    valid = 0 \n    break\n```", "```\ncursor.execute(\"select count(*) from *`tbl_name`* where val = %(val)s\", {'val': *`value`*})\nvalid = cursor.fetchone()[0]\n```", "```\nmembers = {}  # dictionary for lookup values\ncursor.execute(\"SELECT val FROM *`tbl_name`*\");\nrows = cursor.fetchall()\nfor row in rows:\n  members[row[0]] = 1\n```", "```\nvalid = True if val in members else False\n```", "```\nmembers = {}  # dictionary for lookup values\n```", "```\nif val not in members: # haven't seen this value yet\n  cursor.execute(f\"SELECT COUNT(*) FROM {tbl_name} WHERE val = %(val)s\",↩\n                 {'val': val})\n  count = cursor.fetchone()[0]\n  # store true/false to indicate whether value was found\n  members[val] = True if count > 0 else False\nvalid = members[val]\n```", "```\nmysql> `SELECT` `CAST``(``69` `AS` `YEAR``)` `AS` `` ` ```", "``` ` ```", "```70```", "```,` \n    -> `CAST``(``22` `AS` `YEAR``)` `AS` `` ` ```", "``` ` ```", "```\n\nTo use a different transition point, convert years to four-digit form yourself. Here’s a general-purpose routine that converts two-digit years to four digits and supports an arbitrary transition point:\n\n```", "```\n\nThe function uses MySQL’s transition point (70) by default. An optional second argument may be given to provide a different transition point. `yy_to_yyyy()` also verifies that the year actually is less than 100 and needs converting before modifying it. That way you can pass year values regardless of whether they include the century. Some sample invocations using the default transition point have the following results:\n\n```", "```\n\nSuppose that you want to convert year values as follows, using a transition point of 50:\n\n```", "```\n\nTo do this, pass an explicit transition point argument to `yy_to_yyyy()`:\n\n```", "```\n\nThe `yy_to_yyyy()` function is included in the *cookbook_utils.py* library file of the `recipes` distribution.\n\n# 14.14 Performing Validity Checking on Date or Time Subparts\n\n## Problem\n\nA string passes a pattern test as a date or time, but you want to perform further validity checking.\n\n## Solution\n\nBreak the value into parts and perform the appropriate range checking on each part.\n\n## Discussion\n\nPattern matching may not be sufficient for date or time checking. For example, a value like `1947-15-19` might match a date pattern, but it’s not a legal date. To perform more rigorous value testing, combine pattern matching with range checking. Break out the year, month, and day values, then check whether each is within the proper range. Years should be less than 9999 (MySQL represents dates to an upper limit of `9999-12-31`), month values must be in the range from 1 to 12, and days must be in the range from 1 to the number of days in the month. That last part is the trickiest: it’s month-dependent, and also year-dependent for February because it changes for leap years.\n\nSuppose that you’re checking input dates in ISO format. In [Recipe 14.9](#nch-format-format-pat-temporal), we used the `is_iso_date()` function from the *cookbook_utils.py* library file to perform a pattern match on a date string and break it into component values. `is_iso_date()` returns `None` if the value doesn’t satisfy a pattern that matches ISO date format. Otherwise, it returns a reference to an array containing the year, month, and day values. The *cookbook_utils.py* file also contains `is_mmddyy_date()` and `is_ddmmyy_date()` routines that match dates in US or British format and return `None` or a reference to a list of date parts. (The parts returned are always in year, month, day order, not the order in which the parts appear in the input date string.)\n\nTo perform additional checking on the result returned by any of those routines (assuming that the result is not `None`), pass the date parts to `is_valid_date()`, another library function:\n\n```", "```\n\n`is_valid_date()` returns nonzero if the date is valid, 0 otherwise. It checks the parts of a date like this:\n\n```", "```\n\n`is_valid_date()` requires separate year, month, and day values, not a date string. This requires that you break candidate values into components before invoking it, but makes it applicable in more contexts. For example, you can use it to check dates like `12` `February` `2003` by mapping the month to its numeric value before calling `is_valid_date()`. If `is_valid_date()` took a string argument assumed to be in a specific date format, it would be much less general.\n\n`is_valid_date()` uses a subsidiary function `days_in_month()` to determine the number of days in the month represented by the date. `days_in_month()` requires both the year and the month as arguments because if the month is 2 (February), the number of days depends on whether the year is a leap year. This means you *must* pass a four-digit year value, two-digit years are ambiguous with respect to the century, which makes proper leap-year testing impossible. The `days_in_month()` and `is_leap_year()` functions are based on techniques taken from that recipe:\n\n```", "```\n\nTo perform validity checking on time values, a similar procedure applies: verify that the value matches a time pattern and break it into components, then perform range-testing on the components. For times, the ranges are 0 to 23 for the hour, and 0 to 59 for the minute and second. Here is a function `is_24hr_time()` that checks for values in 24-hour format and returns the components:\n\n```", "```\n\nThe following `is_ampm_time()` function is similar but looks for times in 12-hour format with an optional AM or PM suffix, converting PM times to 24-hour values:\n\n```", "```\n\nBoth functions return `None` for values that don’t match the pattern. Otherwise, they return a reference to a three-element array containing the hour, minute, and second values.\n\nAfter you obtain the time components, pass them to `is_valid_time()`, another utility routine, to perform range checks.\n\n# 14.15 Writing Date-Processing Utilities\n\n## Problem\n\nThere is a date-processing operation that you want to perform frequently.\n\n## Solution\n\nWrite a utility that performs the date-processing operation for you.\n\n## Discussion\n\nDue to the idiosyncratic nature of dates, you might occasionally find it necessary to write date converters. This section shows some sample converters that serve various purposes:\n\n*   *isoize_date.py* reads a file looking for dates in US format (*`MM-DD-YY`*) and converts them to ISO format.\n\n*   *cvt_date.py* converts dates to and from any of ISO, US, or British formats. It is more general than *isoize_date.py*, but requires that you tell it what kind of input to expect and what kind of output to produce.\n\n*   *monddyyyy_to_iso.py* looks for dates like `Feb.` `6`, `1788` and converts them to ISO format. It illustrates how to map dates with nonnumeric parts to a format that MySQL understands.\n\nAll three scripts are located in the *transfer* directory of the `recipes` distribution. They assume datafiles are in tab-delimited, linefeed-terminated format. To work with files that have a different format, use *cvt_file.pl*, available in the recipes distribution.\n\nOur first date-processing utility, *isoize_date.py*, looks for dates in US format and rewrites them into ISO format. You’ll recognize that it’s modeled after the general input-processing loop, with some extra stuff thrown in to perform a specific type of conversion:\n\n```", "```\n\nIf you feed *isoize_date.py* an input file that looks like this:\n\n```", "```\n\nIt produces the following output:\n\n```", "```\n\n*isoize_date.py* serves a specific purpose: it converts only from US to ISO format. It does not perform validity checking on date subparts or permit the transition point for adding the century to be specified. A more general tool would be more useful. The next script, *cvt_date.py*, extends the capabilities of *isoize_date.py*; it recognizes input dates in ISO, US, or British formats and converts any of them to any other. It also can convert two-digit years to four digits, enable you to specify the conversion transition point, and warn about bad dates. As such, it can be used to preprocess input for loading into MySQL or postprocess data exported from MySQL for use by other programs.\n\n*cvt_date.py* understands the following options:\n\n`--iformat``=`*`format`*, `--oformat``=`*`format`*, `--format``=`*`format`*\n\nSet the date format for input, output, or both. The default *`format`* value is `iso`; *cvt_date.py* also recognizes any string beginning with `us` or `br` as indicating US or British date format.\n\n`--add-century`\n\nConvert two-digit years to four digits.\n\n`--columns``=`*`column_list`*\n\nConvert dates only in the named columns. By default, *cvt_date.py* looks for dates in all columns. If this option is given, *`column_list`* should be a list of one or more column positions or ranges separated by commas. (Ranges can be given as *`m-n`* to specify columns *`m`* through *`n`*.) Positions begin at 1.\n\n`--transition``=`*`n`*\n\nSpecify the transition point for two-digit to four-digit year conversions. The default transition point is 70\\. This option turns on `--add-century`.\n\n`--warn`\n\nWarn about bad dates. (This option can produce spurious warnings if the dates have two-digit years and you don’t specify `--add-century`, because leap-year testing won’t always be accurate in that case.)\n\nWe won’t show the code for *cvt_date.py* here (most of it is taken up with processing command-line options), but you can examine the source for yourself if you like. As an example of how *cvt_date.py* works, suppose that you have a file *newdata.txt* with the following contents:\n\n```", "```\n\nRunning the file through *cvt_date.py* with options indicating that the dates are in US format and that the century should be added produces this result:\n\n```", "```\n\nTo produce dates in British format instead with no year conversion, do this:\n\n```", "```\n\n*cvt_date.py* has no knowledge of the meaning of each data column, of course. If you have a nondate column with values that match the pattern, it rewrites that column, too. To deal with that, specify a `--columns` option to limit the columns that *cvt_date.py* converts.\n\n*isoize_date.py* and *cvt_date.py* both operate on dates written in all-numeric formats. But dates in datafiles often are written differently, and it may be necessary to write a special-purpose script to process them. Suppose an input file contains dates in the following format (these represent the dates on which US states were admitted to the Union):\n\n```", "```\n\nThe dates consist of a three-character month abbreviation (possibly followed by a period), a numeric day of the month, a comma, and a numeric year. To import this file into MySQL, you must convert the dates to ISO format, resulting in a file that looks like this:\n\n```", "```\n\nThat’s a somewhat specialized kind of transformation, although this general type of problem (converting a particular date format to ISO format) is hardly uncommon. To perform the conversion, identify the dates as those values matching an appropriate pattern, map month names to the corresponding numeric values, and reformat the result. The following script, *monddyyyy_to_iso.py*, illustrates how:\n\n```", "```\n\nThe script only does reformatting, it doesn’t validate the dates. To do that, modify the script to use the *cookbook_utils.py* module by adding this statement in the beginning of the script:\n\n```", "```\n\nThat gives the script access to the module’s `is_valid_date()` routine. To use it, change this line:\n\n```", "```\n\nTo this:\n\n```", "```\n\n# 14.16 Importing Non-ISO Date Values\n\n## Problem\n\nYou want to import date values, but they are not in the ISO (*`YYYY-MM-DD`*) format that MySQL expects.\n\n## Solution\n\nUse an external utility to convert the dates to ISO format before importing the data into MySQL (*cvt_date.py* is useful here). Or use `LOAD` `DATA`’s capability for preprocessing input data prior to loading it into the database.\n\n## Discussion\n\nSuppose that a table contains three columns, `name`, `date`, and `value`, where `date` is a `DATE` column requiring values in ISO format (*`YYYY-MM-DD`*). Suppose also that you’re given a datafile *newdata.txt* to be imported into the table, but its contents look like this:\n\n```", "```\n\nThe dates are in *`MM/DD/YY`* format and must be converted to ISO format to be stored as `DATE` values in MySQL. One way to do this is to run the file through the *cvt_date.py* script from [Recipe 14.15](#nch-format-format-date-utils):\n\n```", "```\n\nThen load the *tmp.txt* file into the table. This task also can be accomplished entirely in MySQL with no external utilities by using SQL to perform the reformatting operation. As discussed in [Recipe 13.1](ch13.xhtml#nch-xfer-xfer-load-data), `LOAD` `DATA` can preprocess input values before inserting them. Applying that capability to the present problem, the date-rewriting `LOAD` `DATA` statement looks like this, using the `STR_TO_DATE()` function (see [Recipe 8.3](ch08.xhtml#nch-dates-dates-format)) to interpret the input dates:\n\n```", "```\n\nWith the `%y` format specifier in `STR_TO_DATE()`, MySQL converts the two-digit years to four-digit years automatically, so the original *`MM/DD/YY`* values end up as ISO values in *`YYYY-MM-DD`* format. The resulting data after import looks like this:\n\n```", "```\n\nThis procedure assumes that MySQL’s automatic conversion of two-digit years to four digits produces the correct century values. This means that the year part of the values must correspond to years in the range from 1970 to 2069\\. If that’s not true, you must convert the year values some other way. (For some ideas on how to do this, see [Recipe 14.14](#nch-format-format-date-part).)\n\nIf the dates are not in a format that `STR_TO_DATE()` can interpret, perhaps you can write a stored function to handle them and return ISO date values. In that case, the `LOAD` `DATA` statement looks like this, where `my_date_interp()` is your stored function name:\n\n```", "```\n\n# 14.17 Exporting Dates Using Non-ISO Formats\n\n## Problem\n\nYou want to export date values using a format other than MySQL’s default ISO (*`YYYY-MM-DD`*) format. This might be a requirement when exporting dates from MySQL to applications that don’t use ISO format.\n\n## Solution\n\nUse an external utility to rewrite the dates to non-ISO format after exporting the data from MySQL (*cvt_date.py* is useful here). Or use the `DATE_FORMAT()` function to rewrite the values during the export operation.\n\n## Discussion\n\nSuppose that you want to export data from MySQL into an application that doesn’t understand ISO-format dates. One way to do this is to export the data into a file, leaving the dates in ISO format. Then run the file through a utility such as *cvt_date.py* that rewrites the dates into the required format (see [Recipe 14.15](#nch-format-format-date-utils)).\n\nAnother approach is to export the dates directly in the required format by rewriting them with `DATE_FORMAT()`. Suppose that you have the following table:\n\n```", "```\n\nSuppose also that you need to export data from this table, but with the dates in any `DATE`, `DATETIME`, or `TIMESTAMP` columns rewritten in US format (*`MM-DD-YYYY`*). A `SELECT` statement that uses the `DATE_FORMAT()` function to rewrite the dates as required looks like this:\n\n```", "```\n\nIf `datetbl` contains the following rows:\n\n```", "```\n\nThe statement generates output that looks like this:\n\n```", "```\n\n# 14.18 Pre-processing and Importing a File\n\n## Problem\n\nRecall the scenario presented at the beginning of [Chapter 13](ch13.xhtml#nch-xfer):\n\nSuppose that a file named *somedata.csv* contains 12 data columns in comma-separated values (CSV) format. From this file you want to extract only columns 2, 11, 5, and 9, and use them to create database rows in a MySQL table that contains <q>name</q>, <q>birth</q>, <q>height</q>, and <q>weight</q> columns. You must make sure that the height and weight are positive integers, and convert the birth dates from *`MM/DD/YY`* format to *`YYYY-MM-DD`* format.\n\n## Solution\n\nCombine techniques that we discussed in [Chapter 13](ch13.xhtml#nch-xfer) and this chapter.\n\n## Discussion\n\nMuch of the work can be done using the utility programs developed in this chapter. Convert the file to tab-delimited format with *cvt_file.pl*, extract the columns in the desired order with *yank_col.pl*, and rewrite the date column to ISO format with *cvt_date.py* (see [Recipe 14.15](#nch-format-format-date-utils)):\n\n```", "```\n\nThe resulting file, *tmp*, has four columns representing the `name`, `birth`, `height`, and `weight` values, in that order. It needs only to have its height and weight columns checked to make sure they contain positive integers. Using the `is_positive_integer()` library function from the *cookbook_utils.py* module file, that task can be achieved using a short special-purpose script that is little more than an input loop:\n\n```", "```\n\nThe *validate_htwt.py* script produces no output (except for warning messages) because it need not reformat any of the input values. If *tmp* passes validation with no errors, it can be loaded into MySQL with a simple `LOAD` `DATA` statement:\n\n```"]