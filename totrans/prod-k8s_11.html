<html><head></head><body><section data-pdf-bookmark="Chapter 10. Identity" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter10">&#13;
<h1><span class="label">Chapter 10. </span>Identity</h1>&#13;
&#13;
&#13;
<p>Establishing the identity of both users and application workloads is a key concern when designing and implementing a Kubernetes platform.<a data-primary="identity" data-type="indexterm" id="ix_ID"/> No one wants to be in the news for having their systems breached. So it’s vital that we ensure that only the appropriately privileged entities (human or application) can access particular systems or take certain actions. For this we need to ensure that there are both Authentication and Authorization systems implemented. As a refresher:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Authentication</em> is the process of establishing the identity of an application or user.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Authorization</em> is the process of determining what actions an application or user are able to do, after they have been authenticated.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This chapter is solely focused on authentication.<a data-primary="authentication" data-seealso="identity" data-type="indexterm" id="idm45611981597960"/><a data-primary="authorization" data-type="indexterm" id="idm45611981597112"/> That’s not to say that authorization is not important, and we will touch on it briefly where appropriate.<a data-primary="RBAC (role-based access control)" data-type="indexterm" id="idm45611981596248"/> For more information you should definitely research Role Based Access Control (RBAC) in Kubernetes (there are many great resources available) and ensure that you have a solid strategy for implementing it for your own applications, so that you understand the permissions that are required by any external applications that you might deploy.<a data-primary="role-based access control" data-see="RBAC" data-type="indexterm" id="idm45611981595160"/></p>&#13;
&#13;
<p>Establishing identity for the purposes of authentication is a key requirement of almost every distributed system.<a data-primary="identity" data-secondary="establishing for authentication" data-type="indexterm" id="idm45611981593800"/> A simple example of this that everyone has used is a username and password. Together, the information identifies you as a user of the system. In this context then, <em>identity</em> needs to have a couple of properties:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It needs to be verifiable. If a user enters their username and password, we need to be able to go to a database or source of truth and compare the values to make sure they’re correct. In the case of a TLS certificate that might be presented, we need to be able to verify that certificate against a trusted issuing Certificate Authority (CA).</p>&#13;
</li>&#13;
<li>&#13;
<p>It needs to be unique. If an identity provided to us is not unique, we cannot specifically identify the bearer. However, we need to maintain uniqueness only <em>within our desired scope</em>—for example, a username or email address.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Establishing identity is also a crucial precursor to handling authorization concerns.<a data-primary="authorization" data-secondary="establishing identity before" data-type="indexterm" id="idm45611981589048"/> Before we can determine what scope of resource access should be granted, we need to uniquely identify the entity that is authenticating to the system.</p>&#13;
&#13;
<p>Kubernetes clusters commonly serve multiple tenants where many users and teams are deploying and operating multiple applications in a single cluster. Solving for tenancy in Kubernetes presents challenges (many covered in this book), of which one is identity. Given the matrix of privileges and resources that must be considered, we must solve for many deployment and configuration scenarios. Development teams should have access to their applications. Operations teams should have access to all applications and might need access to platform services. Application-to-application communication should be limited among applications. Then the list goes on. What about shared services? Security teams? Deployment tooling?</p>&#13;
&#13;
<p>These are all common concerns and add significant complexity to cluster configuration and maintenance. Remember, we have to keep these privileges updated somehow as well. These things are easy to get wrong. But the good news is that Kubernetes has capabilities that allow us to integrate with external systems and to model identity and access controls in a secure fashion.</p>&#13;
&#13;
<p>In this chapter we’ll begin by discussing <em>user</em> identity and the different methods for authenticating users to Kubernetes. We’ll then move on to options and patterns for establishing <em>application</em> identity within a Kubernetes cluster.<a data-primary="API server" data-secondary="authentication to" data-type="indexterm" id="idm45611981584712"/> We’ll see how to authenticate applications to the Kubernetes API server (for writing tools that interact directly with Kubernetes, such as operators). We’ll also cover how to establish unique application identities to enable those applications to authenticate to each other within the cluster, in addition to authenticating to <em>external</em> services like AWS.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="User Identity" data-type="sect1"><div class="sect1" id="user_identity">&#13;
<h1>User Identity</h1>&#13;
&#13;
<p>In this section we’ll cover the methods and patterns for implementing a robust system of <em>user</em> identity across your Kubernetes cluster(s).<a data-primary="identity" data-secondary="user" data-type="indexterm" id="ix_IDusr"/><a data-primary="user identity" data-type="indexterm" id="ix_usrID"/> In this context we’re defining a user as a human who will be interacting with the cluster directly (either through the Kubectl CLI or the API). The properties of identity (described in the previous section) are common to user and application identity, but some of the methods will differ. For example, we always want our identities to be verifiable and unique; however, these properties will be achieved in different ways for a user utilizing OpenID Connect (OIDC) versus an application using service account tokens.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authentication Methods" data-type="sect2"><div class="sect2" id="idm45611981578104">&#13;
<h2>Authentication Methods</h2>&#13;
&#13;
<p>There are a number of different authentication methods available to Kubernetes operators, and each have their own strengths and weaknesses.<a data-primary="identity" data-secondary="user" data-tertiary="authentication methods" data-type="indexterm" id="ix_IDusrau"/><a data-primary="user identity" data-secondary="authentication methods" data-type="indexterm" id="ix_usrIDau"/><a data-primary="authentication" data-secondary="methods of" data-type="indexterm" id="ix_authmth"/> In keeping with the core theme of this book, it’s essential to understand your specific use cases, evaluate what’s going to work for you, integrate with your systems, provide the user experience (UX), and deliver the security posture that your organization requires.</p>&#13;
&#13;
<p>In this section we’ll cover each method of establishing <em>user</em> identity and their trade-offs while describing some commonly used patterns we’ve implemented in the field. Some of the methods described here are platform-specific and tied to functionality available in certain cloud vendors, while others are platform-agnostic. How well a system integrates into your existing technology landscape is definitely going to be a factor in determining whether to adopt it. The trade-off is between extra functionality available in new tooling versus the ease-of-maintenance of integrations with the incumbent stack.</p>&#13;
&#13;
<p>In addition to providing identity, some of the methods described may also provide encryption. For example, the flow described for the public key infrastructure (PKI) method provides certificates that could be used in Mutual Transport Layer Security (mTLS) communication. However, encryption is not the focus of this chapter and is an incidental benefit from those methods of identity grants.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shared secrets" data-type="sect3"><div class="sect3" id="idm45611981570408">&#13;
<h3>Shared secrets</h3>&#13;
&#13;
<p>A shared secret is a unique piece (or set) of information that is held by the calling entity and the server.<a data-primary="secrets" data-secondary="shared" data-type="indexterm" id="idm45611981568904"/><a data-primary="user identity" data-secondary="authentication methods" data-tertiary="shared secrets" data-type="indexterm" id="idm45611981568056"/><a data-primary="authentication" data-secondary="methods of" data-tertiary="shared secrets" data-type="indexterm" id="idm45611981566968"/> For example, when an application needs to connect to a MySQL database, it can use a username and password combination to authenticate. This method necessitates that both parties have access to that combination in some form. You must create an entry in MySQL with that information, and then distribute the secret to any calling application that may need it. <a data-type="xref" href="#shared_secrets_flow">Figure 10-1</a> shows this pattern, with the backend application storing valid credentials that need to be presented by the frontend to gain access.</p>&#13;
&#13;
<figure><div class="figure" id="shared_secrets_flow">&#13;
<img alt="prku 1001" src="assets/prku_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>Shared secrets flow.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Kubernetes provides two options that allow you to utilize a shared secret model to authenticate to the API server. <a data-primary="API server" data-secondary="authentication to" data-tertiary="using shared secrets" data-type="indexterm" id="idm45611981562248"/>In the first method you can give the API server a list of comma-separated values (CSV) mapping usernames (and optionally, groups) to static tokens.<a data-primary="tokens" data-secondary="for users and groups" data-type="indexterm" id="idm45611981560872"/> When you want to authenticate to the API server, you can provide the token as a Bearer token within the HTTP Authorization header.<a data-primary="HTTP Authorization header, Bearer token in" data-type="indexterm" id="idm45611981559752"/><a data-primary="Bearer tokens" data-type="indexterm" id="idm45611981559144"/> Kubernetes will treat the request as coming from the mapped user and act accordingly.</p>&#13;
&#13;
<p>The other method is to supply the API server with a CSV of username (and optionally, groups) and password mappings.<a data-primary="username/password combinations" data-type="indexterm" id="idm45611981557896"/><a data-primary="HTTP Basic Authorization header" data-type="indexterm" id="idm45611981557288"/> With this method configured, users can supply the credentials base64-encoded in the HTTP Basic Authorization header.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Kubernetes has no resource or object called User or Group. These are just predefined names for the purposes of identification within RBAC RoleBindings.<a data-primary="RoleBindings" data-type="indexterm" id="idm45611981555384"/><a data-primary="RBAC (role-based access control)" data-secondary="RoleBindings" data-type="indexterm" id="idm45611981554776"/> The user can be mapped from a static file to token or password (as described previously), can be pulled from the CN of an x509 cert, or can be read as a field from an OAuth request, etc. The method of determining the user and group is entirely dependent on the authentication method in use, and Kubernetes has no way to define or manage them internally. In our opinion this pattern is a strength of the API because it allows us to plug in a variety of different implementations and delegate those concerns to systems specifically designed to handle them.</p>&#13;
</div>&#13;
&#13;
<p>Both of these methods have serious weaknesses and are not recommended. Some of these weaknesses are due to the Kubernetes-specific implementation, and some are inherent to the shared secret model, which we’ll discuss shortly. In Kubernetes, the main issues are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Static token and/or password files must be stored (in plain text) somewhere accessible to the API server. This is less of a risk than it initially seems, because if someone was able to compromise an API server and gain access to that node you would have greater things to worry about than an unencrypted password file. However, Kubenetes installations are mostly automated, and all assets required for setup should be stored in a repository. This repository must be secured, audited, and updated. This opens another potential area for carelessness or bad practices to leak credentials.</p>&#13;
</li>&#13;
<li>&#13;
<p>Both the static tokens and the username/password combinations have no expiration date. If any credentials are compromised, the breach must be identified quickly and remediated by removing the relevant credentials and restarting the API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>Any modifications to these credential files require that the API server is restarted. In practice (and in isolation) this is fairly trivial. However, many organizations are rightly moving away from manual intervention into their running software and servers. Changing configurations is now mostly a rebuild and redeploy process versus simply SSH’ing into the machines (cattle over pets). Therefore, &#13;
<span class="keep-together">modifying</span> API server configurations and restarting the processes is likely a more involved action.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Outside of the Kubernetes-specific disadvantages just described, the shared secrets model suffers from another drawback. If I am an untrusted entity, how can I authenticate to a secret store <em>in the first place</em> to receive an appropriate identity? We’ll look more at this <em>secure introduction</em> problem and how to solve it in <a data-type="xref" href="#app_workload_security">“Application/Workload Identity”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Public key infrastructure" data-type="sect3"><div class="sect3" id="idm45611981544968">&#13;
<h3>Public key infrastructure</h3>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This section assumes you are already familiar with PKI concepts.</p>&#13;
</div>&#13;
&#13;
<p>The PKI model uses certificates and keys to uniquely identify and authenticate users to Kubernetes.<a data-primary="user identity" data-secondary="authentication methods" data-tertiary="public key infrastructure" data-type="indexterm" id="ix_usrIDauPKI"/><a data-primary="authentication" data-secondary="methods of" data-tertiary="public key infrastructure" data-type="indexterm" id="ix_authmthPKI"/><a data-primary="public key infrastructure (PKI)" data-type="indexterm" id="ix_PKI"/> Kubernetes makes extensive use of PKI to secure communications between all of the core components of the system. It’s possible to configure the Certificate Authorities (CA) and certificates in multiple ways, but we will demonstrate it using kubeadm, the method most commonly seen in the field (and the de facto installation method for upstream Kubernetes).<a data-primary="PKI" data-see="public key infrastructure" data-type="indexterm" id="idm45611981537336"/></p>&#13;
&#13;
<p>After installing a Kubernetes cluster, you typically get a kubeconfig file with the <code>kubernetes-admin</code> user details.<a data-primary="kubeconfig file" data-type="indexterm" id="idm45611981535624"/><a data-primary="kubernetes-admin user details" data-type="indexterm" id="idm45611981534888"/> This file is essentially the root key to the cluster. Usually, this kubeconfig file is called <em>admin.conf</em> and is similar to this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">clusters</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">cluster</code><code class="p">:</code>&#13;
    <code class="nt">certificate-authority-data</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code>&#13;
    <code class="nt">server</code><code class="p">:</code> <code class="l-Scalar-Plain">https://127.0.0.1:32770</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
<code class="nt">contexts</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">context</code><code class="p">:</code>&#13;
    <code class="nt">cluster</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
    <code class="nt">user</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
<code class="nt">current-context</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Config</code>&#13;
<code class="nt">preferences</code><code class="p">:</code> <code class="p-Indicator">{}</code>&#13;
<code class="nt">users</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
  <code class="nt">user</code><code class="p">:</code>&#13;
    <code class="nt">client-certificate-data</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code>&#13;
    <code class="nt">client-key-data</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code></pre>&#13;
&#13;
<p>To determine the user that this will authenticate us to the cluster with, we need to first base64 decode the <code>client-certificate-data</code> field and then display the <a data-primary="certificates" data-secondary="client-certificate-data" data-type="indexterm" id="idm45611981531432"/>contents using something like <code>openssl</code>:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">Certificate:&#13;
    Data:&#13;
        Version: 3 (0x2)&#13;
        Serial Number: 2587742639643938140 (0x23e98238661bcd5c)&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
        Issuer: CN=kubernetes&#13;
        Validity&#13;
            Not Before: Jul 25 19:48:42 2020 GMT&#13;
            Not After : Jul 25 19:48:44 2021 GMT&#13;
        Subject: O=system:masters, CN=kubernetes-admin&#13;
        Subject Public Key Info:&#13;
            Public Key Algorithm: rsaEncryption&#13;
                Public-Key: (2048 bit)&#13;
                Modulus:&#13;
                    &lt;.. SNIP ...&gt;&#13;
                Exponent: 65537 (0x10001)&#13;
        X509v3 extensions:&#13;
            X509v3 Key Usage: critical&#13;
                Digital Signature, Key Encipherment&#13;
            X509v3 Extended Key Usage:&#13;
                TLS Web Client Authentication&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
         &lt;.. SNIP ...&gt;</pre>&#13;
&#13;
<p>We see from the certificate that it was issued by the Kubernetes CA, and identifies the User as <code>kubernetes-admin</code> (the subject <code>CN</code> field) in the <code>system:masters</code> group.<a data-primary="x509 certificates" data-type="indexterm" id="idm45611981471560"/> When using x509 certificates, any Organizations (O=) present are treated by Kubernetes as groups that the user should be considered part of. We will discuss some advanced methods around user and group configuration and permissions later in this chapter.</p>&#13;
&#13;
<p>In the preceding example we saw the default configuration for the <code>kubernetes-admin</code> user, a reserved default name that enables cluster-wide administrative privileges. It would also be useful to see how to configure the provisioning of certificates to identify other regular system users who can then be given appropriate permissions using the RBAC system. Provisioning and maintaining a large set of certificate artifacts is an arduous task, but one that Kubernetes can help us with by using some built-in resources.</p>&#13;
&#13;
<p>In order for the CSR flow described next to function correctly, the controller-manager needs to be configured with the <code>--cluster-signing-cert-file</code> and <code>--cluster-signing-key-file</code> parameters as shown here:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">containers</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">command</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">kube-controller-manager</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--cluster-signing-key-file=/etc/kubernetes/pki/ca.key</code>&#13;
    <code class="c1"># Additional flags removed for brevity</code>&#13;
    <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">k8s.gcr.io/kube-controller-manager:v1.17.3</code></pre>&#13;
&#13;
<p>Any entity with appropriate RBAC permissions can submit a Certificate Signing Request object to the Kubernetes API.<a data-primary="certificates" data-secondary="Certificate Signing Requests" data-type="indexterm" id="ix_crtCSR"/><a data-primary="CSRs (Certificate Signing Requests)" data-type="indexterm" id="ix_CSRs"/> If a user should be able to <em>self submit</em>, this means we need to provide a mechanism for the user to submit those requests. One way of doing this is to explicitly configure permissions to allow the <code>system:anonymous</code> User and / or <code>system:unauthenticated</code> group to submit and retrieve CSRs.</p>&#13;
&#13;
<p>Without this, any unauthenticated user would by definition be unable to initiate the process that would allow them to become authenticated. We should definitely be wary of this approach, though, as we never want to give unauthenticated users any access to the Kubernetes API server. A common way of providing self-service for CSRs is therefore to provide a thin abstraction or portal on top of Kubernetes that will run with the appropriate permissions. Users can log in to the portal using some other credentials (usually SSO) and initiate this CSR flow (as shown in <a data-type="xref" href="#csr_flow">Figure 10-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="csr_flow">&#13;
<img alt="prku 1002" src="assets/prku_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>CSR flow.</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this flow the user could generate a private key locally and then submit this through the portal. Or, the portal could generate private keys for each user and return them with the approved certificate to the user. Generation can be done using <code>openssl</code> or any number of other tools/libraries. The CSR should contain the metadata the user wants encoded into their x509 certificate, including their user name and any additional groups they should be part of. The following example creates a certificate request that identifies the user as <em>john</em>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>openssl req -new -key john.key -out john.csr -subj <code class="s2">"/CN=john"</code>&#13;
<code class="nv">$ </code>openssl req -in john.csr -text&#13;
Certificate Request:&#13;
    Data:&#13;
        Version: <code class="m">0</code> <code class="o">(</code>0x0<code class="o">)</code>&#13;
        Subject: <code class="nv">CN</code><code class="o">=</code>john&#13;
        Subject Public Key Info:&#13;
            Public Key Algorithm: rsaEncryption&#13;
                Public-Key: <code class="o">(</code><code class="m">1024</code> bit<code class="o">)</code>&#13;
                Modulus:&#13;
                    &lt;.. SNIP ...&gt;&#13;
                Exponent: <code class="m">65537</code> <code class="o">(</code>0x10001<code class="o">)</code>&#13;
        Attributes:&#13;
            a0:00&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
         &lt;.. SNIP ...&gt;</pre>&#13;
&#13;
<p>After generating the CSR we can submit it to the cluster via our portal in a CertificateSigningRequest resource.<a data-primary="CertificateSigningRequest object" data-type="indexterm" id="idm45611981365976"/> Following is an example of the request as a YAML object, but our portal would likely programatically apply this via the Kubernetes API rather than constructing the YAML manually:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="l-Scalar-Plain">cat &lt;&lt;EOF | kubectl apply -f -</code>&#13;
<code class="l-Scalar-Plain">apiVersion</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">certificates.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CertificateSigningRequest</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">john</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">request</code><code class="p">:</code> <code class="l-Scalar-Plain">$(cat john.csr | base64 | tr -d '\n')</code>&#13;
  <code class="nt">usages</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">client auth</code>&#13;
<code class="l-Scalar-Plain">EOF</code></pre>&#13;
&#13;
<p>This creates a CSR object in Kubernetes with a <code>pending</code> state, awaiting approval. This CSR object contains the (base64-encoded) signing request and the username of the requestor. If using a Service Account token to authenticate to the Kubernetes API (as a Pod would in an automated flow), then the username will be the Service Account name. In the following example, I was authenticated to the Kubernetes API as the <code>kubernetes-admin</code> user and it appears in the Requestor field. If using a portal we’d see the Service Account assigned to that portal component.</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get csr&#13;
NAME     AGE   REQUESTOR            CONDITION&#13;
my-app   17h   kubernetes-admin     Pending</pre>&#13;
&#13;
<p>While the request is pending, the user has not been granted any certificate. The next stage involves a cluster administrator (or a user with appropriate permissions) approving the CSR. This may also be automated if the user’s identity can be programatically determined. Approval will issue a certificate back to the user that can be used to assert identity on that Kubernetes cluster. For this reason, it’s important to perform verification that the submitter of the request <em>is</em> who they claim to be. This could be achieved by adding some additional identifying metadata to the CSR and having an automated process validate the information against the claimed identity, or by having an out-of-band process to verify the user’s identity.</p>&#13;
&#13;
<p>Once the CSR has been approved, the certificate (in the <code>status</code> field of the CSR) can be retrieved and used (in conjunction with their private key) for TLS communications with the Kubernetes API. In our portal implementation, the CSR would be pulled by the portal system and made available for the requesting user once they log back in and recheck the portal:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">certificates.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CertificateSigningRequest</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">my-app</code>&#13;
<code class="c1"># Additional fields removed for brevity</code>&#13;
<code class="nt">status</code><code class="p">:</code>&#13;
  <code class="nt">certificate</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code>&#13;
  <code class="nt">conditions</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">lastUpdateTime</code><code class="p">:</code> <code class="s">"2020-03-04T15:45:30Z"</code>&#13;
    <code class="nt">message</code><code class="p">:</code> <code class="l-Scalar-Plain">This CSR was approved by kubectl certificate approve.</code>&#13;
    <code class="nt">reason</code><code class="p">:</code> <code class="l-Scalar-Plain">KubectlApprove</code>&#13;
    <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Approved</code></pre>&#13;
&#13;
<p>When decoding<a data-primary="CSRs (Certificate Signing Requests)" data-startref="ix_CSRs" data-type="indexterm" id="idm45611981286472"/><a data-primary="certificates" data-secondary="Certificate Signing Requests" data-startref="ix_crtCSR" data-type="indexterm" id="idm45611981200296"/><a data-primary="certificates" data-secondary="provisioned through Kubernetes CSR flow" data-type="indexterm" id="idm45611981199128"/> the certificate we can see that it contains the relevant identity information (<em>john</em>) in the CN field:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">Certificate:&#13;
    Data:&#13;
        Version: 3 (0x2)&#13;
        Serial Number:&#13;
            66:82:3f:cc:10:3f:aa:b1:df:5b:c5:42:cf:cb:5b:44:e1:45:49:7f&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
        Issuer: CN=kubernetes&#13;
        Validity&#13;
            Not Before: Mar  4 15:41:00 2020 GMT&#13;
            Not After : Mar  4 15:41:00 2021 GMT&#13;
        Subject: CN=john&#13;
        Subject Public Key Info:&#13;
            Public Key Algorithm: rsaEncryption&#13;
                Public-Key: (2048 bit)&#13;
                Modulus:&#13;
                    &lt;.. SNIP ...&gt;&#13;
                Exponent: 65537 (0x10001)&#13;
        X509v3 extensions:&#13;
            X509v3 Extended Key Usage:&#13;
                TLS Web Client Authentication&#13;
            X509v3 Basic Constraints: critical&#13;
                CA:FALSE&#13;
            X509v3 Subject Key Identifier:&#13;
                EE:8E:E5:CC:98:41:78:4A:AE:32:75:52:1C:DC:DD:D0:9B:95:E0:81&#13;
    Signature Algorithm: sha256WithRSAEncryption&#13;
         &lt;.. SNIP ...&gt;</pre>&#13;
&#13;
<p>Finally, we can craft a kubeconfig containing our private key and the approved certificate that will allow us to communicate with the Kubernetes API server as the <em>john</em> user.<a data-primary="kubeconfig file" data-type="indexterm" id="idm45611981196648"/> The certificate we get back from the preceding CSR process goes into the <code>client-certificate-data</code> field shown here in the kubeconfig:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">clusters</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">cluster</code><code class="p">:</code>&#13;
    <code class="nt">certificate-authority-data</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code>&#13;
    <code class="nt">server</code><code class="p">:</code> <code class="l-Scalar-Plain">https://127.0.0.1:32770</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
<code class="nt">contexts</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">context</code><code class="p">:</code>&#13;
    <code class="nt">cluster</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
    <code class="nt">user</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
<code class="nt">current-context</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Config</code>&#13;
<code class="nt">preferences</code><code class="p">:</code> <code class="p-Indicator">{}</code>&#13;
<code class="nt">users</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">kind-kind</code>&#13;
  <code class="nt">user</code><code class="p">:</code>&#13;
    <code class="nt">client-certificate-data</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code>&#13;
    <code class="nt">client-key-data</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code></pre>&#13;
&#13;
<p>We have seen implementations of this model in the field whereby an automated system provisions certificates based on some verifiable SSO credentials or other authentication method.<a data-primary="x509 certificates" data-type="indexterm" id="idm45611981190360"/><a data-primary="certificates" data-secondary="x509, issues with" data-type="indexterm" id="idm45611981189752"/> When automated, these systems can be successful, but we do not recommend them. Relying on x509 certificates as a primary authentication method for users of Kubernetes introduces a number of issues:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Certificates provisioned through the Kubernetes CSR flow cannot be revoked prior to their expiry. There is currently no support for certificate revocation lists of Online Certificate Status Protocol (OSCP) stapling in Kubernetes.</p>&#13;
</li>&#13;
<li>&#13;
<p>Additional PKI needs to be provisioned, supported, and maintained, in addition to creating and maintaining a component responsible for provisioning certificates based on external authentication.</p>&#13;
</li>&#13;
<li>&#13;
<p>x509 certificates have expiry timestamps, and these should be kept relatively short to reduce the risk should a pair (key/cert) be compromised. This short life span means that there is a high churn in certificates, and these must be distributed out to users regularly to ensure that consistent access to the cluster is maintained.</p>&#13;
</li>&#13;
<li>&#13;
<p>There needs to be a way to verify the identity of anyone requesting a certificate. In an automated system, you can engineer ways of doing this via externally &#13;
<span class="keep-together">verifiable</span> metadata. In the absence of such metadata, out-of-band verification is often too time-consuming to be practical, especially given the short life span of certificates as noted previously.</p>&#13;
</li>&#13;
<li>&#13;
<p>Certificates are are localized to one cluster. In the field we see many (10s–100s) Kubernetes clusters across projects and groups. Requiring unique credentials for each cluster multiplies the complexity of storing and maintaining the relevant credentials. This leads to a degraded user experience.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>Remember that even when not using certificates as the primary authentication method, you should still keep the <em>admin.conf</em> kubeconfig somewhere secure. If for whatever reason other authentication methods become unavailable, this can act as an admin break-glass solution to access the cluster.<a data-primary="user identity" data-secondary="authentication methods" data-startref="ix_usrIDauPKI" data-tertiary="public key infrastructure" data-type="indexterm" id="idm45611981085928"/><a data-primary="authentication" data-secondary="methods of" data-startref="ix_authmthPKI" data-tertiary="public key infrastructure" data-type="indexterm" id="idm45611981084440"/><a data-primary="public key infrastructure (PKI)" data-startref="ix_PKI" data-type="indexterm" id="idm45611981082984"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="OpenID Connect (OIDC)" data-type="sect3"><div class="sect3" id="idm45611981544056">&#13;
<h3>OpenID Connect (OIDC)</h3>&#13;
&#13;
<p>In our opinion, the best choice when setting up user authentication and identity with Kubernetes is to integrate with an existing Single Sign-On system or provider.<a data-primary="user identity" data-secondary="authentication methods" data-tertiary="OpenID Connect" data-type="indexterm" id="idm45611981080360"/><a data-primary="OpenID Connect (OIDC)" data-type="indexterm" id="idm45611981079112"/><a data-primary="authentication" data-secondary="methods of" data-tertiary="OpenID Connect" data-type="indexterm" id="idm45611981078440"/> Almost every organization already has a solution such as Okta, Auth0, Google, or even internal LDAP/AD that provides a single place for users to authenticate and gain access to internal systems. For something like authentication (where security is a strong factor), outsourcing the complexity is a solid choice unless you have very specialized requirements.</p>&#13;
&#13;
<p>These systems have many advantages. They are built on well-understood and widely supported standards. They consolidate all management of user accounts and access to a single well-secured system, making maintenance and removal of accounts/access straightforward. Additionally, when using the common OIDC framework, they also allow users to access downstream applications without exposing credentials to those systems. Another advantage is that many Kubernetes clusters across multiple environments can leverage a single identity provider, reducing variance between cluster configurations.</p>&#13;
&#13;
<p>Kubernetes supports OIDC directly as an authentication mechanism (as shown in <a data-type="xref" href="#oidc_flow">Figure 10-3</a>). If your organization is using an identity provider that natively exposes the relevant OIDC endpoints, then configuring Kubernetes to take advantage of this is straightforward.</p>&#13;
&#13;
<figure><div class="figure" id="oidc_flow">&#13;
<img alt="prku 1003" src="assets/prku_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>OIDC flow. Reproduced from the <a href="https://oreil.ly/VZCz5">official Kubernetes documentation</a>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>However, there are several scenarios where some extra tooling may be required or desired to provide additional functionality or improve user experience. Firstly, if your organization has multiple identity providers it is necessary to utilize an OIDC aggregator. Kubernetes only supports defining a single identity provider in its configuration options, and an OIDC aggregator is capable of acting as a single intermediary to multiple other providers (either OIDC or other methods). We have used Dex (<a href="https://oreil.ly/_maX6">a sandbox project</a> within the Cloud Native Computing Foundation) with success many times before, although other popular options like Keycloak and UAA offer similiar functionality.</p>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>Remember that authentication is in the critical path to cluster access. Dex, Keycloak, and UAA are all configurable to variable degrees and you should optimize for availability and stability when implementing these solutions. These tools are additional maintenance burdens and must be configured, updated, and secured. In the field we always try to emphasize the need to understand and own any additional complexity that is introduced to your environment and clusters.</p>&#13;
</div>&#13;
&#13;
<p>While configuring the API server to utilize OIDC is straightforward, attention must be given to providing a seamless user experience for the users of the cluster. OIDC solutions will return a token identifying us (given a successful login); however, we require a properly formatted kubeconfig in order to access and perform operations on the cluster.<a data-primary="kubeconfig file" data-type="indexterm" id="idm45611981067432"/> When we hit this use case in the field early on, our colleagues developed a simple web UI called Gangway to automate the process of logging in through an OIDC provider and generating a conformant kubeconfig from the returned token (complete with relevant endpoints and certificates).</p>&#13;
&#13;
<p>Despite OIDC being our preferred method of authentication, it does not suit all cases, and secondary methods may be required. OIDC (as defined in the specification) requires users to log in directly through the web interface of the identity provider. This is for obvious reasons, to ensure the user is actually providing the credentials only to the trusted provider and not to the consuming application. This requirement can cause issues in the case where robot users require access to the system. This is common for automated tooling like CI/CD systems and others who are unable to respond to the web-based credential challenge.</p>&#13;
&#13;
<p>In these cases, we have seen a couple of different models/solutions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>In cases where robot users are tied to centrally managed accounts, it’s possible to implement a kubectl authentication plug-in that would log in to the external system and receive a token in response. Kubernetes can be configured to verify this token via the webhook token authenticator method. This method will likely require some custom coding to create the token generator/webhook server.</p>&#13;
</li>&#13;
<li>&#13;
<p>For other cases, we have seen users fall back to using a certificate-based auth for robot accounts that don’t need to be centrally managed.<a data-primary="certificates" data-secondary="authentication based on for robot accounts" data-type="indexterm" id="idm45611981062360"/> This of course means you need to manage certificate issuance and rotation, but it doesn’t require any custom components.</p>&#13;
</li>&#13;
<li>&#13;
<p>Another manual but effective alternative solution is to create a Service Account for the tool and utilize the token generated for API access.<a data-primary="Service Accounts" data-secondary="for robot users" data-type="indexterm" id="idm45611981059928"/> If the tool is running <em>in</em> cluster it can use the credential directly mounted into the Pod. If the tool is <em>outside</em> the cluster we can manually copy and paste the token into a secure location accessible by the tool and utilize that when making kubectl or API calls.<a data-primary="identity" data-secondary="user" data-startref="ix_IDusrau" data-tertiary="authentication methods" data-type="indexterm" id="idm45611981057864"/><a data-primary="user identity" data-secondary="authentication methods" data-startref="ix_usrIDau" data-type="indexterm" id="idm45611981056344"/><a data-primary="authentication" data-secondary="methods of" data-startref="ix_authmth" data-type="indexterm" id="idm45611981055128"/> Service Accounts are covered in more detail in <a data-type="xref" href="#service_account_tokens">“Service Account Tokens (SAT)”</a>.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Implementing Least Privilege Permissions for Users" data-type="sect2"><div class="sect2" id="idm45611981081640">&#13;
<h2>Implementing Least Privilege Permissions for Users</h2>&#13;
&#13;
<p>Now that we’ve seen the different ways it’s possible to implement identity and authentication, let’s turn to the related topic of authorization.<a data-primary="permissions and privileges" data-secondary="implementing least privilege permissions for users" data-type="indexterm" id="ix_permLPP"/><a data-primary="identity" data-secondary="user" data-tertiary="least privilege permissions for users" data-type="indexterm" id="ix_IDusrLPP"/><a data-primary="user identity" data-secondary="implementing least privilege permissions for users" data-type="indexterm" id="ix_usrIDLPP"/> It’s out of scope for this book to go deep into how you should be configuring RBAC across your clusters. This will likely vary significantly between applications, environments, and teams. However, we do want to describe a pattern we’ve implemented successfully in the field around the principle of least privilege when designing administrative access roles.</p>&#13;
&#13;
<p>Whether you have chosen to go with a cluster-per-team approach, or a multitenant cluster approach, you will likely have <em>super-admin</em> users on the operations team who are responsible for configuring, upgrading, and maintaining the environment. While individual teams should have restricted permissions based on the access they require, these admins will have full reign over the entire cluster and therefore greater potential to accidentally perform destructive actions.</p>&#13;
&#13;
<p>In an ideal world, all cluster access and operations would be performed by an automated process—GitOps or something similar, perhaps. However, practically speaking, we regularly see users individually accessing clusters and found the following pattern to be an effective way to limit potential issues. It is tempting to bind an administrator role to a particular operator’s username/identity directly, only for them to delete something important while mistakenly having loaded the wrong kubeconfig, for example. It should never happen until it does!</p>&#13;
&#13;
<p>Kubernetes <a data-primary="impersonation" data-type="indexterm" id="idm45611981015352"/>supports the concept of <em>impersonation</em>, and with this we can create an experience that behaves closely to <em>sudo</em> on Linux systems by restricting the default permissions of the user and requiring them to elevate permissions to perform sensitive commands. Practically speaking, we want to enable these users to view everything by default but deliberately elevate their privileges to be able to write. This model significantly reduces the chances of the preceding scenario occurring.</p>&#13;
&#13;
<p>Let’s work through<a data-primary="permissions and privileges" data-secondary="privilege elevation attacks" data-type="indexterm" id="idm45611981012984"/><a data-primary="privilege elevation attacks" data-type="indexterm" id="idm45611981011944"/> how you might implement the privilege elevation pattern just described. We’ll assume that our operations team’s user identities are all part of an <code>ops-team</code> group in Kubernetes. As mentioned earlier, Kubernetes has no defined concept of a group per se, so we mean that those users all have additional attributes in their Kubernetes identity (x509 cert, OIDC claim, etc.) that identify them as being part of the group.</p>&#13;
&#13;
<p>We create the ClusterRoleBinding that allows users in the <code>ops-team</code> group access <a data-primary="ClusterRoleBinding" data-type="indexterm" id="idm45611981009464"/>to the <code>view</code> built-in ClusterRole, which is what gives us our default read-only access:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cluster-admin-view</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">view</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Group</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ops-team</code></pre>&#13;
&#13;
<p>Now we create a ClusterRoleBinding to allow our <code>cluster-admin</code> user to have <code>cluster-admin</code> ClusterRole permissions on the cluster.<a data-primary="ClusterRole" data-type="indexterm" id="idm45611980969400"/> Remember, we’re not binding this ClusterRole directly to our <code>ops-team</code> group. No user can <em>directly</em> identify as the <code>cluster-admin</code> user; this will be a user that is <em>impersonated</em> and their permissions <em>assumed</em> by another authenticated user:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cluster-admin-crb</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cluster-admin</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">User</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cluster-admin</code></pre>&#13;
&#13;
<p>Finally, we create a ClusterRole called <code>cluster-admin-impersonator</code> that allows the impersonation of the <code>cluster-admin</code> user, and a ClusterRoleBinding that binds that capability to everyone in the <code>ops-team</code> group:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cluster-admin-impersonator</code>&#13;
<code class="nt">rules</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">resources</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"users"</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"impersonate"</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">resourceNames</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"cluster-admin"</code><code class="p-Indicator">]</code>&#13;
<code class="nn">---</code>&#13;
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cluster-admin-impersonate</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cluster-admin-impersonator</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Group</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ops-team</code></pre>&#13;
&#13;
<p>Now let’s use a kubeconfig for a user (john) in the <code>ops-team</code> group to see how the <a data-primary="kubeconfig file" data-type="indexterm" id="idm45611980893192"/>elevation of privileges works in practice:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get configmaps&#13;
No resources found.&#13;
&#13;
<code class="nv">$ </code>kubectl create configmap my-config --from-literal<code class="o">=</code><code class="nb">test</code><code class="o">=</code><code class="nb">test</code>&#13;
Error from server <code class="o">(</code>Forbidden<code class="o">)</code>: configmaps is forbidden: User <code class="s2">"john"</code>&#13;
cannot create resource <code class="s2">"configmaps"</code> in API group <code class="s2">""</code> in the namespace <code class="s2">"default"</code>&#13;
&#13;
<code class="nv">$ </code>kubectl --as<code class="o">=</code>cluster-admin create configmap my-config --from-literal<code class="o">=</code><code class="nb">test</code><code class="o">=</code><code class="nb">test</code>&#13;
configmap/my-config created</pre>&#13;
&#13;
<p>We used the preceding setup for admin users, although implementing something similiar for every user (having a <em>team-a</em> group, a <em>team-a</em> view role, and a <em>team-a</em> admin user) is a solid pattern that removes a lot of the potential for costly mistakes. Additionally, one of the great things about the impersonation approach just described is that all of this is played out in the Kubernetes audit logs, so we can see the original user log in, impersonate the cluster-admin, and then take action.<a data-primary="permissions and privileges" data-secondary="implementing least privilege permissions for users" data-startref="ix_permLPP" data-type="indexterm" id="idm45611980786968"/><a data-primary="identity" data-secondary="user" data-startref="ix_IDusrLPP" data-tertiary="least privilege permissions for users" data-type="indexterm" id="idm45611980785656"/><a data-primary="user identity" data-secondary="implementing least privilege permissions for users" data-startref="ix_usrIDLPP" data-type="indexterm" id="idm45611980784200"/><a data-primary="identity" data-secondary="user" data-startref="ix_IDusr" data-type="indexterm" id="idm45611980782952"/><a data-primary="user identity" data-startref="ix_usrID" data-type="indexterm" id="idm45611980781736"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Application/Workload Identity" data-type="sect1"><div class="sect1" id="app_workload_security">&#13;
<h1>Application/Workload Identity</h1>&#13;
&#13;
<p>In the previous section, we saw the main methods and patterns for establishing the identity of<a data-primary="identity" data-secondary="application/workload" data-type="indexterm" id="ix_IDAW"/><a data-primary="application/workload identity" data-type="indexterm" id="ix_appwk"/> human users of Kubernetes, and how they can authenticate to the cluster. In this section, we’re going to take at look how we can establish identity for our workloads that run in the cluster. There are three main use cases we’ll be examining:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Workloads identifying themselves to other workloads within the cluster, to potentially establish a mutual authentication between them for additional &#13;
<span class="keep-together">security</span>.<a data-primary="workloads" data-secondary="identity" data-seealso="application/workload identity" data-type="indexterm" id="idm45611980763976"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Workloads identifying themselves to obtain appropriate access to the Kubernetes API itself. This is a common use case for custom controllers that need to watch and act on Kubernetes resources.</p>&#13;
</li>&#13;
<li>&#13;
<p>Workloads identifying themselves and authenticating to external services. This could be anything outside of the cluster but will be primarily cloud vendor services running on AWS, GCP, etc.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In <a data-type="xref" href="#networking">“Network Identity”</a>, we’ll look at two of the most popular Container Networking Interface (CNI) tools (Calico and Cilium) and see how they can assign identity and restrict access, primarily for the first use case we just described.</p>&#13;
&#13;
<p>Secondly, we’ll move on to service account tokens (SAT) and projected service account tokens (PSAT).<a data-primary="Service Account tokens (SAT)" data-type="indexterm" id="idm45611980758312"/><a data-primary="Projected Service Account tokens (PSAT)" data-type="indexterm" id="idm45611980757592"/> These are flexible and important Kubernetes primitives that enable workload-to-workload identity (the first use case) in addition to being the primary mechanism for workloads identifying to the Kubernetes API itself (the second use case).</p>&#13;
&#13;
<p>Next we’ll cover options where an application’s identity is provided by the platform itself. The most common use case we see in the field is workloads that need access to AWS services, and we’ll look at the three main methods that are possible today.</p>&#13;
&#13;
<p>Lastly, we’ll extend the concept of platform-mediated identity to consider tooling that aims to provide a consistent model of identity across multiple platforms and environments. The flexibility of this approach can be used to cover all of the use cases we mentioned, and we’ll show how this can be a very powerful capability.</p>&#13;
&#13;
<p>Before implementing any of the patterns described in this section you should definitely evaluate your requirements as they relate to establishing workload-to-workload identity. Often, establishing this capability is an advanced-level activity, and the majority of organizations may not need to solve this topic, at least initially.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shared Secrets" data-type="sect2"><div class="sect2" id="idm45611980754200">&#13;
<h2>Shared Secrets</h2>&#13;
&#13;
<p>Most of the discussion around shared secrets for user identity also applies to application identity; however, there are some additional nuances and guidance based on field experience.<a data-primary="secrets" data-secondary="shared" data-type="indexterm" id="idm45611980752440"/><a data-primary="application/workload identity" data-secondary="shared secrets" data-type="indexterm" id="idm45611980751464"/><a data-primary="identity" data-secondary="application/workload" data-tertiary="shared secrets" data-type="indexterm" id="idm45611980750504"/></p>&#13;
&#13;
<p>Once we have secrets in place that are known by the client and the server, how do we safely rotate them upon expiry? Ideally we want these secrets to have a fixed life span to mitigate the potential damage caused if one were to be compromised. Additionally, because they are <em>shared</em>, they need to be redistributed to both the client application and the server.<a data-primary="Vault" data-secondary="enterprise secret store" data-type="indexterm" id="idm45611980748200"/> Hashicorp’s Vault is a prominent example of an enterprise secret store and features integrations with many tools that get close to the goal of solving this re-syncing problem. However, Vault also suffers from the secure introduction problem we first encountered in <a data-type="xref" href="#user_identity">“User Identity”</a>.</p>&#13;
&#13;
<p>This is the problem we have when trying to ensure that a shared secret is securely distributed to both the client and the serving entity <em>before</em> we have any model of identity and authentication established (the chicken and the egg). Any attempt to initially seed a secret between two entities could be compromised, breaking our guarantee of identity and unique authentication.</p>&#13;
&#13;
<p>Despite the flaws already discussed, shared secrets have one strong advantange in that it is a model that is well supported and understood by almost all users and applications. This makes it a strong choice for cross-platform operability. We will see how to solve the secure introduction problem for Vault and Kubernetes with more advanced methods of authentication later in this chapter. Once Vault is securely configured with those methods, it is a fine choice (and one we have implemented many times) as many of the issues with shared secrets are mitigated.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network Identity" data-type="sect2"><div class="sect2" id="networking">&#13;
<h2>Network Identity</h2>&#13;
&#13;
<p>Network primitives like IP addresses, VPNs, firewalls, etc., have historically been used as a form of identity for controlling which applications have access to what services.<a data-primary="application/workload identity" data-secondary="network identity" data-type="indexterm" id="ix_appwknet"/><a data-primary="networks" data-secondary="identity" data-type="indexterm" id="ix_netID"/><a data-primary="identity" data-secondary="application/workload" data-tertiary="network identity" data-type="indexterm" id="ix_IDAWni"/><a data-primary="cloud computing" data-secondary="application/workload and network identity" data-type="indexterm" id="idm45611980676072"/> However, in a cloud native ecosystem these methods are breaking down and paradigms are changing. In our experience it is important to educate teams across the organization (especially networking and security) on these changes and how practices can (and should) adapt to embrace and accommodate them. Too often this is met with resistance around concerns over security and/or control. In reality it’s possible to achieve almost any posture if required, and time should be taken to understand the <em>actual requirements</em> of the teams, rather than getting stuck in implementation details.</p>&#13;
&#13;
<p>In container-based environments, workloads share networking stacks and underlying machines. Workloads are increasingly ephemeral and move between nodes often. This results in a constant churn of IP addresses and network changes.</p>&#13;
&#13;
<p>In a multicloud and API-driven world, the network is no longer a primary boundary. Calls commonly occur to external services across multiple providers, each of which may need a way to prove identity of our calling applications.</p>&#13;
&#13;
<p>Existing traditional (platform level) network primitives (host IP addresses, firewalls, etc.) are no longer suitable for establishing workload identity and, if used at all, should be used only as an additional layer of defense in depth. This is not to say that network primitives <em>in general</em> are bad but that they must have additional workload context to be effective.<a data-primary="Container Networking Interface (CNI)" data-secondary="identity for clusters" data-type="indexterm" id="ix_CNIID"/> In this section we’ll look at how CNI options provide degrees of identity for Kubernetes clusters and how best to leverage them. CNI providers are able to contextualize requests and provide identity by combining network primitives and metadata retrieved from the Kubernetes API. We’ll take a brief look at some of the most popular CNI implementations and see what capabilities can they can &#13;
<span class="keep-together">provide</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Calico" data-type="sect3"><div class="sect3" id="idm45611980669048">&#13;
<h3>Calico</h3>&#13;
&#13;
<p><a href="https://www.projectcalico.org">Calico</a> provides network<a data-primary="Calico" data-secondary="identity, establishing" data-type="indexterm" id="idm45611980666936"/> policy enforcement at layers 3 (Network) and 4 (Transport) of the OSI Model, enabling users to restrict communication between Pods based on their Namespace, labels, and other metadata. This enforcement is all enabled by modifying the network configuration <code>iptables</code>/<code>ipvs</code>) to allow/disallow IP addresses.</p>&#13;
&#13;
<p>Calico also supports making policy decisions based on Service Accounts using a component <a data-primary="Service Accounts" data-secondary="Calico's network policy enforcement based on" data-type="indexterm" id="idm45611980664168"/><a data-primary="Dikastes" data-type="indexterm" id="idm45611980663160"/><a data-primary="Envoy proxy" data-type="indexterm" id="idm45611980662488"/><a data-primary="Istio" data-secondary="network policy enforcement" data-type="indexterm" id="idm45611980661816"/>called Dikastes when used in combination with <a href="https://www.envoyproxy.io">Envoy proxy</a> (either standalone Envoy or deployed as part of a service mesh like <a href="https://istio.io">Istio</a>). This approach enables enforcement at layer 7 (Application), based on attributes of the application protocol (headers, etc.) and relevant cryptographic identities (certificates, etc.).</p>&#13;
&#13;
<p>By default, Istio (Envoy) will only perform mTLS and ensure that workloads present certificates signed by the Istio CA (Citadel).<a data-primary="certificates" data-secondary="workload, required by Istio and Envoy" data-type="indexterm" id="idm45611980658552"/> Dikastes runs as a sidecar alongside Envoy as a plug-in, as we can see in the architecture diagram in <a data-type="xref" href="#oidc_flow">Figure 10-3</a>. Envoy verifies the CA before consulting Dikastes for a decision on whether to admit or reject the request.<a data-primary="GlobalNetworkPolicy" data-type="indexterm" id="idm45611980656680"/><a data-primary="NetworkPolicy objects" data-type="indexterm" id="idm45611980656072"/> Dikastes makes this decision based on user-defined Calico NetworkPolicy or GlobalNetworkPolicy objects:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">GlobalNetworkPolicy</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">summary</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">app == 'summary'</code>&#13;
  <code class="nt">ingress</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code>&#13;
      <code class="nt">source</code><code class="p">:</code>&#13;
        <code class="nt">serviceAccounts</code><code class="p">:</code>&#13;
          <code class="nt">names</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"customer"</code><code class="p-Indicator">]</code>&#13;
        <code class="nt">NamespaceSelector</code><code class="p">:</code> <code class="l-Scalar-Plain">app == 'bank'</code>&#13;
  <code class="nt">egress</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code></pre>&#13;
&#13;
<p>The preceding rule is specifying that the policy be applied to any Pods with the label <code>app: summary</code> and restricts access to Pods calling from the <code>customer</code> Service Account (in Namespaces with the label <code>app: bank</code>). This works because the Calico control plane (the Felix node agent) computes rules by reconciling Pods that are running under a specific Service Account with their IP addresses and subsequently syncing this information to Dikastes via a Unix socket.</p>&#13;
&#13;
<p>This out-of-band verification is important as it mitigates a potential attack vector in an Istio environment. Istio stores each Service Account’s PKI assets in a Secret in the cluster. Without this additional verification, an attacker who was able to steal that Secret would be able to masquerade as the asserted Service Account (by presenting those PKI assets), even though it may not be running as that account.</p>&#13;
&#13;
<figure><div class="figure" id="dikastes">&#13;
<img alt="prku 1004" src="assets/prku_1004.png"/>&#13;
<h6><span class="label">Figure 10-4. </span>Architecture diagram using Dikastes with Envoy.</h6>&#13;
</div></figure>&#13;
&#13;
<p>If your team is leveraging Calico already, then Dikastes can provide an extra layer of defense in depth and should definitely be considered. However, it requires Istio or some other mesh solution (e.g., standalone Envoy) to be available and running in the environment to validate the identity presented by the workload. These claims are not independently cryptographically verifiable, relying on the mesh to be present with every connected Service. This in itself adds a nontrivial level of complexity, and the trade-offs should be carefully evaluated. One strength of this approach is that Calico and Istio are both cross-platform, so this setup could be used to establish identity for applications running both on and off Kubernetes within an environment (whereas some options we’ll see are Kubernetes-only).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cilium" data-type="sect3"><div class="sect3" id="idm45611980607432">&#13;
<h3>Cilium</h3>&#13;
&#13;
<p>Like Calico, <a href="https://docs.cilium.io">Cilium</a> also provides network policy enforcement at layers 3 and 4, enabling users to restrict communication between Pods based on their Namespace and other metadata (labels, for example).<a data-primary="Cilium" data-secondary="identity, establishing" data-type="indexterm" id="idm45611980604792"/> Cilium also supports (without additional tooling) the ability to apply policy at layer 7 and restrict access to Services via Service Accounts.<a data-primary="Service Accounts" data-secondary="Cilium using to restrict Services access" data-type="indexterm" id="idm45611980603528"/></p>&#13;
&#13;
<p>Unlike Calico, enforcement in Cilium is not based on IP address (and updating node networking configurations). Instead, Cilium calculates identities for each unique Pod/endpoint (based on a number of selectors) and encodes these identities into each packet. It then enforces whether packets should be allowed based on these identities using <a href="https://oreil.ly/Jl9yw">eBPF</a> kernel hooks at various points in the datapath.</p>&#13;
&#13;
<p>Let’s briefly explore how<a data-primary="endpoints" data-secondary="Cilium calculating identity for" data-type="indexterm" id="idm45611980600712"/> Cilium calculates identities for an endpoint (Pod). The output of listing Cilium endpoints for an application is shown in the following code. We have omitted the list of labels in the snippet but have added an additional label to the last Pod in the list (<code>deathstar-657477f57d-zzz65</code>) that is not present on the other four Pods. As a result of this, we can see that the last Pod is therefore assigned a <em>different</em> identity to the previous four. Aside from that single differing label, all the Pods in the Deployment share a Namespace, Service Account, and several other arbitrary Kubernetes labels.</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl <code class="nb">exec</code> -it -n kube-system cilium-oid9h -- cilium endpoint list&#13;
NAMESPACE     NAME                              ENDPOINT ID   IDENTITY ID&#13;
default       deathstar-657477f57d-jpzgb        <code class="m">1474</code>          1597&#13;
default       deathstar-657477f57d-knxrl        <code class="m">2151</code>          1597&#13;
default       deathstar-657477f57d-xw2tr        <code class="m">16</code>            1597&#13;
default       deathstar-657477f57d-xz2kk        <code class="m">2237</code>          1597&#13;
default       deathstar-657477f57d-zzz65        <code class="m">1</code>             57962</pre>&#13;
&#13;
<p>If we removed the divergent label, the <code>deathstar-657477f57d-zzz65</code> Pod would be reassigned the same identity as its four peers. This level of granularity gives us a lot of power and flexibility when assigning identities to individual Pods.</p>&#13;
&#13;
<p>Cilium implements the Kubernetes-native NetworkPolicy API, and like Calico also<a data-primary="NetworkPolicy API" data-secondary="Cilium implementation of" data-type="indexterm" id="idm45611980594056"/><a data-primary="CiliumNetworkPolicy" data-type="indexterm" id="idm45611980593208"/><a data-primary="CiliumClusterwideNetworkPolicy" data-type="indexterm" id="idm45611980578152"/> exposes more fully featured capabilities in the form of CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy objects:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="s">"cilium.io/v2"</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CiliumNetworkPolicy</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="s">"k8s-svc-account"</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">endpointSelector</code><code class="p">:</code>&#13;
    <code class="nt">matchLabels</code><code class="p">:</code>&#13;
      <code class="nt">io.cilium.k8s.policy.serviceaccount</code><code class="p">:</code> <code class="l-Scalar-Plain">leia</code>&#13;
  <code class="nt">ingress</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">fromEndpoints</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">matchLabels</code><code class="p">:</code>&#13;
        <code class="nt">io.cilium.k8s.policy.serviceaccount</code><code class="p">:</code> <code class="l-Scalar-Plain">luke</code>&#13;
    <code class="nt">toPorts</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">ports</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">port</code><code class="p">:</code> <code class="s">'80'</code>&#13;
        <code class="nt">protocol</code><code class="p">:</code> <code class="l-Scalar-Plain">TCP</code>&#13;
      <code class="nt">rules</code><code class="p">:</code>&#13;
        <code class="nt">http</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="nt">method</code><code class="p">:</code> <code class="l-Scalar-Plain">GET</code>&#13;
          <code class="nt">path</code><code class="p">:</code> <code class="s">"/public$"</code></pre>&#13;
&#13;
<p>In this example, we are using special <code>io.cilium.k8s.policy.*</code> label selectors to target specific Service Accounts in the cluster. Cilium then uses its registry of identities (that we saw previously) to restrict/allow access as necessary. In the policy shown, we are restricting access to the path <code>/public</code> on port 80 for Pods with the <code>leia</code> Service Account. We are allowing access only from Pods with the <code>luke</code> Service Account.</p>&#13;
&#13;
<p>Like Calico, Cilium is cross-platform so can be used across Kubernetes and non-Kubernetes environments. Cilium <em>is</em> required to be present with every connected Service for identities to be verifiable, so the overall complexity of your networking setup can increase with this approach. However, Cilium doesn’t require a service mesh component to operate.<a data-primary="Container Networking Interface (CNI)" data-secondary="identity for clusters" data-startref="ix_CNIID" data-type="indexterm" id="idm45611980456408"/><a data-primary="application/workload identity" data-secondary="network identity" data-startref="ix_appwknet" data-type="indexterm" id="idm45611980455096"/><a data-primary="networks" data-secondary="identity" data-startref="ix_netID" data-type="indexterm" id="idm45611980453864"/><a data-primary="identity" data-secondary="application/workload" data-startref="ix_IDAWni" data-tertiary="network identity" data-type="indexterm" id="idm45611980452648"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Service Account Tokens (SAT)" data-type="sect2"><div class="sect2" id="service_account_tokens">&#13;
<h2>Service Account Tokens (SAT)</h2>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Service Accounts are primitives in Kubernetes that provide identity for groups of Pods.<a data-primary="application/workload identity" data-secondary="Service Account tokens" data-type="indexterm" id="ix_appwkSAT"/><a data-primary="identity" data-secondary="application/workload" data-tertiary="Service Account tokens" data-type="indexterm" id="ix_IDAWSAT"/><a data-primary="tokens" data-secondary="Service Account" data-type="indexterm" id="ix_tknSA"/><a data-primary="Service Account tokens (SAT)" data-type="indexterm" id="ix_SAT"/> Every Pod runs under a Service Account. If a Service Account is not pre-created by an administrator and assigned to a Pod, they are assigned a default Service Account for the Namespace they reside in.</p>&#13;
&#13;
<p>Service Account tokens are JSON Web Tokens (JWT) that are created as Kubernetes Secrets.<a data-primary="JSON Web Tokens (JWT)" data-type="indexterm" id="idm45611980442600"/> Each Service Account (including the default Service Account) has a corresponding Secret that contains the JWT. Unless otherwise specified, these tokens are mounted into each Pod running under that Service Account and can be used to make requests to the Kubernetes API (and as this section shows, other services).</p>&#13;
</div>&#13;
&#13;
<p>Kubernetes Service Accounts provide a way of assigning identity to a set of workloads. Role-Based Access Control (RBAC) rules then can be applied within the cluster to limit the scope of access for a specific Service Account. Service Accounts are the way that Kubernetes itself usually authenticates in-cluster access to the API:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
<code class="nt">secrets</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default-token-mf9v2</code></pre>&#13;
&#13;
<p>When a Service Account is created, an associated Secret is also created containing a unique JWT identifying the account:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">data</code><code class="p">:</code>&#13;
  <code class="nt">ca.crt</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">ZGVmYXVsdA==</code>&#13;
  <code class="nt">token</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;.. SNIP ...&gt;</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">annotations</code><code class="p">:</code>&#13;
    <code class="nt">kubernetes.io/service-account.name</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
    <code class="nt">kubernetes.io/service-account.uid</code><code class="p">:</code> <code class="l-Scalar-Plain">59aee446-b36e-420f-99eb-a68895084c98</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default-token-mf9v2</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">kubernetes.io/service-account-token</code></pre>&#13;
&#13;
<p>By default, Pods will automatically get the <code>default</code> Service Account token for their Namespace mounted if they do not specify a specific Service Account to use. This can (and should) <a href="https://oreil.ly/kX5mI">be disabled</a> to ensure that all Service Account tokens are explicitly mounted to Pods and their access scopes are well understood and defined (rather than falling back and assuming a default).</p>&#13;
&#13;
<p>To specify a Service Account for a Pod, use the <code>serviceAccountName</code> field in the Pod spec:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">my-pod</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">serviceAccountName</code><code class="p">:</code> <code class="l-Scalar-Plain">my-pod-sa</code>&#13;
<code class="c1"># Additional fields removed for brevity</code></pre>&#13;
&#13;
<p>This<a data-primary="secrets" data-secondary="Service Account Secret" data-type="indexterm" id="idm45611980262616"/> will cause the Service Account’s Secret (containing the token) to be mounted into the Pod at <code>/var/run/secrets/kubernetes.io/serviceaccount/</code>. The application can retrieve the token and use it in a request to other applications/services in the cluster.</p>&#13;
&#13;
<p>The destination application can verify the provided token by calling the Kubernetes <code>TokenReview</code> API:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code>curl</code><code> </code><code>-X</code><code> </code><code class="s2">"POST"</code><code> </code><code class="s2">"https://&lt;kubernetes API IP&gt;:&lt;kubernetes API Port&gt;\&#13;
/apis/authentication.k8s.io/v1/tokenreviews"</code><code> </code><code class="se">\&#13;
</code><code>     </code><code>-H</code><code> </code><code class="s1">'Authorization: Bearer &lt;token&gt;'</code><code> </code><code class="se">\ </code><a class="co" href="#callout_identity_CO1-1" id="co_identity_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
     </code><code>-H</code><code> </code><code class="s1">'Content-Type: application/json; charset=utf-8'</code><code> </code><code class="se">\&#13;
</code><code>     </code><code>-d</code><code> </code><code class="s1">$'{&#13;
  "kind": "TokenReview",&#13;
  "apiVersion": "authentication.k8s.io/v1",&#13;
  "spec": {&#13;
    "token": "&lt;token to verify&gt;" </code><a class="co" href="#callout_identity_CO1-2" id="co_identity_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="s1">&#13;
  }&#13;
}'</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_identity_CO1-1" id="callout_identity_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This token is the Secret mounted into the destination application’s Pod, allowing it to communicate with the API server.</p></dd>&#13;
<dt><a class="co" href="#co_identity_CO1-2" id="callout_identity_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This token is the one the calling application has presented as proof of identity.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The Kubernetes API will respond with metadata about the token to be verified, in addition to whether or not it has been authenticated:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"kind"</code><code class="p">:</code> <code class="s2">"TokenReview"</code><code class="p">,</code>&#13;
    <code class="nt">"apiVersion"</code><code class="p">:</code> <code class="s2">"authentication.k8s.io/v1"</code><code class="p">,</code>&#13;
    <code class="nt">"metadata"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"creationTimestamp"</code><code class="p">:</code> <code class="kc">null</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nt">"spec"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"token"</code><code class="p">:</code> <code class="s2">"&lt;token to verify&gt;"</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nt">"status"</code><code class="p">:</code> <code class="p">{</code>&#13;
        <code class="nt">"authenticated"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
        <code class="nt">"user"</code><code class="p">:</code> <code class="p">{</code>&#13;
            <code class="nt">"username"</code><code class="p">:</code> <code class="s2">"system:serviceaccount:default:default"</code><code class="p">,</code>&#13;
            <code class="nt">"uid"</code><code class="p">:</code> <code class="s2">"4afdf4d0-46d2-11e9-8716-005056bf4b40"</code><code class="p">,</code>&#13;
            <code class="nt">"groups"</code><code class="p">:</code> <code class="p">[</code>&#13;
                <code class="s2">"system:serviceaccounts"</code><code class="p">,</code>&#13;
                <code class="s2">"system:serviceaccounts:default"</code><code class="p">,</code>&#13;
                <code class="s2">"system:authenticated"</code>&#13;
            <code class="p">]</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The preceding flow is shown in <a data-type="xref" href="#service_account_tokens_fig">Figure 10-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="service_account_tokens_fig">&#13;
<img alt="prku 1005" src="assets/prku_1005.png"/>&#13;
<h6><span class="label">Figure 10-5. </span>Service Account tokens.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Service Account tokens have been part of Kubernetes since very early on and provide a tight integration with the platform in a consumable format (JWT). We as operators also have a fairly tight control on their validity as tokens are invalidated if the Service Account or Secret is deleted. However, they have some features that make their use as identifiers suboptimal. Most importantly, the tokens are scoped to a specific Service Account, so are unable to validate anything with a more granular scope, for example a Pod or a single container. We also need to add functionality to our applications if we want to use and verify tokens as a form of client identity. This involves calling the TokenReview API with some custom component.</p>&#13;
&#13;
<p>Tokens are also scoped to a single cluster, so we’re not able to use Service Account tokens issued by one cluster as identity documents for services calling from other clusters without exposing each cluster’s TokenReview API and encoding some additional metadata about the cluster where the request originated. All of this adds significant complexity to the setup, so we’d recommend not going down this path as a method of cross-cluster service identity/authentication.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To ensure that <a data-primary="permissions and privileges" data-secondary="application permissions" data-type="indexterm" id="idm45611980150680"/>permissions can be granted to applications in an appropriately granular way, unique Service Accounts should be created for each workload that requires access to the Kubernetes API server.<a data-primary="API server" data-secondary="authentication to" data-tertiary="Service Account for workloads" data-type="indexterm" id="idm45611980149368"/> Additionally, if a workload <em>does not</em> require access to the Kubernetes API server, disable the mounting of a Service Account token by specifying the <code>automountServiceAccountToken: false</code> field on the <code>ServiceAccount</code> object.</p>&#13;
&#13;
<p>For example, this can be set on the default Service Account for a Namespace to disable the auto-mounting of the credential token. This field can also be set on the <code>Pod</code> object, but note that the <code>Pod</code> field takes precedence if it’s set in both places.<a data-primary="application/workload identity" data-secondary="Service Account tokens" data-startref="ix_appwkSAT" data-type="indexterm" id="idm45611980145224"/><a data-primary="identity" data-secondary="application/workload" data-startref="ix_IDAWSAT" data-tertiary="Service Account tokens" data-type="indexterm" id="idm45611980143912"/><a data-primary="tokens" data-secondary="Service Account" data-startref="ix_tknSA" data-type="indexterm" id="idm45611980142424"/><a data-primary="Service Account tokens (SAT)" data-startref="ix_SAT" data-type="indexterm" id="idm45611980141208"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Projected Service Account Tokens (PSAT)" data-type="sect2"><div class="sect2" id="idm45611980450248">&#13;
<h2>Projected Service Account Tokens (PSAT)</h2>&#13;
&#13;
<p>Beginning with Kubernetes v1.12 there is an additional method of identity available that <a data-primary="identity" data-secondary="application/workload" data-tertiary="Projected Service Account tokens" data-type="indexterm" id="ix_IDAWPSAT"/><a data-primary="application/workload identity" data-secondary="Projected Service Account tokens" data-type="indexterm" id="ix_appwkPSAT"/><a data-primary="tokens" data-secondary="Projected Service Account" data-type="indexterm" id="ix_tknPSA"/><a data-primary="Projected Service Account tokens (PSAT)" data-type="indexterm" id="ix_PSAT"/>builds on the ideas in service account tokens but seeks to address some of the weaknesses (such as lack of TTL, wide scoping, and persistence).</p>&#13;
&#13;
<p>In order for the PSAT flow to function correctly, the Kubernetes<a data-primary="API server" data-secondary="authentication to" data-tertiary="using PSATs" data-type="indexterm" id="idm45611980132984"/> API server needs to be configured with the parameter keys shown here (all are configurable, though):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">containers</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">command</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">kube-apiserver</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--service-account-signing-key-file=/etc/kubernetes/pki/sa.key</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--service-account-key-file=/etc/kubernetes/pki/sa.pub</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--service-account-issuer=api</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--service-account-api-audiences=api</code>&#13;
    <code class="c1"># Additional flags removed for brevity</code>&#13;
    <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">k8s.gcr.io/kube-apiserver:v1.17.3</code></pre>&#13;
&#13;
<p>The flow for establishing and verifying identity is similar to the SAT method. However, instead of having our Pod/application read the automounted Service Account token, you instead mount a projected Service Account token as a Volume. This also injects a token into the Pod, but you can specify a TTL and custom audience for the token:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Pod</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">test</code><code>&#13;
</code><code>  </code><code class="nt">labels</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">app</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">test</code><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">test</code><code>&#13;
</code><code>  </code><code class="nt">containers</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">test</code><code>&#13;
</code><code>    </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ubuntu:bionic</code><code>&#13;
</code><code>    </code><code class="nt">command</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="s">'</code><code class="s">sh</code><code class="s">'</code><code class="p-Indicator">,</code><code> </code><code class="s">'</code><code class="s">-c</code><code class="s">'</code><code class="p-Indicator">,</code><code> </code><code class="s">'</code><code class="s">echo</code><code class="nv"> </code><code class="s">Hello</code><code class="nv"> </code><code class="s">Kubernetes!</code><code class="nv"> </code><code class="s">&amp;&amp;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">3600</code><code class="s">'</code><code class="p-Indicator">]</code><code>&#13;
</code><code>    </code><code class="nt">volumeMounts</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">mountPath</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">/var/run/secrets/tokens</code><code>&#13;
</code><code>      </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">app-token</code><code>&#13;
</code><code>  </code><code class="nt">volumes</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">app-token</code><code>&#13;
</code><code>    </code><code class="nt">projected</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="nt">sources</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="p-Indicator">-</code><code> </code><code class="nt">serviceAccountToken</code><code class="p">:</code><code>&#13;
</code><code>          </code><code class="nt">audience</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">api</code><code> </code><a class="co" href="#callout_identity_CO2-1" id="co_identity_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>          </code><code class="nt">expirationSeconds</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">600</code><code>&#13;
</code><code>          </code><code class="nt">path</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">app-token</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_identity_CO2-1" id="callout_identity_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>audience</code> field is important because it prevents destination applications using the token from the calling application and attempting to masquerade as the calling application. The audience should always be scoped correctly depending on the destination application. In this case, we are scoping to communicate with the API server itself.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>When using PSAT, a designated Service Account must be created and used. Kubernetes does not mount PSATs for Namespace default Service Accounts.</p>&#13;
</div>&#13;
&#13;
<p>The calling application can read the projected token and use that in requests within the cluster. <a data-primary="TokenReview API" data-type="indexterm" id="idm45611979845512"/>Destination applications can verify the token by calling the <code>TokenReview</code> API and passing the received token. With the PSAT method, the review will also verify that the TTL has not expired and will return additional metadata about the presenting application, including specific Pod information. This provides a tighter scope than regular SATs (which only assert a Service Account).</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="err">//</code> <code class="err">Additional</code> <code class="err">fields</code> <code class="err">removed</code> <code class="err">for</code> <code class="err">brevity</code>&#13;
<code class="s2">"extra"</code><code class="err">:</code> <code class="p">{</code>&#13;
  <code class="nt">"authentication.kubernetes.io/pod-name"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"test"</code><code class="p">],</code>&#13;
  <code class="nt">"authentication.kubernetes.io/pod-uid"</code><code class="p">:</code>&#13;
    <code class="p">[</code><code class="s2">"8b9bc1be-c71f-4551-aeb9-2759887cbde0"</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#projected_service_account_tokens">Figure 10-6</a>, there is no real difference between the SAT and PSAT flows themselves (aside from the server verifying the <code>audience</code> field), only in the validity and granularity of the identity asserted by the token. The <code>audience</code> field is important as it identifies the intended recipient of the token. In keeping with the <a href="https://oreil.ly/gKlA7">JWT official specification</a>, the API will reject a token whose audience does not match the audience specified in the API server configuration.<a data-primary="JSON Web Tokens (JWT)" data-type="indexterm" id="idm45611979884536"/></p>&#13;
&#13;
<figure><div class="figure" id="projected_service_account_tokens">&#13;
<img alt="prku 1006" src="assets/prku_1006.png"/>&#13;
<h6><span class="label">Figure 10-6. </span>Projected Service Account tokens.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Projected Service Account tokens are a relatively recent but incredibly strong addition to Kubernetes’ feature set. On their own they provide tight integration with the platform itself, they provide configurable TTLs, and they have a tight scope (individual Pods). They can also be used as building blocks to construct even more robust patterns (as we’ll see in later sections).<a data-primary="identity" data-secondary="application/workload" data-startref="ix_IDAWPSAT" data-tertiary="Projected Service Account tokens" data-type="indexterm" id="idm45611979888008"/><a data-primary="application/workload identity" data-secondary="Projected Service Account tokens" data-startref="ix_appwkPSAT" data-type="indexterm" id="idm45611979886472"/><a data-primary="tokens" data-secondary="Projected Service Account" data-startref="ix_tknPSA" data-type="indexterm" id="idm45611979889976"/><a data-primary="Projected Service Account tokens (PSAT)" data-startref="ix_PSAT" data-type="indexterm" id="idm45611979893752"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Platform Mediated Node Identity" data-type="sect2"><div class="sect2" id="idm45611980139864">&#13;
<h2>Platform Mediated Node Identity</h2>&#13;
&#13;
<p>In cases where all workloads are running on a homogeneous platform (for example, AWS), it is possible for the platform itself to determine and assign identities to workloads because of the contextual metadata they possess about the workload.<a data-primary="AWS (Amazon Web Services)" data-type="indexterm" id="idm45611979898856"/><a data-primary="platform mediated Node identity" data-type="indexterm" id="ix_pltID"/><a data-primary="application/workload identity" data-secondary="platform mediated Node identity" data-type="indexterm" id="ix_appwkplt"/><a data-primary="identity" data-secondary="application/workload" data-tertiary="platform mediated Node identity" data-type="indexterm" id="ix_IDAWplt"/></p>&#13;
&#13;
<p>Identity is not asserted by the workload itself but is determined based on its properties by an out-of-band provider. The provider returns the workload a credential to prove identity that may be used to communicate with other services on the platform. It then becomes trivial for the other services to verify that credential because they too are on the same underlying platform.</p>&#13;
&#13;
<p>On AWS, an EC2 instance may request credentials to connect to a different service like an S3 bucket. The AWS platform inspects the metadata of the instance and can provide role-specific credentials back to the instance with which to make the connection, as shown in <a data-type="xref" href="#platform_mediated_identify">Figure 10-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="platform_mediated_identify">&#13;
<img alt="prku 1007" src="assets/prku_1007.png"/>&#13;
<h6><span class="label">Figure 10-7. </span>Platform mediated identity.</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that the platform still has to perform <em>authorization</em> on the request to ensure that the identity being used has the appropriate permissions. This method is only being used to <em>authenticate</em> the request.</p>&#13;
</div>&#13;
&#13;
<p>Many cloud vendors expose functionality described in this section. We’re choosing to focus on tooling that applies to and integrates with Amazon Web Services (AWS) because it is the vendor we most commonly see in the field.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="AWS platform authentication methods/tooling" data-type="sect3"><div class="sect3" id="idm45611979906792">&#13;
<h3>AWS platform authentication methods/tooling</h3>&#13;
&#13;
<p>AWS provides a strong identity solution at the node level via the EC2 metadata API. <a data-primary="application/workload identity" data-secondary="platform mediated Node identity" data-tertiary="AWS platform authentication methods/tools" data-type="indexterm" id="ix_appwkpltAWS"/><a data-primary="platform mediated Node identity" data-secondary="AWS platform authentication methods/tools" data-type="indexterm" id="ix_pltIDAWS"/><a data-primary="AWS platform authentication methods/tooling" data-type="indexterm" id="ix_AWSauth"/>This is an example of a platform-mediated system, whereby the platform (AWS) is able to determine the identity of a calling entity based on a number of intrinsic properties without the entity asserting any credentials/identity claim itself. The platform can then deliver secure credentials to the instance (in the form of a role, for example) that allows it to access any services defined by the relevant policies.<a data-primary="Identity and Access Management (IAM)" data-type="indexterm" id="idm45611979910872"/> As a whole this is referred to as Identity and Access Management (IAM).<a data-primary="IAM" data-see="Identity and Access Management" data-type="indexterm" id="idm45611979918328"/></p>&#13;
&#13;
<p>This model underpins how AWS (and many other vendors) provide secure access to their own cloud services. However, with the rise of containers and other multitenant application models, this per-node identity/authentication system breaks down and requires additional tooling and alternative approaches.</p>&#13;
&#13;
<p>In this section we’ll look at the three main tooling options we encounter in the field. We’ll cover kube2iam and kiam, two separate tools that share the same approximate implementation model (and therefore have similar advantages and disadvantages). We’ll also describe why we don’t recommend those tools today and why you should consider a more integrated solution such as the final option we cover, IAM Roles for Service Accounts (IRSA).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kube2iam" data-type="sect4"><div class="sect4" id="idm45611979920792">&#13;
<h4>kube2iam</h4>&#13;
&#13;
<p><a href="https://github.com/jtblin/kube2iam">kube2iam</a> is an open source (OSS) tool that acts as a proxy between running workloads and the AWS EC2 metadata API.<a data-primary="platform mediated Node identity" data-secondary="AWS platform authentication methods/tools" data-tertiary="kube2iam" data-type="indexterm" id="idm45611979923688"/><a data-primary="AWS platform authentication methods/tooling" data-secondary="kube2iam" data-type="indexterm" id="idm45611979922456"/><a data-primary="Identity and Access Management (IAM)" data-secondary="kube2iam" data-type="indexterm" id="idm45611979929864"/><a data-primary="kube2iam" data-type="indexterm" id="idm45611979928904"/> The architecture is shown in <a data-type="xref" href="#kube2iam">Figure 10-8</a>.</p>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>kube2iam requires that every node in the cluster be able to assume a superset of all the roles that Pods may require. This security model means that the scope of access provided should a container breakout occur is potentially huge. For this reason it is strongly advised not to use kube2iam. We are discussing it here as we regularly encounter it in the field and want to ensure that you are aware of the limitations of the implementation before diving in.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="kube2iam">&#13;
<img alt="prku 1008" src="assets/prku_1008.png"/>&#13;
<h6><span class="label">Figure 10-8. </span>kube2iam architecture and data flow.</h6>&#13;
</div></figure>&#13;
&#13;
<p>kube2iam Pods run on every node via a DaemonSet. Each Pod injects an iptables rule to capture outbound traffic to the metadata API and redirect it to the running instance of kube2iam on that node.</p>&#13;
&#13;
<p>Pods that want to interact with AWS APIs should specify the role they want to assume as an annotation in the spec. For example, in the following Deployment spec you can see the role is specified in the <code>iam.amazonaws.com/role</code> annotation:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx-deployment</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">3</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
    <code class="nt">metadata</code><code class="p">:</code>&#13;
      <code class="nt">annotations</code><code class="p">:</code>&#13;
        <code class="nt">iam.amazonaws.com/role</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;role-arn&gt;</code>&#13;
      <code class="nt">labels</code><code class="p">:</code>&#13;
        <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
    <code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx:1.9.1</code>&#13;
        <code class="nt">ports</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="nt">containerPort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kiam" data-type="sect4"><div class="sect4" id="idm45611979945144">&#13;
<h4>kiam</h4>&#13;
&#13;
<p>Like <a data-primary="platform mediated Node identity" data-secondary="AWS platform authentication methods/tools" data-tertiary="kiam" data-type="indexterm" id="idm45611979985704"/><a data-primary="kiam" data-type="indexterm" id="idm45611979984456"/><a data-primary="Identity and Access Management (IAM)" data-secondary="kiam" data-type="indexterm" id="idm45611980044296"/><a data-primary="AWS platform authentication methods/tooling" data-secondary="kiam" data-type="indexterm" id="idm45611980043384"/>kube2iam, <a href="https://github.com/uswitch/kiam">kiam</a> is an open source (OSS) tool that acts as a proxy to the AWS EC2 metadata API, although its architecture (and as a result, its security model) are different and slightly improved, as shown in <a data-type="xref" href="#kiam">Figure 10-9</a>.</p>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>While safer than kube2iam, kiam also introduces a potentially serious security flaw. This section describes a mitigation of the flaw, but you should still use caution and understand the attack vector when using kiam.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="kiam">&#13;
<img alt="prku 1009" src="assets/prku_1009.png"/>&#13;
<h6><span class="label">Figure 10-9. </span>kiam architecture and data flow.</h6>&#13;
</div></figure>&#13;
&#13;
<p>kiam has both server and agent components. The agents run as a DaemonSet on every node in the cluster. The server component can (and should) be restricted to the either the control-plane nodes or a subset of cluster nodes. Agents capture EC2 metadata API requests and forward them to the server components to complete the appropriate authentication with AWS. Only the server nodes require access to assume AWS IAM roles (again, a superset of all roles that Pods may require), as shown in <a data-type="xref" href="#kiam_flow">Figure 10-10</a>.</p>&#13;
&#13;
<figure><div class="figure" id="kiam_flow">&#13;
<img alt="prku 1010" src="assets/prku_1010.png"/>&#13;
<h6><span class="label">Figure 10-10. </span>kiam flow.</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this model, there should be controls in place to ensure that no workloads are able to run on the server nodes (and thereby obtain unfettered AWS API access). Assumption of roles is achieved (like kube2iam) by annotating Pods with the desired role:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx-deployment</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">3</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
    <code class="nt">metadata</code><code class="p">:</code>&#13;
      <code class="nt">annotations</code><code class="p">:</code>&#13;
        <code class="nt">iam.amazonaws.com/role</code><code class="p">:</code> <code class="l-Scalar-Plain">&lt;role-arn&gt;</code>&#13;
      <code class="nt">labels</code><code class="p">:</code>&#13;
        <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
    <code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">nginx:1.9.1</code>&#13;
        <code class="nt">ports</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="nt">containerPort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code></pre>&#13;
&#13;
<p>While the security model is better than kube2iam, kiam still has a potential attack vector whereby if a user is able to directly schedule a Pod onto a node (by populating its <code>nodeName</code> field, bypassing the Kubernetes scheduler and any potential guards) they would have unrestricted access to the EC2 metadata API.</p>&#13;
&#13;
<p>The mitigation for this issue is to run a mutating or validating admission webhook that ensures the <code>nodeName</code> field is not prepopulated on Pod create and update requests to the Kubernetes API.</p>&#13;
&#13;
<p>kiam provides a strong story for enabling individual Pods to access AWS APIs, using a model that existing AWS users will be familiar with (role assumption). This is a viable solution in many cases, provided the preceding mitigation is put in place prior to use.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="IAM Roles for Service Accounts (IRSA)" data-type="sect4"><div class="sect4" id="idm45611979986424">&#13;
<h4>IAM Roles for Service Accounts (IRSA)</h4>&#13;
&#13;
<p>Since late 2019, AWS has provided a native integration between Kubernetes and IAM called <a href="https://oreil.ly/dUoJJ">IAM Roles for Service Accounts</a> (IRSA).<a data-primary="platform mediated Node identity" data-secondary="AWS platform authentication methods/tools" data-tertiary="IAM Roles for Service Accounts" data-type="indexterm" id="idm45611979609048"/><a data-primary="Service Accounts" data-secondary="IAM Roles for" data-type="indexterm" id="idm45611979607848"/><a data-primary="AWS platform authentication methods/tooling" data-secondary="IAM Roles for Service Accounts" data-type="indexterm" id="idm45611979606904"/><a data-primary="Identity and Access Management (IAM)" data-secondary="IAM Roles for Service Accounts (IRSA)" data-type="indexterm" id="idm45611979605976"/></p>&#13;
&#13;
<p>At a high level, IRSA exposes a similiar experience to kiam and kube2iam, in that users can annotate their Pods with an AWS IAM role they want it to assume. The implementation is very different, though, eliminating the security concerns of the earlier approaches.<a data-primary="IRSA" data-see="IAM Roles for Service Accounts" data-type="indexterm" id="idm45611979604344"/></p>&#13;
&#13;
<p>AWS IAM supports federating identity out to a third-party OIDC provider, in this case the Kubernetes API server.<a data-primary="API server" data-secondary="authentication to" data-tertiary="AWS IRSA" data-type="indexterm" id="idm45611979602840"/> As you saw already with PSATs, Kubernetes is capable of creating and signing short-lived tokens on a per-Pod basis.</p>&#13;
&#13;
<p>AWS IRSA combines these features with an additional credential provider in their SDKs that calls <code>sts:AssumeRoleWithWebIdentity</code>, passing the PSAT. The PSAT and desired role need to be injected as environment variables within the Pod (there is a webhook that will do this automatically based on the <code>serviceAccountName</code> desired):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">myapp</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">serviceAccountName</code><code class="p">:</code> <code class="l-Scalar-Plain">my-serviceaccount</code>&#13;
  <code class="nt">containers</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">myapp</code>&#13;
    <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">myapp:1.2</code>&#13;
    <code class="nt">env</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS_ROLE_ARN</code>&#13;
      <code class="nt">value</code><code class="p">:</code> <code class="s">"arn:aws:iam::123456789012:role/\</code>&#13;
        <code class="s">eksctl-irptest-addon-iamsa-default-my-\</code>&#13;
        <code class="s">serviceaccount-Role1-UCGG6NDYZ3UE"</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">AWS_WEB_IDENTITY_TOKEN_FILE</code>&#13;
      <code class="nt">value</code><code class="p">:</code> <code class="l-Scalar-Plain">/var/run/secrets/eks.amazonaws.com/serviceaccount/token</code>&#13;
    <code class="nt">volumeMounts</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">mountPath</code><code class="p">:</code> <code class="l-Scalar-Plain">/var/run/secrets/eks.amazonaws.com/serviceaccount</code>&#13;
        <code class="l-Scalar-Plain">name</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">aws-iam-token</code>&#13;
        <code class="l-Scalar-Plain">readOnly</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">true</code>&#13;
  <code class="nt">volumes</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">aws-iam-token</code>&#13;
    <code class="nt">projected</code><code class="p">:</code>&#13;
      <code class="nt">defaultMode</code><code class="p">:</code> <code class="l-Scalar-Plain">420</code>&#13;
      <code class="nt">sources</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">serviceAccountToken</code><code class="p">:</code>&#13;
          <code class="nt">audience</code><code class="p">:</code> <code class="l-Scalar-Plain">sts.amazonaws.com</code>&#13;
          <code class="nt">expirationSeconds</code><code class="p">:</code> <code class="l-Scalar-Plain">86400</code>&#13;
          <code class="nt">path</code><code class="p">:</code> <code class="l-Scalar-Plain">token</code></pre>&#13;
&#13;
<p>Kubernetes does not natively expose a <code>.well-known</code> OIDC endpoint, so there is some additional work required to configure this at a public location (static S3 bucket) so that AWS IAM can verify the token using Kubernetes’ public Service Account signing key.</p>&#13;
&#13;
<p>Once verified, AWS IAM responds to the application’s request, exchanging the PSAT for the desired IAM role credentials as shown in <a data-type="xref" href="#iam_roles_for_service_accounts">Figure 10-11</a>.</p>&#13;
&#13;
<figure><div class="figure" id="iam_roles_for_service_accounts">&#13;
<img alt="prku 1011" src="assets/prku_1011.png"/>&#13;
<h6><span class="label">Figure 10-11. </span>IAM roles for Service Accounts.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Although the setup for IRSA is a little clunky, it possesses the best security model of all approaches to Pod IAM Role assumption.</p>&#13;
&#13;
<p class="pagebreak-before">IRSA is a strong choice for organizations already leveraging AWS services as it uses patterns and primitives that will be familiar with your operations and development teams. The model employed (mapping Service Accounts to IAM roles) is also a straightforward one to understand with a strong security model.</p>&#13;
&#13;
<p>The main downside is that IRSA can be somewhat cumbersome to deploy and configure if you are not utilizing the Amazon Elastic Kubernetes Service (EKS).<a data-primary="Amazon Elastic Kubernetes Service (EKS)" data-type="indexterm" id="idm45611979491160"/> However, recent additions to Kubernetes itself will alleviate some of the technical challenges here, such as exposing Kubernetes itself as an OIDC provider.</p>&#13;
&#13;
<p>As we saw in this section, mediating identity through a common platform (AWS in this case) has many strengths. In the next section we’ll dive into tooling that is aiming to implement this same model but capable of spanning <em>multiple</em> underlying platforms. This brings the control of a centralized identity system with the flexibility of running it for any workload across any cloud or platform.<a data-primary="application/workload identity" data-secondary="platform mediated Node identity" data-startref="ix_appwkpltAWS" data-tertiary="AWS platform authentication methods/tools" data-type="indexterm" id="idm45611979488872"/><a data-primary="platform mediated Node identity" data-secondary="AWS platform authentication methods/tools" data-startref="ix_pltIDAWS" data-type="indexterm" id="idm45611979487224"/><a data-primary="AWS platform authentication methods/tooling" data-startref="ix_AWSauth" data-type="indexterm" id="idm45611979485960"/></p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cross-platform identity with SPIFFE and SPIRE" data-type="sect3"><div class="sect3" id="idm45611979610920">&#13;
<h3>Cross-platform identity with SPIFFE and SPIRE</h3>&#13;
&#13;
<p>Secure Production Identity Framework for Everyone (SPIFFE) is a standard that specifies a syntax for identity (SPIFFE Verifiable Identity Document, SVID) that can leverage existing cryptographic formats such as x509 and JWT. It also specifies a number of APIs for providing and consuming these identities.<a data-primary="SVIDs (SPIFFE Verifiable Identity Documents)" data-type="indexterm" id="idm45611979482904"/><a data-primary="SPIFFE and SPIRE" data-type="indexterm" id="ix_SPIFF"/><a data-primary="application/workload identity" data-secondary="platform mediated Node identity" data-tertiary="cross-platform identity with SPIFFE and SPIRE" data-type="indexterm" id="ix_appwkpltcrs"/><a data-primary="platform mediated Node identity" data-secondary="cross-platform identity with SPIFFE and SPIRE" data-type="indexterm" id="ix_pltIDcrs"/><a data-primary="cross-platform identity with SPIFFE and SPIRE" data-type="indexterm" id="ix_crspltID"/> A SPIFFE ID takes the form <code>spiffe://trust-domain/hierarchical/workload</code>, where all sections after the <code>spiffe://</code> are arbitrary string identifiers that can be used in multiple ways (although creating some kind of hierarchy is most common).</p>&#13;
&#13;
<p>SPIFFE Runtime Environment (SPIRE) is the reference implementation of SPIFFE and has a number of SDKs and integrations to allow applications to make use of (both providing, and consuming) SVIDs.</p>&#13;
&#13;
<p>This section will assume use of SPIFFE and SPIRE together unless otherwise noted.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Architecture and concepts" data-type="sect4"><div class="sect4" id="idm45611979475448">&#13;
<h4>Architecture and concepts</h4>&#13;
&#13;
<p>SPIRE runs a server component that acts as a signing authority for identities and maintains a registry of all workload identities and the conditions required for an identity document to be issued.<a data-primary="SPIFFE and SPIRE" data-secondary="architecture and concepts" data-type="indexterm" id="idm45611979473544"/></p>&#13;
&#13;
<p>SPIRE agents run on every node as a DaemonSet where they expose an API for workloads to request identity via a Unix socket. The agent is also configured with read-only access to the kubelet to determine metadata about Pods on the node. The SPIRE architecture is shown in <a data-type="xref" href="#spire_architecture">Figure 10-12</a>.</p>&#13;
&#13;
<figure><div class="figure" id="spire_architecture">&#13;
<img alt="prku 1012" src="assets/prku_1012.png"/>&#13;
<h6><span class="label">Figure 10-12. </span>SPIRE Architecture. Reproduced from the <a href="https://oreil.ly/6VY4A">official SPIRE documentation</a>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>When agents come online they verify and register themselves to the server by a process called <em>node attestation</em> (as shown in <a data-type="xref" href="#node_attestation">Figure 10-13</a>). <a data-primary="node orchestration" data-type="indexterm" id="idm45611979466536"/>This process utilizes environmental context (for example, the AWS EC2 metadata API or Kubernetes PSATs) to identify a node and assign it a SPIFFE ID. The server then issues the node an identity in the form of an x509 SVID. Following is an example registration for a node:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">/opt/spire/bin/spire-server entry create <code class="se">\</code>&#13;
  -spiffeID spiffe://production-trust-domain/nodes <code class="se">\</code>&#13;
  -selector k8s_psat:cluster:production-cluster <code class="se">\</code>&#13;
  -selector k8s_psat:agent_ns:spire <code class="se">\</code>&#13;
  -selector k8s_psat:agent_sa:spire-agent <code class="se">\</code>&#13;
  -node</pre>&#13;
&#13;
<p>This tells the SPIRE server to assign the SPIFFE ID <code>spiffe://production-trust-domain/nodes</code> to any node where the agent Pod satisfies the selectors specified; in this case, we are selecting when the Pod is running in the SPIRE Namespace on the <code>production-cluster</code> under the <code>spire-agent</code> Service account (verified via the PSAT).</p>&#13;
&#13;
<figure><div class="figure" id="node_attestation">&#13;
<img alt="prku 1013" src="assets/prku_1013.png"/>&#13;
<h6><span class="label">Figure 10-13. </span>Node attestation. Reproduced from the <a href="https://oreil.ly/Q5eEW">official SPIRE documentation</a>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>When workloads come online they call the node-local workload API to request an SVID. The SPIRE agent uses information available to it on the platform (from the kernel, kubelet, etc.) to determine the properties of the calling workload. <a data-primary="workload orchestration" data-type="indexterm" id="idm45611979460584"/>This process is referred to as <em>workload attestation</em> (as shown in <a data-type="xref" href="#workload_attestation">Figure 10-14</a>). The SPIRE server then matches the properties against known workload identities based on their selectors and returns an SVID to the workload (via the agent) that can be used for authentication against other systems:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">/opt/spire/bin/spire-server entry create <code class="se">\</code>&#13;
  -spiffeID spiffe://production-trust-domain/service-a <code class="se">\</code>&#13;
  -parentID spiffe://production-trust-domain/nodes <code class="se">\</code>&#13;
  -selector k8s:ns:default <code class="se">\</code>&#13;
  -selector k8s:sa:service-a <code class="se">\</code>&#13;
  -selector k8s:pod-label:app:frontend <code class="se">\</code>&#13;
  -selector k8s:container-image:docker.io/johnharris85/service-a:v0.0.1</pre>&#13;
&#13;
<p>This tells the SPIRE server to assign the SPIFFE ID <code>spiffe://production-trust-domain/service-a</code> to any workload that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Is running on a node with ID <code>spiffe://production-trust-domain/nodes</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Is running in the <code>default</code> Namespace.</p>&#13;
</li>&#13;
<li>&#13;
<p>Is running under the <code>service-a</code> Service Account.</p>&#13;
</li>&#13;
<li>&#13;
<p>Has the Pod label <code>app: frontend</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Was built using the <code>docker.io/johnharris85/service-a:v0.0.1</code> image.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="workload_attestation">&#13;
<img alt="prku 1014" src="assets/prku_1014.png"/>&#13;
<h6><span class="label">Figure 10-14. </span>Workload attestation. Reproduced from the <a href="https://oreil.ly/Eh7Xl">official SPIRE documentation</a>.</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Note that the workload attestor plug-in can query the kubelet (to discover workload information) using its Service Account. The kubelet then uses the <code>TokenReview</code> API to validate bearer tokens. This requires reachability to the Kubernetes API server. Therefore, API server downtime can interrupt workload attestation.</p>&#13;
</div>&#13;
&#13;
<p>The <code>--authentication-token-webhook-cache-ttl</code> kubelet flag controls how long the kubelet caches TokenReview responses and may help to mitigate this issue. A large cache TTL value is not recommended, however, as that can impact permission revocation. See the <a href="https://oreil.ly/Pn1ZP">SPIRE workload attestor documentation</a> for more details.</p>&#13;
&#13;
<p>The patterns described in this section have significant advantages when trying to build a robust identity system for your workloads, both on and off Kubernetes. The SPIFFE specification leverages well-understood and widely supported cryptographic standards in x509 and JWT, and the SPIRE implementation also supports many different methods of application integrations. Another key property is the ability to scope identity to a very granular level by combining projected service account tokens with its own selectors to identify individual Pods. This can be especially useful in scenarios where sidecar containers are present in a Pod and each container needs varying levels of access.</p>&#13;
&#13;
<p>This approach is also undeniably the most labor-intensive and requires expertise in the tooling and effort to maintain another component in the environment. There may also be work required to register each workload, although this could be automated (and work is already underway in the community around the area of automated registration of workloads).</p>&#13;
&#13;
<p>SPIFFE/SPIRE have a number of integration points with workload applications. Which integration point is appropriate will depend on the desired level of coupling to the platform and the amount of control users have over the environment.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Direct application access" data-type="sect4"><div class="sect4" id="idm45611979474824">&#13;
<h4>Direct application access</h4>&#13;
&#13;
<p>SPIRE provides SDKs for Go, C, and Java for applications to directly integrate with the SPIFFE workload API.<a data-primary="SPIFFE and SPIRE" data-secondary="direct application access" data-type="indexterm" id="idm45611979384456"/> These wrap existing HTTP libraries but provide native support for obtaining and verifying identities. Following is an example in Go calling a Kubernetes Service <code>service-b</code> and expecting a specific SPIFFE ID to be presented (through an x509 SVID):</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">err</code> <code class="o">:=</code> <code class="nx">os</code><code class="p">.</code><code class="nx">Setenv</code><code class="p">(</code><code class="s">"SPIFFE_ENDPOINT_SOCKET"</code><code class="p">,</code>&#13;
  <code class="s">"unix:///run/spire/sockets/agent.sock"</code><code class="p">)</code>&#13;
<code class="nx">conn</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">spiffe</code><code class="p">.</code><code class="nx">DialTLS</code><code class="p">(</code><code class="nx">ctx</code><code class="p">,</code> <code class="s">"tcp"</code><code class="p">,</code> <code class="s">"service-b"</code><code class="p">,</code>&#13;
  <code class="nx">spiffe</code><code class="p">.</code><code class="nx">ExpectPeer</code><code class="p">(</code><code class="s">"spiffe://production-trust-domain/service-b"</code><code class="p">))</code>&#13;
<code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
  <code class="nx">log</code><code class="p">.</code><code class="nx">Fatalf</code><code class="p">(</code><code class="s">"Unable to create TLS connection: %v"</code><code class="p">,</code> <code class="nx">err</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The SPIRE agent also exposes a <a href="https://grpc.io/about">gRPC</a> API for those users who want a tighter integration with the platform but are working in a language without SDK availability.</p>&#13;
&#13;
<p>Direct integration (as described in this subsection) is <em>not</em> a recommended approach for end-user applications for the following reasons:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It tightly couples the application with the platform/implementation.</p>&#13;
</li>&#13;
<li>&#13;
<p>It requires mounting the SPIRE agent Unix socket into the Pod.</p>&#13;
</li>&#13;
<li>&#13;
<p>It’s not easily extensible.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The main area where using these libraries directly is appropriate is if building out some intermediate platform tooling that wraps or extends some of the existing functionality of the toolset.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sidecar proxy" data-type="sect4"><div class="sect4" id="idm45611979304392">&#13;
<h4>Sidecar proxy</h4>&#13;
&#13;
<p>SPIRE natively supports the Envoy SDS API for publishing certificates to be consumed by an Envoy proxy. <a data-primary="SPIFFE and SPIRE" data-secondary="integration with sidecar proxy" data-type="indexterm" id="idm45611979302696"/><a data-primary="Envoy proxy" data-secondary="SDS API for publishing certificates" data-type="indexterm" id="idm45611979301704"/>Envoy can then use the SVID x509 certificate to establish TLS connections with other Services and use the trust bundle to verify incoming connections.</p>&#13;
&#13;
<p>Envoy also supports verifying that only specific SPIFFE IDs (encoded into the SVID) should be able to connect. There are two methods to implement this verification:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>By specifying a list of <code>verify_subject_alt_name</code> values in the Envoy &#13;
<span class="keep-together">configuration</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>By utilizing Envoy’s External Authorization API to delegate admission decisions to an external system (for example, Open Policy Agent). Following is an example of a Rego policy to achieve this:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-type="programlisting">package envoy.authz&#13;
&#13;
import input.attributes.request.http as http_request&#13;
import input.attributes.source.address as source_address&#13;
&#13;
default allow = false&#13;
&#13;
allow {&#13;
    http_request.path == "/api"&#13;
    http_request.method == "GET"&#13;
    svc_spiffe_id == "spiffe://production-trust-domain/frontend"&#13;
}&#13;
&#13;
svc_spiffe_id = client_id {&#13;
    [_, _, uri_type_san] := split(&#13;
      http_request.headers["x-forwarded-client-cert"], ";")&#13;
    [_, client_id] := split(uri_type_san, "=")&#13;
}</pre>&#13;
&#13;
<p>In this example, Envoy verifies the request’s TLS certificate against the SPIRE trust bundle, then delegates authorization to Open Policy Agent (OPA). The Rego policy inspects the SVID and allows the request if the SPIFFE ID matches <code>spiffe://production-trust-domain/frontend</code>. The architecture for this flow is shown in <a data-type="xref" href="#spire_with_envoy">Figure 10-15</a>.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This approach inserts OPA into the critical request path, so that should be taken into consideration when designing the flow/&#13;
<span class="keep-together">architecture</span>.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="spire_with_envoy">&#13;
<img alt="prku 1015" src="assets/prku_1015.png"/>&#13;
<h6><span class="label">Figure 10-15. </span>SPIRE with Envoy.</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Service mesh (Istio)" data-type="sect4"><div class="sect4" id="idm45611979289096">&#13;
<h4>Service mesh (Istio)</h4>&#13;
&#13;
<p>Istio’s CA creates SVIDs for all Service Accounts, encoding a SPIFFE ID in the format <code>spiffe://cluster.local/ns/&lt;namespace&gt;/sa/&lt;service_account&gt;</code>. Therefore, Services in an Istio mesh can leverage SPIFFE-aware &#13;
<span class="keep-together">endpoints</span>.<a data-primary="SPIFFE and SPIRE" data-secondary="integration with service mesh (Istio)" data-type="indexterm" id="idm45611979286552"/><a data-primary="service meshes" data-secondary="SPIFFE and SPIRE integration with Istio" data-type="indexterm" id="idm45611979285528"/><a data-primary="Istio" data-secondary="SPIFFE integration" data-type="indexterm" id="idm45611979284568"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>While service meshes are out of scope for this chapter, many attempt to address the issue of identity and authentication. Most of these attempts include or build on the methods and tooling detailed in this chapter.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other application integration methods" data-type="sect4"><div class="sect4" id="idm45611979282040">&#13;
<h4>Other application integration methods</h4>&#13;
&#13;
<p>In addition to the primary methods<a data-primary="SPIFFE and SPIRE" data-secondary="other application integration methods" data-type="indexterm" id="idm45611979280696"/> just discussed, SPIRE also supports the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Pulling SVIDs and trust bundles directly to a filesystem, enabling&#13;
applications to detect changes and reload. While this enables applications to&#13;
be somewhat agnostic to SPIRE, it also opens an attack vector for&#13;
certificates to be stolen from the filesystem.</p>&#13;
</li>&#13;
<li>&#13;
<p>Nginx module that allows for certificates to be streamed from SPIRE (similiar&#13;
to the Envoy integration described earlier). There are custom modules for Nginx&#13;
that enable users to specify the SPIFFE IDs that should be allowed to connect&#13;
to the server.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Integration with secrets store (Vault)" data-type="sect4"><div class="sect4" id="idm45611979276520">&#13;
<h4>Integration with secrets store (Vault)</h4>&#13;
&#13;
<p>SPIRE can be used to solve the secure introduction problem when an application needs<a data-primary="Vault" data-secondary="SPIFFE and SPIRE integration" data-type="indexterm" id="idm45611979275224"/><a data-primary="SPIFFE and SPIRE" data-secondary="integration with secrets store (Vault)" data-type="indexterm" id="idm45611979274184"/> to obtain some shared secret material from <a href="https://www.vaultproject.io">HashiCorp Vault</a>. Vault can be configured to authenticate clients using OIDC federation with the SPIRE server as an OIDC provider.</p>&#13;
&#13;
<p>Roles in Vault can be bound to specific subjects (SPIFFE IDs) so that when a workload requests a JWT SVID from SPIRE, that is valid to obtain a role and therefore accessor credentials to Vault.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Integration with AWS" data-type="sect4"><div class="sect4" id="idm45611979271352">&#13;
<h4>Integration with AWS</h4>&#13;
&#13;
<p>SPIRE can also be used to establish identity and authenticate to AWS services. This process utilizes the same OIDC federation idea in the AWS IRSA and Vault sections. Workloads request JWT SVIDs that are then verified by AWS by validating against the federated OIDC provider (SPIRE server). <a data-primary="SPIFFE and SPIRE" data-secondary="integration with AWS" data-type="indexterm" id="idm45611979269496"/><a data-primary="AWS (Amazon Web Services)" data-secondary="SPIRE integration with" data-type="indexterm" id="idm45611979268520"/><a data-primary="platform mediated Node identity" data-secondary="cross-platform identity with SPIFFE and SPIRE" data-startref="ix_pltIDcrs" data-type="indexterm" id="idm45611979267608"/><a data-primary="cross-platform identity with SPIFFE and SPIRE" data-startref="ix_crspltID" data-type="indexterm" id="idm45611979266280"/><a data-primary="JSON Web Key Set (JWKS)" data-type="indexterm" id="idm45611979265304"/><a data-primary="JSON Web Tokens (JWT)" data-type="indexterm" id="idm45611979264632"/>The downside of this approach is that SPIRE must be publicly accessible for AWS to discover the JSON Web Key Set (JWKS) material required to validate the JWTs.<a data-primary="SPIFFE and SPIRE" data-startref="ix_SPIFF" data-type="indexterm" id="idm45611979263656"/><a data-primary="application/workload identity" data-secondary="platform mediated Node identity" data-startref="ix_appwkpltcrs" data-tertiary="cross-platform identity with SPIFFE and SPIRE" data-type="indexterm" id="idm45611979243048"/><a data-primary="platform mediated Node identity" data-startref="ix_pltID" data-type="indexterm" id="idm45611979241496"/><a data-primary="application/workload identity" data-secondary="platform mediated Node identity" data-startref="ix_appwkplt" data-type="indexterm" id="idm45611979240536"/><a data-primary="identity" data-secondary="application/workload" data-startref="ix_IDAWplt" data-tertiary="platform mediated Node identity" data-type="indexterm" id="idm45611979239288"/><a data-primary="identity" data-secondary="application/workload" data-startref="ix_IDAW" data-type="indexterm" id="idm45611979237784"/><a data-primary="application/workload identity" data-startref="ix_appwk" data-type="indexterm" id="idm45611979236568"/></p>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45611980769976">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we have dived into the patterns and tooling that we have successfully seen and implemented in the field.</p>&#13;
&#13;
<p>Identity is a multilayered topic, and your approach will evolve over time as you become more comfortable with the complexity of the different patterns and how that fits with each individual organization’s requirements. Typically on the user identity side you will already have a third-party SSO of some kind, but directly integrating this into Kubernetes via OIDC might seem nontrivial. In these situations we’ve seen Kubernetes sit <em>outside</em> of the main organizational identity strategy. Depending on requirements this may be fine, but integrating directly will give greater visibility and control over environments, especially those with multiple clusters.</p>&#13;
&#13;
<p>On the workload/application side we have often experienced this being treated as an afterthought (beyond default Service Accounts). Again, depending on internal requirements this may be fine. It’s definitely true that implementing a robust solution for workload identity both in-cluster and cross-platform introduces (in some cases) significant complexity and requires deeper knowledge of external tooling. However, when organizations reach a level of maturity with Kubernetes, we think implementing the patterns described in this chapter can significantly increase the security posture of your Kubernetes environments and provide additional layers of defense in depth should breaches occur.<a data-primary="identity" data-startref="ix_ID" data-type="indexterm" id="idm45611979231832"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>