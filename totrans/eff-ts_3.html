<html><head></head><body><section data-pdf-bookmark="Chapter 3. Type Inference" data-type="chapter" epub:type="chapter" class="praise"><div class="praise" id="ch-inference">
<h1 class="calibre14"><span class="calibre">Chapter 3. </span>Type Inference</h1>


<p class="author1">For<a data-primary="statically typed languages" data-type="indexterm" id="idm45331667284184" class="calibre9"/><a data-primary="explicitly typed languages" data-type="indexterm" id="idm45331667283320" class="calibre9"/> programming languages used in industry, “statically typed” and “explicitly typed” have<a data-primary="C++" data-type="indexterm" id="idm45331667282408" class="calibre9"/> traditionally been synonymous. C, C++, Java: they all made you write out your types. But academic languages never conflated these two things: languages like ML and Haskell have long had sophisticated type inference systems, and in the past decade this has begun to work its way into industry languages. C++ has added <code class="calibre18">auto</code>, and<a data-primary="Java" data-secondary="addition of var" data-type="indexterm" id="idm45331667280888" class="calibre9"/> Java has added <code class="calibre18">var</code>.</p>

<p class="author1">TypeScript makes extensive use of type inference. Used well, this can dramatically reduce the number of type annotations your code requires to get full type safety. One of the easiest ways to tell a TypeScript beginner from a more experienced user is by the number of type annotations. An experienced TypeScript developer will use relatively few annotations (but use them to great effect), while a beginner may drown their code in redundant type annotations.</p>

<p class="author1">This chapter shows you some of the problems that can arise with type inference and how to fix them. After reading it, you should have a good understanding of how TypeScript infers types, when you still need to write type declarations, and when it’s a good idea to write type declarations even when a type can be inferred.</p>






<section data-pdf-bookmark="Item 19: Avoid Cluttering Your Code with Inferable Types" data-type="sect1" class="praise"><div class="praise" id="avoid-inferable">
<h1 class="calibre16">Item 19: Avoid Cluttering Your Code with Inferable Types</h1>

<p class="author1">The<a data-primary="type inference" data-secondary="benefits of inferable types" data-type="indexterm" id="TIbene03" class="calibre9"/><a data-primary="TypeScript" data-secondary="type inference in" data-type="indexterm" id="TStinf03" class="calibre9"/><a data-primary="inferable types" data-type="indexterm" id="infertype03" class="calibre9"/><a data-primary="type annotations" data-secondary="avoiding cluttered code" data-type="indexterm" id="tannot03" class="calibre9"/> first thing that many new TypeScript developers do when they convert a codebase from JavaScript is fill it with type annotations. TypeScript is about <em class="calibre3">types</em>, after all! But in TypeScript many annotations are unnecessary. Declaring types for all your variables is counterproductive and is considered poor style.</p>

<p class="author1">Don’t write:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">x</code>: <code class="nx">number</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code></pre>

<p class="author1">Instead, just write:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code></pre>

<p class="author1">If you mouse over <code class="calibre18">x</code> in your editor, you’ll see that its type has been inferred as <code class="calibre18">number</code> (as shown in <a data-type="xref" href="#efts-3in1" class="calibre9">Figure 3-1</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-3in1">
<img alt="efts 03in01" src="assets/efts_03in01.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 3-1. </span>A text editor showing that the inferred type of x is number.</h6>
</div></figure>

<p class="author1">The explicit type annotation is redundant. Writing it just adds noise. If you’re unsure of the type, you can check it in your editor.</p>

<p class="author1">TypeScript<a data-primary="Truth, Sojourner" data-type="indexterm" id="idm45331667198952" class="calibre9"/> will also infer the types of more complex objects. Instead of:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">person</code><code class="o">:</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">born</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">when</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="p">};</code>
  <code class="nx">died</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">when</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Sojourner Truth'</code><code class="p">,</code>
  <code class="nx">born</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Swartekill, NY'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'c.1797'</code><code class="p">,</code>
  <code class="p">},</code>
  <code class="nx">died</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Battle Creek, MI'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'Nov. 26, 1883'</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

<p class="author1">you can just write:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Sojourner Truth'</code><code class="p">,</code>
  <code class="nx">born</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Swartekill, NY'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'c.1797'</code><code class="p">,</code>
  <code class="p">},</code>
  <code class="nx">died</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">where</code><code class="o">:</code> <code class="s">'Battle Creek, MI'</code><code class="p">,</code>
    <code class="nx">when</code><code class="o">:</code> <code class="s">'Nov. 26, 1883'</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

<p class="author1">Again, the types are exactly the same. Writing the type in addition to the value just adds noise here. (<a href="#widening" class="calibre9">Item 21</a> has more to say on the types inferred for object literals.)</p>

<p class="author1">What’s true for objects is also true for arrays. TypeScript has no trouble figuring out the return type of this function based on its inputs and operations:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">nums</code>: <code class="nx">number</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">nums</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">squares</code> <code class="o">=</code> <code class="nx">square</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]);</code> <code class="c">// Type is number[]</code></pre>

<p class="author1">TypeScript may infer something more precise than what you expected. This is generally a good thing. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">axis1</code>: <code class="kd">string</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>  <code class="c">// Type is string</code>
<code class="kd">const</code> <code class="nx">axis2</code> <code class="o">=</code> <code class="s">'y'</code><code class="p">;</code>  <code class="c">// Type is "y"</code></pre>

<p class="author1"><code class="calibre18">"y"</code> is a more precise type for the <code class="calibre18">axis</code> variable. <a href="#widening" class="calibre9">Item 21</a> gives an example of how this can fix a type error.</p>

<p class="author1">Allowing types to be inferred can also facilitate refactoring. Say you have a <code class="calibre18">Product</code> type and a function to log it:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Product</code> <code class="p">{</code>
  <code class="nx">id</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">price</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">id</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">price</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">price</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">At some point you learn that product IDs might have letters in them in addition to numbers. So you change the type of <code class="calibre18">id</code> in <code class="calibre18">Product</code>. Because you included explicit annotations on all the variables in <code class="calibre18">logProduct</code>, this produces an error:</p>

<pre data-code-language="ts" data-type="programlisting" id="inferable-product" class="calibre17"><code class="kd">interface</code> <code class="nx">Product</code> <code class="p">{</code>
  <code class="nx">id</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">price</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">id</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>
     <code class="c">// ~~ Type 'string' is not assignable to type 'number'</code>
  <code class="kd">const</code> <code class="nx">name</code>: <code class="kd">string</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">price</code>: <code class="nx">number</code> <code class="o">=</code> <code class="nx">product</code><code class="p">.</code><code class="nx">price</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">Had you left off all the annotations in the <code class="calibre18">logProduct</code> function body, the code would have passed the type checker without modification.</p>

<p class="author1">A better implementation of <code class="calibre18">logProduct</code> would use destructuring assignment (<a href="ch08.html#write-modern-js" class="calibre9">Item 58</a>):</p>

<pre data-code-language="ts" data-type="programlisting" id="log-product" class="calibre17"><code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">}</code> <code class="o">=</code> <code class="nx">product</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">This version allows the types of all the local variables to be inferred. The corresponding version with explicit type annotations is repetitive and cluttered:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">logProduct</code><code class="p">(</code><code class="nx">product</code>: <code class="nx">Product</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">}</code><code class="o">:</code> <code class="p">{</code><code class="nx">id</code>: <code class="kd">string</code><code class="p">;</code> <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code> <code class="nx">price</code>: <code class="nx">number</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">product</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">price</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">Explicit type annotations are still required in some situations where TypeScript doesn’t have enough context to determine a type on its own. You have seen one of these before: function parameters.</p>

<p class="author1">Some languages will infer types for parameters based on their eventual usage, but TypeScript does not. In TypeScript, a variable’s type is generally determined when it is first introduced.</p>

<p class="author1">Ideal TypeScript code includes type annotations for function/method signatures but not for the local variables created in their bodies. This keeps noise to a minimum and lets readers focus on the implementation logic.</p>

<p class="author1">There are some situations where you can leave the type annotations off of function parameters, too. When there’s a default value, for example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseNumber</code><code class="p">(</code><code class="nx">str</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">base</code><code class="o">=</code><code class="mi">10</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">Here the type of <code class="calibre18">base</code> is inferred as <code class="calibre18">number</code> because of the default value of <code class="calibre18">10</code>.</p>

<p class="author1">Parameter types can usually be inferred when the function is used as a callback for a library with type declarations. The declarations on <code class="calibre18">request</code> and <code class="calibre18">response</code> in this example using the express HTTP server library are not required:</p>

<pre data-code-language="ts" data-type="programlisting" id="express-example" class="calibre17"><code class="c">// Don't do this:</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'/health'</code><code class="p">,</code> <code class="p">(</code><code class="nx">request</code>: <code class="nx">express.Request</code><code class="p">,</code> <code class="nx">response</code>: <code class="nx">express.Response</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">response</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s">'OK'</code><code class="p">);</code>
<code class="p">});</code>

<code class="c">// Do this:</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'/health'</code><code class="p">,</code> <code class="p">(</code><code class="nx">request</code><code class="p">,</code> <code class="nx">response</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">response</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s">'OK'</code><code class="p">);</code>
<code class="p">});</code></pre>

<p class="author1"><a href="#context-inference" class="calibre9">Item 26</a> goes into more depth on how context is used in type inference.</p>

<p class="author1">There are a few situations where you may still want to specify a type even where it can be inferred.</p>

<p class="author1">One is when you define an object literal:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">elmo</code>: <code class="nx">Product</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Tickle Me Elmo'</code><code class="p">,</code>
  <code class="nx">id</code><code class="o">:</code> <code class="s">'048188 627152'</code><code class="p">,</code>
  <code class="nx">price</code>: <code class="nx">28.99</code><code class="p">,</code>
<code class="p">};</code></pre>

<p class="author1">When you specify a type on a definition like this, you enable excess property checking (<a href="ch02_split_001.html#excess-property-checking" class="calibre9">Item 11</a>). This can help catch errors, particularly for types with optional fields.</p>

<p class="author1">You also increase the odds that an error will be reported in the right place. If you leave off the annotation, a mistake in the object’s definition will result in a type error where it’s used, rather than where it’s defined:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">furby</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'Furby'</code><code class="p">,</code>
  <code class="nx">id</code>: <code class="nx">630509430963</code><code class="p">,</code>
  <code class="nx">price</code>: <code class="nx">35</code><code class="p">,</code>
<code class="p">};</code>
<code class="nx">logProduct</code><code class="p">(</code><code class="nx">furby</code><code class="p">);</code>
        <code class="c">// ~~~~~ Argument .. is not assignable to parameter of type 'Product'</code>
        <code class="c">//         Types of property 'id' are incompatible</code>
        <code class="c">//         Type 'number' is not assignable to type 'string'</code></pre>

<p class="author1">With an annotation, you get a more concise error in the place where the mistake was made:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"> <code class="kd">const</code> <code class="nx">furby</code>: <code class="nx">Product</code> <code class="o">=</code> <code class="p">{</code>
   <code class="nx">name</code><code class="o">:</code> <code class="s">'Furby'</code><code class="p">,</code>
   <code class="nx">id</code>: <code class="nx">630509430963</code><code class="p">,</code>
<code class="c">// ~~ Type 'number' is not assignable to type 'string'</code>
   <code class="nx">price</code>: <code class="nx">35</code><code class="p">,</code>
 <code class="p">};</code>
 <code class="nx">logProduct</code><code class="p">(</code><code class="nx">furby</code><code class="p">);</code></pre>

<p class="author1">Similar considerations apply to a function’s return type. You may still want to annotate this even when it can be inferred to ensure that implementation errors don’t leak out into uses of the function.</p>

<p class="author1">Say you have a function which retrieves a stock quote:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getQuote</code><code class="p">(</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">`https://quotes.example.com/?q=</code><code class="si">${</code><code class="nx">ticker</code><code class="si">}</code><code class="s">`</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>
<code class="p">}</code></pre>

<p class="author1">You decide to add a cache to avoid duplicating network requests:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">function</code> <code class="nx">getQuote</code><code class="p">(</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">ticker</code> <code class="kd">in</code> <code class="nx">cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">cache</code><code class="p">[</code><code class="nx">ticker</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="s">`https://quotes.example.com/?q=</code><code class="si">${</code><code class="nx">ticker</code><code class="si">}</code><code class="s">`</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>
      <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">quote</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">cache</code><code class="p">[</code><code class="nx">ticker</code><code class="p">]</code> <code class="o">=</code> <code class="nx">quote</code><code class="p">;</code>
        <code class="kd">return</code> <code class="nx">quote</code><code class="p">;</code>
      <code class="p">});</code>
<code class="p">}</code></pre>

<p class="author1">There’s a mistake in this implementation: you should really be returning <code class="calibre18">Promise.resolve(cache[ticker])</code> so that <code class="calibre18">getQuote</code> always returns a Promise. The mistake will most likely produce an error…but in the code that calls <code class="calibre18">getQuote</code>, rather than in <code class="calibre18">getQuote</code> itself:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">getQuote</code><code class="p">(</code><code class="s">'MSFT'</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">considerBuying</code><code class="p">);</code>
              <code class="c">// ~~~~ Property 'then' does not exist on type</code>
              <code class="c">//        'number | Promise&lt;any&gt;'</code>
              <code class="c">//      Property 'then' does not exist on type 'number'</code></pre>

<p class="author1">Had you annotated the intended return type (<code class="calibre18">Promise&lt;number&gt;</code>), the error would have been reported in the correct place:</p>

<pre data-code-language="ts" data-type="programlisting" id="get-quote-error" class="calibre17"><code class="kd">const</code> <code class="nx">cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">function</code> <code class="nx">getQuote</code><code class="p">(</code><code class="nx">ticker</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">ticker</code> <code class="kd">in</code> <code class="nx">cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">cache</code><code class="p">[</code><code class="nx">ticker</code><code class="p">];</code>
        <code class="c">// ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">When you annotate the return type, it keeps implementation errors from manifesting as errors in user code. (See <a href="#use-async-await" class="calibre9">Item 25</a> for a discussion of async functions, which are an effective way to avoid this specific error with Promises.)</p>

<p class="author1">Writing out the return type may also help you think more clearly about your function: you should know what its input and output types are <em class="calibre3">before you implement it</em>. While the implementation may shift around a bit, the function’s contract (its type signature) generally should not. This<a data-primary="test-driven development (TDD)" data-type="indexterm" id="idm45331666073672" class="calibre9"/> is similar in spirit to test-driven development (TDD), in which you write the tests that exercise a function before you implement it. Writing the full type signature first helps get you the function you want, rather than the one the implementation makes expedient.</p>

<p class="author1">A final reason to annotate return values is if you want to use a named type. You might choose not to write a return type for this function, for example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector2D</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">Vector2D</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">Vector2D</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">a.x</code> <code class="o">+</code> <code class="nx">b</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">a.y</code> <code class="o">+</code> <code class="nx">b</code><code class="p">.</code><code class="nx">y</code> <code class="p">};</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript infers the return type as <code class="calibre18">{ x: number; y: number; }</code>. This is compatible with <code class="calibre18">Vector2D</code>, but it may be surprising to users of your code when they see <code class="calibre18">Vector2D</code> as a type of the input and not of the output (as shown in <a data-type="xref" href="#efts-03in02" class="calibre9">Figure 3-2</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-03in02">
<img alt="efts 03in02" src="assets/efts_03in02.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 3-2. </span>The parameters to the add function have named types, while the inferred return value does not.</h6>
</div></figure>

<p class="author1">If you annotate the return type, the presentation is more straightforward. And if you’ve written documentation on the type (<a href="ch06.html#use-tsdoc" class="calibre9">Item 48</a>) then it will be associated with the returned value as well. As the complexity of the inferred return type increases, it becomes increasingly helpful to provide a name.</p>

<p class="author1">If you are using a linter, the<a data-primary="eslint" data-type="indexterm" id="idm45331665997144" class="calibre9"/> eslint rule <code class="calibre18">no-inferrable-types</code> (note the variant spelling) can help ensure that all your type annotations are really necessary.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331665995656">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Avoid writing type annotations when TypeScript can infer the same type.</p>
</li>
<li class="calibre12">
<p class="author1">Ideally your code has type annotations in function/method signatures but not on local variables in their bodies.</p>
</li>
<li class="calibre12">
<p class="author1">Consider using explicit annotations for object literals and function return types even when they can be inferred. This will help prevent implementation errors from surfacing in user code.<a data-primary="" data-startref="TIbene03" data-type="indexterm" id="idm45331665991352" class="calibre9"/><a data-primary="" data-startref="TStinf03" data-type="indexterm" id="idm45331665990376" class="calibre9"/><a data-primary="" data-startref="infertype03" data-type="indexterm" id="idm45331665989432" class="calibre9"/><a data-primary="" data-startref="tannot03" data-type="indexterm" id="idm45331665988488" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 20: Use Different Variables for Different Types" data-type="sect1" class="praise"><div class="praise" id="one-var-one-type">
<h1 class="calibre16">Item 20: Use Different Variables for Different Types</h1>

<p class="author1">In<a data-primary="type inference" data-secondary="avoiding variable reuse" data-type="indexterm" id="TIreuse03" class="calibre9"/><a data-primary="variables" data-secondary="avoiding reuse for different types" data-type="indexterm" id="Vreuse03" class="calibre9"/> JavaScript it’s no problem to reuse a variable to hold a differently typed value for a different purpose:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// Expects a string</code>

<code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>
<code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// Expects a number</code></pre>

<p class="author1">In TypeScript, this results in two errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17">   <code class="kd">let</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
   <code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

   <code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>
<code class="c">// ~~ '123456' is not assignable to type 'string'.</code>
   <code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>
                           <code class="c">// ~~ Argument of type 'string' is not assignable to</code>
                           <code class="c">//    parameter of type 'number'</code></pre>

<p class="author1">Hovering over the first <code class="calibre18">id</code> in your editor gives a hint as to what’s going on (see <a data-type="xref" href="#efts-03in03" class="calibre9">Figure 3-3</a>).</p>

<figure class="calibre28"><div class="figure" id="efts-03in03">
<img alt="efts 03in03" src="assets/efts_03in03.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 3-3. </span>The inferred type of id is string.</h6>
</div></figure>

<p class="author1">Based on the value <code class="calibre18">"12-34-56"</code>, TypeScript has inferred <code class="calibre18">id</code>’s type as <code class="calibre18">string</code>. You can’t assign a <code class="calibre18">number</code> to a <code class="calibre18">string</code> and hence the error.</p>

<p class="author1">This leads us to a key insight about variables in TypeScript: <em class="calibre3">while a variable’s value can change, its type generally does not</em>. The one common way a type can change is to narrow (<a href="#narrowing" class="calibre9">Item 22</a>), but this involves a type getting smaller, not expanding to include new values. There are some important exceptions to this rule (<a href="ch05.html#evolving-any" class="calibre9">Item 41</a>), but they are the exceptions and not the rule.</p>

<p class="author1">How can you use this idea to fix the example? In order for <code class="calibre18">id</code>’s type to not change, it must be broad enough to encompass both <code class="calibre18">string</code>s and <code class="calibre18">number</code>s. This<a data-primary="union types" data-secondary="purpose of" data-type="indexterm" id="idm45331665881016" class="calibre9"/> is the very definition of the union type, <code class="calibre18">string|number</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">id</code>: <code class="kd">string</code><code class="o">|</code><code class="kt">number</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

<code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">This fixes the errors. It’s interesting that TypeScript has been able to determine that <code class="calibre18">id</code> is really a <code class="calibre18">string</code> in the first call and really a <code class="calibre18">number</code> in the second. It has narrowed the union type based on the assignment.</p>

<p class="author1">While a union type does work, it may create more issues down the road. Union types are harder to work with than simple types like <code class="calibre18">string</code> or <code class="calibre18">number</code> because you usually have to check what they are before you do anything with them.</p>

<p class="author1">The better solution is to introduce a new variable:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

<code class="kd">const</code> <code class="nx">serial</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">serial</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">In the previous version, the first and second <code class="calibre18">id</code> were not semantically related to one another. They were only related by the fact that you reused a variable. This was confusing for the type checker and would be confusing for a human reader, too.</p>

<p class="author1">The version with two variables is better for a number of reasons:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">It disentangles two unrelated concepts (ID and serial number).</p>
</li>
<li class="calibre12">
<p class="author1">It allows you to use more specific variable names.</p>
</li>
<li class="calibre12">
<p class="author1">It improves type inference. No type annotations are needed.</p>
</li>
<li class="calibre12">
<p class="author1">It results in simpler types (<code class="calibre18">string</code> and <code class="calibre18">number</code>, rather than <code class="calibre18">string|number</code>).</p>
</li>
<li class="calibre12">
<p class="author1">It lets you declare the variables <code class="calibre18">const</code> rather than <code class="calibre18">let</code>. This makes them easier for people and the type checker to reason about.</p>
</li>
</ul>

<p class="author1">Try to avoid type-changing variables. If you can use different names for different concepts, it will make your code clearer both to human readers and to the type checker.</p>

<p class="author1">This is not to be confused with “shadowed” variables as in this example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="s">"12-34-56"</code><code class="p">;</code>
<code class="nx">fetchProduct</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>

<code class="p">{</code>
  <code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="mi">123456</code><code class="p">;</code>  <code class="c">// OK</code>
  <code class="nx">fetchProductBySerialNumber</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

<p class="author1">While these two <code class="calibre18">id</code>s share a name, they are actually two distinct variables with no relationship to one another. It’s fine for them to have different types. While TypeScript is not confused by this, your human readers might be. In general it’s better to use different names for different concepts. Many teams choose to disallow this sort of shadowing via linter rules.</p>

<p class="author1">This item focused on scalar values, but similar considerations apply to objects. For more on that, see <a href="#all-at-once" class="calibre9">Item 23</a>.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331665718328">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">While a variable’s value can change, its type generally does not.</p>
</li>
<li class="calibre12">
<p class="author1">To avoid confusion, both for human readers and for the type checker, avoid reusing variables for differently typed values.<a data-primary="" data-startref="TIreuse03" data-type="indexterm" id="idm45331665715048" class="calibre9"/><a data-primary="" data-startref="Vreuse03" data-type="indexterm" id="idm45331665714072" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 21: Understand Type Widening" data-type="sect1" class="praise"><div class="praise" id="widening">
<h1 class="calibre16">Item 21: Understand Type Widening</h1>

<p class="author1">As<a data-primary="type inference" data-secondary="type widening" data-type="indexterm" id="TIwiden03" class="calibre9"/><a data-primary="type widening" data-type="indexterm" id="twiden03" class="calibre9"/><a data-primary="widening" data-type="indexterm" id="widen03" class="calibre9"/> <a href="ch02_split_000.html#types-as-sets" class="calibre9">Item 7</a> explained, at runtime every variable has a single value. But at static analysis time, when TypeScript is checking your code, a variable has a set of <em class="calibre3">possible</em> values, namely, its type. When you initialize a variable with a constant but don’t provide a type, the type checker needs to decide on one. In other words, it needs to decide on a set of possible values from the single value that you specified. In TypeScript, this process is known as <em class="calibre3">widening</em>. Understanding<a data-primary="type annotations" data-secondary="using more effectively" data-type="indexterm" id="idm45331665705512" class="calibre9"/> it will help you make sense of errors and make more effective use of type annotations.</p>

<p class="author1">Suppose you’re writing a library to work with vectors. You write out a type for a 3D vector and a function to get the value of any of its components:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Vector3</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">getComponent</code><code class="p">(</code><code class="nx">vector</code>: <code class="nx">Vector3</code><code class="p">,</code> <code class="nx">axis</code><code class="o">:</code> <code class="s">'x'</code> <code class="o">|</code> <code class="s">'y'</code> <code class="o">|</code> <code class="s">'z'</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">vector</code><code class="p">[</code><code class="nx">axis</code><code class="p">];</code>
<code class="p">}</code></pre>

<p class="author1">But when you try to use it, TypeScript flags an error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">vec</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">10</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">20</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">30</code><code class="p">};</code>
<code class="nx">getComponent</code><code class="p">(</code><code class="nx">vec</code><code class="p">,</code> <code class="nx">x</code><code class="p">);</code>
               <code class="c">// ~ Argument of type 'string' is not assignable to</code>
               <code class="c">//   parameter of type '"x" | "y" | "z"'</code></pre>

<p class="author1">This code runs fine, so why the error?</p>

<p class="author1">The issue is that <code class="calibre18">x</code>’s type is inferred as <code class="calibre18">string</code>, whereas the <code class="calibre18">getComponent</code> function expected a more specific type for its second argument. This is widening at work, and here it has led to an error.</p>

<p class="author1">This<a data-primary="const" data-secondary="need for context" data-type="indexterm" id="idm45331665615064" class="calibre9"/> process is ambiguous in the sense that there are many possible types for any given value. In this statement, for example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">mixed</code> <code class="o">=</code> <code class="p">[</code><code class="s">'x'</code><code class="p">,</code> <code class="mi">1</code><code class="p">];</code></pre>

<p class="author1">what should the type of <code class="calibre18">mixed</code> be? Here are a few possibilities:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1"><code class="calibre18">('x' | 1)[]</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">['x', 1]</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">[string, number]</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">readonly [string, number]</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">(string|number)[]</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">readonly (string|number)[]</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">[any, any]</code></p>
</li>
<li class="calibre12">
<p class="author1"><code class="calibre18">any[]</code></p>
</li>
</ul>

<p class="author1">Without<a data-primary="context" data-type="indexterm" id="idm45331665576904" class="calibre9"/> more context, TypeScript has no way to know which one is “right.” It has to guess at your intent. (In this case, it guesses <code class="calibre18">(string|number)[]</code>.) And smart as it is, TypeScript can’t read your mind. It won’t get this right 100% of the time. The result is inadvertent errors like the one we just looked at.</p>

<p class="author1">In the initial example, the type of <code class="calibre18">x</code> is inferred as <code class="calibre18">string</code> because TypeScript chooses to allow code like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="s">'a'</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="s">'Four score and seven years ago...'</code><code class="p">;</code></pre>

<p class="author1">But it would also be valid JavaScript to write:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="sr">/x|y|z/</code><code class="p">;</code>
<code class="nx">x</code> <code class="o">=</code> <code class="p">[</code><code class="s">'x'</code><code class="p">,</code> <code class="s">'y'</code><code class="p">,</code> <code class="s">'z'</code><code class="p">];</code></pre>

<p class="author1">In inferring the type of <code class="calibre18">x</code> as <code class="calibre18">string</code>, TypeScript attempts to strike a balance between specificity and flexibility. The general rule is that a variable’s type shouldn’t change after it’s declared (<a href="#one-var-one-type" class="calibre9">Item 20</a>), so <code class="calibre18">string</code> makes more sense than <code class="calibre18">string|RegExp</code> or <code class="calibre18">string|string[]</code> or <code class="calibre18">any</code>.</p>

<p class="author1">TypeScript gives you a few ways to control the process of widening. One is <code class="calibre18">const</code>. If you declare a variable with <code class="calibre18">const</code> instead of <code class="calibre18">let</code>, it gets a narrower type. In fact, using <code class="calibre18">const</code> fixes the error in our original example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="s">'x'</code><code class="p">;</code>  <code class="c">// type is "x"</code>
<code class="kd">let</code> <code class="nx">vec</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">10</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">20</code><code class="p">,</code> <code class="nx">z</code>: <code class="nx">30</code><code class="p">};</code>
<code class="nx">getComponent</code><code class="p">(</code><code class="nx">vec</code><code class="p">,</code> <code class="nx">x</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">Because <code class="calibre18">x</code> cannot be reassigned, TypeScript is able to infer a narrower type without risk of inadvertently flagging errors on subsequent assignments. And because the string literal type <code class="calibre18">"x"</code> is assignable to <code class="calibre18">"x"|"y"|"z"</code>, the code passes the type checker.</p>

<p class="author1"><code class="calibre18">const</code> isn’t a panacea, however. For objects and arrays, there is still ambiguity. The <code class="calibre18">mixed</code> example here illustrates the issue for arrays: should TypeScript infer a tuple type? What type should it infer for the elements? Similar issues arise with objects. This code is fine in JavaScript:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
<code class="p">};</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="s">'3'</code><code class="p">;</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="nx">v</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'Pythagoras'</code><code class="p">;</code></pre>

<p class="author1">The type of <code class="calibre18">v</code> could be inferred anywhere along the spectrum of specificity. At the specific end is <code class="calibre18">{readonly x: 1}</code>. More general is <code class="calibre18">{x: number}</code>. More general still would be <code class="calibre18">{[key: string]: number}</code> or <code class="calibre18">object</code>. In the case of objects, TypeScript’s widening algorithm treats each element as though it were assigned with <code class="calibre18">let</code>. So the type of <code class="calibre18">v</code> comes out as <code class="calibre18">{x: number}</code>. This lets you reassign <code class="calibre18">v.x</code> to a different number, but not to a <code class="calibre18">string</code>. And it prevents you from adding other properties. (This is a good reason to build objects all at once, as explained in <a href="#all-at-once" class="calibre9">Item 23</a>.)</p>

<p class="author1">So the last three statements are errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"> <code class="kd">const</code> <code class="nx">v</code> <code class="o">=</code> <code class="p">{</code>
   <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
 <code class="p">};</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>  <code class="c">// OK</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="s">'3'</code><code class="p">;</code>
<code class="c">// ~ Type '"3"' is not assignable to type 'number'</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="c">// ~ Property 'y' does not exist on type '{ x: number; }'</code>
 <code class="nx">v</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'Pythagoras'</code><code class="p">;</code>
<code class="c">// ~~~~ Property 'name' does not exist on type '{ x: number; }'</code></pre>

<p class="author1">Again, TypeScript is trying to strike a balance between specificity and flexibility. It needs to infer a specific enough type to catch errors, but not so specific that it creates false positives. It does this by inferring a type of <code class="calibre18">number</code> for a property initialized to a value like <code class="calibre18">1</code>.</p>

<p class="author1">If you know better, there are a few ways to override TypeScript’s default behavior. One is to supply an explicit type annotation:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">v</code><code class="o">:</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">1</code><code class="o">|</code><code class="mi">3</code><code class="o">|</code><code class="mi">5</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// Type is { x: 1 | 3 | 5; }</code></pre>

<p class="author1">Another is to provide additional context to the type checker (e.g., by passing the value as the parameter of a function). For much more on the role of context in type inference, see <a href="#context-inference" class="calibre9">Item 26</a>.</p>

<p class="author1">A<a data-primary="as const" data-type="indexterm" id="idm45331665275912" class="calibre9"/><a data-primary="const assertion" data-type="indexterm" id="idm45331665275208" class="calibre9"/> third way is with a <code class="calibre18">const</code> assertion. This is not to be confused with <code class="calibre18">let</code> and <code class="calibre18">const</code>, which introduce symbols in value space. This is a purely type-level construct. Look at the different inferred types for these variables:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">v1</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// Type is { x: number; y: number; }</code>

<code class="kd">const</code> <code class="nx">v2</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// Type is { x: 1; y: number; }</code>

<code class="kd">const</code> <code class="nx">v3</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">}</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>  <code class="c">// Type is { readonly x: 1; readonly y: 2; }</code></pre>

<p class="author1">When you write <code class="calibre18">as const</code> after a value, TypeScript will infer the narrowest possible type for it. There is <em class="calibre3">no</em> widening. For true constants, this is typically what you want. You can also use <code class="calibre18">as const</code> with arrays to infer a tuple type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">a1</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>  <code class="c">// Type is number[]</code>
<code class="kd">const</code> <code class="nx">a2</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>  <code class="c">// Type is readonly [1, 2, 3]</code></pre>

<p class="author1">If you’re getting incorrect errors that you think are due to widening, consider adding some explicit type annotations or <code class="calibre18">const</code> assertions. Inspecting types in your editor is the key to building an intuition for this (see <a href="ch02_split_000.html#editor" class="calibre9">Item 6</a>).</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331665109528">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Understand how TypeScript infers a type from a constant by widening it.</p>
</li>
<li class="calibre12">
<p class="author1">Familiarize yourself with the ways you can affect this behavior: <code class="calibre18">const</code>, type annotations, context, and <code class="calibre18">as const</code>.<a data-primary="" data-startref="TIwiden03" data-type="indexterm" id="idm45331665105624" class="calibre9"/><a data-primary="" data-startref="twiden03" data-type="indexterm" id="idm45331665077592" class="calibre9"/><a data-primary="" data-startref="widen03" data-type="indexterm" id="idm45331665076648" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 22: Understand Type Narrowing" data-type="sect1" class="praise"><div class="praise" id="narrowing">
<h1 class="calibre16">Item 22: Understand Type Narrowing</h1>

<p class="author1">The<a data-primary="narrowing" data-type="indexterm" id="idm45331665073336" class="calibre9"/><a data-primary="type inference" data-secondary="type narrowing" data-type="indexterm" id="TInarrow03" class="calibre9"/><a data-primary="type narrowing" data-type="indexterm" id="tnarrow03" class="calibre9"/> opposite of widening is narrowing. This is the process by which TypeScript goes from a broad type to a narrower one. Perhaps the most common example of this is null checking:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// Type is HTMLElement | null</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">el</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code> <code class="c">// Type is HTMLElement</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="s">'Party Time'</code><code class="p">.</code><code class="nx">blink</code><code class="p">();</code>
<code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
  <code class="nx">el</code> <code class="c">// Type is null</code>
  <code class="nx">alert</code><code class="p">(</code><code class="s">'No element #foo'</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">If <code class="calibre18">el</code> is <code class="calibre18">null</code>, then the code in the first branch won’t execute. So TypeScript is able to exclude <code class="calibre18">null</code> from the type union within this block, resulting in a narrower type which is much easier to work with. The type checker is generally quite good at narrowing types in conditionals like these, though it can occasionally be thwarted by aliasing (<a href="#avoid-aliasing" class="calibre9">Item 24</a>).</p>

<p class="author1">You can also narrow a variable’s type for the rest of a block by throwing or returning from a branch. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// Type is HTMLElement | null</code>
<code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">el</code><code class="p">)</code> <code class="kd">throw</code> <code class="kd">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s">'Unable to find #foo'</code><code class="p">);</code>
<code class="nx">el</code><code class="p">;</code> <code class="c">// Now type is HTMLElement</code>
<code class="nx">el</code><code class="p">.</code><code class="nx">innerHTML</code> <code class="o">=</code> <code class="s">'Party Time'</code><code class="p">.</code><code class="nx">blink</code><code class="p">();</code></pre>

<p class="author1">There are many ways that you can narrow a type. Using <code class="calibre18">instanceof</code> works:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">contains</code><code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">search</code>: <code class="kd">string</code><code class="o">|</code><code class="nb">RegExp</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">search</code> <code class="kd">instanceof</code> <code class="nb">RegExp</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">search</code>  <code class="c">// Type is RegExp</code>
    <code class="kd">return</code> <code class="o">!!</code><code class="nx">search</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">search</code>  <code class="c">// Type is string</code>
  <code class="kd">return</code> <code class="nx">text</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">search</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">So does a property check:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">A</code> <code class="p">{</code> <code class="nx">a</code>: <code class="nx">number</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">B</code> <code class="p">{</code> <code class="nx">b</code>: <code class="nx">number</code> <code class="p">}</code>
<code class="kd">function</code> <code class="nx">pickAB</code><code class="p">(</code><code class="nx">ab</code>: <code class="nx">A</code> <code class="o">|</code> <code class="nx">B</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="s">'a'</code> <code class="kd">in</code> <code class="nx">ab</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">ab</code> <code class="c">// Type is A</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">ab</code> <code class="c">// Type is B</code>
  <code class="p">}</code>
  <code class="nx">ab</code> <code class="c">// Type is A | B</code>
<code class="p">}</code></pre>

<p class="author1">Some built-in functions such as <code class="calibre18">Array.isArray</code> are able to narrow types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">contains</code><code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">terms</code>: <code class="kd">string</code><code class="o">|</code><code class="kt">string</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">termList</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">terms</code><code class="p">)</code> <code class="o">?</code> <code class="nx">terms</code> <code class="o">:</code> <code class="p">[</code><code class="nx">terms</code><code class="p">];</code>
  <code class="nx">termList</code> <code class="c">// Type is string[]</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript is generally quite good at tracking types through conditionals. Think twice before adding an assertion—it might be onto something that you’re not! For example, this is the wrong way to exclude <code class="calibre18">null</code> from a union type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'foo'</code><code class="p">);</code> <code class="c">// type is HTMLElement | null</code>
<code class="kd">if</code> <code class="p">(</code><code class="kd">typeof</code> <code class="nx">el</code> <code class="o">===</code> <code class="s">'object'</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">;</code>  <code class="c">// Type is HTMLElement | null</code>
<code class="p">}</code></pre>

<p class="author1">Because <code class="calibre18">typeof null</code> is <code class="calibre18">"object"</code> in JavaScript, you have not, in fact, excluded <code class="calibre18">null</code> with this check! Similar surprises can come from falsy primitive values:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo</code><code class="p">(</code><code class="nx">x?</code>: <code class="nx">number</code><code class="o">|</code><code class="nx">string</code><code class="o">|</code><code class="nx">null</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">x</code><code class="p">;</code>  <code class="c">// Type is string | number | null | undefined</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Because the empty string and <code class="calibre18">0</code> are both falsy, <code class="calibre18">x</code> could still be a <code class="calibre18">string</code> or <code class="calibre18">number</code> in that branch. TypeScript is right!</p>

<p class="author1">Another common way to help the type checker narrow your types is by putting an explicit “tag” on them:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">UploadEvent</code> <code class="p">{</code> <code class="nx">type</code>: <code class="s">'upload'</code><code class="p">;</code> <code class="nx">filename</code>: <code class="kd">string</code><code class="p">;</code> <code class="nx">contents</code>: <code class="kd">string</code> <code class="p">}</code>
<code class="kd">interface</code> <code class="nx">DownloadEvent</code> <code class="p">{</code> <code class="nx">type</code>: <code class="s">'download'</code><code class="p">;</code> <code class="nx">filename</code>: <code class="kd">string</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">type</code> <code class="nx">AppEvent</code> <code class="o">=</code> <code class="nx">UploadEvent</code> <code class="o">|</code> <code class="nx">DownloadEvent</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">handleEvent</code><code class="p">(</code><code class="nx">e</code>: <code class="nx">AppEvent</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">switch</code> <code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">case</code> <code class="s">'download'</code><code class="o">:</code>
      <code class="nx">e</code>  <code class="c">// Type is DownloadEvent</code>
      <code class="kd">break</code><code class="p">;</code>
    <code class="kd">case</code> <code class="s">'upload'</code><code class="o">:</code>
      <code class="nx">e</code><code class="p">;</code>  <code class="c">// Type is UploadEvent</code>
      <code class="kd">break</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">This<a data-primary="tagged unions" data-secondary="example of" data-type="indexterm" id="idm45331664573816" class="calibre9"/><a data-primary="discriminated unions" data-see="tagged unions" data-type="indexterm" id="idm45331664572968" class="calibre9"/> pattern is known as a “tagged union” or “discriminated union,” and it is ubiquitous in TypeScript.</p>

<p class="author1">If TypeScript isn’t able to figure out a type, you can even introduce a custom function to help it out:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isInputElement</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code><code class="o">:</code> <code class="nx">el</code> <code class="nx">is</code> <code class="nx">HTMLInputElement</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">'value'</code> <code class="kd">in</code> <code class="nx">el</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">getElementContent</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">isInputElement</code><code class="p">(</code><code class="nx">el</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">el</code><code class="p">;</code> <code class="c">// Type is HTMLInputElement</code>
    <code class="kd">return</code> <code class="nx">el</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">el</code><code class="p">;</code> <code class="c">// Type is HTMLElement</code>
  <code class="kd">return</code> <code class="nx">el</code><code class="p">.</code><code class="nx">textContent</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This<a data-primary="user-defined type guards" data-type="indexterm" id="idm45331664515768" class="calibre9"/> is known as a “user-defined type guard.” The <code class="calibre18">el is HTMLInputElement</code> as a return type tells the type checker that it can narrow the type of the parameter if the function returns true.</p>

<p class="author1">Some functions are able to use type guards to perform type narrowing across arrays or objects. If you do some lookups in an array, for instance, you may wind up with an array of nullable types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">jackson5</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Jackie'</code><code class="p">,</code> <code class="s">'Tito'</code><code class="p">,</code> <code class="s">'Jermaine'</code><code class="p">,</code> <code class="s">'Marlon'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">];</code>
<code class="kd">const</code> <code class="nx">members</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Janet'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">jackson5</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">===</code> <code class="nx">who</code><code class="p">)</code>
<code class="p">);</code>  <code class="c">// Type is (string | undefined)[]</code></pre>

<p class="author1">If you filter out the <code class="calibre18">undefined</code> values using <code class="calibre18">filter</code>, TypeScript isn’t able to follow along:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">members</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Janet'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">jackson5</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">===</code> <code class="nx">who</code><code class="p">)</code>
<code class="p">).</code><code class="nx">filter</code><code class="p">(</code><code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">who</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">);</code>  <code class="c">// Type is (string | undefined)[]</code></pre>

<p class="author1">But if you use a type guard, it can:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isDefined</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">T</code> <code class="o">|</code> <code class="kd">undefined</code><code class="p">)</code><code class="o">:</code> <code class="nx">x</code> <code class="nx">is</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">x</code> <code class="o">!==</code> <code class="kd">undefined</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">members</code> <code class="o">=</code> <code class="p">[</code><code class="s">'Janet'</code><code class="p">,</code> <code class="s">'Michael'</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">who</code> <code class="o">=&gt;</code> <code class="nx">jackson5</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">n</code> <code class="o">===</code> <code class="nx">who</code><code class="p">)</code>
<code class="p">).</code><code class="nx">filter</code><code class="p">(</code><code class="nx">isDefined</code><code class="p">);</code>  <code class="c">// Type is string[]</code></pre>

<p class="author1">As always, inspecting types in your editor is key to building an intuition for how narrowing works.</p>

<p class="author1">Understanding how types in TypeScript narrow will help you build an intuition for how type inference works, make sense of errors, and generally have a more productive relationship with the type checker.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331664248952">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Understand how TypeScript narrows types based on conditionals and other types of control flow.</p>
</li>
<li class="calibre12">
<p class="author1">Use tagged/discriminated unions and user-defined type guards to help the process of narrowing.<a data-primary="" data-startref="TInarrow03" data-type="indexterm" id="idm45331664245752" class="calibre9"/><a data-primary="" data-startref="tnarrow03" data-type="indexterm" id="idm45331664244776" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 23: Create Objects All at Once" data-type="sect1" class="praise"><div class="praise" id="all-at-once">
<h1 class="calibre16">Item 23: Create Objects All at Once</h1>

<p class="author1">As<a data-primary="type inference" data-secondary="object creation" data-type="indexterm" id="TIobject03" class="calibre9"/><a data-primary="objects" data-secondary="creating all at once" data-type="indexterm" id="Ocreate03" class="calibre9"/> <a href="#one-var-one-type" class="calibre9">Item 20</a> explained, while a variable’s value may change, its type in TypeScript generally does not. This makes some JavaScript patterns easier to model in TypeScript than others. In particular, it means that you should prefer creating objects all at once, rather than piece by piece.</p>

<p class="author1">Here’s one way to create an object representing a two-dimensional point in JavaScript:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code></pre>

<p class="author1">In TypeScript, this will produce errors on each assignment:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="c">// ~ Property 'x' does not exist on type '{}'</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
<code class="c">// ~ Property 'y' does not exist on type '{}'</code></pre>

<p class="author1">This is because the type of <code class="calibre18">pt</code> on the first line is inferred based on its value <code class="calibre18">{}</code>, and you may only assign to known properties.</p>

<p class="author1">You get the opposite problem if you define a <code class="calibre18">Point</code> interface:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Point</code> <code class="p">{</code> <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code> <code class="p">}</code>
<code class="kd">const</code> <code class="nx">pt</code>: <code class="nx">Point</code> <code class="o">=</code> <code class="p">{};</code>
   <code class="c">// ~~ Type '{}' is missing the following properties from type 'Point': x, y</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code></pre>

<p class="author1">The solution is to define the object all at once:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">If you must build the object piecemeal, you may use a type assertion (<code class="calibre18">as</code>) to silence the type checker:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{}</code> <code class="kd">as</code> <code class="nx">Point</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">But the better way is by building the object all at once and using a declaration (see <a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code>: <code class="nx">Point</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">4</code><code class="p">,</code>
<code class="p">};</code></pre>

<p class="author1">If you need to build a larger object from smaller ones, avoid doing it in multiple steps:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code>: <code class="nx">3</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Pythagoras'</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">namedPoint</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">namedPoint</code><code class="p">,</code> <code class="nx">pt</code><code class="p">,</code> <code class="nx">id</code><code class="p">);</code>
<code class="nx">namedPoint</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
        <code class="c">// ~~~~ Property 'name' does not exist on type '{}'</code></pre>

<p class="author1">You<a data-primary="object spread operator (…)" data-type="indexterm" id="idm45331663902552" class="calibre9"/> can build the larger object all at once instead using the <em class="calibre3">object spread operator</em>, <code class="calibre18">...</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">namedPoint</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">pt</code><code class="p">,</code> <code class="p">...</code><code class="nx">id</code><code class="p">};</code>
<code class="nx">namedPoint</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>  <code class="c">// OK, type is string</code></pre>

<p class="author1">You can also use the object spread operator to build up objects field by field in a type-safe way. The key is to use a new variable on every update so that each gets a new type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">pt0</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">const</code> <code class="nx">pt1</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">pt0</code><code class="p">,</code> <code class="nx">x</code>: <code class="nx">3</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">pt</code>: <code class="nx">Point</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">pt1</code><code class="p">,</code> <code class="nx">y</code>: <code class="nx">4</code><code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">While this is a roundabout way to build up such a simple object, it can be a useful technique for adding properties to an object and allowing TypeScript to infer a new type.</p>

<p class="author1">To conditionally add a property in a type-safe way, you can use object spread with <code class="calibre18">null</code> or <code class="calibre18">{}</code>, which add no properties:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">let</code> <code class="nx">hasMiddle</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">firstLast</code> <code class="o">=</code> <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Harry'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Truman'</code><code class="p">};</code>
<code class="kd">const</code> <code class="nx">president</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">firstLast</code><code class="p">,</code> <code class="p">...(</code><code class="nx">hasMiddle</code> <code class="o">?</code> <code class="p">{</code><code class="nx">middle</code><code class="o">:</code> <code class="s">'S'</code><code class="p">}</code> <code class="o">:</code> <code class="p">{})};</code></pre>

<p class="author1">If you mouse over <code class="calibre18">president</code> in your editor, you’ll see that its type is inferred as a union:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">president</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">middle</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code> <code class="o">|</code> <code class="p">{</code>
    <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
    <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This may come as a surprise if you wanted <code class="calibre18">middle</code> to be an optional field. You can’t read <code class="calibre18">middle</code> off this type, for example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">president</code><code class="p">.</code><code class="nx">middle</code>
       <code class="c">// ~~~~~~ Property 'middle' does not exist on type</code>
       <code class="c">//        '{ first: string; last: string; }'</code></pre>

<p class="author1">If you’re conditionally adding multiple properties, the union does more accurately represent the set of possible values (<a href="ch04.html#union-of-interfaces" class="calibre9">Item 32</a>). But an optional field would be easier to work with. You can get one with a helper:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addOptional</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="p">,</code> <code class="nx">U</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">U</code> <code class="o">|</code> <code class="kd">null</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">{...</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">b</code><code class="p">};</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">president</code> <code class="o">=</code> <code class="nx">addOptional</code><code class="p">(</code><code class="nx">firstLast</code><code class="p">,</code> <code class="nx">hasMiddle</code> <code class="o">?</code> <code class="p">{</code><code class="nx">middle</code><code class="o">:</code> <code class="s">'S'</code><code class="p">}</code> <code class="o">:</code> <code class="kd">null</code><code class="p">);</code>
<code class="nx">president</code><code class="p">.</code><code class="nx">middle</code>  <code class="c">// OK, type is string | undefined</code></pre>

<p class="author1">Sometimes you want to build an object or array by transforming another one. In this case the equivalent of “building objects all at once” is using built-in functional constructs or utility libraries like Lodash rather than loops. See <a href="#well-typed-libs" class="calibre9">Item 27</a> for more on this.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331663585320">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Prefer to build objects all at once rather than piecemeal. Use object spread (<code class="calibre18">{...a, ...b}</code>) to add properties in a type-safe way.</p>
</li>
<li class="calibre12">
<p class="author1">Know how to conditionally add properties to an object.<a data-primary="" data-startref="TIobject03" data-type="indexterm" id="idm45331663581736" class="calibre9"/><a data-primary="" data-startref="Ocreate03" data-type="indexterm" id="idm45331663580760" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 24: Be Consistent in Your Use of Aliases" data-type="sect1" class="praise"><div class="praise" id="avoid-aliasing">
<h1 class="calibre16">Item 24: Be Consistent in Your Use of Aliases</h1>

<p class="author1">When<a data-primary="type inference" data-secondary="aliases" data-type="indexterm" id="TIalias03" class="calibre9"/><a data-primary="aliases" data-type="indexterm" id="alias03" class="calibre9"/> you introduce a new name for a value:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">borough</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="s">'Brooklyn'</code><code class="p">,</code> <code class="nx">location</code><code class="o">:</code> <code class="p">[</code><code class="mi">40.688</code><code class="p">,</code> <code class="o">-</code><code class="mi">73.979</code><code class="p">]};</code>
<code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="nx">borough</code><code class="p">.</code><code class="nx">location</code><code class="p">;</code></pre>

<p class="author1">you have created an <em class="calibre3">alias</em>. Changes to properties on the alias will be visible on the original value as well:</p>
<pre data-type="programlisting" class="calibre17">&gt; <strong class="calibre32">loc[0] = 0;</strong>
&gt; <strong class="calibre32">borough.location</strong>
[0, -73.979]</pre>

<p class="author1">Aliases are the bane of compiler writers in all languages because they make control flow analysis difficult. If you’re deliberate in your use of aliases, TypeScript will be able to understand your code better and help you find more real errors.</p>

<p class="author1">Suppose you have a data structure that represents a polygon:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Coordinate</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">BoundingBox</code> <code class="p">{</code>
  <code class="nx">x</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
  <code class="nx">y</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">];</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">Polygon</code> <code class="p">{</code>
  <code class="nx">exterior</code>: <code class="nx">Coordinate</code><code class="p">[];</code>
  <code class="nx">holes</code>: <code class="nx">Coordinate</code><code class="p">[][];</code>
  <code class="nx">bbox?</code>: <code class="nx">BoundingBox</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The geometry of the polygon is specified by the <code class="calibre18">exterior</code> and <code class="calibre18">holes</code> properties. The <code class="calibre18">bbox</code> property is an optimization that may or may not be present. You can use it to speed up a point-in-polygon check:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>

  <code class="c">// ... more complex check</code>
<code class="p">}</code></pre>

<p class="author1">This code works (and type checks) but is a bit repetitive: <code class="calibre18">polygon.bbox</code> appears five times in three lines! Here’s an attempt to factor out an intermediate variable to reduce duplication:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">box</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="c">//     ~~~                ~~~  Object is possibly 'undefined'</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
        <code class="c">//     ~~~                ~~~  Object is possibly 'undefined'</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">(I’m assuming you’ve enabled <code class="calibre18">strictNullChecks</code>.)</p>

<p class="author1">This code still works, so why the error? By factoring out the <code class="calibre18">box</code> variable, you’ve created an alias for <code class="calibre18">polygon.bbox</code>, and this has thwarted the control flow analysis that quietly worked in the first example.</p>

<p class="author1">You can inspect the types of <code class="calibre18">box</code> and <code class="calibre18">polygon.bbox</code> to see what’s happening:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox | undefined</code>
  <code class="kd">const</code> <code class="nx">box</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">;</code>
  <code class="nx">box</code>  <code class="c">// Type is BoundingBox | undefined</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox</code>
    <code class="nx">box</code>  <code class="c">// Type is BoundingBox | undefined</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The property check refines the type of <code class="calibre18">polygon.bbox</code> but not of <code class="calibre18">box</code> and hence the errors. This leads us to the golden rule of aliasing: <em class="calibre3">if you introduce an alias, use it</em> <span class="calibre"><em class="calibre3">consistently</em>.</span></p>

<p class="author1">Using <code class="calibre18">box</code> in the property check fixes the error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">box</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">box</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">box</code><code class="p">.</code><code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>  <code class="c">// OK</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">The type checker is happy now, but there’s an issue for human readers. We’re using two names for the same thing: <code class="calibre18">box</code> and <code class="calibre18">bbox</code>. This is a distinction without a difference (<a href="ch04.html#language-of-domain" class="calibre9">Item 36</a>).</p>

<p class="author1">Object destructuring syntax rewards consistent naming with a more compact syntax. You can even use it on arrays and nested structures:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isPointInPolygon</code><code class="p">(</code><code class="nx">polygon</code>: <code class="nx">Polygon</code><code class="p">,</code> <code class="nx">pt</code>: <code class="nx">Coordinate</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">bbox</code><code class="p">}</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">;</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">{</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">}</code> <code class="o">=</code> <code class="nx">bbox</code><code class="p">;</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">x</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">||</code>
        <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">||</code> <code class="nx">pt</code><code class="p">.</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="nx">y</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">A few other points:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">This code would have required more property checks if the <code class="calibre18">x</code> and <code class="calibre18">y</code> properties had been optional, rather than the whole <code class="calibre18">bbox</code> property. We benefited from following the advice of <a href="ch04.html#null-values-to-perimeter" class="calibre9">Item 31</a>, which discusses the importance of pushing null values to the perimeter of your types.</p>
</li>
<li class="calibre12">
<p class="author1">An optional property was appropriate for <code class="calibre18">bbox</code> but would not have been appropriate for <code class="calibre18">holes</code>. If <code class="calibre18">holes</code> was optional, then it would be possible for it to be either missing or an empty array (<code class="calibre18">[]</code>). This would be a distinction without a difference. An empty array is a fine way to indicate “no holes.”</p>
</li>
</ul>

<p class="author1">In your interactions with the type checker, don’t forget that aliasing can introduce confusion at runtime, too:</p>

<pre data-code-language="ts" data-type="programlisting" id="calculate-polygon-bbox" class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">bbox</code><code class="p">}</code> <code class="o">=</code> <code class="nx">polygon</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">calculatePolygonBbox</code><code class="p">(</code><code class="nx">polygon</code><code class="p">);</code>  <code class="c">// Fills in polygon.bbox</code>
  <code class="c">// Now polygon.bbox and bbox refer to different values!</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript’s control flow analysis tends to be quite good for local variables. But for properties you should be on guard:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">fn</code><code class="p">(</code><code class="nx">p</code>: <code class="nx">Polygon</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox | undefined</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is BoundingBox</code>
  <code class="nx">fn</code><code class="p">(</code><code class="nx">polygon</code><code class="p">);</code>
  <code class="nx">polygon</code><code class="p">.</code><code class="nx">bbox</code>  <code class="c">// Type is still BoundingBox</code>
<code class="p">}</code></pre>

<p class="author1">The<a data-primary="type refinements" data-type="indexterm" id="idm45331662719160" class="calibre9"/> call to <code class="calibre18">fn(polygon)</code> could very well un-set <code class="calibre18">polygon.bbox</code>, so it would be safer for the type to revert to <code class="calibre18">BoundingBox | undefined</code>. But this would get frustrating: you’d have to repeat your property checks every time you called a function. So TypeScript makes the pragmatic choice to assume the function does not invalidate its type refinements. But it <em class="calibre3">could</em>. If you’d factored out a local <code class="calibre18">bbox</code> variable instead of using <code class="calibre18">polygon.bbox</code>, the type of <code class="calibre18">bbox</code> would remain accurate, but it might no longer be the same value as <code class="calibre18">polygon.box</code>.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331662755112">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Aliasing can prevent TypeScript from narrowing types. If you create an alias for a variable, use it consistently.</p>
</li>
<li class="calibre12">
<p class="author1">Use destructuring syntax to encourage consistent naming.</p>
</li>
<li class="calibre12">
<p class="author1">Be aware of how function calls can invalidate type refinements on properties. Trust refinements on local variables more than on properties.<a data-primary="" data-startref="TIalias03" data-type="indexterm" id="idm45331662750824" class="calibre9"/><a data-primary="" data-startref="alias03" data-type="indexterm" id="idm45331662749848" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 25: Use async Functions Instead of Callbacks for Asynchronous Code" data-type="sect1" class="praise"><div class="praise" id="use-async-await">
<h1 class="calibre16">Item 25: Use async Functions Instead of Callbacks for Asynchronous Code</h1>

<p class="author1">Classic<a data-primary="callbacks" data-secondary="async functions versus callbacks" data-type="indexterm" id="callback03" class="calibre9"/><a data-primary="type inference" data-secondary="asynchronous code" data-type="indexterm" id="TIasyn03" class="calibre9"/><a data-primary="asynchronous code" data-type="indexterm" id="async03" class="calibre9"/><a data-primary="Promises" data-type="indexterm" id="prom03" class="calibre9"/><a data-primary="async functions" data-type="indexterm" id="afunc03" class="calibre9"/> JavaScript modeled asynchronous behavior using callbacks. This leads to the infamous “pyramid of doom”:</p>

<pre data-code-language="ts" data-type="programlisting" id="pyramid-of-doom" class="calibre17"><code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url1</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">response1</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url2</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">response2</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url3</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">response3</code><code class="p">)</code> <code class="p">{</code>
      <code class="c">// ...</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
    <code class="p">});</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
  <code class="p">});</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>
<code class="p">});</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>

<code class="c">// Logs:</code>
<code class="c">// 4</code>
<code class="c">// 3</code>
<code class="c">// 2</code>
<code class="c">// 1</code></pre>

<p class="author1">As you can see from the logs, the execution order is the opposite of the code order. This makes callback code hard to read. It gets even more confusing if you want to run the requests in parallel or bail when an error occurs.</p>

<p class="author1">ES2015<a data-primary="ES2015" data-secondary="Promises in" data-type="indexterm" id="idm45331662737736" class="calibre9"/> introduced the concept of a Promise to break the pyramid of doom. A Promise represents something that will be available in the future (they’re also sometimes called “futures”). Here’s the same code using Promises:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">page1Promise</code> <code class="o">=</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
<code class="nx">page1Promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response1</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response2</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">);</code>
<code class="p">}).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response3</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}).</code><code class="kd">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">});</code></pre>

<p class="author1">Now there’s less nesting, and the execution order more directly matches the code order. It’s also easier to consolidate error handling and use higher-order tools like <code class="calibre18">Promise.all</code>.</p>

<p class="author1">ES2017<a data-primary="ES2017" data-type="indexterm" id="idm45331662559464" class="calibre9"/><a data-primary="await keyword" data-type="indexterm" id="await03" class="calibre9"/> introduced the <code class="calibre18">async</code> and <code class="calibre18">await</code> keywords to make things even simpler:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchPages() {</code>
  <code class="kd">const</code> <code class="nx">response1</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">response2</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">response3</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">);</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">await</code> keyword pauses execution of the <code class="calibre18">fetchPages</code> function until each Promise resolves. Within an <code class="calibre18">async</code> function, <code class="calibre18">await</code>ing a Promise that throws an exception. This lets you use the usual try/catch machinery:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchPages() {</code>
  <code class="kd">try</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">response1</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">response2</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code>
    <code class="kd">const</code> <code class="nx">response3</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">);</code>
    <code class="c">// ...</code>
  <code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">When<a data-primary="ES5" data-secondary="async and await in" data-type="indexterm" id="idm45331662393400" class="calibre9"/> you target ES5 or earlier, the TypeScript compiler will perform some elaborate transformations to make <code class="calibre18">async</code> and <code class="calibre18">await</code> work. In other words, whatever your runtime, with TypeScript you can use <code class="calibre18">async</code>/<code class="calibre18">await</code>.</p>

<p class="author1">There are a few good reasons to prefer Promises or <code class="calibre18">async</code>/<code class="calibre18">await</code> to callbacks:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">Promises are easier to compose than callbacks.</p>
</li>
<li class="calibre12">
<p class="author1">Types are able to flow through Promises more easily than callbacks.</p>
</li>
</ul>

<p class="author1">If you want to fetch the pages in parallel, for example, you can compose Promises with <code class="calibre18">Promise.all</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchPages() {</code>
  <code class="kd">const</code> <code class="p">[</code><code class="nx">response1</code><code class="p">,</code> <code class="nx">response2</code><code class="p">,</code> <code class="nx">response3</code><code class="p">]</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code>
    <code class="nx">fetch</code><code class="p">(</code><code class="nx">url1</code><code class="p">),</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url2</code><code class="p">),</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url3</code><code class="p">)</code>
  <code class="p">]);</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">Using destructuring assignment with <code class="calibre18">await</code> is particularly nice in this context.</p>

<p class="author1">TypeScript is able to infer the types of each of the three <code class="calibre18">response</code> variables as <code class="calibre18">Response</code>. The equivalent code to do the requests in parallel with callbacks requires more machinery and a type annotation:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">fetchPagesCB() {</code>
  <code class="kd">let</code> <code class="nx">numDone</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">responses</code>: <code class="kd">string</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">const</code> <code class="nx">done</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="p">[</code><code class="nx">response1</code><code class="p">,</code> <code class="nx">response2</code><code class="p">,</code> <code class="nx">response3</code><code class="p">]</code> <code class="o">=</code> <code class="nx">responses</code><code class="p">;</code>
    <code class="c">// ...</code>
  <code class="p">};</code>
  <code class="kd">const</code> <code class="nx">urls</code> <code class="o">=</code> <code class="p">[</code><code class="nx">url1</code><code class="p">,</code> <code class="nx">url2</code><code class="p">,</code> <code class="nx">url3</code><code class="p">];</code>
  <code class="nx">urls</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">url</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">r</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">responses</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">url</code><code class="p">;</code>
      <code class="nx">numDone</code><code class="o">++</code><code class="p">;</code>
      <code class="kd">if</code> <code class="p">(</code><code class="nx">numDone</code> <code class="o">===</code> <code class="nx">urls</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="nx">done</code><code class="p">();</code>
    <code class="p">});</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

<p class="author1">Extending this to include error handling or to be as generic as <code class="calibre18">Promise.all</code> is <span class="calibre">challenging.</span></p>

<p class="author1">Type inference also works well with <code class="calibre18">Promise.race</code>, which resolves when the first of its input Promises resolves. You can use this to add timeouts to Promises in a general way:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">timeout</code><code class="p">(</code><code class="nx">millis</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">never</code><code class="o">&gt;</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
     <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">reject</code><code class="p">(</code><code class="s">'timeout'</code><code class="p">),</code> <code class="nx">millis</code><code class="p">);</code>
  <code class="p">});</code>
<code class="p">}</code>

<code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchWithTimeout</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">ms</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">race</code><code class="p">([</code><code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">),</code> <code class="nx">timeout</code><code class="p">(</code><code class="nx">ms</code><code class="p">)]);</code>
<code class="p">}</code></pre>

<p class="author1">The return type of <code class="calibre18">fetchWithTimeout</code> is inferred as <code class="calibre18">Promise&lt;Response&gt;</code>, no type annotations required. It’s interesting to dig into why this works: the return type of <code class="calibre18">Promise.race</code> is the union of the types of its inputs, in this case <code class="calibre18">Promise&lt;Response | never&gt;</code>. But taking a union with <code class="calibre18">never</code> (the empty set) is a no-op, so this gets simplified to <code class="calibre18">Promise&lt;Response&gt;</code>. When you work with Promises, all of TypeScript’s type inference machinery works to get you the right types.</p>

<p class="author1">There are some times when you need to use raw Promises, notably when you are wrapping a callback API like <code class="calibre18">setTimeout</code>. But if you have a choice, you should generally prefer <code class="calibre18">async</code>/<code class="calibre18">await</code> to raw Promises for two reasons:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">It typically produces more concise and straightforward code.</p>
</li>
<li class="calibre12">
<p class="author1">It enforces that <code class="calibre18">async</code> functions always return Promises.</p>
</li>
</ul>

<p class="author1">An <code class="calibre18">async</code> function always returns a <code class="calibre18">Promise</code>, even if it doesn’t involve <code class="calibre18">await</code>ing anything. TypeScript can help you build an intuition for this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// function getNumber(): Promise&lt;number&gt;</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">getNumber() {</code>
  <code class="kd">return</code> <code class="mi">42</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You<a data-primary="async arrow functions" data-type="indexterm" id="idm45331662118168" class="calibre9"/> can also create <code class="calibre18">async</code> arrow functions:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">getNumber</code> <code class="o">=</code> <code class="kd">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">42</code><code class="p">;</code>  <code class="c">// Type is () =&gt; Promise&lt;number&gt;</code></pre>

<p class="author1">The raw Promise equivalent is:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">getNumber</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code>  <code class="c">// Type is () =&gt; Promise&lt;number&gt;</code></pre>

<p class="author1">While it may seem odd to return a Promise for an immediately available value, this actually helps enforce an important rule: a function should either always be run synchronously or always be run asynchronously. It should never mix the two. For example, what if you want to add a cache to the <code class="calibre18">fetchURL</code> function? Here’s an attempt:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Don't do this!</code>
<code class="kd">const</code> <code class="nx">_cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">function</code> <code class="nx">fetchWithCache</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">text</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">url</code> <code class="kd">in</code> <code class="nx">_cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">callback</code><code class="p">(</code><code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">]);</code>
  <code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
    <code class="nx">fetchURL</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">text</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">]</code> <code class="o">=</code> <code class="nx">text</code><code class="p">;</code>
      <code class="nx">callback</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">While this may seem like an optimization, the function is now extremely difficult for a client to use:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">requestStatus</code><code class="o">:</code> <code class="s">'loading'</code> <code class="o">|</code> <code class="s">'success'</code> <code class="o">|</code> <code class="s">'error'</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">getUser</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">fetchWithCache</code><code class="p">(</code><code class="s">`/user/</code><code class="si">${</code><code class="nx">userId</code><code class="si">}</code><code class="s">`</code><code class="p">,</code> <code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'success'</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'loading'</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">What will the value of <code class="calibre18">requestStatus</code> be after calling <code class="calibre18">getUser</code>? It depends entirely on whether the profile is cached. If it’s not, <code class="calibre18">requestStatus</code> will be set to “success.” If it is, it’ll get set to “success” and then set back to “loading.” Oops!</p>

<p class="author1">Using <code class="calibre18">async</code> for both functions enforces consistent behavior:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">_cache</code><code class="o">:</code> <code class="p">{[</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">fetchWithCache</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">url</code> <code class="kd">in</code> <code class="nx">_cache</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>
  <code class="nx">_cache</code><code class="p">[</code><code class="nx">url</code><code class="p">]</code> <code class="o">=</code> <code class="nx">text</code><code class="p">;</code>
  <code class="kd">return</code> <code class="nx">text</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">requestStatus</code><code class="o">:</code> <code class="s">'loading'</code> <code class="o">|</code> <code class="s">'success'</code> <code class="o">|</code> <code class="s">'error'</code><code class="p">;</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">getUser</code><code class="p">(</code><code class="nx">userId</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'loading'</code><code class="p">;</code>
  <code class="kd">const</code> <code class="nx">profile</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetchWithCache</code><code class="p">(</code><code class="s">`/user/</code><code class="si">${</code><code class="nx">userId</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
  <code class="nx">requestStatus</code> <code class="o">=</code> <code class="s">'success'</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Now it’s completely transparent that <code class="calibre18">requestStatus</code> will end in “success.” It’s easy to accidentally produce half-synchronous code with callbacks or raw Promises, but difficult with <code class="calibre18">async</code>.</p>

<p class="author1">Note that if you return a Promise from an <code class="calibre18">async</code> function, it will not get wrapped in another Promise: the return type will be <code class="calibre18">Promise&lt;T&gt;</code> rather than <code class="calibre18">Promise&lt;Promise&lt;T&gt;&gt;</code>. Again, TypeScript will help you build an intuition for this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Function getJSON(url: string): Promise&lt;any&gt;</code>
<code class="kd">async</code> <code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
  <code class="kd">const</code> <code class="nx">jsonPromise</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>  <code class="c">// Type is Promise&lt;any&gt;</code>
  <code class="kd">return</code> <code class="nx">jsonPromise</code><code class="p">;</code>
<code class="p">}</code></pre>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331661718952">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Prefer Promises to callbacks for better composability and type flow.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer <code class="calibre18">async</code> and <code class="calibre18">await</code> to raw Promises when possible. They produce more concise, straightforward code and eliminate whole classes of errors.</p>
</li>
<li class="calibre12">
<p class="author1">If a function returns a Promise, declare it <code class="calibre18">async</code>.<a data-primary="" data-startref="TIasyn03" data-type="indexterm" id="idm45331661691848" class="calibre9"/><a data-primary="" data-startref="async03" data-type="indexterm" id="idm45331661690840" class="calibre9"/><a data-primary="" data-startref="prom03" data-type="indexterm" id="idm45331661689896" class="calibre9"/><a data-primary="" data-startref="afunc03" data-type="indexterm" id="idm45331661688952" class="calibre9"/><a data-primary="" data-startref="await03" data-type="indexterm" id="idm45331661688008" class="calibre9"/><a data-primary="" data-startref="callback03" data-type="indexterm" id="idm45331661687064" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 26: Understand How Context Is Used in Type Inference" data-type="sect1" class="praise"><div class="praise" id="context-inference">
<h1 class="calibre16">Item 26: Understand How Context Is Used in Type Inference</h1>

<p class="author1">TypeScript<a data-primary="type inference" data-secondary="context in" data-type="indexterm" id="TIcontext03" class="calibre9"/><a data-primary="context" data-type="indexterm" id="cont03" class="calibre9"/> doesn’t just infer types based on values. It also considers the context in which the value occurs. This usually works well but can sometimes lead to surprises. Understanding how context is used in type inference will help you identify and work around these surprises when they do occur.</p>

<p class="author1">In JavaScript you can factor an expression out into a constant without changing the behavior of your code (so long as you don’t alter execution order). In other words, these two statements are equivalent:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// Inline form</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="s">'JavaScript'</code><code class="p">);</code>

<code class="c">// Reference form</code>
<code class="kd">let</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code></pre>

<p class="author1">In TypeScript, this refactor still works:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">setLanguage</code><code class="p">(</code><code class="s">'JavaScript'</code><code class="p">);</code>  <code class="c">// OK</code>

<code class="kd">let</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">Now suppose you take to heart the advice of <a href="ch04.html#avoid-strings" class="calibre9">Item 33</a> and replace the string type with a more precise union of string literal types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Language</code> <code class="o">=</code> <code class="s">'JavaScript'</code> <code class="o">|</code> <code class="s">'TypeScript'</code> <code class="o">|</code> <code class="s">'Python'</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code>: <code class="nx">Language</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">setLanguage</code><code class="p">(</code><code class="s">'JavaScript'</code><code class="p">);</code>  <code class="c">// OK</code>

<code class="kd">let</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>
         <code class="c">// ~~~~~~~~ Argument of type 'string' is not assignable</code>
         <code class="c">//          to parameter of type 'Language'</code></pre>

<p class="author1">What went wrong? With the inline form, TypeScript knows from the function declaration that the parameter is supposed to be of type <code class="calibre18">Language</code>. The string literal <code class="calibre18">'JavaScript'</code> is assignable to this type, so this is OK. But when you factor out a variable, TypeScript must infer its type at the time of assignment. In this case it infers <code class="calibre18">string</code>, which is not assignable to <code class="calibre18">Language</code>. Hence the error.</p>

<p class="author1">(Some languages are able to infer types for variables based on their eventual usage. But this can also be confusing. Anders Hejlsberg,<a data-primary="Hejlsberg, Anders" data-type="indexterm" id="idm45331661466920" class="calibre9"/> the creator of TypeScript, refers to it as “spooky action at a distance.” By and large, TypeScript determines the type of a variable when it is first introduced. For a notable exception to this rule, see <a href="ch05.html#evolving-any" class="calibre9">Item 41</a>.)</p>

<p class="author1">There are two good ways to solve this problem. One is to constrain the possible values of <code class="calibre18">language</code> with a type declaration:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">language</code>: <code class="nx">Language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">This also has the benefit of flagging an error if there’s a typo in the language—for example <code class="calibre18">'Typescript'</code> (it should be a capital “S”).</p>

<p class="author1">The other solution is to make the variable constant:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">language</code> <code class="o">=</code> <code class="s">'JavaScript'</code><code class="p">;</code>
<code class="nx">setLanguage</code><code class="p">(</code><code class="nx">language</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">By using <code class="calibre18">const</code>, we’ve told the type checker that this variable cannot change. So TypeScript can infer a more precise type for <code class="calibre18">language</code>, the string literal type <code class="calibre18">"JavaScript"</code>. This is assignable to <code class="calibre18">Language</code> so the code type checks. Of course, if you do need to reassign <code class="calibre18">language</code>, then you’ll need to use the type declaration. (For more on this, see <a href="#widening" class="calibre9">Item 21</a>.)</p>

<p class="author1">The fundamental issue here is that we’ve separated the value from the context in which it’s used. Sometimes this is OK, but often it is not. The rest of this item walks through a few cases where this loss of context can cause errors and shows you how to fix them.</p>








<section class="praise" data-pdf-bookmark="Tuple Types" data-type="sect2"><div class="praise" id="idm45331661441400">
<h2 class="calibre31">Tuple Types</h2>

<p class="author1">In<a data-primary="tuple type" data-type="indexterm" id="idm45331661439400" class="calibre9"/> addition to string literal types, problems can come up with tuple types. Suppose you’re working with a map visualization that lets you programmatically pan the map:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Parameter is a (latitude, longitude) pair.</code>
<code class="kd">function</code> <code class="nx">panTo</code><code class="p">(</code><code class="nx">where</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">panTo</code><code class="p">([</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">]);</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">];</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>
<code class="c">//    ~~~ Argument of type 'number[]' is not assignable to</code>
<code class="c">//        parameter of type '[number, number]'</code></pre>

<p class="author1">As before, you’ve separated a value from its context. In the first instance <code class="calibre18">[10, 20]</code> is assignable to the tuple type <code class="calibre18">[number, number]</code>. In the second, TypeScript infers the type of <code class="calibre18">loc</code> as <code class="calibre18">number[]</code> (i.e., an array of numbers of unknown length). This is not assignable to the tuple type, since many arrays have the wrong number of elements.</p>

<p class="author1">So<a data-primary="const" data-secondary="type declarations and" data-type="indexterm" id="idm45331661315784" class="calibre9"/> how can you fix this error without resorting to <code class="calibre18">any</code>? You’ve already declared it <code class="calibre18">const</code>, so that won’t help. But you can still provide a type declaration to let TypeScript know precisely what you mean:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">loc</code><code class="o">:</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">];</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">Another way is to provide a “const context.” This tells TypeScript that you intend the value to be deeply constant, rather than the shallow constant that <code class="calibre18">const</code> gives:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>
   <code class="c">// ~~~ Type 'readonly [10, 20]' is 'readonly'</code>
   <code class="c">//     and cannot be assigned to the mutable type '[number, number]'</code></pre>

<p class="author1">If you hover over <code class="calibre18">loc</code> in your editor, you’ll see that its type is now inferred as <code class="calibre18">readonly [10, 20]</code>, rather than <code class="calibre18">number[]</code>. Unfortunately this is <em class="calibre3">too</em> precise! The type signature of <code class="calibre18">panTo</code> makes no promises that it won’t modify the contents of its <code class="calibre18">where</code> parameter. Since the <code class="calibre18">loc</code> parameter has a <code class="calibre18">readonly</code> type, this won’t do. The best solution here is to add a <code class="calibre18">readonly</code> annotation to the <code class="calibre18">panTo</code> function:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">panTo</code><code class="p">(</code><code class="nx">where</code>: <code class="nx">readonly</code> <code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">])</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>
<code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">If the type signature is outside your control, then you’ll need to use an annotation.</p>

<p class="author1"><code class="calibre18">const</code> contexts can neatly solve issues around losing context in inference, but they do have an unfortunate downside: if you make a mistake in the definition (say you add a third element to the tuple) then the error will be flagged at the call site, not at the definition. This may be confusing, especially if the error occurs in a deeply nested object:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">loc</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">30</code><code class="p">]</code> <code class="kd">as</code> <code class="kd">const</code><code class="p">;</code>  <code class="c">// error is really here.</code>
<code class="nx">panTo</code><code class="p">(</code><code class="nx">loc</code><code class="p">);</code>
<code class="c">//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to</code>
<code class="c">//        parameter of type 'readonly [number, number]'</code>
<code class="c">//          Types of property 'length' are incompatible</code>
<code class="c">//            Type '3' is not assignable to type '2'</code></pre>
</div></section>













<section class="praise" data-pdf-bookmark="Objects" data-type="sect2"><div class="praise" id="idm45331661176408">
<h2 class="calibre31">Objects</h2>

<p class="author1">The<a data-primary="objects" data-secondary="type inference and" data-type="indexterm" id="idm45331661165576" class="calibre9"/> problem of separating a value from its context also comes up when you factor out a constant from a larger object that contains some string literals or tuples. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Language</code> <code class="o">=</code> <code class="s">'JavaScript'</code> <code class="o">|</code> <code class="s">'TypeScript'</code> <code class="o">|</code> <code class="s">'Python'</code><code class="p">;</code>
<code class="kd">interface</code> <code class="nx">GovernedLanguage</code> <code class="p">{</code>
  <code class="nx">language</code>: <code class="nx">Language</code><code class="p">;</code>
  <code class="nx">organization</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">complain</code><code class="p">(</code><code class="nx">language</code>: <code class="nx">GovernedLanguage</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="nx">complain</code><code class="p">({</code> <code class="nx">language</code><code class="o">:</code> <code class="s">'TypeScript'</code><code class="p">,</code> <code class="nx">organization</code><code class="o">:</code> <code class="s">'Microsoft'</code> <code class="p">});</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="nx">ts</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">language</code><code class="o">:</code> <code class="s">'TypeScript'</code><code class="p">,</code>
  <code class="nx">organization</code><code class="o">:</code> <code class="s">'Microsoft'</code><code class="p">,</code>
<code class="p">};</code>
<code class="nx">complain</code><code class="p">(</code><code class="nx">ts</code><code class="p">);</code>
<code class="c">//       ~~ Argument of type '{ language: string; organization: string; }'</code>
<code class="c">//            is not assignable to parameter of type 'GovernedLanguage'</code>
<code class="c">//          Types of property 'language' are incompatible</code>
<code class="c">//            Type 'string' is not assignable to type 'Language'</code></pre>

<p class="author1">In<a data-primary="as const" data-type="indexterm" id="idm45331661047784" class="calibre9"/><a data-primary="const assertion" data-type="indexterm" id="idm45331661047288" class="calibre9"/> the <code class="calibre18">ts</code> object, the type of <code class="calibre18">language</code> is inferred as <code class="calibre18">string</code>. As before, the solution is to add a type declaration (<code class="calibre18">const ts: GovernedLanguage = ...</code>) or use a const assertion (<code class="calibre18">as const</code>).</p>
</div></section>













<section class="praise" data-pdf-bookmark="Callbacks" data-type="sect2"><div class="praise" id="idm45331661009512">
<h2 class="calibre31">Callbacks</h2>

<p class="author1">When<a data-primary="callbacks" data-secondary="type inference and" data-type="indexterm" id="idm45331661007640" class="calibre9"/> you pass a callback to another function, TypeScript uses context to infer the parameter types of the callback:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">callWithRandomNumbers</code><code class="p">(</code><code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="nx">n1</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">n2</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">fn</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">(),</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">());</code>
<code class="p">}</code>

<code class="nx">callWithRandomNumbers</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">a</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nx">b</code><code class="p">;</code>  <code class="c">// Type is number</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">});</code></pre>

<p class="author1">The types of <code class="calibre18">a</code> and <code class="calibre18">b</code> are inferred as <code class="calibre18">number</code> because of the type declaration for <code class="calibre18">callWithRandom</code>. If you factor the callback out into a constant, you lose that context and get <code class="calibre18">noImplicitAny</code> errors:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
         <code class="c">// ~    Parameter 'a' implicitly has an 'any' type</code>
         <code class="c">//    ~ Parameter 'b' implicitly has an 'any' type</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">callWithRandomNumbers</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code></pre>

<p class="author1">The solution is either to add type annotations to the parameters:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">fn</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">callWithRandomNumbers</code><code class="p">(</code><code class="nx">fn</code><code class="p">);</code></pre>

<p class="author1">or to apply a type declaration to the entire function expression if one is available. See <a href="ch02_split_001.html#type-entire-functions" class="calibre9">Item 12</a>.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331660891512">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Be aware of how context is used in type inference.</p>
</li>
<li class="calibre12">
<p class="author1">If factoring out a variable introduces a type error, consider adding a type declaration.</p>
</li>
<li class="calibre12">
<p class="author1">If the variable is truly a constant, use a const assertion (<code class="calibre18">as const</code>). But be aware that this may result in errors surfacing at use, rather than definition.<a data-primary="" data-startref="TIcontext03" data-type="indexterm" id="idm45331660814424" class="calibre9"/><a data-primary="" data-startref="cont03" data-type="indexterm" id="idm45331660813448" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 27: Use Functional Constructs and Libraries to Help Types Flow" data-type="sect1" class="praise"><div class="praise" id="well-typed-libs">
<h1 class="calibre16">Item 27: Use Functional Constructs and Libraries to Help Types Flow</h1>

<p class="author1">JavaScript<a data-primary="type inference" data-secondary="functional constructs and libraries" data-type="indexterm" id="TIfunc03" class="calibre9"/><a data-primary="functions" data-secondary="utility libraries versus hand-rolled" data-type="indexterm" id="Futility03" class="calibre9"/><a data-primary="libraries" data-secondary="using utility libraries" data-type="indexterm" id="Lutili03" class="calibre9"/><a data-primary="type annotations" data-secondary="reducing need for" data-type="indexterm" id="TAreduc03" class="calibre9"/><a data-primary="Lodash library" data-type="indexterm" id="lodash03" class="calibre9"/> has never included the sort of standard library you find in Python, C, or<a data-primary="Java" data-secondary="standard libraries in" data-type="indexterm" id="idm45331660803448" class="calibre9"/> Java. Over the years many libraries have tried to fill the gap. jQuery<a data-primary="jQuery" data-secondary="interacting with DOM" data-type="indexterm" id="idm45331660802376" class="calibre9"/> provided helpers not just for interacting with the DOM but also for iterating and mapping over objects and arrays. Underscore<a data-primary="Underscore library" data-type="indexterm" id="idm45331660801160" class="calibre9"/> focused more on providing general utility functions, and Lodash built on this effort. Today<a data-primary="Ramda library" data-type="indexterm" id="idm45331660800248" class="calibre9"/> libraries like Ramda continue to bring ideas from functional programming into the JavaScript world.</p>

<p class="author1">Some<a data-primary="flatMap" data-type="indexterm" id="idm45331660798856" class="calibre9"/> features from these libraries, such as <code class="calibre18">map</code>, <code class="calibre18">flatMap</code>, <code class="calibre18">filter</code>, and <code class="calibre18">reduce</code>, have made it into the JavaScript language itself. While these constructs (and the other ones provided by Lodash) are helpful in JavaScript and often preferable to a hand-rolled loop, this advantage tends to get even more lopsided when you add TypeScript to the mix. This is because their type declarations ensure that types flow through these constructs. With hand-rolled loops, you’re responsible for the types yourself.</p>

<p class="author1">For<a data-primary="CSV" data-type="indexterm" id="idm45331660795528" class="calibre9"/> example, consider parsing some CSV data. You could do it in plain JavaScript in a somewhat imperative style:</p>

<pre data-code-language="js" data-type="programlisting" id="nba-js" class="calibre17"><code class="kd">const</code> <code class="nx">csvData</code> <code class="o">=</code> <code class="s">"..."</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">rawRows</code> <code class="o">=</code> <code class="nx">csvData</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">'\n'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">headers</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">);</code>

<code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">row</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">val</code><code class="p">,</code> <code class="nx">j</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">j</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">;</code>
  <code class="p">});</code>
  <code class="kd">return</code> <code class="nx">row</code><code class="p">;</code>
<code class="p">});</code></pre>

<p class="author1">More functionally minded JavaScripters might prefer to build the row objects with <code class="calibre18">reduce</code>:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">reduce</code><code class="p">(</code>
        <code class="p">(</code><code class="nx">row</code><code class="p">,</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">row</code><code class="p">),</code>
        <code class="p">{}));</code></pre>

<p class="author1">This<a data-primary="zipObject" data-type="indexterm" id="idm45331660697176" class="calibre9"/> version saves three lines (almost 20 non-whitespace characters!) but may be more cryptic depending on your sensibilities. Lodash’s <code class="calibre18">zipObject</code> function, which forms an object by “zipping” up a keys and values array, can tighten it even further:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">import</code> <code class="nx">_</code> <code class="nx">from</code> <code class="s">'lodash'</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">zipObject</code><code class="p">(</code><code class="nx">headers</code><code class="p">,</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">)));</code></pre>

<p class="author1">I find this the clearest of all. But is it worth the cost of adding a dependency on a third-party library to your project? If you’re not using a bundler and the overhead of doing this is significant, then the answer may be “no.”</p>

<p class="author1">When you add TypeScript to the mix, it starts to tip the balance more strongly in favor of the Lodash solution.</p>

<p class="author1">Both vanilla JS versions of the CSV parser produce the same error in TypeScript:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rowsA</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">row</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">val</code><code class="p">,</code> <code class="nx">j</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">j</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">;</code>
 <code class="c">// ~~~~~~~~~~~~~~~ No index signature with a parameter of</code>
 <code class="c">//                 type 'string' was found on type '{}'</code>
  <code class="p">});</code>
  <code class="kd">return</code> <code class="nx">row</code><code class="p">;</code>
<code class="p">});</code>
<code class="kd">const</code> <code class="nx">rowsB</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">).</code><code class="nx">reduce</code><code class="p">(</code>
      <code class="p">(</code><code class="nx">row</code><code class="p">,</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">row</code><code class="p">[</code><code class="nx">headers</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">row</code><code class="p">),</code>
                     <code class="c">// ~~~~~~~~~~~~~~~ No index signature with a parameter of</code>
                     <code class="c">//                 type 'string' was found on type '{}'</code>
      <code class="p">{}));</code></pre>

<p class="author1">The solution in each case is to provide a type annotation for <code class="calibre18">{}</code>, either <code class="calibre18">{[column: string]: string}</code> or <code class="calibre18">Record&lt;string, string&gt;</code>.</p>

<p class="author1">The Lodash version, on the other hand, passes the type checker without modification:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">rows</code> <code class="o">=</code> <code class="nx">rawRows</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">rowStr</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">zipObject</code><code class="p">(</code><code class="nx">headers</code><code class="p">,</code> <code class="nx">rowStr</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s">','</code><code class="p">)));</code>
    <code class="c">// Type is _.Dictionary&lt;string&gt;[]</code></pre>

<p class="author1"><code class="calibre18">Dictionary</code> is a Lodash type alias. <code class="calibre18">Dictionary&lt;string&gt;</code> is the same as <code class="calibre18">{[key: string]: string}</code> or <code class="calibre18">Record&lt;string, string&gt;</code>. The important thing here is that the type of <code class="calibre18">rows</code> is exactly correct, no type annotations needed.</p>

<p class="author1">These advantages get more pronounced as your data munging gets more elaborate. For example, suppose you have a list of the rosters for all the NBA teams:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">BasketballPlayer</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">team</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">salary</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">declare</code> <code class="kd">const</code> <code class="nx">rosters</code><code class="o">:</code> <code class="p">{[</code><code class="nx">team</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">BasketballPlayer</code><code class="p">[]};</code></pre>

<p class="author1">To<a data-primary="Object.values" data-type="indexterm" id="idm45331660359000" class="calibre9"/> build a flat list using a loop, you might use <code class="calibre18">concat</code> with an array. This code runs fine but does not type check:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">allPlayers</code> <code class="o">=</code> <code class="p">[];</code>
 <code class="c">// ~~~~~~~~~~ Variable 'allPlayers' implicitly has type 'any[]'</code>
 <code class="c">//            in some locations where its type cannot be determined</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">players</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">rosters</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">allPlayers</code> <code class="o">=</code> <code class="nx">allPlayers</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">players</code><code class="p">);</code>
            <code class="c">// ~~~~~~~~~~ Variable 'allPlayers' implicitly has an 'any[]' type</code>
<code class="p">}</code></pre>

<p class="author1">To fix the error you need to add a type annotation to <code class="calibre18">allPlayers</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">allPlayers</code>: <code class="nx">BasketballPlayer</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[];</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">players</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">rosters</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">allPlayers</code> <code class="o">=</code> <code class="nx">allPlayers</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">players</code><code class="p">);</code>  <code class="c">// OK</code>
<code class="p">}</code></pre>

<p class="author1">But a better solution is to use <code class="calibre18">Array.prototype.flat</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">allPlayers</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">rosters</code><code class="p">).</code><code class="nx">flat</code><code class="p">();</code>
<code class="c">// OK, type is BasketballPlayer[]</code></pre>

<p class="author1">The <code class="calibre18">flat</code> method flattens a multidimensional array. Its type signature is something like <code class="calibre18">T[][] =&gt; T[]</code>. This version is the most concise and requires no type annotations. As an added bonus you can use <code class="calibre18">const</code> instead of <code class="calibre18">let</code> to prevent future mutations to the <code class="calibre18">allPlayers</code> variable.</p>

<p class="author1">Say you want to start with <code class="calibre18">allPlayers</code> and make a list of the highest-paid players on each team ordered by salary.</p>

<p class="author1">Here’s a solution without Lodash. It requires a type annotation where you don’t use functional constructs:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">teamToPlayers</code><code class="o">:</code> <code class="p">{[</code><code class="nx">team</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">BasketballPlayer</code><code class="p">[]}</code> <code class="o">=</code> <code class="p">{};</code>
<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">player</code> <code class="nx">of</code> <code class="nx">allPlayers</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="p">{</code><code class="nx">team</code><code class="p">}</code> <code class="o">=</code> <code class="nx">player</code><code class="p">;</code>
  <code class="nx">teamToPlayers</code><code class="p">[</code><code class="nx">team</code><code class="p">]</code> <code class="o">=</code> <code class="nx">teamToPlayers</code><code class="p">[</code><code class="nx">team</code><code class="p">]</code> <code class="o">||</code> <code class="p">[];</code>
  <code class="nx">teamToPlayers</code><code class="p">[</code><code class="nx">team</code><code class="p">].</code><code class="nx">push</code><code class="p">(</code><code class="nx">player</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">players</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">teamToPlayers</code><code class="p">))</code> <code class="p">{</code>
  <code class="nx">players</code><code class="p">.</code><code class="nx">sort</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">b</code><code class="p">.</code><code class="nx">salary</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">salary</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">bestPaid</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">teamToPlayers</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">players</code> <code class="o">=&gt;</code> <code class="nx">players</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>
<code class="nx">bestPaid</code><code class="p">.</code><code class="nx">sort</code><code class="p">((</code><code class="nx">playerA</code><code class="p">,</code> <code class="nx">playerB</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">playerB</code><code class="p">.</code><code class="nx">salary</code> <code class="o">-</code> <code class="nx">playerA</code><code class="p">.</code><code class="nx">salary</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">bestPaid</code><code class="p">);</code></pre>

<p class="author1">Here’s<a data-primary="Curry, Stephen" data-type="indexterm" id="idm45331660177368" class="calibre9"/><a data-primary="Paul, Chris" data-type="indexterm" id="idm45331660176872" class="calibre9"/><a data-primary="James, LeBron" data-type="indexterm" id="idm45331660176232" class="calibre9"/><a data-primary="Westbrook, Russell" data-type="indexterm" id="idm45331660175560" class="calibre9"/><a data-primary="Griffin, Blake" data-type="indexterm" id="idm45331660004712" class="calibre9"/> the output:</p>

<pre data-type="programlisting" class="calibre17">[
  { team: 'GSW', salary: 37457154, name: 'Stephen Curry' },
  { team: 'HOU', salary: 35654150, name: 'Chris Paul' },
  { team: 'LAL', salary: 35654150, name: 'LeBron James' },
  { team: 'OKC', salary: 35654150, name: 'Russell Westbrook' },
  { team: 'DET', salary: 32088932, name: 'Blake Griffin' },
  ...
]</pre>

<p class="author1">Here’s the equivalent with Lodash:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">bestPaid</code> <code class="o">=</code> <code class="nx">_</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">groupBy</code><code class="p">(</code><code class="nx">player</code> <code class="o">=&gt;</code> <code class="nx">player</code><code class="p">.</code><code class="nx">team</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">mapValues</code><code class="p">(</code><code class="nx">players</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">maxBy</code><code class="p">(</code><code class="nx">players</code><code class="p">,</code> <code class="nx">p</code> <code class="o">=&gt;</code> <code class="nx">p</code><code class="p">.</code><code class="nx">salary</code><code class="p">)</code><code class="o">!</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">values</code><code class="p">()</code>
  <code class="p">.</code><code class="nx">sortBy</code><code class="p">(</code><code class="nx">p</code> <code class="o">=&gt;</code> <code class="o">-</code><code class="nx">p</code><code class="p">.</code><code class="nx">salary</code><code class="p">)</code>
  <code class="p">.</code><code class="nx">value</code><code class="p">()</code>  <code class="c">// Type is BasketballPlayer[]</code></pre>

<p class="author1">In addition to being half the length, this code is clearer and requires only a single non-null assertion (the type checker doesn’t know that the <code class="calibre18">players</code> array passed to <code class="calibre18">_.maxBy</code> is non-empty). It makes use of a “chain,” a concept in Lodash and<a data-primary="Underscore library" data-type="indexterm" id="idm45331659857352" class="calibre9"/> Underscore that lets you write a sequence of operations in a more natural order. Instead of writing:</p>

<pre data-type="programlisting" class="calibre17">_.a(_.b(_.c(v)))</pre>

<p class="author1">you write:</p>

<pre data-type="programlisting" class="calibre17">_(v).a().b().c().value()</pre>

<p class="author1">The <code class="calibre18">_(v)</code> “wraps” the value, and the <code class="calibre18">.value()</code> “unwraps” it.</p>

<p class="author1">You can inspect each function call in the chain to see the type of the wrapped value. It’s always correct.</p>

<p class="author1">Even some of the quirkier shorthands in Lodash can be modeled accurately in TypeScript. For instance, why would you want to use <code class="calibre18">_.map</code> instead of the built-in <code class="calibre18">Array.prototype.map</code>? One reason is that instead of passing in a callback you can pass in the name of a property. These calls all produce the same result:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">namesA</code> <code class="o">=</code> <code class="nx">allPlayers</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">player</code> <code class="o">=&gt;</code> <code class="nx">player</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code>  <code class="c">// Type is string[]</code>
<code class="kd">const</code> <code class="nx">namesB</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="nx">player</code> <code class="o">=&gt;</code> <code class="nx">player</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code>  <code class="c">// Type is string[]</code>
<code class="kd">const</code> <code class="nx">namesC</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="s">'name'</code><code class="p">);</code>  <code class="c">// Type is string[]</code></pre>

<p class="author1">It’s a testament to the sophistication of TypeScript’s type system that it can model a construct like this accurately, but it naturally falls out of the combination of string literal types and index types (see <a href="ch02_split_001.html#map-between-types" class="calibre9">Item 14</a>). If<a data-primary="C++" data-type="indexterm" id="idm45331659810952" class="calibre9"/> you’re used to C++ or<a data-primary="Java" data-secondary="versus TypeScript" data-type="indexterm" id="idm45331659810184" class="calibre9"/> Java, this sort of type inference can feel quite magical!</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">salaries</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="s">'salary'</code><code class="p">);</code>  <code class="c">// Type is number[]</code>
<code class="kd">const</code> <code class="nx">teams</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="s">'team'</code><code class="p">);</code>  <code class="c">// Type is string[]</code>
<code class="kd">const</code> <code class="nx">mix</code> <code class="o">=</code> <code class="nx">_</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">allPlayers</code><code class="p">,</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code> <code class="o">?</code> <code class="s">'name'</code> <code class="o">:</code> <code class="s">'salary'</code><code class="p">);</code>
  <code class="c">// Type is (string | number)[]</code></pre>

<p class="author1">It’s not a coincidence that types flow so well through built-in functional constructs and those in libraries like Lodash. By avoiding mutation and returning new values from every call, they are able to produce new types as well (<a href="#one-var-one-type" class="calibre9">Item 20</a>). And to a large extent, the development of TypeScript has been driven by an attempt to accurately model the behavior of JavaScript libraries in the wild. Take advantage of all this work and use them!</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331659732216">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Use built-in functional constructs and those in utility libraries like Lodash instead of hand-rolled constructs to improve type flow, increase legibility, and reduce the need for explicit type annotations.<a data-primary="" data-startref="lodash03" data-type="indexterm" id="idm45331659729880" class="calibre9"/><a data-primary="" data-startref="TAreduc03" data-type="indexterm" id="idm45331659728904" class="calibre9"/><a data-primary="" data-startref="Lutili03" data-type="indexterm" id="idm45331659727960" class="calibre9"/><a data-primary="" data-startref="Futility03" data-type="indexterm" id="idm45331659727016" class="calibre9"/><a data-primary="" data-startref="TIfunc03" data-type="indexterm" id="idm45331659726072" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>







</div></section></body></html>