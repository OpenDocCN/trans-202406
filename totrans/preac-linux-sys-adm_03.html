<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 3. Customizing the User Experience" data-type="chapter" epub:type="chapter"><div class="chapter" id="customizing_the_user_experience">
<h1><span class="label">Chapter 3. </span>Customizing the User Experience</h1>
<p>This chapter covers customizing the user experience <a contenteditable="false" data-primary="user experience, customizing" data-type="indexterm" id="ix_UX"/>for yourself and your users. System administrators are often called upon to make minor changes to a user’s environment or to the default environment for all users on the system (the latter is known as a global change). As long as any requested alterations and enhancements don’t compromise system security or violate corporate policy, there’s no harm in making changes that accommodate a user’s needs and workflows. Our duty as sysadmins is, after all, to the company first (and then to the user). The user is your customer.</p>
<p>Customizing the default user environment globally changes the environment for everyone on the system. However, you or the user can override some global parameters. You made such an override in <a data-type="xref" href="ch02.xhtml#working_with_permissions_and_privileged">Chapter 2</a> when you added the new <code>umask</code> to your user account. <a contenteditable="false" data-primary="umask command" data-secondary="overriding global parameters with" data-type="indexterm" id="idm45657881254960"/>By setting your personal <code>umask</code> preference after the global one was set, you superseded the one set by the system. It’s a common practice for users to customize the environments they have control over.</p>
<p>This chapter covers customizing your and your users’ environments by editing key files in each user’s home directory. As a system administrator, you’ll also explore the “global” versions of these environment files that can be changed or added to, enabling you to create a specific experience for your users.</p>
<section data-pdf-bookmark="Altering Home Directory Options" data-type="sect1"><div class="sect1" id="altering_home_directory_options">
<h1>Altering Home Directory Options</h1>
<p>In every user’s <a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-type="indexterm" id="ix_UXhome"/>home directory, a few hidden files control most of the user’s environment. <a contenteditable="false" data-primary="home directory (/home)" data-secondary="changing options for" data-type="indexterm" id="ix_homechg"/><a contenteditable="false" data-primary="shells" data-type="indexterm" id="idm45657875184320"/><a contenteditable="false" data-primary="bash" data-secondary="files to use for customization" data-type="indexterm" id="idm45657875183216"/>Since many Linux users use bash, it is the focus of the default and custom user environment discussions in this chapter. (Other shells such as ash, zsh, csh, and ksh are also available to you, and their hidden, user-editable files are similar in name, function, and structure.)</p>
<p>Because some users don’t have adequate skills to make the necessary changes, you might have to make them on the users’ behalf. The relevant files are as follows:</p>
<ul>
<li>
<p><em>.bashrc</em></p>
</li>
<li>
<p><em>.bash_logout</em></p>
</li>
</ul>
<p>Depending on your Linux distribution and previous configuration changes, you might also see files named <em>.profile</em>, <em>.bash_profile</em>, <em>.bash_login</em>, and <em>.bash_history</em> in your home directory.</p>
<p>You won’t have to make changes to all of them. For example, the <em>.bash_history</em> file doesn’t require any changes. It’s a log of issued commands, and there are no user-configurable items.<a contenteditable="false" data-primary=".bash_profile file" data-primary-sortas="bash" data-type="indexterm" id="idm45657875174608"/> When you log into a Linux system, the <em>.bashrc</em> file executes first, and then the <em>.bash_profile</em> executes. The <em>.bash_logout</em> file executes upon logout.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Be careful about which (and how many) programs, scripts, and messages you place in your startup files because if they’re corrupt, damaged, or half open, you might find that your login either is delayed or that you’re completely unable to log in and will have to be rescued by another sysadmin. Pass this warning on to your users, too.</p>
</div>
<p>When you log into a Linux system interactively, a group of files automatically execute to build your user environment, as described in the following sections.</p>
<section data-pdf-bookmark="Login Versus Nonlogin Shells" data-type="sect2"><div class="sect2" id="login_versus_nonlogin_shells">
<h2>Login Versus Nonlogin Shells</h2>
<p>You’ll read and hear about two types of interactive shells: login and nonlogin. <a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-tertiary="login versus nonlogin shells" data-type="indexterm" id="idm45657875167088"/><a contenteditable="false" data-primary="login versus nonlogin shells" data-type="indexterm" id="idm45657875165344"/><a contenteditable="false" data-primary="shells" data-secondary="login versus nonlogin shells" data-type="indexterm" id="idm45657875164272"/>An interactive login shell is one you SSH to or directly log into by supplying a username and password or SSH key. An interactive nonlogin shell is one for which you call a child shell from your command line:</p>
<pre data-type="programlisting">
$ bash
$ echo $SHLVL
2</pre>
<p>The <code>$SHLVL</code> is a variable that tracks your shell level.<a contenteditable="false" data-primary="$SHLVL variable" data-primary-sortas="SHLVL" data-type="indexterm" id="idm45657875290864"/> When you first log into an interactive shell with a username and password or a key, your <code>$SHLVL</code> is <code>1</code>. Child shells that you call after the first one increment the <code>SHLVL</code> variable. A child shell called in this way is an interactive, nonlogin shell because it is interactive but doesn’t involve a new login.</p>
</div></section>
<section data-pdf-bookmark="/etc/bashrc" data-type="sect2"><div class="sect2" id="solidusetcsolidusbashrc">
<h2>/etc/bashrc</h2>
<p>When you interactively log into a Linux system, <em>/etc/bashrc</em> is the first personalization file to execute. <a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-tertiary="/etc/bashrc" data-tertiary-sortas="etc" data-type="indexterm" id="idm45657875155120"/>The <em>/etc/bashrc</em> file also executes on interactive nonlogin shells. <a contenteditable="false" data-primary="/etc/bashrc file" data-primary-sortas="etc" data-type="indexterm" id="idm45657875153312"/>The <em>/etc/bashrc</em> file is a global personalization file that provides your login shell (bash) with functions and aliases. This file should be left as is—meaning that even as a system administrator, you shouldn’t edit it.</p>
<p>The information and warning shown here are reprinted from the <em>/etc/bashrc</em> file. You’ll see them if you attempt to edit the file:</p>
<pre data-type="programlisting">
# System-wide functions and aliases
# Environment stuff goes in /etc/profile

# It's NOT a good idea to change this file unless you know what you
# are doing. It's much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.</pre>
<p>The <em>/etc/bashrc</em> file is analogous to the <em>.bashrc</em> file in your home directory. If you need to change functions and aliases, change them there.</p>
</div></section>
<section data-pdf-bookmark="/etc/profile" data-type="sect2"><div class="sect2" id="solidusetcsolidusprofile">
<h2>/etc/profile</h2>
<p>The <em>/etc/profile</em> file is a system-wide startup file. It provides generic variables, paths, and other settings to all users. <a contenteditable="false" data-primary="paths (file)" data-type="indexterm" id="idm45657875148976"/><a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-tertiary="/etc/profile" data-tertiary-sortas="etc" data-type="indexterm" id="idm45657875148336"/><a contenteditable="false" data-primary="/etc/profile file" data-primary-sortas="etc" data-type="indexterm" id="idm45657875149872"/>A warning in this file, shown in the following code listing, states that you shouldn’t edit this file unless you know what you’re doing:</p>
<pre data-type="programlisting">
# System-wide environment and startup programs for login setup
# Functions and aliases go in /etc/bashrc

# It's NOT a good idea to change this file unless you know what you
# are doing. It's much better to create a custom.sh shell script in
# /etc/profile.d/ to make custom changes to your environment, as this
# will prevent the need for merging in future updates.</pre>
<p>Again, as stated in the warning, it’s better to edit the personalization files in the user’s home directory or create other global personalization files under <em>/etc/profile.d</em>.</p>
<p>However, these global settings can be overwritten by the individual personalization startup files located in the home directory. It is the second environment personalization file that executes when you log in to a Linux system. Strangely, it also calls the <em>/etc/bashrc</em> file so <em>/etc/bashrc</em> is executed twice.</p>
<p>The <em>/etc/profile</em> file is analogous to the <em>.bash_profile</em> file in your home directory. Change any environment settings there.<a contenteditable="false" data-primary=".bash_profile file" data-primary-sortas="bash" data-secondary="/etc/profile file analogous to" data-secondary-sortas="etc" data-type="indexterm" id="idm45657875139824"/></p>
</div></section>
<section data-pdf-bookmark=".bashrc" data-type="sect2"><div class="sect2" id="dotbashrc">
<h2>.bashrc</h2>
<p>The <em>.bashrc</em> file is a hidden file in your home directory. <a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-tertiary=".bashrc" data-tertiary-sortas="bashrc" data-type="indexterm" id="idm45657875135888"/><a contenteditable="false" data-primary=".bashrc file" data-primary-sortas="bashrc" data-secondary="customizations in" data-type="indexterm" id="idm45657875134000"/>It’s hidden because you don’t want direct access to it when renaming or deleting files with a wildcard.<a contenteditable="false" data-primary="home directory (/home)" data-secondary="changing options for" data-tertiary=".bashrc file" data-tertiary-sortas="bashrc" data-type="indexterm" id="idm45657875131328"/> You have full ownership of the file and can edit it at will. This file is for setting and including any functions you might need and setting aliases for commands. After the global personalization files execute, the <em>.bashrc</em> file executes. The <em>.bashrc</em> file, like its global analog, executes in interactive nonlogin shells. The following is a listing of an unchanged <em>.bashrc</em> file.<a contenteditable="false" data-primary="PATH environment variable" data-type="indexterm" id="idm45657875272976"/> You should augment or change your <code>PATH</code> in this file so that your shell behaves similarly for login and nonlogin instances:</p>
<pre data-type="programlisting">
# .bashrc

# Source global definitions
if [ -f /etc/bashrc ]; then
    . /etc/bashrc
fi

# User specific environment
if ! [[ "$PATH" =~ "$HOME/.local/bin:$HOME/bin:" ]]
then
    PATH="$HOME/.local/bin:$HOME/bin:$PATH"
fi
export PATH

# Uncomment the following line if you don't like systemctl's auto-paging feature:
# export SYSTEMD_PAGER=

# User specific aliases and functions</pre>
<p>Aliases are useful shortcuts to commands and their options.<a contenteditable="false" data-primary="aliases in .bashrc file" data-type="indexterm" id="idm45657875124384"/><a contenteditable="false" data-primary="commands, aliasing" data-type="indexterm" id="idm45657875123216"/> For example, if you want a “chatty” version of common commands, create the following aliases in your <code>.bashrc</code> file:</p>
<pre data-type="programlisting">
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'</pre>
<p>The <code>-i</code> option means <em>interactive</em> and asks you to verify before the command performs its action. <a contenteditable="false" data-primary="interactive commands" data-type="indexterm" id="idm45657875119360"/>You get a verification message when you issue the new aliased <code>rm</code> command. This option is especially handy for destructive commands such as <code>rm</code> because Linux isn’t “chatty.” For example, it provides no feedback when you remove a file. The <code>-i</code> option provides you with a more Windows command–like experience by prompting you to confirm your actions:</p>
<pre data-type="programlisting">
$ rm file4.txt
rm: remove regular empty file 'file4.txt'?</pre>
<p>Aliases are handy if you run the same commands and options frequently. For example, I create a few default aliases on every system I use. My most useful one is for long lists:</p>
<pre data-type="programlisting">
alias ll='ls -l'</pre>
<p>You can also create aliases on a per-session basis. This means that you can simply issue the alias command at the command line without saving it to a file, and it remains in effect until you log off or terminate the current shell.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Many sources recommend placing all customizations in the <em>.bashrc</em> file because it’s executed for interactive login and nonlogin shells. Making your shell customizations in the <em>.bashrc</em> file guarantees shell consistency.</p>
</div>
</div></section>
<section data-pdf-bookmark=".bash_profile" data-type="sect2"><div class="sect2" id="dotbash_profile">
<h2>.bash_profile</h2>
<p>The last file to <a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-tertiary=".bash_profile" data-tertiary-sortas="bash" data-type="indexterm" id="idm45657875128288"/>execute on an<a contenteditable="false" data-primary=".bash_profile file" data-primary-sortas="bash" data-secondary="customizations in" data-type="indexterm" id="idm45657875109248"/> interactive <a contenteditable="false" data-primary="home directory (/home)" data-secondary="changing options for" data-tertiary=".bash_profile file" data-tertiary-sortas="bash" data-type="indexterm" id="idm45657875107472"/>login is the <em>.bash_profile</em> file in your home directory:</p>
<pre data-type="programlisting">
# .bash_profile

# Get the aliases and functions
if [ -f ~/.bashrc ]; then
    . ~/.bashrc
fi

# User specific environment and startup programs</pre>
<p>You may place customizations in this file that will run in interactive login shells, but they will not be available for interactive, nonlogin shells.</p>
</div></section>
<section data-pdf-bookmark=".bash_logout" data-type="sect2"><div class="sect2" id="dotbash_logout">
<h2>.bash_logout</h2>
<p>The <em>.bash_logout</em> file executes upon logout. <a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-tertiary=".bash_logout" data-tertiary-sortas="bash" data-type="indexterm" id="idm45657875100736"/><a contenteditable="false" data-primary=".bash_logout file" data-primary-sortas="bash" data-type="indexterm" id="idm45657875098816"/><a contenteditable="false" data-primary="home directory (/home)" data-secondary="changing options for" data-tertiary=".bash_logout file" data-tertiary-sortas="bash" data-type="indexterm" id="idm45657875097440"/>This file is optional. It only exists to allow users to clean up temporary files on exit. One could also use it to log time using the shell or to send a message upon logout.</p>
<p>In the next section, you learn the origins of these shell personalization files and how you can change the defaults for each user.<a contenteditable="false" data-primary="home directory (/home)" data-secondary="changing options for" data-startref="ix_homechg" data-type="indexterm" id="idm45657875105104"/><a contenteditable="false" data-primary="user experience, customizing" data-secondary="home directory options" data-startref="ix_UXhome" data-type="indexterm" id="idm45657875093136"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="The /etc/skel Directory" data-type="sect1"><div class="sect1" id="the_solidusetcsolidusskel_directory">
<h1>The /etc/skel Directory</h1>
<p>The <em>/etc/skel</em> directory is a special directory for holding files you want every user to receive in their home directories as you create their user accounts.<a contenteditable="false" data-primary="user experience, customizing" data-secondary="/etc/skel directory" data-secondary-sortas="etc" data-type="indexterm" id="idm45657875089280"/><a contenteditable="false" data-primary="/etc/skel directory" data-primary-sortas="etc" data-type="indexterm" id="idm45657875087360"/> The files you create in <em>/etc/skel</em> don’t have to be hidden, although the default ones are. These files are copied to the user’s home directory during account creation. These are the global copies of the environment personalization files.<a contenteditable="false" data-primary="Red Hat Enterprise Linux" data-secondary="default files in /etc/skel directory" data-type="indexterm" id="idm45657875084672"/> The list of <em>/etc/skel</em> default files on Red Hat Enterprise Linux–based systems is shown in the following example:</p>
<pre data-type="programlisting">
# ls -la /etc/skel
total 28
drwxr-xr-x.   2 root root   76 Jul  4 12:45 .
drwxr-xr-x. 144 root root 8192 Jul  4 11:07 ..
-rw-r--r--.   1 root root   18 Apr 21 10:04 .bash_logout
-rw-r--r--.   1 root root  141 Apr 21 10:04 .bash_profile
-rw-r--r--.   1 root root  376 Apr 21 10:04 .bashrc
-rw-r--r--.   1 root root  658 Mar  3  2020 .zshrc</pre>
<p>If you create a file in the <em>/etc/skel</em> directory, it’s copied to a new user’s home directory during account creation. Existing users won’t receive files placed in <em>/etc/skel</em> after you have created their accounts. You’ll have to manually copy those to each user’s home directory and change the permissions so that the user has full control of them.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Linux has <a contenteditable="false" data-primary="help system (man pages)" data-type="indexterm" id="idm45657875095104"/>a local help <a contenteditable="false" data-primary="man (manual) pages" data-type="indexterm" id="idm45657875078784"/>system known as manual pages, or <em>man pages</em> for short. If you need help for a command, configuration, or system setting, enter <code>man</code> and the keyword to see if the documentation exists for it. For example, for help with the <code>ls</code> command, you’d use <code>$ man ls</code>. You can move through the man pages using vi (Vim) navigation commands.<a contenteditable="false" data-primary="vi (Vim), moving through man pages with" data-type="indexterm" id="idm45657875074416"/></p>
</div>
</div></section>
<section data-pdf-bookmark="Customizing the Shell Prompt" data-type="sect1"><div class="sect1" id="customizing_the_shell_prompt">
<h1>Customizing the Shell Prompt</h1>
<p>Generally, users accept the default prompt presented by the system.<a contenteditable="false" data-primary="shell prompt" data-secondary="customizing" data-type="indexterm" id="ix_shprmpt"/><a contenteditable="false" data-primary="user experience, customizing" data-secondary="shell prompt" data-type="indexterm" id="ix_UXshprmpt"/> Generically, it looks like <code>[username@hostname pwd]$</code> or, specifically in my case, <code>[khess​@server1 ~]⁠$</code>. The tilde (<code>~</code>) represents the user’s home directory. <a contenteditable="false" data-primary="bash" data-secondary="customizing the shell prompt" data-type="indexterm" id="idm45657875067792"/><a contenteditable="false" data-primary="tilde (~), representing home directory" data-type="indexterm" id="idm45657875066320"/><a contenteditable="false" data-primary="home directory (/home)" data-secondary="represented by tilde (~) in file path" data-type="indexterm" id="idm45657875065248"/>For example, in the previous sections discussing personalization scripts, they are often represented as <code>~/.bashrc</code> and <code>~/.bash_profile</code> to illustrate that these files are located in the user’s home directories.</p>
<p>To set a custom prompt, the shell provides a list of escape characters representing locations, username, time, carriage returns, etc. <a contenteditable="false" data-primary="escaped characters in bash prompt strings" data-type="indexterm" id="idm45657875061984"/>For example, the default prompt is given by the following code for the prompt environment variable (<code>PS1</code>): <code>PS1="[\u@\h \W]\\$ "</code>. The system sets this default prompt in the <em>/etc/bashrc</em> file. You may override it with an entry in your <em>~/.bashrc</em> file.<a contenteditable="false" data-primary=".bashrc file" data-primary-sortas="bashrc" data-secondary="customizing shell prompt in" data-type="indexterm" id="idm45657875058128"/></p>
<p>Bash allows these prompt strings to be<a contenteditable="false" data-primary="backslash-escaped special characters in bash prompt strings" data-type="indexterm" id="idm45657875056976"/> customized by inserting a number of backslash-escaped special characters that are decoded as shown in <a data-type="xref" href="#backslash_escaped_special_characters">Table 3-1</a>.</p>
<table class="border" id="backslash_escaped_special_characters">
<caption><span class="label">Table 3-1. </span>Backslash-escaped special characters</caption>
<thead>
<tr>
<th>Special character</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\a</code></td>
<td>An ASCII bell character (07)</td>
</tr>
<tr>
<td><code>\d</code></td>
<td>The date in “Weekday Month Date” format (e.g., “Tue May 26”)</td>
</tr>
<tr>
<td><code>\D{format}</code></td>
<td>The format is passed to <code>strftime(3)</code> and the result is inserted into the prompt string; an empty format results in a locale-specific time representation. The braces are required.</td>
</tr>
<tr>
<td><code>\e</code></td>
<td>An ASCII escape character (033)</td>
</tr>
<tr>
<td><code>\h</code></td>
<td>The hostname up to the first <code>'.'</code></td>
</tr>
<tr>
<td><code>\H</code></td>
<td>The hostname</td>
</tr>
<tr>
<td><code>\j</code></td>
<td>The number of jobs currently managed by the shell</td>
</tr>
<tr>
<td><code>\l</code></td>
<td>The basename of the shell’s terminal device name</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>Newline</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>Carriage return</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>The name of the shell, the basename of <code>$0</code> (the portion following the final slash)</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>The current time in 24-hour HH:MM:SS format</td>
</tr>
<tr>
<td><code>\T</code></td>
<td>The current time in 12-hour HH:MM:SS format</td>
</tr>
<tr>
<td><code>\@</code></td>
<td>The current time in 12-hour am/pm format</td>
</tr>
<tr>
<td><code>\A</code></td>
<td>The current time in 24-hour HH:MM format</td>
</tr>
<tr>
<td><code>\u</code></td>
<td>The username of the current user</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>The version of bash (e.g., 2.00)</td>
</tr>
<tr>
<td><code>\V</code></td>
<td>The release of bash, version + patch level (e.g., 2.00.0)</td>
</tr>
<tr>
<td><code>\w</code></td>
<td>The current working directory, with <code>$HOME</code> abbreviated with a tilde (uses the value of the <code>PROMPT_DIRTRIM</code> variable)</td>
</tr>
<tr>
<td><code>\W</code></td>
<td>The basename of the current working directory, with <code>$HOME</code> abbreviated with a tilde</td>
</tr>
<tr>
<td><code>\!</code></td>
<td>The history number of this command</td>
</tr>
<tr>
<td><code>\#</code></td>
<td>The command number of this command</td>
</tr>
<tr>
<td><code>\$</code></td>
<td>If the effective UID is <code>0</code>, a <code>#</code>, otherwise a <code>$</code></td>
</tr>
<tr>
<td><code>\nnn</code></td>
<td>The character corresponding to the octal number <code>nnn</code></td>
</tr>
<tr>
<td><code>\\</code></td>
<td>A backslash</td>
</tr>
<tr>
<td><code>\[</code></td>
<td>Begin a sequence of nonprinting characters which could be used to embed a terminal control sequence into the prompt</td>
</tr>
<tr>
<td><code>\]</code></td>
<td>End a sequence of nonprinting characters</td>
</tr>
</tbody>
</table>
<p>The default prompt is sufficient for most users, but some users and sysadmins prefer something a little different, so they’re free to change it. Some clever users have devised codes for colorful and artistic prompts, such as this Christmas-themed prompt:</p>
<pre data-type="programlisting">
PS1="<img height="108" src="assets/santa.png" width="97"/>\[\e[33;41m\][\[\e[m\]\[\e[32m\]\u\[\e[m\]\[\e[36m\]@\[\e[m\] \
\[\e[34m\]\h\[\e[m\]\[\e[33;41m\]]\[\e[m\]<img height="108" src="assets/tree.png" width="83"/> "
</pre>
<p>Search online for “fun Linux prompts” and enjoy yourself. After playing with that, you can log out and back in to reset your prompt or enter <code>PS1="[\u@\h \W]\\$ "</code> to return to the default.<a contenteditable="false" data-primary="shell prompt" data-secondary="customizing" data-startref="ix_shprmpt" data-type="indexterm" id="idm45657875044384"/><a contenteditable="false" data-primary="user experience, customizing" data-secondary="shell prompt" data-startref="ix_UXshprmpt" data-type="indexterm" id="idm45657875000048"/></p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00003">
<h1>Summary</h1>
<p>In this chapter, you learned how to edit user environments through personalization files and the default location and configuration for adding more files to new accounts. You also learned these files’ locations, the order they’re loaded, and which ones you should edit for a particular effect. Finally, you had a brief overview of the shell prompt and how to alter it.</p>
<p>In <a data-type="xref" href="ch04.xhtml#managing_users">Chapter 4</a>, you’ll get an overview of user management from user account creation to managing users through groups to how to grant access to resources.<a contenteditable="false" data-primary="user experience, customizing" data-startref="ix_UX" data-type="indexterm" id="idm45657875504752"/></p>
</div></section>
</div></section></div></body></html>