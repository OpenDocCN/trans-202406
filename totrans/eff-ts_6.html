<html><head></head><body><section data-pdf-bookmark="Chapter 6. Types Declarations and @types" data-type="chapter" epub:type="chapter" class="praise"><div class="praise" id="ch-declarations">
<h1 class="calibre14"><span class="calibre">Chapter 6. </span>Types Declarations and @types</h1>


<p class="author1">Dependency management can be confusing in any language, and TypeScript is no exception. This chapter will help you build a mental model for how dependencies work in TypeScript and show you how to work through some of the issues that can come up with them. It will also help you craft your own type declaration files to publish and share with others. By writing great type declarations, you can help not just your own project but the entire TypeScript community.</p>






<section data-pdf-bookmark="Item 45: Put TypeScript and @types in devDependencies" data-type="sect1" class="praise"><div class="praise" id="dev-dependencies">
<h1 class="calibre16">Item 45: Put TypeScript and @types in devDependencies</h1>

<p class="author1">The<a data-primary="type dependencies" data-see="@types" data-type="indexterm" id="idm45331649895608" class="calibre9"/><a data-primary="Node Package Manager (npm), dependency distinctions in" data-type="indexterm" id="idm45331649894600" class="calibre9"/><a data-primary="dependencies" data-type="indexterm" id="idm45331649893960" class="calibre9"/><a data-primary="@types (type dependencies)" data-secondary="installing in devDependencies" data-type="indexterm" id="idm45331649893288" class="calibre9"/><a data-primary="devDependencies" data-type="indexterm" id="idm45331649892312" class="calibre9"/><a data-primary="TypeScript" data-secondary="installing as a devDependency" data-type="indexterm" id="idm45331649891640" class="calibre9"/><a data-primary="type declaration" data-secondary="TypeScript and @types" data-type="indexterm" id="idm45331649890680" class="calibre9"/> Node Package Manager, npm, is ubiquitous in the JavaScript world. It provides both a repository of JavaScript libraries (the npm registry) and a way to specify which versions of them you depend on (<em class="calibre3">package.json</em>).</p>

<p class="author1">npm draws a distinction between a few types of dependencies, each of which goes in a separate section of <em class="calibre3">package.json</em>:</p>
<dl class="praise">
<dt class="calibre19"><code class="calibre18">dependencies</code></dt>
<dd class="calibre20">
<p class="author1">These<a data-primary="Lodash library" data-type="indexterm" id="lodash06" class="calibre9"/> are packages that are required to run your JavaScript. If you import <code class="calibre18">lodash</code> at runtime, then it should go in <code class="calibre18">dependencies</code>. When you publish your code on npm and another user installs it, it will also install these dependencies. (These are known as transitive dependencies.)</p>
</dd>
<dt class="calibre19"><code class="calibre18">devDependencies</code></dt>
<dd class="calibre20">
<p class="author1">These packages are used to develop and test your code but are not required at runtime. Your test framework would be an example of a <code class="calibre18">devDependency</code>. Unlike <code class="calibre18">dependencies</code>, these are <em class="calibre3">not</em> installed transitively with your packages.</p>
</dd>
<dt class="calibre19"><code class="calibre18">peerDependencies</code></dt>
<dd class="calibre20">
<p class="author1">These are packages that you require at runtime but don’t want to be responsible for tracking. The canonical example is a plug-in. Your<a data-primary="jQuery" data-secondary="dependencies" data-type="indexterm" id="idm45331649879656" class="calibre9"/> jQuery plug-in is compatible with a range of versions of jQuery itself, but you’d prefer that the user select one, rather than you choosing for them.</p>
</dd>
</dl>

<p class="author1">Of these, <code class="calibre18">dependencies</code> and <code class="calibre18">devDependencies</code> are by far the most common. As you use TypeScript, be aware of which type of dependency you’re adding. Because TypeScript is a development tool and TypeScript types do not exist at runtime (<a href="ch01.html#independent" class="calibre9">Item 3</a>), packages related to TypeScript generally belong in <code class="calibre18">devDependencies</code>.</p>

<p class="author1">The first dependency to consider is TypeScript itself. It is possible to install TypeScript system-wide, but this is generally a bad idea for two reasons:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">There’s no guarantee that you and your coworkers will always have the same version installed.</p>
</li>
<li class="calibre12">
<p class="author1">It adds a step to your project setup.</p>
</li>
</ul>

<p class="author1">Make TypeScript a <code class="calibre18">devDependency</code> instead. That way you and your coworkers will always get the correct version when you run <code class="calibre18">npm install</code>. And updating your TypeScript version follows the same pattern as updating any other package.</p>

<p class="author1">Your IDE and build tools will happily discover a version of TypeScript installed in this way. On the command line you can use <code class="calibre18">npx</code> to run the version of <code class="calibre18">tsc</code> installed by npm:</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npx tsc</strong></pre>

<p class="author1">The<a data-primary="DefinitelyTyped" data-type="indexterm" id="idm45331649855624" class="calibre9"/> next type of dependency to consider is <em class="calibre3">type dependencies</em> or <code class="calibre18">@types</code>. If a library itself does not come with TypeScript type declarations, then you may still be able to find typings on DefinitelyTyped, a community-maintained collection of type definitions for JavaScript libraries. Type definitions from DefinitelyTyped are published on the npm registry under the <code class="calibre18">@types</code> scope: <code class="calibre18">@types/jquery</code> has type definitions for the jQuery, <code class="calibre18">@types/lodash</code> has types for Lodash, and so on. These <code class="calibre18">@types</code> packages only contain the <em class="calibre3">types</em>. They don’t contain the implementation.</p>

<p class="author1">Your <code class="calibre18">@types</code> dependencies should also be <code class="calibre18">devDependencies</code>, even if the package itself is a direct dependency. For example, to depend on<a data-primary="React library" data-secondary="dependencies" data-type="indexterm" id="react06" class="calibre9"/> React and its type declarations, you might run:</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npm install react</strong></pre>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npm install --save-dev @types/react</strong></pre>

<p class="author1">This will result in a <em class="calibre3">package.json</em> file that looks something like this:</p>

<pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"devDependencies"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"@types/lodash"</code><code class="p">:</code> <code class="s">"^16.8.19"</code><code class="p">,</code>
    <code class="nt">"typescript"</code><code class="p">:</code> <code class="s">"^3.5.3"</code>
  <code class="p">},</code>
  <code class="nt">"dependencies"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"react"</code><code class="p">:</code> <code class="s">"^16.8.6"</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The idea here is that you should publish JavaScript, not TypeScript, and your JavaScript does not depend on the <code class="calibre18">@types</code> when you run it. There are a few things that can go wrong with <code class="calibre18">@types</code> dependencies, and the next item will delve deeper into this topic.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331649821832">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Avoid installing TypeScript system-wide. Make TypeScript a <code class="calibre18">devDependency</code> of your project to ensure that everyone on the team is using a consistent version.</p>
</li>
<li class="calibre12">
<p class="author1">Put <code class="calibre18">@types</code> dependencies in <code class="calibre18">devDependencies</code>, not <code class="calibre18">dependencies</code>. If you need <code class="calibre18">@types</code> at runtime, then you may want to rework your process.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 46: Understand the Three Versions Involved in Type Declarations" data-type="sect1" class="praise"><div class="praise" id="three-versions">
<h1 class="calibre16">Item 46: Understand the Three Versions Involved in Type Declarations</h1>

<p class="author1">Dependency management<a data-primary="type declaration" data-secondary="three versions involved in" data-type="indexterm" id="TDthree06" class="calibre9"/><a data-primary="versions, managing for type declarations" data-type="indexterm" id="Vmanage06" class="calibre9"/><a data-primary="@types (type dependencies)" data-secondary="three versions involved in" data-type="indexterm" id="attypethree06" class="calibre9"/> rarely conjures up happy feelings for software developers. Usually you just want to use a library and not think too much about whether its transitive dependencies are compatible with yours.</p>

<p class="author1">The bad news is that TypeScript doesn’t make this any better. In fact, it makes dependency management quite a bit <em class="calibre3">more</em> complicated. This is because instead of having a single version to worry about, you now have three:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">The version of the package</p>
</li>
<li class="calibre12">
<p class="author1">The version of its type declarations (<code class="calibre18">@types</code>)</p>
</li>
<li class="calibre12">
<p class="author1">The version of TypeScript</p>
</li>
</ul>

<p class="author1">If any of these versions get out of sync with one another, you can run into errors that may not be clearly related to dependency management. But as the saying goes, “make things as simple as possible but no simpler.” Understanding the full complexity of TypeScript package management will help you diagnose and fix problems. And it will help you make more informed decisions when it comes time to publish type declarations of your own.</p>

<p class="author1">Here’s how dependencies in TypeScript are supposed to work. You install a package as a direct dependency, and you install its types as a dev dependency (see <a href="#dev-dependencies" class="calibre9">Item 45</a>):</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npm install react</strong>
+ react@16.8.6

$ <strong class="calibre32">npm install --save-dev @types/react</strong>
+ @types/react@16.8.19</pre>

<p class="author1">Note that the major and minor versions (<code class="calibre18">16.8</code>) match but that the patch versions (<code class="calibre18">.6</code> and <code class="calibre18">.19</code>) do not. This is exactly what you want to see. The <code class="calibre18">16.8</code> in the <code class="calibre18">@types</code> version means that these type declarations describe the API of version <code class="calibre18">16.8</code> of <code class="calibre18">react</code>. Assuming the <code class="calibre18">react</code> module follows good semantic versioning hygiene, the patch versions (<code class="calibre18">16.8.1</code>, <code class="calibre18">16.8.2</code>, …) will not change its public API and will not require updates to the type declarations. But the type declarations <em class="calibre3">themselves</em> might have bugs or omissions. The patch versions of the <code class="calibre18">@types</code> module correspond to these sorts of fixes and additions. In this case, there were many more updates to the type declarations than the library itself (19 versus 6).</p>

<p class="author1">This can go wrong in a few ways.</p>

<p class="author1">First, you might update a library but forget to update its type declarations. In this case you’ll get type errors whenever you try to use new features of the library. If there were breaking changes to the library, you might get runtime errors despite your code passing the type checker.</p>

<p class="author1">The solution is usually to update your type declarations so that the versions are back in sync. If the type declarations have not been updated, you have a few options. You can use an augmentation in your own project to add new functions and methods that you’d like to use. Or you can contribute updated type declarations back to the <span class="calibre">community</span>.</p>

<p class="author1">Second, your type declarations might get ahead of your library. This can happen if you’ve been using a library without its typings (perhaps you gave it an <code class="calibre18">any</code> type using <code class="calibre18">declare module</code>) and try to install them later. If there have been new releases of the library and its type declarations, your versions might be out of sync. The symptoms of this are similar to the first problem, just in reverse. The type checker will be comparing your code against the latest API, while you’ll be using an older one at runtime. The solution is to either upgrade the library or downgrade the type declarations until they match.</p>

<p class="author1">Third, the type declarations might require a newer version of TypeScript than you’re using in your project. Much of the development of TypeScript’s type system has been motivated by an attempt to more precisely type popular JavaScript libraries like<a data-primary="Ramda library" data-type="indexterm" id="idm45331649766744" class="calibre9"/> Lodash, React, and Ramda. It makes sense that the type declarations for these libraries would want to use the latest and greatest features to get you better type safety.<a data-primary="" data-startref="lodash06" data-type="indexterm" id="idm45331649765720" class="calibre9"/><a data-primary="" data-startref="react06" data-type="indexterm" id="idm45331649764776" class="calibre9"/></p>

<p class="author1">If this happens, you’ll experience it as type errors in the <code class="calibre18">@types</code> declarations themselves. The solution is to either upgrade your TypeScript version, use an older version of the type declarations, or, if you really can’t update TypeScript, stub out the types with <code class="calibre18">declare module</code>. It is possible for a library to provide different type declarations for different versions of TypeScript via <code class="calibre18">typesVersions</code>, but this is rare: at the time of this writing, fewer than 1% of the packages on<a data-primary="DefinitelyTyped" data-type="indexterm" id="idm45331649761768" class="calibre9"/> DefinitelyTyped did so.</p>

<p class="author1">To install <code class="calibre18">@types</code> for a specific version of TypeScript, you can use:</p>

<pre data-type="programlisting" class="calibre17">npm install --save-dev @types/lodash@ts3.1</pre>

<p class="author1">The version matching between libraries and their types is best effort and may not always be correct. But the more popular the library is, the more likely it is that its type declarations will get this right.</p>

<p class="author1">Fourth, you can wind up with duplicate <code class="calibre18">@types</code> dependencies. Say you depend on <code class="calibre18">@types/foo</code> and <code class="calibre18">@types/bar</code>. If <code class="calibre18">@types/bar</code> depends on an incompatible version of <code class="calibre18">@types/foo</code>, then npm will attempt to resolve this by installing both versions, one in a nested folder:</p>

<pre data-type="programlisting" class="calibre17">node_modules/
  @types/
    foo/
      index.d.ts @1.2.3
    bar/
      index.d.ts
      node_modules/
        @types/
          foo/
            index.d.ts @2.3.4</pre>

<p class="author1">While this is sometimes OK for node modules that are used at runtime, it almost certainly won’t be OK for type declarations, which live in a flat global<a data-primary="namespace" data-secondary="type declarations and" data-type="indexterm" id="idm45331649754104" class="calibre9"/> namespace. You’ll see this as errors about duplicate declarations or declarations that cannot be merged. You can track down why you have a duplicate type declaration by running <code class="calibre18">npm ls @types/foo</code>. The solution is typically to update your dependency on <code class="calibre18">@types/foo</code> or <code class="calibre18">@types/bar</code> so that they are compatible. Transitive <code class="calibre18">@types</code> dependencies like these are often a source of trouble. If you’re publishing types, see <a href="#mirror-types-for-deps" class="calibre9">Item 51</a> for ways to avoid them.</p>

<p class="author1">Some<a data-primary="bundling types" data-type="indexterm" id="idm45331649749912" class="calibre9"/> packages, particularly those written in TypeScript, choose to bundle their own type declarations. This is usually indicated by a <code class="calibre18">"types"</code> field in their <em class="calibre3">package.json</em> which points to a <em class="calibre3">.d.ts</em> file:</p>

<pre data-code-language="json" data-type="programlisting" class="calibre17"><code class="p">{</code>
  <code class="nt">"name"</code><code class="p">:</code> <code class="s">"left-pad"</code><code class="p">,</code>
  <code class="nt">"version"</code><code class="p">:</code> <code class="s">"1.3.0"</code><code class="p">,</code>
  <code class="nt">"description"</code><code class="p">:</code> <code class="s">"String left pad"</code><code class="p">,</code>
  <code class="nt">"main"</code><code class="p">:</code> <code class="s">"index.js"</code><code class="p">,</code>
  <code class="nt">"types"</code><code class="p">:</code> <code class="s">"index.d.ts"</code><code class="p">,</code>
  <code class="si">//</code> <code class="si">...</code>
<code class="p">}</code></pre>

<p class="author1">Does this solve all our problems? Would I even be asking if the answer was “yes”?</p>

<p class="author1">Bundling types <em class="calibre3">does</em> solve the problem of version mismatch, particularly if the library itself is written in TypeScript and the type declarations are generated by <code class="calibre18">tsc</code>. But bundling has some problems of its own.</p>

<p class="author1">First, what if there’s an error in the bundled types that can’t be fixed through augmentation? Or the types worked fine when they were published, but a new TypeScript version has since been released which flags an error. With <code class="calibre18">@types</code> you could depend on the library’s implementation but not its type declarations. But with bundled types, you lose this option. One bad type declaration might keep you stuck on an old version of TypeScript. Contrast this with DefinitelyTyped: as TypeScript is developed, Microsoft runs it against all the type declarations on DefinitelyTyped. Breaks are fixed quickly.</p>

<p class="author1">Second, what if your types depend on another library’s type declarations? Usually this would be a <code class="calibre18">devDependency</code> (<a href="#dev-dependencies" class="calibre9">Item 45</a>). But if you publish your module and another user installs it, they won’t get your <code class="calibre18">devDependencies</code>. Type errors will result. On the other hand, you probably don’t want to make it a direct dependency either, since then your JavaScript users will install <code class="calibre18">@types</code> modules for no reason. <a href="#mirror-types-for-deps" class="calibre9">Item 51</a> discusses the standard workaround for this situation. But if you publish your types on DefinitelyTyped, this is not a problem at all: you declare your type dependency there and only your TypeScript users will get it.</p>

<p class="author1">Third, what if you need to fix an issue with the type declarations of an old version of your library? Would you be able to go back and release a patch update? DefinitelyTyped has mechanisms for simultaneously maintaining type declarations for different versions of the same library, something that might be hard for you to do in your own project.</p>

<p class="author1">Fourth, how committed to accepting patches for type declarations are you? Remember the versions of <code class="calibre18">react</code> and <code class="calibre18">@types/react</code> from the start of this item. There were three times more patch updates to the type declarations than the library itself. DefinitelyTyped is community-maintained and is able to handle this volume. In particular, if a library maintainer doesn’t look at a patch within five days, a global maintainer will. Can you commit to a similar turnaround time for your library?</p>

<p class="author1">Managing dependencies in TypeScript can be challenging, but it does come with rewards: well-written type declarations can help you learn how to use libraries correctly and can greatly improve your productivity with them. As you run into issues with dependency management, keep the three versions in mind.</p>

<p class="author1">If you are publishing packages, weigh the pros and cons of bundling type declarations versus publishing them on DefinitelyTyped. The official recommendation is to bundle type declarations only if the library is written in TypeScript. This works well in practice since <code class="calibre18">tsc</code> can automatically generate type declarations for you (using the <code class="calibre18">declaration</code> compiler option). For JavaScript libraries, handcrafted type declarations are more likely to contain errors, and they’ll require more updates. If you publish your type declarations on DefinitelyTyped, the community will help you support and maintain them.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331649703144">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">There are three versions involved in an <code class="calibre18">@types</code> dependency: the library version, the <code class="calibre18">@types</code> version, and the TypeScript version.</p>
</li>
<li class="calibre12">
<p class="author1">If you update a library, make sure you update the corresponding <code class="calibre18">@types</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Understand the pros and cons of bundling types versus publishing them on DefinitelyTyped. Prefer bundling types if your library is written in TypeScript and DefinitelyTyped if it is not.<a data-primary="" data-startref="TDthree06" data-type="indexterm" id="idm45331649697624" class="calibre9"/><a data-primary="" data-startref="Vmanage06" data-type="indexterm" id="idm45331649696648" class="calibre9"/><a data-primary="" data-startref="attypethree06" data-type="indexterm" id="idm45331649695704" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 47: Export All Types That Appear in Public APIs" data-type="sect1" class="praise"><div class="praise" id="export-your-types">
<h1 class="calibre16">Item 47: Export All Types That Appear in Public APIs</h1>

<p class="author1">Use<a data-primary="type declaration" data-secondary="types in public APIs" data-type="indexterm" id="idm45331649692952" class="calibre9"/><a data-primary="public APIs" data-secondary="exporting all types appearing in" data-type="indexterm" id="idm45331649691944" class="calibre9"/> TypeScript long enough and you’ll eventually find yourself wanting to use a <code class="calibre18">type</code> or <code class="calibre18">interface</code> from a third-party module only to find that it isn’t exported. Fortunately TypeScript’s tools for mapping between types are rich enough that, as a library user, you can almost always find a way to reference the type you want. As a library author, this means that you ought to just export your types to begin with. If a type ever appears in a function declaration, it is effectively exported. So you may as well make things explicit.</p>

<p class="author1">Suppose you want to create some secret, unexported types:</p>

<pre data-code-language="ts" data-type="programlisting" id="secret-santa" class="calibre17"><code class="kd">interface</code> <code class="nx">SecretName</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">interface</code> <code class="nx">SecretSanta</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="nx">SecretName</code><code class="p">;</code>
  <code class="nx">gift</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">export</code> <code class="kd">function</code> <code class="nx">getGift</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">SecretName</code><code class="p">,</code> <code class="nx">gift</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">SecretSanta</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">As a user of your module, I cannot directly import <code class="calibre18">SecretName</code> or <code class="calibre18">SecretSanta</code>, only <code class="calibre18">getGift</code>. But this is no barrier: because those types appear in an exported function signature, I can extract them. One way is to use the <code class="calibre18">Parameters</code> and <code class="calibre18">ReturnType</code> generic types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">MySanta</code> <code class="o">=</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">getGift</code><code class="o">&gt;</code><code class="p">;</code>  <code class="c">// SecretSanta</code>
<code class="kd">type</code> <code class="nx">MyName</code> <code class="o">=</code> <code class="nx">Parameters</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="nx">getGift</code><code class="o">&gt;</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// SecretName</code></pre>

<p class="author1">If your goal in not exporting these types was to preserve flexibility, then the jig is up! You’ve already committed to them by putting them in a public API. Do your users a favor and export them.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331649612872">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Export types that appear in any form in any public method. Your users will be able to extract them anyway, so you may as well make it easy for them.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 48: Use TSDoc for API Comments" data-type="sect1" class="praise"><div class="praise" id="use-tsdoc">
<h1 class="calibre16">Item 48: Use TSDoc for API Comments</h1>

<p class="author1">Here’s<a data-primary="type declaration" data-secondary="TSDoc for API comments" data-type="indexterm" id="idm45331649558760" class="calibre9"/><a data-primary="public APIs" data-secondary="TSDoc for API comments" data-type="indexterm" id="idm45331649557752" class="calibre9"/><a data-primary="TSDoc" data-type="indexterm" id="idm45331649556808" class="calibre9"/><a data-primary="JSDoc-style comments" data-type="indexterm" id="idm45331649556136" class="calibre9"/> a TypeScript function to generate a greeting:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// Generate a greeting. Result is formatted for display.</code>
<code class="kd">function</code> <code class="nx">greet</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">title</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">`Hello </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The author was kind enough to leave a comment describing what this function does. But for documentation intended to be read by users of your functions, it’s better to use JSDoc-style comments:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/** Generate a greeting. Result is formatted for display. */</code>
<code class="kd">function</code> <code class="nx">greetJSDoc</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">title</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">`Hello </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The reason is that there is a nearly universal convention in editors to surface JSDoc-style comments when the function is called (see <a data-type="xref" href="#efts-06in01" class="calibre9">Figure 6-1</a>).</p>

<figure class="width1"><div class="figure" id="efts-06in01">
<img alt="efts 06in01" src="assets/efts_06in01.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 6-1. </span>JSDoc-style comments are typically surfaced in tooltips in your editor.</h6>
</div></figure>

<p class="author1">Whereas the inline comment gets no such treatment (see <a data-type="xref" href="#efts-06in02" class="calibre9">Figure 6-2</a>).</p>

<figure class="width1"><div class="figure" id="efts-06in02">
<img alt="efts 06in02" src="assets/efts_06in02.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 6-2. </span>Inline comments are typically not shown in tooltips.</h6>
</div></figure>

<p class="author1">The<a data-primary="language services" data-secondary="commenting convention supported by" data-type="indexterm" id="idm45331649455128" class="calibre9"/><a data-primary="@param type" data-type="indexterm" id="idm45331649454152" class="calibre9"/><a data-primary="@returns type" data-type="indexterm" id="idm45331649453480" class="calibre9"/> TypeScript language service supports this convention, and you should take advantage of it. If a comment describes a public API, it should be JSDoc. In the context of TypeScript, these comments are sometimes called TSDoc. You can use many of the usual conventions like <code class="calibre18">@param</code> and <code class="calibre18">@returns</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * Generate a greeting.</code>
<code class="c"> * @param name Name of the person to greet</code>
<code class="c"> * @param salutation The person's title</code>
<code class="c"> * @returns A greeting formatted for human consumption.</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">greetFullTSDoc</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">title</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="s">`Hello </code><code class="si">${</code><code class="nx">title</code><code class="si">}</code><code class="s"> </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="s">`</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This lets editors show the relevant documentation for each parameter as you’re writing out a function call (as shown in <a data-type="xref" href="#efts-06in03" class="calibre9">Figure 6-3</a>).</p>

<figure class="width"><div class="figure" id="efts-06in03">
<img alt="efts 06in03" src="assets/efts_06in03.png" class="calibre52"/>
<h6 class="calibre29"><span class="calibre">Figure 6-3. </span>An @param annotation lets your editor show documentation for the current parameter as you type it.</h6>
</div></figure>

<p class="author1">You can also use TSDoc with type definitions:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/** A measurement performed at a time and place. */</code>
<code class="kd">interface</code> <code class="nx">Measurement</code> <code class="p">{</code>
  <code class="c">/** Where was the measurement made? */</code>
  <code class="nx">position</code>: <code class="nx">Vector3D</code><code class="p">;</code>
  <code class="c">/** When was the measurement made? In seconds since epoch. */</code>
  <code class="nx">time</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="c">/** Observed momentum */</code>
  <code class="nx">momentum</code>: <code class="nx">Vector3D</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">As you inspect individual fields in a <code class="calibre18">Measurement</code> object, you’ll get contextual documentation (see <a data-type="xref" href="#efts-06in04" class="calibre9">Figure 6-4</a>).</p>

<figure class="width1"><div class="figure" id="efts-06in04">
<img alt="efts 06in04" src="assets/efts_06in04.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 6-4. </span>TSDoc for a field is shown when you mouse over that field in your editor.</h6>
</div></figure>

<p class="author1">TSDoc comments are formatted using Markdown, so if you want to use bold, italic, or bulleted lists, you can (see <a data-type="xref" href="#efts_06in05" class="calibre9">Figure 6-5</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * This _interface_ has **three** properties:</code>
<code class="c"> * 1. x</code>
<code class="c"> * 2. y</code>
<code class="c"> * 3. z</code>
<code class="c"> */</code>
<code class="kd">interface</code> <code class="nx">Vector3D</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">y</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">z</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code></pre>

<figure class="width1"><div class="figure" id="efts_06in05">
<img alt="efts 06in05" src="assets/efts_06in05.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 6-5. </span>TSDoc comments</h6>
</div></figure>

<p class="author1">Try to avoid writing essays in your documentation, though: the best comments are short and to the point.</p>

<p class="author1">JSDoc includes some conventions for specifying type information (<code class="calibre18">@param {string} name ...</code>), but you should avoid these in favor of TypeScript types (<a href="ch04.html#jsdoc-repeat" class="calibre9">Item 30</a>).</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331649331864">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Use JSDoc-/TSDoc-formatted comments to document exported functions, classes, and types. This helps editors surface information for your users when it’s most relevant.</p>
</li>
<li class="calibre12">
<p class="author1">Use <code class="calibre18">@param</code>, <code class="calibre18">@returns</code>, and Markdown for formatting.</p>
</li>
<li class="calibre12">
<p class="author1">Avoid including type information in documentation (see <a href="ch04.html#jsdoc-repeat" class="calibre9">Item 30</a>).</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 49: Provide a Type for this in Callbacks" data-type="sect1" class="praise"><div class="praise" id="this-in-callbacks">
<h1 class="calibre16">Item 49: Provide a Type for this in Callbacks</h1>

<p class="author1">JavaScript’s<a data-primary="JavaScript" data-secondary="this keyword" data-type="indexterm" id="idm45331649299016" class="calibre9"/><a data-primary="type declaration" data-secondary="providing types for this keyword in callbacks" data-type="indexterm" id="idm45331649298008" class="calibre9"/><a data-primary="callbacks" data-secondary="providing types for this keyword in" data-type="indexterm" id="idm45331649297032" class="calibre9"/><a data-primary="this keyword" data-type="indexterm" id="idm45331649296120" class="calibre9"/> <code class="calibre18">this</code> keyword is one of the most notoriously confusing parts of the language. Unlike variables declared with <code class="calibre18">let</code> or <code class="calibre18">const</code>, which are lexically scoped, <code class="calibre18">this</code> is dynamically scoped: its value depends not on the way in which it was <em class="calibre3">defined</em> but on the way in which it was <em class="calibre3">called</em>.</p>

<p class="author1"><code class="calibre18">this</code> is most often used in classes, where it typically references the current instance of an object:</p>

<pre data-code-language="ts" data-type="programlisting" id="this-scoping-example" class="calibre17"><code class="kd">class</code> <code class="nx">C</code> <code class="p">{</code>
  <code class="nx">vals</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
  <code class="nx">logSquares() {</code>
    <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">val</code> <code class="nx">of</code> <code class="kd">this</code><code class="p">.</code><code class="nx">vals</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">val</code> <code class="o">*</code> <code class="nx">val</code><code class="p">);</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">();</code>
<code class="nx">c</code><code class="p">.</code><code class="nx">logSquares</code><code class="p">();</code></pre>

<p class="author1">This logs:</p>

<pre data-type="programlisting" id="this-scoping-example-output" class="calibre17">1
4
9</pre>

<p class="author1">Now look what happens if you try to put <code class="calibre18">logSquares</code> in a variable and call that:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">();</code>
<code class="kd">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">logSquares</code><code class="p">;</code>
<code class="nx">method</code><code class="p">();</code></pre>

<p class="author1">This version throws an error at runtime:</p>

<pre data-type="programlisting" class="calibre17">Uncaught TypeError: Cannot read property 'vals' of undefined</pre>

<p class="author1">The problem is that <code class="calibre18">c.logSquares()</code> actually does two things: it calls <code class="calibre18">C.prototype.logSquares</code> <em class="calibre3">and</em> it binds the value of <code class="calibre18">this</code> in that function to <code class="calibre18">c</code>. By pulling out a reference to <code class="calibre18">logSquares</code>, you’ve separated these, and <code class="calibre18">this</code> gets set to <code class="calibre18">undefined</code>.</p>

<p class="author1">JavaScript gives you complete control over <code class="calibre18">this</code> binding. You can use <code class="calibre18">call</code> to explicitly set <code class="calibre18">this</code> and fix the problem:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">c</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">C</code><code class="p">();</code>
<code class="kd">const</code> <code class="nx">method</code> <code class="o">=</code> <code class="nx">c</code><code class="p">.</code><code class="nx">logSquares</code><code class="p">;</code>
<code class="nx">method</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code>  <code class="c">// Logs the squares again</code></pre>

<p class="author1">There’s no reason that <code class="calibre18">this</code> had to be bound to an instance of <code class="calibre18">C</code>. It could have been bound to anything. So libraries can, and do, make the value of <code class="calibre18">this</code> part of their APIs. Even the DOM makes use of this. In an event handler, for instance:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s">'input'</code><code class="p">)</code><code class="o">!</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'change'</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>  <code class="c">// Logs the input element on which the event fired.</code>
<code class="p">});</code></pre>

<p class="author1"><code class="calibre18">this</code> binding often comes up in the context of callbacks like this one. If you want to define an <code class="calibre18">onClick</code> handler in a class, for example, you might try this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="nx">render() {</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code><code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code>: <code class="nx">this.onClick</code><code class="p">});</code>
  <code class="p">}</code>
  <code class="nx">onClick() {</code>
    <code class="nx">alert</code><code class="p">(</code><code class="s">`Reset </code><code class="si">${</code><code class="kd">this</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">When <code class="calibre18">Button</code> calls <code class="calibre18">onClick</code>, it will alert “Reset undefined.” Oops! As usual, the culprit is <code class="calibre18">this</code> binding. A common solution is to create a bound version of the method in the constructor:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code> <code class="o">=</code> <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">render() {</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code><code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code>: <code class="nx">this.onClick</code><code class="p">});</code>
  <code class="p">}</code>
  <code class="nx">onClick() {</code>
    <code class="nx">alert</code><code class="p">(</code><code class="s">`Reset </code><code class="si">${</code><code class="kd">this</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">onClick() { ... }</code> definition defines a property on <code class="calibre18">ResetButton.prototype</code>. This is shared by all instances of <code class="calibre18">ResetButton</code>. When you bind <code class="calibre18">this.onClick = ...</code> in the constructor, it creates a property called <code class="calibre18">onClick</code> on the instance of <code class="calibre18">ResetButton</code> with <code class="calibre18">this</code> bound to that instance. The <code class="calibre18">onClick</code> instance property comes before the <code class="calibre18">onClick</code> prototype property in the lookup sequence, so <code class="calibre18">this.onClick</code> refers to the bound function in the <code class="calibre18">render()</code> method.</p>

<p class="author1">There is a shorthand for binding that can sometimes be convenient:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="nx">render() {</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code><code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code>: <code class="nx">this.onClick</code><code class="p">});</code>
  <code class="p">}</code>
  <code class="nx">onClick</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">alert</code><code class="p">(</code><code class="s">`Reset </code><code class="si">${</code><code class="kd">this</code><code class="si">}</code><code class="s">`</code><code class="p">);</code>  <code class="c">// "this" always refers to the ResetButton instance.</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Here we’ve replaced <code class="calibre18">onClick</code> with an arrow function. This will define a new function every time a <code class="calibre18">ResetButton</code> is constructed with <code class="calibre18">this</code> set to the appropriate value. It’s instructive to look at the JavaScript that this generates:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">ResetButton</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">var</code> <code class="nx">_this</code> <code class="o">=</code> <code class="kd">this</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">()</code> <code class="p">{</code>
      <code class="nx">alert</code><code class="p">(</code><code class="s">"Reset "</code> <code class="o">+</code> <code class="nx">_this</code><code class="p">);</code>
    <code class="p">};</code>
  <code class="p">}</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">makeButton</code><code class="p">({</code> <code class="nx">text</code><code class="o">:</code> <code class="s">'Reset'</code><code class="p">,</code> <code class="nx">onClick</code><code class="o">:</code> <code class="kd">this</code><code class="p">.</code><code class="nx">onClick</code> <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">So what does this all have to do with TypeScript? Because <code class="calibre18">this</code> binding is part of JavaScript, TypeScript models it. This means that if you’re writing (or typing) a library that sets the value of <code class="calibre18">this</code> on callbacks, then you should model this, too.</p>

<p class="author1">You do this by adding a <code class="calibre18">this</code> parameter to your callback:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addKeyListener</code><code class="p">(</code>
  <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">,</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="nx">e</code>: <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'keydown'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fn</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="nx">e</code><code class="p">);</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">this</code> parameter is special: it’s not just another positional argument. You can see this if you try to call it with two parameters:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addKeyListener</code><code class="p">(</code>
  <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">,</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="nx">e</code>: <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'keydown'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fn</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="nx">e</code><code class="p">);</code>
        <code class="c">// ~ Expected 1 arguments, but got 2</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

<p class="author1">Even better, TypeScript will enforce that you call the function with the correct <code class="calibre18">this</code> context:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">addKeyListener</code><code class="p">(</code>
  <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">,</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">,</code> <code class="nx">e</code>: <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="nx">el</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s">'keydown'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">fn</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
 <code class="c">// ~~~~~ The 'this' context of type 'void' is not assignable</code>
 <code class="c">//       to method's 'this' of type 'HTMLElement'</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

<p class="author1">As a user of this function, you can reference <code class="calibre18">this</code> in the callback and get full type safety:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">let</code> <code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">;</code>
<code class="nx">addKeyListener</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">this</code><code class="p">.</code><code class="nx">innerHTML</code><code class="p">;</code>  <code class="c">// OK, "this" has type of HTMLElement</code>
<code class="p">});</code></pre>

<p class="author1">Of course, if you use an arrow function here, you’ll override the value of <code class="calibre18">this</code>. TypeScript will catch the issue:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">registerHandler</code><code class="p">(</code><code class="nx">el</code>: <code class="nx">HTMLElement</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">addKeyListener</code><code class="p">(</code><code class="nx">el</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="kd">this</code><code class="p">.</code><code class="nx">innerHTML</code><code class="p">;</code>
        <code class="c">// ~~~~~~~~~ Property 'innerHTML' does not exist on type 'Foo'</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Don’t forget about <code class="calibre18">this</code>! If you set the value of <code class="calibre18">this</code> in your callbacks, then it’s part of your API, and you should include it in your type declarations.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331648544184">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Understand how <code class="calibre18">this</code> binding works.</p>
</li>
<li class="calibre12">
<p class="author1">Provide a type for <code class="calibre18">this</code> in callbacks when it’s part of your API.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 50: Prefer Conditional Types to Overloaded Declarations" data-type="sect1" class="praise"><div class="praise" id="conditional-overload">
<h1 class="calibre16">Item 50: Prefer Conditional Types to Overloaded Declarations</h1>

<p class="author1">How<a data-primary="type declaration" data-secondary="conditional types versus overloaded declarations" data-type="indexterm" id="idm45331648480424" class="calibre9"/><a data-primary="overloaded declarations" data-type="indexterm" id="idm45331648479448" class="calibre9"/><a data-primary="conditional types" data-type="indexterm" id="idm45331648478776" class="calibre9"/> would you write a type declaration for this JavaScript function?</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1"><code class="calibre18">double</code> can be passed either a <code class="calibre18">string</code> or a <code class="calibre18">number</code>. So you might use a union type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="o">|</code><code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="o">|</code><code class="kt">string</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code></pre>

<p class="author1">(These examples all make use of TypeScript’s concept of function overloading. For a refresher, see <a href="ch01.html#independent" class="calibre9">Item 3</a>.)</p>

<p class="author1">While this declaration is accurate, it’s a bit imprecise:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// string | number</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// string | number</code></pre>

<p class="author1">When <code class="calibre18">double</code> is passed a <code class="calibre18">number</code>, it returns a <code class="calibre18">number</code>. And when it’s passed a <code class="calibre18">string</code>, it returns a <code class="calibre18">string</code>. This declaration misses that nuance and will produce types that are hard to work with.</p>

<p class="author1">You might try to capture this relationship using a generic:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="kt">number</code><code class="o">|</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code>

<code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// Type is 12</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// Type is "x"</code></pre>

<p class="author1">Unfortunately, in our zeal for precision we’ve overshot. The types are now a little <em class="calibre3">too</em> precise. When passed a <code class="calibre18">string</code> type, this <code class="calibre18">double</code> declaration will result in a <code class="calibre18">string</code> type, which is correct. But when passed a string <em class="calibre3">literal</em> type, the return type is the same string literal type. This is wrong: doubling <code class="calibre18">'x'</code> results in <code class="calibre18">'xx'</code>, not <code class="calibre18">'x'</code>.</p>

<p class="author1">Another option is to provide multiple type declarations. While TypeScript only allows you to write one implementation of a function, it allows you to write any number of type declarations. You can use this to improve the type of <code class="calibre18">double</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code>

<code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// Type is number</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// Type is string</code></pre>

<p class="author1">This is progress! But is this declaration correct? Unfortunately there’s still a subtle bug. This type declaration will work with values that are either a <code class="calibre18">string</code> or a <code class="calibre18">number</code>, but not with values that could be either:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="o">|</code><code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
             <code class="c">// ~ Argument of type 'string | number' is not assignable</code>
             <code class="c">//   to parameter of type 'string'</code>
<code class="p">}</code></pre>

<p class="author1">This call to <code class="calibre18">double</code> is safe and should return <code class="calibre18">string|number</code>. When you overload type declarations, TypeScript processes them one by one until it finds a match. The error you’re seeing is a result of the last overload (the <code class="calibre18">string</code> version) failing, because <code class="calibre18">string|number</code> is not assignable to <code class="calibre18">string</code>.</p>

<p class="author1">While you could patch this issue by adding a third <code class="calibre18">string|number</code> overload, the best solution is to use a <em class="calibre3">conditional type</em>. Conditional types are like if statements (conditionals) in type space. They’re perfect for situations like this one where there are a few possibilities that you need to cover:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">x</code>: <code class="nx">T</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="kd">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="kt">string</code> <code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code> <code class="kd">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code></pre>

<p class="author1">This is similar to the first attempt to type <code class="calibre18">double</code> using a generic, but with a more elaborate return type. You read the conditional type like you’d read a ternary (<code class="calibre18">?:</code>) operator in JavaScript:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">If <code class="calibre18">T</code> is a subset of <code class="calibre18">string</code> (e.g., <code class="calibre18">string</code> or a string literal or a union of string literals), then the return type is <code class="calibre18">string</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Otherwise return <code class="calibre18">number</code>.</p>
</li>
</ul>

<p class="author1">With this declaration, all of our examples work:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">num</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code>  <code class="c">// number</code>
<code class="kd">const</code> <code class="nx">str</code> <code class="o">=</code> <code class="kd">double</code><code class="p">(</code><code class="s">'x'</code><code class="p">);</code>  <code class="c">// string</code>

<code class="c">// function f(x: string | number): string | number</code>
<code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="o">|</code><code class="kt">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">double</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">number|string</code> example works because conditional types distribute over unions. When <code class="calibre18">T</code> is <code class="calibre18">number|string</code>, TypeScript resolves the conditional type as follows:</p>

<pre data-type="programlisting" class="calibre17">   (number|string) extends string ? string : number
-&gt; (number extends string ? string : number) |
   (string extends string ? string : number)
-&gt; number | string</pre>

<p class="author1">While the type declaration using overloading was simpler to write, the version using conditional types is more correct because it generalizes to the union of the individual cases. This is often the case for overloads. Whereas overloads are treated independently, the type checker can analyze conditional types as a single expression, distributing them over unions. If you find yourself writing an overloaded type declarations, consider whether it might be better expressed using a conditional type.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331648031864">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Prefer conditional types to overloaded type declarations. By distributing over unions, conditional types allow your declarations to support union types without additional overloads.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 51: Mirror Types to Sever Dependencies" data-type="sect1" class="praise"><div class="praise" id="mirror-types-for-deps">
<h1 class="calibre16">Item 51: Mirror Types to Sever Dependencies</h1>

<p class="author1">Suppose<a data-primary="type declaration" data-secondary="mirroring types to sever dependencies" data-type="indexterm" id="idm45331648001512" class="calibre9"/><a data-primary="@types (type dependencies)" data-secondary="JavaScript developers and" data-type="indexterm" id="idm45331648000536" class="calibre9"/><a data-primary="NodeJS" data-type="indexterm" id="idm45331647999656" class="calibre9"/> you’ve written a library for parsing<a data-primary="CSV" data-type="indexterm" id="idm45331647998856" class="calibre9"/> CSV files. Its API is simple: you pass in the contents of the CSV file and get back a list of objects mapping column names to values. As a convenience for your NodeJS users, you allow the contents to be either a <code class="calibre18">string</code> or a NodeJS <code class="calibre18">Buffer</code>:</p>

<pre data-code-language="ts" data-type="programlisting" id="parse-csv-with-node" class="calibre17"><code class="kd">function</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">contents</code>: <code class="kd">string</code> <code class="o">|</code> <code class="nx">Buffer</code><code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">column</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}[]</code>  <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="kd">typeof</code> <code class="nx">contents</code> <code class="o">===</code> <code class="s">'object'</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// It's a buffer</code>
    <code class="kd">return</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">contents</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="s">'utf8'</code><code class="p">));</code>
  <code class="p">}</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">The type definition for <code class="calibre18">Buffer</code> comes from the NodeJS type declarations, which you must install:</p>

<pre data-type="programlisting" class="calibre17">npm install --save-dev @types/node</pre>

<p class="author1">When you publish your CSV parsing library, you include the type declarations with it. Since your type declarations depend on the NodeJS types, you include these as a <code class="calibre18">devDependency</code> (<a href="#dev-dependencies" class="calibre9">Item 45</a>). If you do this, you’re liable to get complaints from two groups of users:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">JavaScript developers who wonder what these <code class="calibre18">@types</code> modules are that they’re depending on.</p>
</li>
<li class="calibre12">
<p class="author1">TypeScript web developers who wonder why they’re depending on NodeJS.</p>
</li>
</ul>

<p class="author1">These complaints are reasonable. The <code class="calibre18">Buffer</code> behavior isn’t essential and is only relevant for users who are using NodeJS already. And the declaration in <code class="calibre18">@types/node</code> is only relevant to NodeJS users who are also using TypeScript.</p>

<p class="author1">TypeScript’s<a data-primary="TypeScript" data-secondary="structural typing" data-type="indexterm" id="idm45331647915608" class="calibre9"/><a data-primary="structural typing" data-type="indexterm" id="idm45331647914600" class="calibre9"/> structural typing (<a href="ch01.html#structural" class="calibre9">Item 4</a>) can help you out of the jam. Rather than using the declaration of <code class="calibre18">Buffer</code> from <code class="calibre18">@types/node</code>, you can write your own with just the methods and properties you need. In this case that’s just a <code class="calibre18">toString</code> method that accepts an encoding:</p>

<pre data-code-language="ts" data-type="programlisting" id="parse-csv-buffer" class="calibre17"><code class="kd">interface</code> <code class="nx">CsvBuffer</code> <code class="p">{</code>
  <code class="nx">toString</code><code class="p">(</code><code class="nx">encoding</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">parseCSV</code><code class="p">(</code><code class="nx">contents</code>: <code class="kd">string</code> <code class="o">|</code> <code class="nx">CsvBuffer</code><code class="p">)</code><code class="o">:</code> <code class="p">{[</code><code class="nx">column</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">}[]</code>  <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">This interface is dramatically shorter than the complete one, but it does capture our (simple) needs from a <code class="calibre18">Buffer</code>. In a NodeJS project, calling <code class="calibre18">parseCSV</code> with a real <code class="calibre18">Buffer</code> is still OK because the types are compatible:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">parseCSV</code><code class="p">(</code><code class="kd">new</code> <code class="nx">Buffer</code><code class="p">(</code><code class="s">"column1,column2\nval1,val2"</code><code class="p">,</code> <code class="s">"utf-8"</code><code class="p">));</code>  <code class="c">// OK</code></pre>

<p class="author1">If your library only depends on the types for another library, rather than its implementation, consider mirroring just the declarations you need into your own code. This will result in a similar experience for your TypeScript users and an improved experience for everyone else.</p>

<p class="author1">If you depend on the implementation of a library, you may still be able to apply the same trick to avoid depending on its typings. But this becomes increasingly difficult as the dependence grows larger and more essential. If you’re copying a large portion of the type declarations for another library, you may want to formalize the relationship by making the <code class="calibre18">@types</code> dependency explicit.</p>

<p class="author1">This technique is also helpful for severing dependencies between your unit tests and production systems. See the <code class="calibre18">getAuthors</code> example in <a href="ch01.html#structural" class="calibre9">Item 4</a>.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331647851224">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Use structural typing to sever dependencies that are nonessential.</p>
</li>
<li class="calibre12">
<p class="author1">Don’t force JavaScript users to depend on <code class="calibre18">@types</code>. Don’t force web developers to depend on NodeJS.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 52: Be Aware of the Pitfalls of Testing Types" data-type="sect1" class="praise"><div class="praise" id="test-your-types">
<h1 class="calibre16">Item 52: Be Aware of the Pitfalls of Testing Types</h1>

<p class="author1">You<a data-primary="Testing types" data-type="indexterm" id="test06" class="calibre9"/><a data-primary="type declaration" data-secondary="pitfalls of testing types" data-type="indexterm" id="idm45331647843160" class="calibre9"/><a data-primary="equality" data-type="indexterm" id="idm45331647834120" class="calibre9"/><a data-primary="assignable to" data-type="indexterm" id="idm45331647833448" class="calibre9"/><a data-primary="callbacks" data-secondary="testing inferred types" data-type="indexterm" id="idm45331647832776" class="calibre9"/><a data-primary="functions" data-secondary="testing inferred types of callbacks" data-type="indexterm" id="idm45331647831832" class="calibre9"/> wouldn’t publish code without writing tests for it (I hope!), and you shouldn’t publish type declarations without writing tests for them, either. But how do you test types? If you’re authoring type declarations, testing is an essential but surprisingly fraught undertaking. It’s tempting to make assertions about types inside the type system using the tools that TypeScript provides. But there are several pitfalls with this approach. Ultimately it’s safer and more straightforward<a data-primary="dtslint" data-type="indexterm" id="idm45331647830280" class="calibre9"/> to use <code class="calibre18">dtslint</code> or a similar tool that inspects types from outside of the type system.</p>

<p class="author1">Suppose you’ve written a type declaration for a <code class="calibre18">map</code> function provided by a utility library (the popular<a data-primary="Lodash library" data-type="indexterm" id="idm45331647828232" class="calibre9"/><a data-primary="Underscore library" data-type="indexterm" id="idm45331647827528" class="calibre9"/> Lodash and Underscore libraries both provide such a function):</p>

<pre data-code-language="ts" data-type="programlisting" id="map-declaration" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">map</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code> <code class="nx">V</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">U</code><code class="p">[],</code> <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="nx">u</code>: <code class="nx">U</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">V</code><code class="p">)</code><code class="o">:</code> <code class="nx">V</code><code class="p">[];</code></pre>

<p class="author1">How can you check that this type declaration results in the expected types? (Presumably there are separate tests for the implementation.) One common technique is to write a test file that calls the function:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">map</code><code class="p">([</code><code class="s">'2017'</code><code class="p">,</code> <code class="s">'2018'</code><code class="p">,</code> <code class="s">'2019'</code><code class="p">],</code> <code class="nx">v</code> <code class="o">=&gt;</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">v</code><code class="p">));</code></pre>

<p class="author1">This will do some blunt error checking: if your declaration of <code class="calibre18">map</code> only listed a single parameter, this would catch the mistake. But does it feel like something is missing here?</p>

<p class="author1">The equivalent of this style of test for runtime behavior might look something like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">test</code><code class="p">(</code><code class="s">'square a number'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">square</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
  <code class="nx">square</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>
<code class="p">});</code></pre>

<p class="author1">Sure, this tests that the <code class="calibre18">square</code> function doesn’t throw an error. But it’s missing any checks on the return value, so there’s no real test of the behavior. An incorrect implementation of <code class="calibre18">square</code> would still pass this test.</p>

<p class="author1">This approach is common in testing type declaration files because it’s simple to copy over existing unit tests for a library. And while it does provide some value, it would be much better to actually check some types!</p>

<p class="author1">One way is to assign the result to a variable with a specific type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">lengths</code>: <code class="nx">number</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">map</code><code class="p">([</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">],</code> <code class="nx">name</code> <code class="o">=&gt;</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code></pre>

<p class="author1">This is exactly the sort of superfluous type declaration that <a href="ch03.html#avoid-inferable" class="calibre9">Item 19</a> would encourage you to remove. But here it plays an essential role: it provides some confidence that the <code class="calibre18">map</code> declaration is at least doing something sensible with the types. And indeed you can find many type declarations in DefinitelyTyped that use exactly this approach for testing. But, as we’ll see, there are a few fundamental problems with using assignment for testing.</p>

<p class="author1">One is that you have to create a named variable that is likely to be unused. This adds boilerplate, but also means that you’ll have to disable some forms of linting.</p>

<p class="author1">A common workaround is to define a helper:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">assertType</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code>: <code class="nx">T</code><code class="p">)</code> <code class="p">{}</code>

<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">map</code><code class="p">([</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">],</code> <code class="nx">name</code> <code class="o">=&gt;</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">));</code></pre>

<p class="author1">This eliminates the unused variable issue, but there are still surprises.</p>

<p class="author1">A second issue is that we’re checking <em class="calibre3">assignability</em> of the two types rather than equality. Often this works as you’d expect. For example:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">If you inspect the <code class="calibre18">n</code> symbol, you’ll see that its type is actually <code class="calibre18">12</code>, a numeric literal type. This is a subtype of <code class="calibre18">number</code> and so the assignability check passes, just as you’d expect.</p>

<p class="author1">So far so good. But things get murkier when you start checking the types of objects:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">beatles</code> <code class="o">=</code> <code class="p">[</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">,</code> <code class="s">'george'</code><code class="p">,</code> <code class="s">'ringo'</code><code class="p">];</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">{</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">}[]</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">map</code><code class="p">(</code><code class="nx">beatles</code><code class="p">,</code> <code class="nx">name</code> <code class="o">=&gt;</code> <code class="p">({</code>
    <code class="nx">name</code><code class="p">,</code>
    <code class="nx">inYellowSubmarine</code>: <code class="nx">name</code> <code class="o">===</code> <code class="s">'ringo'</code>
  <code class="p">})));</code>  <code class="c">// OK</code></pre>

<p class="author1">The <code class="calibre18">map</code> call returns an array of <code class="calibre18">{name: string, inYellowSubmarine: boolean}</code> objects. This is assignable to <code class="calibre18">{name: string}[]</code>, sure, but shouldn’t we be forced to acknowledge the yellow submarine? Depending on the context you may or may not really want to check for type equality.</p>

<p class="author1">If your function returns another function, you may be surprised at what’s considered assignable:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">add</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">add</code><code class="p">);</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="kd">double</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="kd">double</code><code class="p">);</code>  <code class="c">// OK!?</code></pre>

<p class="author1">Are you surprised that the second assertion succeeds? The reason is that a function in TypeScript is assignable to a function type, which takes fewer parameters:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">g</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code>: <code class="kd">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">12</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">This reflects the fact that it’s perfectly fine to call a JavaScript function with more parameters than it’s declared to take. TypeScript chooses to model this behavior rather than bar it, largely because it is pervasive in callbacks. The callback in the<a data-primary="Lodash library" data-type="indexterm" id="idm45331647376168" class="calibre9"/> Lodash <code class="calibre18">map</code> function, for example, takes up to three parameters:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">map</code><code class="p">(</code><code class="nx">array</code><code class="p">,</code> <code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">index</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">});</code></pre>

<p class="author1">While all three are available, it’s very common to use only one or sometimes two, as we have so far in this item. In fact, it’s quite rare to use all three. By disallowing this assignment, TypeScript would report errors in an enormous amount of JavaScript code.</p>

<p class="author1">So what can you do? You could break apart the function type and test its pieces using the generic <code class="calibre18">Parameters</code> and <code class="calibre18">ReturnType</code> types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="kd">double</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">p</code>: <code class="nx">Parameters</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="kd">double</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kd">null</code><code class="o">!</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="p">[</code><code class="kt">number</code><code class="p">,</code> <code class="kt">number</code><code class="p">]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">p</code><code class="p">);</code>
<code class="c">//                           ~ Argument of type '[number]' is not</code>
<code class="c">//                             assignable to parameter of type [number, number]</code>
<code class="kd">let</code> <code class="nx">r</code>: <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="kd">typeof</code> <code class="kd">double</code><code class="o">&gt;</code> <code class="o">=</code> <code class="kd">null</code><code class="o">!</code><code class="p">;</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">r</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">But if “this” isn’t complicated enough, there’s another issue: <code class="calibre18">map</code> sets the value of <code class="calibre18">this</code> for its callback. TypeScript can model this behavior (see <a href="#this-in-callbacks" class="calibre9">Item 49</a>), so your type declaration should do so. And you should test it. How can we do that?</p>

<p class="author1">Our tests of <code class="calibre18">map</code> so far have been a bit black box in style: we’ve run an array and function through <code class="calibre18">map</code> and tested the type of the result, but we haven’t tested the details of the intermediate steps. We can do so by filling out the callback function and verifying the types of its parameters and <code class="calibre18">this</code> directly:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">beatles</code> <code class="o">=</code> <code class="p">[</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">,</code> <code class="s">'george'</code><code class="p">,</code> <code class="s">'ringo'</code><code class="p">];</code>
<code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">map</code><code class="p">(</code>
  <code class="nx">beatles</code><code class="p">,</code>
  <code class="kd">function</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="p">{</code>
<code class="c">// ~~~~~~~ Argument of type '(name: any, i: any, array: any) =&gt; any' is</code>
<code class="c">//         not assignable to parameter of type '(u: string) =&gt; any'</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code><code class="p">);</code>
    <code class="nx">assertType</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
                      <code class="c">// ~~~~ 'this' implicitly has type 'any'</code>
    <code class="kd">return</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">));</code></pre>

<p class="author1">This surfaced a few issues with our declaration of <code class="calibre18">map</code>. Note the use of a non-arrow function so that we could test the type of <code class="calibre18">this</code>.</p>

<p class="author1">Here is a declaration that passes the checks:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">map</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code> <code class="nx">V</code><code class="o">&gt;</code><code class="p">(</code>
  <code class="nx">array</code>: <code class="nx">U</code><code class="p">[],</code>
  <code class="nx">fn</code><code class="o">:</code> <code class="p">(</code><code class="kd">this</code><code class="o">:</code> <code class="nx">U</code><code class="p">[],</code> <code class="nx">u</code>: <code class="nx">U</code><code class="p">,</code> <code class="nx">i</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">array</code>: <code class="nx">U</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">V</code>
<code class="p">)</code><code class="o">:</code> <code class="nx">V</code><code class="p">[];</code></pre>

<p class="author1">There remains a final issue, however, and it is a major one. Here’s a complete type declaration file for our module that will pass even the most stringent tests for <code class="calibre18">map</code> but is worse than useless:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="nx">module</code> <code class="s">'overbar'</code><code class="p">;</code></pre>

<p class="author1">This assigns an <code class="calibre18">any</code> type to the <em class="calibre3">entire module</em>. Your tests will all pass, but you won’t have any type safety. What’s worse, every call to a function in this module will quietly produce an <code class="calibre18">any</code> type, contagiously destroying type safety throughout your code. Even with <code class="calibre18">noImplicitAny</code>, you can still get <code class="calibre18">any</code> types through type declarations.</p>

<p class="author1">Barring some advanced trickery, it’s quite difficult to detect an <code class="calibre18">any</code> type from within the type system. This is why the preferred method for testing type declarations is to use a tool that operates <em class="calibre3">outside</em> the type checker.</p>

<p class="author1">For<a data-primary="dtslint" data-type="indexterm" id="idm45331647022328" class="calibre9"/> type declarations in the DefinitelyTyped repository, this tool is <code class="calibre18">dtslint</code>. It operates through specially formatted comments. Here’s how you might write the last test for the <code class="calibre18">map</code> function using <code class="calibre18">dtslint</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">beatles</code> <code class="o">=</code> <code class="p">[</code><code class="s">'john'</code><code class="p">,</code> <code class="s">'paul'</code><code class="p">,</code> <code class="s">'george'</code><code class="p">,</code> <code class="s">'ringo'</code><code class="p">];</code>
<code class="nx">map</code><code class="p">(</code><code class="nx">beatles</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code>
  <code class="nx">name</code><code class="p">,</code>  <code class="c">// $ExpectType string</code>
  <code class="nx">i</code><code class="p">,</code>     <code class="c">// $ExpectType number</code>
  <code class="nx">array</code>  <code class="c">// $ExpectType string[]</code>
<code class="p">)</code> <code class="p">{</code>
  <code class="kd">this</code>   <code class="c">// $ExpectType string[]</code>
  <code class="kd">return</code> <code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">});</code>  <code class="c">// $ExpectType number[]</code></pre>

<p class="author1">Rather than checking assignability, <code class="calibre18">dtslint</code> inspects the type of each symbol and does a textual comparison. This matches how you’d manually test the type declarations in your editor: <code class="calibre18">dtslint</code> essentially automates this process. This approach does have some drawbacks: <code class="calibre18">number|string</code> and <code class="calibre18">string|number</code> are textually different but the same type. But so are <code class="calibre18">string</code> and <code class="calibre18">any</code>, despite being assignable to each other, which is really the point.</p>

<p class="author1">Testing type declarations is tricky business. You <em class="calibre3">should</em> test them. But be aware of the pitfalls of some of the common techniques and consider using a tool like <code class="calibre18">dtslint</code> to avoid them.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331646906200">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">When testing types, be aware of the difference between equality and assignability, particularly for function types.</p>
</li>
<li class="calibre12">
<p class="author1">For functions that use callbacks, test the inferred types of the callback parameters. Don’t forget to test the type of <code class="calibre18">this</code> if it’s part of your API.</p>
</li>
<li class="calibre12">
<p class="author1">Be wary of <code class="calibre18">any</code> in tests involving types. Consider using a tool like <code class="calibre18">dtslint</code> for stricter, less error-prone checking.<a data-primary="" data-startref="test06" data-type="indexterm" id="idm45331646900536" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>







</div></section></body></html>