- en: Chapter 8\. Managing Disk Partitioning with parted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All mass storage drives—SATA hard disks, solid state drives, USB drives, SD
    (Secure Digital), NVMe (Non-Volatile Memory Express), and CompactFlash cards—must
    be partitioned and formatted with filesystems before you can use them. They all
    ship with some kind of partitioning and filesystems, which may not be what you
    want. As your needs change, you will want to repartition your disks and use different
    filesystems. In this chapter you will learn about using *parted* (partition editor)
    to manage partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*parted* only manages partitioning; see [Chapter 11](ch11.xhtml#cha-create-filesystems)
    to learn about filesystems. [Chapter 9](ch09.xhtml#cha-partitioning-gparted) covers
    the graphical frontend to *parted*, GParted, which manages both partitioning and
    filesystems.'
  prefs: []
  type: TYPE_NORMAL
- en: You will also learn about the modern replacement for the Master Boot Record
    (MBR), which is the elderly and inadequate legacy partition table. The MBR has
    been supplanted by the new Globally Unique Identifier Partition Table (GUID Partition
    Table or GPT).
  prefs: []
  type: TYPE_NORMAL
- en: '*parted* shows partition information and adds, removes, and resizes partitions.
    *parted* has just one gotcha: it writes your changes to disk immediately, so you
    must be careful. GParted does not apply changes until you click a button.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a common convenience to call all mass storage devices *disks*, even though
    many of them are not disks anymore, but solid-state devices, like USB sticks.
    Why not, when we still dial telephones, and make tape recordings and film videos
    with our smartphones?
  prefs: []
  type: TYPE_NORMAL
- en: A disk partition is a logical division of a storage disk, a way of dividing
    the disk into one or more independent regions. A disk must have at least one partition.
    The number of partitions depends on your needs and whims. After partitioning a
    disk, you must put a filesystem on each partition, and then you can use it. A
    single disk may have multiple partitions, and each partition may have a different
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The disk name on Linux is always */dev* something, which is short for device.
    For example, */dev/sda* for a hard disk, and */dev/sr0* for an optical drive.
    Partitions are the disk name plus a number. If */dev/sda* has three partitions,
    they are */dev/sda1*, */dev/sda2*, and */dev/sda3*.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning Schemes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default partitioning scheme on some Linux distributions is to stuff the
    whole installation into a single partition. This works fine, but setting up a
    few more partitions during installation has some advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Giving */boot* its own partition makes managing multiboot systems easier because
    the boot files are independent of whatever operating systems you install or remove.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put */home* on its own partition to isolate it from the root filesystem, so
    you can replace your Linux installation without touching */home*. */home* could
    even be on a separate drive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/var* and */tmp* can fill up from runaway processes. Putting them on their
    own partitions prevents them from interfering with the other filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting the swap file on its own partition enables suspend-to-disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Chapter 1](ch01.xhtml#cha-install-linux) to learn more about designing
    your partitioning layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partition Tables: GPT and MBR'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GUID Partition Table (GPT), first released in 2010, is the modern replacement
    for the antique PC-DOS Master Boot Record (MBR). If your only experience is with
    the MBR, prepare yourself for a treat, because the GPT is a big improvement.
  prefs: []
  type: TYPE_NORMAL
- en: The MBR was created for IBM PCs way back in the last millennium in the early
    1980s, during the exciting era of 10-megabyte (MB) hard disks. The MBR goes on
    the first 512 bytes of the first sector of your disk, preceding the first partition,
    and holds the bootloader and partition table. The bootloader occupies 446 bytes,
    the partition table uses 64 bytes, and the remaining 2 bytes store the boot signature.
  prefs: []
  type: TYPE_NORMAL
- en: '64 bytes is not much room to store much of anything, so the MBR is limited
    to four primary partitions. One primary partition may hold an extended partition,
    which can then be divided into logical partitions. Linux supports (theoretically)
    an unlimited number of logical partitions. Even with great thundering herds of
    logical partitions, the MBR is limited to addressing a maximum disk size of 2.2
    TiB, which these days is barely enough to hold your cat memes. Why this limitation?
    You can do the math yourself: the MBR is limited to 32 bits of addressing, and
    can address 2^(32) number of blocks (we’ll discuss blocks and sectors in a moment),
    so the equation for disks with 512-byte blocks is 2^(32) x 512 = 2.199023256×10^(12)
    bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: BIOS and UEFI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GPT is part of the UEFI (Unified Extensible Firmware Interface) specification.
    UEFI replaces your computer’s Basic Input Output System, better known as the PC
    BIOS, or just plain BIOS. [Figure 8-1](#fig-legacy-bios) is the old legacy BIOS,
    and [Figure 8-2](#fig-uefi-setup) is a modern UEFI, all full of shiny whizbang
    features, just like a little operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'GPT has many advantages over the MBR:'
  prefs: []
  type: TYPE_NORMAL
- en: Up to 128 partitions on Linux, numbered 1–128, and no messing with primary and
    extended partitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fault-tolerance: copies of the partition table are stored in multiple locations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unique IDs for disks and partitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy BIOS/MBR boot mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifies its own integrity and the partition table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Legacy BIOS setup](Images/lcb2_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Legacy BIOS setup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![UEFI setup](Images/lcb2_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. UEFI setup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The MBR is nearly obsolete, and you should use the GPT. In GPT, the first sector
    of the disk is reserved for a protective MBR that supports GPT on a BIOS computer,
    so we can use the GPT on older systems that have a BIOS instead of UEFI. The bootloader
    and operating system must both be GPT-aware, which has been the case with Linux
    for years. The only reason to use the MBR is on old computers with old operating
    systems that do not support the GPT.
  prefs: []
  type: TYPE_NORMAL
- en: If you have an older system with a BIOS, you cannot upgrade it to UEFI, but
    must replace the motherboard to get UEFI. Both UEFI and BIOS are integrated into
    the motherboard.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks and Sectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will talk about blocks and sectors, and how they affect the maximum sizes
    of your disks, files, and partitions. *Blocks* are the smallest storage units
    on a disk that a filesystem can use. These are logical, not physical, divisions.
    The smallest physical unit of storage is a *sector*. Blocks can span multiple
    sectors, and a file can span multiple blocks.
  prefs: []
  type: TYPE_NORMAL
- en: When a file spans multiple blocks, there is a certain amount of waste because
    files rarely match block sizes. For example, a file that is one byte larger than
    four blocks uses five blocks. The fifth block holds just that one byte, and that
    block is exclusive to the file. Because of this you might think that 512-byte
    blocks are less wasteful. But there is more information stored in a block than
    just the file.
  prefs: []
  type: TYPE_NORMAL
- en: Every block, in addition to your file data, stores timestamps, the filename,
    ownership, permissions, the block ID, and its correct order with other blocks,
    the inode, and other metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 4096-byte blocks use one-eighth the metadata of 512-byte blocks. On a 4 TiB
    hard disk, you need 8,000,000,000 512-byte blocks. With a 4096-byte block size
    there are only 1,000,000,000 blocks, which represents quite a lot of metadata
    savings.
  prefs: []
  type: TYPE_NORMAL
- en: The sector size limits the size of storage volumes. The standard sector size
    for hard disks has been 512 bytes for some years, and now 4096 bytes is the standard
    because hard disks have grown so large.
  prefs: []
  type: TYPE_NORMAL
- en: The GPT provides 64-bit addressing, supporting 2^(64) total blocks on a single
    disk, so a hard disk with 512-byte blocks can be as large as 9 zettabytes. With
    4096-byte blocks, your maximum disk size is 64 zettabytes, which I daresay is
    sufficient for even the most dedicated cat meme collector. These are theoretical
    maximums, limited by available hardware, operating system limits, and filesystem
    support for large volumes. For example, the Ext4 filesystem maxes out at 1 EiB
    for a single filesystem, and a maximum 16 TiB file size with a 4096-byte block
    size. XFS supports a maximum filesystem and file size of 8 EiB minus 1 byte.
  prefs: []
  type: TYPE_NORMAL
- en: CDs and DVDs have 2048-byte sectors. Solid-state devices such as USB sticks,
    SD cards, CompactFlash, and Solid State Drives (SSDs) also have sectors and blocks.
    The smallest unit on an SSD is called a *page*. Common page sizes are 2 KB, 4
    KB, 8 KB, and larger. Blocks contain 128 to 256 pages, and block size is typically
    256 KB to 4 MB.
  prefs: []
  type: TYPE_NORMAL
- en: All of these enormous numbers are a bit dizzying. [Table 8-1](#table-decimal-binary-bytes)
    summarizes the decimal and binary measurements used to measure disk capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Decimal and binary multiples of bytes
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Decimal | Value | Binary |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | B byte | 1 | B byte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | kB kilobyte | 1024 | KiB kibibyte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000² | MB megabyte | 1024² | MiB mebibyte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000³ | GB gigabyte | 1024³ | GiB gibibyte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000⁴ | TB terabyte | 1024⁴ | TiB tebibyte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000⁵ | PB petabyte | 1024⁵ | PiB pebibyte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000⁶ | EB exabyte | 1024⁶ | EiB exbibyte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000⁷ | ZB zettabyte | 1024⁷ | ZiB zebibyte |'
  prefs: []
  type: TYPE_TB
- en: '| 1000⁸ | YB yottabyte | 1024⁸ | YiB yobibyte |'
  prefs: []
  type: TYPE_TB
- en: The decimal values are powers of 10; for example, a kilobyte is 1000 bytes,
    or 10³. The binary values are powers of two, so a kibibyte is 2^(10), 1024 bytes.
    Hard disk manufacturers like to use the decimal format to make their drives look
    bigger.
  prefs: []
  type: TYPE_NORMAL
- en: Whoever came up with the weird “bibyte” naming scheme just about guaranteed
    that nobody would ever want to say the names. It’s all a mishmash anyway, as people
    like to use them interchangeably. At any rate, now you know the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Unmounting Your Partitions Before Using parted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know you must unmount your partition, or partitions, before you can make
    any changes with *parted*, and you need to know how.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unmount a partition from your graphical file manager, or use the *umount* command.
    The following example unmounts */dev/sdc2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How do you know the correct device name? See [Recipe 8.3](#rec-list-partitions)
    to learn how to list your attached disks and partitions.
  prefs: []
  type: TYPE_NORMAL
- en: If you are creating a new partition table on a disk, you should unmount all
    the partitions on it.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a Running System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is risky to unmount filesystems attached to the active root filesystem, such
    as */home*, */var*, or */tmp*, if they are on separate partitions. It is safer
    to perform partitioning operations from another Linux instance, such as SystemRescue
    ([Chapter 19](Images/ch19.html#cha-rescue-recovery)), or a second Linux on the
    same machine ([Chapter 1](ch01.xhtml#cha-install-linux)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Technically, you mount and unmount filesystems rather than partitions. However,
    I shall not hold it against you if you say “partitions.”
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parted User’s Manual](https://oreil.ly/SNyLL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.2 Choosing the Command Mode for parted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You know you can start the *parted* command in interactive mode, launching the
    *parted* command shell, or run it as an ordinary command, and you want to know
    how to do both.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running *parted* with no options launches the interactive *parted* shell. You
    need root privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When your normal command prompt changes to *(parted)*, you are in the *parted*
    shell. Type **`help`** to see a list of commands and their descriptions. There
    is also help for the individual *parted* commands, for example, *help print*.
    Type *quit* to exit parted. Most *parted* commands can be abbreviated to their
    first letter, like *h* and *q*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a complete command to run *parted* as a normal command in your regular
    shell, like this example that lists all of your disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The command runs and exits, and returns to your normal command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful in both modes, because *parted* applies your changes immediately.
    Always have good backups before doing anything with *parted*.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parted User’s Manual](https://oreil.ly/SNyLL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.3 Viewing Your Existing Disks and Partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to see your existing partitions, their sizes, and what filesystems
    are on them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you don’t know the names of the disks on your system, run *parted* with
    no options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you have not selected a device, *parted* guesses which one you want, usually
    the first one, and tells you which one it has selected (see *Using /dev/sda* in
    the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: '*print devices* lists your disk names and sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Select which device you want to look at, then display its information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Type **`quit`** to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open the *parted* shell to a specific disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter **`print`** with no options to see information about this disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*print all* lists all partitions on all devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Find any unpartitioned free space on any disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at what all of this output means:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Model* is the manufacturer’s name for the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Disk* gives the device name and size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sector size* gives both the logical and physical block size. A logical block
    size of 512B is for backward compatibility with older disk controllers and software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Partition table* tells you the partition type, either *msdos* or *gpt*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Flags* matter more to Windows than Linux. They identify the partition types,
    and in some cases are necessary so Windows gets less confused. The full list is
    in the [*Parted User’s Manual*](https://oreil.ly/SNyLL).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the partition flags in the examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '*legacy_boot* marks a GPT partition as bootable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*msftdata* labels GPT partitions that contain Microsoft filesystems, either
    NTFS or FAT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*msftres* is a Microsoft reserved partition. This is a special partition that
    is required by Microsoft on GPT partitions, for use by the operating system. On
    partitions less than 16 GB in size, the MSR is 32 MB, and on larger drives it
    is 128 MB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*diag* is a Windows recovery partition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*boot, esp* both mark the partition as a boot partition. *boot* is an MBR label,
    and *esp* is a GPT label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*swap* marks swap partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Parted User’s Manual*](https://oreil.ly/SNyLL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.4 Creating GPT Partitions on a Nonbooting Disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to repartition a disk, removing all data and starting over with a new
    GUID Partition Table (GPT). This is not a bootable disk with an operating system,
    but is only for data storage.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create the new partition table, then create your partitions, then verify
    that all were created correctly. Be very certain that you select the correct disk;
    see [Recipe 8.3](#rec-list-partitions) to learn how to list your disks and partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, there is a USB stick at */dev/sdc*, which is used
    for data storage. It is not a bootable disk with an operating system on it. You
    must unmount your devices before running *parted*. The first step is to unmount
    it, then create a new GPT partition table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create new partitions. The following example creates two partitions
    that are about the same size. You must specify a name for the partition, and the
    start and end locations for both partitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then check your work, and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If your start or end points are too close to another partition, you will see
    an error message. In the following example, the start of the second partition
    is the same as the end of the first partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Changing it to 200 5MB fixes the error.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*start* sets the beginning of the new partition. This is always a number value.
    The `1MB` value in the example means one megabyte from the beginning of the disk.
    You cannot start at zero because the first 33 sectors are reserved for the EFI
    label, so the first partition starts at the 34th sector or higher. I start at
    the one megabyte mark because it is easy to remember.'
  prefs: []
  type: TYPE_NORMAL
- en: '*end* can take a size value or a percentage. In the example, the end of first
    partition is 200 5MB from the start of the first partition. The second partition
    ends at 100% of the remaining space. Creating a new partition table wipes out
    all data on the disk.'
  prefs: []
  type: TYPE_NORMAL
- en: You must put filesystems on your new partitions before they are usable (see
    [Chapter 11](ch11.xhtml#cha-create-filesystems)).
  prefs: []
  type: TYPE_NORMAL
- en: The warning “You may need to update /etc/fstab” applies only if you change partitions
    that are in your */etc/fstab* file.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for creating new GPT partitions is *mkpart name fs-type start end*.
  prefs: []
  type: TYPE_NORMAL
- en: '*name* is required. This is anything you want, so you can make it a name that
    helps you remember what the partition is for.'
  prefs: []
  type: TYPE_NORMAL
- en: The *fs-type* label is not required, but you should specify it so that the partition
    is assigned the correct filesystem type code. Run *help mkpart* in the *parted*
    shell to see a list of filesystem labels.
  prefs: []
  type: TYPE_NORMAL
- en: Even though you created filesystem labels, there are no filesystems on your
    disk. Creating filesystems is a separate step.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem labels sometimes disappear. After you put a filesystem on the
    partition, they will stay put.
  prefs: []
  type: TYPE_NORMAL
- en: The *parted* help and documentation are a bit confusing on the differences between
    creating GPT partitions and MS-DOS partitions. When you create a GPT partition,
    you must create a *name* for it. When you create an MS-DOS partition you must
    specify a *part-type*, which is one of *primary*, *extended*, or *logical*. There
    is a fair bit of confusion about this, and the result is admins creating GPT partition
    names of *primary*, *extended*, and *logical*. This is not correct and you should
    create *names* for GPT partitions.
  prefs: []
  type: TYPE_NORMAL
- en: At any rate, you should not create MS-DOS partition tables because they are
    obsolete, except on old computers with old software that does not support GPT.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Parted User’s Manual*](https://oreil.ly/SNyLL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.xhtml#cha-create-filesystems)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.5 Creating Partitions for Installing Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to install Linux on a disk and need to know how to partition it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the partition manager in the Linux installer. You can set up your partitions
    before running the installer, but using the installer’s partition manager ensures
    that it will be done correctly, and you will see warnings for any errors. See
    [Recipe 1.8](ch01.xhtml#rec-install-partition) for a suggested partitioning scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most Linux installers provide guidance for partitioning for a new installation
    and also allow manual customizations.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction to this chapter for partitioning suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.xhtml#cha-install-linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.6 Removing Partitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to delete some partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start *parted* in interactive mode for the disk you want to make changes on,
    then print the partition table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, delete the second partition by typing *rm 2*. The partition
    will be immediately removed, and there will not be a confirmation. Then type *p*
    to verify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be very certain you are deleting the correct partitions. It is OK to make written
    notes and check many times before you start.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to delete a mounted partition, *parted* will warn you with “Warning:
    Partition /dev/sdc2 is being used. Are you sure you want to continue?” You may
    go ahead and delete it. Any open files will remain in memory until you reboot
    or close them, which is kind of fun because you can still read and save the files
    to a different partition.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parted User’s Manual](https://oreil.ly/SNyLL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.7 Recovering a Deleted Partition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You deleted a partition, and now you wish you hadn’t, and you want to get it
    back.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you accidentally deleted a new empty partition, don’t bother trying to recover
    it, just create it again. If your partition had a filesystem and data on it, then
    your best chance is to try immediate recovery. In the *parted* shell, use the
    *rescue* command, and give it the partition’s start and end locations. These can
    be approximate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*parted* won’t give you any feedback, so print the partition table to see if
    the lost partition came back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And there it is. With a little luck all of your files are intact.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The longer you wait to try to restore a partition, the more likely it will not
    be restorable because it may be unintentionally overwritten. If you need to delay
    rescue operations until a later time, put it away in a safe place, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: As always, your best practice is to always maintain good backups.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*Parted User’s Manual*](https://oreil.ly/SNyLL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.8 Increasing Partition Size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to increase the size of an existing partition, which has a filesystem
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example increases the size of a partition with a filesystem on
    it. There are two steps: first resize the partition, then resize the filesystem
    to match. Every filesystem has its own set of tools, and you must use the correct
    tool for increasing the size. In this recipe, we will resize the Ext4, XFS, Btrfs,
    and FAT16/32 partitions.'
  prefs: []
  type: TYPE_NORMAL
- en: Ext4, XFS, and Btrfs can all be enlarged online or offline. FAT16/32 can be
    resized only offline and must be unmounted first.
  prefs: []
  type: TYPE_NORMAL
- en: 'There must be free space at the end of the partition you want to increase.
    Open the *parted* shell to your selected disk, and look for free space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This shows 981 MB of free space preceding Partition 2, and 510 MB of free space
    following. You can only change the end point of a partition, so the following
    examples expand Partition 2 to use all of the 510 MB of free space at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, expand the partition to its new end point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You will not see a success message, but if you make a mistake, you will see
    an error message. Type **`p`** to see the partition table and verify that *resizepart*
    did what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Now you must expand the filesystem to fit the new partition size with the appropriate
    command for the filesystem. [Table 8-2](#command-increase-fs-size) shows the commands
    to use for each filesystem, expanding them to fill their partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Commands to increase filesystem sizes
  prefs: []
  type: TYPE_NORMAL
- en: '| Filesystem | Resize command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ext4 | sudo resize2fs /dev/sd*c2* |'
  prefs: []
  type: TYPE_TB
- en: '| XFS | sudo xfs_growfs -d /dev/sd*c2* |'
  prefs: []
  type: TYPE_TB
- en: '| Btrfs | sudo btrfs filesystem resize max /dev/sd*c2* |'
  prefs: []
  type: TYPE_TB
- en: '| FAT16/32 | sudo fatresize -i /dev/sd*c2* |'
  prefs: []
  type: TYPE_TB
- en: Remember that FAT16/32 must be unmounted first.
  prefs: []
  type: TYPE_NORMAL
- en: Print the partition table in *parted* to check your work.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples in this chapter and in [Recipe 8.9](#rec-shrink-partition) are
    small, using a 4 GB USB stick. This is great for testing, but in real life you
    will likely be using larger disks. The commands are the same, except for partition
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: As always, you should have current backups before you start.
  prefs: []
  type: TYPE_NORMAL
- en: You could resize a filesystem to be smaller than the partition, but that doesn’t
    make sense. Check out [Chapter 11](ch11.xhtml#cha-create-filesystems) to learn
    all about creating and managing filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering “Where is my favorite filesystem?” I chose Ext4, Btrfs,
    XFS, and FAT16/32 because those are the most commonly used Linux filesystems,
    and they are all well maintained.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.xhtml#cha-create-filesystems)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 resize2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 xfs_growfs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 btrfs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 fsck.vfat*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 8.9 Shrinking a Partition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a partition with a filesystem on it, and you want to shrink it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XFS filesystems cannot be reduced in size, only increased. You can shrink Ext4,
    Btrfs, and FAT16/32\. Ext4 and FAT16/32 must be unmounted before shrinking them.
    Btrfs can be shrunken online, but it is safer to unmount it first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the used portion of the filesystem you want to shrink is smaller
    than the size you want to shrink it to. Use the *du* command to see how much space
    your files occupy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You should allow about 40% extra room for metadata, wasted block space, and
    for just in case, so in this example the new size should not be smaller than 1.4
    GB. If you need room to add more files, then account for that as well.
  prefs: []
  type: TYPE_NORMAL
- en: Shrinking partitions is a little more complicated than expanding them. There
    are more steps, and the filesystems must be shrunk offline. If the partition is
    on an external storage device, such as a USB stick, unmount it and then shrink
    it. If it is a partition that belongs to your running system, then you must run
    *parted* from a bootable rescue disk, or a second Linux on a multiboot system,
    so that you can unmount the filesystem you want to shrink.
  prefs: []
  type: TYPE_NORMAL
- en: 'After your selected filesystem is unmounted, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a filesystem check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shrink the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shrink the partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following command to check the health of an Ext4 filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Check a Btrfs filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Check a FAT16/32 filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When everything checks out, shrink your filesystem. The examples in [Table 8-3](#cmd-decrease-fs-size)
    shrink the filesystems to 2000 MB.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-3\. Commands to decrease filesystem sizes
  prefs: []
  type: TYPE_NORMAL
- en: '| Filesystem | Resize command |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Ext4 | sudo resize2fs /dev/sd*c2* 2g |'
  prefs: []
  type: TYPE_TB
- en: '| Btrfs | sudo btrfs filesystem resize 2g /dev/sd*c2* |'
  prefs: []
  type: TYPE_TB
- en: '| FAT16/32 | sudo fatresize -s 2G /dev/sd*c2* |'
  prefs: []
  type: TYPE_TB
- en: 'Now you can shrink your partition to match the filesystem size. Open the *parted*
    shell to your device and then run the *resize* command. Specify the partition
    number and the end point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Check your work by printing the partition table in *parted*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storage media is large and cheap. In the olden days, fiddling with partitions
    was necessary for cramming the most files onto a disk. Now we have the luxury
    of customizing their sizes for our convenience.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.xhtml#cha-create-filesystems)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 resize2fs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 parted*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 btrfs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*man 8 fsck.vfat*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
