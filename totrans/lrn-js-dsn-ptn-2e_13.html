<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Rendering Patterns"><div class="chapter" id="rendering-patterns">
<h1><span class="label">Chapter 13. </span>Rendering Patterns</h1>


<p>As we moved to more interactive websites,<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="about" id="idm45017684696960"/> the number of events handled and the amount of content rendered on the client side grew, resulting in SPAs rendered primarily on the client, as in the case of React.js.</p>

<p>However, web pages can be as static or dynamic as the function they serve. We continue to serve a lot of static content on the web, for example, blog/news pages that you can generate on the server and push as-is to the clients. Static content is stateless, does not fire events, and does not need rehydration after rendering. Conversely, dynamic content (buttons, filters, search bar) has to be rewired to its events after rendering. <a data-type="indexterm" data-primary="DOM" data-secondary="virtual DOM on client side" id="idm45017684695472"/><a data-type="indexterm" data-primary="virtual DOM on client side" id="idm45017684694432"/>The DOM has to be regenerated on the client side (virtual DOM). This regeneration, rehydration, and event handling functions contribute to the JavaScript sent to the client.</p>

<p>A Rendering pattern provides the ideal solution for rendering content for a given use case. The Rendering patterns in this table are popular:<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="about" data-tertiary="list of popular patterns" id="idm45017684693008"/><a data-type="indexterm" data-primary="client-side rendering (CSR)" id="idm45017684691792"/><a data-type="indexterm" data-primary="CSR (client-side rendering)" id="idm45017684691104"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="about" id="idm45017684690416"/><a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="about" id="idm45017684689456"/><a data-type="indexterm" data-primary="static rendering" id="idm45017684688496"/><a data-type="indexterm" data-primary="incremental static regeneration (ISR)" id="idm45017684687824"/><a data-type="indexterm" data-primary="streaming SSR" id="idm45017684687136"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="streaming SSR" id="idm45017684686464"/><a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="streaming SSR" id="idm45017684685504"/><a data-type="indexterm" data-primary="edge rendering" id="idm45017684684544"/><a data-type="indexterm" data-primary="partial hydration" id="idm45017684683872"/><a data-type="indexterm" data-primary="progressive hydration" id="idm45017684683200"/><a data-type="indexterm" data-primary="Islands architecture" data-secondary="about" id="idm45017684682528"/><a data-type="indexterm" data-primary="hydration" data-secondary="partial hydration" id="idm45017684681584"/><a data-type="indexterm" data-primary="hydration" data-secondary="progressive hydration" id="idm45017684680640"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="streaming SSR" id="idm45017684679696"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="progressive hydration" id="idm45017684678752"/></p>
<table id="classes" class="customtable">

<tbody>
<tr class="level1">
<td><p><strong>Rendering patterns</strong></p></td>
<td><p/></td>
</tr>
<tr>
<td><p><em>Client-side rendering (CSR)</em></p></td>
<td><p>HTML is rendered completely on the client</p></td>
</tr>
<tr>
<td><p><em>Server-side rendering (SSR)</em></p></td>
<td><p>Dynamically rendering HTML content on the server before rehydrating it on the client</p></td>
</tr>
<tr>
<td><p><em>Static rendering</em></p></td>
<td><p>Building a static site to render pages on the server at build time</p></td>
</tr>
<tr>
<td><p><em>Incremental static generation</em></p></td>
<td><p>Being able to dynamically augment or modify a static site even after the initial build (Next.js ISR, Gatsby DSG)</p></td>
</tr>
<tr>
<td><p><em>Streaming SSR</em></p></td>
<td><p>Breaking down server-rendered content into smaller streamed chunks</p></td>
</tr>
<tr>
<td><p><em>Edge rendering</em></p></td>
<td><p>Altering rendered HTML at the edge before sending it on to the client</p></td>
</tr>
<tr><td><p><em>Hybrid rendering</em></p></td>
<td><p>Combines build-time, server, and client rendering to create a more flexible approach to web development (e.g., React Server Components and Next.js App Router)</p></td>
</tr>
<tr>
<td><p><em>Partial hydration</em></p></td>
<td><p>Only hydrating some of your components on the client (e.g., React Server Components and Gatsby)</p></td>
</tr>
<tr>
<td><p><em>Progressive hydration</em></p></td>
<td><p>Controlling the order of component hydration on the client</p></td>
</tr>
<tr>
<td><p><em>Islands architecture</em></p></td>
<td><p>Isolated islands of dynamic behavior with multiple entry points in an otherwise static site (Astro, Eleventy)</p></td>
</tr>
<tr>
<td><p><em>Progressive enhancement</em></p></td>
<td><p>Making sure an app is functional even without JavaScript</p></td>
</tr>
</tbody>
</table>

<p>This chapter introduces some of these Rendering patterns and will help you decide which pattern is most suitable for your needs. It will help you make foundational decisions such as:</p>

<ul>
<li>
<p>How and where do I want to render content?</p>
</li>
<li>
<p>Should content be rendered on the web server, on the build server, on an edge network, or directly on the client?</p>
</li>
<li>
<p>Should content be rendered all at once, partially, or progressively?</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="Importance of Rendering Patterns"><div class="sect1" id="importance-of-rendering-patterns">
<h1>Importance of Rendering Patterns</h1>

<p>Choosing the most suitable Rendering pattern<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="importance of" id="idm45017684649968"/> for a given use case can make a world of difference to the developer experience (DX) you create for the engineering team and the UX you design for your end users. Choosing the correct pattern could lead to faster builds and excellent loading performance at low processing costs. On the other hand, a wrong choice of pattern can kill an app that could have brought to life a great business idea.</p>

<p>To create great UX, we must optimize our apps for user-centric metrics,<a data-type="indexterm" data-primary="Core Web Vitals (CWV)" id="idm45017684648480"/><a data-type="indexterm" data-primary="CWV (Core Web Vitals)" id="idm45017684647776"/><a data-type="indexterm" data-primary="metrics of Core Web Vitals" id="idm45017684647104"/><a data-type="indexterm" data-primary="user-centric metrics of Core Web Vitals" id="idm45017684646368"/> such as the <a href="https://oreil.ly/R20lq">Core Web Vitals (CWV)</a>:</p>
<dl>
<dt>Time to First Byte (TTFB)</dt>
<dd>
<p>Time it takes for a client to receive the first byte of page content</p>
</dd>
<dt>First Contentful Paint(FCP)</dt>
<dd>
<p>Time it takes the browser to render the first piece of content after navigation</p>
</dd>
<dt>Time to Interactive (TTI)</dt>
<dd>
<p>Time from when the page starts loading to when it responds quickly to user input</p>
</dd>
<dt>Largest Contentful Paint (LCP)</dt>
<dd>
<p>Time it takes to load and render the page’s main content</p>
</dd>
<dt>Cumulative Layout Shift (CLS)</dt>
<dd>
<p>Measures visual stability to avoid unexpected layout shift</p>
</dd>
<dt>First Input Delay (FID)</dt>
<dd>
<p>Time from when the user interacts with the page to the time when the event handlers can run</p>
</dd>
</dl>

<p>The CWV metrics measure parameters most relevant to UX. Optimizing the CWV can ensure a great UX and optimal search engine optimization (SEO) for our apps.</p>

<p>To create a great DX for our product/engineering teams, we have to optimize our development environments by ensuring faster build times, easy rollbacks, scalable infrastructure, and many other features that help developers succeed:</p>
<dl>
<dt>Fast build times</dt>
<dd>
<p>The project should build fast for quick iteration and deployment.</p>
</dd>
<dt>Low server costs</dt>
<dd>
<p>The website should limit and optimize the server execution time to reduce execution costs.</p>
</dd>
<dt>Dynamic content</dt>
<dd>
<p>The page should be able to load dynamic content performantly.</p>
</dd>
<dt>Easy rollbacks</dt>
<dd>
<p>You can quickly revert to a previous build version and deploy it.</p>
</dd>
<dt>Reliable uptime</dt>
<dd>
<p>Users should always be able to visit your website through operational servers.</p>
</dd>
<dt>Scalable infrastructure</dt>
<dd>
<p>Your project may grow or shrink without facing performance issues.</p>
</dd>
</dl>

<p>Setting up a development environment based on these principles enables our development teams to build a great product efficiently.</p>

<p>We have now built quite a long list of expectations. But, if you choose the correct Rendering pattern, you can get most of these benefits automatically.</p>

<p>Rendering patterns have come a long way, from SSR and CSR to highly nuanced patterns discussed and judged today on different forums. While this can get overwhelming, it’s important to remember that every pattern was designed to address specific use cases. A pattern characteristic beneficial for one use case can be detrimental in the case of another. It is also quite likely that different types of pages require different Rendering patterns on the same website.</p>

<p>The Chrome team has encouraged<a data-type="indexterm" data-primary="Chrome" data-secondary="static or SSR over full rehydration approach" id="idm45017684624816"/><a data-type="indexterm" data-primary="browsers" data-secondary="Chrome" data-tertiary="static or SSR over full rehydration approach" id="idm45017684623744"/> developers to consider static or SSR over a full rehydration approach. Over time, progressive loading and rendering techniques may help strike a good balance of performance and feature delivery when using a modern framework.</p>

<p>The following sections cover different patterns in detail.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Client-Side Rendering"><div class="sect1" id="client-side-rendering">
<h1>Client-Side Rendering</h1>

<p>We have already discussed CSR<a data-type="indexterm" data-primary="CSR (client-side rendering)" data-secondary="React" id="idm45017684620016"/><a data-type="indexterm" data-primary="client-side rendering (CSR)" data-secondary="React" id="idm45017684619024"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="design patterns" data-tertiary="client-side rendering" id="idm45017684618064"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="client-side rendering" data-tertiary="React" id="idm45017684616848"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="client-side rendering" id="idm45017684615632"/> with React in the previous chapter. Here is a brief overview to help us relate it to the other Rendering patterns.</p>

<p>With React CSR, most of the application logic is executed on the client, and it interacts with the server through API calls to fetch or save data. Almost all of the UI is thus generated on the client. The entire web application is loaded on the first request. As the user navigates by clicking on links, no new request is generated to the server for rendering the pages. The code runs on the client to change the view/data.</p>

<p>CSR allows us to have an<a data-type="indexterm" data-primary="CSR (client-side rendering)" id="idm45017684613632"/><a data-type="indexterm" data-primary="client-side rendering (CSR)" id="idm45017684612864"/> SPA that supports navigation without page refresh and provides a great UX. As the data processed to change the view is limited, routing between pages is generally faster, making the CSR application seem more responsive.</p>

<p>As the complexity of the page increases to show images, display data from a data store, and include event handling, the complexity and size of the JavaScript code required to render the page will also increase. CSR resulted in large JavaScript bundles, which increased the FCP and TTI of the page. Large payloads and a waterfall of network requests (e.g., for API responses) may also result in meaningful content not being rendered fast enough for a crawler to index it. This can affect the SEO of the website.</p>

<p>Loading and processing excess JavaScript can hurt performance. However, some interactivity and JavaScript are often required, even on primarily static websites. The rendering techniques discussed in the following sections try to find a balance between:</p>

<ul>
<li>
<p>Interactivity comparable to CSR applications</p>
</li>
<li>
<p>SEO and performance benefits that are comparable to SSR applications</p>
</li>
</ul>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Server-Side Rendering"><div class="sect1" id="server-side-rendering">
<h1>Server-Side Rendering</h1>

<p>With SSR, we generate the HTML<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="server-side rendering" data-see="server-side rendering (SSR)" id="idm45017684606688"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="Rendering pattern" id="idm45017684605376"/><a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="Rendering pattern" id="idm45017684604416"/><a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="about" id="idm45017684603456"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="about" id="idm45017684602496"/><a data-type="indexterm" data-primary="sensitive data and server-side rendering" id="idm45017684601536"/><a data-type="indexterm" data-primary="data" data-secondary="sensitive data and server-side rendering" id="idm45017684600768"/> for every request. This approach is most suitable for pages containing highly personalized data, for example, data based on the user cookie or generally any data obtained from the user’s request. It’s also suitable for pages that should be render-blocking, perhaps based on the authentication state.</p>

<p>SSR is one of the oldest methods of rendering web content. SSR generates the complete HTML for the page content to be rendered in response to a user request. The content may include data from a data store or external API.</p>

<p>The connect and fetch operations are handled on the server. HTML required to format the content is also generated on the server. Thus, with SSR, we can avoid making additional round trips for data fetching and templating. As such, rendering code is not required on the client and the JavaScript corresponding to this need not be sent to the client.</p>

<p>With SSR, every request is treated independently and processed as a new request by the server. Even if the output of two consecutive requests is not very different, the server will process and generate it from scratch. Since the server is common to multiple users, the processing capability is shared by all active users at a given time.</p>
<p class="fix_tracking">
A personalized dashboard is an excellent example of highly dynamic content on a page. Most of the content is based on the user’s identity or authorization level that may be contained in a user cookie. This dashboard shows only when a user is authenticated and possibly shows user-specific sensitive data that should not be visible to others.</p>

<p>The core principle for SSR is that HTML is rendered on the server and shipped with the necessary JavaScript to rehydrate it on the client. Rehydration is regenerating the state of UI components on the client side after the server renders it. Since rehydration comes at a cost, each variation of SSR tries to optimize the rehydration process.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Static Rendering"><div class="sect1" id="static-rendering">
<h1>Static Rendering</h1>

<p>With static rendering, the HTML<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="static rendering" id="ch13-statre"/><a data-type="indexterm" data-primary="static rendering" id="ch13-statre2"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="static rendering" data-tertiary="about" id="idm45017684593088"/><a data-type="indexterm" data-primary="static rendering" data-secondary="about" id="idm45017684591872"/> for the entire page gets generated at build time and does not change until the next build. The HTML content is static and easily cacheable on a content delivery network (CDN) or an edge network. CDNs can quickly serve the prerendered cached HTML to clients when they request a specific page. This considerably cuts down the time it would otherwise take to process the request, render HTML content, and respond to a request in a typical SSR setup.</p>

<p>This process is most suitable for pages that do not change often and display the same data no matter who requests them. Static pages like the “About us,” “Contact us,” and “Blog” pages for websites, or product pages for ecommerce apps are ideal candidates for static rendering. <a data-type="indexterm" data-primary="Next.js" data-secondary="static rendering support" id="idm45017684590416"/><a data-type="indexterm" data-primary="VuePress" id="idm45017684589424"/><a data-type="indexterm" data-primary="Gatsby" id="idm45017684588752"/>Frameworks like Next.js, Gatsby, and VuePress support static generation.</p>

<p>At its core, plain static rendering does not involve any dynamic data. Let us understand it using a Next.js example:<a data-type="indexterm" data-primary="Next.js" data-secondary="static rendering support" data-tertiary="example" id="idm45017684587440"/></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="c1">// pages/about.js</code>

<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">About</code><code class="p">()</code> <code class="p">{</code>
 <code class="k">return</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
   <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">About</code> <code class="nx">Us</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>
   <code class="p">{</code><code class="cm">/* ... */</code><code class="p">}</code>
 <code class="o">&lt;</code><code class="err">/div&gt;</code>
<code class="p">}</code></pre>

<p>When the site is built (using <code>next build</code>), this page will be prerendered into an HTML file <em>about.html</em> accessible at the route <em>/about</em>.</p>

<p>You can have several variations of static rendering as follows:</p>
<dl>
<dt>Static generation of a listing page with dynamic data from a database</dt>
<dd>
<p>The listing page is generated on the server with the data. This is suitable for pages where the listing itself is not very dynamic.<a data-type="indexterm" data-primary="Next.js" data-secondary="getStaticProps() for dynamic data" id="idm45017684569520"/> In Next.js, you can export the function <a href="https://oreil.ly/QcNhk"><code>getStaticProps()</code></a> in the page component for this.</p>
</dd>
<dt>Static generation of detail pages with dynamic routes</dt>
<dd>
<p>Product pages or blog pages usually follow a fixed template with data populated in placeholders. In this case, individual pages can be generated on the server by merging the template with the dynamic data giving us several individual routes for each detailed page. <a data-type="indexterm" data-primary="Next.js" data-secondary="dynamic routes with getStaticPaths()" id="idm45017684566384"/>The Next.js <a href="https://oreil.ly/2Bugb">dynamic routes</a> feature helps to achieve this using the <code>getStaticPaths()</code> function.</p>
</dd>
<dt>Static rendering with client-side fetch</dt>
<dd>
<p>This pattern is helpful for a reasonably dynamic listing page that should display fresh listings always.  You can still use static rendering for the website to render the UI with a skeleton component where you want to place the dynamic listing data. Then, after the page has loaded, we can fetch the data using SWR. SWR (inspired by the Stale-While-Revalidate pattern) are React Hooks for data fetching. A custom API route is used to fetch the data from the CMS and return this data. The pregenerated HTML file is sent to the client when the user requests the page. The user initially sees the skeleton UI without any data. The client fetches the data from the API route, receives the response, and shows the listings.</p>
</dd>
</dl>

<p>The key highlights of static rendering include the following:</p>

<ul>
<li>
<p>HTML gets generated at build time.</p>
</li>
<li>
<p>Easily cacheable by CDN/Vercel Edge Network.</p>
</li>
<li>
<p>Plain static rendering is best for pages that do not require request-based data.</p>
</li>
<li>
<p>Static with client-side fetch is best for pages that contain data that should refresh on every page load and is contained in stable placeholder components.</p>
</li>
</ul>








<section data-type="sect2" data-pdf-bookmark="Incremental Static Regeneration"><div class="sect2" id="idm45017684516112">
<h2>Incremental Static Regeneration</h2>

<p>ISR is a hybrid of static and<a data-type="indexterm" data-primary="static rendering" data-secondary="incremental static regeneration" id="idm45017684514912"/><a data-type="indexterm" data-primary="incremental static regeneration (ISR)" id="idm45017684513920"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="static rendering" data-tertiary="incremental static regeneration" id="idm45017684513232"/><a data-type="indexterm" data-primary="ISR" data-see="incremental static regeneration" id="idm45017684512000"/> SSR because it allows us to prerender only certain static pages and render the dynamic pages on-demand when the user requests them. This results in shorter build times and allows automatic invalidation of the cache and regeneration of the page after a specific interval.</p>

<p>ISR works on two fronts to incrementally introduce updates to an existing static site after it has been built:</p>
<dl>
<dt>Allows addition of new pages</dt>
<dd>
<p>The lazy-loading concept is used to include new pages on the website after the build. This means that the new page is generated immediately on the first request. While the generation takes place, a fallback page or a loading indicator can be shown to the user on the frontend.</p>
</dd>
<dt>Update existing pages</dt>
<dd>
<p>A suitable timeout is defined for every page. This will ensure that the page is revalidated whenever the defined timeout period has elapsed. The timeout could be set to as low as 1 second. The user will continue to see the previous version of the page until the page has finished revalidation. Thus, ISR uses the stale-while-revalidate strategy, where the user receives the cached or stale version while the revalidation takes place. The revalidation occurs entirely in the background and does not need a full rebuild.</p>
</dd>
</dl>
</div></section>








<section data-type="sect2" data-pdf-bookmark="On-Demand ISR"><div class="sect2" id="idm45017684507104">
<h2>On-Demand ISR</h2>

<p>In this variation of ISR, the regeneration<a data-type="indexterm" data-primary="incremental static regeneration (ISR)" data-secondary="on-demand ISR" id="idm45017684505712"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="static rendering" data-tertiary="on-demand ISR" id="idm45017684504672"/> occurs on certain events rather than at fixed intervals. With regular ISR, the updated page is cached only at the edge nodes that have handled user requests for the page. On-demand ISR regenerates and redistributes the page across the edge network so that users worldwide will automatically see the most recent version of the page from the edge cache without seeing stale content. We also avoid unnecessary regenerations and serverless function calls, reducing operational costs compared to regular ISR. Thus on-demand ISR gives us performance benefits and a great DX. On-demand ISR is best for pages that should be regenerated based on specific events. It allows us to have fast and dynamic websites that are always online at a reasonable cost.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Summary of Static Rendering"><div class="sect2" id="idm45017684503072">
<h2>Summary of Static Rendering</h2>

<p>Static rendering is an excellent<a data-type="indexterm" data-primary="static rendering" data-secondary="about" id="idm45017684501760"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="static rendering" data-tertiary="about" id="idm45017684500784"/> pattern for websites where HTML can be generated at build time. We have now covered different variations of static generation, each of which is suitable for different use cases:</p>
<dl>
<dt>Plain static rendering</dt>
<dd>
<p>Best for pages that do not contain dynamic data</p>
</dd>
<dt>Static with client-side fetch</dt>
<dd>
<p>Best for pages where data  should refresh on every page load and which have stable placeholder components</p>
</dd>
<dt>Incremental static regeneration</dt>
<dd>
<p>Best for pages that should be regenerated on a certain interval or on-demand</p>
</dd>
<dt>On-demand ISR</dt>
<dd>
<p>Best for pages that should be regenerated based on certain events</p>
</dd>
</dl>

<p>There are use cases where static isn’t the best option. For example, SSR is ideal for highly dynamic, personalized pages that are different for every user. <a data-type="indexterm" data-startref="ch13-statre" id="idm45017684492944"/><a data-type="indexterm" data-startref="ch13-statre2" id="idm45017684492208"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Streaming SSR"><div class="sect1" id="streaming-ssr">
<h1>Streaming SSR</h1>

<p>With SSR or static rendering,<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="streaming SSR" id="idm45017684489552"/><a data-type="indexterm" data-primary="streaming SSR" id="idm45017684488576"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="streaming SSR" id="idm45017684487904"/><a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="streaming SSR" id="idm45017684486896"/> you can reduce the amount of JavaScript so that the time taken for the page to become interactive (TTI) is closer to the time for FCP. Streaming the contents can reduce the TTI/FCP further while still server-rendering the application. Instead of generating one large HTML file containing the necessary markup for the current navigation, we can split it into smaller chunks. Node streams allow us to stream data into the response object, which means we can continuously send data down to the client. When the client receives the chunks of data, it can start rendering the contents.</p>

<p>React’s built-in <code>renderToNodeStream</code> allows<a data-type="indexterm" data-primary="React (React.js)" data-secondary="streaming SSR" data-tertiary="renderToNodeStream" id="idm45017684484976"/><a data-type="indexterm" data-primary="streaming SSR" data-secondary="React support for" id="idm45017684483696"/> us to send our application in smaller chunks. As the client can start painting the UI when it’s still receiving data, we can create a very performant first-load experience. Calling the <code>hydrate</code> method on the received DOM nodes will attach the corresponding event handlers, which makes the UI interactive.</p>

<p>Streaming responds well to network backpressure. If the network is clogged and unable to transfer any more bytes, the renderer gets a signal and stops streaming until the network is cleared up. Thus, the server uses less memory and is more responsive to I/O conditions. <a data-type="indexterm" data-primary="Node.js (Node)" data-secondary="streaming SSR" id="idm45017684481696"/>This enables your Node.js server to render multiple requests simultaneously and prevents heavier requests from blocking lighter requests for a long time. As a result, the site stays responsive even in challenging conditions.</p>

<p>React introduced support for streaming<a data-type="indexterm" data-primary="React (React.js)" data-secondary="streaming SSR" data-tertiary="APIs in ReactDOMServer" id="idm45017684480208"/><a data-type="indexterm" data-primary="APIs" data-secondary="React 16 streaming support" id="idm45017684478960"/> in React 16, released in 2016. It included the following APIs in the <code>ReactDOMServer</code> to support streaming:</p>
<dl>
<dt><code>ReactDOMServer.renderToNodeStream(element)</code></dt>
<dd>
<p>The output HTML from this function is the same as <code>ReactDOMServer.renderToString(element)</code> but is in a Node.js <code>ReadableStream</code> format instead of a string. The function will only work on the server to render HTML as a stream. The client receiving this stream can call <code>ReactDOM.hydrate()</code> to hydrate the page and make it interactive.</p>
</dd>
<dt><code>ReactDOMServer.renderToStaticNodeStream(element)</code></dt>
<dd>
<p>This corresponds to <code>ReactDOMServer.renderToStaticMarkup(element)</code>. The HTML output is the same but in a stream format. You can use it to render static, noninteractive pages on the server and then stream them to the client.</p>
</dd>
</dl>

<p>The readable stream output by both functions can emit bytes once you start reading from it. You can achieve this by piping the readable stream to a writable stream, such as the response object. The response object progressively sends chunks of data to the client while waiting for new chunks to be rendered.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Edge SSR"><div class="sect1" id="edge-rendering">
<h1>Edge SSR</h1>

<p>Edge SSR enables you to server-render from all regions of a CDN and experience a near-zero cold boot.<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="edge SSR" id="idm45017684469600"/><a data-type="indexterm" data-primary="edge rendering" data-secondary="edge SSR" id="idm45017684468624"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="edge SSR" id="idm45017684467680"/><a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="edge SSR" id="idm45017684466672"/></p>

<p>Serverless functions can be used to generate the entire page server-side. The edge runtime also allows HTTP streaming so that you can stream parts of the document as soon as they are ready and hydrate these components granularly. This reduces the time to FCP.</p>

<p>A use case for this pattern is building<a data-type="indexterm" data-primary="region-specific pages rendered" id="idm45017684464912"/> region-specific listing pages for users. The majority of the page contains only static data; it’s just the listings that require request-based data. Instead of server-rendering the entire page, we can now choose to render only the listing component server-side and the rest edge-side. Whereas we initially had to server-render the whole page to achieve this behavior, we can now get the excellent performance of static rendering on the edge with the dynamic benefits of SSR.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Hybrid Rendering"><div class="sect1" id="hybrid-rendering">
<h1>Hybrid Rendering</h1>

<p>As the name suggests, hybrid rendering <a data-type="indexterm" data-primary="Rendering patterns" data-secondary="hybrid rendering" id="idm45017684462176"/><a data-type="indexterm" data-primary="hybrid rendering" id="idm45017684461200"/>combines different approaches to focus on delivering an optimal result. It represents a mental shift in how developers approach web development, moving from a client-only starting point to a more versatile combination of rendering strategies. Pages that can be served statically will be prerendered. A dynamic strategy may be chosen for other pages in the app (e.g., ISR or SSR or CSR and streaming for subsequent navigations).</p>

<p>Hybrid rendering conceptually challenges traditional terminology (SPA, MPA, SSR, SSG) and emphasizes the need for new verbiage to describe modern web development practices better. A web app need not be classified as an SPA or MPA anymore. It can easily transition from one to the other based on the function served. Thus, it provides the benefits of SPAs (no server needed) while avoiding issues with static rendering (navigation without page reloads).</p>

<p>The shift in focus is not from writing SPAs to not writing SPAs but rather from being locked into SPAs to using whatever rendering mode makes sense for each page, thus entering the hybrid era. This shift is primarily mental, where developers start with build-time and client rendering and add server rendering as needed on a per-page basis.</p>

<p>As the web development landscape converges toward hybrid rendering, we see that many frameworks, both within and outside the React universe, have started supporting it. For example:<a data-type="indexterm" data-primary="Next.js" data-secondary="hybrid rendering support" id="idm45017684459184"/><a data-type="indexterm" data-primary="Astro" data-secondary="hybrid rendering support" id="idm45017684458144"/><a data-type="indexterm" data-primary="Angular" data-secondary="hybrid rendering support" id="idm45017684457184"/><a data-type="indexterm" data-primary="Nuxt hybrid rendering support" id="idm45017684456224"/><a data-type="indexterm" data-primary="Next.js" data-secondary="App Router" id="idm45017684455536"/><a data-type="indexterm" data-primary="Next.js" data-secondary="App Router" data-tertiary="React Server Component support" id="idm45017684454592"/></p>

<ul>
<li>
<p>Next.js 13 combines React Server Components and the <a href="https://oreil.ly/UEnVf">Next.js App Router</a> to demonstrate the potential of hybrid rendering.</p>
</li>
<li>
<p><a href="https://oreil.ly/Sbfu8">Astro 2.0</a> brings the best of both static and dynamic rendering instead of choosing between SSG and SSR.</p>
</li>
<li>
<p><a href="https://oreil.ly/g076-">Angular Universal 11.1</a> has native hybrid rendering support. It can perform prerendering (SSG) for static routes and SSR for dynamic routes.</p>
</li>
<li>
<p><a href="https://oreil.ly/gCriy">Nuxt 3.0</a> lets you configure route rules for hybrid rendering support.</p>
</li>
</ul>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Progressive Hydration"><div class="sect1" id="progressive-hydration">
<h1>Progressive Hydration</h1>

<p>Progressive hydration implies you<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="progressive hydration" id="idm45017684444848"/><a data-type="indexterm" data-primary="progressive hydration" id="idm45017684443872"/><a data-type="indexterm" data-primary="hydration" data-secondary="progressive hydration" id="idm45017684443200"/> can individually hydrate nodes over time so that you request only the minimum necessary JavaScript at any time. By progressively hydrating the application, we can delay the hydration of less critical parts of the page.</p>

<p>This way, we reduce the amount of JavaScript requested to make the page interactive and only hydrate the nodes once the user needs them, for example, when a component is visible in the viewport. Progressive hydration also helps avoid the most common SSR rehydration pitfalls, where a server-rendered DOM tree is destroyed and immediately rebuilt.</p>

<p>The idea behind progressive hydration is to provide excellent performance by activating your app in chunks. Any progressive hydration solution should also consider how it will impact the overall UX. You cannot have chunks of the screen popping up one after the other and blocking any activity or user input on the chunks that have already loaded. Thus, the requirements for a holistic progressive hydration implementation are as follows:</p>

<ul>
<li>
<p>Allows usage of SSR for all components</p>
</li>
<li>
<p>Supports splitting of code into individual components or chunks</p>
</li>
<li>
<p>Supports client-side hydration of these chunks in a developer-defined sequence</p>
</li>
<li>
<p>Does not block user input on chunks that are already hydrated</p>
</li>
<li>
<p>Allows usage of some loading indicator for chunks with deferred hydration</p>
</li>
</ul>

<p>React concurrent mode will address all these requirements once it is available. It allows React to work on different tasks simultaneously and switch between them based on the given priority. When switching, a partially rendered tree need not be committed so that the rendering task can continue once React switches back to the same task.</p>

<p>Concurrent mode can be used to implement progressive hydration. In this case, the hydration of each chunk on the page becomes a task for React concurrent mode. If a task of higher priority, like user input, needs to be performed, React will pause the hydration task and switch to accepting the user input. Features like <code>lazy()</code> and 
<span class="keep-together"><code>Suspense()</code></span> allow you to use declarative loading states. These can be used to show the loading indicator while chunks are lazy-loaded. <code>SuspenseList()</code> can be used to define the priority for lazy-loading components. Dan Abramov has shared a great <a href="https://oreil.ly/JHhPm">demo</a> that shows the concurrent mode in action and implements progressive 
<span class="keep-together">hydration.</span></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Islands Architecture"><div class="sect1" id="islands-architecture">
<h1>Islands Architecture</h1>

<p>Katie Sylor-Miller and Jason Miller<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="Islands architecture" id="ch13-isl"/><a data-type="indexterm" data-primary="Islands architecture" id="ch13-isl2"/><a data-type="indexterm" data-primary="Sylor-Miller, Katie" id="idm45017684428496"/><a data-type="indexterm" data-primary="Miller, Jason" id="idm45017684427824"/> popularized the term <a href="https://oreil.ly/CYhom">Islands architecture</a> to describe a paradigm that aims to reduce the volume of JavaScript shipped through “islands” of interactivity that can be independently delivered on top of otherwise static HTML. Islands are a component-based architecture that suggests a compartmentalized page view with static and dynamic islands. Most pages are a combination of static and dynamic content. Usually, a page consists of static content with sprinkles of interactive regions that you can demarcate. The static regions of the page are pure noninteractive HTML and do not need hydration. The dynamic regions are a combination of HTML and scripts capable of rehydrating themselves after 
<span class="keep-together">rendering.</span></p>

<p>The Islands architecture facilitates<a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="Islands architecture facilitating" id="idm45017684425360"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="Islands architecture facilitating" id="idm45017684424352"/> SSR of pages with all of their static content. However, in this case, the rendered HTML will include placeholders for dynamic content. The dynamic content placeholders contain self-contained component widgets. Each widget is similar to an app and combines server-rendered output and JavaScript to hydrate the app on the client.</p>

<p>Islands architecture may be confused<a data-type="indexterm" data-primary="progressive hydration" data-secondary="Islands architecture compared" id="idm45017684422864"/><a data-type="indexterm" data-primary="hydration" data-secondary="progressive hydration" data-tertiary="Islands architecture compared" id="idm45017684421824"/><a data-type="indexterm" data-primary="Islands architecture" data-secondary="progressive hydration compared" id="idm45017684420592"/> with progressive hydration, but there are pretty distinct. In progressive hydration, the hydration architecture of the page is top-down. The page controls the scheduling and hydration of individual components. Each component has its hydration script in the Islands architecture that executes 
<span class="keep-together">asynchronously,</span> independent of any other script on the page. A performance issue in one component should not affect the other.</p>








<section data-type="sect2" data-pdf-bookmark="Implementing Islands"><div class="sect2" id="idm45017684418592">
<h2>Implementing Islands</h2>

<p>The Island architecture borrows<a data-type="indexterm" data-primary="Islands architecture" data-secondary="implementing islands" id="idm45017684416864"/><a data-type="indexterm" data-primary="isomorphic rendering" id="idm45017684415888"/><a data-type="indexterm" data-primary="Jekyll" id="idm45017684415216"/><a data-type="indexterm" data-primary="Hugo" id="idm45017684414544"/> concepts from different sources and aims to combine them optimally. Template-based static site generators such as <a href="https://oreil.ly/dlxdC">Jekyll</a> and <a href="https://oreil.ly/WOKTz">Hugo</a> support rendering static 
<span class="keep-together">components</span> to pages. Most modern JavaScript frameworks also support <a href="https://oreil.ly/mre3v">isomorphic rendering</a>, which allows you to use the same code to render elements on the server and client.</p>

<p>Jason Miller’s post suggests using<a data-type="indexterm" data-primary="Miller, Jason" id="idm45017684410528"/><a data-type="indexterm" data-primary="Islands architecture" data-secondary="implementing islands" data-tertiary="requestIdleCallback() to schedule hydrating" id="idm45017684409792"/> <a href="https://oreil.ly/x7dpf"><code>requestIdleCallback()</code></a> to implement a scheduling approach for hydrating components. A framework that supports Islands architecture should do the following:</p>

<ul>
<li>
<p>Support static rendering of pages on the server with zero JavaScript.</p>
</li>
<li>
<p>Support embedding independent dynamic components via placeholders in static content. Each dynamic component contains its scripts and can hydrate itself using <code>requestIdleCallback()</code> as soon as the main thread is free.</p>
</li>
<li>
<p>Allow isomorphic rendering of components on the server with hydration on the client to recognize the same component at both ends.</p>
</li>
</ul>

<p>The following frameworks support this to some extent at present:</p>
<dl>
<dt>Marko</dt>
<dd>
<p><a href="https://oreil.ly/-l3QP">Marko</a> is an<a data-type="indexterm" data-primary="Marko" id="idm45017684400848"/> open source framework developed and maintained by eBay to improve server rendering performance. It supports Islands architecture by combining streaming rendering with automatic partial hydration. HTML and other static assets are streamed to the client as soon as they are ready. Automatic partial hydration allows interactive components to hydrate themselves. Hydration code is only shipped for interactive components, which can change state on the browser. It is isomorphic, and the Marko compiler generates optimized code depending on where it will run (client or server).</p>
</dd>
<dt>Astro</dt>
<dd>
<p><a href="https://oreil.ly/QT77v">Astro</a> is a <a data-type="indexterm" data-primary="Astro" id="idm45017684398144"/>static site builder that can generate lightweight static HTML pages from UI components built in other frameworks such as React, Preact, Svelte, Vue, and others. Components that need client-side JavaScript are loaded individually with their dependencies. Thus it provides built-in partial hydration. Astro can also lazy-load components depending on when they become visible.</p>
</dd>
<dt>Eleventy + Preact</dt>
<dd>
<p><a href="https://oreil.ly/PBckZ">Markus Oberlehner</a> demonstrates the use of Eleventy (11ty), a <a data-type="indexterm" data-primary="Eleventy (11ty) + Preact" id="idm45017684395440"/><a data-type="indexterm" data-primary="Oberlehner, Markus" id="idm45017684394672"/>static site generator with isomorphic Preact components that can be partially hydrated. It also supports lazy hydration. The component itself declaratively controls its hydration. Interactive components use a <code>WithHydration</code> wrapper so that they are hydrated on the client.</p>
</dd>
</dl>

<p>Note that Marko and Eleventy predate the definition of Islands provided by Jason but contain some of the features required to support it. Astro, however, was built based on the definition and inherently supports the Islands architecture.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Pros and Cons"><div class="sect2" id="idm45017684392784">
<h2>Pros and Cons</h2>

<p>Some of the potential benefits of implementing islands are as follows:<a data-type="indexterm" data-primary="Islands architecture" data-secondary="advantages and disadvantages" id="idm45017684391456"/></p>
<dl>
<dt>Performance</dt>
<dd>
<p>Reduces the amount of JavaScript code shipped to the client. The code sent consists only of the script required for interactive components. This is considerably less than the script needed to re-create the virtual DOM for the entire page and rehydrate all the elements. The smaller size of JavaScript automatically corresponds to faster page loads.</p>
</dd>
<dt>SEO</dt>
<dd>
<p>Since all the static content is rendered on the server, pages are SEO-friendly.</p>
</dd>
<dt>Prioritization of important content</dt>
<dd>
<p>Key content (especially for blogs, news articles, and product pages) is available almost immediately to the user.</p>
</dd>
<dt>Accessibility</dt>
<dd>
<p>Using standard static HTML links to access other pages helps to improve the accessibility of the website.</p>
</dd>
<dt>Component-based</dt>
<dd>
<p>The design offers all advantages of component-based architecture, such as reusability and maintainability.</p>
</dd>
</dl>

<p>Despite the advantages, the concept is still in a nascent stage. The only options for developers to implement Islands are to use one of the few available frameworks or develop the architecture yourself. Migrating existing sites to Astro or Marko would require additional efforts. The architecture is also unsuitable for highly interactive pages like social media apps that would probably require thousands of islands.<a data-type="indexterm" data-startref="ch13-isl" id="idm45017684382304"/><a data-type="indexterm" data-startref="ch13-isl2" id="idm45017684381600"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="React Server Components"><div class="sect1" id="idm45017684380672">
<h1>React Server Components</h1>

<p><a href="https://oreil.ly/nYygy">React Server Components (RSC)</a> are<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="React Server Components" id="idm45017684378608"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="React Server Components" id="idm45017684377632"/><a data-type="indexterm" data-primary="React Server Components" id="idm45017684376688"/> stateless React components designed to run on the server. They aim to enable modern UX with a server-driven mental model. These zero-bundle-size components facilitate a seamless code transition experience, or “knitting”, between server and client components. This differs from the SSR of components and could result in significantly smaller client-side JavaScript bundles.</p>

<p>RSC uses <code>async</code>/<code>await</code> as the primary way to fetch data from Server Components. They let you incorporate data fetching as an integral part of the component tree, allowing for top-level <code>await</code> and server-side data serialization. Components can thus be refetched regularly. An application with components that re-render when there is new data can be run on the server, limiting how much code needs to be sent to the client. This combines the rich interactivity of client-side apps with the improved performance of traditional server rendering.</p>

<p>RSC protocol enables the server to expose a special endpoint for the client to request parts of the component tree, allowing for SPA-like routing with MPA-like architecture. This allows merging the server component tree with the client-side tree without a loss of state and enables scaling up to more components.</p>

<p>Server Components<a data-type="indexterm" data-primary="SSR (server-side rendering)" data-secondary="React" data-tertiary="Server Components complementing SSR" id="idm45017684373360"/><a data-type="indexterm" data-primary="server-side rendering (SSR)" data-secondary="React" data-tertiary="Server Components complementing SSR" id="idm45017684372096"/> are not a replacement for SSR. When paired together, they support quickly rendering in an intermediate format, then having SSR infrastructure rendering this into HTML, enabling early paints to still be fast. We SSR the Client Components, which the Server Components emit, similar to how SSR is used with other data-fetching mechanisms.</p>

<p>RSC provides the specification for components. Adoption of RSC depends on frameworks implementing the feature. It is technically possible to use RSC with any React framework, enabling React’s own flavor of <a href="https://oreil.ly/CTvSX">partial hydration</a> with an end-state of hybrid rendering. <a data-type="indexterm" data-primary="Next.js" data-secondary="App Router" data-tertiary="React Server Component support" id="idm45017684369584"/><a data-type="indexterm" data-primary="Next.js" data-secondary="App Router" id="idm45017684368320"/>Next.js has already introduced support through its App Router feature. The React team believes RSC will eventually be widely adopted and change the ecosystem.</p>








<section data-type="sect2" data-pdf-bookmark="Hybrid Rendering with RSC and the Next.js App Router"><div class="sect2" id="idm45017684367120">
<h2>Hybrid Rendering with RSC and the Next.js App Router</h2>

<p>Next.js 13 introduced the <a href="https://oreil.ly/2fkjH">App Router</a> with new features,<a data-type="indexterm" data-primary="Next.js" data-secondary="hybrid rendering support" id="idm45017684364752"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="React Server Components" data-tertiary="hybrid rendering" id="idm45017684363680"/><a data-type="indexterm" data-primary="hybrid rendering" data-secondary="RSC and Next.js App Router" id="idm45017684362464"/> conventions, and support for RSC. Components in the app directory are RSC by default, promoting automatic adoption and improved performance.</p>

<p>RSC provide benefits such as leveraging server infrastructure and keeping large dependencies server-side, leading to better performance and reduced client-side bundle size. The Next.js App Router combines server rendering and client-side interactivity, progressively enhancing the application for a seamless user experience.</p>

<p>Client Components can be added to introduce client-side interactivity, similar to the functionality in Next.js 12 and earlier versions. The “use client” directive can mark components as Client Components. Components without the “use client” directive are automatically rendered as Server Components if not imported by another Client Component.</p>

<p>Server and Client Components can be interleaved in the same component tree, with React handling the merge of both environments. Next.js users have seen <a href="https://oreil.ly/sfKEC">performance improvements</a> after adopting RSC and the app directory in production.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="ch13_conclusion">
<h1>Summary</h1>

<p>This chapter introduced many patterns that attempt to balance the capabilities of CSR and SSR. Depending on the type of the application or the page type, some of the patterns may be more suitable than others. The chart in <a data-type="xref" href="#renderingpatterns">Figure 13-1</a> compares the highlights of different patterns and provides use cases for each.<a data-type="indexterm" data-primary="Rendering patterns" data-secondary="about" data-tertiary="chart highlighting pattern use cases" id="idm45017684356432"/></p>

<figure><div id="renderingpatterns" class="figure">
<img src="Images/ljd2_1301.png" alt="ljd2 1301" width="1228" height="1246"/>
<h6><span class="label">Figure 13-1. </span>Rendering patterns</h6>
</div></figure>

<p class="less_space pagebreak-before">The following table from <a href="https://oreil.ly/Qg_h6">Patterns for Building JavaScript Websites in 2022</a> offers another view pivoted by key application characteristics. It should be helpful for anyone looking for a suitable pattern for common <a href="https://oreil.ly/qgaKE">application holotypes</a>.<a data-type="indexterm" data-primary="Patterns for Building JavaScript Websites key application characteristics" id="idm45017684350912"/><a data-type="indexterm" data-primary="application holotypes" id="idm45017684350208"/><a data-type="indexterm" data-primary="Rendering patterns" data-secondary="about" data-tertiary="table of key application characteristics" id="idm45017684349536"/></p>
<table id="table_from_pbjs_2022" class="customtable">
<thead>
<tr class="level1">
<td><p/></td>
<td><p><strong>Portfolio</strong></p></td>
<td><p><strong>Content</strong></p></td>
<td><p><strong>Storefront</strong></p></td>
<td><p><strong>Social network</strong></p></td>
<td><p><strong>Immersive</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td><p><strong>Holotype</strong></p></td>
<td><p>Personal blog</p></td>
<td><p>CNN</p></td>
<td><p>Amazon</p></td>
<td><p>Social network</p></td>
<td><p>Figma</p></td>
</tr>
<tr>
<td><p><strong>Interactivity</strong></p></td>
<td><p>Minimal</p></td>
<td><p>Linked articles</p></td>
<td><p>Purchase</p></td>
<td><p>Multipoint, real time</p></td>
<td><p>Everything</p></td>
</tr>
<tr>
<td><p><strong>Session depth</strong></p></td>
<td><p>Shallow</p></td>
<td><p>Shallow</p></td>
<td><p>Shallow to medium</p></td>
<td><p>Extended</p></td>
<td><p>Deep</p></td>
</tr>
<tr>
<td><p><strong>Values</strong></p></td>
<td><p>Simplicity</p></td>
<td><p>Discover-ability</p></td>
<td><p>Load performance</p></td>
<td><p>Dynamicism</p></td>
<td><p>Immersiveness</p></td>
</tr>
<tr>
<td><p><strong>Routing</strong></p></td>
<td><p>Server</p></td>
<td><p>Server, hybrid</p></td>
<td><p>Hybrid, transitional</p></td>
<td><p>Transitional, client</p></td>
<td><p>Client</p></td>
</tr>
<tr>
<td><p><strong>Rendering</strong></p></td>
<td><p>Static</p></td>
<td><p>Static, SSR</p></td>
<td><p>Static, SSR</p></td>
<td><p>SSR</p></td>
<td><p>CSR</p></td>
</tr>
<tr>
<td><p><strong>Hydration</strong></p></td>
<td><p>None</p></td>
<td><p>Progressive, partial</p></td>
<td><p>Partial, resumable</p></td>
<td><p>Any</p></td>
<td><p>None (CSR)</p></td>
</tr>
<tr>
<td><p><strong>Example framework</strong></p></td>
<td><p>11ty</p></td>
<td><p>Astro, Elder</p></td>
<td><p>Marko, Qwik, Hydrogen</p></td>
<td><p>Next, Remix</p></td>
<td><p>Create React App</p></td>
</tr>
</tbody>
</table>

<p>We have now discussed some interesting React patterns for components, state management, rendering, and others. Libraries like React do not enforce a specific application structure, but there are recommended best practices for organizing your React projects. Let’s explore this in the next chapter.</p>
</div></section>
</div></section></div></body></html>