- en: Chapter 10\. Deploying Our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine if each time a user wanted to access our API to create, read, update,
    or delete a note we had to go meet them, laptop in tow. Currently, this is how
    our API works, as it is running only on our individual computer. We can resolve
    this by *deploying* our application to a web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’ll take two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll set up a remote database that our API can access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we’ll deploy our API code to a server and connect it to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we’ve followed these steps, we can access our API from any web-connected
    computer, including the web, desktop, and mobile interfaces that we will develop.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting Our Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the first step we’ll use a hosted database solution. For our Mongo database,
    we’ll be using MongoDB Atlas. This is a fully managed cloud offering backed by
    the organization behind Mongo itself. Additionally, they offer a free tier that
    will work well for our initial deployment. Let’s walk through the steps of deploying
    to MongoDB Atlas.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, visit [*mongodb.com/cloud/atlas*](https://oreil.ly/-TpJG) and create
    an account. Once you’ve created an account, you’ll be prompted to create a database.
    From this screen you can manage the settings of your sandbox database, but I recommend
    sticking with the defaults for now. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon’s AWS as the database host, though Google’s Cloud Platform and Microsoft’s
    Azure are also offered as options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closest region with a “free tier” option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster Tier with a default value of “M0 Sandbox (Shared RAM, 512MB Storage)”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional Settings, which we can leave as the defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster Name, which we can leave as the default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From here, click Create Cluster, at which point it will take a few minutes for
    Mongo to set up the database ([Figure 10-1](#mongo-atlas-create)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the default MongoDB Atlas new database settings](assets/jsev_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. The MongoDB Atlas database creation screen
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, you’ll see the Clusters page, where you can manage your individual database
    cluster ([Figure 10-2](#mongo-atlas-cluster)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of MongoDB Atlas''s Cluster Screen](assets/jsev_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. MongoDB Atlas Cluster
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From the Clusters screen, click Connect, where you’ll be prompted to set up
    your connection security. The first step will be to whitelist your IP address.
    Because our application will have a dynamic IP address, you’ll need to open this
    to any IP address by using `0.0.0.0/0`. With all IP addresses whitelisted, you’ll
    then need to set up a secure username and password for accessing the data ([Figure 10-3](#mongo-atlas-ip)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of MongoDB Atlas''s IP whitelist and user prompt](assets/jsev_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. MongoDB Atlas IP whitelist and user account management
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once your IP has been whitelisted and your user account has been created, you’ll
    choose the connection method for the database. In this case, it will be an “Application”
    connection ([Figure 10-4](#mongo-atlas-connection)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the connection type selection in MongoDB Atlas](assets/jsev_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Selecting a connection type in MongoDB Atlas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From here, you can copy the connection string, which we’ll be using in our production
    *.env* file ([Figure 10-5](#mongo-atlas-connection-string)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the connection string in MongoDB Atlas](assets/jsev_1005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-5\. MongoDB Atlas’s database connection string
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Mongo Passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB Atlas *hex-encodes* special characters within passwords. This means
    that if you use (and you should!) any nonalpha or numeric value, you will need
    to use the hex value for that code when adding your password to the connection
    string. The site [*ascii.cl*](https://ascii.cl) offers the corresponding hex codes
    for all special characters. For example, if your password was `Pizz@2!` you would
    need to encode the `@` and `!` characters. You do this with a `%` followed by
    the hex value. The resulting password would be `Pizz%402%21`.
  prefs: []
  type: TYPE_NORMAL
- en: With our MongoDB Atlas managed database up and running, we now have a hosted
    data store for our application. In the next step we’ll host our application code
    and connect it to our database.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Our Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in our deployment setup is to deploy our application code. For
    the purpose of this book we will use the cloud application platform Heroku. I’ve
    chosen Heroku due to its excellent user experience and generous free tier, but
    other cloud platforms such as Amazon Web Services, Google Cloud Platform, Digital
    Ocean, or Microsoft Azure all provide alternative hosting environments for Node.js
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, you will need to visit [Heroku’s website](https://heroku.com/apps)
    and create an account. Once your account has been created, you’ll need to install
    the [Heroku command-line tools](https://oreil.ly/Vf2Q_) for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS you can install the Heroku command-line tools using Homebrew as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For Windows users, visit the Heroku command-line tools guide and download the
    appropriate installer.
  prefs: []
  type: TYPE_NORMAL
- en: Project Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the Heroku command-line tools installed, we can set up our project within
    the Heroku website. Create a new Heroku project by clicking New → Create New App
    ([Figure 10-6](#heroku-new-app)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Heroku new app dialog](assets/jsev_1006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-6\. The Heroku New App dialog
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From here you’ll be prompted to give the application a unique name, after which
    you can click the Create App button ([Figure 10-7](#heroku-name-app)). Going forward,
    use this name anywhere you see `YOUR_APP_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Heroku app name screen](assets/jsev_1007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-7\. Provide a unique application name
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now we can add environment variables. Similar to how we used our *.env* file
    locally, we can manage our production environment variables within the Heroku
    website interface. To do so, click Settings followed by the Reveal Config Vars
    button. From this screen, add the following configuration variables ([Figure 10-8](#heroku-env)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Screenshot of the Heroku environment variable configuration](assets/jsev_1008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-8\. Heroku’s environment variable configuration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With our application configured, we’re ready to deploy our code.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to deploy our code to Heroku’s servers. To do this, we can
    use straightforward Git commands from our terminal application. We’ll set Heroku
    as a remote endpoint, then add and commit our changes, and finally push our code
    to Heroku. To do this, run the following commands within your terminal application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should see output in your terminal while Heroku builds and deploys the files.
    Once complete, Heroku will use the `run` script within our *package.json* file
    to run our application on their servers.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once our application has been successfully deployed, we will be able to make
    GraphQL API requests to our remote server. By default, the GraphQL Playground
    UI is disabled in production, but we can test our application using `curl` from
    our terminal application. To run a `curl` request, enter the following in your
    terminal application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If the test is successful, we should receive a response containing an empty
    `notes` array, since our production database does not yet contain any data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have deployed our application!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we used cloud services to deploy a database and our application
    code. Services such as MongoDB Atlas and Heroku enable developers to launch small
    applications and scale them anywhere from hobby projects to heavily trafficked
    business. With our API deployed, we have successfully developed the backend services
    of our applications’ stack. In the following chapters, we will focus on the UIs
    of our app.
  prefs: []
  type: TYPE_NORMAL
