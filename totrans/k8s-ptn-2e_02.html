<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introduction" data-type="chapter" epub:type="chapter"><div class="chapter" id="kubernetes-core-concepts">&#13;
<h1><span class="label">Chapter 1. </span>Introduction</h1>&#13;
&#13;
&#13;
<p>In this introductory chapter, we set the scene for the rest of the book by explaining a few of the core Kubernetes concepts used for designing and implementing cloud native applications. Understanding these new abstractions, and the related principles and patterns from this book, is key to building distributed applications that can be automatable by Kubernetes.</p>&#13;
&#13;
<p>This chapter is not a prerequisite for understanding the patterns described later. Readers familiar with Kubernetes concepts can skip it and jump straight into the pattern category of interest.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Path to Cloud Native" data-type="sect1"><div class="sect1" id="idm45902106225056">&#13;
<h1>The Path to Cloud Native</h1>&#13;
&#13;
<p>Microservices<a data-primary="Kubernetes" data-secondary="path to cloud native applications" data-type="indexterm" id="Kpath01"/><a data-primary="cloud native applications" data-type="indexterm" id="clntapp01"/><a data-primary="microservices architectural style" data-type="indexterm" id="micros01"/> is among the most popular architectural styles for creating cloud native applications. They tackle software complexity through modularization of business capabilities and trading development complexity for operational complexity. That is why a key prerequisite for becoming successful with microservices is to create applications that can be operated at scale through Kubernetes.</p>&#13;
&#13;
<p>As part of the microservices movement, there is a tremendous amount of theory, techniques, and supplemental tools for creating microservices from scratch or for splitting monoliths into microservices. Most of these practices are based on <a href="https://oreil.ly/UoON5"><em>Domain-Driven Design</em></a> by Eric Evans (Addison-Wesley) and the concepts of bounded contexts and aggregates. <em>Bounded contexts</em> deal with large models by dividing them into different components, and <em>aggregates</em> help to further group bounded contexts into modules with defined transaction boundaries. However, in addition to these business domain considerations, for each distributed system—whether it is based on microservices or not—there are also technical concerns around its external structure, and runtime coupling. Containers and container orchestrators such as Kubernetes bring in new primitives and abstractions to address the concerns of distributed applications, and here we discuss the various options to consider when putting a distributed system into Kubernetes.</p>&#13;
&#13;
<p>Throughout this book, we look at container and platform interactions by treating the containers as black boxes. However, we created this section to emphasize the importance of what goes into containers. Containers and cloud native platforms bring tremendous benefits to your distributed applications, but if all you put into containers is rubbish, you will get distributed rubbish at scale. <a data-type="xref" href="#img-path-cloud-native">Figure 1-1</a> shows the mixture of the skills required for creating good cloud native applications and where Kubernetes patterns fit in.</p>&#13;
&#13;
<figure class="width-55"><div class="figure" id="img-path-cloud-native">&#13;
<img alt="The path to cloud native" src="assets/kup2_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>The path to cloud native</h6>&#13;
</div></figure>&#13;
&#13;
<p>At a high level, creating good cloud native applications requires familiarity with multiple design techniques:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>At the lowest <em>code level</em>, every variable you define, every method you create, and every class you decide to instantiate plays a role in the long-term maintenance of the application. No matter what container technology and orchestration platform you use, the development team and the artifacts they create will have the most impact. It is important to grow developers who strive to write clean code, have the right number of automated tests, constantly refactor to improve code quality, and are guided by Software Craftsmanship principles at heart.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Domain-driven design</em> is<a data-primary="Domain-Driven Design (DDD)" data-type="indexterm" id="idm45902098868480"/><a data-primary="DDD (Domain-Driven Design)" data-type="indexterm" id="idm45902098867840"/> about approaching software design from a business perspective with the intention of keeping the architecture as close to the real world as possible. This approach works best for object-oriented programming languages, but there are also other good ways to model and design software for real-world problems. A model with the right business and transaction boundaries, easy-to-consume interfaces, and rich APIs is the foundation for successful containerization and automation later.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <em>hexagonal architecture</em> and its variations, such as Onion and Clean architectures, improve the flexibility and maintainability of applications by decoupling the application components and providing standardized interfaces for interacting with them. By decoupling the core business logic of a system from the surrounding infrastructure, hexagonal architecture makes it easier to port the system to different environments or platforms. These architectures complement domain-driven design and help arrange application code with distinct boundaries and externalized infrastructure dependencies.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <em>microservices architectural style</em> and the <a href="https://12factor.net">twelve-factor app</a> methodology very quickly evolved to become the norm for creating distributed applications and they provide valuable principles and practices for designing changing distributed applications. Applying these principles lets you create implementations that are optimized for scale, resiliency, and pace of change, which are common requirements for any modern software today.<a data-primary="" data-startref="micros01" data-type="indexterm" id="idm45902099386480"/></p>&#13;
</li>&#13;
<li>&#13;
<p><em>Containers</em> were<a data-primary="container orchestration platforms" data-type="indexterm" id="idm45902098561232"/> very quickly adopted as the standard way of packaging and running distributed applications, whether these are microservices or functions. Creating modular, reusable containers that are good cloud native citizens is another fundamental prerequisite. <em>Cloud native</em> is a term used to describe principles, patterns, and tools to automate containerized applications at scale. We use <em>cloud native</em> interchangeably with <em>Kubernetes</em>, which is the most popular open source cloud native platform available today.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In this book, we are not covering clean code, domain-driven design, hexagonal architecture, or microservices. We are focusing only on the patterns and practices addressing the concerns of the container orchestration. But for these patterns to be effective, your application needs to be designed well from the inside by using clean code practices, domain-driven design, hexagonal architecture-like isolation of external dependencies, microservices principles, and other relevant design techniques.<a data-primary="" data-startref="Kpath01" data-type="indexterm" id="idm45902098696080"/><a data-primary="" data-startref="clntapp01" data-type="indexterm" id="idm45902098695104"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Distributed Primitives" data-type="sect1"><div class="sect1" id="idm45902098694032">&#13;
<h1>Distributed Primitives</h1>&#13;
&#13;
<p>To<a data-primary="Kubernetes" data-secondary="primitives" data-type="indexterm" id="Kprim01"/> explain what we mean by new abstractions and primitives, here we compare them with the well-known<a data-primary="OOP (object-oriented programming)" data-type="indexterm" id="idm45902098949104"/><a data-primary="object-oriented programming (OOP)" data-type="indexterm" id="idm45902099580608"/> object-oriented programming (OOP), and Java specifically. In the OOP universe, we have concepts such as class, object, package, inheritance, encapsulation, and polymorphism. Then the Java runtime provides specific features and guarantees on how it manages the lifecycle of our objects and the application as a whole.</p>&#13;
&#13;
<p>The Java language and the<a data-primary="daemons" data-secondary="background tasks" data-type="indexterm" id="Dback01"/><a data-primary="JVM daemon threads" data-type="indexterm" id="jvmdaemon01"/> Java Virtual Machine (JVM) provide local, in-process building blocks for creating applications. Kubernetes adds an entirely new dimension to this well-known mindset by offering a new set of distributed primitives and runtime for building distributed systems that spread across multiple nodes and processes. With Kubernetes at hand, we don’t rely only on the local primitives to implement the whole application behavior.</p>&#13;
&#13;
<p>We still need to use the object-oriented building blocks to create the components of the distributed application, but we can also use Kubernetes primitives for some of the application behaviors. <a data-type="xref" href="#table-jvm_k8s">Table 1-1</a> shows how various development concepts are realized differently with local and distributed primitives in the JVM and Kubernetes, respectively.<a data-primary="Periodic Job" data-type="indexterm" id="idm45902100988480"/><a data-primary="Daemon Service" data-type="indexterm" id="idm45902100987808"/><a data-primary="Sidecar" data-type="indexterm" id="idm45902099907440"/><a data-primary="Configuration Resource" data-type="indexterm" id="idm45902099906768"/><a data-primary="Init Container" data-type="indexterm" id="idm45902099906096"/><a data-primary="DaemonSets" data-secondary="background tasks" data-type="indexterm" id="DSback01"/><a data-primary="CronJobs" data-secondary="periodic tasks" data-type="indexterm" id="cronjob01"/><a data-primary="Job parallelism" data-type="indexterm" id="idm45902099575664"/></p>&#13;
<table id="table-jvm_k8s">&#13;
<caption><span class="label">Table 1-1. </span>Local and distributed primitives</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Concept</th>&#13;
<th>Local primitive</th>&#13;
<th>Distributed primitive</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Behavior encapsulation</p></td>&#13;
<td><p>Class</p></td>&#13;
<td><p>Container image</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Behavior instance</p></td>&#13;
<td><p>Object</p></td>&#13;
<td><p>Container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Unit of reuse</p></td>&#13;
<td><p><em>.jar</em></p></td>&#13;
<td><p>Container image</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Composition</p></td>&#13;
<td><p>Class A contains Class B</p></td>&#13;
<td><p>Sidecar pattern</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Inheritance</p></td>&#13;
<td><p>Class A extends Class B</p></td>&#13;
<td><p>A container’s <code>FROM</code> parent image</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Deployment unit</p></td>&#13;
<td><p><em>.jar</em>/<em>.war</em>/<em>.ear</em></p></td>&#13;
<td><p>Pod</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Buildtime/Runtime isolation</p></td>&#13;
<td><p>Module, package, class</p></td>&#13;
<td><p>Namespace, Pod, container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Initialization preconditions</p></td>&#13;
<td><p>Constructor</p></td>&#13;
<td><p>Init container</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Postinitialization trigger</p></td>&#13;
<td><p>Init-method</p></td>&#13;
<td><p><code>postStart</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Predestroy trigger</p></td>&#13;
<td><p>Destroy-method</p></td>&#13;
<td><p><code>preStop</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Cleanup procedure</p></td>&#13;
<td><p><code>finalize()</code>, shutdown hook</p></td>&#13;
<td><p>-</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Asynchronous and parallel execution</p></td>&#13;
<td><p><code>ThreadPoolExecutor</code>, &#13;
<span class="keep-together"><code>ForkJoinPool</code></span></p></td>&#13;
<td><p>Job</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Periodic task</p></td>&#13;
<td><p><code>Timer</code>, <code>ScheduledExecutorService</code></p></td>&#13;
<td><p>CronJob</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Background task</p></td>&#13;
<td><p>Daemon thread</p></td>&#13;
<td><p>DaemonSet</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Configuration management</p></td>&#13;
<td><p><code>System.getenv()</code>, <code>Properties</code></p></td>&#13;
<td><p>ConfigMap, Secret</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The in-process primitives and the distributed primitives have commonalities, but they are not directly comparable and replaceable. They operate at different abstraction levels and have different preconditions and guarantees. Some primitives are supposed to be used together. For example, we still have to use classes to create objects and put them into container images. However, some other primitives such as CronJob in Kubernetes can completely replace the <code>ExecutorService</code> behavior in Java.</p>&#13;
&#13;
<p>Next, let’s see a few distributed abstractions and primitives from Kubernetes that are especially interesting for application developers.<a data-primary="" data-startref="cronjob01" data-type="indexterm" id="idm45902098822912"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Containers" data-type="sect2"><div class="sect2" id="idm45902098821808">&#13;
<h2>Containers</h2>&#13;
&#13;
<p><em>Containers</em> are<a data-primary="containers" data-secondary="basics of" data-type="indexterm" id="idm45902098819984"/> the building blocks for Kubernetes-based cloud native applications. If we make a comparison with OOP and Java, container images are like classes, and containers are like objects. The same way we can extend classes to reuse and alter behavior, we can have container images that extend other container images to reuse and alter behavior. The same way we can do object composition and use functionality, we can do container compositions by putting containers into a Pod and using collaborating containers.</p>&#13;
&#13;
<p>If we continue the comparison, Kubernetes would be like the JVM but spread over multiple hosts, and it would be responsible for running and managing the containers. Init containers would be something like object constructors; DaemonSets would be similar to daemon threads that run in the background (like the Java Garbage Collector, for example). A Pod would be something similar to an Inversion of Control (IoC) context<a data-primary="Spring Framework" data-type="indexterm" id="idm45902098743376"/> (Spring Framework, for example), where multiple running objects share a managed lifecycle and can access one another directly.<a data-primary="" data-startref="jvmdaemon01" data-type="indexterm" id="idm45902098742544"/><a data-primary="" data-startref="Dback01" data-type="indexterm" id="idm45902098741600"/><a data-primary="" data-startref="DSback01" data-type="indexterm" id="idm45902099028912"/></p>&#13;
&#13;
<p>The parallel doesn’t go much further, but the point is that containers play a fundamental role in Kubernetes, and creating modularized, reusable, single-purpose container images is fundamental to the long-term success of any project and even the containers’ ecosystem as a whole. Apart from the technical characteristics of a container image that provide packaging and isolation, what does a container represent, and what is its purpose in the context of a distributed application? Here are a few suggestions on how to look at containers:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A container image is the unit of functionality that addresses a single concern.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container image is owned by one team and has its own release cycle.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container image is self-contained and defines and carries its runtime <span class="keep-together">dependencies</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container image is immutable, and once it is built, it does not change; it is <span class="keep-together">configured</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container image defines its resource requirements and external dependencies.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container image has well-defined APIs to expose its functionality.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container typically runs as a single Unix process.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container is disposable and safe to scale up or down at any moment.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In addition to all these characteristics, a proper container image is modular. It is parameterized and created for reuse in the different environments in which it is going to run. Having small, modular, and reusable container images leads to the creation of more specialized and stable container images in the long term, similar to a great reusable library in the programming language world.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pods" data-type="sect2"><div class="sect2" id="idm45902099618720">&#13;
<h2>Pods</h2>&#13;
&#13;
<p>Looking<a data-primary="Pods" data-secondary="basics of" data-type="indexterm" id="idm45902098622880"/> at the characteristics of containers, we can see that they are a perfect match for implementing the microservices principles. A container image provides a single unit of functionality, belongs to a single team, has an independent release cycle, and provides deployment and runtime isolation. Most of the time, one microservice corresponds to one container image.</p>&#13;
&#13;
<p>However, most cloud native platforms offer another primitive for managing the lifecycle of a group of containers—in Kubernetes, it is called a Pod. A <em>Pod</em> is an atomic unit of<a data-primary="scheduler" data-secondary="role of" data-type="indexterm" id="idm45902098620944"/> scheduling, deployment, and runtime isolation for a group of containers. All containers in a Pod are always scheduled to the same host, are deployed and scaled together, and can also share filesystem, networking, and process namespaces. This joint lifecycle allows the containers in a Pod to interact with one another over the filesystem or through networking via localhost or host interprocess communication mechanisms if desired (for performance reasons, for <span class="keep-together">example</span>). A Pod also represents a security boundary for an application. While it is possible to have containers with varying security parameters in the same Pod, typically all containers would have the same access level, network segmentation, and identity.</p>&#13;
&#13;
<p>As you can see in <a data-type="xref" href="#img-pod">Figure 1-2</a>, at development and build time, a microservice corresponds to a container image that one team develops and releases. But at runtime, a microservice is represented by a Pod, which is the unit of deployment, placement, and scaling. The only way to run a container—whether for scale or migration—is through the Pod abstraction. Sometimes a Pod contains more than one container. In one such example, a containerized microservice uses a helper container at runtime, as<a data-primary="Sidecar" data-type="indexterm" id="idm45902101112048"/> <a data-type="xref" data-xrefstyle="chap-num-title" href="ch16.html#Sidecar">Chapter 16, “Sidecar”</a>, demonstrates.</p>&#13;
&#13;
<figure class="width-55"><div class="figure" id="img-pod">&#13;
<img alt="Pod as the deployment and management unit" src="assets/kup2_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>A Pod as the deployment and management unit</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Containers, Pods, and their unique characteristics offer a new set of patterns and principles for designing microservices-based applications. We saw some of the characteristics of well-designed containers; now let’s look at some characteristics of a Pod:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A Pod is the atomic unit of scheduling. That means the scheduler tries to find a host that satisfies the requirements of all containers that belong to the Pod (we cover some specifics around<a data-primary="Init Container" data-type="indexterm" id="idm45902099625488"/> init containers in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch15.html#InitContainer">Chapter 15, “Init Container”</a>). If you create a Pod with many containers, the scheduler needs to find a host that has enough resources to satisfy all container demands combined. This scheduling process is described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch06.html#AutomatedPlacement">Chapter 6, “Automated Placement”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A Pod ensures colocation of containers. Thanks to the colocation, containers in the same Pod have additional means to interact with one another. The most common ways of communicating include using a shared local filesystem for exchanging data, using the localhost network interface, or using some host interprocess communication (IPC) mechanism for high-performance interactions.</p>&#13;
</li>&#13;
<li>&#13;
<p>A Pod has an IP address, name, and port range that are shared by all containers belonging to it. That means containers in the same Pod have to be carefully configured to avoid port clashes, in the same way that parallel, running Unix processes have to take care when sharing the networking space on a host.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A Pod is the atom of Kubernetes where your application lives, but you don’t access Pods directly—that is where Services enter the scene.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Services" data-type="sect2"><div class="sect2" id="idm45902099998448">&#13;
<h2>Services</h2>&#13;
&#13;
<p>Pods<a data-primary="Services" data-secondary="basics of" data-type="indexterm" id="idm45902099032992"/> are ephemeral. They come and go at any time for all sorts of reasons (e.g., scaling up and down, failing container health checks, node migrations). A Pod IP address is known only after it is scheduled and started on a node. A Pod can be rescheduled to a different node if the existing node it is running on is no longer healthy. This means the Pod’s network address may change over the life of an application, and there is a need for another primitive for discovery and load balancing.</p>&#13;
&#13;
<p>That’s where the Kubernetes Services come into play. The Service is another simple but powerful Kubernetes abstraction that binds the Service name to an IP address and port number permanently. So a Service represents a named entry point for accessing an application. In the most common scenario, the Service serves as the entry point for a set of Pods, but that might not always be the case. The Service is a generic primitive, and it may also point to functionality provided outside the Kubernetes cluster. As such, the Service primitive can be used for<a data-primary="Service Discovery" data-type="indexterm" id="idm45902099031008"/> Service discovery and load balancing, and it allows altering implementations and scaling without affecting Service consumers. We explain Services in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.html#ServiceDiscovery">Chapter 13, “Service Discovery”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Labels" data-type="sect2"><div class="sect2" id="intro-labels">&#13;
<h2>Labels</h2>&#13;
&#13;
<p>We<a data-primary="labels" data-type="indexterm" id="idm45902103864144"/> have seen that a microservice is a container image at build time but is represented by a Pod at runtime. So what is an application that consists of multiple microservices? Here, Kubernetes offers two more primitives that can help you define the concept of an application: labels and namespaces.</p>&#13;
&#13;
<p>Before microservices, an application corresponded to a single deployment unit with a single versioning scheme and release cycle. There was a single file for an application in a <em>.war</em>, <em>.ear</em>, or some other packaging format. But then, applications were split into microservices, which are independently developed, released, run, restarted, or scaled. With microservices, the notion of an application diminishes, and there are no key artifacts or activities that we have to perform at the application level. But if you still need a way to indicate that some independent services belong to an application, <em>labels</em> can be used. Let’s imagine that we have split one monolithic application into three microservices and another one into two microservices.</p>&#13;
&#13;
<p>We now have five Pod definitions (and maybe many more Pod instances) that are independent of the development and runtime points of view. However, we may still need to indicate that the first three Pods represent an application and the other two Pods represent another application. Even the Pods may be independent, to provide a business value, but they may depend on one another. For example, one Pod may contain the containers responsible for the frontend, and the other two Pods are responsible for providing the backend functionality. If either of these Pods is down, the application is useless from a business point of view. Using<a data-primary="label selectors" data-secondary="benefits of" data-type="indexterm" id="idm45902099084912"/> label selectors gives us the ability to query and identify a set of Pods and manage it as one logical unit. <a data-type="xref" href="#img-label">Figure 1-3</a> shows how you can use labels to group the parts of a distributed application into specific subsystems.</p>&#13;
&#13;
<figure class="width-80"><div class="figure" id="img-label">&#13;
<img alt="Labels used as an application identity for Pods" src="assets/kup2_0103.png"/>&#13;
<h6><span class="label">Figure 1-3. </span>Labels used as an application identity for Pods</h6>&#13;
</div></figure>&#13;
&#13;
<p>Here are a few examples where labels can be useful:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Labels<a data-primary="ReplicaSet" data-secondary="labels" data-type="indexterm" id="idm45902099041968"/> are used by ReplicaSets to keep some instances of a specific Pod running. That means every Pod definition needs to have a unique combination of labels used for scheduling.</p>&#13;
</li>&#13;
<li>&#13;
<p>Labels<a data-primary="scheduler" data-secondary="labels used by" data-type="indexterm" id="idm45902104041296"/> are also heavily used by the scheduler. The scheduler uses labels for colocating or spreading Pods to the nodes that satisfy the Pods’ requirements.</p>&#13;
</li>&#13;
<li>&#13;
<p>A label can indicate a logical grouping of a set of Pods and give an application identity to them.</p>&#13;
</li>&#13;
<li>&#13;
<p>In addition to the preceding typical use cases, labels can be used to store metadata. It may be difficult to predict what a label could be used for, but it is best to have enough labels to describe all important aspects of the Pods. For example, having labels to indicate the logical group of an application, the business characteristics and criticality, the specific runtime platform dependencies such as hardware architecture, or location preferences are all useful.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Later, these labels can be used by the scheduler for more fine-grained scheduling, or the same labels can be used from the command line for managing the matching Pods at scale. However, you should not go overboard and add too many labels in advance. You can always add them later if needed. Removing labels is much riskier as there is no straightforward way of finding out what a label is used for and what unintended effect such an action may cause.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902103851744">&#13;
<h1>Annotations</h1>&#13;
<p>Another<a data-primary="annotations" data-type="indexterm" id="idm45902103850416"/> primitive very similar to labels is the <em>annotation</em>. Like labels, annotations are organized as a map, but they are intended for specifying nonsearchable metadata and for machine usage rather than human.</p>&#13;
&#13;
<p>The information on the annotations is not intended for querying and matching objects. Instead, it is intended for attaching additional metadata to objects from various tools and libraries we want to use. Some examples of using annotations include build IDs, release IDs, image information, timestamps, Git branch names, pull request numbers, image hashes, registry addresses, author names, tooling information, and more. So while labels are used primarily for query matching and performing actions on the matching resources, annotations are used to attach metadata that can be consumed by a machine.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Namespaces" data-type="sect2"><div class="sect2" id="concepts-namespaces">&#13;
<h2>Namespaces</h2>&#13;
&#13;
<p>Another<a data-primary="namespaces" data-type="indexterm" id="idm45902098825632"/> primitive that can also help manage a group of resources is the Kubernetes <em>namespace</em>. As we have described, a namespace may seem similar to a label, but in reality, it is a very different primitive with different characteristics and purposes.</p>&#13;
&#13;
<p>Kubernetes namespaces allow you to divide a Kubernetes cluster (which is usually spread across multiple hosts) into a logical pool of resources. Namespaces provide scopes for Kubernetes resources and a mechanism to apply authorizations and other policies to a subsection of the cluster. The most common use case of namespaces is representing different software environments such as development, testing, integration testing, or production. Namespaces can also be used to achieve multitenancy and provide isolation for team workspaces, projects, and even specific applications. But ultimately, for a greater isolation of certain environments, namespaces are not enough, and having separate clusters is common. Typically, there is one nonproduction Kubernetes cluster used for some environments (development, testing, and integration testing) and another production Kubernetes cluster to represent performance testing and production environments.</p>&#13;
&#13;
<p>Let’s look at some of the characteristics of namespaces and how they can help us in different scenarios:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A namespace is managed as a Kubernetes resource.</p>&#13;
</li>&#13;
<li>&#13;
<p>A namespace provides scope for resources such as containers, Pods, Services, or<a data-primary="ReplicaSet" data-secondary="namespaces" data-type="indexterm" id="idm45902099694880"/> ReplicaSets. The names of resources need to be unique within a namespace but not across them.</p>&#13;
</li>&#13;
<li>&#13;
<p>By default, namespaces provide scope for resources, but nothing isolates those resources and prevents access from one resource to another. For example, a Pod from a development namespace can access another Pod from a production namespace as long as the Pod IP address is known. “Network isolation across namespaces for creating a lightweight multitenancy solution is described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch24.html#NetworkSegmentation">Chapter 24, “Network Segmentation”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Some other resources, such as namespaces, nodes, and PersistentVolumes, do not belong to namespaces and should have unique cluster-wide names.</p>&#13;
</li>&#13;
<li>&#13;
<p>Each Kubernetes Service belongs to a namespace and gets a corresponding Domain Name Service (DNS) record that has the namespace in the form of <code>&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code>. So the namespace name is in the URL of every Service belonging to the given namespace. That’s one reason it is vital to name namespaces wisely.</p>&#13;
</li>&#13;
<li>&#13;
<p>ResourceQuotas provide constraints that limit the aggregated resource consumption per namespace. With ResourceQuotas, a cluster administrator can control the number of objects per type that are allowed in a namespace. For example, a developer namespace may allow only five ConfigMaps, five Secrets, five Services, five ReplicaSets, five PersistentVolumeClaims, and ten Pods.</p>&#13;
</li>&#13;
<li>&#13;
<p>ResourceQuotas can also limit the total sum of computing resources we can request in a given namespace. For example, in a cluster with a capacity of 32 GB RAM and 16 cores, it is possible to allocate 16 GB RAM and 8 cores for the production namespace, 8 GB RAM and 4 cores for the staging environment, 4 GB RAM and 2 cores for development, and the same amount for testing namespaces. The ability to impose resource constraints decoupled from the shape and the limits of the underlying infrastructure is invaluable.<a data-primary="" data-startref="Kprim01" data-type="indexterm" id="idm45902099315264"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902098951600">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>We’ve only briefly covered a few of the main Kubernetes concepts we use in this book. However, there are more primitives used by developers on a day-by-day basis. For example, if you create a containerized service, there are plenty of Kubernetes abstractions you can use to reap all the benefits of Kubernetes. Keep in mind, these are only a few of the objects used by application developers to integrate a containerized service into Kubernetes. There are plenty of other concepts used primarily by cluster administrators for managing Kubernetes. <a data-type="xref" href="#img-k8s_objects">Figure 1-4</a> gives an overview of the main Kubernetes resources that are useful for developers.</p>&#13;
&#13;
<figure class="width-85"><div class="figure" id="img-k8s_objects">&#13;
<img alt="Kubernetes concepts for developers" src="assets/kup2_0104.png"/>&#13;
<h6><span class="label">Figure 1-4. </span>Kubernetes concepts for developers<a data-primary="Kubernetes" data-secondary="concepts for developers" data-type="indexterm" id="idm45902098983824"/></h6>&#13;
</div></figure>&#13;
&#13;
<p>With time, these new primitives give birth to new ways of solving problems, and some of these repetitive solutions become patterns. Throughout this book, rather than describing each Kubernetes resource in detail, we will focus on concepts that are proven as patterns.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902098807680">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/ad0al">The Twelve-Factor App</a><a data-primary="Kubernetes" data-secondary="resources for learning about" data-type="indexterm" id="idm45902098805056"/><a data-primary="twelve-factor app" data-type="indexterm" id="idm45902098804064"/></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/NUiXM">CNCF Cloud Native Definition v1.0</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/rvcDB">Hexagonal Architecture</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/8IHI4"><em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Be0g6">Best Practices for Writing Dockerfiles</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/-x16l">Principles of Container-Based Application Design</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/yyItc">General Container Image Guidelines</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>