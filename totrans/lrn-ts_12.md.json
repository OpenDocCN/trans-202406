["```\nfunction identity(input) {\n    return input;\n}\n\nidentity(\"abc\");\nidentity(123);\nidentity({ quote: \"I think your self emerges more clearly over time.\" });\n```", "```\nfunction identity(input: any) {\n    return input;\n}\n\nlet value = identity(42); // Type of value: any\n```", "```\nfunction identity<T>(input: T) {\n    return input;\n}\n\nconst numeric = identity(\"me\"); // Type: \"me\"\nconst stringy = identity(123); // Type: 123\n```", "```\nconst identity = <T>(input: T) => input;\n\nidentity(123); // Type: 123\n```", "```\nfunction logWrapper<Input>(callback: (input: Input) => void) {\n    return (input: Input) => {\n        console.log(\"Input:\", input);\n        callback(input);\n    };\n}\n\n// Type: (input: string) => void\nlogWrapper((input: string) => {\n    console.log(input.length);\n});\n\n// Type: (input: unknown) => void\nlogWrapper((input) => {\n    console.log(input.length);\n    //                ~~~~~~\n    // Error: Property 'length' does not exist on type 'unknown'.\n});\n```", "```\n// Type: (input: string) => void\nlogWrapper<string>((input) => {\n    console.log(input.length);\n});\n\nlogWrapper<string>((input: boolean) => {\n    //             ~~~~~~~~~~~~~~~~~~~~~~~\n    // Argument of type '(input: boolean) => void' is not\n    // assignable to parameter of type '(input: string) => void'.\n    //   Types of parameters 'input' and 'input' are incompatible.\n    //     Type 'string' is not assignable to type 'boolean'.\n});\n```", "```\n// Type: (input: string) => void\nlogWrapper<string>((input: string) => { /* ... */ });\n```", "```\nfunction makeTuple<First, Second>(first: First, second: Second) {\n    return [first, second] as const;\n}\n\nlet tuple = makeTuple(true, \"abc\"); // Type of value: readonly [boolean, string]\n```", "```\nfunction makePair<Key, Value>(key: Key, value: Value) {\n    return { key, value };\n}\n\n// Ok: neither type argument provided\nmakePair(\"abc\", 123); // Type: { key: string; value: number }\n\n// Ok: both type arguments provided\nmakePair<string, number>(\"abc\", 123); // Type: { key: string; value: number }\nmakePair<\"abc\", 123>(\"abc\", 123); // Type: { key: \"abc\"; value: 123 }\n\nmakePair<string>(\"abc\", 123);\n//       ~~~~~~\n// Error: Expected 2 type arguments, but got 1.\n```", "```\ninterface Box<T> {\n    inside: T;\n}\n\nlet stringyBox: Box<string> = {\n    inside: \"abc\",\n};\n\nlet numberBox: Box<number> = {\n    inside: 123,\n}\n\nlet incorrectBox: Box<number> = {\n    inside: false,\n    // Error: Type 'boolean' is not assignable to type 'number'.\n}\n```", "```\ninterface Array<T> {\n    // ...\n\n    /**\n * Removes the last element from an array and returns it.\n * If the array is empty, undefined is returned and the array is not modified.\n */\n    pop(): T | undefined;\n\n    /**\n * Appends new elements to the end of an array,\n * and returns the new length of the array.\n * @param items new elements to add to the array.\n */\n    push(...items: T[]): number;\n\n    // ...\n}\n```", "```\ninterface LinkedNode<Value> {\n    next?: LinkedNode<Value>;\n    value: Value;\n}\n\nfunction getLast<Value>(node: LinkedNode<Value>): Value {\n    return node.next ? getLast(node.next) : node.value;\n}\n\n// Inferred Value type argument: Date\nlet lastDate = getLast({\n    value: new Date(\"09-13-1993\"),\n});\n\n// Inferred Value type argument: string\nlet lastFruit = getLast({\n    next: {\n        value: \"banana\",\n    },\n    value: \"apple\",\n});\n\n// Inferred Value type argument: number\nlet lastMismatch = getLast({\n    next: {\n        value: 123\n    },\n    value: false,\n//  ~~~~~\n// Error: type 'boolean' is not assignable to type 'number'.\n});\n```", "```\ninterface CrateLike<T> {\n    contents: T;\n}\n\nlet missingGeneric: CrateLike = {\n    //              ~~~~~~~~~\n    // Error: Generic type 'Crate<T>' requires 1 type argument(s).\n    inside: \"??\"\n};\n```", "```\nclass Secret<Key, Value> {\n    key: Key;\n    value: Value;\n\n    constructor(key: Key, value: Value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    getValue(key: Key): Value | undefined {\n        return this.key === key\n            ? this.value\n            : undefined;\n    }\n}\n\nconst storage = new Secret(12345, \"luggage\"); // Type: Secret<number, string>\n\nstorage.getValue(1987); // Type: string | undefined\n```", "```\nclass CurriedCallback<Input> {\n    #callback: (input: Input) => void;\n\n    constructor(callback: (input: Input) => void) {\n        this.#callback = (input: Input) => {\n            console.log(\"Input:\", input);\n            callback(input);\n        };\n    }\n\n    call(input: Input) {\n        this.#callback(input);\n    }\n}\n\n// Type: CurriedCallback<string>\nnew CurriedCallback((input: string) => {\n    console.log(input.length);\n});\n\n// Type: CurriedCallback<unknown>\nnew CurriedCallback((input) => {\n    console.log(input.length);\n    //                ~~~~~~\n    // Error: Property 'length' does not exist on type 'unknown'.\n});\n```", "```\n// Type: CurriedCallback<string>\nnew CurriedCallback<string>((input) => {\n    console.log(input.length);\n});\n\nnew CurriedCallback<string>((input: boolean) => {\n    //                       ~~~~~~~~~~~~~~~~~~~~~~\n    // Argument of type '(input: boolean) => void' is not\n    // assignable to parameter of type '(input: string) => void'.\n    //   Types of parameters 'input' and 'input' are incompatible.\n    //     Type 'string' is not assignable to type 'boolean'.\n});\n```", "```\nclass Quote<T> {\n    lines: T;\n\n    constructor(lines: T) {\n        this.lines = lines;\n    }\n}\n\nclass SpokenQuote extends Quote<string[]> {\n    speak() {\n        console.log(this.lines.join(\"\\n\"));\n    }\n}\n\nnew Quote(\"The only real failure is the failure to try.\").lines; // Type: string\nnew Quote([4, 8, 15, 16, 23, 42]).lines; // Type: number[]\n\nnew SpokenQuote([\n    \"Greed is so destructive.\",\n    \"It destroys everything\",\n]).lines; // Type: string[]\n\nnew SpokenQuote([4, 8, 15, 16, 23, 42]);\n//              ~~~~~~~~~~~~~~~~~~~~~~\n// Error: Argument of type 'number' is not\n// assignable to parameter of type 'string'.\n```", "```\nclass AttributedQuote<Value> extends Quote<Value> {\n    speaker: string\n\n    constructor(value: Value, speaker: string) {\n        super(value);\n        this.speaker = speaker;\n    }\n}\n\n// Type: AttributedQuote<string>\n// (extending Quote<string>)\nnew AttributedQuote(\n    \"The road to success is always under construction.\",\n    \"Lily Tomlin\",\n);\n```", "```\ninterface ActingCredit<Role> {\n    role: Role;\n}\n\nclass MoviePart implements ActingCredit<string> {\n    role: string;\n    speaking: boolean;\n\n    constructor(role: string, speaking: boolean) {\n        this.role = role;\n        this.speaking = speaking;\n    }\n}\n\nconst part = new MoviePart(\"Miranda Priestly\", true);\n\npart.role; // Type: string\n\nclass IncorrectExtension implements ActingCredit<string> {\n    role: boolean;\n    //    ~~~~~~~\n    // Error: Property 'role' in type 'IncorrectExtension' is not\n    // assignable to the same property in base type 'ActingCredit<string>'.\n    //   Type 'boolean' is not assignable to type 'string'.\n}\n```", "```\nclass CreatePairFactory<Key> {\n    key: Key;\n\n    constructor(key: Key) {\n        this.key = key;\n    }\n\n    createPair<Value>(value: Value) {\n        return { key: this.key, value };\n    }\n}\n\n// Type: CreatePairFactory<string>\nconst factory = new CreatePairFactory(\"role\");\n\n// Type: { key: string, value: number }\nconst numberPair = factory.createPair(10);\n\n// Type: { key: string, value: string }\nconst stringPair = factory.createPair(\"Sophie\");\n```", "```\nclass BothLogger<OnInstance> {\n    instanceLog(value: OnInstance) {\n        console.log(value);\n        return value;\n    }\n\n    static staticLog<OnStatic>(value: OnStatic) {\n        let fromInstance: OnInstance;\n        //                ~~~~~~~~~~\n        // Error: Static members cannot reference class type arguments.\n\n        console.log(value);\n        return value;\n    }\n}\n\nconst logger = new BothLogger<number[]>;\nlogger.instanceLog([1, 2, 3]); // Type: number[]\n\n// Inferred OnStatic type argument: boolean[]\nBothLogger.staticLog([false, true]);\n\n// Explicit OnStatic type argument: string\nBothLogger.staticLog<string>(\"You can't change the music of your soul.\");\n```", "```\ntype Nullish<T> = T | null | undefined;\n```", "```\ntype CreatesValue<Input, Output> = (input: Input) => Output;\n\n// Type: (input: string) => number\nlet creator: CreatesValue<string, number>;\n\ncreator = text => text.length; // Ok\n\ncreator = text => text.toUpperCase();\n//                ~~~~~~~~~~~~~~~~~~\n// Error: Type 'string' is not assignable to type 'number'.\n```", "```\ntype Result<Data> = FailureResult | SuccessfulResult<Data>;\n\ninterface FailureResult {\n    error: Error;\n    succeeded: false;\n}\n\ninterface SuccessfulResult<Data> {\n    data: Data;\n    succeeded: true;\n}\n\nfunction handleResult(result: Result<string>) {\n    if (result.succeeded) {\n        // Type of result: SuccessfulResult<string>\n        console.log(`We did it! ${result.data}`);\n    } else {\n        // Type of result: FailureResult\n        console.error(`Awww... ${result.error}`);\n    }\n\n    result.data;\n    //     ~~~~\n    // Error: Property 'data' does not exist on type 'Result<string>'.\n    //   Property 'data' does not exist on type 'FailureResult'.\n}\n```", "```\ninterface Quote<T = string> {\n    value: T;\n}\n\nlet explicit: Quote<number> = { value: 123 };\n\nlet implicit: Quote = { value: \"Be yourself. The world worships the original.\" };\n\nlet mismatch: Quote = { value: 123 };\n//                                     ~~~\n// Error: Type 'number' is not assignable to type 'string'.\n```", "```\ninterface KeyValuePair<Key, Value = Key> {\n    key: Key;\n    value: Value;\n}\n\n// Type: KeyValuePair<string, string>\nlet allExplicit: KeyValuePair<string, number> = {\n    key: \"rating\",\n    value: 10,\n};\n\n// Type: KeyValuePair<string>\nlet oneDefaulting: KeyValuePair<string> = {\n    key: \"rating\",\n    value: \"ten\",\n};\n\nlet firstMissing: KeyValuePair = {\n    //            ~~~~~~~~~~~~\n    // Error: Generic type 'KeyValuePair<Key, Value>'\n    // requires between 1 and 2 type arguments.\n    key: \"rating\",\n    value: 10,\n};\n```", "```\nfunction inTheEnd<First, Second, Third = number, Fourth = string>() {} // Ok\n\nfunction inTheMiddle<First, Second = boolean, Third = number, Fourth>() {}\n//                                                         // ~~~~~~\n// Error: Required type parameters may not follow optional type parameters.\n```", "```\ninterface WithLength {\n    length: number;\n}\n\nfunction logWithLength<T extends WithLength>(input: T) {\n    console.log(`Length: ${input.length}`);\n    return input;\n}\n\nlogWithLength(\"No one can figure out your worth but you.\"); // Type: string\nlogWithLength([false, true]); // Type: boolean[]\nlogWithLength({ length: 123 }); // Type: { length: number }\n\nlogWithLength(new Date());\n//            ~~~~~~~~~~\n// Error: Argument of type 'Date' is not\n// assignable to parameter of type 'WithLength'.\n//   Property 'length' is missing in type\n//   'Date' but required in type 'WithLength'.\n```", "```\nfunction get<T, Key extends keyof T>(container: T, key: Key) {\n    return container[key];\n}\n\nconst roles = {\n    favorite: \"Fargo\",\n    others: [\"Almost Famous\", \"Burn After Reading\", \"Nomadland\"],\n};\n\nconst favorite = get(roles, \"favorite\"); // Type: string\nconst others = get(roles, \"others\"); // Type: string[]\n\nconst missing = get(roles, \"extras\");\n//                         ~~~~~~~~\n// Error: Argument of type '\"extras\"' is not assignable\n// to parameter of type '\"favorite\" | \"others\"'.\n```", "```\nfunction get<T>(container: T, key: keyof T) {\n    return container[key];\n}\n\nconst roles = {\n    favorite: \"Fargo\",\n    others: [\"Almost Famous\", \"Burn After Reading\", \"Nomadland\"],\n};\n\nconst found = get(roles, \"favorite\"); // Type: string | string[]\n```", "```\nclass PromiseLike<Value> {\n    constructor(\n        executor: (\n            resolve: (value: Value) => void,\n            reject: (reason: unknown) => void,\n        ) => void,\n    ) { /* ... */ }\n}\n```", "```\n// Type: Promise<unknown>\nconst resolvesUnknown = new Promise((resolve) => {\n    setTimeout(() => resolve(\"Done!\"), 1000);\n});\n\n// Type: Promise<string>\nconst resolvesString = new Promise<string>((resolve) => {\n    setTimeout(() => resolve(\"Done!\"), 1000);\n});\n```", "```\n// Type: Promise<string>\nconst textEventually = new Promise<string>((resolve) => {\n    setTimeout(() => resolve(\"Done!\"), 1000);\n});\n\n// Type: Promise<number>\nconst lengthEventually = textEventually.then((text) => text.length)\n```", "```\n// Type: (text: string) => Promise<number>\nasync function lengthAfterSecond(text: string) {\n    await new Promise((resolve) => setTimeout(resolve, 1000))\n    return text.length;\n}\n\n// Type: (text: string) => Promise<number>\nasync function lengthImmediately(text: string) {\n    return text.length;\n}\n```", "```\n// Ok\nasync function givesPromiseForString(): Promise<string> {\n    return \"Done!\";\n}\n\nasync function givesString(): string {\n    //                        ~~~~~~\n    // Error: The return type of an async function\n    // or method must be the global Promise<T> type.\n    return \"Done!\";\n}\n```", "```\nfunction logInput<Input extends string>(input: Input) {\n    console.log(\"Hi!\", input);\n}\n```", "```\nfunction logInput(input: string) {\n    console.log(\"Hi!\", input);\n}\n```", "```\n// What on earth are L and V?!\nfunction labelBox<L, V>(l: L, v: V) { /* ... */ }\n```", "```\n// Much more clear.\nfunction labelBox<Label, Value>(label: Label, value: Value) { /* ... */ }\n```"]