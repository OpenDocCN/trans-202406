["```\ninterface BillingClient {\n    fun interface BillingCallback {\n        fun onInitDone(provider: PurchasesProvider?)\n    }\n\n    /* Implementations should be nonblocking */\n    fun init(callback: BillingCallback)\n}\n```", "```\ninterface PurchasesProvider {\n    fun interface PurchaseFetchCallback {\n        fun onPurchaseFetchDone(purchases: List<String>)\n    }\n\n    fun fetchPurchases(user: String, callback: PurchaseFetchCallback)\n}\n```", "```\nclass PurchasesViewModel internal constructor(\n    private val billingClient: BillingClient,\n    private val user: String\n) : ViewModel() {\n    private var _purchases = MutableLiveData<UserPurchases>()\n\n    private fun getUserPurchases(user: String) {\n        // TODO: implement\n    }\n\n    val purchasesLiveData: LiveData<UserPurchases>\n        get() {\n            getUserPurchases(user)\n            return _purchases\n        }\n\n    interface BillingClient { /* removed for brevity*/ }\n\n    interface PurchasesProvider { /* removed for brevity*/ }\n}\n```", "```\nclass PurchasesFragment : Fragment() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        /* Create a ViewModel the first time this Fragment is created.\n         * Re-created Fragment receives the same ViewModel instance after\n         * device rotation. */\n        val factory: ViewModelProvider.Factory = PurchaseViewModelFactory() ![1](assets/1.png)\n        val model by viewModels<PurchasesViewModel> { factory }             ![2](assets/2.png)\n        model.purchasesLiveData.observe(this) { (_, purchases) ->           ![3](assets/3.png)\n            // update UI\n            println(purchases)\n        }\n    }\n}\n```", "```\nclass PurchaseViewModelFactory : ViewModelProvider.Factory {\n    private val provider: PurchasesProvider = PurchasesProviderImpl()\n    private val billingClient: BillingClient = BillingClientImpl(provider)\n    private val user = \"user\" // Get in from registration service\n\n    override fun <T : ViewModel?> create(modelClass: Class<T>): T {\n        if (modelClass.isAssignableFrom(PurchasesViewModel::class.java)) {\n            return PurchasesViewModel(billingClient, user) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class\")\n    }\n}\n```", "```\nclass BillingClientImpl(private val purchasesProvider: PurchasesProvider) : BillingClient {\n    private val executor =\n        Executors.newSingleThreadExecutor()\n\n    override fun init(callback: BillingCallback) {\n        /* perform asynchronous work here */\n        executor.submit {\n            try {\n                Thread.sleep(1000)\n                callback.onInitDone(purchasesProvider)\n            } catch (e: InterruptedException) {\n                e.printStackTrace()\n            }\n        }\n    }\n}\n```", "```\nclass PurchasesProviderImpl : PurchasesProvider {\n    private val executor =\n        Executors.newSingleThreadExecutor()\n\n    override fun fetchPurchases(\n        user: String,\n        callback: PurchaseFetchCallback\n    ) {\n        /* perform asynchronous work */\n        executor.submit {\n            try {\n                // Simulate blocking IO\n                Thread.sleep(1000)\n                callback.onPurchaseFetchDone(\n                    listOf(\"Purchase1\", \"Purchase2\")\n                )\n            } catch (e: InterruptedException) {\n                e.printStackTrace()\n            }\n        }\n    }\n}\n```", "```\nprivate fun getUserPurchases(user: String) {\n   billingClient.init { provider ->                   ![1](assets/1.png)\n       // this is called from a background thread\n       provider?.fetchPurchases(user) { purchases ->  ![2](assets/2.png)\n           _purchases.postValue(UserPurchases(user, purchases))\n       }\n   }\n}\n```", "```\n_purchases.postValue(UserPurchases(user, purchases))\n```", "```\nprivate void getUserPurchases(String user) {\n    billingClient.initAsync()\n    .thenCompose { provider ->\n        fetchPurchasesAsync(provider, user)\n    }\n    .thenAccept { purchases ->\n        this.purchases.postValue(...)\n    }\n}\n```"]