- en: Chapter 20\. Filters, Blending, Clipping, and Masking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章。滤镜、混合、裁剪和遮罩
- en: 'Several special properties allow authors to alter the appearance of elements
    with visual filters, specify different ways to visually blend elements with whatever
    is behind them, and alter the presentation of elements by showing parts and hiding
    other parts. While these may seem like disparate concepts, they all share one
    thing in common: they allow elements to be altered in ways that were previously
    difficult or impossible.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 几个特殊属性允许作者通过视觉滤镜改变元素的外观，指定不同的方式将元素视觉混合到其后的内容中，并通过显示部分和隐藏其他部分来改变元素的呈现方式。虽然这些可能看起来是不同的概念，但它们都有一个共同点：它们允许以前难以或不可能的方式改变元素。
- en: CSS Filters
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSS 滤镜
- en: CSS provides a way to apply built-in visual filter effects, as well as custom
    filters defined in the page or in external files, to elements by way of the `filter`
    property.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 提供了一种通过 `filter` 属性对元素应用内置视觉滤镜效果以及在页面或外部文件中定义的自定义滤镜的方法。
- en: 'The value syntax permits a space-separated list of filter functions, with each
    filter applied in sequence. Thus, given the declaration `filter: opacity(0.5)
    blur(1px);`, the opacity is applied to the element, and the semitransparent result
    is then blurred. If the order is reversed, so too is the order of application:
    the fully opaque element is blurred, and the resulting blur made semitransparent.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '值语法允许空格分隔的滤镜函数列表，每个滤镜依次应用。因此，给定声明 `filter: opacity(0.5) blur(1px);`，透明度应用于元素，然后模糊这个半透明的结果。如果顺序颠倒，应用的顺序也会颠倒：完全不透明的元素被模糊，然后再使模糊后的结果变得半透明。'
- en: The CSS specification talks of “input images” when discussing `filter`, but
    this doesn’t mean `filter` is used only on images. Any HTML element can be filtered,
    and all graphic SVG elements can be filtered. The *input image* is a visual copy
    of the rendered element *before* it is filtered. Filters are applied to this input,
    and the final filtered result is then rendered to the display medium (e.g., the
    device display).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 规范在讨论 `filter` 时提到了“输入图像”，但这并不意味着 `filter` 只能用在图像上。任何 HTML 元素都可以被过滤，并且所有图形
    SVG 元素也可以被过滤。*输入图像* 是渲染元素被过滤*前*的视觉副本。过滤器应用于这个输入，最终过滤后的结果再渲染到显示介质（例如设备显示器）上。
- en: All the values permitted (save `url()`) are function values, with the permitted
    value types for each function being dependent on the function in question. We’ve
    grouped these functions into a few broad categories for ease of understanding.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的所有值（除了 `url()`）都是函数值，每个函数的允许值类型取决于具体的函数。为了便于理解，我们将这些函数分成了几个广泛的类别。
- en: Basic Filters
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本滤镜
- en: 'The following filters are basic in the sense that they cause the changes that
    their names directly describe—blurring, drop shadows, and opacity changes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下滤镜在直接描述它们名称变化的意义上是基本的：模糊、投影阴影和透明度变化：
- en: '`blur(` <*`length`*> `)`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`blur(` <*`length`*> `)`'
- en: Blurs the element’s contents by using a Gaussian blur whose standard deviation
    is defined by the <*`length`*> value supplied, where a value of `0` leaves the
    element unchanged. Negative lengths are not permitted.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用由提供的 <*`length`*> 值定义的高斯模糊来模糊元素的内容，其中值为 `0` 保持元素不变。不允许负值长度。
- en: '`opacity(` [ <*`number`*> | <*`percentage`*> ] `)`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`opacity(` [ <*`number`*> | <*`percentage`*> ] `)`'
- en: Applies a transparency filter to the element in a manner very similar to the
    `opacity` property, where the value `0` yields a completely transparent element
    and a value of `1` or `100%` leaves the element unchanged. Negative values are
    not permitted. Values greater than `1` and `100%` are permitted, but are clipped
    to be `1` or `100%` for the purposes of computing the final value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种非常类似于 `opacity` 属性的方式，向元素应用透明度滤镜，其中值 `0` 会使元素完全透明，值为 `1` 或 `100%` 保持元素不变。不允许负值。允许大于
    `1` 和 `100%` 的值，但在计算最终值时会被剪切为 `1` 或 `100%`。
- en: Warning
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The specification makes clear that `filter: opacity()` is *not* meant to be
    a replacement or shorthand for the `opacity` property, and in fact both can be
    applied to the same element, resulting in a sort of double-transparency.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '规范明确指出 `filter: opacity()` *不* 是 `opacity` 属性的替代或简写，事实上两者都可以应用于同一元素，从而导致一种双重透明效果。'
- en: '`drop-shadow(` <*`length`*>{2,3} <*`color`*>? `)`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`drop-shadow(` <*`length`*>{2,3} <*`color`*>? `)`'
- en: Creates a drop shadow that matches the shape of the element’s alpha channel,
    with a blur and using an optional color. The handling of the lengths and colors
    is the same as for the property `box-shadow`, which means that while the first
    two <*`length`*> values can be negative, the third (which defines the blur) cannot.
    Unlike box-shadow, though, the `inset` value is not permitted. To apply multiple
    drop shadows, provide multiple space-separated `drop-shadow()` functions; unlike
    `box-shadow`, comma-separated shadows don’t work here. If no <*`color`*> value
    is supplied, the used color is the same as the computed value of the `color` property
    for the element.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个与元素的 alpha 通道形状匹配的模糊阴影，并使用可选颜色。长度和颜色的处理与 `box-shadow` 属性相同，这意味着前两个 <*`length`*>
    值可以是负值，但第三个（定义模糊度）不能是负值。不过与 `box-shadow` 不同的是，这里不允许 `inset` 值。要应用多个阴影，提供多个以空格分隔的
    `drop-shadow()` 函数；不像 `box-shadow`，逗号分隔的阴影在这里不起作用。如果没有提供 <*`color`*> 值，则使用的颜色与元素的
    `color` 属性的计算值相同。
- en: '[Figure 20-1](#filter-basic-effects) shows some effects of these filter functions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-1](#filter-basic-effects) 展示了这些 filter 函数的一些效果。'
- en: '![css5 2001](assets/css5_2001.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2001](assets/css5_2001.png)'
- en: Figure 20-1\. Basic filter effects
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-1\. 基本滤镜效果
- en: Before we go on, two things deserve further exploration. The first is how `drop-shadow()`
    really operates. Just by looking at [Figure 20-1](#filter-basic-effects), it’s
    easy to get the impression that drop shadows are bound to the element box, because
    of the boxlike nature of the drop shadows shown there. But that’s just because
    the image used to illustrate filters is a PNG, which is to say a raster image,
    and more importantly one that doesn’t have any alpha channel. The white parts
    of the image are opaque white, in other words.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有两件事值得进一步探讨。首先是 `drop-shadow()` 的实际操作方式。仅仅通过查看[图 20-1](#filter-basic-effects)，很容易得出
    `drop-shadow` 是与元素框绑定的结论，因为所示的阴影具有盒状的特性。但这只是因为用来说明滤镜的图像是一个 PNG 图像，也就是一种光栅图像，更重要的是这种图像没有任何
    alpha 通道。图像的白色部分是不透明的白色，换句话说。
- en: If the image has transparent bits, `drop-shadow()` will use those in computing
    the shadow. To see what this means, consider [Figure 20-2](#filter-basic-effects-dropshadows).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像具有透明部分，`drop-shadow()` 将使用这些部分来计算阴影。要了解这意味着什么，请考虑[图 20-2](#filter-basic-effects-dropshadows)。
- en: '![css5 2002](assets/css5_2002.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2002](assets/css5_2002.png)'
- en: Figure 20-2\. Drop shadows and alpha channels
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-2\. 阴影和 alpha 通道
- en: 'The other thing to point out in [Figure 20-2](#filter-basic-effects-dropshadows)
    is the last image has two drop shadows. This was accomplished as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点要指出在[图 20-2](#filter-basic-effects-dropshadows)中，最后一张图片有两个阴影。这是通过以下方式完成的：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Any number of filters can be chained together like this. To pick another example,
    you could write the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像这样链接任意数量的过滤器。举个例子，你可以写如下内容：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That would get you a blurry, drop-shadowed, half-opaque element. It might not
    be the most reader-friendly effect for text, but it’s possible nonetheless. This
    function-chaining is possible with all `filter` functions, both those you’ve seen
    and those to come.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使您得到一个模糊的、带阴影的、半透明的元素。对于文本来说，这可能不是最友好的效果，但它仍然是可能的。所有 `filter` 函数都支持此类函数链接。
- en: Color Filtering
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色过滤
- en: This next set of `filter` functions alter the colors present in the element.
    This can be as simple as leaching out the colors, or as complex as shifting all
    the colors by way of an angle value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这组 `filter` 函数会改变元素中的颜色。这可以简单到淡化颜色，也可以复杂到通过角度值移动所有颜色。
- en: 'Note that for the first three of the four following functions, all of which
    accept either a <*`number`*> or <*`percentage`*>, negative values are not permitted;
    the fourth permits positive and negative angle values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于接受 <*`number`*> 或 <*`percentage`*> 的以下四个函数中的前三个函数，不允许负值；第四个允许正负角度值：
- en: '`grayscale(` [ <*`number`*> | <*`percentage`*> ] `)`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`grayscale(` [ <*`number`*> | <*`percentage`*> ] `)`'
- en: Alters the colors in the element to be shifted toward shades of gray. A value
    of `0` leaves the element unchanged, and a value of `1` or `100%` will result
    in black and white, as a fully grayscale element.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素中的颜色调整为朝向灰度阴影。值为 `0` 保持元素不变，值为 `1` 或 `100%` 将结果显示为黑白，即完全灰度元素。
- en: '`sepia(` [ <*`number`*> | <*`percentage`*> ] `)`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`sepia(` [ <*`number`*> | <*`percentage`*> ] `)`'
- en: Alters the colors in the element to be shifted toward shades of sepia tones
    (sepia is the reddish-brown color used in antique photography, defined by Wikipedia
    to be equivalent to `#704214` or `rgba(112,66,20)` in the sRGB color space). A
    value of `0` leaves the element unchanged, and a value of `1` or `100%` will result
    in a fully sepia element.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 改变元素中的颜色，使其向赭色调的色调移动（赭色是古老摄影中使用的红棕色，由维基百科定义为在sRGB颜色空间中等于`#704214`或`rgba(112,66,20)`）。值为`0`保持元素不变，值为`1`或`100%`将导致完全赭色的元素。
- en: '`invert(` [ <*`number`*> | <*`percentage`*> ] `)`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`invert(` [ <*`数字`*> | <*`百分比`*> ] `)`'
- en: Inverts all colors in the element. Each of the R, G, and B values for a given
    color are inverted by subtracting them from 255 (in 0–255 notation) or from 100%
    (in 0%–100% notation). For example, a pixel with the color `rgb(255 128 55)` will
    be rendered as `rgb(0 127 200)`; a different pixel with the value `rgb(75% 57.2%
    23%)` will become `rgb(25% 42.8% 77%)`. A value of `0` leaves the element unchanged,
    and a value of `1` or `100%` results in a fully inverted element. A value of `0.5`
    or `50%` stops the inversion of each color at the midpoint of the color space,
    leading to an element of uniform gray regardless of the input element’s appearance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 反转元素中的所有颜色。给定颜色的每个R、G和B值都通过从255（在0-255表示法中）或从100%（在0%-100%表示法中）中减去它们来进行反转。例如，具有颜色`rgb(255
    128 55)`的像素将呈现为`rgb(0 127 200)`；具有值为`rgb(75% 57.2% 23%)`的不同像素将变为`rgb(25% 42.8%
    77%)`。值为`0`保持元素不变，值为`1`或`100%`会导致完全反转的元素。值为`0.5`或`50%`将使每种颜色在颜色空间的中点停止反转，从而导致一个统一灰色的元素，而不考虑输入元素的外观。
- en: '`hue-rotate(` <*`angle`*> `)`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`hue-rotate(` <*`角度`*> `)`'
- en: Alters the colors of the image by shifting their hue angle around an HSL color
    wheel, leaving saturation and lightness unchanged. A value of `0deg` means no
    difference between the input and output images. A value of `360deg` (a full single
    rotation) will also present an apparently unchanged element, though the rotation-angle
    value is maintained. Values above `360deg` are permitted. Negative values are
    also permitted, and cause a counterclockwise rotation as opposed to the clockwise
    rotation caused by positive values. (In other words, the rotation is “compass-style,”
    with 0° at the top and increasing angle values in the clockwise direction.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在HSL色轮上围绕色相角度改变图像的颜色，保持饱和度和亮度不变。值为`0deg`意味着输入和输出图像之间没有差异。值为`360deg`（完整的单次旋转）也将呈现看似未改变的元素，尽管旋转角度值被保留。允许使用大于`360deg`的值。也允许负值，负值导致逆时针旋转，而不是正值导致的顺时针旋转（换句话说，旋转是“罗盘式”的，0°在顶部，顺时针方向的角度值递增）。
- en: Examples of the preceding `filter` functions are shown in [Figure 20-3](#filter-color-effects),
    though fully appreciating them depends on a color rendering.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前述`filter`函数的示例显示在[图20-3](#filter-color-effects)，尽管充分理解它们取决于颜色渲染。
- en: '![css5 2003](assets/css5_2003.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2003](assets/css5_2003.png)'
- en: Figure 20-3\. Color filter effects
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-3\. 颜色滤镜效果
- en: Brightness, Contrast, and Saturation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亮度、对比度和饱和度
- en: 'While the following `filter` functions also manipulate color, they do so in
    closely related ways, and are a familiar grouping to anyone who’s worked with
    images, particularly photographic images. For all these functions, values greater
    than `1` and `100%` are permitted, but are clipped to be `1` or `100%` for the
    purposes of computing the final value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下`filter`函数也操纵颜色，但它们以密切相关的方式执行此操作，并且对于那些曾处理过图像，特别是摄影图像的人来说，这些函数是熟悉的组合。对于所有这些函数，允许的值大于`1`和`100%`，但在计算最终值时会被剪切为`1`或`100%`：
- en: '`brightness(` [ <*`number`*> | <*`percentage`*> ] `)`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`brightness(` [ <*`数字`*> | <*`百分比`*> ] `)`'
- en: Alters the brightness of the element’s colors. A value of `0` leaves the element
    a solid black, and a value of `1` or `100%` leaves it unchanged. Values above
    `1` and `100%` yield colors brighter than the input element, and can eventually
    reach a state of solid white.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 改变元素颜色的亮度。值为`0`使元素呈现纯黑色，值为`1`或`100%`使其保持不变。大于`1`和`100%`的值产生比输入元素更亮的颜色，并最终可能达到纯白色状态。
- en: '`contrast(` [ <*`number`*> | <*`percentage`*> ] `)`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`contrast(` [ <*`数字`*> | <*`百分比`*> ] `)`'
- en: Alters the contrast of the element’s colors. The higher the contrast, the more
    colors are differentiated from each other; the lower the contrast, the more they
    converge on each other. A value of `0` leaves the element a solid gray, and a
    value of `1` or `100%` leaves it unchanged. Values above `1` and `100%` yield
    colors with greater contrast than is present in the input element.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 改变元素颜色的对比度。对比度越高，颜色之间的区别越大；对比度越低，颜色越接近。值为`0`会使元素呈现为纯灰色，值为`1`或`100%`则保持不变。大于`1`和`100%`的值会产生比输入元素更高对比度的颜色。
- en: '`saturate(` [ <*`number`*> | <*`percentage`*> ] `)`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`saturate(` [ <*`number`*> | <*`percentage`*> ] `)`'
- en: Alters the saturation of the element’s colors. The more saturated an element’s
    colors, the more intense they become; the less saturated they are, the more muted
    they appear. A value of `0` leaves the element completely unsaturated, making
    it effectively grayscale, whereas a value of `1` or `100%` leaves the element
    unchanged. Similar to `brightness()`, `saturate()` permits *and* acts upon values
    greater than `1` or `100%`; such values result in *supersaturation*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 改变元素颜色的饱和度。颜色的饱和度越高，颜色变得越强烈；饱和度越低，颜色变得越柔和。值为`0`会使元素完全不饱和，实际上呈现为灰度图像；而值为`1`或`100%`则保持不变。类似于`brightness()`，`saturate()`允许并作用于大于`1`或`100%`的值；这些值会导致*超饱和*的效果。
- en: Examples of the preceding `filter` functions are shown in [Figure 20-4](#filter-bcs-effects),
    though fully appreciating them depends on a color rendering. Also, the effects
    of greater-than-one values may be hard to make out in the figure, but they are
    present.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了前述`filter`函数的示例，详细理解这些函数取决于颜色渲染。大于一的值的效果在图中可能难以辨认，但它们确实存在。
- en: '![css5 2004](assets/css5_2004.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2004](assets/css5_2004.png)'
- en: Figure 20-4\. Brightness, contrast, and saturation filter effects
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-4\. 亮度、对比度和饱和度滤镜效果
- en: SVG Filters
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SVG滤镜
- en: 'The last `filter` value type is a function of a familiar kind: the `url()`
    value type. This allows you to point to a (potentially very complicated) filter
    defined in SVG, whether it’s embedded in the document or stored in an external
    file.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种`filter`值类型是熟悉类型的函数：`url()`值类型。这允许您指向SVG中定义的（可能非常复杂的）滤镜，无论它是嵌入在文档中还是存储在外部文件中。
- en: This takes the form `url(<*uri*>)`, where the <*`uri`*> value points to a filter
    defined using SVG syntax, specifically the `<filter>` element. This can be a reference
    to a single SVG image that contains only a filter, such as `url(wavy.svg)`, or
    it can be a pointer to an identified filter embedded in an SVG image, such as
    `url(filters.svg#wavy)`. The advantage of the latter pattern is that a single
    SVG file can define multiple filters, thus consolidating all your filtering into
    one file for easy loading, caching, and referencing.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为`url(<*uri*>)`，其中<*`uri`*>指向使用SVG语法定义的滤镜，特别是`<filter>`元素。这可以是指向仅包含滤镜的单个SVG图像的引用，如`url(wavy.svg)`，或者是指向SVG图像中标识滤镜的引用，如`url(filters.svg#wavy)`。后一种模式的优点是单个SVG文件可以定义多个滤镜，从而将所有滤镜整合到一个文件中，方便加载、缓存和引用。
- en: If a `url()` function points to a nonexistent file, or points to an SVG fragment
    that is not a `<filter>` element, the function is invalid and the *entire* function
    list is ignored (thus rendering the `filter` declaration invalid).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`url()`函数指向不存在的文件，或者指向非`<filter>`元素的SVG片段，则该函数无效，*整个*函数列表将被忽略（因此`filter`声明无效）。
- en: 'Examining the full range of filtering possibilities in SVG is well beyond the
    scope of this book, but let’s just say that the power of the offered features
    is substantial. A few simple examples of SVG filtering are shown in [Figure 20-5](#filter-svg-effects),
    with brief captions to indicate the kinds of operations the filters were built
    to create. (The actual CSS used to apply these filters looks like `filter: url(filters.svg#rough)`.)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '在SVG中检查所有滤镜可能性远超出本书的范围，但我们可以简单说一下提供的功能非常强大。在图20-5中展示了几个简单的SVG滤镜示例，简要说明了这些滤镜被设计用来创建的操作类型（应用这些滤镜的实际CSS看起来像`filter:
    url(filters.svg#rough)`）。'
- en: '![css5 2005](assets/css5_2005.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2005](assets/css5_2005.png)'
- en: Figure 20-5\. SVG filter effects
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-5\. SVG滤镜效果
- en: 'It’s easily possible to put every last bit of filtering you do into SVG, including
    replacements for every other `filter` function you’ve seen. (In fact, all the
    other `filter` functions are defined by the specification as literal SVG filters,
    to give a precise rendering target for implementors.) Remember, however, that
    you can chain CSS functions together. Thus, you might define a specular-highlight
    filter in SVG, and modify it with blurring or grayscale functions as needed. For
    example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以将您进行的所有过滤工作放入SVG中，包括您看到的其他`filter`函数的替换。 （事实上，所有其他`filter`函数在规范中被定义为文字SVG过滤器，以为实现者提供精确的渲染目标。）然而，请记住，您可以将CSS函数链接在一起。
    因此，您可以在SVG中定义一个镜面高亮过滤器，并根据需要进行模糊处理或灰度处理。 例如：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Always keep in mind that the filter functions are applied in order. That’s why
    the `grayscale()` and `blur()` functions come after the `url()`-imported spotlight
    filter. If they were reversed, the logos would be made grayscale or blurred first,
    and then have the spotlight filter applied afterward.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请始终记住，过滤函数是按顺序应用的。 这就是为什么`grayscale()`和`blur()`函数在`url()`导入的聚光灯过滤器之后使用。 如果反过来，徽标首先变为灰度或模糊，然后再应用聚光灯过滤器。
- en: Compositing and Blending
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合成和混合
- en: In addition to filtering, CSS enables you to determine how elements are *composited*
    together. Take, for example, two elements that partially overlap because of positioning.
    By default, the element in front, if fully opaque, completely obscures the one
    behind, wherever they overlap. If the one in front is semitransparent, the element
    in back is partially visible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了过滤外，CSS还可以确定如何将元素*合成*在一起。例如，由于定位而部分重叠的两个元素。默认情况下，完全不透明的前置元素会完全遮挡其后的元素在重叠处。如果前置元素是半透明的，则后置元素部分可见。
- en: 'This is sometimes called *simple alpha compositing*, in that you can see whatever
    is behind an element as long as some (or all) of it has alpha channel values less
    than `1`. Think of how you can see the background through an element with `opacity:
    0.5`, or in the areas of a PNG or GIF that are set to be transparent. That’s simple
    alpha compositing.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '有时这被称为*简单的α合成*，因为只要某些（或全部）元素具有小于`1`的α通道值，您就可以看到元素背后的内容。 想象一下，通过`opacity: 0.5`可以看到背景，或者PNG或GIF中设置为透明的区域。
    这就是简单的α合成。'
- en: 'But if you’re familiar with image-editing programs like Photoshop or GIMP,
    you know that overlapping image layers can be blended together in a variety of
    ways. CSS has the same ability. CSS has two blending strategies (at least as of
    late 2022): blending entire elements with whatever is behind them, and blending
    the background layers of a single element together. While similar to filter effects
    in many ways, blending mode values are predefined—they don’t accept a parameter—and
    while both filter effects and blend modes support multiple values, the properties
    that support blend modes use a comma-separated list of values instead of a space-separated
    list. (This inconsistency in value syntaxes is rooted deep in the history of CSS,
    and is something we just have to live with for the time being.)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您熟悉像Photoshop或GIMP这样的图像编辑程序，您就会知道重叠的图像层可以以多种方式混合在一起。 CSS也具有相同的能力。 CSS具有两种混合策略（至少在2022年末是这样）：将整个元素与其背后的内容混合在一起，以及混合单个元素的背景层。
    尽管在许多方面类似于过滤效果，但混合模式的值是预定义的 - 它们不接受参数 - 而支持混合模式的属性支持多个值，这些属性使用逗号分隔的值列表而不是空格分隔的值列表。
    （这种值语法的不一致性深植于CSS的历史中，目前我们只能接受这种情况。）
- en: Blending Elements
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合元素
- en: If elements overlap, you can change the way they blend together by using the
    `mix-blend-mode` property.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素重叠，可以通过使用`mix-blend-mode`属性改变它们混合在一起的方式。
- en: The CSS specification indicates that this property “defines the formula that
    must be used to mix the colors with the backdrop.” The element is blended with
    whatever is behind it (the “backdrop”), whether that’s pieces of another element,
    or just the background of an ancestor element such as the `<body>`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CSS规范指出，此属性“定义了必须使用的公式来将颜色与背景混合在一起”。 元素与其背后的任何东西（“背景”）混合在一起，无论是另一个元素的片段还是诸如`<body>`之类的祖先元素的背景。
- en: The default value, `normal`, shows the element’s pixels as is, without any mixing
    with the backdrop, except where the alpha channel is less than `1`. This is the
    simple alpha compositing mentioned previously. It’s what we’re all used to, which
    is why it’s the default value. [Figure 20-6](#blending-elements-normal) shows
    a few examples.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值 `normal` 将元素的像素显示为原样，与背景没有任何混合，除非 alpha 通道小于 `1`。这是前面提到的简单 alpha 合成。这是我们所习惯的，也是默认值的原因。[图 20-6](#blending-elements-normal)
    展示了一些示例。
- en: '![css5 2006](assets/css5_2006.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2006](assets/css5_2006.png)'
- en: Figure 20-6\. Simple alpha-channel blending
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-6\. 简单的 alpha 通道混合
- en: 'For the rest of the `mix-blend-mode` keywords, we’ve grouped them into a few
    categories. Let’s also nail down a few definitions we’ll be using in the blend
    mode descriptions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的 `mix-blend-mode` 关键字，我们将它们分成几类。让我们还确定一下在混合模式描述中将要使用的一些定义：
- en: Foreground
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前景
- en: The element that has `mix-blend-mode` applied to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 `mix-blend-mode` 的元素。
- en: Backdrop
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 背景
- en: Whatever is behind an element. This can be other elements, the background of
    an ancestor element, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元素的背景。这可以是其他元素、祖先元素的背景等。
- en: Pixel component
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 像素分量
- en: 'The color component of a given pixel: R, G, and B.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 给定像素的颜色分量：R、G 和 B。
- en: If it helps, think of the foreground and backdrop as layers atop each other
    in an image-editing program. With `mix-blend-mode`, you can change the blend mode
    applied to the top element (the foreground).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有帮助的话，可以将前景和背景视为图像编辑程序中彼此叠加的图层。使用 `mix-blend-mode`，您可以更改应用于顶部元素（前景）的混合模式。
- en: Darken, lighten, difference, and exclusion
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Darken、lighten、difference 和 exclusion
- en: 'The following blend modes might be called *simple-math modes*—they achieve
    their effect by directly comparing values in some way, or using simple addition
    and subtraction to modify pixels:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的混合模式可能被称为*简单数学模式*，它们通过直接比较值的方式或使用简单的加减来修改像素来实现其效果：
- en: '`darken`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`darken`'
- en: Each pixel in the foreground is compared with the corresponding pixel in the
    backdrop, and for each of the R, G, and B values (the pixel components), the smaller
    of the two is kept. Thus, if the foreground pixel has a value corresponding to
    `rgb(91 164 22)` and the backdrop pixel is `rgb(102 104 255)`, the resulting pixel
    will be `rgb(91 104 22)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前景中的每个像素与背景中对应的像素进行比较，对于 R、G 和 B 值（像素分量），保留两者中较小的值。因此，如果前景像素的值对应 `rgb(91 164
    22)`，背景像素是 `rgb(102 104 255)`，则生成的像素将是 `rgb(91 104 22)`。
- en: '`lighten`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`lighten`'
- en: 'This blend is the inverse of `darken`: when comparing the R, G, and B components
    of a foreground pixel and its corresponding backdrop pixel, the larger of the
    two values is kept. Thus, if the foreground pixel has a value corresponding to
    `rgb(91 164 22)` and the backdrop pixel is `rgb(102 104 255)`, the resulting pixel
    will be `rgb(102 164 255)`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合是 `darken` 的反转：比较前景像素及其对应背景像素的 R、G 和 B 组件时，保留两者中较大的值。因此，如果前景像素的值对应 `rgb(91
    164 22)`，背景像素是 `rgb(102 104 255)`，则生成的像素将是 `rgb(102 164 255)`。
- en: '`difference`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference`'
- en: The R, G, and B components of each pixel in the foreground are compared to the
    corresponding pixel in the backdrop, and the absolute value of subtracting one
    from the other is the final result. Thus, if the foreground pixel has a value
    corresponding to `rgb(91 164 22)` and the backdrop pixel is `rgb(102 104 255)`,
    the resulting pixel will be `rgb(11 60 233)`. If one of the pixels is white, the
    resulting pixel will be the inverse of the nonwhite pixel. If one of the pixels
    is black, the result will be exactly the same as the nonblack pixel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前景中每个像素的 R、G 和 B 分量与背景中对应像素进行比较，它们之间相减的绝对值是最终结果。因此，如果前景像素的值对应 `rgb(91 164 22)`，背景像素是
    `rgb(102 104 255)`，则生成的像素将是 `rgb(11 60 233)`。如果其中一个像素是白色，生成的像素将是非白色像素的反色。如果其中一个像素是黑色，则结果将与非黑色像素完全相同。
- en: '`exclusion`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`exclusion`'
- en: This blend is a milder version of `difference`. Rather than *| back* – *fore*,
    the formula is *back* + *fore* – (2 × *back* × *fore*), where *back* and *fore*
    are values in the range 0 to 1\. For example, an exclusion calculation of an orange
    (`rgb(100% 50% 0%)`) and a medium gray (`rgb(50% 50% 50%)`) will yield `rgb(50%
    50% 50%)`. For the green component, as an example, the math is 0.5 + 0.5 – (2
    × 0.5 × 0.5), which reduces to 0.5, corresponding to `50%`. Compare this to `difference`,
    where the result would be `rgb(50% 0% 50%)`, since each component is the absolute
    value of subtracting one from the other.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合是`difference`的一个较温和版本。而不是*| 背景* – *前景*，公式是 *背景* + *前景* – (2 × *背景* × *前景*)，其中*背景*和*前景*的值在
    0 到 1 的范围内。例如，橙色 (`rgb(100% 50% 0%)`) 和中灰色 (`rgb(50% 50% 50%)`) 的排除计算将得到 `rgb(50%
    50% 50%)`。例如，绿色分量的计算为 0.5 + 0.5 – (2 × 0.5 × 0.5)，结果为 0.5，对应 `50%`。与`difference`相比，其结果为
    `rgb(50% 0% 50%)`，因为每个分量是相减后的绝对值。
- en: 'This last definition highlights that, for all blend modes, the actual values
    being operated on are in the range 0–1\. The previous examples showing values
    like `rgb(11 60 233)` are normalized from the 0–1 range. In other words, given
    the example of applying the `difference` blend mode to `rgb(91 164 22)` and `rgb(102
    104 255)`, the actual operation is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后的定义强调，对于所有混合模式，实际操作的值都在 0 到 1 的范围内。前面展示的 `rgb(11 60 233)` 等值是从 0 到 1 范围归一化的。换句话说，以应用`difference`混合模式到
    `rgb(91 164 22)` 和 `rgb(102 104 255)` 为例，实际操作如下：
- en: '`rgb(91 164 22)` is *R* = 91 ÷ 255 = 0.357; *G* = 164 ÷ 255 = 0.643; *B* =
    22 ÷ 255 = 0.086\. Similarly, `rgb(102 104 255)` corresponds to *R* = 0.4; *G*
    = 0.408; *B* = 1.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rgb(91 164 22)` 的 *R* = 91 ÷ 255 = 0.357；*G* = 164 ÷ 255 = 0.643；*B* = 22
    ÷ 255 = 0.086。类似地，`rgb(102 104 255)` 对应于 *R* = 0.4；*G* = 0.408；*B* = 1。'
- en: Each component is subtracted from the corresponding component, and the absolute
    value taken. Thus, *R* = | 0.357 – 0.4 | = 0.043; *G* = | 0.643 – 0.408 | = 0.235;
    *B* = | 1 – 0.086 | = 0.914\. This could be expressed as `rgba(4.3% 23.5% 91.4%)`,
    or (by multiplying each component by 255) as `rgb(11 60 233)`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个分量从对应的分量中减去，并取绝对值。因此，*R* = | 0.357 – 0.4 | = 0.043；*G* = | 0.643 – 0.408 |
    = 0.235；*B* = | 1 – 0.086 | = 0.914。这可以表示为 `rgba(4.3% 23.5% 91.4%)`，或者（通过将每个分量乘以
    255）为 `rgb(11 60 233)`。
- en: From all this, you can perhaps understand why the full formulas are not written
    out for every blend mode we cover. If you’re interested in the fine details, each
    blend mode’s formula is provided in the [“Compositing and Blending Level 2”](https://drafts.fxtf.org/compositing/#blendingseparable)
    specification.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，你可能理解为何我们不会为每种混合模式详细列出完整的公式。如果你对细节感兴趣，每种混合模式的公式都在[“合成和混合级别 2”](https://drafts.fxtf.org/compositing/#blendingseparable)规范中提供。
- en: '[Figure 20-7](#blending-elements-dark-light-diff-excl) depicts examples of
    the blend modes in this section.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-7](#blending-elements-dark-light-diff-excl) 展示了本节中混合模式的示例。'
- en: '![css5 2007](assets/css5_2007.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2007](assets/css5_2007.png)'
- en: Figure 20-7\. Darken, lighten, difference, and exclusion blending with `mix-blend-mode:`
    applied to the foreground image
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-7。使用 `mix-blend-mode:` 应用于前景图像的暗化、亮化、差异和排除混合
- en: Multiply, screen, and overlay
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Multiply、screen 和 overlay
- en: 'The following blend modes might be called the *multiplication modes*—they achieve
    their effect by multiplying values together:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下列混合模式可能被称为*乘法模式*——它们通过将值相乘来实现其效果：
- en: '`multiply`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiply`'
- en: Each pixel component in the foreground is multiplied by the corresponding pixel
    component in the backdrop. This yields a darker version of the foreground, modified
    by what is underneath. This blend mode is *symmetric*, in that the result will
    be exactly the same even if you were to swap the foreground with the backdrop.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前景中的每个像素分量与背景中的对应像素分量相乘。这会产生前景的较暗版本，通过底下的内容进行修改。这种混合模式是*对称的*，即结果即使将前景与背景互换也会完全相同。
- en: '`screen`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`screen`'
- en: Each pixel component in the foreground is inverted (see `invert` in [“Color
    Filtering”](#csstdg4-color-filtering)), multiplied by the inverse of the corresponding
    pixel component in the backdrop, and the result inverted again. This yields a
    lighter version of the foreground, modified by what is underneath. Like `multiply`,
    `screen` is symmetric.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前景中的每个像素分量被反转（见[“颜色过滤”](#csstdg4-color-filtering)中的`invert`），乘以背景中对应像素分量的倒数，然后再次反转。这会产生前景的较轻版本，通过底下的内容进行修改。像`multiply`一样，`screen`是对称的。
- en: '`overlay`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`overlay`'
- en: This blend is a combination of `multiply` and `screen`. For foreground pixel
    components darker than 0.5 (50%), the `multiply` operation is carried out; for
    foreground pixel components whose values are above 0.5, `screen` is used. This
    makes the dark areas darker, and the light areas lighter. This blend mode is *not*
    symmetric, because swapping the foreground for the backdrop would mean a different
    pattern of light and dark, and thus a different pattern of multiplying versus
    screening.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合是`multiply`和`screen`的结合体。对于比0.5（50%）更暗的前景像素组件，执行`multiply`操作；对于值高于0.5的前景像素组件，使用`screen`。这使得暗区更暗，亮区更亮。这种混合模式*不*对称，因为交换前景和背景会产生不同的光和暗的模式，进而产生不同的multiply和screen模式。
- en: '[Figure 20-8](#blending-elements-multiply-screen-overlay) depicts examples
    of these blend modes.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-8](#blending-elements-multiply-screen-overlay) 描述了这些混合模式的示例。'
- en: '![css5 2008](assets/css5_2008.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2008](assets/css5_2008.png)'
- en: Figure 20-8\. Images with `mix-blend-mode` property set showing multiply, screen,
    and overlay blending
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-8\. 使用`mix-blend-mode`属性显示multiply、screen和overlay混合的图像
- en: Hard and soft light
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬光和软光
- en: 'The following blend modes are covered here because the first is closely related
    to a previous blend mode, and the other is just a muted version of the first:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍以下混合模式，因为第一个与之前的混合模式密切相关，而第二个只是第一个的柔和版本：
- en: '`hard-light`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`hard-light`'
- en: This blend is the inverse of `overlay` blending. Like `overlay`, it’s a combination
    of `multiply` and `screen`, but the determining layer is the backdrop. Thus, for
    backdrop pixel components darker than 0.5 (50%), the `multiply` operation is carried
    out; for backdrop pixel components lighter than 0.5, `screen` is used. This makes
    it appear somewhat as if the foreground is being projected onto the backdrop with
    a projector that employs a harsh light.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合是`overlay`混合的反转。像`overlay`一样，它是`multiply`和`screen`的结合，但决定层是背景。因此，对于背景像素组件低于0.5（50%）的部分，执行`multiply`操作；对于背景像素组件高于0.5的部分，使用`screen`。这使得前景看起来像是被一个使用强烈光线的投影仪投射到背景上。
- en: '`soft-light`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`soft-light`'
- en: This blend is a softer version of `hard-light`. This mode uses the same operation
    but is muted in its effects. The intended appearance is as if the foreground is
    being projected onto the backdrop with a projector that employs a diffuse light.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合是`hard-light`的柔和版本。此模式使用相同的操作，但效果更柔和。其预期外观是，前景像是被一个使用散射光的投影仪投射到背景上。
- en: '[Figure 20-9](#blending-elements-hard-soft-light) depicts examples of these
    blend modes.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-9](#blending-elements-hard-soft-light) 描述了这些混合模式的示例。'
- en: '![css5 2009](assets/css5_2009.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2009](assets/css5_2009.png)'
- en: Figure 20-9\. Hard- and soft-light blending
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-9\. 硬光和软光混合
- en: Color dodge and burn
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色减淡和加深
- en: 'Color dodging and burning—terms that come from old darkroom techniques performed
    on chemical film stock—are meant to lighten or darken a picture with a minimum
    of change to the colors themselves. These modes are as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色减淡和加深——这些术语来自于旧的在化学胶片上进行的暗房技术，用于尽可能少地改变颜色本身来调整图片的明暗。这些模式包括：
- en: '`color-dodge`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`color-dodge`'
- en: Each pixel component in the foreground is inverted, and the component of the
    corresponding backdrop pixel component is divided by the inverted foreground value.
    This yields a brightened backdrop unless the foreground value is `0`, in which
    case the backdrop value is unchanged.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前景中的每个像素组件都被反转，相应背景像素组件的值被反转的前景值除以。这会使得背景明亮，除非前景值为`0`，此时背景值保持不变。
- en: '`color-burn`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`color-burn`'
- en: 'This blend is a reverse of `color-dodge`: each pixel component in the backdrop
    is inverted, the inverted backdrop value is divided by the unchanged value of
    the corresponding foreground pixel component, and the result is then inverted.
    This yields a result where the darker the backdrop pixel, the more its color will
    burn through the foreground pixel.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种混合是`color-dodge`的反转：背景中的每个像素组件都被反转，反转后的背景值被对应前景像素组件的不变值除以，然后结果再反转。这会导致背景像素越暗，其颜色就越能穿透前景像素。
- en: '[Figure 20-10](#blending-elements-color-dodge-burn) depicts examples of these
    blend modes.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-10](#blending-elements-color-dodge-burn) 描述了这些混合模式的示例。'
- en: '![css5 2010](assets/css5_2010.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2010](assets/css5_2010.png)'
- en: 'Figure 20-10\. Blending with `mix-blend-mode: color-dodge` and `mix-blend-mode:
    color-burn`'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图 20-10\. 使用`mix-blend-mode: color-dodge` 和 `mix-blend-mode: color-burn` 进行混合'
- en: Hue, saturation, luminosity, and color
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 色相、饱和度、亮度和颜色
- en: 'The final four blend modes are different from those we’ve shown before, because
    they do *not* perform operations on the R/G/B pixel components. Instead, they
    perform operations to combine the hue, saturation, luminosity, and color of the
    foreground and backdrop in different ways. These modes are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后四种混合模式与我们之前展示的不同，因为它们不对R/G/B像素分量执行操作。相反，它们以不同的方式组合前景和背景的色调、饱和度、亮度和颜色。这些模式如下：
- en: '`hue`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`色调`'
- en: For each pixel, combines the luminosity and saturation levels of the backdrop
    with the hue angle of the foreground.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个像素，将背景的亮度和饱和度水平与前景的色调角结合起来。
- en: '`saturation`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`饱和度`'
- en: For each pixel, combines the hue angle and luminosity level of the backdrop
    with the saturation level of the foreground.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个像素，将背景的色调角和亮度级别与前景的饱和度水平结合起来。
- en: '`color`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`颜色`'
- en: For each pixel, combines the luminosity level of the backdrop with the hue angle
    and saturation level of the foreground.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个像素，将背景的亮度级别与前景的色调角和饱和度水平结合起来。
- en: '`luminosity`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`亮度`'
- en: For each pixel, combines the hue angle and saturation level of the backdrop
    with the luminosity level of the foreground.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个像素，将背景的色调角和饱和度水平与前景的亮度级别结合起来。
- en: '[Figure 20-11](#blending-elements-hue-sat-lum-color) depicts examples of these
    blend modes.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-11](#blending-elements-hue-sat-lum-color)展示了这些混合模式的示例。'
- en: '![css5 2011](assets/css5_2011.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2011](assets/css5_2011.png)'
- en: Figure 20-11\. Hue, saturation, luminosity, and color blending
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-11\. 色调、饱和度、亮度和颜色混合
- en: These blend modes can be a lot harder to grasp without busting out raw formulas,
    and even those can be confusing if you aren’t familiar with how things like saturation
    and luminosity levels are determined. If you don’t feel like you quite have a
    handle on how these modes work, the best solution is to practice with a bunch
    of images and simple color patterns.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉饱和度和亮度水平的确定方式，那么这些混合模式可能会更难理解，即使使用原始公式也可能会令人困惑。如果你觉得自己对这些模式的工作方式还不是很掌握，最好的解决办法是练习使用大量的图像和简单的色彩模式。
- en: 'Two points to note:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点需要注意：
- en: Remember that an element always blends with its backdrop. If there are other
    elements behind an element, it will blend with them; if there’s a patterned background
    on the parent element, the blending will be done against that pattern.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，元素始终与其背景混合。如果在元素后面有其他元素，它将与它们混合；如果父元素有图案背景，混合将针对该图案进行。
- en: 'Changing the opacity of a blended element will change the outcome, though not
    always in the way you might expect. For example, if an element with `mix-blend-mode:
    difference` is also given `opacity: 0.8`, the difference calculations will be
    scaled by 80%. More precisely, a scaling factor of 0.8 will be applied to the
    color-value calculations. This can cause some operations to trend toward flat
    middle gray and others to shift the color changes.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '更改混合元素的不透明度将改变结果，尽管结果可能并非总是你所期望的。例如，如果具有`mix-blend-mode: difference`的元素也设置了`opacity:
    0.8`，则差异计算将按80%缩放。具体而言，将色值计算应用了0.8的缩放因子。这可能导致某些操作趋向于平坦的中间灰色，而其他操作则会改变颜色变化。'
- en: Blending Backgrounds
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合背景
- en: Blending an element with its backdrop is one thing, but what if an element has
    multiple background images that overlap and also need to be blended together?
    That’s where `background-blend-mode` comes in.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素与其背景混合是一回事，但如果一个元素有多个重叠的背景图片需要混合在一起，那该怎么办？这就是`background-blend-mode`发挥作用的地方。
- en: We won’t go through an exhaustive list of all the blend modes and what they
    mean, because we did that in [“Blending Elements”](#blending-elements). What they
    meant there, they mean here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详尽列出所有混合模式及其含义，因为我们在[“混合元素”](#blending-elements)中已经这样做过。它们在那里的含义，这里也一样。
- en: 'The difference is that when it comes to blending multiple background images,
    they’re blended with one other against an empty background—that is, a completely
    transparent, uncolored backdrop. They do *not* blend with the backdrop of the
    element, except as directed by `mix-blend-mode`. To see what that means, consider
    the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，当涉及混合多个背景图片时，它们将与空背景（完全透明、无色背景）混合在一起。它们不会与元素的背景混合，除非由`mix-blend-mode`指定。要看看这意味着什么，考虑以下情况：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we have three background images, each with its own blend mode. These are
    blended together into a single result, shown in [Figure 20-12](#blending-backgrounds-threebgs).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有三个背景图片，每个都有自己的混合模式。它们被混合在一起，显示在[图 20-12](#blending-backgrounds-threebgs)中的单个结果中。
- en: '![css5 2012](assets/css5_2012.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2012](assets/css5_2012.png)'
- en: Figure 20-12\. Three backgrounds blended together
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-12\. 三个背景混合在一起
- en: 'So far, fine. Here’s the kicker: the result will be the same regardless of
    what might appear behind the element. We can change the parent’s background to
    white, gray, fuchsia, or a lovely pattern of repeating gradients, and in every
    case those three blended backgrounds will look exactly the same, pixel for pixel.
    They’re blended in *isolation*, a term we’ll return to shortly. We can see the
    previous example ([Figure 20-12](#blending-backgrounds-threebgs)) sitting atop
    a variety of backgrounds in [Figure 20-13](#blending-backgrounds-color-transparent).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。这里的关键是：无论出现在元素背后的是什么，结果都会相同。我们可以将父元素的背景更改为白色、灰色、紫红色或重复梯度的可爱图案，但这三个混合的背景看起来都会完全相同，像素对像素。它们被隔离混合，这是我们马上会回头讨论的一个术语。我们可以看到前面的例子
    ([图 20-12](#blending-backgrounds-threebgs)) 位于 [图 20-13](#blending-backgrounds-color-transparent)
    中各种背景之上。
- en: '![css5 2013](assets/css5_2013.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2013](assets/css5_2013.png)'
- en: Figure 20-13\. Blending with color versus transparency
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-13\. 使用颜色与透明度混合
- en: 'Like multiple blended elements stacked atop one another, the blending of background
    layers works from the back to the front. Thus, if you have two background images
    over a solid background color, the background layer in the back is blended with
    the background color, and then the frontmost layer is blended with the result
    of the first blend. Consider the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像多个混合元素堆叠在一起一样，背景层的混合从后到前进行。因此，如果您在一个纯色背景上有两个背景图像，则将背景图像的后置层与背景色混合，然后将前置层与第一个混合的结果混合。请考虑以下情况：
- en: '[PRE4]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Given these styles, *diamond.png* is blended with the background color `goldenrod`
    using the `luminosity` blend. Once that’s done, *star.svg* is blended with the
    results of the diamond-goldenrod blend using a `color-burn` blend.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些样式，*diamond.png* 使用`luminosity`混合模式与背景色`goldenrod`混合。一旦完成这个步骤，*star.svg*
    将使用`color-burn`混合模式与 diamond-goldenrod混合结果混合。
- en: 'Although it’s true that the background layers are blended in isolation, they’re
    also part of an element that may have its own blending rules via `mix-blend-mode`.
    Thus, the final result of the isolated background blend may be blended with the
    element’s backdrop after all. Given the following styles, the first example’s
    background will sit atop the element’s backdrop, but the rest will end up blended
    with it in some fashion, as illustrated in [Figure 20-14](#blending-backgrounds-backdrops):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管背景层确实是在隔离状态下混合的，但它们也是元素的一部分，可能通过`mix-blend-mode`具有自己的混合规则。因此，隔离背景混合的最终结果可能会在某种程度上与元素的背景混合。有了以下样式，第一个例子的背景将位于元素的背景之上，但其余的混合将以某种方式与之混合，正如
    [图 20-14](#blending-backgrounds-backdrops) 中所示：
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![css5 2014](assets/css5_2014.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2014](assets/css5_2014.png)'
- en: Figure 20-14\. Blending elements with their backdrops
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-14\. 元素与它们的背景混合
- en: Throughout this section, we’ve touched on the concept of blending in isolation
    as a thing that backgrounds naturally do. Elements, on the other hand, do not
    naturally blend in isolation. As you’ll see next, that behavior can be changed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们提到了隔离混合的概念，这是背景元素自然发生的事情。然而，元素本身并不会在隔离状态下自然混合。接下来您会看到，这种行为是可以改变的。
- en: Blending in Isolation
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离混合
- en: Sometimes you might want to blend multiple elements together, but in a group
    of their own, in the same way background layers on an element are blended. This
    is, as you’ve seen, called blending in *isolation*. If that’s what you’re after,
    the `isolation` property is for you.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您可能想要将多个元素一起混合，但是在它们自己的组中，就像元素的背景层一样被混合。正如您所见，这被称为隔离混合。如果这正是您想要的，那么`isolation`属性正是为您量身定制的。
- en: 'This pretty much does exactly what it says: it either defines an element to
    create an isolated blending context, or not. Given the following styles, then,
    we get the result shown in [Figure 20-15](#blending-isolation):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎完全按照其字面意思执行：它定义了一个元素是否创建一个隔离的混合上下文。有了以下样式，我们得到了 [图 20-15](#blending-isolation)
    中显示的结果：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![css5 2015](assets/css5_2015.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2015](assets/css5_2015.png)'
- en: Figure 20-15\. Blending in isolation, and not
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-15\. 隔离混合与非隔离混合
- en: 'Take particular note of where `isolation` is applied, and where `mix-blend-mode`
    is applied. The image is given the blend mode, but the containing element (in
    this case, a paragraph) is set to isolation blending. It’s done this way because
    you want the parent (or ancestor element) to be isolated from the rest of the
    document, in terms of how its descendant elements are blended. So if you want
    an element to blend in isolation, look for an ancestor element to set to `isolation:
    isolate`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '特别注意`isolation`的应用位置以及`mix-blend-mode`的应用位置。图像给出了混合模式，但包含元素（在本例中为段落）设置为隔离混合。这样做是因为您希望父元素（或祖先元素）在其后代元素的混合方面与文档的其他部分隔离开来。因此，如果要使元素在隔离中混合，找到一个祖先元素并设置其`isolation:
    isolate`。'
- en: 'An interesting wrinkle arises in all of this: any element that establishes
    a stacking context is automatically isolated, regardless of the `isolation` value.
    For example, if you transform an element by using the `transform` property, it
    will become isolated.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况中，都会出现一个有趣的问题：任何形成堆叠上下文的元素都会自动隔离，而不管`isolation`值如何。例如，如果使用`transform`属性转换元素，则它将变得孤立。
- en: 'The complete list of stacking-context-establishing conditions, as of late 2022,
    is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自2022年末起，形成堆叠上下文的完整条件列表如下：
- en: The root element (e.g., `<html>`)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根元素（例如，`<html>`）
- en: Making an element a flex or grid item *and* setting its `z-index` to anything
    other than `auto`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元素设置为flex或grid项目，并将其`z-index`设置为除`auto`以外的任何值。
- en: Positioning an element with `relative` or `absolute` *and* setting its `z-index`
    to anything other than `auto`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`relative`或`absolute`定位元素，并将其`z-index`设置为除`auto`以外的任何值。
- en: Positioning an element with `fixed` or `sticky`, regardless of its `z-index`
    value
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fixed`或`sticky`定位元素，不论其`z-index`值如何。
- en: Setting `opacity` to anything other than `1`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`opacity`设置为除`1`以外的任何值。
- en: Setting `transform` to anything other than `none`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`transform`设置为除`none`以外的任何值。
- en: Setting `mix-blend-mode` to anything other than `normal`
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`mix-blend-mode`设置为除`normal`以外的任何值。
- en: Setting `filter` to anything other than `none`
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`filter`设置为除`none`以外的任何值。
- en: Setting `perspective` to anything other than `none`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`perspective`设置为除`none`以外的任何值。
- en: Setting `mask-image`, `mask-border`, or `mask` to anything other than `none`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`mask-image`，`mask-border`或`mask`设置为除`none`以外的任何值。
- en: Setting `isolation` to `isolate`
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`isolation`设置为`isolate`。
- en: Setting `contain` to a value that contains `layout` or `paint`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`contain`设置为包含`layout`或`paint`的值。
- en: Applying `will-change` to any of the other properties, even if they are not
    actually changed
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`will-change`应用于任何其他属性，即使实际上没有改变。
- en: Thus, if you have a group of elements that are blended together and then blended
    with their shared backdrop, and you then transition the group’s `opacity` from
    `1` to `0`, the group will suddenly become isolated during the transition. This
    might have no visual impact, depending on the original set of blends, but it very
    well might.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您有一组元素进行混合，然后与它们的共享背景混合，然后将组的`opacity`从`1`过渡到`0`，在过渡期间该组将突然变得孤立。这可能根据原始混合集合没有视觉影响，但也可能有。
- en: Containing Elements
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含元素。
- en: Similar to isolating elements for the purposes of blending modes, CSS has a
    property called `contain` that sets limits on how much an element’s layout can
    be affected by other content, and how much its layout will affect other content.
    It’s meant as a way for authors to give optimization hints to browsers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于为混合模式而隔离元素，CSS有一个称为`contain`的属性，用于限制元素布局如何受其他内容影响，以及其布局会如何影响其他内容。它旨在为作者提供给浏览器的优化提示。
- en: The default, `none`, means no containment is indicated and so no optimization
    hints are given. Each of the other values has its own peculiar effects, so we’ll
    examine them in turn.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`none`表示不指示任何包含，因此也不提供任何优化提示。每个其他值都有其自己的独特效果，因此我们将依次检查它们。
- en: 'Perhaps the simplest of the four alternatives is `contain: paint`. With this
    value set, the painting of an element is confined to its overflow box, so that
    any descendants cannot be painted outside that area. This is in many ways similar
    to `overflow: hidden`. The difference here is that with paint containment enabled,
    there will never be a way to reveal the unpainted portions of the element and
    its descendants; thus, no scrollbar, click-dragging, or other user action will
    bring the unpainted content into view. This allows browsers to completely ignore
    the layout and painting of elements that are entirely offscreen or otherwise not
    visible, since their descendants cannot be displayed either.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '或许四种替代方案中最简单的是 `contain: paint`。设置此值时，元素的绘制被限制在其溢出框内，因此任何后代元素不能在该区域外绘制。这在很多方面类似于
    `overflow: hidden`。不同之处在于启用绘制约束后，将永远无法显示元素及其后代未绘制的部分；因此，没有滚动条、点击拖动或其他用户操作能使未绘制内容显示出来。这允许浏览器完全忽略屏幕外或其他方式不可见元素的布局和绘制，因为其后代也无法显示。'
- en: 'A step up from that in complexity is `contain: style`. With the `style` value,
    things like counter increments and resets, and quotation-mark nesting, are calculated
    within the contained element as though no such styles exist outside it, and furthermore,
    they cannot leave the element to affect other elements. This sounds like it creates
    *scoped styles*, where you can have a set of styles just apply to a subtree of
    the DOM, but it doesn’t, really. It does that only for things like counters and
    quote nesting.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '在复杂度上更进一步的选项是 `contain: style`。使用 `style` 值时，诸如计数器递增和重置以及引号嵌套等样式在包含元素内被计算时，就好像在外部不存在这些样式一样，并且它们不能离开元素影响其他元素。这听起来像是创建了*作用域样式*，可以让一组样式仅适用于
    DOM 的子树，但实际上并非如此。它仅对计数器和引号嵌套等内容有效。'
- en: 'A more impactful option is `contain: size`. This value makes it so that an
    element is laid out without checking to see how its descendant elements might
    affect its layout, and furthermore, its size is calculated as though it has no
    descendants, which means it will have zero height. It’s also treated as though
    it has no intrinsic aspect ratio, even if the element is an `<img>`, `<svg>`,
    form input, or something else that would ordinarily have an intrinsic aspect ratio.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '更具影响力的选择是 `contain: size`。该值使得元素在布局时不会检查其后代元素可能如何影响其布局，并且其大小被计算为没有后代元素的情况，这意味着它的高度为零。它也被视为没有固有的宽高比，即使元素是
    `<img>`、`<svg>`、表单输入或其他通常具有固有宽高比的内容。'
- en: 'Here are a couple examples of size containment, illustrated in [Figure 20-16](#size_containment):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个大小约束的例子，见 [图 20-16](#size_containment)：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](assets/css5_2016.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_2016.png)'
- en: Figure 20-16\. Examples of size containment
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-16\. 大小约束示例
- en: Maybe that’s interesting, but is it useful? To pick one example, it could be
    when JavaScript is used to size elements based on the sizes of their ancestors,
    rather than the other way around (*container queries* by another name) in order
    to prevent layout loops. It could also be applied to elements known to be offscreen
    at page render, in order to minimize the amount of work required by the browser.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或许这很有趣，但是它有用吗？举一个例子，当 JavaScript 用于基于祖先元素大小而不是相反的方式（*容器查询*）来调整元素大小时，可以防止布局循环。这也可以应用于已知在页面渲染时在屏幕外的元素，以最小化浏览器所需的工作量。
- en: 'The last kind of containment is invoked with `contain: layout`. This allows
    fragments to come into it, but no fragments to escape, as might be possible with
    proposed features like CSS Regions. When `layout` is set, the internal layout
    of the element is isolated from the rest of the page. This means that nothing
    in the element affects anything outside the element and that nothing outside the
    element affects the element’s internal layout.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一种约束类型由 `contain: layout` 触发。这允许片段进入其中，但不允许任何片段逃逸，就像 CSS Regions 等提议功能可能会做的那样。设置
    `layout` 后，元素的内部布局与页面的其余部分隔离开来。这意味着元素内部的任何内容都不会影响元素外部的任何内容，反之亦然。'
- en: 'More than one of these keywords can be used in a single rule, such as `contain:
    size paint`. This leads to the last two possible keywords, `content` and `strict`.
    The `content` keyword is shorthand for `layout paint style`, and `strict` is shorthand
    for `size layout paint style`. In other words, `content` contains everything but
    size, and `strict` contains in all possible ways.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '可以在单个规则中使用多个关键字，例如 `contain: size paint`。这导致了最后两个可能的关键字，`content` 和 `strict`。`content`
    关键字是 `layout paint style` 的简写，而 `strict` 是 `size layout paint style` 的简写。换句话说，`content`
    包含除了尺寸外的所有内容，而 `strict` 则以所有可能的方式包含。'
- en: 'An important caveat is that `contain` can apply to elements with the following
    exceptions: elements that do not generate a box (e.g., `display: none` or `display:
    contents`), internal table boxes that aren’t table cells, internal Ruby boxes,
    and nonatomic inline-level boxes can’t be set to `paint`, `size`, or `layout`.
    Furthermore, elements that have an inside display type of `table` (e.g., `<table>`)
    can’t be set to `size`. Any element can be set to `style`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '一个重要的警告是，`contain` 可以应用于以下元素，但有以下例外：不生成框的元素（例如 `display: none` 或 `display:
    contents`），内部表格框不是表格单元格，内部 Ruby 框和非原子性内联级框不能设置为 `paint`、`size` 或 `layout`。此外，具有内部显示类型为
    `table`（例如 `<table>`）的元素不能设置为 `size`。任何元素都可以设置为 `style`。'
- en: 'We have one more caveat to mention: some forms of containment can be invoked
    even without `contain`. For example, `overflow: hidden` will have effectively
    the same result as `contain: paint`, even though `contain: none` may apply to
    the same element.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还有一个需要注意的地方：即使没有 `contain`，某些形式的包含也可以被调用。例如，`overflow: hidden` 将有效地产生与 `contain:
    paint` 相同的结果，即使 `contain: none` 可能也适用于同一元素。'
- en: All this leads us to the other containment property, `content-visibility`, which
    effectively invokes kinds of containment, as well as potentially suppressing the
    rendering of an element’s contents.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些导致我们到达另一个包含属性，`content-visibility`，它有效地调用包含的种类，以及潜在地抑制元素内容的呈现。
- en: In the default case, `visible`, the contents of an element are shown as normal.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认情况下，`visible`，元素的内容会正常显示。
- en: 'If the `hidden` value is used, none of the element’s contents are rendered,
    and they do not participate in the sizing of the element, as if all the contents
    (including any text outside of descendant elements) had been set to `display:
    none`. Furthermore, the suppressed content should not be available to things such
    as page search and tab-order navigation, and should not be selectable (as with
    mouse click-and-drag) or focusable.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '如果使用 `hidden` 值，则元素的所有内容都不会被呈现，并且它们不参与元素的尺寸调整，就好像所有内容（包括任何超出后代元素的文本）都已设置为 `display:
    none`。此外，被抑制的内容不应该对页面搜索和标签顺序导航等产生影响，并且不可选择（例如鼠标点击和拖动）或可聚焦。'
- en: 'If `auto` is used, paint, style, and layout containment are enabled, as if
    having declared `contain: content`. The content may be skipped by the user agent
    or may not; most likely, it will be if the element is offscreen or otherwise not
    visible, but that’s up to the user agent. The contents in this case *are* available
    to page search and tab-order navigation, and can be selected and focused.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '如果使用 `auto`，则启用绘制、样式和布局的包含，就好像声明了 `contain: content`。内容可能会被用户代理跳过，也可能不会；如果元素不在屏幕上或以其他方式不可见，最有可能会跳过。在这种情况下的内容
    *可* 供页面搜索和标签顺序导航，并且可以选择和聚焦。'
- en: Warning
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of early 2023, `content-visibility` is behind a flag in Firefox and not supported
    in Safari.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2023 年初，`content-visibility` 在 Firefox 中还需要一个标志来启用，并且在 Safari 中不支持。
- en: To be honest, you probably shouldn’t be messing with `contain` or `content-visibility`
    unless you know with absolute certainty that you really need them, and you’ll
    more likely be setting and disabling them via JavaScript. But they’re there when
    you do need them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 坦率地说，除非你绝对确定确实需要它们，否则你可能不应该使用 `contain` 或 `content-visibility`，而且更有可能是通过 JavaScript
    来设置和禁用它们。但当你确实需要它们时，它们就在那里。
- en: Float Shapes
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮动形状
- en: Let’s take a moment to return to the world of floating elements and see how
    we can shape the way text flows past them. Old-school web designers may remember
    techniques such as *ragged floats* and *sandbagging*—in both cases, using a series
    of short, floated images of varying widths to create ragged float shapes. Thanks
    to CSS Shapes, these tricks are no longer needed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间回到浮动元素的世界，并看看如何塑造文本流过它们的方式。老式网页设计师可能会记得技术，如 *ragged floats* 和 *sandbagging*
    ——在这两种情况下，使用一系列宽度不同的短浮动图像来创建不整齐的浮动形状。由于 CSS Shapes 的出现，这些技巧不再需要了。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the future, shapes may be available for nonfloated elements such as elements
    placed using CSS Grid, but as of late 2022, they’re allowed on only floated elements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，形状可能会用于非浮动元素，例如使用CSS Grid放置的元素，但截至2022年底，它们仅适用于浮动元素。
- en: To shape the flow of content around a floated element, you need to define a
    shape. The property `shape-outside` is how you do so.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要围绕浮动元素来塑造内容流动，您需要定义一个形状。属性`shape-outside`就是您这样做的方式。
- en: With `none`, there’s no shaping except the margin box of the float itself—same
    as it ever was. That’s straightforward and boring. Time for the good stuff.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`none`，除了浮动元素本身的边距框外，没有任何形状——就像以前一样。这很直接也很无聊。是时候来点好东西了。
- en: 'Let’s start with using an image to define the float shape, as it’s both the
    simplest and (in many ways) the most exciting. Say we have an image of a crescent
    moon, and we want the content to flow around the visible parts of it. If that
    image has transparent parts, as in a GIF or a PNG, then the content will flow
    into those transparent parts, as shown in [Figure 20-17](#using_an_image_to_define_fig):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用图像来定义浮动形状开始，因为它既简单又（在许多方面上）最令人兴奋。假设我们有一张新月形状的图像，我们希望内容围绕其可见部分流动。如果该图像具有透明部分，如GIF或PNG中所示，那么内容将流入这些透明部分，如图20-17所示：
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In most cases, when you have a floated image, you’ll just use that same image
    as its shape. You don’t have to—you can always load a second, different image
    to create a float shape that doesn’t match the visible image—but using a single
    image as both the float and its shape is by far the most common use case. We’ll
    talk in the following sections about how to push the content away from the visible
    parts of the image, and how to vary the transparency threshold that determines
    the shape; but for now, let’s just savor the power this affords us.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当您有一个浮动图像时，您通常会使用同一图像作为其形状。您并非一定要这样做——您可以始终加载第二张不同的图像来创建不匹配可见图像的浮动形状——但将单个图像同时用作浮动和其形状是迄今为止最常见的用例。在接下来的章节中，我们将讨论如何将内容推开离可见图像的部分，以及如何变化透明度阈值以确定形状；但现在，让我们尽情享受这种功能带来的力量。
- en: '![image](assets/css5_2017.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2017.png)'
- en: Figure 20-17\. Using an image to define a float shape
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-17。使用图像定义浮动形状
- en: 'One point needs to be clarified at this stage: the content will flow into transparent
    parts to which it has “direct access,” for lack of a better term. That is, the
    content doesn’t flow to both the left and right of the image in [Figure 20-17](#using_an_image_to_define_fig),
    but just the right side. That’s the side that faces the content, it being a left-floated
    image. If we right-floated the image, the content would flow into the transparent
    areas on the image’s left side. This is illustrated in [Figure 20-18](#an_image_float_shape_fig)
    (with the text right-aligned to make the effect more obvious):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段需要澄清一点：内容将流入其“直接访问”的透明部分，以便缺乏更好的术语。也就是说，内容不会同时流入图像的左右两侧（如图20-17所示），而只会流入右侧。这是因为右侧面向内容，这是左浮动图像。如果我们将图像右浮动，内容将流入图像左侧的透明区域。这在图20-18（文本右对齐以使效果更明显）中有所说明：
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![image](assets/css5_2018.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2018.png)'
- en: Figure 20-18\. An image float shape on the right
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-18。右侧的图像浮动形状
- en: 'Always remember that the image has to have actual areas of transparency to
    create a shape. With an image format like JPEG, or even if you have a GIF or PNG
    with no alpha channel, the shape will be a rectangle, exactly as if you’d used
    `shape-outside: none`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '请始终记住，图像必须具有实际的透明区域才能创建形状。使用像JPEG这样的图像格式，或者即使您有一个没有Alpha通道的GIF或PNG，形状将是一个矩形，就像您使用了`shape-outside:
    none`一样。'
- en: Shaping with Image Transparency
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用图像透明度进行形状塑造
- en: As you saw in the previous section, it’s possible to use an image with transparent
    areas to define the float shape. Any part of the image that isn’t fully transparent
    creates the shape. That’s the default behavior, anyway, but you can modify it
    with `shape-image-threshold`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前一节中看到的，可以使用具有透明区域的图像来定义浮动形状。图像的任何非完全透明部分都会创建形状。无论如何，这是默认行为，但您可以使用`shape-image-threshold`进行修改。
- en: 'This property lets you decide what level of transparency determines an area
    where content can flow, or, conversely, what level of opacity defines the float
    shape. Thus, with `shape-image-threshold: 0.5`, any part of the image with more
    than 50% transparency can allow content to flow into it, and any part of the image
    with less than 50% transparency is part of the float shape. This is illustrated
    in [Figure 20-19](#using_image_opacity_to_define).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2019.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Figure 20-19\. Using image opacity to define the float shape at the 50% opacity
    level
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you set the value of the `shape-image-threshold` property to `1.0` (or just
    `1`), no part of the image can be part of the shape, so there won’t be one, and
    the content will flow over the entire float.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a value of `0.0` (or just `0`) will make any nontransparent
    part of the image the float shape, as if this property was not even set. Furthermore,
    any value below 0 is reset to `0.0`, and any above one is reset to `1.0`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Using Inset Shapes
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s turn back to the <*`basic-shape`*> and <*`shape-box`*> values. A
    basic shape is one of the following types:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`inset()`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`circle()`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ellipse()`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`polygon()`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the <*`shape-box`*> can be one of these types:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '`margin-box`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`border-box`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`padding-box`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content-box`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These shape boxes indicate the outermost limits of the shape. You can use them
    on their own, as illustrated in [Figure 20-20](#basic_shape_boxes_fig), where
    the images have some padding in which a dark background color can be seen, then
    a thick border, and finally some (invisible, as always) margins.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2020.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: Figure 20-20\. The basic shape boxes
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The default shape box is the margin box, which makes sense, since that’s what
    float boxes use when they aren’t being shaped. You can use a shape box in combination
    with a basic shape; thus, for example, you could declare `shape-outside: inset(10px)
    border-box`. The syntax for each of the basic shapes is different, so we’ll take
    them in turn.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: If you’re used to working with border images, inset shapes should seem familiar.
    Even if you aren’t, the syntax isn’t too complicated. You define distances to
    move inward from each side of the shape box, using from one to four length or
    percentage values, with an optional corner-rounding value.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'To pick a simple case, suppose we want to shrink the shape 2.5 em inside the
    shape box:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Four offsets are created, each 2.5 em inward from the outside edge of the shape
    box. In this case, the shape box is the margin box, since we haven’t altered it.
    If we wanted the shape to shrink from, say, the padding box, the value would change
    like so:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 20-21](#insets_from_two_basic_shape_boxes) illustrates the two inset
    shapes we just defined.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2021.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: Figure 20-21\. Insets from two basic shape boxes
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As with margins, padding, borders, and so on, *value replication* is in force:
    if there are fewer than four lengths or percentages, the missing values are derived
    from the given values. They go in TRBL order, and thus the following pairs are
    internally equivalent:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与边距、填充、边框等一样，*值复制*也适用：如果少于四个长度或百分比，缺失的值将从给定值中派生。它们按照TRBL的顺序排列，因此以下对是内部等效的：
- en: '[PRE16]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An interesting aspect of inset shapes is the ability to round the corners of
    the shape after the inset has been calculated. The syntax (and effects) are identical
    to the `border-radius` property. Thus, if you wanted to round the corners of the
    float shape with a 5-pixel round, you’d write something like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 内嵌形状的一个有趣方面是在计算内嵌后能够圆角形状的能力。语法（和效果）与`border-radius`属性相同。因此，如果你想要给浮动形状加上5像素的圆角，你可以这样写：
- en: '[PRE17]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the other hand, if you want each corner to be rounded elliptically, so that
    the elliptical curving is 5 pixels tall and half an em wide, you’d write it like
    this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你想让每个角都呈椭圆形，使椭圆曲线高度为5像素，宽度为半个em，你可以这样写：
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Setting a different rounding radius in each corner is also possible and follows
    the usual replication pattern, except it starts from the top left instead of the
    top. So if you have more than one value, they’re in the order top left, top right,
    bottom right, bottom left (TL-TR-BR-BL, or TiLTeR-BuRBLe), and are filled in by
    copying declared values in for the missing values. [Figure 20-22](#rounding_the_corners_fig)
    shows a few examples. (The rounded shapes in the middle are the float shapes,
    which have been added for clarity. Browsers do not actually draw the float shapes
    on the page.)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个角设置不同的圆角半径也是可能的，并遵循通常的复制模式，只是从左上角开始而不是从顶部开始。因此，如果有多个值，它们的顺序是从左上角开始，顶部右侧，底部右侧，底部左侧（TL-TR-BR-BL，或TiLTeR-BuRBLe），并通过复制声明的值填充缺失的值。[图20-22](#rounding_the_corners_fig)展示了一些示例。（中间的圆角形状是浮动形状，为了清晰起见添加。浏览器实际上不会在页面上绘制浮动形状。）
- en: '![image](assets/css5_2022.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2022.png)'
- en: Figure 20-22\. Rounding the corners of a shape box
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-22。圆角形状的角盒
- en: Note
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you set a `border-radius` value for your floated element, this is *not* the
    same as creating a flat shape with rounded corners. Remember that `shape-outside`
    defaults to `none`, so the floated element’s box won’t be affected by the rounding
    of borders. If you want to have text flow closely past the border rounding you’ve
    defined with `border-radius`, you’ll need to supply identical rounding values
    to `shape-outside`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为浮动元素设置了`border-radius`值，这与创建具有圆角的平面形状并不相同。请记住，`shape-outside`默认为`none`，因此浮动元素的框不会受到边框的影响。如果你想让文本紧密地流过你用`border-radius`定义的边框圆角，你需要为`shape-outside`提供相同的圆角值。
- en: Circles and ellipses
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 圆形和椭圆形
- en: Circular and elliptical float shapes use similar syntax. In either case, you
    define the radius (or two radii, for the ellipse) of the shape, and then the position
    of its center.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形和椭圆形浮动形状使用类似的语法。在任何情况下，你都要定义形状的半径（或椭圆的两个半径），然后定义其中心的位置。
- en: Note
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re familiar with circular and elliptical gradient images, the syntax
    for defining circular and elliptical float shapes will seem very much the same.
    There are some important caveats, however, as this section will explore.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉圆形和椭圆形渐变图像，定义圆形和椭圆形浮动形状的语法看起来非常相似。然而，本节将探讨一些重要的注意事项。
- en: 'Suppose we want to create a circle shape that’s centered in its float, with
    a 25-pixel radius. We can accomplish that in any of the following ways:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个在其浮动中心的圆形形状，半径为25像素。我们可以通过以下任何一种方式实现：
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Regardless of which we use, the result will be that shown in [Figure 20-23](#a_circular_float_shape).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用哪种，结果都将如[图20-23](#a_circular_float_shape)所示。
- en: '![image](assets/css5_2023.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2023.png)'
- en: Figure 20-23\. A circular float shape
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-23。一个圆形浮动形状
- en: 'Something to watch out for is that shapes *cannot* exceed their shape box,
    even if you set up a condition where that seems possible. For example, suppose
    we applied the previous 25-pixel-radius rule to a small image, one that’s no more
    than 30 pixels on a side. In that case, you’ll have a circle 50 pixels in diameter
    centered on a rectangle that’s smaller than the circle. What happens? The circle
    may be defined to stick out past the edges of the shape box—in the default case,
    the margin box—but it will be clipped at the edges of the shape box. Thus, given
    the following rules, the content will flow past the image as if it had no shape,
    as shown in [Figure 20-24](#a_rather_small_circular_float_shape):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，形状*不能*超出其形状框，即使您设置了一个看似可能的条件。例如，假设我们将前述的25像素半径规则应用于一个小图像，边长不超过30像素。在这种情况下，您将得到一个直径为50像素的圆，其圆心位于小于圆的矩形内部的矩形中。结果会怎样？圆可能被定义为突出到形状框的边缘之外——默认情况下是边界框——但它将在形状框的边缘处被剪切。因此，根据以下规则，内容将像没有形状一样流过图像，如[图20-24](#a_rather_small_circular_float_shape)所示：
- en: '[PRE20]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![image](assets/css5_2024.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2024.png)'
- en: Figure 20-24\. A rather small circular float shape for an even smaller image
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-24。一个非常小的圆形浮动形状，适用于更小的图像
- en: We can see the circle extending past the edges of the image, but notice how
    the text flows along the edge of the image, not the float shape. Again, that’s
    because the actual float shape is clipped by the shape box; in [Figure 20-24](#a_rather_small_circular_float_shape),
    that’s the margin box, which is at the outer edge of the image. So the actual
    float shape isn’t a circle, but a box the exact dimensions of the image.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到圆形延伸超出图像的边缘，但请注意文本是如何沿着图像的边缘而不是浮动形状而流动的。这是因为实际的浮动形状被形状框剪切；在[图20-24](#a_rather_small_circular_float_shape)中，这是外边缘框，位于图像的外边缘处。因此，实际的浮动形状不是一个圆形，而是一个与图像尺寸完全相同的框。
- en: 'The same holds true no matter what edge you define to be the shape box. If
    you declare `shape-outside: circle(5em) content-box;`, the shape will be clipped
    at the edges of the content box. Content will be able to flow over the padding,
    borders, and margins, and will not be pushed away in a circular fashion.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '无论您将形状框定义为何种边缘，都是如此。如果您声明`shape-outside: circle(5em) content-box;`，则形状将被剪切到内容框的边缘。内容将能够流过填充、边框和边距，并且不会以圆形方式推开。'
- en: 'This means you can do things like create a float shape that’s the lower-right
    quadrant of a circle in the upper-left corner of the float, assuming the image
    is `3em` square:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以做一些事情，比如创建一个浮动形状，它是浮动框左上角圆的右下象限，假设图像是`3em`的正方形：
- en: '[PRE21]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For that matter, if you have a perfectly square float, you can define a circle-quadrant
    that just touches the opposite sides, using a percentage radius:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您有一个完全正方形的浮动框，您可以定义一个圆形象限，该圆形象限刚好接触相反的边缘，使用百分比半径：
- en: '[PRE22]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But note: that works *only* if the float is square. If it’s rectangular, oddities
    creep in. Take this example, which is illustrated in [Figure 20-25](#circular_float_shape_that_results):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意：这仅适用于浮动框是正方形的情况。如果是长方形，则会出现奇怪的情况。例如，以下示例将进行说明，该示例在[图20-25](#circular_float_shape_that_results)中有插图：
- en: '[PRE23]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![image](assets/css5_2025.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2025.png)'
- en: Figure 20-25\. The circular float shape that results from a rectangle
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-25。由矩形形成的圆形浮动形状
- en: Don’t bother trying to pick which dimension is controlling the `50%` calculation,
    because neither is. Or, in a sense, both are.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不要费心试图选择哪个维度控制了`50%`的计算，因为没有一个是。或者从某种意义上说，两者都是。
- en: 'When you define a percentage for the radius of a circular float shape, it’s
    calculated with respect to a calculated *reference box*. The height and width
    of this box are calculated as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为圆形浮动形状的半径定义百分比时，它是相对于计算出的*参考框*来计算的。该框的高度和宽度如下计算：
- en: '![css5 2026](assets/css5_2026.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2026](assets/css5_2026.png)'
- en: In effect, this creates a square that’s a blending of the float’s intrinsic
    height and width. In the case of our floated image of 70 × 150 pixels, that works
    out to a square that’s 117.047 pixels on a side. Thus, the circle’s radius is
    50% of that, or 58.5235 pixels.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这创建了一个正方形，它是浮动的固有高度和宽度的混合。对于我们的浮动图像，宽度为70像素，高度为150像素，这会导致一个边长为117.047像素的正方形。因此，圆的半径是这个值的50%，即58.5235像素。
- en: Once again, note that the content in [Figure 20-26](#a_clipped_float_shape)
    is flowing past the image and ignoring the circle. That’s because the actual float
    shape is clipped by the shape box, so the final float shape would be a kind of
    vertical bar with rounded ends, something very much like what’s shown in [Figure 20-26](#a_clipped_float_shape).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，[图 20-26](#a_clipped_float_shape) 中的内容流经图像并忽略了圆形。这是因为实际的浮动形状被形状框裁剪，所以最终的浮动形状将是一个类似垂直条形的形状，两端带有圆形，与
    [图 20-26](#a_clipped_float_shape) 所示的非常相似。
- en: '![image](assets/css5_2027.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2027.png)'
- en: Figure 20-26\. A clipped float shape
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-26\. 裁剪后的浮动形状
- en: 'It’s a lot simpler to position the center of the circle and have it grow until
    it touches either the closest side to the circle’s center, or the farthest side
    from the circle’s center. Both techniques are possible, as shown here and illustrated
    in [Figure 20-27](#various_circular_float_shapes):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 把圆的中心定位并使其增长，直到触及到最接近圆心的一侧或最远离圆心的一侧，都是可行的技术，如此处所示，并在 [图 20-27](#various_circular_float_shapes)
    中有所说明：
- en: '[PRE24]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![image](assets/css5_2028.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2028.png)'
- en: Figure 20-27\. Various circular float shapes
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-27\. 各种圆形浮动形状
- en: Note
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: In one of the examples in [Figure 20-27](#various_circular_float_shapes), the
    shape is clipped to its shape box, whereas in the others, the shape is allowed
    to extend beyond it. If we hadn’t clipped the shape, it would have been too big
    for the figure! You’ll see this again in the next figure.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 20-27](#various_circular_float_shapes) 的一个示例中，形状被裁剪到其形状框，而在其他示例中，形状允许超出其框。如果我们没有裁剪形状，它将对图像过大！你将在下一个图中再次看到这一点。
- en: Now, how about ellipses? Besides using the name `ellipse()`, the only syntactical
    difference between circles and ellipses is that you define two radii instead of
    one radius. The first is the x (horizontal) radius, and the second is the y (vertical)
    radius. Thus, for an ellipse with an x radius of 20 pixels and a y radius of 30
    pixels, you’d declare `ellipse(20px 30px)`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，说到椭圆？除了使用名称 `ellipse()`，圆形和椭圆之间的唯一语法区别是你需要定义两个半径而不是一个。第一个是 x（水平）半径，第二个是 y（垂直）半径。因此，对于
    x 半径为 20 像素和 y 半径为 30 像素的椭圆，你应该声明 `ellipse(20px 30px)`。
- en: You can use any length or percentage, *or* the keywords `closest-side` and `farthest-side`,
    for either of the radii in an ellipse. [Figure 20-28](#various_elliptical_float_shapes)
    shows some possibilities.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆中，你可以使用任意长度或百分比，*或者*关键词 `closest-side` 和 `farthest-side` 来定义椭圆的两个半径。[图 20-28](#various_elliptical_float_shapes)
    展示了一些可能性。
- en: '![image](assets/css5_2029.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2029.png)'
- en: Figure 20-28\. Defining float shapes with ellipses
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-28\. 使用椭圆定义浮动形状
- en: Working with percentages for the lengths of the radii is a little different
    with ellipses than with circles. Instead of a calculated reference box, percentages
    in ellipses are calculated against the axis of the radius. Thus, horizontal percentages
    are calculated with respect to the width of the shape box, and vertical percentages
    with respect to the height. This is illustrated in [Figure 20-29](#elliptical_float_shapes_and_percentages).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 与圆形不同，使用百分比来定义椭圆半径的长度稍有不同。椭圆中的百分比是相对于半径轴进行计算的。因此，水平百分比是相对于形状框的宽度计算的，垂直百分比是相对于高度计算的。这在
    [图 20-29](#elliptical_float_shapes_and_percentages) 中有所说明。
- en: '![image](assets/css5_2030.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2030.png)'
- en: Figure 20-29\. Elliptical float shapes and percentages
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-29\. 椭圆形浮动形状和百分比
- en: As with any basic shape, an elliptical shape is clipped at the edges of the
    shape box.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何基本形状一样，椭圆形状在形状框的边缘处被裁剪。
- en: Polygons
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多边形
- en: Polygons are a lot more complicated to write, though they may be a little bit
    easier to understand. You define a polygonal shape by specifying a comma-separated
    list of *x*-*y* coordinates, expressed as either lengths or percentages, calculated
    from the top left of the shape box, as in SVG. Each *x*-*y* pair is a *vertex*
    in the polygon. If the first and last vertices are not the same, the browser will
    close the polygon by connecting them. (All polygonal float shapes must be closed.)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形的编写要复杂得多，尽管可能会稍微容易理解一些。你通过指定以逗号分隔的 *x*-*y* 坐标列表来定义多边形形状，可以是从形状框的左上角开始计算的长度或百分比，就像
    SVG 中一样。每个 *x*-*y* 对都是多边形中的一个 *顶点*。如果第一个和最后一个顶点不同，浏览器会通过连接它们来闭合多边形。（所有多边形浮动形状必须是闭合的。）
- en: 'So let’s say we want a diamond shape that’s 50 pixels tall and wide. If we
    start building the polygon from the topmost vertex, the `polygon()` value would
    look like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 所以假设我们想要一个50像素高和宽的菱形。如果我们从最顶端顶点开始构建多边形，`polygon()`值将如下所示：
- en: '[PRE25]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Percentages have the same behavior as they do in `background-image` positioning
    (for example), so we can define a diamond shape that always “fills out” the shape
    box. It would be written like so:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比在`background-image`定位中的行为与此相同，因此我们可以定义一个菱形形状，始终“填满”形状框。它应该这样写：
- en: '[PRE26]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The result of this and the previous polygon example are shown in [Figure 20-30](#a_polygonal_float_shape).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个和之前的多边形示例的结果显示在[图 20-30](#a_polygonal_float_shape)中。
- en: '![image](assets/css5_2031.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2031.png)'
- en: Figure 20-30\. A polygonal float shape
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-30。一个多边形浮动形状
- en: 'These examples both start from the topmost vertex, but they don’t have to.
    All of the following will yield the same result:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子都从最顶端顶点开始，但不必如此。以下所有方式都会得到相同结果：
- en: '[PRE27]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As before, remember: if a shape definition exceeds the shape box, it will always
    be clipped to it. So even if you create a polygon with coordinates that lie outside
    the shape box (by default, the margin box), the polygon will get clipped. [Figure 20-31](#how_a_float_shape_is_clipped)
    demonstrates the result.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，请记住：如果一个形状定义超出了形状框，它将始终被剪切到形状框内。因此，即使你创建一个带有超出形状框（默认为边距框）的坐标的多边形，该多边形也将被剪切。[图 20-31](#how_a_float_shape_is_clipped)演示了结果。
- en: '![image](assets/css5_2032.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2032.png)'
- en: Figure 20-31\. How a float shape is clipped when it exceeds the shape box
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-31。当浮动形状超出形状框时如何剪切
- en: 'Polygons have an extra wrinkle: you can toggle their fill rule. By default,
    the fill rule is `nonzero`, but the other possible value is `evenodd`. It’s easier
    to show the difference than to describe it, so here’s a star polygon with two
    fill rules, illustrated in [Figure 20-32](#the_two_polygonal_fills):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形还有一个额外的复杂点：你可以切换它们的填充规则。默认情况下，填充规则是`nonzero`，但另一个可能的值是`evenodd`。展示它们之间区别比描述更容易，所以这里有一个星形多边形，有两种填充规则，详见[图 20-32](#the_two_polygonal_fills)：
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![image](assets/css5_2033.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2033.png)'
- en: Figure 20-32\. The two polygonal fills
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-32。两个多边形填充
- en: 'The default `nonzero` case is what we tend to think of with filled polygons:
    a single shape, completely filled. The `evenodd` option has a different effect,
    in which some pieces of the polygon are filled and others are not.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`nonzero`情况是我们填充多边形时倾向于考虑的：一个完全填充的单一形状。`evenodd`选项有不同的效果，其中一些多边形片段填充，而其他部分不填充。
- en: This particular example doesn’t show much difference, since the part of the
    polygon that’s missing is completely enclosed by filled parts, so the end result
    is the same either way. However, imagine a shape that has sideways spikes, and
    then a line that cuts vertically across the middle of them. Rather than a comb
    shape, you’d end up with a set of discontinuous triangles. There are a lot of
    possibilities.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子没有显示出太大差异，因为多边形的一部分缺失完全被填充的部分包围，所以无论哪种方式最终结果都是一样的。然而，想象一个有侧面尖刺的形状，然后一条垂直穿过它们中间的线。你不会得到一个梳子形状，而是一组不连续的三角形。有很多可能性。
- en: As you can imagine, a polygon can become very complex, with a large number of
    vertices. You’re welcome to work out the coordinates of each vertex on paper and
    type them in, but it makes a lot more sense to use a tool to do this. A good example
    of such a tool is the CSS Shapes Editor extension available for Chrome via the
    Chrome Web Store. (Firefox has this capability built natively into its web inspector.)
    You can select a float in the DOM inspector, bring up the CSS Shapes Editor, select
    a polygon, and then start creating and moving vertices in the browser, with live
    reflowing of the content as you do so. Then, once you’re satisfied, you can drag-select-copy
    the polygon value for pasting into your stylesheet. [Figure 20-33](#the_chroms_shapes_editor)
    shows a screenshot of the Shapes Editor in action.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的，一个多边形可能变得非常复杂，顶点数量很多。你可以在纸上计算每个顶点的坐标并输入，但使用工具会更加合理。这类工具的一个很好的例子是 Chrome
    Web Store 提供的 CSS Shapes Editor 扩展。 （Firefox 在其网络检查器中内置了此功能。）你可以在 DOM 检查器中选择一个浮动元素，打开
    CSS Shapes Editor，选择一个多边形，然后在浏览器中创建和移动顶点，同时实时重新排列内容。一旦满意，你可以拖动选择并复制多边形值，以便粘贴到你的样式表中。[图 20-33](#the_chroms_shapes_editor)展示了
    Shapes Editor 在操作中的截图。
- en: '![image](assets/css5_2034.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_2034.png)'
- en: Figure 20-33\. The Chrome Shapes Editor in action
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-33。Chrome Shapes Editor 的操作
- en: Warning
  id: totrans-337
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Because of cross-origin resource sharing (CORS) restrictions, shapes cannot
    be edited with the Shapes Editor unless they’re being loaded over HTTP(S) from
    the same origin server as the HTML and CSS. Loading local files from your computer
    will prevent the shapes from being editable. The same restriction prevents shapes
    from being loaded off local storage via the `url()` mechanism.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跨源资源共享（CORS）限制，除非它们通过HTTP(S)从与HTML和CSS相同源服务器加载，否则不能使用形状编辑器编辑形状。从您的计算机加载本地文件将阻止形状可编辑。同样的限制阻止通过`url()`机制从本地存储加载形状。
- en: Adding a Shape Margin
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加形状边距
- en: Once a float of any kind of shape has been defined, it’s possible to add a “margin”—more
    properly, a *shape modifier*—to that shape by using the property `shape-margin`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了任何类型形状的浮动，就可以通过使用属性`shape-margin`向该形状添加“边距”——更正确地说是*形状修改器*。
- en: Much like a regular element margin, a *shape margin* pushes content away by
    either a length or a percentage; a percentage is calculated with respect to the
    width of the element’s containing block, just as are regular margins.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 就像常规元素边距一样，*形状边距*通过长度或百分比将内容推开；百分比相对于元素包含块的宽度计算，就像常规边距一样。
- en: The advantage of a shape margin is that you can define a shape that exactly
    matches the thing you want to shape, and then use the shape margin to create extra
    space. Take an image-based shape, where part of the image is visible and the rest
    is transparent. Instead of having to add opaque portions to the image to keep
    text and other content away from the visible part of the image, you can just add
    a shape margin. This enlarges the shape by the distance supplied.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 形状边距的优点在于可以定义与要形状化的对象完全匹配的形状，然后使用形状边距创建额外空间。以基于图像的形状为例，其中图像的一部分可见，其余部分为透明。与其必须向图像添加不透明部分以使文本和其他内容远离图像的可见部分不同，可以直接添加形状边距。这样可以通过提供的距离扩大形状。
- en: In detail, the new shape is found by drawing a line perpendicular from each
    point along the basic shape, with a length equal to the value of `shape-margin`,
    to find a point in the new shape. At sharp corners, a circle is drawn centered
    on that point with a radius equal to the value of `shape-margin`. After all that,
    the new shape is the smallest shape that can describe all those points and circles
    (if any).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，通过从基本形状沿每个点垂直画一条长度等于`shape-margin`值的线来找到新形状中的点。在尖锐的角上，以该点为中心画一个半径等于`shape-margin`值的圆。之后，新形状是可以描述所有这些点和圆（如果有的话）的最小形状。
- en: Remember, though, that a shape can never exceed the shape box. Thus, by default,
    the shape can’t get any bigger than the margin box of the unshaped float. Since
    `shape-margin` actually increases the size of the shape, any part of the newly
    enlarged shape that exceeds the shape box will be clipped.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，形状永远不能超出形状框。因此，默认情况下，形状不能比未形状化的浮动的边距框更大。由于`shape-margin`实际上增加了形状的大小，任何超出形状框的新扩展形状部分将被裁剪。
- en: 'To see what this means, consider the following, as illustrated in [Figure 20-34](#adding_margins_to_float_shapes):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这意味着什么，考虑以下内容，如 [图 20-34](#adding_margins_to_float_shapes) 所示：
- en: '[PRE29]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![image](assets/css5_2035.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2035.png)'
- en: Figure 20-34\. Adding margins to float shapes
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-34\. 给浮动形状添加边距
- en: 'Notice the way the content flows past the second and third examples. There
    are definitely places where the content gets closer than the specified `shape-margin`,
    because the shape has been clipped at the margin box of the floated element. To
    make sure the separation distance is always observed, include standard margins
    that equal or exceed the `shape-margin` distance. For example, we could have avoided
    the problem by modifying two of the rules like so:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意内容在第二和第三个示例中的流动方式。有些地方内容确实比指定的`shape-margin`更接近，因为形状已在浮动元素的边距框内被裁剪。为了确保分离距离始终被观察到，包含标准边距，其距离等于或超过`shape-margin`距离。例如，我们可以通过修改两条规则来避免这个问题：
- en: '[PRE30]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In both cases, the right and bottom margins are set to be the same as the `shape-margin`
    value, ensuring that the enlarged shape will never exceed the shape box on those
    sides. This is demonstrated in [Figure 20-35](#making_sure_the_shape_margins).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，右边和底边的边距被设置为与`shape-margin`值相同，确保扩展的形状在这些边上永远不会超过形状框。这在 [图 20-35](#making_sure_the_shape_margins)
    中有所展示。
- en: '![image](assets/css5_2036.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_2036.png)'
- en: Figure 20-35\. Making sure the shape margins don’t get clipped
  id: totrans-353
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-35\. 确保形状边距不被裁剪
- en: 'If you have a float go to the right, you’ll have to adjust its margins to create
    space below and to the left, not the right, but the principle is the same. You
    can also use `float: inline-end` and the `margin-inline` property to ensure that
    if the writing direction changes, your layout still works as intended.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '如果浮动元素向右移动，您将需要调整其边距以在下方和左侧创建空间，而不是右侧，但其原则是相同的。您还可以使用`float: inline-end`和`margin-inline`属性，以确保如果写入方向发生更改，布局仍按预期工作。'
- en: Clipping and Masking
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裁剪和遮罩
- en: Similar to float shaping, CSS also offers clipping and masking of elements,
    albeit without any shaping of the element box. These are methods of showing only
    portions of an element, using a variety of simple shapes as well as the application
    of complete images and SVG elements. These can be used to make decorative bits
    of a layout more visually interesting, among other things—a common technique is
    to frame images or give them ragged edges.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于浮动形状，CSS还提供了元素的裁剪和遮罩功能，尽管没有任何元素框的形状。这些方法可以仅显示元素的部分内容，使用各种简单形状以及应用完整图像和SVG元素。这些方法可以使布局中的装饰性部分更加视觉上有趣，其中一种常见技术是为图像添加边框或不规则边缘。
- en: Clipping
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 裁剪
- en: If all you want to do is visually clip away pieces of an element, you can use
    the property `clip-path`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想在视觉上裁剪元素的一部分，可以使用`clip-path`属性。
- en: 'With `clip-path`, you’re able to define a *clipping shape*. This is essentially
    the area of the element inside which visible portions are drawn. Any part of the
    element that falls outside the shape is clipped away, leaving behind empty transparent
    space. The following code gives an unclipped and a clipped example of the same
    paragraph, with the result depicted in [Figure 20-36](#clipping-compare):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`clip-path`，您可以定义*裁剪形状*。这基本上是元素内部可见部分绘制的区域。任何落在形状外部的部分将被裁剪掉，留下空的透明空间。下面的代码显示了同一段落的未裁剪和裁剪示例，结果显示在[图20-36](#clipping-compare)中：
- en: '[PRE31]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![css5 2037](assets/css5_2037.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2037](assets/css5_2037.png)'
- en: Figure 20-36\. Unclipped and clipped paragraphs
  id: totrans-362
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-36。未裁剪和裁剪的段落
- en: The default value, `none`, means no clipping is performed, as you’d probably
    expect. Similarly, if a <*`url`*> value is given (as in the preceding code) and
    it points to a missing resource, or to an element in an SVG file that isn’t a
    `<clipPath>`, no clipping is performed.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值`none`表示不执行裁剪，这可能是您所预期的。类似地，如果给出了<*`url`*>值（如前面的代码所示），并且它指向丢失的资源或SVG文件中不是`<clipPath>`的元素，则不执行裁剪。
- en: Warning
  id: totrans-364
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, URL-based clip paths work in most browsers only if the URL
    points to an embedded SVG inside the same document as the clipped element. External
    SVGs are not supported. Firefox is the only browser supporting clip paths from
    external SVGs.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年底，基于URL的裁剪路径仅在大多数浏览器中工作，前提是URL指向与裁剪元素相同文档中的嵌入式SVG。不支持外部SVG。Firefox是唯一支持来自外部SVG的裁剪路径的浏览器。
- en: The rest of the values are either shapes written in CSS, reference boxes, or
    both.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的值要么是用CSS编写的形状，要么是参考框，或者两者都有。
- en: Clip Shapes
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 裁剪形状
- en: 'You can define clip shapes with one of a set of four simple shape functions.
    These are identical to the shape functions used to define float shapes with `shape-outside`,
    so we won’t redescribe them in detail here. Here’s a brief recap:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用四个简单形状函数之一定义裁剪形状。这些与用于定义浮动形状的形状函数相同，因此我们在此不会详细描述它们。这里是一个简要回顾：
- en: '`inset()`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`inset()`'
- en: Accepts from one to four lengths or percentage values, defining offsets from
    the edges of the bounding box, with optional corner rounding via the `round` keyword
    and another set of one to four lengths or percentages.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 接受从一个到四个长度或百分比值，定义与边界框边缘的偏移量，并通过`round`关键字和另一组从一个到四个长度或百分比值可选地圆角化角。
- en: '`circle()`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`circle()`'
- en: Accepts a single length, percentage, or keyword defining the radius of the circle,
    with an optional position for the circle’s center with the `at` keyword followed
    by one or two lengths or percentages.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 接受一个长度、百分比或关键字，定义圆的半径，还可以用`at`关键字后跟一个或两个长度或百分比来定义圆的中心位置。
- en: '`ellipse()`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`ellipse()`'
- en: Accepts a mandatory two lengths, percentages, or keywords defining the radii
    of the vertical and horizontal axes of the ellipse, with an optional position
    for the ellipse’s center with the `at` keyword followed by one or two lengths
    or percentages.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 接受两个必填的长度、百分比或关键字，定义椭圆垂直和水平轴的半径，还可以用`at`关键字后跟一个或两个长度或百分比来定义椭圆的中心位置。
- en: '`polygon()`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`polygon()`'
- en: Accepts a comma-separated list of space-separated *x* and *y* coordinates, using
    either lengths or percentages. Can be prefaced by a keyword defining the fill
    rule for the polygon.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接受逗号分隔的空格分隔的*x*和*y*坐标列表，使用长度或百分比。可以以定义多边形填充规则的关键字为前缀。
- en: '[Figure 20-37](#clipping-shapes) shows a variety of examples of these clip
    shapes, corresponding to the following styles:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 20-37](#clipping-shapes)展示了这些剪切形状的多种示例，对应以下样式：'
- en: '[PRE32]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![css5 2038](assets/css5_2038.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2038](assets/css5_2038.png)'
- en: Figure 20-37\. Various clip shapes
  id: totrans-380
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-37\. 各种剪切形状
- en: As [Figure 20-37](#clipping-shapes) shows, the elements are visible only inside
    the clip shapes. Anything outside that is just gone. But note that the clipped
    elements still take up the same space they would if they weren’t clipped at all.
    In other words, clipping doesn’t make the elements smaller. It just limits the
    part of them that’s actually drawn.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 20-37](#clipping-shapes)所示，元素只在剪切形状内可见。超出其范围的部分则消失了。但请注意，被剪切的元素仍然占据了它们本来要占据的空间。换句话说，剪切并不会使元素变小，它只是限制了实际绘制的部分。
- en: Clip Boxes
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪切框
- en: Unlike clip shapes, clip boxes aren’t specified using lengths or percentages.
    They correspond, for the most part, directly to boundaries in the box model.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于剪切形状，剪切框并不使用长度或百分比来指定。它们在很大程度上直接对应于盒模型中的边界。
- en: 'If you just write `clip-path: border-box`, for example, the element is clipped
    along the outside edge of the border. This is likely what you’d expect anyway,
    since margins are transparent. Remember, however, that outlines can be drawn outside
    borders, so if you *do* clip at the border edge, any outlines will be clipped
    away. That includes any outlines, which can create a major accessibility problem,
    so be very careful clipping any element that can receive focus. (You probably
    just shouldn’t do it in those cases.)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '如果只写`clip-path: border-box`，例如，元素会被剪切到边框的外边缘。这很可能是您所期望的，因为边距是透明的。然而，请记住，轮廓可以在边框外绘制，因此如果在边框边缘剪切，任何轮廓都将被剪切掉。这包括任何轮廓，这可能会导致重大的可访问性问题，因此在可以接收焦点的任何元素上进行剪切时要非常小心。（在这些情况下，您可能根本不应该这样做。）'
- en: When used by themselves, the values `margin-box`, `padding-box`, and `content-box`
    dictate that the clipping occurs at the outer edges of the margin, padding, or
    content areas, respectively. These are diagrammed in [Figure 20-38](#clipping-boxes).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当单独使用`margin-box`、`padding-box`和`content-box`值时，剪切发生在外边距、内边距或内容区域的外边缘。这些在[图 20-38](#clipping-boxes)中有示意图。
- en: '![css5 2039](assets/css5_2039.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2039](assets/css5_2039.png)'
- en: Figure 20-38\. Various clipping boxes
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-38\. 各种剪切框
- en: 'There’s another part to [Figure 20-38](#clipping-boxes), which shows the SVG
    bounding boxes:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 还有[图 20-38](#clipping-boxes)的另一部分，展示了SVG边界框：
- en: '`view-box`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`view-box`'
- en: The nearest (the closest ancestor) SVG viewport is used as the clipping box.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的（最接近的祖先）SVG视口被用作剪切框。
- en: '`fill-box`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill-box`'
- en: The *object bounding box* is used as the clipping box. The object bounding box
    is the smallest box that will fit every part of the element’s geometry, taking
    into account any transformations (e.g., rotation), not including any strokes along
    its outside.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象边界框*用作剪切框。对象边界框是适合元素几何的最小框，考虑到任何变换（例如旋转），但不包括沿其外部的任何描边。'
- en: '`stroke-box`'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`stroke-box`'
- en: The *stroke bounding box* is used as the clipping box. Similar to the fill box,
    the stroke box is the smallest box that will fit every part of the element’s geometry,
    taking into account any transformations (e.g., rotation), but the stroke box includes
    any strokes along its outside.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*描边边界框*用作剪切框。与填充框类似，描边框是适合元素几何的最小框，考虑到任何变换（例如旋转），但描边框包括沿其外部的任何描边。'
- en: These values apply only to SVG elements that don’t have an associated CSS layout
    box. For such elements, if the CSS-style boxes (`margin-box`, `border-box`, `padding-box`,
    `content-box`) are given, `fill-box` is used instead. Conversely, if one of the
    SVG bounding box values is applied to an element that *does* have a CSS layout
    box—which is most elements—`border-box` is used instead.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值仅适用于没有关联CSS布局框的SVG元素。对于这些元素，如果给定了CSS样式框（`margin-box`、`border-box`、`padding-box`、`content-box`），则使用`fill-box`。相反，如果应用了SVG边界框值之一于*有*CSS布局框的元素（这是大多数元素），则使用`border-box`。
- en: 'It can be useful at times to be able to use something like `clip-path: content-box`
    just to clip away everything outside the content area, but these box values really
    come into their own in conjunction with a clipping shape. Suppose you have an
    `ellipse()` clip shape you want to apply to an element, and furthermore, you want
    to have it just touch the outer edges of the padding box. Rather than have to
    calculate the necessary radii by subtracting margins and borders from the overall
    element, you can just write `clip-path: ellipse(50% 50%) padding-box`. That will
    center an elliptical clip shape at the center of the element, with horizontal
    and vertical radii half the element’s reference box, as shown in [Figure 20-39](#clipping-boxes-ellipse),
    along with the effect of fitting to other boxes.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '有时使用类似 `clip-path: content-box` 这样的东西来裁剪掉内容区域外的所有内容可能很有用，但是这些框值在与裁剪形状结合使用时确实发挥了自己的作用。假设你有一个
    `ellipse()` 裁剪形状要应用于一个元素，并且此外，你希望它刚好触及内边距框的外边缘。而不是必须通过减去边距和边框来计算必要的半径，你可以直接写 `clip-path:
    ellipse(50% 50%) padding-box`。这将在元素的中心处居中一个椭圆形裁剪形状，水平和垂直半径为元素参考框的一半，如 [Figure 20-39](#clipping-boxes-ellipse)
    中所示，同时适配其他框的效果。'
- en: '![css5 2040](assets/css5_2040.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2040](assets/css5_2040.png)'
- en: Figure 20-39\. Fitting an elliptical clip shape to various boxes
  id: totrans-398
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-39\. 将椭圆形裁剪形状适配到各种框中
- en: Notice that the ellipse is cut off in the `margin-box` example? That’s because
    the margin is invisible, so while parts of it fall inside the elliptical clip
    shape, we can’t actually see those parts unless there’s a box shadow or an outset
    border image on the element.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到椭圆在 `margin-box` 示例中被截断了吗？那是因为边距是不可见的，所以虽然部分内容落在椭圆形裁剪区域内，但实际上我们看不到这些部分，除非元素上有阴影或外边框图片。
- en: Interestingly, the bounding-box keywords can be used only in conjunction with
    clip shapes—*not* with an SVG-based clip path. The keywords that relate to SVG
    bounding boxes apply only if an SVG image is being clipped via CSS.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，边界框关键字只能与裁剪形状一起使用，*不能*与基于 SVG 的裁剪路径一起使用。与 SVG 边界框相关的关键字仅在通过 CSS 裁剪 SVG
    图像时应用。
- en: Clipping with SVG Paths
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SVG 路径进行裁剪
- en: 'If you happen to have an SVG path handy, or you’re comfortable writing your
    own, you can use it to define the clipping shape in the `clip-path` property.
    The syntax looks like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你恰好有一个 SVG 路径方便使用，或者你对自己编写路径感到舒适，你可以将其用于定义 `clip-path` 属性中的裁剪形状。语法如下：
- en: '[PRE33]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Replace that ellipsis with the contents of an SVG `d` or `points` attribute,
    and that will give you a clipping shape. Here’s an example of such an attribute:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 用 SVG 的 `d` 或 `points` 属性替换那个省略号，这将给你一个裁剪形状。以下是这种属性的示例：
- en: '[PRE34]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will draw a diamond from the point at *x*=500, *y*=0 to *x*=1000, *y*=250,
    and so on, forming a diamond shape 1,000 pixels across by 500 high. If applied
    to an image exactly 1,000 pixels by 500 pixels, you’d get the result shown in
    [Figure 20-40](#clipping-svg-path).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从点 *x*=500，*y*=0 开始绘制一个菱形，直到 *x*=1000，*y*=250，等等，形成一个宽度为 1,000 像素，高度为 500
    像素的菱形。如果应用于精确为 1,000 像素乘以 500 像素的图像，你将得到 [Figure 20-40](#clipping-svg-path) 中显示的结果。
- en: '![css5 2041](assets/css5_2041.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2041](assets/css5_2041.png)'
- en: Figure 20-40\. An image clipped with an SVG clip path
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-40\. 使用 SVG 裁剪路径裁剪的图像
- en: 'You’d get the same clip shape shown in [Figure 20-40](#clipping-svg-path) by
    using the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容可以得到与 [Figure 20-40](#clipping-svg-path) 中显示的相同的裁剪形状：
- en: '[PRE35]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The difference here is that the clipping path defined with percentage values
    in a polygon is a lot more robust than one that requires images to be exactly
    1,000 pixels wide by 500 pixels tall. That’s because, as of late 2022, all SVG
    path coordinates are expressed in absolute units, and can’t be declared as percentages
    of the image’s height and width as the `polygon()` shape can.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的区别在于，在多边形中使用百分比值定义的裁剪路径要比要求图像精确为 1,000 像素宽和 500 像素高的路径坐标更为强大。这是因为截至 2022
    年末，所有 SVG 路径坐标都以绝对单位表示，不能像 `polygon()` 形状那样声明为图像高度和宽度的百分比。
- en: Note
  id: totrans-412
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This has been a necessarily very brief spotlight on the ability to use SVG paths
    in CSS, as describing all the ways paths can be shaped is far beyond the scope
    of this book. If you want to know more, we recommend reading [*Using SVG with
    CSS3 & HTML5*](https://learning.oreilly.com/library/view/using-svg-with/9781491921968)
    by Amelia Bellamy-Royds et al. (O’Reilly).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对在 CSS 中使用 SVG 路径能力的简要介绍，因为描述路径形状的所有方式远远超出了本书的范围。如果你想了解更多，请阅读 [*Using SVG
    with CSS3 & HTML5*](https://learning.oreilly.com/library/view/using-svg-with/9781491921968)
    一书，作者是 Amelia Bellamy-Royds 等人（O’Reilly）。
- en: Masks
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蒙版
- en: 'When we say *mask*, at least in this context, we mean a shape inside of which
    things are visible, and outside of which they are not. Masks are thus very similar
    in concept to clipping paths. The primary differences are twofold: first, with
    masks you can only use an image to define the areas of the element that are shown
    or clipped away; and second, a lot more properties are available to use with masks,
    allowing you to do things such as position, size, and repeat the masking image.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 *遮罩* 时，至少在这个上下文中，我们指的是一个形状，内部的东西是可见的，而外部是不可见的。因此，遮罩在概念上与裁剪路径非常相似。主要的区别有两点：首先，使用遮罩时，您只能使用图像来定义显示或裁剪的元素区域；其次，有更多的属性可用于遮罩，允许您执行诸如位置、大小和重复遮罩图像等操作。
- en: Warning
  id: totrans-416
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, the Chromium familiy supports most of the masking properties,
    but only with the `-webkit-` prefix. So instead of `mask-image`, for example,
    Chrome and Edge support `-webkit-mask-image` instead.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2022 年底，Chromium 家族支持大多数遮罩属性，但仅支持 `-webkit-` 前缀。因此，例如，Chrome 和 Edge 支持 `-webkit-mask-image`
    而非 `mask-image`。
- en: Defining a Mask
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义遮罩
- en: The first step to applying a mask is to point to the image that you’ll be using
    to define the mask. This is accomplished with `mask-image`, which accepts any
    image type.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 应用遮罩的第一步是指向用于定义遮罩的图像。这通过 `mask-image` 实现，可以接受任何类型的图像。
- en: Assuming the image reference is valid, `mask-image` will give the browser an
    image to use as a mask for the element to which it’s being applied.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 假设图像引用有效，`mask-image` 将为浏览器提供要用作遮罩的图像。
- en: 'We’ll start with a simple situation: one image applied to another, where both
    are the same height and width. [Figure 20-41](#masks-image-simple) shows two images
    separately, along with the first image being masked by the second.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的情况开始：将一个图像应用于另一个图像，两者高度和宽度相同。[Figure 20-41](#masks-image-simple) 显示了两张单独的图像，同时第一张图像被第二张图像遮罩。
- en: '![css5 2042](assets/css5_2042.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2042](assets/css5_2042.png)'
- en: Figure 20-41\. A simple image mask
  id: totrans-423
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-41\. 一个简单的图像遮罩
- en: As the figure shows, in the parts of the second image that are opaque, the first
    image is visible. In the parts that are transparent, the first image is not visible.
    For the parts that are semitransparent, the first image is also semitransparent.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，第二张图像中不透明部分显示第一张图像，透明部分则不显示。半透明部分则同时显示第一张图像的半透明效果。
- en: 'Here’s the basic code for the end result shown in [Figure 20-41](#masks-image-simple):'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成 [Figure 20-41](#masks-image-simple) 所示结果的基本代码：
- en: '[PRE36]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: CSS doesn’t require that you apply mask images only to other images, though.
    You can mask pretty much any element with an image, and that image can be a raster
    image (GIF, JPG, PNG) or a vector image (SVG). The latter is usually a better
    choice, if available. You can even construct your own image with gradients, whether
    linear or radial, repeated or otherwise.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 并不要求您仅将遮罩图像应用于其他图像。您可以将几乎任何元素与图像一起使用作为遮罩，该图像可以是光栅图像（GIF、JPG、PNG）或矢量图像（SVG）。如果有选择，后者通常是更好的选择。您甚至可以使用渐变构建自己的图像，无论是线性还是径向，重复或其他方式。
- en: 'The following styles will have the result shown in [Figure 20-42](#masks-image-variety):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 下列样式将显示为 [Figure 20-42](#masks-image-variety) 所示：
- en: '[PRE37]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![css5 2043](assets/css5_2043.png)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2043](assets/css5_2043.png)'
- en: Figure 20-42\. A variety of image masks
  id: totrans-431
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-42\. 多样的图像遮罩
- en: 'An important point to keep in mind is that when a mask clips away pieces of
    an element, it clips away *all* pieces. The best example of this occurs when you
    apply an image that clips away the outer edges of elements, and the markers on
    list items can very easily become invisible. [Figure 20-43](#masks-image-listitems)
    shows an example, which is the result of the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，当遮罩剪裁元素的部分时，它会将 *所有* 部分都裁剪掉。最好的例子是，当您应用一个遮罩图像来剪裁元素的外边缘时，列表项上的标记很容易变得不可见。[Figure 20-43](#masks-image-listitems)
    显示了一个示例，这是以下操作的结果：
- en: '[PRE38]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![css5 2044](assets/css5_2044.png)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2044](assets/css5_2044.png)'
- en: Figure 20-43\. A PNG with areas of transparency masking an unordered list
  id: totrans-436
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-43\. 一个 PNG 图像，其中透明区域遮罩了一个无序列表
- en: 'One other value option enables you to point directly at a `<mask>` element
    in SVG to use the mask it defines. This is analogous to pointing to a `<clipPath>`
    or other SVG element from the property `clip-path`. Here’s an example of how a
    mask might be defined:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项允许您直接指向 SVG 中的 `<mask>` 元素来使用它定义的遮罩。这类似于从属性 `clip-path` 指向 `<clipPath>`
    或其他 SVG 元素。以下是遮罩的定义示例：
- en: '[PRE40]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With that SVG embedded in the HTML file directly, the mask can be referenced
    like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 将 SVG 直接嵌入到 HTML 文件中时，可以像这样引用该遮罩：
- en: '[PRE41]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If the SVG is in an external file, this is how to reference it from CSS:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SVG 在外部文件中，可以通过以下方式从 CSS 中引用它：
- en: '[PRE42]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The difference between using an image as a mask versus an SVG `<mask>` is that
    SVG masking is based on luminance, rather than alpha transparency. This difference
    can be inverted with the `mask-mode` property.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图像作为遮罩与使用 SVG `<mask>` 的不同之处在于，SVG 遮罩是基于亮度而不是 alpha 透明度的。可以通过 `mask-mode`
    属性来反转这种差异。
- en: Changing the Mask’s Mode
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改遮罩的模式
- en: You’ve just seen the two ways to use an image as a mask. Masking is accomplished
    by applying an image with an alpha channel to another element. Masking can also
    be done by using the brightness of each part of the masking image to define the
    mask. Switching between these two options is accomplished with the `mask-mode`
    property.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才已经看到两种将图像用作遮罩的方法。通过将带有 alpha 通道的图像应用于另一个元素来实现遮罩。还可以通过使用遮罩图像的每个部分的亮度来定义遮罩。使用
    `mask-mode` 属性可以在这两种选项之间切换。
- en: 'Two of the three values are straightforward: `alpha` means the alpha channel
    of the image should be used to compute the mask, and `luminance` means the brightness
    levels should be used. The difference is illustrated in [Figure 20-44](#masks-mode),
    which is the result of the following code:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 三个值中的两个值很直观：`alpha` 意味着应使用图像的 alpha 通道来计算遮罩，而 `luminance` 意味着应使用亮度级别。差异在于 [图
    20-44](#masks-mode) 中有所体现，该图是以下代码的结果：
- en: '[PRE43]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When `luminance` is used to calculate the mask, brightness is treated the same
    way alpha values are in alpha masking. Consider how alpha masking works: any part
    of the image with opacity of 0 hides that part of the masked element. A part of
    the image with opacity of 1 (fully opaque) reveals that part of the masked element.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `luminance` 计算遮罩时，亮度处理方式类似于使用 alpha 值进行遮罩。考虑 alpha 值遮罩的工作方式：任何不透明度为0的部分会隐藏被遮罩元素的相应部分。不透明度为1的部分（完全不透明）显示被遮罩元素的相应部分。
- en: 'The same is true with luminance-based masking. A part of the mask with luminosity
    of 1 reveals that part of the masked element. A part of the mask with luminosity
    of 0 (fully black) hides that part of the masked element. But note that any fully
    transparent part of the mask is *also* treated as having a luminance of 0\. This
    is why the shadow portion of the theater-mask image doesn’t show any part of the
    masked image: its alpha value is greater than 0.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 基于亮度的遮罩处理也是如此。亮度为1的遮罩部分显示被遮罩元素的相应部分。亮度为0（完全黑色）的遮罩部分隐藏被遮罩元素的相应部分。但要注意，任何完全透明的遮罩部分*也*被视为亮度为0。这就是为什么剧场面具图像的阴影部分不显示任何遮罩图像的原因：其
    alpha 值大于0。
- en: '![css5 2045](assets/css5_2045.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2045](assets/css5_2045.png)'
- en: Figure 20-44\. Alpha and luminance mask modes
  id: totrans-452
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-44。Alpha 和亮度遮罩模式
- en: 'The third (and default) value, `match-source`, is a combination of `alpha`
    and `luminance`, choosing between them based on the actual source image for the
    mask as follows:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个（也是默认的）数值是 `match-source`，结合了 `alpha` 和 `luminance`，根据实际的源图像来选择使用哪一个，如下所示：
- en: If the source is a type of <*`image`*>, use `alpha`. The <*`image`*> can be
    an image such as a PNG or visible SVG, a CSS gradient, or a piece of the page
    referred to by the `element()` function.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果源是 <*`image`*> 类型，则使用 `alpha`。 <*`image`*> 可以是诸如 PNG 或可见 SVG、CSS 渐变或通过 `element()`
    函数引用的页面部分的图像。
- en: If the source is an SVG `<mask>` element, use `luminance`.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果源是 SVG `<mask>` 元素，则使用 `luminance`。
- en: Sizing and Repeating Masks
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整和重复遮罩
- en: Thus far, nearly all the examples have been carefully crafted to make each mask’s
    size match the size of the element it’s masking. (This is why we keeping applying
    masks to images.) In many cases, mask images may be a different size than the
    masked element. CSS has a couple of ways to deal with this, starting with `mask-size`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，几乎所有的示例都经过精心设计，以使每个遮罩的大小与其遮罩的元素大小相匹配。（这就是为什么我们一直将遮罩应用于图像。）在许多情况下，遮罩图像的大小可能与被遮罩元素的大小不同。CSS
    有几种处理方式，从 `mask-size` 开始。
- en: 'If you’ve ever sized background images, you know exactly how to size masks,
    because the value syntax is *exactly* the same, as are the behaviors. As an example,
    consider the following styles, which have the result shown in [Figure 20-45](#masks-sizing):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经调整过背景图像的尺寸，那么你完全知道如何调整遮罩的尺寸，因为值的语法*完全*相同，行为也是如此。例如，考虑下面的样式，其效果如 [图 20-45](#masks-sizing)
    所示：
- en: '[PRE45]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![css5 2046](assets/css5_2046.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2046](assets/css5_2046.png)'
- en: Figure 20-45\. Sizing masks
  id: totrans-461
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-45。调整遮罩尺寸
- en: Again, these should be immediately familiar to you if you’ve ever sized backgrounds.
    If not, see [“Sizing Background Images”](ch08.html#sizing-background-images) for
    a more detailed exploration of the possibilities.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经调整过背景大小，这些应该马上就能让你熟悉起来。如果没有，详细了解[“调整背景图片大小”](ch08.html#sizing-background-images)以探索更多可能性。
- en: In a like vein, just as the pattern of backgrounds repeating throughout the
    background area of the element can be changed or suppressed, mask images can be
    affected with `mask-repeat`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如背景的模式可以通过`background-repeat`进行更改或抑制一样，遮罩图像也可以通过`mask-repeat`受到影响。
- en: 'The values available here are the same as those for `background-repeat`. [Figure 20-46](#masks-repeat)
    shows some examples, based on the following styles:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的值与`background-repeat`相同。图 [20-46](#masks-repeat) 展示了一些示例，基于以下样式：
- en: '[PRE46]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![css5 2047](assets/css5_2047.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2047](assets/css5_2047.png)'
- en: Figure 20-46\. Repeating masks
  id: totrans-467
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-46\. 重复遮罩
- en: Positioning Masks
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位遮罩
- en: Given that sizing and repetition of mask images mirrors the sizing and repetition
    of background images, you might think that the same is true for positioning the
    origin mask image, similar to `background-position`, as well as the origin box,
    similar to `background-origin`. And you’d be exactly right.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于遮罩图像的大小和重复与背景图像的大小和重复相似，您可能会认为定位原始遮罩图像的方法与`background-position`类似，以及原点框的定义与`background-origin`类似。而这一切都是正确的。
- en: 'Once again, if you’ve ever positioned a background image, you know how to position
    mask images. Following are a few examples, illustrated in [Figure 20-47](#masks-position):'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经定位过背景图像，那么您就知道如何定位遮罩图像。以下是几个示例，详见[图 20-47](#masks-position)：
- en: '[PRE47]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![css5 2048](assets/css5_2048.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2048](assets/css5_2048.png)'
- en: Figure 20-47\. Positioning masks
  id: totrans-473
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-47\. 定位遮罩
- en: By default, the origin box for mask images is the outer border edge. If you
    want to move it further inward, or define a specific origin box in an SVG context,
    then `mask-origin` does for masks what `background-origin` does for backgrounds.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，遮罩图像的原点框是外边框边缘。如果您希望将其移动到更深的内部，或在SVG上下文中定义特定的原点框，则`mask-origin`的作用类似于背景的`background-origin`。
- en: For the full story, see [“Changing the positioning box”](ch08.html#changing-the-positioning-box),
    but for a quick example, see [Figure 20-48](#masks-origin).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解完整内容，请参阅[“更改定位框”](ch08.html#changing-the-positioning-box)，但快速示例请参见[图 20-48](#masks-origin)。
- en: '![css5 2049](assets/css5_2049.png)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2049](assets/css5_2049.png)'
- en: Figure 20-48\. Changing the origin box
  id: totrans-477
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-48\. 更改原点框
- en: Clipping and Compositing Masks
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 裁剪和合成遮罩
- en: One more property echoes backgrounds, and that’s `mask-clip`, the mask equivalent
    of `background-clip`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个属性与背景相似，那就是`mask-clip`，遮罩版本的`background-clip`。
- en: 'All this does is clip the overall mask to a specific area of the masked element.
    In other words, it restricts the area in which the visible parts of the element
    are in fact visible. [Figure 20-49](#masks-clip) shows the result of the following
    styles:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作只是将整体遮罩剪裁到受遮罩元素的特定区域。换句话说，它限制了元素可见部分的显示区域。[图 20-49](#masks-clip)展示了以下样式的结果：
- en: '[PRE48]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![css5 2050](assets/css5_2050.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2050](assets/css5_2050.png)'
- en: Figure 20-49\. Clipping the mask
  id: totrans-483
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-49\. 裁剪遮罩
- en: The last longhand masking property, `mask-composite`, is quite interesting because
    it can radically change the way multiple masks interact.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个长手遮罩属性`mask-composite`非常有趣，因为它可以根本改变多个遮罩之间的相互作用方式。
- en: Warning
  id: totrans-485
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of early 2023, `mask-composite` is supported only by Firefox, but all browsers
    (even Firefox) support the prefixed form `-webkit-mask-composite`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2023年初，`mask-composite`仅由Firefox支持，但所有浏览器（包括Firefox）都支持前缀形式`-webkit-mask-composite`。
- en: If you are not familiar with compositing operations, a diagram is in order.
    See [Figure 20-50](#masks-composite-diagram).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对合成操作不熟悉，需要看一张图解。请参阅[图 20-50](#masks-composite-diagram)。
- en: '![css5 2051](assets/css5_2051.png)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2051](assets/css5_2051.png)'
- en: Figure 20-50\. Compositing operations
  id: totrans-489
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-50\. 合成操作
- en: The image on top in the operation is called the *source*, and the image beneath
    it is called the *destination*.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作中位于顶部的图像称为*源图像*，而底部的图像称为*目标图像*。
- en: 'This doesn’t particularly matter for three of the four operations: `add`, `intersect`,
    and `exclude`, all of which have the same result regardless of which image is
    the source and which the destination. But for `subtract`, the question is: which
    image is being subtracted from which? The answer: the destination is subtracted
    from the source.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 对于四种操作中的三种操作，即 `add`、`intersect` 和 `exclude`，无论图像是源还是目标，其结果都相同。但对于 `subtract`，问题是：从哪个图像中减去哪个？答案是：从目标中减去源。
- en: The distinction between source and destination also becomes important when compositing
    multiple masks together. In these cases, the compositing order is from back to
    front, with each succeeding layer being the source and the already-composited
    layers beneath it being the destination.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合多个蒙版时，源和目标之间的区分也变得重要。在这些情况下，组合顺序是从后到前，每个后续层都是源，其下面已经组合好的层是目标。
- en: To see why, consider [Figure 20-51](#masks-composite-multiple), which shows
    the various ways three overlapping masks are composited together, and how results
    change with changes to their order and compositing operations.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解原因，请考虑 [图 20-51](#masks-composite-multiple)，它显示了三个重叠蒙版如何组合在一起，以及随着其顺序和组合操作的更改，结果如何变化。
- en: The figure is constructed to show the bottommost mask at the bottom, the topmost
    above the other two, and the resulting mask at the very top. Thus, in the first
    column, the triangle and circle are composited with an exclusion operation. The
    resulting shape is then composited with the square using an additive operation.
    That results in the mask shown at the top of the first column.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图形被构造成将最底部的蒙版放在底部，最顶部的放在其他两个之上，并将结果蒙版放在最顶部。因此，在第一列中，三角形和圆形通过排除操作进行组合。然后，使用加法操作将结果形状与正方形组合。这导致了显示在第一列顶部的蒙版。
- en: 'Just remember that when doing a subtraction composite, the bottom shape is
    subtracted from the shape above it. Thus, in the third column, the addition of
    the triangle and circle is subtracted from the square above them. This is accomplished
    with `mask-composite: add, subtract`.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '只需记住，在进行减法复合时，底部形状从位于其上方的形状中减去。因此，在第三列中，三角形和圆形的加法被从它们上方的正方形中减去。这通过 `mask-composite:
    add, subtract` 来实现。'
- en: '![css5 2052](assets/css5_2052.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2052](assets/css5_2052.png)'
- en: Figure 20-51\. Compositing masks
  id: totrans-497
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-51\. 复合蒙版
- en: Bringing It All Together
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容结合起来
- en: All of the preceding mask properties are brought together in the shorthand property
    `mask`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述的蒙版属性都汇集在简写属性 `mask` 中。
- en: Like all the other masking properties, `mask` accepts a comma-separated list
    of masks. The order of the values in each mask can be anything except for the
    mask size, which always follows the position and is separated from it by a forward
    slash (`/`).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有其他蒙版属性一样，`mask` 接受一个逗号分隔的蒙版列表。每个蒙版中的值的顺序可以是任意的，除了蒙版尺寸，它始终跟随位置，并由斜杠（`/`）分隔。
- en: 'Thus, the following rules are equivalent:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下规则是等效的：
- en: '[PRE49]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The triangle and square are added together, and then the result of that additive
    composite is subtracted from the circle. The result is shown in [Figure 20-52](#masks-multiple)
    as applied to a square element (the teal shape on the left) and a shape wider
    than it is tall (the goldenrod shape on the right).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形和正方形被加在一起，然后将这个加性复合物的结果从圆形中减去。结果显示在 [图 20-52](#masks-multiple) 中，应用于一个正方形元素（左侧的青色形状）和一个宽于高的形状（右侧的金黄色形状）。
- en: '![css5 2053](assets/css5_2053.png)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2053](assets/css5_2053.png)'
- en: Figure 20-52\. Two masks
  id: totrans-505
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-52\. 两个蒙版
- en: Setting Mask Types
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置蒙版类型
- en: When you’re using CSS to style SVG elements, and you want to set the SVG `<mask>`
    type, then `mask-type` is for you.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 CSS 样式化 SVG 元素，并且希望设置 SVG `<mask>` 类型时，`mask-type` 就派上用场了。
- en: This property is similar to `mask-mode`, except there is no `match-source` equivalent.
    You can choose only `luminance` or `alpha`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性类似于 `mask-mode`，只是没有 `match-source` 的等效项。您只能选择 `luminance` 或 `alpha`。
- en: 'The interesting thing is that if `mask-type` is set for a `<mask>` element
    that’s used to mask an element, and `mask-mode` is declared for that masked element,
    `mask-mode` wins. As an example, consider the following rules:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果为用于掩蔽元素的 `<mask>` 元素设置了 `mask-type`，并且为该掩蔽元素声明了 `mask-mode`，则 `mask-mode`
    优先。例如，请考虑以下规则：
- en: '[PRE50]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Given these rules, the masked images will have a mask with luminance compositing,
    not alpha compositing. If the `mask-mode` value were left at its default value,
    `match-source`, then `mask-type`’s value would be used instead.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些规则，遮罩图像将具有亮度合成的遮罩，而不是alpha合成。如果`mask-mode`值保持默认值`match-source`，那么将使用`mask-type`的值。
- en: Border-Image Masking
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边框图像遮罩
- en: The same specification that defines clipping paths and element masking, CSS
    Masking, also defines properties that are used to apply masking images in a way
    that mirrors border-image properties. In fact, with one exception, the properties
    between border images and border masks are direct analogues, and the values the
    same. Refer to [“Image Borders”](ch07.html#image-borders) for a detailed explanation
    of how these work, but here are some quick recaps.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 定义剪切路径和元素遮罩的同一规范，CSS遮罩也定义了用于以与边框图像属性相似的方式应用遮罩图像的属性。实际上，除了一个例外，边框图像和边框遮罩之间的属性是直接对应的，值也相同。请参考[“图像边框”](ch07.html#image-borders)以了解这些属性的工作原理，但这里有一些快速回顾。
- en: 'Remember that without having a border of some sort, none of these properties
    will have any visible effect. To apply a border and then mask it, you must first
    declare a border’s style, at a minimum. If you intend your masked border to be
    10 pixels wide, you would need something like this:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果没有任何边框，这些属性将不会产生任何可见效果。要应用边框然后对其进行遮罩，您必须首先声明边框的样式，至少是这样。如果您打算使遮罩边框宽度为10像素，您需要类似以下内容：
- en: '[PRE51]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once that’s been established, you can begin masking the border.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了这一点，您就可以开始遮罩边框。
- en: Note
  id: totrans-517
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'As of late 2022, all these properties are supported in Chromium and WebKit
    browsers as `-webkit-mask-box-image-*` instead of the names used in the specification.
    The actually supported names are noted in the property summary boxes that follow,
    but examples use the standard (unprefixed) property names. Also note: as of this
    writing, the Gecko (Firefox) family does not support border masks in any form.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年底，所有这些属性在Chromium和WebKit浏览器中都支持`-webkit-mask-box-image-*`，而不是规范中使用的名称。实际支持的名称在接下来的属性摘要框中有说明，但示例使用标准（无前缀）属性名称。另请注意：截至目前，Gecko（Firefox）系列不支持任何形式的边框遮罩。
- en: The `mask-border-source` property specifies the image to be used as a mask.
    This can be a URL, gradient, or other supported <*`image`*> value type. Once the
    masking image has been set up, you can move on to doing things like slicing it
    into sections, defining a distinct width for the mask, and so on.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask-border-source`属性指定要用作遮罩的图像。这可以是URL、渐变或其他支持的<*`image`*>值类型。一旦设置了遮罩图像，您可以继续进行诸如将其切片成部分、为遮罩定义独特宽度等操作。'
- en: 'The `mask-border-slice` property establishes a set of four slice-lines that
    are laid over the border, and where they fall determines how the mask will be
    sliced up for use in each of the eight parts of the border area: the top, right,
    bottom, and left edges, as well as the top-left, top-right, bottom-right, and
    bottom-left corners. The property takes up to four values, defining (in order)
    offsets from the top, right, bottom, and left edges.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask-border-slice`属性建立了一组四个切片线，这些线覆盖在边框上，它们的位置决定了遮罩将如何被切片用于边框区域的八个部分：顶部、右侧、底部和左侧边缘，以及左上、右上、右下和左下角。该属性最多接受四个值，按顺序定义从顶部、右侧、底部和左侧边缘的偏移量。'
- en: Note
  id: totrans-521
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As of late 2022, no logical-property equivalent exists for `mask-border-slice`.
    If the proposed addition of a `logical` keyword, or something equivalent, to this
    property is ever adopted and implemented, at that point it will be possible to
    use `mask-border-slice` in a writing-flow-relative fashion.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年底，`mask-border-slice`没有逻辑属性等效项。如果对此属性的提议添加`logical`关键字或类似内容被采纳并实施，那么将可以以书写流相对方式使用`mask-border-slice`。
- en: 'Consider the following, diagrammed in [Figure 20-53](#mask-border-patterns):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容，在[图20-53](#mask-border-patterns)中有示意图：
- en: '[PRE52]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![css5 2054](assets/css5_2054.png)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2054](assets/css5_2054.png)'
- en: Figure 20-53\. Some mask border-slicing patterns
  id: totrans-526
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-53。一些遮罩边框切片模式
- en: You might think that numeric offsets need to be given a length unit to define
    a distance, but this is not so. Number values are interpreted in the coordinate
    system of the image used for the mask. With a raster image like a PNG, the coordinate
    system will be the pixels of the image. In an SVG image, the coordinate system
    defined by the SVG file is used.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为数值偏移需要给定长度单位来定义距离，但实际情况并非如此。数字值在用于遮罩的图像坐标系统中进行解释。对于像PNG这样的光栅图像，坐标系统将是图像的像素。在SVG图像中，则使用SVG文件定义的坐标系统。
- en: 'Using the optional `fill` keyword causes the center portion of the mask image
    to be applied to the element inside the border area. By default, it is not used,
    allowing the element’s padding and content to be fully seen. If you do use it
    by adding `fill`, the part of the mask image inside the four slice lines will
    be stretched over the element’s content and padding, and applied to them. Consider
    the following, illustrated in [Figure 20-54](#mask-border-fill):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选的`fill`关键字会导致遮罩图像的中心部分应用到边框区域内的元素上。默认情况下，它不会被使用，允许元素的填充和内容完全可见。如果你通过添加`fill`来使用它，则遮罩图像在四个切片线内的部分将被拉伸到元素的内容和填充上，并应用到它们上。请参考下面的说明，图示在[图20-54](#mask-border-fill)中。
- en: '[PRE53]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![css5 2055](assets/css5_2055.png)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2055](assets/css5_2055.png)'
- en: Figure 20-54\. Applying the mask fill
  id: totrans-531
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图20-54。应用遮罩填充
- en: Warning
  id: totrans-532
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, a bug in browsers that support the prefixed property causes
    the content and padding of an element to be completely hidden unless the `fill`
    keyword is used. Thus, in order to use border masks and show the content of an
    element, you need to fill the center of the mask image completely, and use `fill`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年底，浏览器中支持前缀属性的错误导致元素的内容和填充完全隐藏，除非使用`fill`关键字。因此，为了使用边框遮罩并显示元素的内容，你需要完全填充遮罩图像的中心，并使用`fill`。
- en: 'This property allows you to define a width (or individual widths) for the four
    edge slices of the border mask. If the slices are not actually the size(s) you
    declare, they will be resized to fit. For example, a masking image might be sliced
    and then sized as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性允许你为边框遮罩的四个边缘切片定义宽度（或单独的宽度）。如果切片实际大小与声明的大小不符，它们将被调整大小以适应。例如，遮罩图像可能会被切片然后按以下方式调整大小：
- en: '[PRE54]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This allows you to slice up the masking image in one way, and then size it as
    needed for the context or define a universal size for masking image, regardless
    of the context in which it appears.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这使你能够以一种方式切割遮罩图像，然后根据上下文需要调整其大小，或者定义一个通用的遮罩图像大小，无论其出现的上下文如何。
- en: With `mask-border-outset`, you can push the mask outside the border area. This
    is useful only if you’re already pushing a border image outside the border area
    with `border-image-outset` and want to also apply the mask to that border image,
    or if you’ve applied an outline to the element and want to mask that as well.
    If neither is true, the masked area outside the border will mask only the margin
    area, which is already transparent and so can’t be visibly altered.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mask-border-outset`，你可以将遮罩推到边框区域外。只有在你已经用`border-image-outset`将边框图像推到边框区域外并希望也将遮罩应用于该边框图像，或者已经对元素应用了轮廓并希望也遮罩它时，这很有用。如果两者都不是真的，则边框外的遮罩区域将仅遮罩边距区域，而该区域已经是透明的，因此不会明显改变。
- en: Warning
  id: totrans-538
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, browsers supporting the prefixed property not only push the
    slices outward, but also expand the center area by the given amount, scaling up
    the masked area covered by the center slice in the process. This behavior is not
    called for or apparently supported by the specifications current as of this writing,
    and is most likely a bug (unless the behavior is eventually made retroactively
    correct by a CSS Working Group decision).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年底，支持前缀属性的浏览器不仅将片段推向外部，还会根据给定的量扩展中心区域，从而放大中心片段覆盖的掩膜区域。此行为在撰写本文时并未调用或显然未得到规范支持，很可能是一个错误（除非此行为最终被CSS工作组决定以回溯方式纠正）。
- en: Thus far, our only example of border masking has used a masking image that is
    an exact fit for the element it’s masking. This is unlikely to be the case, since
    elements can be resized by any number of factors. The default is to stretch each
    slice to fit its part of the border area, but other options are possible. [Figure 20-55](#mask-border-repeating)
    illustrates the options (center areas have been removed for clarity).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们唯一的边框掩码示例使用了一个完全适合其掩码元素的掩码图像。这种情况不太可能发生，因为元素可以被任意数量的因素调整大小。默认情况下，将每个切片拉伸以适应其边框区域的部分，但也可能存在其他选项。[图 20-55](#mask-border-repeating)说明了这些选项（为清晰起见，中心区域已被移除）。
- en: '![css5 2056](assets/css5_2056.png)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2056](assets/css5_2056.png)'
- en: Figure 20-55\. Various kinds of mask image repeating
  id: totrans-542
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-55\. 各种掩码图像重复方式
- en: As shown in [Figure 20-55](#mask-border-repeating), `mask-border-repeat` can
    accept one or two repeat values. If one is given, it’s applied to all sides of
    the border area. If two are given, the first applies to the horizontal sides of
    the border area, and the second to the vertical sides.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 20-55所示，`mask-border-repeat`可以接受一个或两个重复值。如果给出一个，它应用于边框区域的所有边。如果给出两个，则第一个应用于边框区域的水平边，第二个应用于垂直边。
- en: Border masks have one styling aspect that image borders do not, and it’s set
    with the property `mask-border-mode`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 边框掩码具有一种样式方面，即使用`mask-border-mode`属性设置的图像边框没有的。
- en: The `mask-border-mode` property sets whether the masking mode is alpha based,
    or luminance based. For more details on the difference, see the `mask-mode` property
    discussed earlier in the chapter.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask-border-mode`属性设置掩码模式是基于透明度还是亮度。有关差异的更多细节，请参阅本章前面讨论的`mask-mode`属性。'
- en: The property `mask-border` incorporates all of the previous border-masking properties
    into one convenient shorthand.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask-border`属性将所有先前的边框掩码属性合并为一个便捷的简写形式。'
- en: Object Fitting and Positioning
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象适配与定位
- en: One more variety of masking applies solely to replaced elements like images.
    With `object-fit`, you can change the way the replaced element fills its element
    box—or even have it not fill that box completely.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种掩码的变化仅适用于像图像这样的替换元素。使用`object-fit`，你可以改变替换元素填充其元素框的方式 — 或者甚至让它完全不填充该框。
- en: If you’ve ever worked with `background-size`, these values probably look familiar.
    They do similar things, too, only with replaced elements.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过`background-size`，那么这些值可能看起来很熟悉。它们也做类似的事情，只是用于替换元素。
- en: 'For example, assume a 50 × 50 pixel image. We can change its size via CSS with
    something like this:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个50 × 50像素的图像。我们可以通过CSS像这样改变它的大小：
- en: '[PRE55]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The default expectation is that these style declarations will stretch the 50
    × 50 image to be 250 × 150\. And if `object-fit` is its default value, `fill`,
    that’s exactly what happens.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 默认期望是这些样式声明将使50 × 50的图像拉伸为250 × 150。如果`object-fit`是其默认值`fill`，那么确实如此。
- en: 'Change the value of `object-fit`, however, and other behaviors occur. The following
    examples are illustrated in [Figure 20-56](#object-fit):'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`object-fit`的值，将导致其他行为的发生。下面的示例在[图 20-56](#object-fit)中进行了说明：
- en: '[PRE56]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![css5 2057](assets/css5_2057.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2057](assets/css5_2057.png)'
- en: Figure 20-56\. Four kinds of object fitting
  id: totrans-556
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-56\. 四种对象适配方式
- en: In the first instance, `none`, the `<img>` element is drawn 250 pixels wide
    by 150 pixels tall. The image itself, however, is drawn 50 × 50 pixels—its intrinsic
    size—because it was directed to *not* fit the element box. The second instance,
    `fill`, is the default behavior, as mentioned. This is the only value that may
    distort the image, as the dimensions are the element’s dimensions, not the image’s
    intrinsic size.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`none`，`<img>`元素绘制为250像素宽，150像素高。但是图像本身绘制为50 × 50像素（其固有大小），因为它被指定*不*适合元素框。第二个例子中，`fill`，是默认行为，如前所述。这是唯一可能扭曲图像的值，因为尺寸是元素的尺寸，而不是图像的固有大小。
- en: In the third instance, `cover`, the image is scaled up until no part of the
    element box is left “uncovered”—but the image itself keeps its intrinsic aspect
    ratio. In other words, the image stays a square. In this case, the longest axis
    of the `<img>` element is `250px` long, so the image is scaled up to be 250 ×
    250 pixels. That 250 × 250 image is then placed in the 250 × 150 `<img>` element.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，`cover`，图像被缩放直到元素框没有任何部分“未覆盖” — 但图像本身保持其固有的宽高比。换句话说，图像保持为正方形。在这种情况下，`<img>`元素的最长轴是`250px`长，因此图像被放大为250
    × 250像素。然后将该250 × 250图像放置在250 × 150的`<img>`元素中。
- en: The fourth instance, `contain`, is similar, except the image is only big enough
    to touch two sides of the `<img>` element. This means the image is 150 × 150 pixels,
    and placed into the 250 × 150 pixel box of its `<img>` element.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个实例 `contain` 类似，只是图像只大到足以触及 `<img>` 元素的两侧。这意味着图像为 150 × 150 像素，并放置到其 `<img>`
    元素的 250 × 150 像素框中。
- en: To reiterate, what you see in [Figure 20-56](#object-fit) is four `<img>` elements.
    There are no wrapper `<div>` or `<span>` or other elements around those images.
    The border and background color are part of the `<img>` element. The image placed
    inside the `<img>` element is fitted according to `object-fit`. The element box
    of the `<img>` element then acts rather like it’s a simple mask for the fitted
    image inside it. (And then you can mask and clip the element box with the properties
    covered earlier in this chapter.)
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 重申一下，在 [图 20-56](#object-fit) 中所看到的是四个 `<img>` 元素。这些图像周围没有包装器 `<div>`、`<span>`
    或其他元素。边框和背景色是 `<img>` 元素的一部分。放置在 `<img>` 元素内的图像根据 `object-fit` 进行调整。然后，`<img>`
    元素的元素框就像是对其中适合的图像的简单遮罩一样起作用。（然后您可以使用本章早些时候介绍的属性来对元素框进行遮罩和裁剪。）
- en: A fifth value for `object-fit`, not represented in [Figure 20-56](#object-fit),
    is `scale-down`. The meaning of `scale-down` is “do the same as either `none`
    or `contain`, whichever leads to a smaller size.” This lets an image always be
    its intrinsic size unless the `<img>` element gets too small, in which case it’s
    scaled down à la `contain`. This is illustrated in [Figure 20-57](#object-fit-scale-down),
    where each `<img>` element is labeled with the `height` values it’s been given;
    the `width` in each case is `100px`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`object-fit` 的第五个值，未在 [图 20-56](#object-fit) 中表示，是 `scale-down`。`scale-down`
    的意思是“做与 `none` 或 `contain` 相同的事情，以尽可能更小的尺寸为准。” 这使得图像始终保持其固有尺寸，除非 `<img>` 元素变得太小，此时会像
    `contain` 一样缩小。这在 [图 20-57](#object-fit-scale-down) 中有所说明，其中每个 `<img>` 元素都标有其给定的
    `height` 值；每种情况下的 `width` 都为 `100px`。'
- en: '![css5 2058](assets/css5_2058.png)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2058](assets/css5_2058.png)'
- en: Figure 20-57\. Various `scale-down` scenarios
  id: totrans-563
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-57\. 多种 `scale-down` 场景
- en: So if a replaced element is bigger or smaller than the element box into which
    it’s being fit, how can we affect its alignment within that box? Using `object-position`
    is the answer.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果替换元素比其适合的元素框大或小，我们如何影响其在该框内的对齐？使用 `object-position` 就是答案。
- en: 'The value syntax here is just like that for `mask-position` or `background-position`,
    allowing you to position a replaced element within its element box if it isn’t
    set to `object-fit: fill`. Thus, given the following CSS, we get the result shown
    in [Figure 20-58](#object-position):'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '此处的值语法与 `mask-position` 或 `background-position` 相同，允许您在其元素框内定位替换元素，如果未设置为 `object-fit:
    fill` 的话。因此，给定以下 CSS，我们可以得到 [图 20-58](#object-position) 中所示的结果：'
- en: '[PRE57]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![css5 2059](assets/css5_2059.png)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2059](assets/css5_2059.png)'
- en: Figure 20-58\. A variety of `object-position` values
  id: totrans-568
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-58\. 多种 `object-position` 值的示例
- en: Notice that the first example has a value of `50% 50%`, even though that isn’t
    present in the CSS code. That illustrates that the default value of `object-position`
    is `50% 50%`. The next two examples show how various `object-position` values
    move the image around within the `<img>` element box.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个示例中的值是 `50% 50%`，即使在 CSS 代码中没有这个值。这说明 `object-position` 的默认值是 `50% 50%`。接下来的两个示例展示了各种
    `object-position` 值如何在 `<img>` 元素框内移动图像。
- en: As the last example shows, it’s possible to move an unscaled replaced element
    like an image so that it’s partly clipped by its element box. This is similar
    to positioning background images or masks so that they are clipped at the element
    boundaries.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如最后一个示例所示，可以将一个未缩放的替换元素（如图像）移动，使其部分被其元素框裁剪。这类似于将背景图像或蒙版定位，使其在元素边界处被裁剪。
- en: 'It’s also possible to position fitted elements that are larger than the element
    box, as can happen with `object-fit: cover`, although the results can be very
    different than with `object-fit: none`. The following CSS will have results like
    those shown in [Figure 20-59](#object-position-cover):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '对于比元素框大或小的替换元素，例如 `object-fit: cover`，也可以定位，尽管结果可能与 `object-fit: none` 很不同。以下
    CSS 将产生类似 [图 20-59](#object-position-cover) 中所示的结果：'
- en: '[PRE58]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![css5 2060](assets/css5_2060.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![css5 2060](assets/css5_2060.png)'
- en: Figure 20-59\. Positioning a covered object
  id: totrans-574
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-59\. 定位覆盖对象
- en: If any of these results confuse you, review [“Positioning Background Images”](ch08.html#background-positioning)
    for more details.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些结果中有任何让您困惑的地方，请查看[“背景图像定位”](ch08.html#background-positioning)以获取更多详细信息。
- en: Summary
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With all of the effects available to CSS authors, we have an infinite variety
    of outcomes and thus an infinite variety of creative presentation of elements.
    Whether it’s altering elements’ appearances with filters, changing how they’re
    composited with their backdrops, clipping or masking parts of elements, or altering
    the way images fill out their element boxes, there have never been more options
    at your fingertips.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 利用CSS作者可用的所有效果，我们可以获得无限种类的结果，因此可以创造出无限多种元素的创意呈现方式。不论是通过滤镜改变元素的外观，改变元素与背景混合的方式，剪裁或遮罩元素的部分，还是改变图像填充元素框的方式，现在您的选择空前丰富。
