- en: Chapter 20\. Filters, Blending, Clipping, and Masking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Several special properties allow authors to alter the appearance of elements
    with visual filters, specify different ways to visually blend elements with whatever
    is behind them, and alter the presentation of elements by showing parts and hiding
    other parts. While these may seem like disparate concepts, they all share one
    thing in common: they allow elements to be altered in ways that were previously
    difficult or impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: CSS Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS provides a way to apply built-in visual filter effects, as well as custom
    filters defined in the page or in external files, to elements by way of the `filter`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value syntax permits a space-separated list of filter functions, with each
    filter applied in sequence. Thus, given the declaration `filter: opacity(0.5)
    blur(1px);`, the opacity is applied to the element, and the semitransparent result
    is then blurred. If the order is reversed, so too is the order of application:
    the fully opaque element is blurred, and the resulting blur made semitransparent.'
  prefs: []
  type: TYPE_NORMAL
- en: The CSS specification talks of “input images” when discussing `filter`, but
    this doesn’t mean `filter` is used only on images. Any HTML element can be filtered,
    and all graphic SVG elements can be filtered. The *input image* is a visual copy
    of the rendered element *before* it is filtered. Filters are applied to this input,
    and the final filtered result is then rendered to the display medium (e.g., the
    device display).
  prefs: []
  type: TYPE_NORMAL
- en: All the values permitted (save `url()`) are function values, with the permitted
    value types for each function being dependent on the function in question. We’ve
    grouped these functions into a few broad categories for ease of understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following filters are basic in the sense that they cause the changes that
    their names directly describe—blurring, drop shadows, and opacity changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blur(` <*`length`*> `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Blurs the element’s contents by using a Gaussian blur whose standard deviation
    is defined by the <*`length`*> value supplied, where a value of `0` leaves the
    element unchanged. Negative lengths are not permitted.
  prefs: []
  type: TYPE_NORMAL
- en: '`opacity(` [ <*`number`*> | <*`percentage`*> ] `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Applies a transparency filter to the element in a manner very similar to the
    `opacity` property, where the value `0` yields a completely transparent element
    and a value of `1` or `100%` leaves the element unchanged. Negative values are
    not permitted. Values greater than `1` and `100%` are permitted, but are clipped
    to be `1` or `100%` for the purposes of computing the final value.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The specification makes clear that `filter: opacity()` is *not* meant to be
    a replacement or shorthand for the `opacity` property, and in fact both can be
    applied to the same element, resulting in a sort of double-transparency.'
  prefs: []
  type: TYPE_NORMAL
- en: '`drop-shadow(` <*`length`*>{2,3} <*`color`*>? `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a drop shadow that matches the shape of the element’s alpha channel,
    with a blur and using an optional color. The handling of the lengths and colors
    is the same as for the property `box-shadow`, which means that while the first
    two <*`length`*> values can be negative, the third (which defines the blur) cannot.
    Unlike box-shadow, though, the `inset` value is not permitted. To apply multiple
    drop shadows, provide multiple space-separated `drop-shadow()` functions; unlike
    `box-shadow`, comma-separated shadows don’t work here. If no <*`color`*> value
    is supplied, the used color is the same as the computed value of the `color` property
    for the element.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-1](#filter-basic-effects) shows some effects of these filter functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2001](assets/css5_2001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-1\. Basic filter effects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before we go on, two things deserve further exploration. The first is how `drop-shadow()`
    really operates. Just by looking at [Figure 20-1](#filter-basic-effects), it’s
    easy to get the impression that drop shadows are bound to the element box, because
    of the boxlike nature of the drop shadows shown there. But that’s just because
    the image used to illustrate filters is a PNG, which is to say a raster image,
    and more importantly one that doesn’t have any alpha channel. The white parts
    of the image are opaque white, in other words.
  prefs: []
  type: TYPE_NORMAL
- en: If the image has transparent bits, `drop-shadow()` will use those in computing
    the shadow. To see what this means, consider [Figure 20-2](#filter-basic-effects-dropshadows).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2002](assets/css5_2002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-2\. Drop shadows and alpha channels
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The other thing to point out in [Figure 20-2](#filter-basic-effects-dropshadows)
    is the last image has two drop shadows. This was accomplished as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Any number of filters can be chained together like this. To pick another example,
    you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That would get you a blurry, drop-shadowed, half-opaque element. It might not
    be the most reader-friendly effect for text, but it’s possible nonetheless. This
    function-chaining is possible with all `filter` functions, both those you’ve seen
    and those to come.
  prefs: []
  type: TYPE_NORMAL
- en: Color Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This next set of `filter` functions alter the colors present in the element.
    This can be as simple as leaching out the colors, or as complex as shifting all
    the colors by way of an angle value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that for the first three of the four following functions, all of which
    accept either a <*`number`*> or <*`percentage`*>, negative values are not permitted;
    the fourth permits positive and negative angle values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`grayscale(` [ <*`number`*> | <*`percentage`*> ] `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Alters the colors in the element to be shifted toward shades of gray. A value
    of `0` leaves the element unchanged, and a value of `1` or `100%` will result
    in black and white, as a fully grayscale element.
  prefs: []
  type: TYPE_NORMAL
- en: '`sepia(` [ <*`number`*> | <*`percentage`*> ] `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Alters the colors in the element to be shifted toward shades of sepia tones
    (sepia is the reddish-brown color used in antique photography, defined by Wikipedia
    to be equivalent to `#704214` or `rgba(112,66,20)` in the sRGB color space). A
    value of `0` leaves the element unchanged, and a value of `1` or `100%` will result
    in a fully sepia element.
  prefs: []
  type: TYPE_NORMAL
- en: '`invert(` [ <*`number`*> | <*`percentage`*> ] `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Inverts all colors in the element. Each of the R, G, and B values for a given
    color are inverted by subtracting them from 255 (in 0–255 notation) or from 100%
    (in 0%–100% notation). For example, a pixel with the color `rgb(255 128 55)` will
    be rendered as `rgb(0 127 200)`; a different pixel with the value `rgb(75% 57.2%
    23%)` will become `rgb(25% 42.8% 77%)`. A value of `0` leaves the element unchanged,
    and a value of `1` or `100%` results in a fully inverted element. A value of `0.5`
    or `50%` stops the inversion of each color at the midpoint of the color space,
    leading to an element of uniform gray regardless of the input element’s appearance.
  prefs: []
  type: TYPE_NORMAL
- en: '`hue-rotate(` <*`angle`*> `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Alters the colors of the image by shifting their hue angle around an HSL color
    wheel, leaving saturation and lightness unchanged. A value of `0deg` means no
    difference between the input and output images. A value of `360deg` (a full single
    rotation) will also present an apparently unchanged element, though the rotation-angle
    value is maintained. Values above `360deg` are permitted. Negative values are
    also permitted, and cause a counterclockwise rotation as opposed to the clockwise
    rotation caused by positive values. (In other words, the rotation is “compass-style,”
    with 0° at the top and increasing angle values in the clockwise direction.)
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the preceding `filter` functions are shown in [Figure 20-3](#filter-color-effects),
    though fully appreciating them depends on a color rendering.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2003](assets/css5_2003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-3\. Color filter effects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Brightness, Contrast, and Saturation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the following `filter` functions also manipulate color, they do so in
    closely related ways, and are a familiar grouping to anyone who’s worked with
    images, particularly photographic images. For all these functions, values greater
    than `1` and `100%` are permitted, but are clipped to be `1` or `100%` for the
    purposes of computing the final value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`brightness(` [ <*`number`*> | <*`percentage`*> ] `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Alters the brightness of the element’s colors. A value of `0` leaves the element
    a solid black, and a value of `1` or `100%` leaves it unchanged. Values above
    `1` and `100%` yield colors brighter than the input element, and can eventually
    reach a state of solid white.
  prefs: []
  type: TYPE_NORMAL
- en: '`contrast(` [ <*`number`*> | <*`percentage`*> ] `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Alters the contrast of the element’s colors. The higher the contrast, the more
    colors are differentiated from each other; the lower the contrast, the more they
    converge on each other. A value of `0` leaves the element a solid gray, and a
    value of `1` or `100%` leaves it unchanged. Values above `1` and `100%` yield
    colors with greater contrast than is present in the input element.
  prefs: []
  type: TYPE_NORMAL
- en: '`saturate(` [ <*`number`*> | <*`percentage`*> ] `)`'
  prefs: []
  type: TYPE_NORMAL
- en: Alters the saturation of the element’s colors. The more saturated an element’s
    colors, the more intense they become; the less saturated they are, the more muted
    they appear. A value of `0` leaves the element completely unsaturated, making
    it effectively grayscale, whereas a value of `1` or `100%` leaves the element
    unchanged. Similar to `brightness()`, `saturate()` permits *and* acts upon values
    greater than `1` or `100%`; such values result in *supersaturation*.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of the preceding `filter` functions are shown in [Figure 20-4](#filter-bcs-effects),
    though fully appreciating them depends on a color rendering. Also, the effects
    of greater-than-one values may be hard to make out in the figure, but they are
    present.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2004](assets/css5_2004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-4\. Brightness, contrast, and saturation filter effects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: SVG Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last `filter` value type is a function of a familiar kind: the `url()`
    value type. This allows you to point to a (potentially very complicated) filter
    defined in SVG, whether it’s embedded in the document or stored in an external
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: This takes the form `url(<*uri*>)`, where the <*`uri`*> value points to a filter
    defined using SVG syntax, specifically the `<filter>` element. This can be a reference
    to a single SVG image that contains only a filter, such as `url(wavy.svg)`, or
    it can be a pointer to an identified filter embedded in an SVG image, such as
    `url(filters.svg#wavy)`. The advantage of the latter pattern is that a single
    SVG file can define multiple filters, thus consolidating all your filtering into
    one file for easy loading, caching, and referencing.
  prefs: []
  type: TYPE_NORMAL
- en: If a `url()` function points to a nonexistent file, or points to an SVG fragment
    that is not a `<filter>` element, the function is invalid and the *entire* function
    list is ignored (thus rendering the `filter` declaration invalid).
  prefs: []
  type: TYPE_NORMAL
- en: 'Examining the full range of filtering possibilities in SVG is well beyond the
    scope of this book, but let’s just say that the power of the offered features
    is substantial. A few simple examples of SVG filtering are shown in [Figure 20-5](#filter-svg-effects),
    with brief captions to indicate the kinds of operations the filters were built
    to create. (The actual CSS used to apply these filters looks like `filter: url(filters.svg#rough)`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2005](assets/css5_2005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-5\. SVG filter effects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It’s easily possible to put every last bit of filtering you do into SVG, including
    replacements for every other `filter` function you’ve seen. (In fact, all the
    other `filter` functions are defined by the specification as literal SVG filters,
    to give a precise rendering target for implementors.) Remember, however, that
    you can chain CSS functions together. Thus, you might define a specular-highlight
    filter in SVG, and modify it with blurring or grayscale functions as needed. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Always keep in mind that the filter functions are applied in order. That’s why
    the `grayscale()` and `blur()` functions come after the `url()`-imported spotlight
    filter. If they were reversed, the logos would be made grayscale or blurred first,
    and then have the spotlight filter applied afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Compositing and Blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to filtering, CSS enables you to determine how elements are *composited*
    together. Take, for example, two elements that partially overlap because of positioning.
    By default, the element in front, if fully opaque, completely obscures the one
    behind, wherever they overlap. If the one in front is semitransparent, the element
    in back is partially visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is sometimes called *simple alpha compositing*, in that you can see whatever
    is behind an element as long as some (or all) of it has alpha channel values less
    than `1`. Think of how you can see the background through an element with `opacity:
    0.5`, or in the areas of a PNG or GIF that are set to be transparent. That’s simple
    alpha compositing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you’re familiar with image-editing programs like Photoshop or GIMP,
    you know that overlapping image layers can be blended together in a variety of
    ways. CSS has the same ability. CSS has two blending strategies (at least as of
    late 2022): blending entire elements with whatever is behind them, and blending
    the background layers of a single element together. While similar to filter effects
    in many ways, blending mode values are predefined—they don’t accept a parameter—and
    while both filter effects and blend modes support multiple values, the properties
    that support blend modes use a comma-separated list of values instead of a space-separated
    list. (This inconsistency in value syntaxes is rooted deep in the history of CSS,
    and is something we just have to live with for the time being.)'
  prefs: []
  type: TYPE_NORMAL
- en: Blending Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If elements overlap, you can change the way they blend together by using the
    `mix-blend-mode` property.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS specification indicates that this property “defines the formula that
    must be used to mix the colors with the backdrop.” The element is blended with
    whatever is behind it (the “backdrop”), whether that’s pieces of another element,
    or just the background of an ancestor element such as the `<body>`.
  prefs: []
  type: TYPE_NORMAL
- en: The default value, `normal`, shows the element’s pixels as is, without any mixing
    with the backdrop, except where the alpha channel is less than `1`. This is the
    simple alpha compositing mentioned previously. It’s what we’re all used to, which
    is why it’s the default value. [Figure 20-6](#blending-elements-normal) shows
    a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2006](assets/css5_2006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-6\. Simple alpha-channel blending
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the rest of the `mix-blend-mode` keywords, we’ve grouped them into a few
    categories. Let’s also nail down a few definitions we’ll be using in the blend
    mode descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Foreground
  prefs: []
  type: TYPE_NORMAL
- en: The element that has `mix-blend-mode` applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: Backdrop
  prefs: []
  type: TYPE_NORMAL
- en: Whatever is behind an element. This can be other elements, the background of
    an ancestor element, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel component
  prefs: []
  type: TYPE_NORMAL
- en: 'The color component of a given pixel: R, G, and B.'
  prefs: []
  type: TYPE_NORMAL
- en: If it helps, think of the foreground and backdrop as layers atop each other
    in an image-editing program. With `mix-blend-mode`, you can change the blend mode
    applied to the top element (the foreground).
  prefs: []
  type: TYPE_NORMAL
- en: Darken, lighten, difference, and exclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following blend modes might be called *simple-math modes*—they achieve
    their effect by directly comparing values in some way, or using simple addition
    and subtraction to modify pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`darken`'
  prefs: []
  type: TYPE_NORMAL
- en: Each pixel in the foreground is compared with the corresponding pixel in the
    backdrop, and for each of the R, G, and B values (the pixel components), the smaller
    of the two is kept. Thus, if the foreground pixel has a value corresponding to
    `rgb(91 164 22)` and the backdrop pixel is `rgb(102 104 255)`, the resulting pixel
    will be `rgb(91 104 22)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`lighten`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This blend is the inverse of `darken`: when comparing the R, G, and B components
    of a foreground pixel and its corresponding backdrop pixel, the larger of the
    two values is kept. Thus, if the foreground pixel has a value corresponding to
    `rgb(91 164 22)` and the backdrop pixel is `rgb(102 104 255)`, the resulting pixel
    will be `rgb(102 164 255)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`difference`'
  prefs: []
  type: TYPE_NORMAL
- en: The R, G, and B components of each pixel in the foreground are compared to the
    corresponding pixel in the backdrop, and the absolute value of subtracting one
    from the other is the final result. Thus, if the foreground pixel has a value
    corresponding to `rgb(91 164 22)` and the backdrop pixel is `rgb(102 104 255)`,
    the resulting pixel will be `rgb(11 60 233)`. If one of the pixels is white, the
    resulting pixel will be the inverse of the nonwhite pixel. If one of the pixels
    is black, the result will be exactly the same as the nonblack pixel.
  prefs: []
  type: TYPE_NORMAL
- en: '`exclusion`'
  prefs: []
  type: TYPE_NORMAL
- en: This blend is a milder version of `difference`. Rather than *| back* – *fore*,
    the formula is *back* + *fore* – (2 × *back* × *fore*), where *back* and *fore*
    are values in the range 0 to 1\. For example, an exclusion calculation of an orange
    (`rgb(100% 50% 0%)`) and a medium gray (`rgb(50% 50% 50%)`) will yield `rgb(50%
    50% 50%)`. For the green component, as an example, the math is 0.5 + 0.5 – (2
    × 0.5 × 0.5), which reduces to 0.5, corresponding to `50%`. Compare this to `difference`,
    where the result would be `rgb(50% 0% 50%)`, since each component is the absolute
    value of subtracting one from the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'This last definition highlights that, for all blend modes, the actual values
    being operated on are in the range 0–1\. The previous examples showing values
    like `rgb(11 60 233)` are normalized from the 0–1 range. In other words, given
    the example of applying the `difference` blend mode to `rgb(91 164 22)` and `rgb(102
    104 255)`, the actual operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rgb(91 164 22)` is *R* = 91 ÷ 255 = 0.357; *G* = 164 ÷ 255 = 0.643; *B* =
    22 ÷ 255 = 0.086\. Similarly, `rgb(102 104 255)` corresponds to *R* = 0.4; *G*
    = 0.408; *B* = 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each component is subtracted from the corresponding component, and the absolute
    value taken. Thus, *R* = | 0.357 – 0.4 | = 0.043; *G* = | 0.643 – 0.408 | = 0.235;
    *B* = | 1 – 0.086 | = 0.914\. This could be expressed as `rgba(4.3% 23.5% 91.4%)`,
    or (by multiplying each component by 255) as `rgb(11 60 233)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From all this, you can perhaps understand why the full formulas are not written
    out for every blend mode we cover. If you’re interested in the fine details, each
    blend mode’s formula is provided in the [“Compositing and Blending Level 2”](https://drafts.fxtf.org/compositing/#blendingseparable)
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-7](#blending-elements-dark-light-diff-excl) depicts examples of
    the blend modes in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2007](assets/css5_2007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-7\. Darken, lighten, difference, and exclusion blending with `mix-blend-mode:`
    applied to the foreground image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Multiply, screen, and overlay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following blend modes might be called the *multiplication modes*—they achieve
    their effect by multiplying values together:'
  prefs: []
  type: TYPE_NORMAL
- en: '`multiply`'
  prefs: []
  type: TYPE_NORMAL
- en: Each pixel component in the foreground is multiplied by the corresponding pixel
    component in the backdrop. This yields a darker version of the foreground, modified
    by what is underneath. This blend mode is *symmetric*, in that the result will
    be exactly the same even if you were to swap the foreground with the backdrop.
  prefs: []
  type: TYPE_NORMAL
- en: '`screen`'
  prefs: []
  type: TYPE_NORMAL
- en: Each pixel component in the foreground is inverted (see `invert` in [“Color
    Filtering”](#csstdg4-color-filtering)), multiplied by the inverse of the corresponding
    pixel component in the backdrop, and the result inverted again. This yields a
    lighter version of the foreground, modified by what is underneath. Like `multiply`,
    `screen` is symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: '`overlay`'
  prefs: []
  type: TYPE_NORMAL
- en: This blend is a combination of `multiply` and `screen`. For foreground pixel
    components darker than 0.5 (50%), the `multiply` operation is carried out; for
    foreground pixel components whose values are above 0.5, `screen` is used. This
    makes the dark areas darker, and the light areas lighter. This blend mode is *not*
    symmetric, because swapping the foreground for the backdrop would mean a different
    pattern of light and dark, and thus a different pattern of multiplying versus
    screening.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-8](#blending-elements-multiply-screen-overlay) depicts examples
    of these blend modes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2008](assets/css5_2008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-8\. Images with `mix-blend-mode` property set showing multiply, screen,
    and overlay blending
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Hard and soft light
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following blend modes are covered here because the first is closely related
    to a previous blend mode, and the other is just a muted version of the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hard-light`'
  prefs: []
  type: TYPE_NORMAL
- en: This blend is the inverse of `overlay` blending. Like `overlay`, it’s a combination
    of `multiply` and `screen`, but the determining layer is the backdrop. Thus, for
    backdrop pixel components darker than 0.5 (50%), the `multiply` operation is carried
    out; for backdrop pixel components lighter than 0.5, `screen` is used. This makes
    it appear somewhat as if the foreground is being projected onto the backdrop with
    a projector that employs a harsh light.
  prefs: []
  type: TYPE_NORMAL
- en: '`soft-light`'
  prefs: []
  type: TYPE_NORMAL
- en: This blend is a softer version of `hard-light`. This mode uses the same operation
    but is muted in its effects. The intended appearance is as if the foreground is
    being projected onto the backdrop with a projector that employs a diffuse light.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-9](#blending-elements-hard-soft-light) depicts examples of these
    blend modes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2009](assets/css5_2009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-9\. Hard- and soft-light blending
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Color dodge and burn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Color dodging and burning—terms that come from old darkroom techniques performed
    on chemical film stock—are meant to lighten or darken a picture with a minimum
    of change to the colors themselves. These modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color-dodge`'
  prefs: []
  type: TYPE_NORMAL
- en: Each pixel component in the foreground is inverted, and the component of the
    corresponding backdrop pixel component is divided by the inverted foreground value.
    This yields a brightened backdrop unless the foreground value is `0`, in which
    case the backdrop value is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '`color-burn`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This blend is a reverse of `color-dodge`: each pixel component in the backdrop
    is inverted, the inverted backdrop value is divided by the unchanged value of
    the corresponding foreground pixel component, and the result is then inverted.
    This yields a result where the darker the backdrop pixel, the more its color will
    burn through the foreground pixel.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-10](#blending-elements-color-dodge-burn) depicts examples of these
    blend modes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2010](assets/css5_2010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20-10\. Blending with `mix-blend-mode: color-dodge` and `mix-blend-mode:
    color-burn`'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Hue, saturation, luminosity, and color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final four blend modes are different from those we’ve shown before, because
    they do *not* perform operations on the R/G/B pixel components. Instead, they
    perform operations to combine the hue, saturation, luminosity, and color of the
    foreground and backdrop in different ways. These modes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hue`'
  prefs: []
  type: TYPE_NORMAL
- en: For each pixel, combines the luminosity and saturation levels of the backdrop
    with the hue angle of the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: '`saturation`'
  prefs: []
  type: TYPE_NORMAL
- en: For each pixel, combines the hue angle and luminosity level of the backdrop
    with the saturation level of the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: '`color`'
  prefs: []
  type: TYPE_NORMAL
- en: For each pixel, combines the luminosity level of the backdrop with the hue angle
    and saturation level of the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: '`luminosity`'
  prefs: []
  type: TYPE_NORMAL
- en: For each pixel, combines the hue angle and saturation level of the backdrop
    with the luminosity level of the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-11](#blending-elements-hue-sat-lum-color) depicts examples of these
    blend modes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2011](assets/css5_2011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-11\. Hue, saturation, luminosity, and color blending
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These blend modes can be a lot harder to grasp without busting out raw formulas,
    and even those can be confusing if you aren’t familiar with how things like saturation
    and luminosity levels are determined. If you don’t feel like you quite have a
    handle on how these modes work, the best solution is to practice with a bunch
    of images and simple color patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that an element always blends with its backdrop. If there are other
    elements behind an element, it will blend with them; if there’s a patterned background
    on the parent element, the blending will be done against that pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changing the opacity of a blended element will change the outcome, though not
    always in the way you might expect. For example, if an element with `mix-blend-mode:
    difference` is also given `opacity: 0.8`, the difference calculations will be
    scaled by 80%. More precisely, a scaling factor of 0.8 will be applied to the
    color-value calculations. This can cause some operations to trend toward flat
    middle gray and others to shift the color changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blending Backgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blending an element with its backdrop is one thing, but what if an element has
    multiple background images that overlap and also need to be blended together?
    That’s where `background-blend-mode` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go through an exhaustive list of all the blend modes and what they
    mean, because we did that in [“Blending Elements”](#blending-elements). What they
    meant there, they mean here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that when it comes to blending multiple background images,
    they’re blended with one other against an empty background—that is, a completely
    transparent, uncolored backdrop. They do *not* blend with the backdrop of the
    element, except as directed by `mix-blend-mode`. To see what that means, consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we have three background images, each with its own blend mode. These are
    blended together into a single result, shown in [Figure 20-12](#blending-backgrounds-threebgs).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2012](assets/css5_2012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-12\. Three backgrounds blended together
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So far, fine. Here’s the kicker: the result will be the same regardless of
    what might appear behind the element. We can change the parent’s background to
    white, gray, fuchsia, or a lovely pattern of repeating gradients, and in every
    case those three blended backgrounds will look exactly the same, pixel for pixel.
    They’re blended in *isolation*, a term we’ll return to shortly. We can see the
    previous example ([Figure 20-12](#blending-backgrounds-threebgs)) sitting atop
    a variety of backgrounds in [Figure 20-13](#blending-backgrounds-color-transparent).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2013](assets/css5_2013.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-13\. Blending with color versus transparency
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Like multiple blended elements stacked atop one another, the blending of background
    layers works from the back to the front. Thus, if you have two background images
    over a solid background color, the background layer in the back is blended with
    the background color, and then the frontmost layer is blended with the result
    of the first blend. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Given these styles, *diamond.png* is blended with the background color `goldenrod`
    using the `luminosity` blend. Once that’s done, *star.svg* is blended with the
    results of the diamond-goldenrod blend using a `color-burn` blend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it’s true that the background layers are blended in isolation, they’re
    also part of an element that may have its own blending rules via `mix-blend-mode`.
    Thus, the final result of the isolated background blend may be blended with the
    element’s backdrop after all. Given the following styles, the first example’s
    background will sit atop the element’s backdrop, but the rest will end up blended
    with it in some fashion, as illustrated in [Figure 20-14](#blending-backgrounds-backdrops):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2014](assets/css5_2014.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-14\. Blending elements with their backdrops
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Throughout this section, we’ve touched on the concept of blending in isolation
    as a thing that backgrounds naturally do. Elements, on the other hand, do not
    naturally blend in isolation. As you’ll see next, that behavior can be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Blending in Isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you might want to blend multiple elements together, but in a group
    of their own, in the same way background layers on an element are blended. This
    is, as you’ve seen, called blending in *isolation*. If that’s what you’re after,
    the `isolation` property is for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pretty much does exactly what it says: it either defines an element to
    create an isolated blending context, or not. Given the following styles, then,
    we get the result shown in [Figure 20-15](#blending-isolation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2015](assets/css5_2015.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-15\. Blending in isolation, and not
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Take particular note of where `isolation` is applied, and where `mix-blend-mode`
    is applied. The image is given the blend mode, but the containing element (in
    this case, a paragraph) is set to isolation blending. It’s done this way because
    you want the parent (or ancestor element) to be isolated from the rest of the
    document, in terms of how its descendant elements are blended. So if you want
    an element to blend in isolation, look for an ancestor element to set to `isolation:
    isolate`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting wrinkle arises in all of this: any element that establishes
    a stacking context is automatically isolated, regardless of the `isolation` value.
    For example, if you transform an element by using the `transform` property, it
    will become isolated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete list of stacking-context-establishing conditions, as of late 2022,
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The root element (e.g., `<html>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an element a flex or grid item *and* setting its `z-index` to anything
    other than `auto`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning an element with `relative` or `absolute` *and* setting its `z-index`
    to anything other than `auto`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning an element with `fixed` or `sticky`, regardless of its `z-index`
    value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `opacity` to anything other than `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `transform` to anything other than `none`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `mix-blend-mode` to anything other than `normal`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `filter` to anything other than `none`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `perspective` to anything other than `none`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `mask-image`, `mask-border`, or `mask` to anything other than `none`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `isolation` to `isolate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting `contain` to a value that contains `layout` or `paint`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying `will-change` to any of the other properties, even if they are not
    actually changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, if you have a group of elements that are blended together and then blended
    with their shared backdrop, and you then transition the group’s `opacity` from
    `1` to `0`, the group will suddenly become isolated during the transition. This
    might have no visual impact, depending on the original set of blends, but it very
    well might.
  prefs: []
  type: TYPE_NORMAL
- en: Containing Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to isolating elements for the purposes of blending modes, CSS has a
    property called `contain` that sets limits on how much an element’s layout can
    be affected by other content, and how much its layout will affect other content.
    It’s meant as a way for authors to give optimization hints to browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The default, `none`, means no containment is indicated and so no optimization
    hints are given. Each of the other values has its own peculiar effects, so we’ll
    examine them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the simplest of the four alternatives is `contain: paint`. With this
    value set, the painting of an element is confined to its overflow box, so that
    any descendants cannot be painted outside that area. This is in many ways similar
    to `overflow: hidden`. The difference here is that with paint containment enabled,
    there will never be a way to reveal the unpainted portions of the element and
    its descendants; thus, no scrollbar, click-dragging, or other user action will
    bring the unpainted content into view. This allows browsers to completely ignore
    the layout and painting of elements that are entirely offscreen or otherwise not
    visible, since their descendants cannot be displayed either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A step up from that in complexity is `contain: style`. With the `style` value,
    things like counter increments and resets, and quotation-mark nesting, are calculated
    within the contained element as though no such styles exist outside it, and furthermore,
    they cannot leave the element to affect other elements. This sounds like it creates
    *scoped styles*, where you can have a set of styles just apply to a subtree of
    the DOM, but it doesn’t, really. It does that only for things like counters and
    quote nesting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A more impactful option is `contain: size`. This value makes it so that an
    element is laid out without checking to see how its descendant elements might
    affect its layout, and furthermore, its size is calculated as though it has no
    descendants, which means it will have zero height. It’s also treated as though
    it has no intrinsic aspect ratio, even if the element is an `<img>`, `<svg>`,
    form input, or something else that would ordinarily have an intrinsic aspect ratio.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a couple examples of size containment, illustrated in [Figure 20-16](#size_containment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_2016.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-16\. Examples of size containment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Maybe that’s interesting, but is it useful? To pick one example, it could be
    when JavaScript is used to size elements based on the sizes of their ancestors,
    rather than the other way around (*container queries* by another name) in order
    to prevent layout loops. It could also be applied to elements known to be offscreen
    at page render, in order to minimize the amount of work required by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last kind of containment is invoked with `contain: layout`. This allows
    fragments to come into it, but no fragments to escape, as might be possible with
    proposed features like CSS Regions. When `layout` is set, the internal layout
    of the element is isolated from the rest of the page. This means that nothing
    in the element affects anything outside the element and that nothing outside the
    element affects the element’s internal layout.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More than one of these keywords can be used in a single rule, such as `contain:
    size paint`. This leads to the last two possible keywords, `content` and `strict`.
    The `content` keyword is shorthand for `layout paint style`, and `strict` is shorthand
    for `size layout paint style`. In other words, `content` contains everything but
    size, and `strict` contains in all possible ways.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important caveat is that `contain` can apply to elements with the following
    exceptions: elements that do not generate a box (e.g., `display: none` or `display:
    contents`), internal table boxes that aren’t table cells, internal Ruby boxes,
    and nonatomic inline-level boxes can’t be set to `paint`, `size`, or `layout`.
    Furthermore, elements that have an inside display type of `table` (e.g., `<table>`)
    can’t be set to `size`. Any element can be set to `style`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more caveat to mention: some forms of containment can be invoked
    even without `contain`. For example, `overflow: hidden` will have effectively
    the same result as `contain: paint`, even though `contain: none` may apply to
    the same element.'
  prefs: []
  type: TYPE_NORMAL
- en: All this leads us to the other containment property, `content-visibility`, which
    effectively invokes kinds of containment, as well as potentially suppressing the
    rendering of an element’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: In the default case, `visible`, the contents of an element are shown as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `hidden` value is used, none of the element’s contents are rendered,
    and they do not participate in the sizing of the element, as if all the contents
    (including any text outside of descendant elements) had been set to `display:
    none`. Furthermore, the suppressed content should not be available to things such
    as page search and tab-order navigation, and should not be selectable (as with
    mouse click-and-drag) or focusable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `auto` is used, paint, style, and layout containment are enabled, as if
    having declared `contain: content`. The content may be skipped by the user agent
    or may not; most likely, it will be if the element is offscreen or otherwise not
    visible, but that’s up to the user agent. The contents in this case *are* available
    to page search and tab-order navigation, and can be selected and focused.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of early 2023, `content-visibility` is behind a flag in Firefox and not supported
    in Safari.
  prefs: []
  type: TYPE_NORMAL
- en: To be honest, you probably shouldn’t be messing with `contain` or `content-visibility`
    unless you know with absolute certainty that you really need them, and you’ll
    more likely be setting and disabling them via JavaScript. But they’re there when
    you do need them.
  prefs: []
  type: TYPE_NORMAL
- en: Float Shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a moment to return to the world of floating elements and see how
    we can shape the way text flows past them. Old-school web designers may remember
    techniques such as *ragged floats* and *sandbagging*—in both cases, using a series
    of short, floated images of varying widths to create ragged float shapes. Thanks
    to CSS Shapes, these tricks are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the future, shapes may be available for nonfloated elements such as elements
    placed using CSS Grid, but as of late 2022, they’re allowed on only floated elements.
  prefs: []
  type: TYPE_NORMAL
- en: To shape the flow of content around a floated element, you need to define a
    shape. The property `shape-outside` is how you do so.
  prefs: []
  type: TYPE_NORMAL
- en: With `none`, there’s no shaping except the margin box of the float itself—same
    as it ever was. That’s straightforward and boring. Time for the good stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with using an image to define the float shape, as it’s both the
    simplest and (in many ways) the most exciting. Say we have an image of a crescent
    moon, and we want the content to flow around the visible parts of it. If that
    image has transparent parts, as in a GIF or a PNG, then the content will flow
    into those transparent parts, as shown in [Figure 20-17](#using_an_image_to_define_fig):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, when you have a floated image, you’ll just use that same image
    as its shape. You don’t have to—you can always load a second, different image
    to create a float shape that doesn’t match the visible image—but using a single
    image as both the float and its shape is by far the most common use case. We’ll
    talk in the following sections about how to push the content away from the visible
    parts of the image, and how to vary the transparency threshold that determines
    the shape; but for now, let’s just savor the power this affords us.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2017.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-17\. Using an image to define a float shape
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One point needs to be clarified at this stage: the content will flow into transparent
    parts to which it has “direct access,” for lack of a better term. That is, the
    content doesn’t flow to both the left and right of the image in [Figure 20-17](#using_an_image_to_define_fig),
    but just the right side. That’s the side that faces the content, it being a left-floated
    image. If we right-floated the image, the content would flow into the transparent
    areas on the image’s left side. This is illustrated in [Figure 20-18](#an_image_float_shape_fig)
    (with the text right-aligned to make the effect more obvious):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_2018.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-18\. An image float shape on the right
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Always remember that the image has to have actual areas of transparency to
    create a shape. With an image format like JPEG, or even if you have a GIF or PNG
    with no alpha channel, the shape will be a rectangle, exactly as if you’d used
    `shape-outside: none`.'
  prefs: []
  type: TYPE_NORMAL
- en: Shaping with Image Transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the previous section, it’s possible to use an image with transparent
    areas to define the float shape. Any part of the image that isn’t fully transparent
    creates the shape. That’s the default behavior, anyway, but you can modify it
    with `shape-image-threshold`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property lets you decide what level of transparency determines an area
    where content can flow, or, conversely, what level of opacity defines the float
    shape. Thus, with `shape-image-threshold: 0.5`, any part of the image with more
    than 50% transparency can allow content to flow into it, and any part of the image
    with less than 50% transparency is part of the float shape. This is illustrated
    in [Figure 20-19](#using_image_opacity_to_define).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2019.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-19\. Using image opacity to define the float shape at the 50% opacity
    level
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you set the value of the `shape-image-threshold` property to `1.0` (or just
    `1`), no part of the image can be part of the shape, so there won’t be one, and
    the content will flow over the entire float.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a value of `0.0` (or just `0`) will make any nontransparent
    part of the image the float shape, as if this property was not even set. Furthermore,
    any value below 0 is reset to `0.0`, and any above one is reset to `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Inset Shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s turn back to the <*`basic-shape`*> and <*`shape-box`*> values. A
    basic shape is one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inset()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`circle()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ellipse()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`polygon()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the <*`shape-box`*> can be one of these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`margin-box`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`border-box`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`padding-box`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content-box`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These shape boxes indicate the outermost limits of the shape. You can use them
    on their own, as illustrated in [Figure 20-20](#basic_shape_boxes_fig), where
    the images have some padding in which a dark background color can be seen, then
    a thick border, and finally some (invisible, as always) margins.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2020.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-20\. The basic shape boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The default shape box is the margin box, which makes sense, since that’s what
    float boxes use when they aren’t being shaped. You can use a shape box in combination
    with a basic shape; thus, for example, you could declare `shape-outside: inset(10px)
    border-box`. The syntax for each of the basic shapes is different, so we’ll take
    them in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re used to working with border images, inset shapes should seem familiar.
    Even if you aren’t, the syntax isn’t too complicated. You define distances to
    move inward from each side of the shape box, using from one to four length or
    percentage values, with an optional corner-rounding value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pick a simple case, suppose we want to shrink the shape 2.5 em inside the
    shape box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Four offsets are created, each 2.5 em inward from the outside edge of the shape
    box. In this case, the shape box is the margin box, since we haven’t altered it.
    If we wanted the shape to shrink from, say, the padding box, the value would change
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 20-21](#insets_from_two_basic_shape_boxes) illustrates the two inset
    shapes we just defined.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2021.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-21\. Insets from two basic shape boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As with margins, padding, borders, and so on, *value replication* is in force:
    if there are fewer than four lengths or percentages, the missing values are derived
    from the given values. They go in TRBL order, and thus the following pairs are
    internally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting aspect of inset shapes is the ability to round the corners of
    the shape after the inset has been calculated. The syntax (and effects) are identical
    to the `border-radius` property. Thus, if you wanted to round the corners of the
    float shape with a 5-pixel round, you’d write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if you want each corner to be rounded elliptically, so that
    the elliptical curving is 5 pixels tall and half an em wide, you’d write it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Setting a different rounding radius in each corner is also possible and follows
    the usual replication pattern, except it starts from the top left instead of the
    top. So if you have more than one value, they’re in the order top left, top right,
    bottom right, bottom left (TL-TR-BR-BL, or TiLTeR-BuRBLe), and are filled in by
    copying declared values in for the missing values. [Figure 20-22](#rounding_the_corners_fig)
    shows a few examples. (The rounded shapes in the middle are the float shapes,
    which have been added for clarity. Browsers do not actually draw the float shapes
    on the page.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2022.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-22\. Rounding the corners of a shape box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you set a `border-radius` value for your floated element, this is *not* the
    same as creating a flat shape with rounded corners. Remember that `shape-outside`
    defaults to `none`, so the floated element’s box won’t be affected by the rounding
    of borders. If you want to have text flow closely past the border rounding you’ve
    defined with `border-radius`, you’ll need to supply identical rounding values
    to `shape-outside`.
  prefs: []
  type: TYPE_NORMAL
- en: Circles and ellipses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Circular and elliptical float shapes use similar syntax. In either case, you
    define the radius (or two radii, for the ellipse) of the shape, and then the position
    of its center.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re familiar with circular and elliptical gradient images, the syntax
    for defining circular and elliptical float shapes will seem very much the same.
    There are some important caveats, however, as this section will explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to create a circle shape that’s centered in its float, with
    a 25-pixel radius. We can accomplish that in any of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of which we use, the result will be that shown in [Figure 20-23](#a_circular_float_shape).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2023.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-23\. A circular float shape
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Something to watch out for is that shapes *cannot* exceed their shape box,
    even if you set up a condition where that seems possible. For example, suppose
    we applied the previous 25-pixel-radius rule to a small image, one that’s no more
    than 30 pixels on a side. In that case, you’ll have a circle 50 pixels in diameter
    centered on a rectangle that’s smaller than the circle. What happens? The circle
    may be defined to stick out past the edges of the shape box—in the default case,
    the margin box—but it will be clipped at the edges of the shape box. Thus, given
    the following rules, the content will flow past the image as if it had no shape,
    as shown in [Figure 20-24](#a_rather_small_circular_float_shape):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_2024.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-24\. A rather small circular float shape for an even smaller image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see the circle extending past the edges of the image, but notice how
    the text flows along the edge of the image, not the float shape. Again, that’s
    because the actual float shape is clipped by the shape box; in [Figure 20-24](#a_rather_small_circular_float_shape),
    that’s the margin box, which is at the outer edge of the image. So the actual
    float shape isn’t a circle, but a box the exact dimensions of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same holds true no matter what edge you define to be the shape box. If
    you declare `shape-outside: circle(5em) content-box;`, the shape will be clipped
    at the edges of the content box. Content will be able to flow over the padding,
    borders, and margins, and will not be pushed away in a circular fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means you can do things like create a float shape that’s the lower-right
    quadrant of a circle in the upper-left corner of the float, assuming the image
    is `3em` square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For that matter, if you have a perfectly square float, you can define a circle-quadrant
    that just touches the opposite sides, using a percentage radius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But note: that works *only* if the float is square. If it’s rectangular, oddities
    creep in. Take this example, which is illustrated in [Figure 20-25](#circular_float_shape_that_results):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_2025.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-25\. The circular float shape that results from a rectangle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t bother trying to pick which dimension is controlling the `50%` calculation,
    because neither is. Or, in a sense, both are.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you define a percentage for the radius of a circular float shape, it’s
    calculated with respect to a calculated *reference box*. The height and width
    of this box are calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2026](assets/css5_2026.png)'
  prefs: []
  type: TYPE_IMG
- en: In effect, this creates a square that’s a blending of the float’s intrinsic
    height and width. In the case of our floated image of 70 × 150 pixels, that works
    out to a square that’s 117.047 pixels on a side. Thus, the circle’s radius is
    50% of that, or 58.5235 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, note that the content in [Figure 20-26](#a_clipped_float_shape)
    is flowing past the image and ignoring the circle. That’s because the actual float
    shape is clipped by the shape box, so the final float shape would be a kind of
    vertical bar with rounded ends, something very much like what’s shown in [Figure 20-26](#a_clipped_float_shape).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2027.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-26\. A clipped float shape
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It’s a lot simpler to position the center of the circle and have it grow until
    it touches either the closest side to the circle’s center, or the farthest side
    from the circle’s center. Both techniques are possible, as shown here and illustrated
    in [Figure 20-27](#various_circular_float_shapes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_2028.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-27\. Various circular float shapes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In one of the examples in [Figure 20-27](#various_circular_float_shapes), the
    shape is clipped to its shape box, whereas in the others, the shape is allowed
    to extend beyond it. If we hadn’t clipped the shape, it would have been too big
    for the figure! You’ll see this again in the next figure.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how about ellipses? Besides using the name `ellipse()`, the only syntactical
    difference between circles and ellipses is that you define two radii instead of
    one radius. The first is the x (horizontal) radius, and the second is the y (vertical)
    radius. Thus, for an ellipse with an x radius of 20 pixels and a y radius of 30
    pixels, you’d declare `ellipse(20px 30px)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use any length or percentage, *or* the keywords `closest-side` and `farthest-side`,
    for either of the radii in an ellipse. [Figure 20-28](#various_elliptical_float_shapes)
    shows some possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2029.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-28\. Defining float shapes with ellipses
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Working with percentages for the lengths of the radii is a little different
    with ellipses than with circles. Instead of a calculated reference box, percentages
    in ellipses are calculated against the axis of the radius. Thus, horizontal percentages
    are calculated with respect to the width of the shape box, and vertical percentages
    with respect to the height. This is illustrated in [Figure 20-29](#elliptical_float_shapes_and_percentages).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2030.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-29\. Elliptical float shapes and percentages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with any basic shape, an elliptical shape is clipped at the edges of the
    shape box.
  prefs: []
  type: TYPE_NORMAL
- en: Polygons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polygons are a lot more complicated to write, though they may be a little bit
    easier to understand. You define a polygonal shape by specifying a comma-separated
    list of *x*-*y* coordinates, expressed as either lengths or percentages, calculated
    from the top left of the shape box, as in SVG. Each *x*-*y* pair is a *vertex*
    in the polygon. If the first and last vertices are not the same, the browser will
    close the polygon by connecting them. (All polygonal float shapes must be closed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s say we want a diamond shape that’s 50 pixels tall and wide. If we
    start building the polygon from the topmost vertex, the `polygon()` value would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Percentages have the same behavior as they do in `background-image` positioning
    (for example), so we can define a diamond shape that always “fills out” the shape
    box. It would be written like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The result of this and the previous polygon example are shown in [Figure 20-30](#a_polygonal_float_shape).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2031.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-30\. A polygonal float shape
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'These examples both start from the topmost vertex, but they don’t have to.
    All of the following will yield the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, remember: if a shape definition exceeds the shape box, it will always
    be clipped to it. So even if you create a polygon with coordinates that lie outside
    the shape box (by default, the margin box), the polygon will get clipped. [Figure 20-31](#how_a_float_shape_is_clipped)
    demonstrates the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2032.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-31\. How a float shape is clipped when it exceeds the shape box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Polygons have an extra wrinkle: you can toggle their fill rule. By default,
    the fill rule is `nonzero`, but the other possible value is `evenodd`. It’s easier
    to show the difference than to describe it, so here’s a star polygon with two
    fill rules, illustrated in [Figure 20-32](#the_two_polygonal_fills):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_2033.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-32\. The two polygonal fills
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The default `nonzero` case is what we tend to think of with filled polygons:
    a single shape, completely filled. The `evenodd` option has a different effect,
    in which some pieces of the polygon are filled and others are not.'
  prefs: []
  type: TYPE_NORMAL
- en: This particular example doesn’t show much difference, since the part of the
    polygon that’s missing is completely enclosed by filled parts, so the end result
    is the same either way. However, imagine a shape that has sideways spikes, and
    then a line that cuts vertically across the middle of them. Rather than a comb
    shape, you’d end up with a set of discontinuous triangles. There are a lot of
    possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, a polygon can become very complex, with a large number of
    vertices. You’re welcome to work out the coordinates of each vertex on paper and
    type them in, but it makes a lot more sense to use a tool to do this. A good example
    of such a tool is the CSS Shapes Editor extension available for Chrome via the
    Chrome Web Store. (Firefox has this capability built natively into its web inspector.)
    You can select a float in the DOM inspector, bring up the CSS Shapes Editor, select
    a polygon, and then start creating and moving vertices in the browser, with live
    reflowing of the content as you do so. Then, once you’re satisfied, you can drag-select-copy
    the polygon value for pasting into your stylesheet. [Figure 20-33](#the_chroms_shapes_editor)
    shows a screenshot of the Shapes Editor in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2034.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-33\. The Chrome Shapes Editor in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because of cross-origin resource sharing (CORS) restrictions, shapes cannot
    be edited with the Shapes Editor unless they’re being loaded over HTTP(S) from
    the same origin server as the HTML and CSS. Loading local files from your computer
    will prevent the shapes from being editable. The same restriction prevents shapes
    from being loaded off local storage via the `url()` mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Shape Margin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a float of any kind of shape has been defined, it’s possible to add a “margin”—more
    properly, a *shape modifier*—to that shape by using the property `shape-margin`.
  prefs: []
  type: TYPE_NORMAL
- en: Much like a regular element margin, a *shape margin* pushes content away by
    either a length or a percentage; a percentage is calculated with respect to the
    width of the element’s containing block, just as are regular margins.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of a shape margin is that you can define a shape that exactly
    matches the thing you want to shape, and then use the shape margin to create extra
    space. Take an image-based shape, where part of the image is visible and the rest
    is transparent. Instead of having to add opaque portions to the image to keep
    text and other content away from the visible part of the image, you can just add
    a shape margin. This enlarges the shape by the distance supplied.
  prefs: []
  type: TYPE_NORMAL
- en: In detail, the new shape is found by drawing a line perpendicular from each
    point along the basic shape, with a length equal to the value of `shape-margin`,
    to find a point in the new shape. At sharp corners, a circle is drawn centered
    on that point with a radius equal to the value of `shape-margin`. After all that,
    the new shape is the smallest shape that can describe all those points and circles
    (if any).
  prefs: []
  type: TYPE_NORMAL
- en: Remember, though, that a shape can never exceed the shape box. Thus, by default,
    the shape can’t get any bigger than the margin box of the unshaped float. Since
    `shape-margin` actually increases the size of the shape, any part of the newly
    enlarged shape that exceeds the shape box will be clipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what this means, consider the following, as illustrated in [Figure 20-34](#adding_margins_to_float_shapes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_2035.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-34\. Adding margins to float shapes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice the way the content flows past the second and third examples. There
    are definitely places where the content gets closer than the specified `shape-margin`,
    because the shape has been clipped at the margin box of the floated element. To
    make sure the separation distance is always observed, include standard margins
    that equal or exceed the `shape-margin` distance. For example, we could have avoided
    the problem by modifying two of the rules like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the right and bottom margins are set to be the same as the `shape-margin`
    value, ensuring that the enlarged shape will never exceed the shape box on those
    sides. This is demonstrated in [Figure 20-35](#making_sure_the_shape_margins).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_2036.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-35\. Making sure the shape margins don’t get clipped
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you have a float go to the right, you’ll have to adjust its margins to create
    space below and to the left, not the right, but the principle is the same. You
    can also use `float: inline-end` and the `margin-inline` property to ensure that
    if the writing direction changes, your layout still works as intended.'
  prefs: []
  type: TYPE_NORMAL
- en: Clipping and Masking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to float shaping, CSS also offers clipping and masking of elements,
    albeit without any shaping of the element box. These are methods of showing only
    portions of an element, using a variety of simple shapes as well as the application
    of complete images and SVG elements. These can be used to make decorative bits
    of a layout more visually interesting, among other things—a common technique is
    to frame images or give them ragged edges.
  prefs: []
  type: TYPE_NORMAL
- en: Clipping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all you want to do is visually clip away pieces of an element, you can use
    the property `clip-path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `clip-path`, you’re able to define a *clipping shape*. This is essentially
    the area of the element inside which visible portions are drawn. Any part of the
    element that falls outside the shape is clipped away, leaving behind empty transparent
    space. The following code gives an unclipped and a clipped example of the same
    paragraph, with the result depicted in [Figure 20-36](#clipping-compare):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2037](assets/css5_2037.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-36\. Unclipped and clipped paragraphs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default value, `none`, means no clipping is performed, as you’d probably
    expect. Similarly, if a <*`url`*> value is given (as in the preceding code) and
    it points to a missing resource, or to an element in an SVG file that isn’t a
    `<clipPath>`, no clipping is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, URL-based clip paths work in most browsers only if the URL
    points to an embedded SVG inside the same document as the clipped element. External
    SVGs are not supported. Firefox is the only browser supporting clip paths from
    external SVGs.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the values are either shapes written in CSS, reference boxes, or
    both.
  prefs: []
  type: TYPE_NORMAL
- en: Clip Shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define clip shapes with one of a set of four simple shape functions.
    These are identical to the shape functions used to define float shapes with `shape-outside`,
    so we won’t redescribe them in detail here. Here’s a brief recap:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inset()`'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts from one to four lengths or percentage values, defining offsets from
    the edges of the bounding box, with optional corner rounding via the `round` keyword
    and another set of one to four lengths or percentages.
  prefs: []
  type: TYPE_NORMAL
- en: '`circle()`'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a single length, percentage, or keyword defining the radius of the circle,
    with an optional position for the circle’s center with the `at` keyword followed
    by one or two lengths or percentages.
  prefs: []
  type: TYPE_NORMAL
- en: '`ellipse()`'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a mandatory two lengths, percentages, or keywords defining the radii
    of the vertical and horizontal axes of the ellipse, with an optional position
    for the ellipse’s center with the `at` keyword followed by one or two lengths
    or percentages.
  prefs: []
  type: TYPE_NORMAL
- en: '`polygon()`'
  prefs: []
  type: TYPE_NORMAL
- en: Accepts a comma-separated list of space-separated *x* and *y* coordinates, using
    either lengths or percentages. Can be prefaced by a keyword defining the fill
    rule for the polygon.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 20-37](#clipping-shapes) shows a variety of examples of these clip
    shapes, corresponding to the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2038](assets/css5_2038.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-37\. Various clip shapes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As [Figure 20-37](#clipping-shapes) shows, the elements are visible only inside
    the clip shapes. Anything outside that is just gone. But note that the clipped
    elements still take up the same space they would if they weren’t clipped at all.
    In other words, clipping doesn’t make the elements smaller. It just limits the
    part of them that’s actually drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Clip Boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike clip shapes, clip boxes aren’t specified using lengths or percentages.
    They correspond, for the most part, directly to boundaries in the box model.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just write `clip-path: border-box`, for example, the element is clipped
    along the outside edge of the border. This is likely what you’d expect anyway,
    since margins are transparent. Remember, however, that outlines can be drawn outside
    borders, so if you *do* clip at the border edge, any outlines will be clipped
    away. That includes any outlines, which can create a major accessibility problem,
    so be very careful clipping any element that can receive focus. (You probably
    just shouldn’t do it in those cases.)'
  prefs: []
  type: TYPE_NORMAL
- en: When used by themselves, the values `margin-box`, `padding-box`, and `content-box`
    dictate that the clipping occurs at the outer edges of the margin, padding, or
    content areas, respectively. These are diagrammed in [Figure 20-38](#clipping-boxes).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2039](assets/css5_2039.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-38\. Various clipping boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There’s another part to [Figure 20-38](#clipping-boxes), which shows the SVG
    bounding boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`view-box`'
  prefs: []
  type: TYPE_NORMAL
- en: The nearest (the closest ancestor) SVG viewport is used as the clipping box.
  prefs: []
  type: TYPE_NORMAL
- en: '`fill-box`'
  prefs: []
  type: TYPE_NORMAL
- en: The *object bounding box* is used as the clipping box. The object bounding box
    is the smallest box that will fit every part of the element’s geometry, taking
    into account any transformations (e.g., rotation), not including any strokes along
    its outside.
  prefs: []
  type: TYPE_NORMAL
- en: '`stroke-box`'
  prefs: []
  type: TYPE_NORMAL
- en: The *stroke bounding box* is used as the clipping box. Similar to the fill box,
    the stroke box is the smallest box that will fit every part of the element’s geometry,
    taking into account any transformations (e.g., rotation), but the stroke box includes
    any strokes along its outside.
  prefs: []
  type: TYPE_NORMAL
- en: These values apply only to SVG elements that don’t have an associated CSS layout
    box. For such elements, if the CSS-style boxes (`margin-box`, `border-box`, `padding-box`,
    `content-box`) are given, `fill-box` is used instead. Conversely, if one of the
    SVG bounding box values is applied to an element that *does* have a CSS layout
    box—which is most elements—`border-box` is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be useful at times to be able to use something like `clip-path: content-box`
    just to clip away everything outside the content area, but these box values really
    come into their own in conjunction with a clipping shape. Suppose you have an
    `ellipse()` clip shape you want to apply to an element, and furthermore, you want
    to have it just touch the outer edges of the padding box. Rather than have to
    calculate the necessary radii by subtracting margins and borders from the overall
    element, you can just write `clip-path: ellipse(50% 50%) padding-box`. That will
    center an elliptical clip shape at the center of the element, with horizontal
    and vertical radii half the element’s reference box, as shown in [Figure 20-39](#clipping-boxes-ellipse),
    along with the effect of fitting to other boxes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2040](assets/css5_2040.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-39\. Fitting an elliptical clip shape to various boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the ellipse is cut off in the `margin-box` example? That’s because
    the margin is invisible, so while parts of it fall inside the elliptical clip
    shape, we can’t actually see those parts unless there’s a box shadow or an outset
    border image on the element.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the bounding-box keywords can be used only in conjunction with
    clip shapes—*not* with an SVG-based clip path. The keywords that relate to SVG
    bounding boxes apply only if an SVG image is being clipped via CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Clipping with SVG Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you happen to have an SVG path handy, or you’re comfortable writing your
    own, you can use it to define the clipping shape in the `clip-path` property.
    The syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace that ellipsis with the contents of an SVG `d` or `points` attribute,
    and that will give you a clipping shape. Here’s an example of such an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will draw a diamond from the point at *x*=500, *y*=0 to *x*=1000, *y*=250,
    and so on, forming a diamond shape 1,000 pixels across by 500 high. If applied
    to an image exactly 1,000 pixels by 500 pixels, you’d get the result shown in
    [Figure 20-40](#clipping-svg-path).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2041](assets/css5_2041.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-40\. An image clipped with an SVG clip path
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You’d get the same clip shape shown in [Figure 20-40](#clipping-svg-path) by
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that the clipping path defined with percentage values
    in a polygon is a lot more robust than one that requires images to be exactly
    1,000 pixels wide by 500 pixels tall. That’s because, as of late 2022, all SVG
    path coordinates are expressed in absolute units, and can’t be declared as percentages
    of the image’s height and width as the `polygon()` shape can.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This has been a necessarily very brief spotlight on the ability to use SVG paths
    in CSS, as describing all the ways paths can be shaped is far beyond the scope
    of this book. If you want to know more, we recommend reading [*Using SVG with
    CSS3 & HTML5*](https://learning.oreilly.com/library/view/using-svg-with/9781491921968)
    by Amelia Bellamy-Royds et al. (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: Masks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we say *mask*, at least in this context, we mean a shape inside of which
    things are visible, and outside of which they are not. Masks are thus very similar
    in concept to clipping paths. The primary differences are twofold: first, with
    masks you can only use an image to define the areas of the element that are shown
    or clipped away; and second, a lot more properties are available to use with masks,
    allowing you to do things such as position, size, and repeat the masking image.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, the Chromium familiy supports most of the masking properties,
    but only with the `-webkit-` prefix. So instead of `mask-image`, for example,
    Chrome and Edge support `-webkit-mask-image` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Mask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step to applying a mask is to point to the image that you’ll be using
    to define the mask. This is accomplished with `mask-image`, which accepts any
    image type.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the image reference is valid, `mask-image` will give the browser an
    image to use as a mask for the element to which it’s being applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a simple situation: one image applied to another, where both
    are the same height and width. [Figure 20-41](#masks-image-simple) shows two images
    separately, along with the first image being masked by the second.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2042](assets/css5_2042.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-41\. A simple image mask
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As the figure shows, in the parts of the second image that are opaque, the first
    image is visible. In the parts that are transparent, the first image is not visible.
    For the parts that are semitransparent, the first image is also semitransparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic code for the end result shown in [Figure 20-41](#masks-image-simple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: CSS doesn’t require that you apply mask images only to other images, though.
    You can mask pretty much any element with an image, and that image can be a raster
    image (GIF, JPG, PNG) or a vector image (SVG). The latter is usually a better
    choice, if available. You can even construct your own image with gradients, whether
    linear or radial, repeated or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following styles will have the result shown in [Figure 20-42](#masks-image-variety):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2043](assets/css5_2043.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-42\. A variety of image masks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An important point to keep in mind is that when a mask clips away pieces of
    an element, it clips away *all* pieces. The best example of this occurs when you
    apply an image that clips away the outer edges of elements, and the markers on
    list items can very easily become invisible. [Figure 20-43](#masks-image-listitems)
    shows an example, which is the result of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2044](assets/css5_2044.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-43\. A PNG with areas of transparency masking an unordered list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One other value option enables you to point directly at a `<mask>` element
    in SVG to use the mask it defines. This is analogous to pointing to a `<clipPath>`
    or other SVG element from the property `clip-path`. Here’s an example of how a
    mask might be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With that SVG embedded in the HTML file directly, the mask can be referenced
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If the SVG is in an external file, this is how to reference it from CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The difference between using an image as a mask versus an SVG `<mask>` is that
    SVG masking is based on luminance, rather than alpha transparency. This difference
    can be inverted with the `mask-mode` property.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Mask’s Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve just seen the two ways to use an image as a mask. Masking is accomplished
    by applying an image with an alpha channel to another element. Masking can also
    be done by using the brightness of each part of the masking image to define the
    mask. Switching between these two options is accomplished with the `mask-mode`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two of the three values are straightforward: `alpha` means the alpha channel
    of the image should be used to compute the mask, and `luminance` means the brightness
    levels should be used. The difference is illustrated in [Figure 20-44](#masks-mode),
    which is the result of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When `luminance` is used to calculate the mask, brightness is treated the same
    way alpha values are in alpha masking. Consider how alpha masking works: any part
    of the image with opacity of 0 hides that part of the masked element. A part of
    the image with opacity of 1 (fully opaque) reveals that part of the masked element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true with luminance-based masking. A part of the mask with luminosity
    of 1 reveals that part of the masked element. A part of the mask with luminosity
    of 0 (fully black) hides that part of the masked element. But note that any fully
    transparent part of the mask is *also* treated as having a luminance of 0\. This
    is why the shadow portion of the theater-mask image doesn’t show any part of the
    masked image: its alpha value is greater than 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2045](assets/css5_2045.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-44\. Alpha and luminance mask modes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The third (and default) value, `match-source`, is a combination of `alpha`
    and `luminance`, choosing between them based on the actual source image for the
    mask as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the source is a type of <*`image`*>, use `alpha`. The <*`image`*> can be
    an image such as a PNG or visible SVG, a CSS gradient, or a piece of the page
    referred to by the `element()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the source is an SVG `<mask>` element, use `luminance`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sizing and Repeating Masks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, nearly all the examples have been carefully crafted to make each mask’s
    size match the size of the element it’s masking. (This is why we keeping applying
    masks to images.) In many cases, mask images may be a different size than the
    masked element. CSS has a couple of ways to deal with this, starting with `mask-size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve ever sized background images, you know exactly how to size masks,
    because the value syntax is *exactly* the same, as are the behaviors. As an example,
    consider the following styles, which have the result shown in [Figure 20-45](#masks-sizing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2046](assets/css5_2046.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-45\. Sizing masks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Again, these should be immediately familiar to you if you’ve ever sized backgrounds.
    If not, see [“Sizing Background Images”](ch08.html#sizing-background-images) for
    a more detailed exploration of the possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: In a like vein, just as the pattern of backgrounds repeating throughout the
    background area of the element can be changed or suppressed, mask images can be
    affected with `mask-repeat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values available here are the same as those for `background-repeat`. [Figure 20-46](#masks-repeat)
    shows some examples, based on the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2047](assets/css5_2047.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-46\. Repeating masks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Positioning Masks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that sizing and repetition of mask images mirrors the sizing and repetition
    of background images, you might think that the same is true for positioning the
    origin mask image, similar to `background-position`, as well as the origin box,
    similar to `background-origin`. And you’d be exactly right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, if you’ve ever positioned a background image, you know how to position
    mask images. Following are a few examples, illustrated in [Figure 20-47](#masks-position):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2048](assets/css5_2048.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-47\. Positioning masks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, the origin box for mask images is the outer border edge. If you
    want to move it further inward, or define a specific origin box in an SVG context,
    then `mask-origin` does for masks what `background-origin` does for backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: For the full story, see [“Changing the positioning box”](ch08.html#changing-the-positioning-box),
    but for a quick example, see [Figure 20-48](#masks-origin).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2049](assets/css5_2049.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-48\. Changing the origin box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Clipping and Compositing Masks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more property echoes backgrounds, and that’s `mask-clip`, the mask equivalent
    of `background-clip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this does is clip the overall mask to a specific area of the masked element.
    In other words, it restricts the area in which the visible parts of the element
    are in fact visible. [Figure 20-49](#masks-clip) shows the result of the following
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2050](assets/css5_2050.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-49\. Clipping the mask
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The last longhand masking property, `mask-composite`, is quite interesting because
    it can radically change the way multiple masks interact.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of early 2023, `mask-composite` is supported only by Firefox, but all browsers
    (even Firefox) support the prefixed form `-webkit-mask-composite`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with compositing operations, a diagram is in order.
    See [Figure 20-50](#masks-composite-diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2051](assets/css5_2051.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-50\. Compositing operations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The image on top in the operation is called the *source*, and the image beneath
    it is called the *destination*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn’t particularly matter for three of the four operations: `add`, `intersect`,
    and `exclude`, all of which have the same result regardless of which image is
    the source and which the destination. But for `subtract`, the question is: which
    image is being subtracted from which? The answer: the destination is subtracted
    from the source.'
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between source and destination also becomes important when compositing
    multiple masks together. In these cases, the compositing order is from back to
    front, with each succeeding layer being the source and the already-composited
    layers beneath it being the destination.
  prefs: []
  type: TYPE_NORMAL
- en: To see why, consider [Figure 20-51](#masks-composite-multiple), which shows
    the various ways three overlapping masks are composited together, and how results
    change with changes to their order and compositing operations.
  prefs: []
  type: TYPE_NORMAL
- en: The figure is constructed to show the bottommost mask at the bottom, the topmost
    above the other two, and the resulting mask at the very top. Thus, in the first
    column, the triangle and circle are composited with an exclusion operation. The
    resulting shape is then composited with the square using an additive operation.
    That results in the mask shown at the top of the first column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember that when doing a subtraction composite, the bottom shape is
    subtracted from the shape above it. Thus, in the third column, the addition of
    the triangle and circle is subtracted from the square above them. This is accomplished
    with `mask-composite: add, subtract`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2052](assets/css5_2052.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-51\. Compositing masks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bringing It All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the preceding mask properties are brought together in the shorthand property
    `mask`.
  prefs: []
  type: TYPE_NORMAL
- en: Like all the other masking properties, `mask` accepts a comma-separated list
    of masks. The order of the values in each mask can be anything except for the
    mask size, which always follows the position and is separated from it by a forward
    slash (`/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the following rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The triangle and square are added together, and then the result of that additive
    composite is subtracted from the circle. The result is shown in [Figure 20-52](#masks-multiple)
    as applied to a square element (the teal shape on the left) and a shape wider
    than it is tall (the goldenrod shape on the right).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2053](assets/css5_2053.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-52\. Two masks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Setting Mask Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re using CSS to style SVG elements, and you want to set the SVG `<mask>`
    type, then `mask-type` is for you.
  prefs: []
  type: TYPE_NORMAL
- en: This property is similar to `mask-mode`, except there is no `match-source` equivalent.
    You can choose only `luminance` or `alpha`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting thing is that if `mask-type` is set for a `<mask>` element
    that’s used to mask an element, and `mask-mode` is declared for that masked element,
    `mask-mode` wins. As an example, consider the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Given these rules, the masked images will have a mask with luminance compositing,
    not alpha compositing. If the `mask-mode` value were left at its default value,
    `match-source`, then `mask-type`’s value would be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Border-Image Masking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same specification that defines clipping paths and element masking, CSS
    Masking, also defines properties that are used to apply masking images in a way
    that mirrors border-image properties. In fact, with one exception, the properties
    between border images and border masks are direct analogues, and the values the
    same. Refer to [“Image Borders”](ch07.html#image-borders) for a detailed explanation
    of how these work, but here are some quick recaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that without having a border of some sort, none of these properties
    will have any visible effect. To apply a border and then mask it, you must first
    declare a border’s style, at a minimum. If you intend your masked border to be
    10 pixels wide, you would need something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Once that’s been established, you can begin masking the border.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As of late 2022, all these properties are supported in Chromium and WebKit
    browsers as `-webkit-mask-box-image-*` instead of the names used in the specification.
    The actually supported names are noted in the property summary boxes that follow,
    but examples use the standard (unprefixed) property names. Also note: as of this
    writing, the Gecko (Firefox) family does not support border masks in any form.'
  prefs: []
  type: TYPE_NORMAL
- en: The `mask-border-source` property specifies the image to be used as a mask.
    This can be a URL, gradient, or other supported <*`image`*> value type. Once the
    masking image has been set up, you can move on to doing things like slicing it
    into sections, defining a distinct width for the mask, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mask-border-slice` property establishes a set of four slice-lines that
    are laid over the border, and where they fall determines how the mask will be
    sliced up for use in each of the eight parts of the border area: the top, right,
    bottom, and left edges, as well as the top-left, top-right, bottom-right, and
    bottom-left corners. The property takes up to four values, defining (in order)
    offsets from the top, right, bottom, and left edges.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, no logical-property equivalent exists for `mask-border-slice`.
    If the proposed addition of a `logical` keyword, or something equivalent, to this
    property is ever adopted and implemented, at that point it will be possible to
    use `mask-border-slice` in a writing-flow-relative fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following, diagrammed in [Figure 20-53](#mask-border-patterns):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2054](assets/css5_2054.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-53\. Some mask border-slicing patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might think that numeric offsets need to be given a length unit to define
    a distance, but this is not so. Number values are interpreted in the coordinate
    system of the image used for the mask. With a raster image like a PNG, the coordinate
    system will be the pixels of the image. In an SVG image, the coordinate system
    defined by the SVG file is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the optional `fill` keyword causes the center portion of the mask image
    to be applied to the element inside the border area. By default, it is not used,
    allowing the element’s padding and content to be fully seen. If you do use it
    by adding `fill`, the part of the mask image inside the four slice lines will
    be stretched over the element’s content and padding, and applied to them. Consider
    the following, illustrated in [Figure 20-54](#mask-border-fill):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2055](assets/css5_2055.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-54\. Applying the mask fill
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, a bug in browsers that support the prefixed property causes
    the content and padding of an element to be completely hidden unless the `fill`
    keyword is used. Thus, in order to use border masks and show the content of an
    element, you need to fill the center of the mask image completely, and use `fill`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property allows you to define a width (or individual widths) for the four
    edge slices of the border mask. If the slices are not actually the size(s) you
    declare, they will be resized to fit. For example, a masking image might be sliced
    and then sized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to slice up the masking image in one way, and then size it as
    needed for the context or define a universal size for masking image, regardless
    of the context in which it appears.
  prefs: []
  type: TYPE_NORMAL
- en: With `mask-border-outset`, you can push the mask outside the border area. This
    is useful only if you’re already pushing a border image outside the border area
    with `border-image-outset` and want to also apply the mask to that border image,
    or if you’ve applied an outline to the element and want to mask that as well.
    If neither is true, the masked area outside the border will mask only the margin
    area, which is already transparent and so can’t be visibly altered.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, browsers supporting the prefixed property not only push the
    slices outward, but also expand the center area by the given amount, scaling up
    the masked area covered by the center slice in the process. This behavior is not
    called for or apparently supported by the specifications current as of this writing,
    and is most likely a bug (unless the behavior is eventually made retroactively
    correct by a CSS Working Group decision).
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, our only example of border masking has used a masking image that is
    an exact fit for the element it’s masking. This is unlikely to be the case, since
    elements can be resized by any number of factors. The default is to stretch each
    slice to fit its part of the border area, but other options are possible. [Figure 20-55](#mask-border-repeating)
    illustrates the options (center areas have been removed for clarity).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2056](assets/css5_2056.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-55\. Various kinds of mask image repeating
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As shown in [Figure 20-55](#mask-border-repeating), `mask-border-repeat` can
    accept one or two repeat values. If one is given, it’s applied to all sides of
    the border area. If two are given, the first applies to the horizontal sides of
    the border area, and the second to the vertical sides.
  prefs: []
  type: TYPE_NORMAL
- en: Border masks have one styling aspect that image borders do not, and it’s set
    with the property `mask-border-mode`.
  prefs: []
  type: TYPE_NORMAL
- en: The `mask-border-mode` property sets whether the masking mode is alpha based,
    or luminance based. For more details on the difference, see the `mask-mode` property
    discussed earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The property `mask-border` incorporates all of the previous border-masking properties
    into one convenient shorthand.
  prefs: []
  type: TYPE_NORMAL
- en: Object Fitting and Positioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more variety of masking applies solely to replaced elements like images.
    With `object-fit`, you can change the way the replaced element fills its element
    box—or even have it not fill that box completely.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever worked with `background-size`, these values probably look familiar.
    They do similar things, too, only with replaced elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume a 50 × 50 pixel image. We can change its size via CSS with
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The default expectation is that these style declarations will stretch the 50
    × 50 image to be 250 × 150\. And if `object-fit` is its default value, `fill`,
    that’s exactly what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the value of `object-fit`, however, and other behaviors occur. The following
    examples are illustrated in [Figure 20-56](#object-fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2057](assets/css5_2057.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-56\. Four kinds of object fitting
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first instance, `none`, the `<img>` element is drawn 250 pixels wide
    by 150 pixels tall. The image itself, however, is drawn 50 × 50 pixels—its intrinsic
    size—because it was directed to *not* fit the element box. The second instance,
    `fill`, is the default behavior, as mentioned. This is the only value that may
    distort the image, as the dimensions are the element’s dimensions, not the image’s
    intrinsic size.
  prefs: []
  type: TYPE_NORMAL
- en: In the third instance, `cover`, the image is scaled up until no part of the
    element box is left “uncovered”—but the image itself keeps its intrinsic aspect
    ratio. In other words, the image stays a square. In this case, the longest axis
    of the `<img>` element is `250px` long, so the image is scaled up to be 250 ×
    250 pixels. That 250 × 250 image is then placed in the 250 × 150 `<img>` element.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth instance, `contain`, is similar, except the image is only big enough
    to touch two sides of the `<img>` element. This means the image is 150 × 150 pixels,
    and placed into the 250 × 150 pixel box of its `<img>` element.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, what you see in [Figure 20-56](#object-fit) is four `<img>` elements.
    There are no wrapper `<div>` or `<span>` or other elements around those images.
    The border and background color are part of the `<img>` element. The image placed
    inside the `<img>` element is fitted according to `object-fit`. The element box
    of the `<img>` element then acts rather like it’s a simple mask for the fitted
    image inside it. (And then you can mask and clip the element box with the properties
    covered earlier in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: A fifth value for `object-fit`, not represented in [Figure 20-56](#object-fit),
    is `scale-down`. The meaning of `scale-down` is “do the same as either `none`
    or `contain`, whichever leads to a smaller size.” This lets an image always be
    its intrinsic size unless the `<img>` element gets too small, in which case it’s
    scaled down à la `contain`. This is illustrated in [Figure 20-57](#object-fit-scale-down),
    where each `<img>` element is labeled with the `height` values it’s been given;
    the `width` in each case is `100px`.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 2058](assets/css5_2058.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-57\. Various `scale-down` scenarios
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So if a replaced element is bigger or smaller than the element box into which
    it’s being fit, how can we affect its alignment within that box? Using `object-position`
    is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value syntax here is just like that for `mask-position` or `background-position`,
    allowing you to position a replaced element within its element box if it isn’t
    set to `object-fit: fill`. Thus, given the following CSS, we get the result shown
    in [Figure 20-58](#object-position):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2059](assets/css5_2059.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-58\. A variety of `object-position` values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the first example has a value of `50% 50%`, even though that isn’t
    present in the CSS code. That illustrates that the default value of `object-position`
    is `50% 50%`. The next two examples show how various `object-position` values
    move the image around within the `<img>` element box.
  prefs: []
  type: TYPE_NORMAL
- en: As the last example shows, it’s possible to move an unscaled replaced element
    like an image so that it’s partly clipped by its element box. This is similar
    to positioning background images or masks so that they are clipped at the element
    boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to position fitted elements that are larger than the element
    box, as can happen with `object-fit: cover`, although the results can be very
    different than with `object-fit: none`. The following CSS will have results like
    those shown in [Figure 20-59](#object-position-cover):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 2060](assets/css5_2060.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-59\. Positioning a covered object
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If any of these results confuse you, review [“Positioning Background Images”](ch08.html#background-positioning)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all of the effects available to CSS authors, we have an infinite variety
    of outcomes and thus an infinite variety of creative presentation of elements.
    Whether it’s altering elements’ appearances with filters, changing how they’re
    composited with their backdrops, clipping or masking parts of elements, or altering
    the way images fill out their element boxes, there have never been more options
    at your fingertips.
  prefs: []
  type: TYPE_NORMAL
