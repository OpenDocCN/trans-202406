<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Using Joins and Subqueries"><div class="chapter" id="nch-multi"><h1><span class="label">Chapter 16. </span>Using Joins and Subqueries</h1><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820341533008"><h5>A note for Early Release readers</h5><p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p></div></aside><section data-type="sect1" data-pdf-bookmark="16.0 Introduction"><div class="sect1" id="nch-multi-multi-intro"><h1>16.0 Introduction</h1><p>Most queries in earlier chapters used a single table, but for any
    application of even moderate complexity, you’ll likely need to use
    multiple tables. Some questions simply cannot be answered using a single
    table, and the real power of a relational database comes into play when
    you combine the information from multiple sources:</p><ul><li><p>Combine rows from tables to obtain more comprehensive
        information than can be obtained from individual tables alone</p></li><li><p>Hold intermediate results for a multiple-stage
        operation</p></li><li><p>Modify rows in one table based on information from
        another</p></li></ul><p>This chapter focuses on two types of statements that use multiple
    tables: joins between tables and subqueries that nest one <code>SELECT</code> within another. It covers the following
    topics:</p><dl><dt>Comparing tables to find matches or mismatches</dt><dd><p>To solve such problems, you should know which types of joins
          apply. Inner joins show which rows in one table match rows in
          another. Outer joins show matching rows, but also find rows in one
          table <em>not</em> matched by rows in another.</p></dd><dt>Deleting unmatched rows</dt><dd><p>If two datasets are related, but imperfectly, you can
          determine which rows are unmatched and remove them as
          necessary.</p></dd><dt>Comparing a table to itself</dt><dd><p>Some problems require comparing a table to itself. This is
          similar to performing a join between different tables, except that
          you must use table aliases to disambiguate table references.</p></dd><dt>Producing candidate-detail and many-to-many relationships</dt><dd><p>Joins enable production of lists or summaries when each item
          in one table can match many in the other, or when each item in
          either table can match many in the other.</p></dd></dl><p>Scripts that create tables used in this chapter are located in the
    <em class="filename">tables</em> directory of the <code>recipes</code> distribution. For scripts that implement
    techniques discussed here, look in the <em class="filename">joins</em> directory.</p></div></section><section data-type="sect1" data-pdf-bookmark="16.1 Finding Matches Between Tables"><div class="sect1" id="nch-multi-multi-inner-join"><h1>16.1 Finding Matches Between Tables</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820341522816"><h2>Problem</h2><p>You need to perform a task that requires information from more than
      one table.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820341521840"><h2>Solution</h2><p>Use a join—that is, a query that lists multiple tables in its <code>FROM</code> clause and
      tells MySQL how to match information from them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820341520480"><h2>Discussion</h2><p>The essential idea behind a join is that it matches rows in one
      table with rows in one or more other tables. Joins enable you to combine
      information from multiple tables when each one answers only part of the
      question in which you’re interested.</p><p>A complete join that produces all possible row combinations is
      called a Cartesian product. For example, joining each row in a 100-row
      table to each row in a 200-row table produces a result containing 100 ×
      200 = 20,000 rows. With larger tables, or joins between more than two
      tables, the result set for a Cartesian product easily becomes immense,
      so a join normally includes an <code>ON</code> or
      <code>USING</code> comparison clause to produce only the desired matches between tables.
      (This requires that each table have one or more columns of common
      information that link them together logically.) You can also include a <code>WHERE</code> clause
      that restricts which of the joined rows to select. Each clause narrows
      the focus of the query.</p><p>This recipe introduces join syntax and demonstrates how joins
      answer specific types of questions when you are looking for matches
      between tables. Other sections show how to identify mismatches between
      tables (see <a data-type="xref" href="#nch-multi-multi-outer-join">Recipe 16.2</a>) and how to
      compare a table to itself (see <a data-type="xref" href="#nch-multi-multi-self-join">Recipe 16.4</a>). The examples assume that you
      have an art collection and use the following two tables to record your
      acquisitions. <code>artist</code> lists those
      painters whose works you want to collect, and <code>painting</code> lists each painting you’ve actually
      purchased:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">artist</code>
<code class="p">(</code>
  <code class="n">a_id</code>  <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="n">AUTO_INCREMENT</code><code class="p">,</code> <code class="o">#</code> <code class="n">artist</code> <code class="n">ID</code>
  <code class="n">name</code>  <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">30</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>                 <code class="o">#</code> <code class="n">artist</code> <code class="n">name</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">a_id</code><code class="p">),</code>
  <code class="k">UNIQUE</code> <code class="p">(</code><code class="n">name</code><code class="p">)</code>
<code class="p">);</code>

<code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">painting</code>
<code class="p">(</code>
  <code class="n">a_id</code>  <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>                <code class="o">#</code> <code class="n">artist</code> <code class="n">ID</code>
  <code class="n">p_id</code>  <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="n">AUTO_INCREMENT</code><code class="p">,</code> <code class="o">#</code> <code class="n">painting</code> <code class="n">ID</code>
  <code class="n">title</code> <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>                <code class="o">#</code> <code class="n">title</code> <code class="k">of</code> <code class="n">painting</code>
  <code class="n">state</code> <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code> <code class="k">NOT</code> <code class="k">NULL</code><code class="p">,</code>                  <code class="o">#</code> <code class="n">state</code> <code class="k">where</code> <code class="n">purchased</code>
  <code class="n">price</code> <code class="nb">INT</code> <code class="n">UNSIGNED</code><code class="p">,</code>                         <code class="o">#</code> <code class="n">purchase</code> <code class="n">price</code> <code class="p">(</code><code class="n">dollars</code><code class="p">)</code>
  <code class="k">INDEX</code> <code class="p">(</code><code class="n">a_id</code><code class="p">),</code>
  <code class="k">PRIMARY</code> <code class="k">KEY</code> <code class="p">(</code><code class="n">p_id</code><code class="p">)</code>
<code class="p">);</code></pre><p>You’ve just begun the collection, so the tables contain only a few
      rows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist ORDER BY a_id;</code></strong>
+------+----------+
| a_id | name     |
+------+----------+
|    1 | Da Vinci |
|    2 | Monet    |
|    3 | Van Gogh |
|    4 | Renoir   |
+------+----------+
mysql&gt; <strong><code>SELECT * FROM painting ORDER BY a_id, p_id;</code></strong>
+------+------+-------------------+-------+-------+
| a_id | p_id | title             | state | price |
+------+------+-------------------+-------+-------+
|    1 |    1 | The Last Supper   | IN    |    34 |
|    1 |    2 | Mona Lisa         | MI    |    87 |
|    3 |    3 | Starry Night      | KY    |    48 |
|    3 |    4 | The Potato Eaters | KY    |    67 |
|    4 |    5 | Les Deux Soeurs   | NE    |    64 |
+------+------+-------------------+-------+-------+</pre><p>The low values in the <code>price</code>
      column of the <code>painting</code> table betray
      the fact that your collection actually contains only cheap imitations,
      not the originals. Well, that’s all right: who can afford the
      originals?</p><p>Each table contains partial information about your collection. For
      example, the <code>artist</code> table doesn’t
      tell you which paintings each artist produced, and the <code>painting</code> table lists artist IDs but not their
      names. To use the information in both tables, write a query that
      performs a join. A join names two or more tables after the <code>FROM</code> keyword. In the output column list, use
      <code>*</code> to select all columns from all
      tables, <em><code>tbl_name</code></em><code>.*</code> to select all columns from a given table,
      or name specific columns from the joined tables or expressions based on
      those columns.</p><p>The simplest join involves two tables and selects all columns from
      each. The following join between the <code>artist</code> and <code>painting</code> tables shows this (the <code>ORDER</code> <code>BY</code>
      clause makes the result easier to read):</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist INNER JOIN painting ORDER BY artist.a_id;</code></strong>
+------+----------+------+------+-------------------+-------+-------+
| a_id | name     | a_id | p_id | title             | state | price |
+------+----------+------+------+-------------------+-------+-------+
|    1 | Da Vinci |    1 |    1 | The Last Supper   | IN    |    34 |
|    1 | Da Vinci |    3 |    3 | Starry Night      | KY    |    48 |
|    1 | Da Vinci |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
|    1 | Da Vinci |    1 |    2 | Mona Lisa         | MI    |    87 |
|    1 | Da Vinci |    3 |    4 | The Potato Eaters | KY    |    67 |
|    2 | Monet    |    1 |    2 | Mona Lisa         | MI    |    87 |
|    2 | Monet    |    3 |    4 | The Potato Eaters | KY    |    67 |
|    2 | Monet    |    1 |    1 | The Last Supper   | IN    |    34 |
|    2 | Monet    |    3 |    3 | Starry Night      | KY    |    48 |
|    2 | Monet    |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
|    3 | Van Gogh |    1 |    2 | Mona Lisa         | MI    |    87 |
|    3 | Van Gogh |    3 |    4 | The Potato Eaters | KY    |    67 |
|    3 | Van Gogh |    1 |    1 | The Last Supper   | IN    |    34 |
|    3 | Van Gogh |    3 |    3 | Starry Night      | KY    |    48 |
|    3 | Van Gogh |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
|    4 | Renoir   |    1 |    1 | The Last Supper   | IN    |    34 |
|    4 | Renoir   |    3 |    3 | Starry Night      | KY    |    48 |
|    4 | Renoir   |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
|    4 | Renoir   |    1 |    2 | Mona Lisa         | MI    |    87 |
|    4 | Renoir   |    3 |    4 | The Potato Eaters | KY    |    67 |
+------+----------+------+------+-------------------+-------+-------+</pre><p>An <code>INNER</code> <code>JOIN</code> produces results that combine values in one table with values in
      another table. The preceding query specifies no restrictions on row
      matching, so the join generates all row combinations (that is, the
      Cartesian product). This result illustrates why such a join generally is
      not useful: it produces a lot of unmeaningful output. Clearly, you don’t
      maintain these tables to match every artist with every painting.</p><div data-type="tip"><h6>Tip</h6><p>
         In MySQL, <code>JOIN</code>, <code>CROSS JOIN</code>, and <code>INNER JOIN</code> are syntactic equivalents and can replace each other. You can use <code>CROSS JOIN</code>, or simply <code>JOIN</code>, in all places where we use <code>INNER JOIN</code>.
       </p></div><p>To answer questions meaningfully, produce only the relevant
      matches by including appropriate join conditions. For example, to
      produce a list of paintings together with the artist names, associate
      rows from the two tables using a simple <code>WHERE</code> clause that matches values based on the
      artist ID column that is common to both tables and serves to link
      them:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist INNER JOIN painting</code></strong>
    -&gt; <strong><code>WHERE artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>ORDER BY artist.a_id;</code></strong>
+------+----------+------+------+-------------------+-------+-------+
| a_id | name     | a_id | p_id | title             | state | price |
+------+----------+------+------+-------------------+-------+-------+
|    1 | Da Vinci |    1 |    1 | The Last Supper   | IN    |    34 |
|    1 | Da Vinci |    1 |    2 | Mona Lisa         | MI    |    87 |
|    3 | Van Gogh |    3 |    3 | Starry Night      | KY    |    48 |
|    3 | Van Gogh |    3 |    4 | The Potato Eaters | KY    |    67 |
|    4 | Renoir   |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
+------+----------+------+------+-------------------+-------+-------+</pre><p>The column names in the <code>WHERE</code>
      clause include table qualifiers to make it clear which <code>a_id</code> values to compare. The result indicates
      who painted each painting, and, conversely, which paintings by each
      artist are in your collection.</p><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820341325728"><h5>Joins and Indexes</h5><p>A join can easily cause MySQL to process large numbers of row combinations, so it’s a
        good idea to index the comparison columns. Otherwise, performance
        drops off quickly as table sizes increase. For the <code>artist</code> and <code>painting</code> tables, joins are made by comparing
        the <code>a_id</code> columns. If you look back
        at the <code>CREATE</code> <code>TABLE</code> statements for those tables, you see
        that <code>a_id</code> is indexed in each
        table.</p></div></aside><p>Another way to write the same join indicates the matching
      conditions with an <code>ON</code> clause:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code>
<code class="k">ON</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code>
<code class="k">ORDER</code> <code class="k">BY</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code><code class="p">;</code></pre><p>In the special case of equality comparisons between columns with
      the same name in both tables, you can use an <code>INNER</code> <code>JOIN</code>
      with a <code>USING</code> clause instead. This requires no table qualifiers and names each
      joined column only once:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code>
<code class="k">USING</code> <code class="p">(</code><code class="n">a_id</code><code class="p">)</code>
<code class="k">ORDER</code> <code class="k">BY</code> <code class="n">a_id</code><code class="p">;</code></pre><p>For <code>SELECT</code> <code>*</code> queries, the <code>USING</code> form produces a result that differs from
      the <code>ON</code> form: it returns only one
      instance of each join column, so <code>a_id</code>
      appears once, not twice.</p><p>Any of <code>ON</code>, <code>USING</code>, or <code>WHERE</code> can include comparisons, so how do you
      know which join conditions to put in each clause? As a rule of thumb,
      it’s conventional to use <code>ON</code> or
      <code>USING</code> to specify how to join the
      tables, and the <code>WHERE</code> clause to
      restrict which of the joined rows to select. For example, to join tables
      based on the <code>a_id</code> column, but select
      only rows for paintings obtained in Kentucky, use an <code>ON</code> (or <code>USING</code>) clause to match the rows in the two
      tables, and a <code>WHERE</code> clause to test
      the <code>state</code> column:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist INNER JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>WHERE painting.state = 'KY';</code></strong>
+------+----------+------+------+-------------------+-------+-------+
| a_id | name     | a_id | p_id | title             | state | price |
+------+----------+------+------+-------------------+-------+-------+
|    3 | Van Gogh |    3 |    3 | Starry Night      | KY    |    48 |
|    3 | Van Gogh |    3 |    4 | The Potato Eaters | KY    |    67 |
+------+----------+------+------+-------------------+-------+-------+</pre><p>The preceding queries use <code>SELECT</code> <code>*</code> to display all columns. To be more
      selective, name only those columns in which you’re interested:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, painting.title, painting.state, painting.price</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>WHERE painting.state = 'KY';</code></strong>
+----------+-------------------+-------+-------+
| name     | title             | state | price |
+----------+-------------------+-------+-------+
| Van Gogh | Starry Night      | KY    |    48 |
| Van Gogh | The Potato Eaters | KY    |    67 |
+----------+-------------------+-------+-------+</pre><p>Joins can use more than two tables. Suppose that you prefer to see
      complete state names rather than abbreviations in the preceding query
      result. The <code>states</code> table used in
      earlier chapters maps state abbreviations to names; add it to the
      previous query to display name rather than abbreviation:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, painting.title, states.name, painting.price</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting INNER JOIN states</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id AND painting.state = states.abbrev</code></strong>
    -&gt; <strong><code>WHERE painting.state = 'KY';</code></strong>
+----------+-------------------+----------+-------+
| name     | title             | name     | price |
+----------+-------------------+----------+-------+
| Van Gogh | Starry Night      | Kentucky |    48 |
| Van Gogh | The Potato Eaters | Kentucky |    67 |
+----------+-------------------+----------+-------+</pre><p>Another common use of three-way joins is enumerating many-to-many
      relationships (see <a data-type="xref" href="#nch-multi-multi-many-to-many">Recipe 16.6</a>).</p><p>By including appropriate conditions in your joins, you can answer
      very specific questions:</p><ul><li><p>Which paintings did Van Gogh paint? Use the <code>a_id</code> value to find matching rows, add a
          <code>WHERE</code> clause to restrict output
          to rows that contain the artist name, and select the title from
          those rows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT painting.title</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>WHERE artist.name = 'Van Gogh';</code></strong>
+-------------------+
| title             |
+-------------------+
| Starry Night      |
| The Potato Eaters |
+-------------------+</pre></li><li><p>Who painted the <em>Mona Lisa</em>? Again, use the
          <code>a_id</code> column to join the rows, but
          this time use the <code>WHERE</code> clause to
          restrict output to rows that contain the title, and select the
          artist name from those rows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>WHERE painting.title = 'Mona Lisa';</code></strong>
+----------+
| name     |
+----------+
| Da Vinci |
+----------+</pre></li><li><p>For which artists did you purchase paintings in Kentucky or
          Indiana? This is similar to the previous statement, but tests a
          different column in the <code>painting</code>
          table (<code>state</code>) to restrict output
          to rows for <code>KY</code> or <code>IN</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DISTINCT artist.name</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>WHERE painting.state IN ('KY','IN');</code></strong>
+----------+
| name     |
+----------+
| Da Vinci |
| Van Gogh |
+----------+</pre><p>The statement also uses <code>DISTINCT</code> to display each artist name just once. Try it without <code>DISTINCT</code>; Van Gogh appears twice because
          you obtained two Van Goghs in Kentucky.</p></li><li><p>Joins used with aggregate functions produce summaries. This statement
          shows how many paintings you have per artist:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, COUNT(*) AS 'number of paintings'</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>GROUP BY artist.name;</code></strong>
+----------+---------------------+
| name     | number of paintings |
+----------+---------------------+
| Da Vinci |                   2 |
| Renoir   |                   1 |
| Van Gogh |                   2 |
+----------+---------------------+</pre><p>A more elaborate statement uses aggregates to also show how
          much you paid for each artist’s paintings, in total and on
          average:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name,</code></strong>
    -&gt; <strong><code>COUNT(*) AS 'number of paintings',</code></strong>
    -&gt; <strong><code>SUM(painting.price) AS 'total price',</code></strong>
    -&gt; <strong><code>AVG(painting.price) AS 'average price'</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>GROUP BY artist.name;</code></strong>
+----------+---------------------+-------------+---------------+
| name     | number of paintings | total price | average price |
+----------+---------------------+-------------+---------------+
| Da Vinci |                   2 |         121 |       60.5000 |
| Renoir   |                   1 |          64 |       64.0000 |
| Van Gogh |                   2 |         115 |       57.5000 |
+----------+---------------------+-------------+---------------+</pre></li></ul><p>The preceding summary statements produce output only for those
      artists in the <code>artist</code> table for whom
      you actually have acquired paintings. (For example, Monet is listed in
      the <code>artist</code> table but is not present
      in the summary because you have none of his paintings yet.) To summarize
      all artists, including those for whom you have no paintings, you must
      use a different kind of join—specifically, an outer join:</p><ul><li><p>Joins written with <code>INNER</code>
          <code>JOIN</code> are inner joins. They
          produce a result only for values in one table that match values in
          another table.</p></li><li><p>An outer join can produce those matches as well, but also can show you
          which values in one table are missing from the other. <a data-type="xref" href="#nch-multi-multi-outer-join">Recipe 16.2</a> introduces outer
          joins.</p></li></ul><p>The <em><code>tbl_name.col_name</code></em> notation that
      qualifies a column name with a table name is always permitted in a join
      but can be shortened to just <em><code>col_name</code></em> if the
      name appears in only one of the joined tables. In that case, MySQL can
      determine without ambiguity which table the column comes from, and no
      table name qualifier is necessary. We can’t do that for the following
      join. Both tables have an <code>a_id</code>
      column, so the <code>ON</code> clause column
      references are ambiguous:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist INNER JOIN painting ON a_id = a_id;</code></strong>
ERROR 1052 (23000): Column 'a_id' in on clause is ambiguous</pre><p>By contrast, the following query is unambiguous. Each instance of
      <code>a_id</code> is qualified with the
      appropriate table name, only <code>artist</code>
      has a <code>name</code> column, and only <code>painting</code> has <code>title</code> and <code>state</code> columns:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, title, state FROM artist INNER JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>ORDER BY name;</code></strong>
+----------+-------------------+-------+
| name     | title             | state |
+----------+-------------------+-------+
| Da Vinci | The Last Supper   | IN    |
| Da Vinci | Mona Lisa         | MI    |
| Renoir   | Les Deux Soeurs   | NE    |
| Van Gogh | Starry Night      | KY    |
| Van Gogh | The Potato Eaters | KY    |
+----------+-------------------+-------+</pre><p>To make the meaning of a statement clearer to human readers, it’s
      often useful to qualify column names even when that’s not strictly
      necessary as far as MySQL is concerned. We tend to use qualified names in
      join examples for that reason.</p><p>To avoid writing complete table names when qualifying column
      references, give each table a short alias and refer to its columns using
      the alias. The following two statements are equivalent:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">artist</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">title</code><code class="p">,</code> <code class="n">states</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code>
<code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">states</code>
<code class="k">ON</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code> <code class="k">AND</code> <code class="n">painting</code><code class="p">.</code><code class="n">state</code> <code class="o">=</code> <code class="n">states</code><code class="p">.</code><code class="n">abbrev</code><code class="p">;</code>

<code class="k">SELECT</code> <code class="n">a</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">p</code><code class="p">.</code><code class="n">title</code><code class="p">,</code> <code class="n">s</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">p</code><code class="p">.</code><code class="n">price</code>
<code class="k">FROM</code> <code class="n">artist</code> <code class="k">AS</code> <code class="n">a</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code> <code class="k">AS</code> <code class="n">p</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">states</code> <code class="k">AS</code> <code class="n">s</code>
<code class="k">ON</code> <code class="n">a</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">p</code><code class="p">.</code><code class="n">a_id</code> <code class="k">AND</code> <code class="n">p</code><code class="p">.</code><code class="n">state</code> <code class="o">=</code> <code class="n">s</code><code class="p">.</code><code class="n">abbrev</code><code class="p">;</code></pre><p>In <code>AS</code>
      <em><code>alias_name</code></em> clauses, the <code>AS</code> is optional.</p><p>For complicated statements that select many columns, aliases
      can save a lot of typing. In addition, for some types of
      statements, aliases are not only convenient but necessary, as will
      become evident when we get to the topic of self-joins (see <a data-type="xref" href="#nch-multi-multi-self-join">Recipe 16.4</a>).</p><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820341077408"><h5>Joining Tables from Different Databases</h5><p>To perform a join between tables located in different databases, qualify table and
        column names sufficiently that MySQL knows what you’re referring to.
        Thus far, we have used the <code>artist</code>
        and <code>painting</code> tables with the
        implicit understanding that both are in the <code>cookbook</code> database, so we can simply refer to
        the tables without specifying any database name when <code>cookbook</code> is the default database. For
        example, the following statement uses the two tables to associate
        artists with their paintings:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">artist</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">title</code>
<code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code>
<code class="k">ON</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code><code class="p">;</code></pre><p>But suppose instead that <code>artist</code> is in the <code>db1</code> database and <code>painting</code> is in the <code>db2</code> database. To indicate this, qualify each
        table name with a prefix that specifies which database it’s in. The
        fully qualified form of the join looks like this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">db1</code><code class="p">.</code><code class="n">artist</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">db2</code><code class="p">.</code><code class="n">painting</code><code class="p">.</code><code class="n">title</code>
<code class="k">FROM</code> <code class="n">db1</code><code class="p">.</code><code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">db2</code><code class="p">.</code><code class="n">painting</code>
<code class="k">ON</code> <code class="n">db1</code><code class="p">.</code><code class="n">artist</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">db2</code><code class="p">.</code><code class="n">painting</code><code class="p">.</code><code class="n">a_id</code><code class="p">;</code></pre><p>Table aliases can simplify that considerably:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">a</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">p</code><code class="p">.</code><code class="n">title</code>
<code class="k">FROM</code> <code class="n">db1</code><code class="p">.</code><code class="n">artist</code> <code class="k">AS</code> <code class="n">a</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">db2</code><code class="p">.</code><code class="n">painting</code> <code class="k">AS</code> <code class="n">p</code>
<code class="k">ON</code> <code class="n">a</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">p</code><code class="p">.</code><code class="n">a_id</code><code class="p">;</code></pre><p>If there is no default database, or it is neither <code>db1</code> nor <code>db2</code>, it’s necessary to fully qualify both
        table names. If the default database is either <code>db1</code> or <code>db2</code>, you can dispense with the corresponding
        qualifiers. If the default database is <code>db1</code>, you can omit the <code>db1</code> qualifiers. Conversely, if the default
        database is <code>db2</code>, no <code>db2</code> qualifiers are necessary.</p></div></aside></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.2 Finding Mismatches Between Tables"><div class="sect1" id="nch-multi-multi-outer-join"><h1>16.2 Finding Mismatches Between Tables</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820340864624"><h2>Problem</h2><p>You want to find rows in one table that have no match in another. Or you want to
      produce a list on the basis of a join between tables, and you want the
      list to include an entry for every row in the first table, including
      those for which no match occurs in the second table.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820340863680"><h2>Solution</h2><p>Use an outer join (a <code>LEFT</code>
      <code>JOIN</code> or a <code>RIGHT</code> <code>JOIN</code>)
      or a <code>NOT</code> <code>IN</code> subquery.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820340862688"><h2>Discussion</h2><p><a data-type="xref" href="#nch-multi-multi-inner-join">Recipe 16.1</a> focuses on inner
      joins, which find matches between two tables. However, the answers to
      some questions require determining which rows do
      <em>not</em> have a match (or, stated another way, which
      rows have values missing from the other table). For example, you might
      want to know artists in the <code>artist</code>
      table for whom you have no paintings yet. Similar questions occur in
      other contexts:</p><ul><li><p>You have a list of potential customers, and another list of
          people who have placed orders. To focus sales efforts on people who
          are not yet actual customers, produce the set of people who are in
          the first list but not the second.</p></li><li><p>You have one list of baseball players, and another list of
          players who have hit home runs. To determine which players in the
          first list have <em>not</em> hit a home run, produce the
          set of players who are in the first list but not the second.</p></li></ul><p>These types of questions require use of an outer join. Like inner
      joins, an outer join finds matches between tables. But unlike an inner
      join, an outer join also determines which rows in one table have no
      match in another. Two types of outer join are <code>LEFT</code> <code>JOIN</code>
      and <code>RIGHT</code> <code>JOIN</code>.</p><p>To see how outer joins are useful, consider the problem of
      determining which artists in the <code>artist</code> table are missing from the <code>painting</code> table. At present, the tables are
      small, so it’s easy to examine them visually and see that you have no
      paintings by Monet (there are no <code>painting</code> rows with an <code>a_id</code> value of 2):</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist ORDER BY a_id;</code></strong>
+------+----------+
| a_id | name     |
+------+----------+
|    1 | Da Vinci |
|    2 | Monet    |
|    3 | Van Gogh |
|    4 | Renoir   |
+------+----------+
mysql&gt; <strong><code>SELECT * FROM painting ORDER BY a_id, p_id;</code></strong>
+------+------+-------------------+-------+-------+
| a_id | p_id | title             | state | price |
+------+------+-------------------+-------+-------+
|    1 |    1 | The Last Supper   | IN    |    34 |
|    1 |    2 | Mona Lisa         | MI    |    87 |
|    3 |    3 | Starry Night      | KY    |    48 |
|    3 |    4 | The Potato Eaters | KY    |    67 |
|    4 |    5 | Les Deux Soeurs   | NE    |    64 |
+------+------+-------------------+-------+-------+</pre><p>As you acquire more paintings and the tables get larger, it won’t
      be so easy to eyeball them and answer questions by inspection. Can you
      answer it using SQL? Sure, although first attempts at a solution often
      look something like the following statement, which uses a not-equal
      condition to look for mismatches between the two tables:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist INNER JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id &lt;&gt; painting.a_id</code></strong>
    -&gt; <strong><code>ORDER BY artist.a_id;</code></strong>
+------+----------+------+------+-------------------+-------+-------+
| a_id | name     | a_id | p_id | title             | state | price |
+------+----------+------+------+-------------------+-------+-------+
|    1 | Da Vinci |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
|    1 | Da Vinci |    3 |    4 | The Potato Eaters | KY    |    67 |
|    1 | Da Vinci |    3 |    3 | Starry Night      | KY    |    48 |
|    2 | Monet    |    1 |    1 | The Last Supper   | IN    |    34 |
|    2 | Monet    |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
|    2 | Monet    |    3 |    4 | The Potato Eaters | KY    |    67 |
|    2 | Monet    |    3 |    3 | Starry Night      | KY    |    48 |
|    2 | Monet    |    1 |    2 | Mona Lisa         | MI    |    87 |
|    3 | Van Gogh |    1 |    2 | Mona Lisa         | MI    |    87 |
|    3 | Van Gogh |    1 |    1 | The Last Supper   | IN    |    34 |
|    3 | Van Gogh |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
|    4 | Renoir   |    3 |    3 | Starry Night      | KY    |    48 |
|    4 | Renoir   |    1 |    2 | Mona Lisa         | MI    |    87 |
|    4 | Renoir   |    1 |    1 | The Last Supper   | IN    |    34 |
|    4 | Renoir   |    3 |    4 | The Potato Eaters | KY    |    67 |
+------+----------+------+------+-------------------+-------+-------+</pre><p>The query may look plausible but its result obviously is not. For
      example, it falsely indicates that each painting was painted by several
      different artists. The problem is that the statement lists all
      combinations of values from the two tables in which the artist ID values
      aren’t the same. What you really need is a list of values in <code>artist</code> that aren’t present
      <em>at</em> <em>all</em> in <code>painting</code>, but an inner join can only produce
      results based on values that are present in both tables. It can’t tell
      you anything about values that are missing from one of them.</p><p>When faced with the need to find values in one table with no match
      in (or missing from) another table, you should get in the habit of
      thinking, <q>Aha, that’s a <code>LEFT</code>
      <code>JOIN</code> problem.</q> A <code>LEFT</code> <code>JOIN</code>
      is one type of outer join: it’s similar to an inner join in that it
      matches rows in the first (left) table with rows in the second (right)
      table. In addition, if a left table row has no match in the right table,
      a <code>LEFT</code> <code>JOIN</code> still produces a row—one in which all the
      columns from the right table are set to <code>NULL</code>. This means you
      can find values that are missing from the right table by looking for
      <code>NULL</code>. It’s easier to understand how
      this happens by working in stages. Begin with an inner join that
      displays matching rows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist INNER JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>ORDER BY artist.a_id;</code></strong>
+------+----------+------+------+-------------------+-------+-------+
| a_id | name     | a_id | p_id | title             | state | price |
+------+----------+------+------+-------------------+-------+-------+
|    1 | Da Vinci |    1 |    1 | The Last Supper   | IN    |    34 |
|    1 | Da Vinci |    1 |    2 | Mona Lisa         | MI    |    87 |
|    3 | Van Gogh |    3 |    3 | Starry Night      | KY    |    48 |
|    3 | Van Gogh |    3 |    4 | The Potato Eaters | KY    |    67 |
|    4 | Renoir   |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
+------+----------+------+------+-------------------+-------+-------+</pre><p>In this output, the first <code>a_id</code>
      column comes from the <code>artist</code> table
      and the second one comes from the <code>painting</code> table.</p><p>Now substitute <code>LEFT</code> for
      <code>INNER</code> to see the result you get from
      an outer join:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist LEFT JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>ORDER BY artist.a_id;</code></strong>
+------+----------+------+------+-------------------+-------+-------+
| a_id | name     | a_id | p_id | title             | state | price |
+------+----------+------+------+-------------------+-------+-------+
|    1 | Da Vinci |    1 |    1 | The Last Supper   | IN    |    34 |
|    1 | Da Vinci |    1 |    2 | Mona Lisa         | MI    |    87 |
|    2 | Monet    | NULL | NULL | NULL              | NULL  |  NULL |
|    3 | Van Gogh |    3 |    3 | Starry Night      | KY    |    48 |
|    3 | Van Gogh |    3 |    4 | The Potato Eaters | KY    |    67 |
|    4 | Renoir   |    4 |    5 | Les Deux Soeurs   | NE    |    64 |
+------+----------+------+------+-------------------+-------+-------+</pre><p>Compared to the inner join, the outer join produces an additional
      row for every <code>artist</code> row that has no
      <code>painting</code> table match, with all
      <code>painting</code> columns set to <code>NULL</code>.</p><p>Next, to restrict the output only to the unnmatched <code>artist</code> rows, add a <code>WHERE</code> clause that looks for <code>NULL</code>
      values in any <code>painting</code> column that
      cannot otherwise contain <code>NULL</code>. This
      filters out the rows that the inner join produces, leaving those
      produced only by the outer join:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist LEFT JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>WHERE painting.a_id IS NULL;</code></strong>
+------+-------+------+------+-------+-------+-------+
| a_id | name  | a_id | p_id | title | state | price |
+------+-------+------+------+-------+-------+-------+
|    2 | Monet | NULL | NULL | NULL  | NULL  |  NULL |
+------+-------+------+------+-------+-------+-------+</pre><p>Finally, to show only the <code>artist</code> table values that are missing from the
      <code>painting</code> table, write the output
      column list to name only columns from the <code>artist</code> table. The result is that the <code>LEFT</code> <code>JOIN</code>
      lists those left-table rows containing <code>a_id</code> values not present in the right
      table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.* FROM artist LEFT JOIN painting</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>WHERE painting.a_id IS NULL;</code></strong>
+------+-------+
| a_id | name  |
+------+-------+
|    2 | Monet |
+------+-------+</pre><p>A similar kind of operation reports each left-table value along
      with an indicator as to whether it’s present in the right table. To do
      this, perform a <code>LEFT</code> <code>JOIN</code> that counts the number of times each
      left-table value occurs in the right table. A count of zero indicates
      that the value is not present. The following statement lists each artist
      from the <code>artist</code> table and shows
      whether you have any paintings by the artist:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name,</code></strong>
    -&gt; <strong><code>IF(COUNT(painting.a_id)&gt;0,'yes','no') AS 'in collection?'</code></strong>
    -&gt; <strong><code>FROM artist LEFT JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>GROUP BY artist.name;</code></strong>
+----------+----------------+
| name     | in collection? |
+----------+----------------+
| Da Vinci | yes            |
| Monet    | no             |
| Renoir   | yes            |
| Van Gogh | yes            |
+----------+----------------+</pre><p>A <code>RIGHT</code> <code>JOIN</code> is an outer join that is like <code>LEFT</code> <code>JOIN</code>
      but reverses the roles of the left and right tables. Semantically,
      <code>RIGHT</code> <code>JOIN</code> forces the matching process to produce a row from each table in
      the right table, even in the absence of a corresponding row in the left
      table. Syntactically, <em><code>tbl1</code></em> <code>LEFT</code> <code>JOIN</code>
      <em><code>tbl2</code></em> is equivalent to
      <em><code>tbl2</code></em> <code>RIGHT</code>
      <code>JOIN</code> <em><code>tbl1</code></em>.
      Therefore, references to <code>LEFT</code>
      <code>JOIN</code> in this book apply to <code>RIGHT</code> <code>JOIN</code>
      as well if you reverse the roles of the tables.</p><p>Another way to identify values present in one table but missing
      from another is to use a <code>NOT</code> <code>IN</code> subquery. The following example finds
      artists not represented in the <code>painting</code> table; compare it to the earlier
      <code>LEFT</code> <code>JOIN</code> that answers the same question:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM artist</code></strong>
    -&gt; <strong><code>WHERE a_id NOT IN (SELECT a_id FROM painting);</code></strong>
+------+-------+
| a_id | name  |
+------+-------+
|    2 | Monet |
+------+-------+</pre><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820340795520"><h5>Other Ways to Write LEFT JOIN and RIGHT JOIN Queries</h5><p>As with <code>INNER</code> <code>JOIN</code>, if the names of the columns to be
        matched in an outer join are the same in both tables and you compare
        them with the <code>=</code> operator, you can
        use a <code>USING</code> clause
        rather than <code>ON</code>. For example, the
        following two statements are equivalent:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">t1</code> <code class="k">LEFT</code> <code class="k">JOIN</code> <code class="n">t2</code> <code class="k">ON</code> <code class="n">t1</code><code class="p">.</code><code class="n">n</code> <code class="o">=</code> <code class="n">t2</code><code class="p">.</code><code class="n">n</code><code class="p">;</code>
<code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">t1</code> <code class="k">LEFT</code> <code class="k">JOIN</code> <code class="n">t2</code> <code class="k">USING</code> <code class="p">(</code><code class="n">n</code><code class="p">);</code></pre><p>As are these:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">t1</code> <code class="k">RIGHT</code> <code class="k">JOIN</code> <code class="n">t2</code> <code class="k">ON</code> <code class="n">t1</code><code class="p">.</code><code class="n">n</code> <code class="o">=</code> <code class="n">t2</code><code class="p">.</code><code class="n">n</code><code class="p">;</code>
<code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">t1</code> <code class="k">RIGHT</code> <code class="k">JOIN</code> <code class="n">t2</code> <code class="k">USING</code> <code class="p">(</code><code class="n">n</code><code class="p">);</code></pre><p>In the special case that you want to base the comparison on
        every column that appears in both tables, you can use <code>NATURAL</code> <code>LEFT</code> <code>JOIN</code>
        or <code>NATURAL</code> <code>RIGHT</code> <code>JOIN</code> and omit the <code>ON</code> or <code>USING</code> clause:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">t1</code> <code class="k">NATURAL</code> <code class="k">LEFT</code> <code class="k">JOIN</code> <code class="n">t2</code><code class="p">;</code>
<code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">t1</code> <code class="k">NATURAL</code> <code class="k">RIGHT</code> <code class="k">JOIN</code> <code class="n">t2</code><code class="p">;</code></pre></div></aside></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820340674336"><h2>See Also</h2><p>As shown in this section, <code>LEFT</code>
      <code>JOIN</code> is useful for finding values
      with no match in another table or for showing whether each value is
      matched. <code>LEFT</code> <code>JOIN</code> may also be used to produce a summary
      that includes all items in a list, even those for which there’s nothing
      to summarize. This is very common for relationships between a candidate
      table and a detail table. For example, a <code>LEFT</code> <code>JOIN</code>
      can produce <q>total sales per customer</q> reports that list
      all customers, even those who bought nothing during the summary period.
      (For information about candidate-detail lists, see <a data-type="xref" href="#nch-multi-multi-one-to-many">Recipe 16.5</a>.)</p><p><code>LEFT</code> <code>JOIN</code> is also useful for consistency checking
      when you receive two datafiles that are supposed to be related, and you
      want to determine whether they really are. (That is, you want to check
      the integrity of their relationship.) Import each file into a MySQL
      table, and then run a couple <code>LEFT</code>
      <code>JOIN</code> statements to determine whether
      there are unattached rows in one table or the other—that is, rows that
      have no match in the other table. <a data-type="xref" href="#nch-multi-multi-delete-unrelated">Recipe 16.3</a> discusses how to identify
      (and optionally delete) these unattached rows.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.3 Identifying and Removing Mismatched or Unattached Rows"><div class="sect1" id="nch-multi-multi-delete-unrelated"><h1>16.3 Identifying and Removing Mismatched or Unattached Rows</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820340647216"><h2>Problem</h2><p>You have two datasets that are related, but possibly imperfectly so. You want to
      determine whether there are records in either dataset that are
      <q>unattached</q> (not matched by any record in the other
      dataset), and perhaps remove them if so.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820340645856"><h2>Solution</h2><p>To identify unmatched values in each table, use a <code>LEFT</code> <code>JOIN</code> or a <code>NOT</code> <code>IN</code>
      subquery. To remove them, use <code>DELETE</code> with a
      <code>NOT</code> <code>IN</code> subquery.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820340641488"><h2>Discussion</h2><p>Inner joins are useful for identifying matches, and outer joins
      are useful for identifying mismatches. This property of outer joins is
      valuable when you have related datasets for which the relationship might
      be imperfect. Mismatches might be found, for example, when you must
      verify the integrity of two datafiles received from an external
      source.</p><p>When you have related tables with unmatched rows, you can analyze
      and modify them using SQL statements. Specifically, restoring their
      relationship is a matter of identifying the unattached rows and then
      deleting them:</p><ul><li><p>To identify unattached rows, use a <code>LEFT</code> <code>JOIN</code>, because this is a <q>find
          unmatched rows</q> problem; alternatively, use a <code>NOT</code> <code>IN</code>
          subquery (see <a data-type="xref" href="#nch-multi-multi-outer-join">Recipe 16.2</a>).</p></li><li><p>To delete rows that are unmatched, use <code>DELETE</code> with a <code>NOT</code> <code>IN</code>
          subquery.</p></li></ul><p>It’s useful to know about unmatched data because you can alert
      whoever gave you the data. The data collection method might have a flaw
      that must be corrected. For example, with sales data, a missing region
      might mean that some regional manager didn’t report in and the omission
      was overlooked.</p><p>The following example shows how to identify and remove mismatched
      rows using two datasets that describe sales regions and volume of sales
      per region. One dataset contains the ID and location of each
      region:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM sales_region ORDER BY region_id;</code></strong>
+-----------+------------------------+
| region_id | name                   |
+-----------+------------------------+
|         1 | London, United Kingdom |
|         2 | Madrid, Spain          |
|         3 | Berlin, Germany        |
|         4 | Athens, Greece         |
+-----------+------------------------+</pre><p>The other dataset contains sales volume figures. Each row contains
      the amount of sales for a given quarter of a year and indicates the
      sales region to which the row applies:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT region_id, year, quarter, volume</code></strong>
    -&gt; <strong><code>FROM sales_volume ORDER BY region_id, year, quarter;</code></strong>
+-----------+------+---------+--------+
| region_id | year | quarter | volume |
+-----------+------+---------+--------+
|         1 | 2014 |       1 | 100400 |
|         1 | 2014 |       2 | 120000 |
|         3 | 2014 |       1 | 280000 |
|         3 | 2014 |       2 | 250000 |
|         5 | 2014 |       1 |  18000 |
|         5 | 2014 |       2 |  32000 |
+-----------+------+---------+--------+</pre><p>A little visual inspection reveals that neither table is fully
      matched by the other. Sales regions 2 and 4 are not represented in the
      sales volume table, and the sales volume table contains rows for region
      5, which is not in the sales region table. But we don’t want to check
      the tables by inspection. We want to find unmatched rows by using SQL
      statements that do the work.</p><p>Mismatch identification is a matter of using outer joins. For
      example, to find sales regions for which there are no sales volume rows,
      use the following <code>LEFT</code> <code>JOIN</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT sales_region.region_id AS 'unmatched region row IDs'</code></strong>
    -&gt; <strong><code>FROM sales_region LEFT JOIN sales_volume</code></strong>
    -&gt;   <strong><code>ON sales_region.region_id = sales_volume.region_id</code></strong>
    -&gt; <strong><code>WHERE sales_volume.region_id IS NULL;</code></strong>
+--------------------------+
| unmatched region row IDs |
+--------------------------+
|                        2 |
|                        4 |
+--------------------------+</pre><p>Conversely, to find sales volume rows that are not associated with
      any known region, reverse the roles of the two tables:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT sales_volume.region_id AS 'unmatched volume row IDs'</code></strong>
    -&gt; <strong><code>FROM sales_volume LEFT JOIN sales_region</code></strong>
    -&gt;   <strong><code>ON sales_volume.region_id = sales_region.region_id</code></strong>
    -&gt; <strong><code>WHERE sales_region.region_id IS NULL;</code></strong>
+--------------------------+
| unmatched volume row IDs |
+--------------------------+
|                        5 |
|                        5 |
+--------------------------+</pre><p>In this case, an ID appears more than once in the list if there are
      multiple volume rows for a missing region. To see each unmatched ID only
      once, use <code>SELECT</code> <code>DISTINCT</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DISTINCT sales_volume.region_id AS 'unmatched volume row IDs'</code></strong>
    -&gt; <strong><code>FROM sales_volume LEFT JOIN sales_region</code></strong>
    -&gt;   <strong><code>ON sales_volume.region_id = sales_region.region_id</code></strong>
    -&gt; <strong><code>WHERE sales_region.region_id IS NULL</code></strong>
+--------------------------+
| unmatched volume row IDs |
+--------------------------+
|                        5 |
+--------------------------+</pre><p>You can also identify mismatches using <code>NOT</code> <code>IN</code>
      subqueries:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT region_id AS 'unmatched region row IDs'</code></strong>
    -&gt; <strong><code>FROM sales_region</code></strong>
    -&gt; <strong><code>WHERE region_id NOT IN (SELECT region_id FROM sales_volume);</code></strong>
+--------------------------+
| unmatched region row IDs |
+--------------------------+
|                        2 |
|                        4 |
+--------------------------+
mysql&gt; <strong><code>SELECT region_id AS 'unmatched volume row IDs'</code></strong>
    -&gt; <strong><code>FROM sales_volume</code></strong>
    -&gt; <strong><code>WHERE region_id NOT IN (SELECT region_id FROM sales_region);</code></strong>
+--------------------------+
| unmatched volume row IDs |
+--------------------------+
|                        5 |
|                        5 |
+--------------------------+</pre><p>To get rid of unmatched rows, use a <code>NOT</code> <code>IN</code>
      subquery in a <code>DELETE</code> statement. To
      remove <code>sales_region</code> rows that match
      no <code>sales_volume</code> rows, do this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">DELETE</code> <code class="k">FROM</code> <code class="n">sales_region</code>
<code class="k">WHERE</code> <code class="n">region_id</code> <code class="k">NOT</code> <code class="k">IN</code> <code class="p">(</code><code class="k">SELECT</code> <code class="n">region_id</code> <code class="k">FROM</code> <code class="n">sales_volume</code><code class="p">);</code></pre><p>To remove mismatched <code>sales_volume</code> rows that match no <code>sales_region</code> rows, the statement is similar
      but with the table roles reversed:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">DELETE</code> <code class="k">FROM</code> <code class="n">sales_volume</code>
<code class="k">WHERE</code> <code class="n">region_id</code> <code class="k">NOT</code> <code class="k">IN</code> <code class="p">(</code><code class="k">SELECT</code> <code class="n">region_id</code> <code class="k">FROM</code> <code class="n">sales_region</code><code class="p">);</code></pre><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="nch-multi-multi-fks"><h5>Using Foreign Keys to Enforce Referential Integrity and Prevent Mismatches</h5><p>One feature a database system offers to help you maintain consistency
        between tables is the ability to define foreign key relationships.
        This means you can specify explicitly in the table definition that a
        primary key in a parent table (such as the <code>region_id</code> column of the <code>sales_region</code> table) is a parent to a key in
        another table (the <code>region_id</code> column
        in the <code>sales_volume</code> table). </p><p>By defining the ID column in the child table as a foreign key to
        the ID column in the parent, the database system can enforce certain
        constraints against illegal operations. For example, it can prevent
        you from creating a child row with an ID not present in the parent or
        from deleting parent rows without also deleting the corresponding
        child rows first. A foreign key implementation may also offer cascaded
        delete and update: if you delete or update a parent row, the database
        engine cascades the effect of the delete or update to any child tables
        and automatically deletes or updates the child rows for you. The
        InnoDB storage engine in MySQL supports foreign keys and
        cascaded deletes and updates.</p></div></aside></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.4 Comparing a Table to Itself"><div class="sect1" id="nch-multi-multi-self-join"><h1>16.4 Comparing a Table to Itself</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820340524112"><h2>Problem</h2><p>You want to compare rows in a table to other rows in the same table.
      For example, you want to find all paintings in your collection by the
      artist who painted <em>The Potato Eaters</em>. Or you want
      to know which states listed in the <code>states</code> table joined the Union in the same year
      as New York. Or you want to know which states did not join the Union in
      the same year as any other state.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820340522144"><h2>Solution</h2><p>Problems that require comparing a table to itself involve an operation known as a self-join.
      It’s performed much like other joins, except that you must use table
      aliases so that you can refer to the same table different ways within
      the statement.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820340516720"><h2>Discussion</h2><p>A special case of joining one table to another occurs when both
      tables are the same. This is called a self-join. This may be confusing or strange to think about at first, but
      it’s perfectly legal. You’ll likely find yourself using self-joins quite
      often because they are so important.</p><p>A tip-off that a self-join is required is that you want to know
      which pairs of rows in a table satisfy some condition. Suppose that your
      favorite painting is <em>The Potato Eaters</em>, and you
      want to identify all items in your collection that were painted by the
      same artist. The artist ID and painting titles that we begin with look
      like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT a_id, title FROM painting ORDER BY a_id;</code></strong>
+------+-------------------+
| a_id | title             |
+------+-------------------+
|    1 | The Last Supper   |
|    1 | Mona Lisa         |
|    3 | Starry Night      |
|    3 | The Potato Eaters |
|    4 | Les Deux Soeurs   |
+------+-------------------+</pre><p>Solve the problem as follows:</p><ol><li><p>Identify which <code>painting</code>
          table row contains the title <em>The Potato Eaters</em>,
          so that you can refer to its <code>a_id</code>
          value.</p></li><li><p>Match other rows in the table that have the same <code>a_id</code> value.</p></li><li><p>Display the titles from those matching rows.</p></li></ol><p>The trick lies in using the proper notation. First attempts at
      joining a table to itself often look something like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT title</code></strong>
    -&gt; <strong><code>FROM painting INNER JOIN painting</code></strong>
    -&gt; <strong><code>ON a_id = a_id</code></strong>
    -&gt; <strong><code>WHERE title = 'The Potato Eaters';</code></strong>
ERROR 1066 (42000): Not unique table/alias: 'painting'</pre><p>The column references in that statement are ambiguous because
      MySQL cannot tell which instance of the <code>painting</code> table any given column name refers
      to. The solution is to alias at least one instance of the table so that
      you can distinguish column references by using different table
      qualifiers. The following statement shows how to do this, using the
      aliases <code>p1</code> and <code>p2</code> to refer to the <code>painting</code> table different ways:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT p2.title</code></strong>
    -&gt; <strong><code>FROM painting AS p1 INNER JOIN painting AS p2</code></strong>
    -&gt; <strong><code>ON p1.a_id = p2.a_id</code></strong>
    -&gt; <strong><code>WHERE p1.title = 'The Potato Eaters';</code></strong>
+-------------------+
| title             |
+-------------------+
| Starry Night      |
| The Potato Eaters |
+-------------------+</pre><p>The statement output illustrates something typical of self-joins:
      when you begin with a reference value in one table instance
      (<em>The Potato Eaters</em>) to find matching rows in a
      second table instance (paintings by the same artist), the output
      includes the reference value. That makes sense: after all, the reference
      matches itself. To find only <em>other</em> paintings by the
      same artist, explicitly exclude the reference value from the
      output:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT p2.title</code></strong>
    -&gt; <strong><code>FROM painting AS p1 INNER JOIN painting AS p2</code></strong>
    -&gt; <strong><code>ON p1.a_id = p2.a_id</code></strong>
    -&gt; <strong><code>WHERE p1.title = 'The Potato Eaters' AND p2.title &lt;&gt; p1.title</code></strong>
+--------------+
| title        |
+--------------+
| Starry Night |
+--------------+</pre><p>The preceding statements use ID value comparisons to match rows in
      the two table instances, but any kind of value can be used. For example,
      to use the <code>states</code> table to answer the
      question <q>Which states joined the Union in the same year as New
      York?</q> perform a temporal pairwise comparison based on the year
      part of the dates in the table’s <code>statehood</code> column:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT s2.name, s2.statehood</code></strong>
    -&gt; <strong><code>FROM states AS s1 INNER JOIN states AS s2</code></strong>
    -&gt; <strong><code>ON YEAR(s1.statehood) = YEAR(s2.statehood) AND s1.name &lt;&gt; s2.name</code></strong>
    -&gt; <strong><code>WHERE s1.name = 'New York'</code></strong>
    -&gt; <strong><code>ORDER BY s2.name;</code></strong>
+----------------+------------+
| name           | statehood  |
+----------------+------------+
| Connecticut    | 1788-01-09 |
| Georgia        | 1788-01-02 |
| Maryland       | 1788-04-28 |
| Massachusetts  | 1788-02-06 |
| New Hampshire  | 1788-06-21 |
| South Carolina | 1788-05-23 |
| Virginia       | 1788-06-25 |
+----------------+------------+</pre><div data-type="note" epub:type="note"><h6>Note</h6><p>
          In the example above we do not specify the year when New York joined the Union. Instead, we compare the value of the <code>statehood</code> column for the row where state name is “New York” and the same <code>statehood</code> column for other states.
        </p></div><p>Now suppose that you want to find <em>every</em> pair
      of states that joined the Union in the same year. In this case, the
      output potentially can include any pair of rows from the <code>states</code> table. A self-join is perfect for this
      problem:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT YEAR(s1.statehood) AS year,</code></strong>
    -&gt; <strong><code>s1.name AS name1, s1.statehood AS statehood1,</code></strong>
    -&gt; <strong><code>s2.name AS name2, s2.statehood AS statehood2</code></strong>
    -&gt; <strong><code>FROM states AS s1 INNER JOIN states AS s2</code></strong>
    -&gt; <strong><code>ON YEAR(s1.statehood) = YEAR(s2.statehood) AND s1.name &lt;&gt; s2.name</code></strong>
    -&gt; <strong><code>ORDER BY year, name1, name2;</code></strong>
+------+----------------+------------+----------------+------------+
| year | name1          | statehood1 | name2          | statehood2 |
+------+----------------+------------+----------------+------------+
| 1787 | Delaware       | 1787-12-07 | New Jersey     | 1787-12-18 |
| 1787 | Delaware       | 1787-12-07 | Pennsylvania   | 1787-12-12 |
| 1787 | New Jersey     | 1787-12-18 | Delaware       | 1787-12-07 |
| 1787 | New Jersey     | 1787-12-18 | Pennsylvania   | 1787-12-12 |
| 1787 | Pennsylvania   | 1787-12-12 | Delaware       | 1787-12-07 |
| 1787 | Pennsylvania   | 1787-12-12 | New Jersey     | 1787-12-18 |
…
| 1912 | Arizona        | 1912-02-14 | New Mexico     | 1912-01-06 |
| 1912 | New Mexico     | 1912-01-06 | Arizona        | 1912-02-14 |
| 1959 | Alaska         | 1959-01-03 | Hawaii         | 1959-08-21 |
| 1959 | Hawaii         | 1959-08-21 | Alaska         | 1959-01-03 |
+------+----------------+------------+----------------+------------+</pre><p>The condition in the <code>ON</code> clause
      that requires state pair names not to be identical
      eliminates the trivially duplicate rows showing that each state joined
      the Union in the same year as itself. But you’ll notice that each
      remaining pair of states still appears twice. For example, there is one
      row that lists Delaware and New Jersey, and another that lists New
      Jersey and Delaware. This is often the case with self-joins: they
      produce pairs of rows that contain the same values, but for which the
      values are not in the same order.</p><p>Because the values are not listed in the same order within the
      rows, they are not identical and you can’t get rid of these <q>near
      duplicates</q> by adding <code>DISTINCT</code> to the
      statement. To solve this problem, select rows in such a way that only
      one row from each pair ever appears in the query result. Slightly modify
      the <code>ON</code> clause, from:</p><pre data-type="programlisting">ON YEAR(s1.statehood) = YEAR(s2.statehood) AND s1.name &lt;&gt; s2.name</pre><p>to:</p><pre data-type="programlisting">ON YEAR(s1.statehood) = YEAR(s2.statehood) AND s1.name &lt; s2.name</pre><p>Using <code>&lt;</code> rather than <code>&lt;&gt;</code> selects only those rows in which the
      first state name is lexically less than the second, and eliminates rows
      in which the names appear in opposite order (as well as rows in which
      the state names are identical). The resulting query produces the desired
      output without duplicates:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT YEAR(s1.statehood) AS year,</code></strong>
    -&gt; <strong><code>s1.name AS name1, s1.statehood AS statehood1,</code></strong>
    -&gt; <strong><code>s2.name AS name2, s2.statehood AS statehood2</code></strong>
    -&gt; <strong><code>FROM states AS s1 INNER JOIN states AS s2</code></strong>
    -&gt; <strong><code>ON YEAR(s1.statehood) = YEAR(s2.statehood) AND s1.name &lt; s2.name</code></strong>
    -&gt; <strong><code>ORDER BY year, name1, name2;</code></strong>
+------+----------------+------------+----------------+------------+
| year | name1          | statehood1 | name2          | statehood2 |
+------+----------------+------------+----------------+------------+
| 1787 | Delaware       | 1787-12-07 | New Jersey     | 1787-12-18 |
| 1787 | Delaware       | 1787-12-07 | Pennsylvania   | 1787-12-12 |
| 1787 | New Jersey     | 1787-12-18 | Pennsylvania   | 1787-12-12 |
…
| 1912 | Arizona        | 1912-02-14 | New Mexico     | 1912-01-06 |
| 1959 | Alaska         | 1959-01-03 | Hawaii         | 1959-08-21 |
+------+----------------+------------+----------------+------------+</pre><p>For self-join problems of the <q>Which values are
      <em>not</em> matched by other rows in the table?</q>
      variety, use a <code>LEFT</code> <code>JOIN</code> rather than an <code>INNER</code> <code>JOIN</code>.
      An instance of this is the question <q>Which states did
      not join the Union in the same year as any other state?</q> In this
      case, the solution uses a <code>LEFT</code>
      <code>JOIN</code> of the <code>states</code> table to itself:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT s1.name, s1.statehood</code></strong>
    -&gt; <strong><code>FROM states AS s1 LEFT JOIN states AS s2</code></strong>
    -&gt; <strong><code>ON YEAR(s1.statehood) = YEAR(s2.statehood) AND s1.name &lt;&gt; s2.name</code></strong>
    -&gt; <strong><code>WHERE s2.name IS NULL</code></strong>
    -&gt; <strong><code>ORDER BY s1.name;</code></strong>
+----------------+------------+
| name           | statehood  |
+----------------+------------+
| Alabama        | 1819-12-14 |
| Arkansas       | 1836-06-15 |
| California     | 1850-09-09 |
| Colorado       | 1876-08-01 |
| Illinois       | 1818-12-03 |
| Indiana        | 1816-12-11 |
| Iowa           | 1846-12-28 |
| Kansas         | 1861-01-29 |
| Kentucky       | 1792-06-01 |
…
| Tennessee      | 1796-06-01 |
| Utah           | 1896-01-04 |
| Vermont        | 1791-03-04 |
| West Virginia  | 1863-06-20 |
| Wisconsin      | 1848-05-29 |
+----------------+------------+</pre><p>For each row in the <code>states</code>
      table, the statement selects rows for which the state has a <code>statehood</code> value in the same year, not
      including that state itself. For rows having no such match, the <code>LEFT</code> <code>JOIN</code>
      forces the output to contain a row anyway, with all the <code>s2</code> columns set to <code>NULL</code>. Those rows identify the states with no
      other state that joined the Union in the same year.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.5 Producing Candidate-Detail Lists and Summaries"><div class="sect1" id="nch-multi-multi-one-to-many"><h1>16.5 Producing Candidate-Detail Lists and Summaries</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820340447648"><h2>Problem</h2><p>Two tables have a relationship such that row in one table, usually called parent table with a candidate key, is referenced by one or mor erows in another table, usually called the child table with a detail row. In this situation, you want to produce a list
      that shows each parent row with its detail rows or a list that produces
      a summary of the detail rows for each parent row.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820340446704"><h2>Solution</h2><p>This is a one-to-many relationship. The solution to this problem involves a join, but the type
      of join depends on the question you want answered. To produce a list
      containing only parent rows for which some detail row exists, use an
      inner join based on the primary key in the parent table. To produce a
      list that includes all parent rows, even those with no detail rows, use
      an outer join.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820340445760"><h2>Discussion</h2><p>To produce a list from two tables that have a candidate-detail or
      parent-child relationship, a given row in one table might be matched by
      several rows in the other. These relationships occur frequently. For
      example, in business contexts, one-to-many relationships involve
      invoices per customer or items per invoice.</p><p>This recipe suggests some candidate-detail questions that you can
      ask (and answer) using the <code>artist</code> and
      <code>painting</code> tables from earlier in the
      chapter.</p><p>One form of candidate-detail question for these tables is,
      <q>Which paintings did each artist paint?</q> This is a simple
      inner join (see <a data-type="xref" href="#nch-multi-multi-inner-join">Recipe 16.1</a>). Match
      each <code>artist</code> row to its corresponding
      <code>painting</code> rows based on the artist ID
      values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, painting.title</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>ORDER BY name, title;</code></strong>
+----------+-------------------+
| name     | title             |
+----------+-------------------+
| Da Vinci | Mona Lisa         |
| Da Vinci | The Last Supper   |
| Renoir   | Les Deux Soeurs   |
| Van Gogh | Starry Night      |
| Van Gogh | The Potato Eaters |
+----------+-------------------+</pre><p>To also list artists for whom you have no paintings, the join
      output should include rows in one table that have no match in the other.
      That’s a form of <q>find the nonmatching rows</q> problem that
      requires an outer join (see <a data-type="xref" href="#nch-multi-multi-outer-join">Recipe 16.2</a>). Thus, to list each <code>artist</code> row, whether or not any <code>painting</code> rows match, use a <code>LEFT</code> <code>JOIN</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, painting.title</code></strong>
    -&gt; <strong><code>FROM artist LEFT JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>ORDER BY name, title;</code></strong>
+----------+-------------------+
| name     | title             |
+----------+-------------------+
| Da Vinci | Mona Lisa         |
| Da Vinci | The Last Supper   |
| Monet    | NULL              |
| Renoir   | Les Deux Soeurs   |
| Van Gogh | Starry Night      |
| Van Gogh | The Potato Eaters |
+----------+-------------------+</pre><p>Rows in the result that have <code>NULL</code> in the <code>title</code> column correspond to artists listed in
      the <code>artist</code> table for whom you have no
      paintings.</p><p>The same principles apply when producing summaries using candidate
      and detail tables. For example, to summarize your art collection by
      number of paintings per artist, you might ask, <q>How many paintings
      are there per artist in the <code>painting</code>
      table?</q> To find the answer based on artist ID but displaying the artist’s
      name (from the <code>artist</code> table), count
      the paintings with this statement:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, COUNT(painting.a_id) AS paintings</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>GROUP BY artist.name;</code></strong>
+----------+-----------+
| name     | paintings |
+----------+-----------+
| Da Vinci |         2 |
| Renoir   |         1 |
| Van Gogh |         2 |
+----------+-----------+</pre><p>On the other hand, you might ask, <q>How many paintings did
      each artist paint?</q> This is the same question as the previous one
      (and the same statement answers it), as long as every artist in the
      <code>artist</code> table has at least one
      corresponding <code>painting</code> table row. But
      if you have artists in the <code>artist</code>
      table not yet represented by any paintings in your collection, they do
      not appear in the statement output. To produce a summary that also
      includes artists with no paintings in the <code>painting</code> table, use a <code>LEFT</code> <code>JOIN</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, COUNT(painting.a_id) AS paintings</code></strong>
    -&gt; <strong><code>FROM artist LEFT JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>GROUP BY artist.name;</code></strong>
+----------+-----------+
| name     | paintings |
+----------+-----------+
| Da Vinci |         2 |
| Monet    |         0 |
| Renoir   |         1 |
| Van Gogh |         2 |
+----------+-----------+</pre><p>Beware of a subtle error that is easy to make when writing that
      kind of statement. Suppose that you write the <code>COUNT()</code> function slightly differently, like so:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, COUNT(*) AS paintings</code></strong>
    -&gt; <strong><code>FROM artist LEFT JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>GROUP BY artist.name;</code></strong></pre><div class="hard-pagebreak"/><pre data-type="programlisting">+----------+-----------+
| name     | paintings |
+----------+-----------+
| Da Vinci |         2 |
| Monet    |         1 |
| Renoir   |         1 |
| Van Gogh |         2 |
+----------+-----------+</pre><p>Now every artist appears to have at least one painting. Why the
      difference? The problem is the use of <code>COUNT(*)</code> rather than <code>COUNT(painting.a_id)</code>. The way <code>LEFT</code> <code>JOIN</code>
      works for unmatched rows in the left table is that it generates a row
      with all the columns from the right table set to <code>NULL</code>. In the example, the right table is
      <code>painting</code>. The statement that uses
      <code>COUNT(painting.a_id)</code> works correctly
      because <code>COUNT(</code><em><code>expr</code></em><code>)</code> counts only non-<code>NULL</code> values. The statement that uses <code>COUNT(*)</code> is incorrect because it counts
      <em>rows</em>, including those containing <code>NULL</code> that correspond to missing
      artists.</p><p><code>LEFT</code> <code>JOIN</code> is suitable for other types of summaries
      as well. To produce additional columns showing the total and average
      prices of the paintings for each artist in the <code>artist</code> table, use this statement:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name,</code></strong>
    -&gt; <strong><code>COUNT(painting.a_id) AS 'number of paintings',</code></strong>
    -&gt; <strong><code>SUM(painting.price) AS 'total price',</code></strong>
    -&gt; <strong><code>AVG(painting.price) AS 'average price'</code></strong>
    -&gt; <strong><code>FROM artist LEFT JOIN painting ON artist.a_id = painting.a_id</code></strong>
    -&gt; <strong><code>GROUP BY artist.name;</code></strong>
+----------+---------------------+-------------+---------------+
| name     | number of paintings | total price | average price |
+----------+---------------------+-------------+---------------+
| Da Vinci |                   2 |         121 |       60.5000 |
| Monet    |                   0 |        NULL |          NULL |
| Renoir   |                   1 |          64 |       64.0000 |
| Van Gogh |                   2 |         115 |       57.5000 |
+----------+---------------------+-------------+---------------+</pre><p>Note that <code>COUNT()</code> is zero for
      artists that are not represented, but <code>SUM()</code> and <code>AVG()</code> are <code>NULL</code>. The latter two functions return <code>NULL</code> when applied to a set of values with no
      non-<code>NULL</code> values. To display a sum or
      average value of zero in that case, replace <code>SUM(</code><em><code>expr</code></em><code>)</code> and <code>AVG(</code><em><code>expr</code></em><code>)</code> with <code>IFNULL(SUM(</code><em><code>expr</code></em><code>),0)</code> and <code>IFNULL(AVG(</code><em><code>expr</code></em><code>),0)</code>.</p><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820340403360"><h5>Using Subqueries in the Select List</h5><p>
          To generate master details you may use subqueries in the select list. For example, to answer on a question <q>Which paintings did each artist paint?</q> you can use <code>JOIN</code> as we discussed in the beginning of this recipe, or a subquery in the <code>SELECT</code> list:
        </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">title</code><code class="p">,</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="n">name</code><code> </code><code class="k">FROM</code><code> </code><code class="n">artist</code><code> </code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code>  </code><code class="k">WHERE</code><code> </code><code class="n">artist</code><code class="p">.</code><code class="n">a_id</code><code class="o">=</code><code class="n">painting</code><code class="p">.</code><code class="n">a_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">name</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">painting</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">-------------------+----------+
</code><code class="o">|</code><code> </code><code class="n">title</code><code>             </code><code class="o">|</code><code> </code><code class="n">name</code><code>     </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">-------------------+----------+
</code><code class="o">|</code><code> </code><code class="n">The</code><code> </code><code class="k">Last</code><code> </code><code class="n">Supper</code><code>   </code><code class="o">|</code><code> </code><code class="n">Da</code><code> </code><code class="n">Vinci</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Mona</code><code> </code><code class="n">Lisa</code><code>         </code><code class="o">|</code><code> </code><code class="n">Da</code><code> </code><code class="n">Vinci</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Starry</code><code> </code><code class="n">Night</code><code>      </code><code class="o">|</code><code> </code><code class="n">Van</code><code> </code><code class="n">Gogh</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">The</code><code> </code><code class="n">Potato</code><code> </code><code class="n">Eaters</code><code> </code><code class="o">|</code><code> </code><code class="n">Van</code><code> </code><code class="n">Gogh</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Les</code><code> </code><code class="n">Deux</code><code> </code><code class="n">Soeurs</code><code>   </code><code class="o">|</code><code> </code><code class="n">Renoir</code><code>   </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">-------------------+----------+
</code><code class="mi">5</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
          You can use as many subqueries in the <code>SELECT</code> list as you wish. For example, to print artist name and name of the state where the painting was acquired instead of its abbreviation, use the following query:
        </p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">title</code><code class="p">,</code>
<code class="p">(</code><code class="k">SELECT</code> <code class="n">name</code> <code class="k">FROM</code> <code class="n">artist</code> <code class="k">WHERE</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code><code class="o">=</code><code class="n">painting</code><code class="p">.</code><code class="n">a_id</code><code class="p">)</code> <code class="k">AS</code> <code class="n">name</code><code class="p">,</code>
<code class="p">(</code><code class="k">SELECT</code> <code class="n">name</code> <code class="k">FROM</code> <code class="n">states</code> <code class="k">WHERE</code> <code class="n">states</code><code class="p">.</code><code class="n">abbrev</code> <code class="o">=</code> <code class="n">painting</code><code class="p">.</code><code class="n">state</code><code class="p">)</code> <code class="k">AS</code> <code class="n">state</code>
<code class="k">FROM</code> <code class="n">painting</code><code class="p">;</code></pre><p>
          This approach is useful when you join many tables that do not have referenced values which you want to use in the resulting output. At the same time, such details are stored in the separate small tables. In all other cases using explicit <code>JOIN</code> is more preferable for performance reasons.
        </p></div></aside></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.6 Enumerating a Many-to-Many Relationship"><div class="sect1" id="nch-multi-multi-many-to-many"><h1>16.6 Enumerating a Many-to-Many Relationship</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820340176240"><h2>Problem</h2><p>You want to display a relationship between tables when any row in either table
      might be matched by multiple rows in the other.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820340175360"><h2>Solution</h2><p>This is a many-to-many relationship. It requires a third table for
      associating your two primary tables and a three-way join to produce the correspondences between them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820340174480"><h2>Discussion</h2><p>The <code>artist</code> and <code>painting</code> tables used in earlier sections have
      a one-to-many relationship: a given artist may have produced many
      paintings, but each painting was created by only one artist. One-to-many
      relationships are relatively simple and the two related tables can be
      joined using a column that is common to both.</p><p>A many-to-many relationship between tables is more complex. It
      occurs when a row in one table may have many matches in the other, and
      vice versa. An example is the relationship between movies and actors:
      each movie may have multiple actors, and each actor may have appeared in
      multiple movies. One way to represent this relationship uses a table
      structured as follows, with a row for each movie-actor
      combination:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM movies_actors ORDER BY year, movie, actor;</code></strong>
+------+----------------------------+---------------+
| year | movie                      | actor         |
+------+----------------------------+---------------+
| 1997 | The Fifth Element          | Bruce Willis  |
| 1997 | The Fifth Element          | Gary Oldman   |
| 1997 | The Fifth Element          | Ian Holm      |
| 1999 | The Phantom Menace         | Ewan McGregor |
| 1999 | The Phantom Menace         | Liam Neeson   |
| 2001 | The Fellowship of the Ring | Elijah Wood   |
| 2001 | The Fellowship of the Ring | Ian Holm      |
| 2001 | The Fellowship of the Ring | Ian McKellen  |
| 2001 | The Fellowship of the Ring | Orlando Bloom |
| 2005 | Kingdom of Heaven          | Liam Neeson   |
| 2005 | Kingdom of Heaven          | Orlando Bloom |
| 2010 | Red                        | Bruce Willis  |
| 2010 | Red                        | Helen Mirren  |
| 2011 | Unknown                    | Diane Kruger  |
| 2011 | Unknown                    | Liam Neeson   |
+------+----------------------------+---------------+</pre><p>The table captures the nature of this many-to-many relationship,
      but it’s also in nonnormal form because it unnecessarily stores
      repetitive information. For example, information for each movie is
      recorded multiple times. To better represent this many-to-many
      relationship, use multiple tables:</p><ul><li><p>Store each movie year and name once in a table named <code>movies</code>.</p></li><li><p>Store each actor name once in a table named <code>actors</code>.</p></li><li><p>Create a third table, <code>movies_actors_link</code>, that stores
          movie-actor associations and serves as a link, or bridge, between
          the two primary tables. To minimize the information stored in this
          table, assign unique IDs to each movie and actor within their
          respective tables, and store only those IDs in the <code>movies_actors_link</code> table.</p></li></ul><p>The resulting <code>movie</code> and
      <code>actor</code> tables look like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM movies ORDER BY id;</code></strong>
+----+------+----------------------------+
| id | year | movie                      |
+----+------+----------------------------+
|  1 | 1997 | The Fifth Element          |
|  2 | 1999 | The Phantom Menace         |
|  3 | 2001 | The Fellowship of the Ring |
|  4 | 2005 | Kingdom of Heaven          |
|  5 | 2010 | Red                        |
|  6 | 2011 | Unknown                    |
+----+------+----------------------------+
mysql&gt; <strong><code>SELECT * FROM actors ORDER BY id;</code></strong>
+----+---------------+
| id | actor         |
+----+---------------+
|  1 | Bruce Willis  |
|  2 | Diane Kruger  |
|  3 | Elijah Wood   |
|  4 | Ewan McGregor |
|  5 | Gary Oldman   |
|  6 | Helen Mirren  |
|  7 | Ian Holm      |
|  8 | Ian McKellen  |
|  9 | Liam Neeson   |
| 10 | Orlando Bloom |
+----+---------------+</pre><p>The <code>movies_actors_link</code> table
      associates movies and actors as follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM movies_actors_link ORDER BY movie_id, actor_id;</code></strong>
+----------+----------+
| movie_id | actor_id |
+----------+----------+
|        1 |        1 |
|        1 |        5 |
|        1 |        7 |
|        2 |        4 |
|        2 |        9 |
|        3 |        3 |
|        3 |        7 |
|        3 |        8 |
|        3 |       10 |
|        4 |        9 |
|        4 |       10 |
|        5 |        1 |
|        5 |        6 |
|        6 |        2 |
|        6 |        9 |
+----------+----------+</pre><p>You’ll surely notice that the content of the <code>movies_actors_link</code> table is entirely
      meaningless from a human perspective. That’s okay: we need never display
      it explicitly. Its utility derives from its ability to link the two
      primary tables in queries, without appearing in query output itself. The
      next few examples illustrate this principle. They answer questions about
      the movies or actors, using three-way joins that relate the two primary
      tables using the link table.</p><ul><li><p>List all the pairings that show each movie and who acted in
          it. This statement enumerates all the correspondences between the
          <code>movie</code> and <code>actor</code> tables and reproduces the
          information that was originally in the nonnormal <code>movies_actors</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT m.year, m.movie, a.actor</code></strong>
    -&gt; <strong><code>FROM movies AS m INNER JOIN movies_actors_link AS l</code></strong>
    -&gt; <strong><code>INNER JOIN actors AS a</code></strong>
    -&gt; <strong><code>ON m.id = l.movie_id AND a.id = l.actor_id</code></strong>
    -&gt; <strong><code>ORDER BY m.year, m.movie, a.actor;</code></strong>
+------+----------------------------+---------------+
| year | movie                      | actor         |
+------+----------------------------+---------------+
| 1997 | The Fifth Element          | Bruce Willis  |
| 1997 | The Fifth Element          | Gary Oldman   |
| 1997 | The Fifth Element          | Ian Holm      |
| 1999 | The Phantom Menace         | Ewan McGregor |
| 1999 | The Phantom Menace         | Liam Neeson   |
| 2001 | The Fellowship of the Ring | Elijah Wood   |
| 2001 | The Fellowship of the Ring | Ian Holm      |
| 2001 | The Fellowship of the Ring | Ian McKellen  |
| 2001 | The Fellowship of the Ring | Orlando Bloom |
| 2005 | Kingdom of Heaven          | Liam Neeson   |
| 2005 | Kingdom of Heaven          | Orlando Bloom |
| 2010 | Red                        | Bruce Willis  |
| 2010 | Red                        | Helen Mirren  |
| 2011 | Unknown                    | Diane Kruger  |
| 2011 | Unknown                    | Liam Neeson   |
+------+----------------------------+---------------+</pre></li><li><p>List the actors in a given movie:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT a.actor</code></strong>
    -&gt; <strong><code>FROM movies AS m INNER JOIN movies_actors_link AS l</code></strong>
    -&gt; <strong><code>INNER JOIN actors AS a</code></strong>
    -&gt; <strong><code>ON m.id = l.movie_id AND a.id = l.actor_id</code></strong>
    -&gt; <strong><code>WHERE m.movie = 'The Fellowship of the Ring'</code></strong>
    -&gt; <strong><code>ORDER BY a.actor;</code></strong>
+---------------+
| actor         |
+---------------+
| Elijah Wood   |
| Ian Holm      |
| Ian McKellen  |
| Orlando Bloom |
+---------------+</pre></li><li><p>List the movies in which a given actor has acted:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT m.year, m.movie</code></strong>
    -&gt; <strong><code>FROM movies AS m INNER JOIN movies_actors_link AS l</code></strong>
    -&gt; <strong><code>INNER JOIN actors AS a</code></strong>
    -&gt; <strong><code>ON m.id = l.movie_id AND a.id = l.actor_id </code></strong>
    -&gt; <strong><code>WHERE a.actor = 'Liam Neeson'</code></strong>
    -&gt; <strong><code>ORDER BY m.year, m.movie;</code></strong>
+------+--------------------+
| year | movie              |
+------+--------------------+
| 1999 | The Phantom Menace |
| 2005 | Kingdom of Heaven  |
| 2011 | Unknown            |
+------+--------------------+</pre></li></ul></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.7 Finding Per-Group Minimum or Maximum Values"><div class="sect1" id="nch-multi-multi-per-group"><h1>16.7 Finding Per-Group Minimum or Maximum Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820340138368"><h2>Problem</h2><p>You want to find which row within each group of rows in a table contains the maximum
      or minimum value for a given column. For example, you want to determine
      the most expensive painting in your collection for each artist.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820340137232"><h2>Solution</h2><p>Create a temporary table to hold the per-group maximum or minimum
      values, then join the temporary table with the original one to pull out
      the matching row for each group. If you prefer a single-query solution,
      use a subquery in the <code>FROM</code>
      clause rather than a temporary table.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820340135568"><h2>Discussion</h2><p>Many questions involve finding largest or smallest values in a
      particular table column, but it’s also common to want to know other
      values in the row that contains the value. For example, using the
      <code>artist</code> and <code>painting</code> tables with the techniques from <a data-type="xref" href="ch10.xhtml#nch-sum-sum-assoc">Recipe 10.6</a>, it’s possible to answer questions such
      as <q>What is the most expensive painting in the collection, and who
      painted it?</q> One solution is to store the highest price in a
      user-defined variable, then use the variable to identify the row
      containing the price so that you can retrieve other columns from
      it:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @max_price = (SELECT MAX(price) FROM painting);</code></strong>
mysql&gt; <strong><code>SELECT artist.name, painting.title, painting.price</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting</code></strong>
    -&gt; <strong><code>ON painting.a_id = artist.a_id</code></strong>
    -&gt; <strong><code>WHERE painting.price = @max_price;</code></strong>
+----------+-----------+-------+
| name     | title     | price |
+----------+-----------+-------+
| Da Vinci | Mona Lisa |    87 |
+----------+-----------+-------+</pre><p>The same thing can be done by creating a temporary table to hold
      the maximum price and joining it with the other tables:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">tmp</code> <code class="k">SELECT</code> <code class="k">MAX</code><code class="p">(</code><code class="n">price</code><code class="p">)</code> <code class="k">AS</code> <code class="n">max_price</code> <code class="k">FROM</code> <code class="n">painting</code><code class="p">;</code>
<code class="k">SELECT</code> <code class="n">artist</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">title</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code>
<code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">tmp</code>
<code class="k">ON</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code>
<code class="k">AND</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code> <code class="o">=</code> <code class="n">tmp</code><code class="p">.</code><code class="n">max_price</code><code class="p">;</code></pre><p>On the face of it, using a temporary table and a join is just a
      more complicated way of answering the question than with a user-defined
      variable. Does this technique have any practical value? Yes, it does,
      because it leads to a more general technique for answering more
      difficult questions. The previous statements show information only for
      the single most expensive painting in the entire <code>painting</code> table. What if your question is,
      <q>What is the most expensive painting <em>for each
      artist</em>?</q> You can’t use a user-defined variable to
      answer that question because the answer requires finding one price per
      artist, and a variable holds only a single value. But the technique of
      using a temporary table works well because the table can hold multiple
      rows, and a join can find matches for all of them.</p><p>To answer the question, select each artist ID and the
      corresponding maximum painting price into a temporary table. This table
      contains not only the maximum painting price but the maximum within each
      group, where <q>group</q> is defined as <q>paintings by a
      given artist.</q> Then use the artist IDs and prices stored in the
      temporary table to match rows in the <code>painting</code> table, and join the result with the
      <code>artist</code> table to get the artist
      names:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE tmp</code></strong>
    -&gt; <strong><code>SELECT a_id, MAX(price) AS max_price FROM painting GROUP BY a_id;</code></strong>
mysql&gt; <strong><code>SELECT artist.name, painting.title, painting.price</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting INNER JOIN tmp</code></strong>
    -&gt; <strong><code>ON painting.a_id = artist.a_id</code></strong>
    -&gt; <strong><code>AND painting.a_id = tmp.a_id</code></strong>
    -&gt; <strong><code>AND painting.price = tmp.max_price;</code></strong>
+----------+-------------------+-------+
| name     | title             | price |
+----------+-------------------+-------+
| Da Vinci | Mona Lisa         |    87 |
| Van Gogh | The Potato Eaters |    67 |
| Renoir   | Les Deux Soeurs   |    64 |
+----------+-------------------+-------+</pre><p>
        To avoid explicitly creating temporary tables and obtain the same result with a single statement, use Common Table Expressions (CTEs).
      </p><pre data-type="programlisting" data-code-language="sql"><code class="k">WITH</code> <code class="n">tmp</code> <code class="k">AS</code> <code class="p">(</code><code class="k">SELECT</code> <code class="n">a_id</code><code class="p">,</code> <code class="k">MAX</code><code class="p">(</code><code class="n">price</code><code class="p">)</code> <code class="k">AS</code> <code class="n">max_price</code> <code class="k">FROM</code> <code class="n">painting</code> <code class="k">GROUP</code> <code class="k">BY</code> <code class="n">a_id</code><code class="p">)</code> 
<code class="k">SELECT</code> <code class="n">artist</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">title</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code> 
<code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">tmp</code> 
<code class="k">ON</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code> <code class="k">AND</code> 
<code class="n">painting</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">tmp</code><code class="p">.</code><code class="n">a_id</code> <code class="k">AND</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code> <code class="o">=</code> <code class="n">tmp</code><code class="p">.</code><code class="n">max_price</code><code class="p">;</code></pre><p>
         We discuss CTEs in detail in <a data-type="xref" href="ch10.xhtml#nch-sum-sum-with">Recipe 10.18</a>.
      </p><p>Another way to obtain the same result with a single statement, is to use a subquery in
      the <code>FROM</code> clause that retrieves the
      same rows contained in the temporary table:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">artist</code><code class="p">.</code><code class="n">name</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">title</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code>
<code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code> <code class="k">INNER</code> <code class="k">JOIN</code>
<code class="p">(</code><code class="k">SELECT</code> <code class="n">a_id</code><code class="p">,</code> <code class="k">MAX</code><code class="p">(</code><code class="n">price</code><code class="p">)</code> <code class="k">AS</code> <code class="n">max_price</code> <code class="k">FROM</code> <code class="n">painting</code> <code class="k">GROUP</code> <code class="k">BY</code> <code class="n">a_id</code><code class="p">)</code> <code class="k">AS</code> <code class="n">tmp</code>
<code class="k">ON</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code>
<code class="k">AND</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">tmp</code><code class="p">.</code><code class="n">a_id</code>
<code class="k">AND</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code> <code class="o">=</code> <code class="n">tmp</code><code class="p">.</code><code class="n">max_price</code><code class="p">;</code></pre><p>Yet another way to answer maximum-per-group questions is to use a
      <code>LEFT</code> <code>JOIN</code> that joins a table to itself. The following statement
      identifies the highest-priced painting per artist ID (use <code>IS</code> <code>NULL</code> to
      select all the rows from <code>p1</code>
      for which there is <em>no</em> row in <code>p2</code> with a higher price):</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT p1.a_id, p1.title, p1.price</code></strong>
    -&gt; <strong><code>FROM painting AS p1 LEFT JOIN painting AS p2</code></strong>
    -&gt; <strong><code>ON p1.a_id = p2.a_id AND p1.price &lt; p2.price</code></strong>
    -&gt; <strong><code>WHERE p2.a_id IS NULL;</code></strong>
+------+-------------------+-------+
| a_id | title             | price |
+------+-------------------+-------+
|    1 | Mona Lisa         |    87 |
|    3 | The Potato Eaters |    67 |
|    4 | Les Deux Soeurs   |    64 |
+------+-------------------+-------+</pre><p>To display artist names rather than ID values, join the result of
      the <code>LEFT</code> <code>JOIN</code> to the <code>artist</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, p1.title, p1.price</code></strong>
    -&gt; <strong><code>FROM painting AS p1 LEFT JOIN painting AS p2</code></strong>
    -&gt; <strong><code>ON p1.a_id = p2.a_id AND p1.price &lt; p2.price</code></strong>
    -&gt; <strong><code>INNER JOIN artist ON p1.a_id = artist.a_id</code></strong>
    -&gt; <strong><code>WHERE p2.a_id IS NULL;</code></strong>
+----------+-------------------+-------+
| name     | title             | price |
+----------+-------------------+-------+
| Da Vinci | Mona Lisa         |    87 |
| Van Gogh | The Potato Eaters |    67 |
| Renoir   | Les Deux Soeurs   |    64 |
+----------+-------------------+-------+</pre><p>The self-<code>LEFT</code> <code>JOIN</code> method is perhaps less intuitive than
      using a temporary table, a CTE, or a subquery.</p></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820340135264"><h2>See Also</h2><p>This recipe showed how to answer maximum-per-group questions by
      selecting summary information into a temporary table and joining that
      table to the original one or by using a subquery in the <code>FROM</code> clause. These techniques have application
      in many contexts. One of them is calculation of team standings, where
      the standings for each group of teams are determined by comparing each
      team in the group to the team with the best record. <a data-type="xref" href="ch17.xhtml#nch-stats-stats-standings">Recipe 17.12</a> discusses how to do this.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.8 Using a Join to Fill or Identify Holes in a List"><div class="sect1" id="nch-multi-multi-fill-hole"><h1>16.8 Using a Join to Fill or Identify Holes in a List</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820339807824"><h2>Problem</h2><p>You want to produce a summary by category, but some categories are missing from
      the data to be summarized. Consequently, the summary has missing
      categories as well.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820339806880"><h2>Solution</h2><p>Create a reference table that lists each category and produce the
      summary based on a <code>LEFT</code> <code>JOIN</code> between the list and the table containing
      your data. Every category in the reference table will appear in the
      result, even those not present in the data to be summarized.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820339804960"><h2>Discussion</h2><p>A summary query normally produces entries only for categories
      actually present in the data. Suppose that you want to summarize the
      <code>driver_log</code> table (introduced in <a data-type="xref" href="ch09.xhtml#nch-sort">Chapter 9</a>), to determine how many drivers were on the road
      each day. The table has these rows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log ORDER BY rec_id;</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      1 | Ben   | 2014-07-30 |   152 |
|      2 | Suzi  | 2014-07-29 |   391 |
|      3 | Henry | 2014-07-29 |   300 |
|      4 | Henry | 2014-07-27 |    96 |
|      5 | Ben   | 2014-07-29 |   131 |
|      6 | Henry | 2014-07-26 |   115 |
|      7 | Suzi  | 2014-08-02 |   502 |
|      8 | Henry | 2014-08-01 |   197 |
|      9 | Ben   | 2014-08-02 |    79 |
|     10 | Henry | 2014-07-30 |   203 |
+--------+-------+------------+-------+</pre><p>A simple summary showing the number of active drivers per day looks
      like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT trav_date, COUNT(trav_date) AS drivers</code></strong>
    -&gt; <strong><code>FROM driver_log GROUP BY trav_date ORDER BY trav_date;</code></strong>
+------------+---------+
| trav_date  | drivers |
+------------+---------+
| 2014-07-26 |       1 |
| 2014-07-27 |       1 |
| 2014-07-29 |       3 |
| 2014-07-30 |       2 |
| 2014-08-01 |       1 |
| 2014-08-02 |       2 |
+------------+---------+</pre><p>Here, the summary category is date, but the summary is
      <q>incomplete</q> in the sense that it includes entries only for
      dates represented in the <code>driver_log</code>
      table. To produce a summary that includes all categories (all dates
      within the date range represented in the table), including those for
      which no driver was active, create a reference table that lists each
      date:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE dates (d DATE);</code></strong>
mysql&gt; <strong><code>INSERT INTO dates (d)</code></strong>
    -&gt; <strong><code>VALUES('2014-07-26'),('2014-07-27'),('2014-07-28'),</code></strong>
    -&gt; <strong><code>('2014-07-29'),('2014-07-30'),('2014-07-31'),</code></strong>
    -&gt; <strong><code>('2014-08-01'),('2014-08-02');</code></strong></pre><p>Then join the reference table to the <code>driver_log</code> table using a <code>LEFT</code> <code>JOIN</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dates.d, COUNT(driver_log.trav_date) AS drivers</code></strong>
    -&gt; <strong><code>FROM dates LEFT JOIN driver_log ON dates.d = driver_log.trav_date</code></strong>
    -&gt; <strong><code>GROUP BY d ORDER BY d;</code></strong>
+------------+---------+
| d          | drivers |
+------------+---------+
| 2014-07-26 |       1 |
| 2014-07-27 |       1 |
| 2014-07-28 |       0 |
| 2014-07-29 |       3 |
| 2014-07-30 |       2 |
| 2014-07-31 |       0 |
| 2014-08-01 |       1 |
| 2014-08-02 |       2 |
+------------+---------+</pre><p>Now the summary includes a row for every date in the range because
      the <code>LEFT</code> <code>JOIN</code> forces the output to include a row for
      every date in the reference table, even those missing from the <code>driver_log</code> table.</p><p>The example just shown uses the reference table with a <code>LEFT</code> <code>JOIN</code>
      to fill holes in the summary. It’s also possible to use the reference
      table to <em>detect</em> holes in the dataset—that is, to
      determine which categories are not present in the data to be summarized.
      The following statement shows those dates on which no driver was active
      by looking for reference rows for which no <code>driver_log</code> table rows have a matching category
      value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dates.d</code></strong>
    -&gt; <strong><code>FROM dates LEFT JOIN driver_log ON dates.d = driver_log.trav_date</code></strong>
    -&gt; <strong><code>WHERE driver_log.trav_date IS NULL;</code></strong>
+------------+
| d          |
+------------+
| 2014-07-28 |
| 2014-07-31 |
+------------+</pre><p>Reference tables that contain a list of categories are quite useful in
      summary context, as just shown. But creating such tables manually is
      mind-numbing and error-prone. It is much easier to use recursive CTE for this purpose. 
      </p><pre data-type="programlisting" data-code-language="sql"><code class="k">WITH</code> <code class="k">RECURSIVE</code> <code class="n">dates</code> <code class="p">(</code><code class="n">d</code><code class="p">)</code>  <code class="k">AS</code> <code class="p">(</code>
  <code class="k">SELECT</code> <code class="s1">'2014-07-26'</code>
  <code class="k">UNION</code> <code class="k">ALL</code>
  <code class="k">SELECT</code> <code class="n">d</code> <code class="o">+</code> <code class="nb">INTERVAL</code> <code class="mi">1</code> <code class="k">day</code>
  <code class="k">FROM</code> <code class="n">dates</code>
  <code class="k">WHERE</code> <code class="n">d</code> <code class="o">&lt;</code> <code class="s1">'2014-08-02'</code><code class="p">)</code> 
<code class="k">SELECT</code> <code class="n">dates</code><code class="p">.</code><code class="n">d</code><code class="p">,</code> <code class="k">COUNT</code><code class="p">(</code><code class="n">driver_log</code><code class="p">.</code><code class="n">trav_date</code><code class="p">)</code> <code class="k">AS</code> <code class="n">drivers</code>
<code class="k">FROM</code> <code class="n">dates</code> <code class="k">LEFT</code> <code class="k">JOIN</code> <code class="n">driver_log</code> <code class="k">ON</code> <code class="n">dates</code><code class="p">.</code><code class="n">d</code> <code class="o">=</code> <code class="n">driver_log</code><code class="p">.</code><code class="n">trav_date</code>
<code class="k">GROUP</code> <code class="k">BY</code> <code class="n">d</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">d</code><code class="p">;</code></pre><p>
        We discuss recursive CTEs in more details in <a data-type="xref" href="ch15.xhtml#nch-sum-sum-recursive-cte">Recipe 15.16</a>
      </p><p>If you need a very long list of dates that you expect to re-use often you may prefer to store them in a table instead of generating series each time you need them. In this case, a stored procedure that uses the endpoints
      of the range of category values to generate the reference table for you
      helps automate the process. In essence, this type of procedure acts as
      an iterator that generates a row for each value in the range. The
      following procedure, <code>make_date_list()</code>, shows an example of this
      approach. It creates a reference table containing a row for every date
      in a particular date range. It also indexes the table so that it
      will be fast in large joins:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">PROCEDURE</code> <code class="n">make_date_list</code><code class="p">(</code><code class="n">db_name</code> <code class="nb">TEXT</code><code class="p">,</code> <code class="n">tbl_name</code> <code class="nb">TEXT</code><code class="p">,</code> <code class="n">col_name</code> <code class="nb">TEXT</code><code class="p">,</code>
                                <code class="n">min_date</code> <code class="nb">DATE</code><code class="p">,</code> <code class="n">max_date</code> <code class="nb">DATE</code><code class="p">)</code>
<code class="k">BEGIN</code>
  <code class="k">DECLARE</code> <code class="n">i</code><code class="p">,</code> <code class="n">days</code> <code class="nb">INT</code><code class="p">;</code>
  <code class="k">SET</code> <code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="n">days</code> <code class="o">=</code> <code class="n">DATEDIFF</code><code class="p">(</code><code class="n">max_date</code><code class="p">,</code><code class="n">min_date</code><code class="p">)</code><code class="o">+</code><code class="mi">1</code><code class="p">;</code>

  <code class="o">#</code> <code class="n">Make</code> <code class="n">identifiers</code> <code class="n">safe</code> <code class="k">for</code> <code class="n">insertion</code> <code class="k">into</code> <code class="k">SQL</code> <code class="n">statements</code><code class="p">.</code> <code class="n">Use</code> <code class="n">db_name</code>
  <code class="o">#</code> <code class="k">and</code> <code class="n">tbl_name</code> <code class="k">to</code> <code class="k">create</code> <code class="n">qualified</code> <code class="k">table</code> <code class="n">name</code><code class="p">.</code>
  <code class="k">SET</code> <code class="n">tbl_name</code> <code class="o">=</code> <code class="n">CONCAT</code><code class="p">(</code><code class="n">quote_identifier</code><code class="p">(</code><code class="n">db_name</code><code class="p">),</code><code class="s1">'.'</code><code class="p">,</code>
                        <code class="n">quote_identifier</code><code class="p">(</code><code class="n">tbl_name</code><code class="p">));</code>
  <code class="k">SET</code> <code class="n">col_name</code> <code class="o">=</code> <code class="n">quote_identifier</code><code class="p">(</code><code class="n">col_name</code><code class="p">);</code>
  <code class="k">CALL</code> <code class="n">exec_stmt</code><code class="p">(</code><code class="n">CONCAT</code><code class="p">(</code><code class="s1">'DROP TABLE IF EXISTS '</code><code class="p">,</code><code class="n">tbl_name</code><code class="p">));</code>
  <code class="k">CALL</code> <code class="n">exec_stmt</code><code class="p">(</code><code class="n">CONCAT</code><code class="p">(</code><code class="s1">'CREATE TABLE '</code><code class="p">,</code><code class="n">tbl_name</code><code class="p">,</code><code class="s1">'('</code><code class="p">,</code>
                        <code class="n">col_name</code><code class="p">,</code><code class="s1">' DATE NOT NULL, PRIMARY KEY('</code><code class="p">,</code>
                        <code class="n">col_name</code><code class="p">,</code><code class="s1">'))'</code><code class="p">));</code>
  <code class="n">WHILE</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="n">days</code> <code class="k">DO</code>
    <code class="k">CALL</code> <code class="n">exec_stmt</code><code class="p">(</code><code class="n">CONCAT</code><code class="p">(</code><code class="s1">'INSERT INTO '</code><code class="p">,</code><code class="n">tbl_name</code><code class="p">,</code><code class="s1">'('</code><code class="p">,</code><code class="n">col_name</code><code class="p">,</code><code class="s1">') VALUES('</code><code class="p">,</code>
                          <code class="n">QUOTE</code><code class="p">(</code><code class="n">min_date</code><code class="p">),</code><code class="s1">' + INTERVAL '</code><code class="p">,</code><code class="n">i</code><code class="p">,</code><code class="s1">' DAY)'</code><code class="p">));</code>
    <code class="k">SET</code> <code class="n">i</code> <code class="o">=</code> <code class="n">i</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
  <code class="k">END</code> <code class="n">WHILE</code><code class="p">;</code>
<code class="k">END</code><code class="p">;</code></pre><p>Use <code>make_date_list()</code> to
      generate the reference table, <code>dates</code>,
      like this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CALL</code> <code class="n">make_date_list</code><code class="p">(</code><code class="s1">'cookbook'</code><code class="p">,</code> <code class="s1">'dates'</code><code class="p">,</code> <code class="s1">'d'</code><code class="p">,</code> <code class="s1">'2014-07-26'</code><code class="p">,</code> <code class="s1">'2014-08-02'</code><code class="p">);</code></pre><p>Then use the <code>dates</code> table as
      shown earlier in this section to fill holes in the summary or to detect
      holes in the dataset.</p><p>You can find the <code>make_date_list()</code> procedure in the <em class="filename">joins</em> directory of the <code>recipes</code> distribution. It requires the <code>exec_stmt()</code> and
      <code>quote_identifier()</code> helper routines
      (see <a data-type="xref" href="ch11.xhtml#nch-routines-dynamic-sql-helpers">Recipe 11.6</a>), located in
      the <em class="filename">routines</em> directory. The
      <em class="filename">joins</em> directory also contains a
      Perl script, <span class="command"><em>make_date_list.pl</em></span>, that
      implements an alternate approach; it generates date reference tables
      from the command line.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.9 Using a Join to Control Query Sort Order"><div class="sect1" id="nch-multi-multi-join-sort"><h1>16.9 Using a Join to Control Query Sort Order</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820339440160"><h2>Problem</h2><p>You want to sort a statement’s output using a characteristic of the output
      that cannot be specified using <code>ORDER</code>
      <code>BY</code>. For example, you want to sort a
      set of rows by subgroups, putting first those groups with the most rows
      and last those groups with the fewest rows. But <q>number of rows in
      each group</q> is not a property of individual rows, so you can’t
      use it for sorting.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820339411040"><h2>Solution</h2><p>Derive the ordering information and store it in an auxiliary
      table. Then join the original table to the auxiliary table, using the
      auxiliary table to control the sort order.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820339410128"><h2>Discussion</h2><p>Most of the time you sort a query result using an <code>ORDER</code> <code>BY</code> clause that names which column or columns
      to use for sorting. But sometimes the values you want to sort by aren’t
      present in the rows to be sorted. This is the case when you want to use
      group characteristics to order the rows. The following example uses the
      <code>driver_log</code> table to illustrate this.
      The following query sorts the table using the ID column, which is
      present in the rows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM driver_log ORDER BY rec_id;</code></strong>
+--------+-------+------------+-------+
| rec_id | name  | trav_date  | miles |
+--------+-------+------------+-------+
|      1 | Ben   | 2014-07-30 |   152 |
|      2 | Suzi  | 2014-07-29 |   391 |
|      3 | Henry | 2014-07-29 |   300 |
|      4 | Henry | 2014-07-27 |    96 |
|      5 | Ben   | 2014-07-29 |   131 |
|      6 | Henry | 2014-07-26 |   115 |
|      7 | Suzi  | 2014-08-02 |   502 |
|      8 | Henry | 2014-08-01 |   197 |
|      9 | Ben   | 2014-08-02 |    79 |
|     10 | Henry | 2014-07-30 |   203 |
+--------+-------+------------+-------+</pre><p>But what if you want to display a list and sort it on the basis of
      a summary value not present in the rows? That’s a little trickier.
      Suppose that you want to show each driver’s rows by date, but place
      those drivers who drive the most miles first. You can’t do this with a
      summary query because then you wouldn’t get back the individual driver
      rows. But you can’t do it without a summary query, either, because the
      summary values are required for sorting. The way out of the dilemma is
      to create another table containing the summary value per driver and join
      it to the original table. That way you can produce the individual rows
      and also sort them by the summary values.</p><p>To summarize the driver totals into another table, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE tmp</code></strong>
    -&gt; <strong><code>SELECT name, SUM(miles) AS driver_miles FROM driver_log GROUP BY name;</code></strong></pre><p>That produces the values we need to put the names in the proper
      total-miles order:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM tmp ORDER BY driver_miles DESC;</code></strong>
+-------+--------------+
| name  | driver_miles |
+-------+--------------+
| Henry |          911 |
| Suzi  |          893 |
| Ben   |          362 |
+-------+--------------+</pre><p>Then use the <code>name</code> values to
      join the summary table to the <code>driver_log</code> table, and use the <code>driver_miles</code> values to sort the result:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT tmp.driver_miles, driver_log.*</code></strong>
    -&gt; <strong><code>FROM driver_log INNER JOIN tmp ON driver_log.name = tmp.name</code></strong>
    -&gt; <strong><code>ORDER BY tmp.driver_miles DESC, driver_log.trav_date;</code></strong>
+--------------+--------+-------+------------+-------+
| driver_miles | rec_id | name  | trav_date  | miles |
+--------------+--------+-------+------------+-------+
|          911 |      6 | Henry | 2014-07-26 |   115 |
|          911 |      4 | Henry | 2014-07-27 |    96 |
|          911 |      3 | Henry | 2014-07-29 |   300 |
|          911 |     10 | Henry | 2014-07-30 |   203 |
|          911 |      8 | Henry | 2014-08-01 |   197 |
|          893 |      2 | Suzi  | 2014-07-29 |   391 |
|          893 |      7 | Suzi  | 2014-08-02 |   502 |
|          362 |      5 | Ben   | 2014-07-29 |   131 |
|          362 |      1 | Ben   | 2014-07-30 |   152 |
|          362 |      9 | Ben   | 2014-08-02 |    79 |
+--------------+--------+-------+------------+-------+</pre><p>The preceding statement shows the mileage totals in the result.
      That’s only to clarify how the values are being sorted. It’s not
      actually necessary to display them; they’re needed only for the <code>ORDER</code> <code>BY</code>
      clause.</p><p>To avoid using the temporary table, use a CTE:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">WITH</code> <code class="n">tmp</code> <code class="k">AS</code>
<code class="p">(</code><code class="k">SELECT</code> <code class="n">name</code><code class="p">,</code> <code class="k">SUM</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code> <code class="k">AS</code> <code class="n">driver_miles</code> <code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">GROUP</code> <code class="k">BY</code> <code class="n">name</code><code class="p">)</code>
<code class="k">SELECT</code> <code class="n">tmp</code><code class="p">.</code><code class="n">driver_miles</code><code class="p">,</code> <code class="n">driver_log</code><code class="p">.</code><code class="o">*</code>
<code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">tmp</code> <code class="k">ON</code> <code class="n">driver_log</code><code class="p">.</code><code class="n">name</code> <code class="o">=</code> <code class="n">tmp</code><code class="p">.</code><code class="n">name</code>
<code class="k">ORDER</code> <code class="k">BY</code> <code class="n">tmp</code><code class="p">.</code><code class="n">driver_miles</code> <code class="k">DESC</code><code class="p">,</code> <code class="n">driver_log</code><code class="p">.</code><code class="n">trav_date</code><code class="p">;</code></pre><p>Alternatively, select the same rows using a
      subquery in the <code>FROM</code> clause:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">tmp</code><code class="p">.</code><code class="n">driver_miles</code><code class="p">,</code> <code class="n">driver_log</code><code class="p">.</code><code class="o">*</code>
<code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">INNER</code> <code class="k">JOIN</code>
<code class="p">(</code><code class="k">SELECT</code> <code class="n">name</code><code class="p">,</code> <code class="k">SUM</code><code class="p">(</code><code class="n">miles</code><code class="p">)</code> <code class="k">AS</code> <code class="n">driver_miles</code>
<code class="k">FROM</code> <code class="n">driver_log</code> <code class="k">GROUP</code> <code class="k">BY</code> <code class="n">name</code><code class="p">)</code> <code class="k">AS</code> <code class="n">tmp</code>
<code class="k">ON</code> <code class="n">driver_log</code><code class="p">.</code><code class="n">name</code> <code class="o">=</code> <code class="n">tmp</code><code class="p">.</code><code class="n">name</code>
<code class="k">ORDER</code> <code class="k">BY</code> <code class="n">tmp</code><code class="p">.</code><code class="n">driver_miles</code> <code class="k">DESC</code><code class="p">,</code> <code class="n">driver_log</code><code class="p">.</code><code class="n">trav_date</code><code class="p">;</code></pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.10 Joining Results of Multiple Queries"><div class="sect1" id="nch-multi-multi-subquery-join"><h1>16.10 Joining Results of Multiple Queries</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820339223120"><h2>Problem</h2><p>
        You want to join results of two or more queries.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820339222240"><h2>Solution</h2><p>
        Run the queries and store results in the temporary tables, then access those temporary tables to obtain final result. Or, use named subqueries, then join their results. Or, use our favorite method: CTEs that will help you to perform this task in the easiest and clear manner.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820339221360"><h2>Discussion</h2><p>
        You may need to join not only tables but results of other queries. Assume you are working with tables <code>city</code> and <code>states</code> from the <code>recipes</code> distribution, and want to find capital names of the states that belong to the 10 states with the highest population. At the same time, you want to include into your search results only those states where the largest city is the same as the capital.
      </p><p>
        This task is very easy to solve if you first split it into three parts:
      </p><ol><li><p>
            Find all states where the capital and the largest city are the same. You can do it with a query:
          </p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">city</code> <code class="k">WHERE</code> <code class="n">capital</code><code class="o">=</code><code class="n">largest</code><code class="p">;</code></pre></li><li><p>
            Find 10 states with the highest population:
          </p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">states</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">pop</code> <code class="k">DESC</code> <code class="k">LIMIT</code> <code class="mi">10</code><code class="p">;</code></pre></li><li><p>
            Join the results to select rows that exist in both.
          </p></li></ol><p>
        There are three ways to do this: by creating intermediate temporary tables, by joining subquery results, and by using CTEs.
      </p><section data-type="sect3" data-pdf-bookmark="Using Intermediate Temporary Tables"><div class="sect3" id="idm45820339193008"><h3>Using Intermediate Temporary Tables</h3><p>
          Store results of the queries into temporary tables, then select from them.
        </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">CREATE</code><code> </code><code class="k">TEMPORARY</code><code> </code><code class="k">TABLE</code><code> </code><code class="n">large_capitals</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">city</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">capital</code><code class="o">=</code><code class="n">largest</code><code class="p">;</code></strong><code>
</code><code class="n">Query</code><code> </code><code class="n">OK</code><code class="p">,</code><code> </code><code class="mi">17</code><code> </code><code class="k">rows</code><code> </code><code class="n">affected</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code><code>
</code><code class="n">Records</code><code class="p">:</code><code> </code><code class="mi">17</code><code>  </code><code class="n">Duplicates</code><code class="p">:</code><code> </code><code class="mi">0</code><code>  </code><code class="n">Warnings</code><code class="p">:</code><code> </code><code class="mi">0</code><code>

</code><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">CREATE</code><code> </code><code class="k">TEMPORARY</code><code> </code><code class="k">TABLE</code><code> </code><code class="n">top10states</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">states</code><code> </code><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">pop</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">10</code><code class="p">;</code></strong><code>
</code><code class="n">Query</code><code> </code><code class="n">OK</code><code class="p">,</code><code> </code><code class="mi">10</code><code> </code><code class="k">rows</code><code> </code><code class="n">affected</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code><code>
</code><code class="n">Records</code><code class="p">:</code><code> </code><code class="mi">10</code><code>  </code><code class="n">Duplicates</code><code class="p">:</code><code> </code><code class="mi">0</code><code>  </code><code class="n">Warnings</code><code class="p">:</code><code> </code><code class="mi">0</code><code>

</code><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">state</code><code class="p">,</code><code> </code><code class="n">capital</code><code class="p">,</code><code> </code><code class="n">pop</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">large_capitals</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">top10states</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ON</code><code class="p">(</code><code class="n">large_capitals</code><code class="p">.</code><code class="n">state</code><code> </code><code class="o">=</code><code> </code><code class="n">top10states</code><code class="p">.</code><code class="n">name</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="o">|</code><code> </code><code class="n">state</code><code>   </code><code class="o">|</code><code> </code><code class="n">capital</code><code>  </code><code class="o">|</code><code> </code><code class="n">pop</code><code>      </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="o">|</code><code> </code><code class="n">Georgia</code><code> </code><code class="o">|</code><code> </code><code class="n">Atlanta</code><code>  </code><code class="o">|</code><code> </code><code class="mi">10799566</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Ohio</code><code>    </code><code class="o">|</code><code> </code><code class="n">Columbus</code><code> </code><code class="o">|</code><code> </code><code class="mi">11780017</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="mi">2</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><div data-type="tip"><h6>Tip</h6><p>
            Keyword <code>TEMPORARY</code> for the <code>CREATE TABLE</code> statement instructs MySQL to create a table, visible for the current session only and which will be destroyed after you close the session. See <a data-type="xref" href="ch06.xhtml#nch-tblmgmt-tblmgmt-temp">Recipe 6.3</a> for further details.
          </p></div></div></section><section data-type="sect3" data-pdf-bookmark="Using Named Subqueries"><div class="sect3" id="idm45820338957968"><h3>Using Named Subqueries</h3><p>
          If you only need to access the intermediate results once, you can avoid creating temporary tables by using subqueries and joining their results.
        
        </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">state</code><code class="p">,</code><code> </code><code class="n">capital</code><code class="p">,</code><code> </code><code class="n">pop</code><code> </code><code class="k">FROM</code></strong><code> </code><a class="co" id="co_nch-multi-multi-subquery-join-outer_co" href="#callout_nch-multi-multi-subquery-join-outer_co"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">city</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">capital</code><code class="o">=</code><code class="n">largest</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">large_capitals</code><code class="p">,</code></strong><code> </code><a class="co" id="co_nch-multi-multi-subquery-join-lc_co" href="#callout_nch-multi-multi-subquery-join-lc_co"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">states</code><code> </code><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">pop</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">10</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">top10states</code></strong><code> </code><a class="co" id="co_nch-multi-multi-subquery-join-ts_co" href="#callout_nch-multi-multi-subquery-join-ts_co"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">large_capitals</code><code class="p">.</code><code class="n">state</code><code> </code><code class="o">=</code><code> </code><code class="n">top10states</code><code class="p">.</code><code class="n">name</code><code class="p">;</code></strong><code> </code><a class="co" id="co_nch-multi-multi-subquery-join-where_co" href="#callout_nch-multi-multi-subquery-join-where_co"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="o">|</code><code> </code><code class="n">state</code><code>   </code><code class="o">|</code><code> </code><code class="n">capital</code><code>  </code><code class="o">|</code><code> </code><code class="n">pop</code><code>      </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="o">|</code><code> </code><code class="n">Georgia</code><code> </code><code class="o">|</code><code> </code><code class="n">Atlanta</code><code>  </code><code class="o">|</code><code> </code><code class="mi">10799566</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Ohio</code><code>    </code><code class="o">|</code><code> </code><code class="n">Columbus</code><code> </code><code class="o">|</code><code> </code><code class="mi">11780017</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="mi">2</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
          </p><dl class="calloutlist"><dt><a class="co" id="callout_nch-multi-multi-subquery-join-outer_co" href="#co_nch-multi-multi-subquery-join-outer_co"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt><dd><p>Start the query from selecting columns you need in the final result</p></dd><dt><a class="co" id="callout_nch-multi-multi-subquery-join-lc_co" href="#co_nch-multi-multi-subquery-join-lc_co"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt><dd><p>Put the first subquery into brackets and assign it a unique name.</p></dd><dt><a class="co" id="callout_nch-multi-multi-subquery-join-ts_co" href="#co_nch-multi-multi-subquery-join-ts_co"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt><dd><p>Do the same for the second subquery.</p></dd><dt><a class="co" id="callout_nch-multi-multi-subquery-join-where_co" href="#co_nch-multi-multi-subquery-join-where_co"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt><dd><p>Narrow the search with clause <code>WHERE</code>.</p></dd></dl><p>
        </p></div></section><section data-type="sect3" data-pdf-bookmark="Using Common Table Expressions (CTEs)"><div class="sect3" id="idm45820338801424"><h3>Using Common Table Expressions (CTEs)</h3><p>
          With CTEs start by naming your subqueries, then join their results like if they were regular MySQL tables.
          </p><pre data-type="programlisting" data-code-language="sql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">WITH</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">large_capitals</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">city</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">capital</code><code class="o">=</code><code class="n">largest</code><code class="p">)</code><code class="p">,</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">top10states</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">states</code><code> </code><code class="k">ORDER</code><code> </code><code class="k">BY</code><code> </code><code class="n">pop</code><code> </code><code class="k">DESC</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">10</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">state</code><code class="p">,</code><code> </code><code class="n">capital</code><code class="p">,</code><code> </code><code class="n">pop</code><code> </code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">large_capitals</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">top10states</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ON</code><code> </code><code class="p">(</code><code class="n">large_capitals</code><code class="p">.</code><code class="n">state</code><code> </code><code class="o">=</code><code> </code><code class="n">top10states</code><code class="p">.</code><code class="n">name</code><code class="p">)</code><code class="p">;</code></strong><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="o">|</code><code> </code><code class="n">state</code><code>   </code><code class="o">|</code><code> </code><code class="n">capital</code><code>  </code><code class="o">|</code><code> </code><code class="n">pop</code><code>      </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="o">|</code><code> </code><code class="n">Georgia</code><code> </code><code class="o">|</code><code> </code><code class="n">Atlanta</code><code>  </code><code class="o">|</code><code> </code><code class="mi">10799566</code><code> </code><code class="o">|</code><code>
</code><code class="o">|</code><code> </code><code class="n">Ohio</code><code>    </code><code class="o">|</code><code> </code><code class="n">Columbus</code><code> </code><code class="o">|</code><code> </code><code class="mi">11780017</code><code> </code><code class="o">|</code><code>
</code><code class="o">+</code><code class="c1">---------+----------+----------+
</code><code class="mi">2</code><code> </code><code class="k">rows</code><code> </code><code class="k">in</code><code> </code><code class="k">set</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code></pre><p>
        </p></div></section></div></section></div></section><section data-type="sect1" data-pdf-bookmark="16.11 Referring to Join Output Column Names in Programs"><div class="sect1" id="nch-multi-multi-api-col-names"><h1>16.11 Referring to Join Output Column Names in Programs</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820338609872"><h2>Problem</h2><p>You need to process the result of a join from within a program, but column names
      in the result set aren’t unique.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820338608992"><h2>Solution</h2><p>Rewrite the query using column aliases so that each column has a unique name.
      Alternatively, refer to the columns by position.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820338608112"><h2>Discussion</h2><p>Joins typically retrieve columns from related tables and it’s not
      unusual for columns selected from different tables to have the same
      names. Consider the following join that shows the items in your art
      collection. For each painting, it displays artist name, painting title,
      the state in which you acquired the item, and its price:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT artist.name, painting.title, states.name, painting.price</code></strong>
    -&gt; <strong><code>FROM artist INNER JOIN painting INNER JOIN states</code></strong>
    -&gt; <strong><code>ON artist.a_id = painting.a_id AND painting.state = states.abbrev;</code></strong>
+----------+-------------------+----------+-------+
| name     | title             | name     | price |
+----------+-------------------+----------+-------+
| Da Vinci | The Last Supper   | Indiana  |    34 |
| Da Vinci | Mona Lisa         | Michigan |    87 |
| Van Gogh | Starry Night      | Kentucky |    48 |
| Van Gogh | The Potato Eaters | Kentucky |    67 |
| Renoir   | Les Deux Soeurs   | Nebraska |    64 |
+----------+-------------------+----------+-------+</pre><p>The statement uses table qualifiers for each output column, but
      MySQL doesn’t include table names in the column headings, so not all
      column names in the output are distinct. If you process the join result
      from within a program and fetch rows into a data structure that
      references column values by name, nonunique column names cause values to
      become inaccessible. Suppose that you fetch rows in a Perl DBI script
      like this:</p><pre data-type="programlisting" data-code-language="perl">while (my $ref = $sth-&gt;fetchrow_hashref ())
{
  <em><code>... process row hash here ...</code></em>
}</pre><p>Fetching rows into the hash yields three hash elements (<code>name</code>, <code>title</code>, <code>price</code>); one of the <code>name</code> elements is lost. To solve this problem,
      supply aliases that make the column names unique:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">artist</code><code class="p">.</code><code class="n">name</code> <code class="k">AS</code> <code class="n">painter</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">title</code><code class="p">,</code>
  <code class="n">states</code><code class="p">.</code><code class="n">name</code> <code class="k">AS</code> <code class="n">state</code><code class="p">,</code> <code class="n">painting</code><code class="p">.</code><code class="n">price</code>
<code class="k">FROM</code> <code class="n">artist</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">painting</code> <code class="k">INNER</code> <code class="k">JOIN</code> <code class="n">states</code>
<code class="k">ON</code> <code class="n">artist</code><code class="p">.</code><code class="n">a_id</code> <code class="o">=</code> <code class="n">painting</code><code class="p">.</code><code class="n">a_id</code> <code class="k">AND</code> <code class="n">painting</code><code class="p">.</code><code class="n">state</code> <code class="o">=</code> <code class="n">states</code><code class="p">.</code><code class="n">abbrev</code><code class="p">;</code></pre><p>Now fetching rows into a hash yields four hash elements (<code>painter</code>, <code>title</code>, <code>state</code>, <code>price</code>).</p><p>To address the problem without column renaming, fetch the row into
      something other than a hash. For example, fetch the row into an array
      and refer to the columns by ordinal position within the array:</p><pre data-type="programlisting" data-code-language="perl"><code class="k">while</code> <code class="p">(</code><code class="k">my</code> <code class="nv">@val</code> <code class="o">=</code> <code class="nv">$sth</code><code class="o">-&gt;</code><code class="n">fetchrow_array</code> <code class="p">())</code>
<code class="p">{</code>
  <code class="k">print</code> <code class="s">"painter: $val[0], title: $val[1], "</code>
        <code class="o">.</code> <code class="s">"state: $val[2], price: $val[3]\n"</code><code class="p">;</code>
<code class="p">}</code></pre></div></section></div></section></div></section></div></body></html>