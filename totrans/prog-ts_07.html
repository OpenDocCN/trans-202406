<html><head></head><body><section data-pdf-bookmark="Chapter 7. Handling Errors" data-type="chapter" epub:type="chapter"><div class="chapter" id="error_handling">&#13;
<h1><span class="label">Chapter 7. </span>Handling Errors</h1>&#13;
&#13;
<blockquote>&#13;
<p>A physicist, a structural engineer, and a programmer were in a car driving over a steep alpine pass when the brakes failed.<a data-primary="errors" data-secondary="handling" data-type="indexterm" id="ix_errhan"/> The car went faster and faster, they were struggling to get around the corners, and once or twice the flimsy crash barrier saved them from tumbling down the side of the mountain. They were sure they were all going to die, when suddenly they spotted an escape lane. They pulled into the escape lane, and came safely to a halt.</p>&#13;
&#13;
<p>The physicist said, “We need to model the friction in the brake pads and the resultant temperature rise, and see if we can work out why they failed.”</p>&#13;
&#13;
<p>The structural engineer said, “I think I’ve got a few spanners in the back. I’ll take a look and see if I can work out what’s wrong.”</p>&#13;
&#13;
<p>The programmer said, “Why don’t we see if it’s reproducible?”</p>&#13;
<p data-type="attribution">Anonymous</p>&#13;
</blockquote>&#13;
&#13;
<p>TypeScript does everything it can to move runtime exceptions<a data-primary="runtime" data-secondary="exceptions" data-type="indexterm" id="idm46304962247976"/><a data-primary="exceptions" data-type="indexterm" id="idm46304962246952"/> to compile time: from the rich type system it provides to the powerful static and symbolic analyses it performs, it works hard so you don’t have to spend your Friday nights debugging misspelled variables and null pointer exceptions (and so your on-call coworker doesn’t have to be late to their great aunt’s birthday party because of it).</p>&#13;
&#13;
<p>Unfortunately, regardless of what language you write in, sometimes runtime exceptions do sneak through. TypeScript is really good about preventing them, but even it can’t prevent things like network and filesystem failures, errors parsing user input, stack overflows, and out of memory errors. What it does do—thanks to its lush type system—is give you lots of ways to deal with the runtime errors that end up making it through.</p>&#13;
&#13;
<p class="pagebreak-before">In this chapter <a data-primary="exceptions" data-secondary="handling" data-seealso="errors, handling" data-type="indexterm" id="idm46304962244232"/>I’ll walk you through the most common patterns for representing and handling errors in TypeScript:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Returning <code>null</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Throwing exceptions</p>&#13;
</li>&#13;
<li>&#13;
<p>Returning exceptions</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>Option</code> type</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Which mechanism you use is up to you, and depends on your application. As I cover each error-handling mechanism, I’ll talk about its pros and cons so you can make the right choice for yourself.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Returning null" data-type="sect1"><div class="sect1" id="idm46304962237032">&#13;
<h1>Returning null</h1>&#13;
&#13;
<p>We’re going to write a program that asks a user for their birthday, which we will then<a data-primary="errors" data-secondary="handling" data-tertiary="returning null" data-type="indexterm" id="idm46304962235256"/><a data-primary="null type" data-secondary="function returning null" data-type="indexterm" id="idm46304962234008"/> parse into a <code>Date</code> object:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">ask() {</code>&#13;
  <code class="k">return</code> <code class="nx">prompt</code><code class="p">(</code><code class="s1">'When is your birthday?'</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">parse</code><code class="p">(</code><code class="nx">birthday</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nb">Date</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="nx">birthday</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">date</code> <code class="o">=</code> <code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">())</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code> <code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">())</code></pre>&#13;
&#13;
<p>We should probably validate the date the user entered—it’s just a text prompt, after all:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kd">function</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">birthday</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nb">Date</code><code> </code><strong><code class="o">|</code><code> </code><code class="kc">null</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="nx">birthday</code><code class="p">)</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nx">isValid</code><code class="p">(</code><code class="nx">date</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="kc">null</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
  </code><code class="k">return</code><code> </code><strong><code class="nx">date</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="c1">// </code><em><code class="c1">Checks if the given date is valid</code></em><code class="c1">&#13;
</code><strong><code class="kd">function</code><code> </code><code class="nx">isValid</code><code class="p">(</code><code class="nx">date</code><code>: </code><code class="kt">Date</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">date</code><code class="p">)</code><code> </code><code class="o">===</code><code> </code><code class="s1">'[object Date]'</code><code>&#13;
      </code><code class="o">&amp;&amp;</code><code> </code><code class="o">!</code><code class="nb">Number</code><code class="p">.</code><code class="nb">isNaN</code><code class="p">(</code><code class="nx">date</code><code class="p">.</code><code class="nx">getTime</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>When we consume this, we’re forced to first check if the result is <code>null</code> before we can use it:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="c1">// ...&#13;
</code><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><strong><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">date</code><code class="p">)</code><code> </code><code class="p">{</code></strong><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><strong><code class="p">}</code><code> </code><code class="k">else</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'Error parsing date for some reason'</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>Returning <code>null</code> is the most lightweight way to handle errors in a typesafe way. Valid user input results in a <code>Date</code>, invalid user input in a <code>null</code>, and the type system checks for us that we handled both.</p>&#13;
&#13;
<p>However, we lose some information doing it this way <code>parse</code> doesn’t tell us why exactly the operation failed, which stinks for whatever engineer has to comb through our logs to debug this, as well as the user who gets a pop up saying that there was an “Error parsing date for some reason” rather than a specific, actionable error like “Enter a date in the form YYYY/MM/DD.”</p>&#13;
&#13;
<p>Returning <code>null</code> is also difficult to compose: having to check for <code>null</code> after every operation can become verbose as you start to nest and chain operations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Throwing Exceptions" data-type="sect1"><div class="sect1" id="idm46304962236408">&#13;
<h1>Throwing Exceptions</h1>&#13;
&#13;
<p>Let’s throw an exception instead of returning <code>null</code>, so that we can handle specific failure modes and have some metadata about the failure so we can debug it more easily.<a data-primary="errors" data-secondary="handling" data-tertiary="throwing exceptions" data-type="indexterm" id="ix_errhanthrexc"/><a data-primary="exceptions" data-secondary="throwing" data-type="indexterm" id="ix_excptthrow"/></p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kd">function</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">birthday</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="nb">Date</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="nx">birthday</code><code class="p">)</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nx">isValid</code><code class="p">(</code><code class="nx">date</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><strong><code class="k">throw</code><code> </code><code class="k">new</code><code> </code><code class="nx">RangeError</code><code class="p">(</code><code class="s1">'Enter a date in the form YYYY/MM/DD'</code><code class="p">)</code></strong><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">date</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Now when we consume this code, we need to be careful to catch the exception so that we can handle it <a data-primary="try/catch statements" data-type="indexterm" id="idm46304961912760"/>gracefully without crashing our whole application:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><strong><code class="k">try</code><code> </code><code class="p">{</code></strong><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><strong><code class="p">}</code><code> </code><code class="k">catch</code><code> </code><code class="p">(</code><code class="nx">e</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>We probably want to be careful to rethrow other exceptions, so we don’t silently swallow every possible error:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="k">try</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code> </code><code class="k">catch</code><code> </code><code class="p">(</code><code class="nx">e</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">e</code><code> </code><code class="k">instanceof</code><code> </code><code class="nx">RangeError</code><code class="p">)</code><code> </code><code class="p">{</code></strong><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code><code>&#13;
  </code><strong><code class="p">}</code><code> </code><code class="k">else</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">throw</code><code> </code><code class="nx">e</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>We might want to subclass the error for something more specific, so that when another engineer changes <code>parse</code> or <code>ask</code> to throw other <code>RangeError</code>s, we can differentiate between our error and the one they added:</p>&#13;
<pre data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code>&#13;
</code><em><code class="c1">// Custom error types&#13;
</code></em><strong><code class="kr">class</code><code> </code><code class="nx">InvalidDateFormatError</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">RangeError</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">DateIsInTheFutureError</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">RangeError</code><code> </code><code class="p">{</code><code class="p">}</code></strong><code>&#13;
&#13;
</code><code class="kd noBold">function</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">birthday</code><code>: </code><code class="kt noBold">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nb">Date</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd noBold">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="k noBold">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="nx">birthday</code><code class="p">)</code><code>&#13;
  </code><code class="k noBold">if</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nx">isValid</code><code class="p">(</code><code class="nx">date</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k noBold">throw</code><code> </code><strong><code class="k">new</code><code> </code><code class="nx">InvalidDateFormatError</code></strong><code class="p">(</code><code class="s1">'Enter a date in the form YYYY/MM/DD'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><strong><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">date</code><code class="p">.</code><code class="nx">getTime</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">&gt;</code><code> </code><code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">throw</code><code> </code><code class="k">new</code><code> </code><code class="nx">DateIsInTheFutureError</code><code class="p">(</code><code class="s1">'Are you a timelord?'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
  </code><code class="k noBold">return</code><code> </code><code class="nx">date</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="k noBold">try</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd noBold">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code> </code><code class="k noBold">catch</code><code> </code><code class="p">(</code><code class="nx">e</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k noBold">if</code><code> </code><code class="p">(</code><code class="nx">e</code><code> </code><code class="k noBold">instanceof</code><code> </code><strong><code class="nx">InvalidDateFormatError</code></strong><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code> </code><strong><code class="k">else</code><code> </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">e</code><code> </code><code class="k">instanceof</code><code> </code><code class="nx">DateIsInTheFutureError</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code></strong><code>&#13;
  </code><code class="p">}</code><code> </code><code class="k noBold">else</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k noBold">throw</code><code> </code><code class="nx">e</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code>&#13;
</pre>&#13;
&#13;
<p>Looking good. We can now do more than just signal that something failed: we can use a custom error to indicate <em>why</em> it failed. These errors might come in handy when combing through our server logs to debug an issue, or we can map them to specific error dialogs to give our users actionable feedback about what they did wrong and how they can fix it. We can also effectively chain and nest operations by wrapping any number of operations in a single <code>try</code>/<code>catch</code> (we don’t have to check each operation for failure, like we did when returning <code>null</code>).</p>&#13;
&#13;
<p>What does it feel like to use this code? Say the big <code>try</code>/<code>catch</code> is in one file, and the rest of the code is in a library being imported from somewhere else. How would an engineer know to catch those specific types of errors (<code>InvalidDateFormatError</code> and <code>DateIsInTheFutureError</code>), or to even just check for a regular old <code>RangeError</code>? (Remember that TypeScript doesn’t encode exceptions as part of a function’s signature.) We could indicate it in our function’s name (<code>parseThrows</code>), or include it in a docblock:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="cm">/**&#13;
 * @throws {InvalidDateFormatError} The user entered their birthday incorrectly.&#13;
 * @throws {DateIsInTheFutureError} The user entered a birthday in the future.&#13;
 */</code></strong><code>&#13;
</code><code class="kd">function</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">birthday</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nb">Date</code><code> </code><code class="p">{</code><code>&#13;
  </code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code></pre>&#13;
&#13;
<p>But in practice, an engineer probably wouldn’t wrap this code in a <code>try</code>/<code>catch</code> and check for exceptions at all, because engineers are lazy (at least, I am), and the type system isn’t telling them that they missed a case and should handle it. Sometimes, though—like in this example—errors are so expected that downstream code really should handle them, lest they cause the program to crash.</p>&#13;
&#13;
<p>How else can we indicate to consumers that they should handle both the success and the error cases?<a data-primary="errors" data-secondary="handling" data-startref="ix_errhanthrexc" data-tertiary="throwing exceptions" data-type="indexterm" id="idm46304961609656"/><a data-primary="exceptions" data-secondary="throwing" data-startref="ix_excptthrow" data-type="indexterm" id="idm46304961608136"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Returning Exceptions" data-type="sect1"><div class="sect1" id="idm46304962000072">&#13;
<h1>Returning Exceptions</h1>&#13;
&#13;
<p>TypeScript isn’t Java,<a data-primary="errors" data-secondary="handling" data-tertiary="returning exceptions" data-type="indexterm" id="ix_errhanretexc"/><a data-primary="exceptions" data-secondary="returning" data-type="indexterm" id="ix_excptret"/> and doesn’t support <code>throws</code> clauses.<sup><a data-type="noteref" href="ch07.html#idm46304961581304" id="idm46304961581304-marker">1</a></sup> But we can achieve something similar with union types:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="c1">// ...&#13;
</code><code class="kd">function</code><code> </code><code class="nx">parse</code><code class="p">(</code><code>&#13;
  </code><code class="nx">birthday</code><code>: </code><code class="kt">string</code><code>&#13;
</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nb">Date</code><code> </code><strong><code class="o">|</code><code> </code><code class="nx">InvalidDateFormatError</code><code> </code><code class="o">|</code><code> </code><code class="nx">DateIsInTheFutureError</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="nx">birthday</code><code class="p">)</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nx">isValid</code><code class="p">(</code><code class="nx">date</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><strong><code class="k">return</code></strong><code> </code><code class="k">new</code><code> </code><code class="nx">InvalidDateFormatError</code><code class="p">(</code><code class="s1">'Enter a date in the form YYYY/MM/DD'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">date</code><code class="p">.</code><code class="nx">getTime</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">&gt;</code><code> </code><code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><strong><code class="k">return</code></strong><code> </code><code class="k">new</code><code> </code><code class="nx">DateIsInTheFutureError</code><code class="p">(</code><code class="s1">'Are you a timelord?'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">date</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Now a consumer is forced to handle all three cases—<code>InvalidDateFormatError</code>, <code>DateIsInTheFutureError</code>, and successful parse—or they’ll get a <code>TypeError</code> at compile time:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// ...</code>&#13;
<code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">())</code> <code class="c1">// Either a date or an error</code>&#13;
<code class="k">if</code> <code class="p">(</code><code class="nx">result</code> <code class="k">instanceof</code> <code class="nx">InvalidDateFormatError</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">result</code> <code class="k">instanceof</code> <code class="nx">DateIsInTheFutureError</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code> <code class="nx">result</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">())</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, we successfully took advantage of TypeScript’s type system to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Encode likely exceptions in <code>parse</code>’s signature.</p>&#13;
</li>&#13;
<li>&#13;
<p>Communicate to consumers which specific exceptions might be thrown.</p>&#13;
</li>&#13;
<li>&#13;
<p>Force consumers to handle (or rethrow) each of the exceptions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A lazy consumer can avoid handling each error individually. But they have to do so explicitly:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kd">let</code><code> </code><code class="nx">result</code><code> </code><code class="o">=</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code> </code><code class="c1">// Either a date or an error&#13;
</code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">result</code><code> </code><code class="k">instanceof</code><code> </code><strong><code class="nb">Error</code></strong><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code> </code><code class="k">else</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">result</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Of course, your program might still crash due to an out of memory error or a stack overflow exception, but there’s not much we can do to recover from those.</p>&#13;
&#13;
<p>This approach is lightweight and doesn’t require fancy data structures, but it’s also informative enough that consumers will know what type of failure an error represents and what to search for to find more information.</p>&#13;
&#13;
<p>A downside is that chaining and nesting error-giving operations can quickly get verbose. If a function returns <code>T | Error1</code>, then any function that consumes that function has two options:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Explicitly handle <code>Error1</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Handle <code>T</code> (the success case) and pass <code>Error1</code> through to its consumers to handle. If you do this enough, the list of possible errors that a consumer has to handle grows quickly:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">x</code><code class="p">()</code><code class="o">:</code> <code class="nx">T</code> <code class="o">|</code> <code class="nx">Error1</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">function</code> <code class="nx">y</code><code class="p">()</code><code class="o">:</code> <code class="nx">U</code> <code class="o">|</code> <code class="nx">Error1</code> <code class="o">|</code> <code class="nx">Error2</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">x</code><code class="p">()</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="k">instanceof</code> <code class="nb">Error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">a</code>&#13;
  <code class="p">}</code>&#13;
  <code class="c1">// Do something with a</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">function</code> <code class="nx">z</code><code class="p">()</code><code class="o">:</code> <code class="nx">U</code> <code class="o">|</code> <code class="nx">Error1</code> <code class="o">|</code> <code class="nx">Error2</code> <code class="o">|</code> <code class="nx">Error3</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">y</code><code class="p">()</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="k">instanceof</code> <code class="nb">Error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">a</code>&#13;
  <code class="p">}</code>&#13;
  <code class="c1">// Do something with a</code>&#13;
<code class="p">}</code></pre>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This approach is verbose, but gives us excellent safety.<a data-primary="errors" data-secondary="handling" data-startref="ix_errhanretexc" data-tertiary="returning exceptions" data-type="indexterm" id="idm46304961321112"/><a data-primary="exceptions" data-secondary="returning" data-startref="ix_excptret" data-type="indexterm" id="idm46304961226264"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Option Type" data-type="sect1"><div class="sect1" id="option">&#13;
<h1>The Option Type</h1>&#13;
&#13;
<p>You can also describe exceptions using special-purpose data types.<a data-primary="errors" data-secondary="handling" data-tertiary="using Option type" data-type="indexterm" id="ix_errhanOpt"/><a data-primary="Option type" data-type="indexterm" id="ix_Opti"/> This approach has some downsides compared to returning unions of values and errors (notably, interoperability with code that doesn’t use these data types), but it does give you the ability to chain operations over possibly errored computations.<a data-primary="Try type" data-type="indexterm" id="idm46304961219096"/><a data-primary="Either type" data-type="indexterm" id="idm46304961218424"/> Three of the most popular options (heh!) are the <code>Try</code>, <code>Option</code>,<sup><a data-type="noteref" href="ch07.html#idm46304961216792" id="idm46304961216792-marker">2</a></sup> and <code>Either</code> types. In this chapter, we’ll just cover the <code>Option</code> type;<sup><a data-type="noteref" href="ch07.html#idm46304961214696" id="idm46304961214696-marker">3</a></sup> the other two are similar in spirit.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note that the <code>Try</code>, <code>Option</code>, and <code>Either</code> data types don’t come built into JavaScript environments the same way that <code>Array</code>, <code>Error</code>, <code>Map</code>, or <code>Promise</code> are. If you want to use these types, you’ll have to find implementations on NPM, or write them yourself.</p>&#13;
</div>&#13;
&#13;
<p>The <code>Option</code> type comes to us from languages like Haskell, OCaml, Scala, and Rust. The idea is that instead of returning a value, you return a <em>container</em> that may or may not have a value in it. The container has a few methods defined on it, which lets you chain operations even though there may not actually be a value inside. The container can be pretty much any data structure, so long as it can hold a value. For example, you could use an array as the container:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kd">function</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">birthday</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="nb">Date</code><code class="p">[</code><code class="p">]</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="nx">birthday</code><code class="p">)</code><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nx">isValid</code><code class="p">(</code><code class="nx">date</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><strong><code class="k">return</code><code> </code><code class="p">[</code><code class="p">]</code></strong><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><strong><code class="k">return</code><code> </code><code class="p">[</code><code class="nx">date</code><code class="p">]</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">date</code><code> </code><code class="o">=</code><code> </code><code class="nx">parse</code><code class="p">(</code><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><strong><code class="nx">date</code><code>&#13;
  </code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">_</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">_</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
  </code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">_</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">_</code><code class="p">)</code><code class="p">)</code></strong><code>&#13;
</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As you may have noticed, a downside of <code>Option</code> is that, much like our original <code>null</code>-returning approach, it doesn’t tell the consumer why the error happened; it just signals that something went wrong.</p>&#13;
</div>&#13;
&#13;
<p>Where <code>Option</code> really shines is when you need to do multiple operations in a row, each of which might fail.</p>&#13;
&#13;
<p>For example, before we assumed that <code>prompt</code> always succeeds, and <code>parse</code> might fail. But what if <code>prompt</code> can fail too? That might happen if the user cancelled out of the birthday prompt—that’s an error and we shouldn’t continue our computation. We can model that with… another <code>Option</code>!</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">ask() {</code><code>&#13;
  </code><strong><code class="kd">let</code><code> </code><code class="nx">result</code><code> </code><code class="o">=</code></strong><code> </code><code class="nx">prompt</code><code class="p">(</code><code class="s1">'When is your birthday?'</code><code class="p">)</code><code>&#13;
  </code><strong><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">result</code><code> </code><code class="o">===</code><code> </code><code class="kc">null</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="p">[</code><code class="p">]</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="p">[</code><code class="nx">result</code><code class="p">]</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><strong><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code>&#13;
  </code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">parse</code><code class="p">)</code></strong><code>&#13;
  </code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">date</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
    </code><em><code class="c1">// Error TS2339: Property 'toISOString' does not exist on type 'Date[]'.</code></em><code class="c1">&#13;
</code><code>  </code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">date</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">date</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Yikes—that didn’t work. Since we mapped an array of <code>Date</code>s (<code>Date[]</code>) to an array of arrays of <code>Date</code>s (<code>Date[][]</code>), we need to flatten it back to an array of <code>Date</code>s before we can keep going:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="nx">flatten</code><code class="p">(</code></strong><code class="nx">ask</code><code class="p">(</code><code class="p">)</code><code>&#13;
  </code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">parse</code><code class="p">)</code><strong><code class="p">)</code></strong><code>&#13;
  </code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">date</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
  </code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">date</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Date is'</code><code class="p">,</code><code> </code><code class="nx">date</code><code class="p">)</code><code class="p">)</code><code>&#13;
&#13;
</code><em><code class="c1">// Flattens an array of arrays into an array</code></em><code class="c1">&#13;
</code><strong><code class="kd">function</code><code> </code><code class="nx">flatten</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">T</code><code class="p">[</code><code class="p">]</code><code class="p">[</code><code class="p">]</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">concat</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">array</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>This is all getting a bit unwieldy. Because the types don’t tell you much (everything is a regular array), it’s hard to understand what’s going on in that code at a glance. To fix this, let’s wrap what we’re doing—putting a value in a container, exposing a way to operate on that value, and exposing a way to get a result back from the container—in a special data type that helps document our approach. Once we’re done implementing it, you’ll be able to use the data type like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">ask</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">parse</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">date</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nx">Some</code><code class="p">(</code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">()))</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">date</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nx">Some</code><code class="p">(</code><code class="s1">'Date is '</code> <code class="o">+</code> <code class="nx">date</code><code class="p">))</code>&#13;
  <code class="p">.</code><code class="nx">getOrElse</code><code class="p">(</code><code class="s1">'Error parsing date for some reason'</code><code class="p">)</code></pre>&#13;
&#13;
<p>We’ll define our <code>Option</code> type like this:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Option</code> is an interface that’s implemented by two classes: <code>Some&lt;T&gt;</code> and <code>None</code> (see <a data-type="xref" href="#optiont-fig">Figure 7-1</a>). They are<a data-primary="Option type" data-secondary="implementation in Some&lt;T&gt; and None classes" data-type="indexterm" id="idm46304960779144"/> the two kinds of <code>Option</code>s. <code>Some&lt;T&gt;</code> is an <code>Option</code> that contains a value of type <code>T</code>, and <code>None</code> is an <code>Option</code> without a value, which represents a failure.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Option</code> is both a type and a function. Its type is an interface that simply serves as the supertype of <code>Some</code> and <code>None</code>. Its function is the way to create a new value of type <code>Option</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="optiont-fig">&#13;
<img alt="prts 0701" src="assets/prts_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Option&lt;T&gt; has two cases: Some&lt;T&gt; and None</h6>&#13;
</div></figure>&#13;
&#13;
<p>Let’s start by sketching out the types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code class="p">}</code><code> </code><a class="co" href="#callout_handling_errors_CO1-1" id="co_handling_errors_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Some</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_handling_errors_CO1-2" id="co_handling_errors_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code><code> </code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">None</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">never</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code class="p">}</code><code> </code><a class="co" href="#callout_handling_errors_CO1-3" id="co_handling_errors_CO1-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_handling_errors_CO1-1" id="callout_handling_errors_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>Option&lt;T&gt;</code> is an interface that we’ll share between <code>Some&lt;T&gt;</code> and <code>None</code>.</p></dd>&#13;
<dt><a class="co" href="#co_handling_errors_CO1-2" id="callout_handling_errors_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>Some&lt;T&gt;</code> represents a successful operation that resulted in a value. Like the array we used before, <code>Some&lt;T&gt;</code> is a container for that value.</p></dd>&#13;
<dt><a class="co" href="#co_handling_errors_CO1-3" id="callout_handling_errors_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>None</code> represents an operation that failed, and does not contain a value.</p></dd>&#13;
</dl>&#13;
&#13;
<p>These types are equivalent to the following in our array-based <code>Option</code> <span class="keep-together">implementation</span>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Option&lt;T&gt;</code> is <code>[T] | []</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Some&lt;T&gt;</code> is <code>[T]</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>None</code> is <code>[]</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>What can you do with an <code>Option</code>? For our bare-bones implementation, we’ll define just <a data-primary="Option type" data-secondary="flatMap and getOrElse methods" data-type="indexterm" id="idm46304960657784"/>two operations:</p>&#13;
<dl>&#13;
<dt><code>flatMap</code></dt>&#13;
<dd>&#13;
<p>A way to chain operations on a possibly empty <code>Option</code></p>&#13;
</dd>&#13;
<dt><code>getOrElse</code></dt>&#13;
<dd>&#13;
<p>A way to retrieve a value from an <code>Option</code></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>We’ll start by defining these operations on our <code>Option</code> interface, meaning that <code>Some&lt;T&gt;</code> and <code>None</code> will need to provide concrete implementations for them:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">interface</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code>&#13;
  </code><code class="nx">getOrElse</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Some</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code><code> </code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">None</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">never</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>That is:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>flatMap</code> takes a function <code>f</code> that takes a value of type <code>T</code> (the type of the value the <code>Option</code> contains) and returns an <code>Option</code> of <code>U</code>. <code>flatMap</code> calls <code>f</code> with the <code>Option</code>’s value, and returns a new <code>Option&lt;U&gt;</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>getOrElse</code> takes a default value of the same type <code>T</code> as the value that the <code>Option</code> contains, and returns either that default value (if the <code>Option</code> is an empty <code>None</code>) or the <code>Option</code>’s value (if the <code>Option</code> is a <code>Some&lt;T&gt;</code>).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Guided by the types, <a data-primary="Option type" data-secondary="implementing flatMap and getOrElse on Some&lt;T&gt; and None" data-type="indexterm" id="idm46304960533864"/>let’s implement these methods for <code>Some&lt;T&gt;</code> and <code>None</code>:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">interface</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code>&#13;
  </code><code class="nx">getOrElse</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Some</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code><code> </code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
  </code><strong><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code> </code><code class="p">{</code></strong><code> </code><a data-type="co" href="#co_7_1_1" id="callout_7_1_1"><img src="assets/1.png"/></a><code>&#13;
    </code><strong><code class="k">return</code><code> </code><code class="nx">f</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">getOrElse</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code> </code><code class="p">{</code></strong><code> </code><a data-type="co" href="#co_7_1_2" id="callout_7_1_2"><img src="assets/2.png"/></a><code>&#13;
    </code><strong><code class="k">return</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">value</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">None</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">never</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code> </code><code class="p">{</code></strong><code> </code><a data-type="co" href="#co_7_1_3" id="callout_7_1_3"><img src="assets/3.png"/></a><code>&#13;
    </code><strong><code class="k">return</code><code> </code><code class="k">this</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">getOrElse</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">U</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">U</code><code> </code><code class="p">{</code></strong><code> </code><a data-type="co" href="#co_7_1_4" id="callout_7_1_4"><img src="assets/4.png"/></a><code>&#13;
    </code><strong><code class="k">return</code><code> </code><code class="nx">value</code><code>&#13;
  </code><code class="p">}</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<dl class="calloutlist">&#13;
<dt><a data-type="co" href="#callout_7_1_1" id="co_7_1_1"><img src="assets/1.png"/></a></dt>&#13;
<dd><p>When we call <code>flatMap</code> on a <code>Some&lt;T&gt;</code>, we pass in a function <code>f</code>, which <code>flatMap</code> calls with the <code>Some&lt;T&gt;</code>’s value to yield a new <code>Option</code> of a new type.</p></dd>&#13;
<dt><a data-type="co" href="#callout_7_1_2" id="co_7_1_2"><img src="assets/2.png"/></a></dt>&#13;
<dd><p>Calling <code>getOrElse</code> on a <code>Some&lt;T&gt;</code> just returns the <code>Some&lt;T&gt;</code>’s value.</p></dd>&#13;
<dt><a data-type="co" href="#callout_7_1_3" id="co_7_1_3"><img src="assets/3.png"/></a></dt>&#13;
<dd><p>Since a <code>None</code> represents a failed computation, calling <code>flatMap</code> on it always returns a <code>None</code>: once a computation fails, we can’t recover from that failure (at least not with our particular <code>Option</code> implementation).</p></dd>&#13;
<dt><a data-type="co" href="#callout_7_1_4" id="co_7_1_4"><img src="assets/4.png"/></a></dt>&#13;
<dd><p>Calling <code>getOrElse</code> on a <code>None</code> always returns the value we passed into <code>getOrElse</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>We can actually go a step beyond this naive implementation, and specify our types better. If all you know is that you have an <code>Option</code> and a function from <code>T</code> to <code>Option&lt;U&gt;</code>, then an <code>Option&lt;T&gt;</code> always <code>flatMap</code>s to an <code>Option&lt;U&gt;</code>. But when you know you have a <code>Some&lt;T&gt;</code> or a <code>None</code>, you can be more specific.</p>&#13;
&#13;
<p><a data-type="xref" href="#flatmap-table">Table 7-1</a> shows the result types we want when calling <code>flatMap</code> on the two types of <code>Option</code>s.</p>&#13;
<table id="flatmap-table">&#13;
<caption><span class="label">Table 7-1. </span>Result of calling .flatMap(f) on Some&lt;T&gt; and None</caption>&#13;
<thead>&#13;
<tr>&#13;
<th/>&#13;
<th>From <code>Some&lt;T&gt;</code></th>&#13;
<th>From <code>None</code></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>To <code>Some&lt;U&gt;</code></p></td>&#13;
<td><p><code>Some&lt;U&gt;</code></p></td>&#13;
<td><p><code>None</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>To <code>None</code></p></td>&#13;
<td><p><code>None</code></p></td>&#13;
<td><p><code>None</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>That is, we know that mapping over a <code>None</code> always results in a <code>None</code>, and mapping over a <code>Some&lt;T&gt;</code> results in either a <code>Some&lt;T&gt;</code> or a <code>None</code>, depending on what calling <code>f</code> returns.<a data-primary="Option type" data-secondary="using overloaded signatures to give flatMap more specific types" data-type="indexterm" id="idm46304960282728"/> We’ll exploit this and use overloaded signatures to give <code>flatMap</code> more specific types:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">interface</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">None</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">None</code></strong><code>&#13;
  </code><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code>&#13;
  </code><code class="nx">getOrElse</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Some</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code class="kr">private</code><code> </code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
  </code><strong><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">None</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">None</code><code>&#13;
  </code><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Some</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Some</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code></strong><code>&#13;
  </code><code class="nx">flatMap</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="nx">f</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">getOrElse</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">value</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kr">class</code><code> </code><code class="nx">None</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">never</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="nx">flatMap</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">None</code></strong><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">getOrElse</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">U</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">U</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="nx">value</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>We’re almost done. All that’s left to do is implement the <code>Option</code> function, which we’ll use to create new <code>Option</code>s.<a data-primary="Option type" data-secondary="implementing Option function" data-type="indexterm" id="idm46304960025016"/> We already implemented the <code>Option</code> <em>type</em> as an interface; now we’re going to implement a function with the same name (remember that TypeScript has two separate namespaces for types and for values) as a way to create a new <code>Option</code>, similar to what we did in <a data-type="xref" href="ch06.html#companion-objects">“Companion Object Pattern”</a>. If a user passes in <code>null</code> or <code>undefined</code>, we’ll give them back a <code>None</code>; otherwise, we’ll return a <code>Some</code>. Once again, we’ll overload the signature to do that:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">null</code><code> </code><code class="o">|</code><code> </code><code class="kc">undefined</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">None</code><code> </code><a class="co" href="#callout_handling_errors_CO2-1" id="co_handling_errors_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="kd">function</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Some</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_handling_errors_CO2-2" id="co_handling_errors_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="kd">function</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Option</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_handling_errors_CO2-3" id="co_handling_errors_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">value</code><code> </code><code class="o">==</code><code> </code><code class="kc">null</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nx">None</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="k">new</code><code> </code><code class="nx">Some</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_handling_errors_CO2-1" id="callout_handling_errors_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>If the consumer calls <code>Option</code> with <code>null</code> or <code>undefined</code>, we return a <code>None</code>.</p></dd>&#13;
<dt><a class="co" href="#co_handling_errors_CO2-2" id="callout_handling_errors_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Otherwise, we return a <code>Some&lt;T&gt;</code>, where <code>T</code> is the type of value the user passed in.</p></dd>&#13;
<dt><a class="co" href="#co_handling_errors_CO2-3" id="callout_handling_errors_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Finally, we manually calculate an upper bound for the two overloaded signatures. The upper bound of <code>null | undefined</code> and <code>T</code> is <code>T | null | undefined</code>, which simplifies to <code>T</code>. The upper bound of <code>None</code> and <code>Some&lt;T&gt;</code> is <code>None | Some&lt;T&gt;</code>, which we already have a name for: <code>Option&lt;T&gt;</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>That’s it. We’ve derived a fully working, minimal <code>Option</code> type that lets us safely perform operations over maybe-<code>null</code> values. We use it like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">Option</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>          <code class="c1">// Some&lt;number&gt;</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">Option</code><code class="p">(</code><code class="nx">n</code> <code class="o">*</code> <code class="mi">3</code><code class="p">))</code>  <code class="c1">// Some&lt;number&gt;</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nx">None</code><code class="p">)</code>       <code class="c1">// None</code>&#13;
  <code class="p">.</code><code class="nx">getOrElse</code><code class="p">(</code><code class="mi">7</code><code class="p">)</code>                 <code class="c1">// 7</code></pre>&#13;
&#13;
<p>Getting back to our birthday prompt example, our code now works as we’d expect:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">ask</code><code class="p">()</code>                                              <code class="c1">// Option&lt;string&gt;</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">parse</code><code class="p">)</code>                                  <code class="c1">// Option&lt;Date&gt;</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">date</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nx">Some</code><code class="p">(</code><code class="nx">date</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">()))</code>   <code class="c1">// Option&lt;string&gt;</code>&#13;
  <code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">date</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nx">Some</code><code class="p">(</code><code class="s1">'Date is '</code> <code class="o">+</code> <code class="nx">date</code><code class="p">))</code>    <code class="c1">// Option&lt;string&gt;</code>&#13;
  <code class="p">.</code><code class="nx">getOrElse</code><code class="p">(</code><code class="s1">'Error parsing date for some reason'</code><code class="p">)</code> <code class="c1">// string</code></pre>&#13;
&#13;
<p><code>Option</code>s are a powerful way to work with series of operations that may or may not succeed. They give you excellent type safety, and signal to consumers via the type system that a given operation might fail.</p>&#13;
&#13;
<p>However, <code>Option</code>s aren’t without their downsides. They signal failure with a <code>None</code>, so you don’t get more details about what failed and why. They also don’t interoperate with code that doesn’t use <code>Option</code>s (you’ll have to explicitly wrap those APIs to return <code>Option</code>s).</p>&#13;
&#13;
<p>Still, what you did there was pretty neat. The overloads you added let you do something that you can’t express in most languages, even those that rely on the <code>Option</code> type for working with nullable values. By restricting <code>Option</code> to just <code>Some</code> or <code>None</code> where possible via overloaded call signatures, you made your code a whole lot safer, and a whole lot of Haskell programmers very jealous. Now go grab yourself a cold one—you deserve it.<a data-primary="errors" data-secondary="handling" data-startref="ix_errhanOpt" data-tertiary="using Option type" data-type="indexterm" id="idm46304959769480"/><a data-primary="Option type" data-startref="ix_Opti" data-type="indexterm" id="idm46304959767960"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304961223496">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we covered the different ways to signal and recover from errors in TypeScript: returning <code>null</code>, throwing exceptions, returning exceptions, and the <code>Option</code> type. You now have an arsenal of approaches for safely working with things that might fail. Which approach you choose is up to you, and depends on:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Whether you want to simply signal that something failed (<code>null</code>, <code>Option</code>), or give more information about why it failed (throwing and returning exceptions).</p>&#13;
</li>&#13;
<li>&#13;
<p>Whether you want to force consumers to explicitly handle every possible exception (returning exceptions), or write less error-handling boilerplate (throwing exceptions).</p>&#13;
</li>&#13;
<li>&#13;
<p>Whether you need a way to compose errors (<code>Option</code>), or simply handle them when they come up (<code>null</code>, exceptions).</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46304959760392">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Design a way to handle errors for the following API, using one of the patterns from this chapter. In this API, every operation might fail—feel free to update the API’s method signatures to allow for failures (or don’t, if you prefer). Think about how you might perform a sequence of actions while handling errors that come up (e.g., getting the logged-in user’s ID, then getting their list of friends, then getting each friend’s name):<a data-primary="errors" data-secondary="handling" data-startref="ix_errhan" data-type="indexterm" id="idm46304959757928"/></p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">API</code> <code class="p">{</code>&#13;
  <code class="nx">getLoggedInUserID</code><code class="p">()</code><code class="o">:</code> <code class="nx">UserID</code>&#13;
  <code class="nx">getFriendIDs</code><code class="p">(</code><code class="nx">userID</code>: <code class="kt">UserID</code><code class="p">)</code><code class="o">:</code> <code class="nx">UserID</code><code class="p">[]</code>&#13;
  <code class="nx">getUserName</code><code class="p">(</code><code class="nx">userID</code>: <code class="kt">UserID</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304961581304"><sup><a href="ch07.html#idm46304961581304-marker">1</a></sup> If you haven’t worked with Java before, a <code>throws</code> clause indicates which types of runtime exceptions a method might throw, so a consumer has to handle those exceptions.</p><p data-type="footnote" id="idm46304961216792"><sup><a href="ch07.html#idm46304961216792-marker">2</a></sup> Also called the <code>Maybe</code> type.</p><p data-type="footnote" id="idm46304961214696"><sup><a href="ch07.html#idm46304961214696-marker">3</a></sup> Google “try type” or “either type” for more information on those types.</p></div></div></section></body></html>