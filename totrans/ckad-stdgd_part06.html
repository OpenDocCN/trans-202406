<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><div data-type="part" epub:type="part" data-pdf-bookmark="Part VI. Services and Networking" id="services_networking" class="dedication">
<h1 class="calibre30"><span class="keep-together">Part VI. </span>Services and Networking</h1>


<p class="author1">The last domain in the exam is named <em class="calibre3">Services and Networking</em>. It covers the Kubernetes primitives important for establishing and restricting communication between microservices running in the cluster, or outside consumers. More specifically, this domain covers the primitives Services and Ingresses, as well as network policies.</p>

<p class="author1">The following chapters cover these concepts:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1"><a data-type="xref" href="ch21.xhtml#services" class="calibre10">Chapter 21</a> introduces the Services resource type. You will learn how to expose a microservice inside of the cluster to other portions of the system. Services also allows for making an application accessible to end users outside of the cluster. This chapter doesn’t stop there. It also provides techniques for troubleshooting misconfigured Service objects.</p>
</li>
<li class="calibre13">
<p class="author1"><a data-type="xref" href="ch22.xhtml#ingresses" class="calibre10">Chapter 22</a> starts by explaining why a Service is often not good enough for exposing an application to outside consumers. The Ingress primitive can expose a load-balanced endpoint to consumers accessible via HTTP(S).</p>
</li>
<li class="calibre13">
<p class="author1"><a data-type="xref" href="ch23.xhtml#network_policies" class="calibre10">Chapter 23</a> explains the need for network policies from a security perspective. By default, Kubernetes’ Pod-to-Pod communication is unrestricted; however, you want to implement the principle of least privilege to ensure that only those Pods can talk to other Pods required by your architectural needs. Limiting network communication between Pods will decrease the potential attack surface.</p>
</li>
</ul>
</div></div></body>
</html>