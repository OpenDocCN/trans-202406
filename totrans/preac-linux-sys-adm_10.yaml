- en: Chapter 10\. Scripting and Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sysadmins automate what they can. But you can’t automate everything. Automation
    is a good thing but has its limitations. In this chapter, I discuss both the pros
    and cons of automation. Some tasks are difficult to automate because they involve
    too many variables. And automation does come with some security risks because
    automating tasks that require elevated privileges creates security holes that
    can lead to system compromise. Other obstacles to automation include timing and
    time drift, system failure, script error conditions, and human interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating scripts and automating tasks is challenging and fun. Watching a series
    of scripts and schedules work as planned to mimic human keystrokes, decisions,
    and activities is rewarding. Every sysadmin must know how to create basic shell
    scripts and should automate every possible nonprivileged, repetitive task. This
    chapter covers the concepts of scripting and automation but not the low-level
    mechanics of scripting (loops, file I/O, etc.), which are well-documented on the
    web.
  prefs: []
  type: TYPE_NORMAL
- en: 'Answering the Question: Why Automate?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’ve had a few sysadmins ask me why they should automate anything. The answer
    is simple: so you can focus on higher-level tasks while your computer systems
    handle the mundane, daily jobs that you must perform but that a CPU and some memory
    can address without making mistakes. Do you want your day filled with the drudgery
    of manually creating backups, copying backups to an archive location, checking
    capacity on every system, installing updates, checking log files for errors, and
    checking uptimes, or would you rather focus on system security, testing new software,
    and sharpening your scripting skills?'
  prefs: []
  type: TYPE_NORMAL
- en: You have only a limited number of hours to perform the work that must be done.
    And you probably have an almost inexhaustible supply of computing power at your
    fingertips. Use it. The tasks that require hours of your time can be handed off
    to systems that complete those repetitive tasks flawlessly, without getting tired
    or frustrated, and with almost no overhead. And those are the reasons to automate
    every task that you possibly can.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Yourself Out of a Job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spoiler alert: you’re never going to automate yourself out of a job, but you
    should try. Seriously, you can automate every repetitive, mundane task you face,
    but you’ll never succeed in losing your job because you’ve automated it. Too many
    variables and things can go wrong with the hardware, software, networks, and,
    most of all, users to end your employment because you’ve successfully automated
    too much.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are answers to five common questions about automation that I’m confident
    will clear things up for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Which tasks should I automate?
  prefs: []
  type: TYPE_NORMAL
- en: Anything that can be scripted reliably, even if it requires user input.
  prefs: []
  type: TYPE_NORMAL
- en: Are there tasks that cannot be automated?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, plenty of them. Most things requiring a complex, multistep decision can’t
    be automated (although some can). You can use various techniques to automate them,
    including `expect`, shell scripts, Perl, PHP, and other scripting and compiled
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: Are there tasks that should never be automated?
  prefs: []
  type: TYPE_NORMAL
- en: Yes. You should not automate tasks such as those that require you to store an
    unencrypted password in a text file. There are multiple methods of automating
    tasks where you can use encrypted passwords, key files, limited `sudo`, or nonprivileged
    accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Which task should I automate first?
  prefs: []
  type: TYPE_NORMAL
- en: Backups. For example, create a backup of your */etc* directory and use secure
    copy (SCP) to archive it onto another system.
  prefs: []
  type: TYPE_NORMAL
- en: Should I purchase a commercial automation solution?
  prefs: []
  type: TYPE_NORMAL
- en: You can, but you should begin by using your own scripts and exhausting your
    options before spending money on something you can do just as efficiently and
    free of charge. But certainly, purchase a commercial solution if the number of
    hosts makes it reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Basic automation is easy to do, it saves money and time, and it prevents mistakes
    made by human hands.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a psychological aspect of automation—sysadmins who automate experience
    less burnout than those who perform every task manually. Think about the repetitive
    nature of making backups, transferring them to an archive location, checking backups,
    and removing old archives. If you manage more than a handful of systems, it will
    take a significant portion of your day (or evening) to type every command manually.
    This kind of labor wears on a person’s psyche and causes burnout and job dissatisfaction.
    Multiple studies show that automation does increase job satisfaction. Alex Edelstein’s
    blog post [“89% of Your Employees Could Benefit with This One Change”](https://oreil.ly/5-iR9)
    explains this concept further.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need a script to perform a particular task, chances are excellent that
    you can find one with a simple online search. You don’t have to write one from
    scratch. Adapt scripts to your needs and use them without guilt. Other system
    administrators place their scripts online for you to use. You should, however,
    learn the basics of scripting, such as reading from a file, writing to a file,
    grepping, piping, redirecting, looping, and calling other scripts from within
    a script. You don’t have to become a scripting expert but learning the basics
    helps you find what you need and allows you to adapt what you find to your circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Writing backup scripts is a good place to start. Backups are required, and you’ll
    be a hero in case of a failure or human error, which could be your own. I’ve known
    sysadmins with more than ten years of experience who have removed entire */etc*
    directories by accident, so a good backup is essential to a happy life as a sysadmin.
    The following sections teach you scriptwriting concepts. The most important of
    these is outlining your script.
  prefs: []
  type: TYPE_NORMAL
- en: Outlining Your Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you write a script, outline what you want the script to do. No, you
    don’t have to create a flowchart, but you should list the steps that you want
    to occur during the script’s run. Here’s an example of a script that I’ll call
    *backup_server1.sh*:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `tar` file of the */etc* directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compress the `tar` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transfer the file to server *archive1*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s simple enough. The script is a simple, top-down procedure with no decision
    tree or branching.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Script from an Outline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And now that you have your script outline, you also have the documentation for
    your script. You must document your scripts because, in six months or a year,
    you might not remember the script’s purpose or even that you wrote it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of *backup_server1.sh* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, give it execute permission, and it’s ready to use. The */server1/backups*
    directory on the *archive1* system should be executable and writeable by the user
    placing the backups into it. For better security, you should designate a backup
    user and create backup directories with permissions restricted to that user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Backup and Restore (`bur`) user on all systems and set up passwordless
    SSH key files for the `bur` user. Set up `cron` jobs for backups as the `bur`
    user on all systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `crontab` for the `bur` user on *server1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `bur` user’s `crontab` will back up *server1*’s */etc* directory every day
    at 2 a.m. The backups will transfer to *archive1* into the */server1/backup* directory.
    You need to set up this scenario on every system. The backup for *archive1* should
    be sent to a different system.
  prefs: []
  type: TYPE_NORMAL
- en: The */etc* directory isn’t the only directory you need to back up. This is just
    an example. You might need to back up */home*, */var/www/html*, */opt*, and others
    to restore a system to its previous state before a security incident or failure.
    The `crontab` (scheduled task) will be explained in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cron` utility schedules commands to run at a specific time. It helps to
    automate repetitive tasks that must be performed at a specific time, multiple
    times, or at inconvenient times for humans.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, developers have attempted to replace the `cron` utility with
    little success. `cron` is difficult to replace because it works well and is versatile
    enough to handle most scheduled activities. `cron` is reliable because it uses
    the computer’s system clock to act on scheduled activities. The one flaw with
    `cron`, if you can call it that, is that you will encounter problems if your automated
    tasks involve multiple systems and their times drift out of sync. The solution
    is to reference a central time server. I will cover the network time protocol
    later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using cron to Schedule Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `cron` utility is available on all Linux systems, and it just works. There’s
    no tweaking or configuration required. It’s a time-tested application built to
    do one job: run commands at a specific time—and it does that job very well. The
    best way to learn `cron` is by example because the syntax isn’t necessarily intuitive.'
  prefs: []
  type: TYPE_NORMAL
- en: '`cron` has a simple “syntax” or format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What isn’t shown here is that you can run scripts or commands multiple times
    using only one schedule or `cron` “job.” For example, you need to run a script
    that checks for the existence of a file every 5 minutes every day. The format
    for that entry is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a script to run every Monday, Wednesday, and Friday at 2:00 p.m.,
    the `cron` schedule takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want your script to run at 6 a.m. on the 15th of every month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You have a full range of possibilities with `cron` schedules.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Do not set a schedule in `cron` for ** * * * * /path/to/script.sh* unless you
    want your script to run every minute of every day. For most monitoring scenarios,
    once every five minutes is sufficient to catch any process, error, or file you’re
    trying to capture or track.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Time Drift with the Network Time Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the problems with writing scripts that operate on multiple systems is
    synchronizing system time among them. For example, imagine you have a script that
    gathers files from *Server A* and copies them to *Server B*, and once those files
    are copied, *Server B* checks for them and then creates a tarball and copies them
    onto NAS for archiving. If this needs to happen multiple times per day and in
    a timed sequence, you can see how synchronized time among server systems is essential.
  prefs: []
  type: TYPE_NORMAL
- en: The way to keep time synced among all your systems is to reference an internet
    time server plus a time server inside your network (in case you experience an
    internet connectivity outage).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `ntp` or `chrony` to allow your systems to synchronize with an external
    (internet) time server. Installing `chrony` is easy and requires no configuration
    as a client. Here, I demonstrate how to install and configure `chrony`. It works
    similarly on Debian distributions except that your `chrony` configuration file
    is located in */etc/chrony/* rather than simply in */etc*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `chrony` package provides you with the `chrony` daemon, `chronyd`, and
    a command-line interface utility that has dozens of options, which you can find
    in its man page. To perform a quick check, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also configure `chrony` as a time server for your local network. To
    do so, uncomment the following two lines in the */etc/chrony.conf* file on the
    system you wish to set up as the time server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `Allow` line to cover your subnet(s) and restart the `chronyd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up other Linux systems to use your `chrony` server, enter the following
    line into your */etc/chrony.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prefer` designation tells `chrony` that this local system should be consulted
    first for the correct time. Restart the `chronyd` to accept the new setting and
    check your `chronyd` sources with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You could also configure all your client systems to use only the local server
    by commenting out the “pool” line(s) in */etc/chrony.conf*. You may also edit
    the *chrony.conf* file to set up more specific settings. What I’ve shown here
    is a minimal but working configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although `cron` and `chrony` sound similar, deal with timing, and work together,
    they are quite different. The `cron` utility schedules jobs to be executed at
    a specific day and time, whereas `chrony` synchronizes the system clock with an
    external time server. `chrony` keeps system time stable so that `cron` jobs run
    at the correct time, which is especially important when timing jobs across multiple
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Timing is everything.* Scheduling jobs, synchronizing time among local systems,
    timing automated scripts among systems, and synchronizing time with an external
    “source of truth” is essential. Automation is but one reason to keep your systems’
    times synchronized. Security is another. Consider the scenario where you’re attempting
    to isolate a security incident, and your systems are not time synchronized. It
    would be difficult to pinpoint a timeframe for the incident to determine when
    it occurred and its length.'
  prefs: []
  type: TYPE_NORMAL
- en: Automation is an important part of your work as a system administrator. There
    aren’t enough hours available to manually complete every required task. You must
    hand off your repetitive, mundane tasks to your systems. They won’t complain,
    tire, or mistype a command. Automation is a good thing, and you should embrace
    it. Try to automate yourself out of a job.
  prefs: []
  type: TYPE_NORMAL
