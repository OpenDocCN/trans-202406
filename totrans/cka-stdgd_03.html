<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Workloads"><div class="chapter" id="workloads">
<h1><span class="label">Chapter 3. </span>Workloads</h1>


<p><a data-type="indexterm" data-primary="workloads" id="work_ch"/>When we talk about <a href="https://oreil.ly/Uz1gG">workloads in Kubernetes</a>, we mean the API resource types that run an application. Those API resource types include a Deployment, ReplicaSet, StatefulSet, DaemonSet, Job, CronJob, and of course the Pod. The curriculum of the CKA is very specific about the types of workload you need to be familiar with. The exam will include only the Deployment, ReplicaSet, and Pod. You will need to understand replication and rollout features managed by a Deployment and understand the API primitives for injecting configuration data into a Pod.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This chapter will use the concept of a volume. Take a look through <a data-type="xref" href="ch06.xhtml#storage">Chapter 6</a> for more information if you’re not familiar with Kubernetes’ persistent storage options.</p>
</div>

<p>At a high level, this chapter covers the following concepts:</p>

<ul>
<li>
<p>A basic understanding of Deployments</p>
</li>
<li>
<p>Deployment rollout and rollback functionality</p>
</li>
<li>
<p>Manual and automatic scaling of the replicas controlled by a ReplicaSet</p>
</li>
<li>
<p>ConfigMap and Secret</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="Managing Workloads with Deployments"><div class="sect1" id="idm45322727299248">
<h1>Managing Workloads with Deployments</h1>

<p><a data-type="indexterm" data-primary="Deployments" data-secondary="managing workloads with" id="dep_man"/><a data-type="indexterm" data-primary="workloads" data-secondary="managing with Deployments" id="work_dep"/>In Kubernetes, a workload is executed in a Pod. There are various API resources that manage one or many Pods. In this section, we’ll concentrate on the API resources Deployment and ReplicaSet, which are most relevant to the exam. Moreover, we’ll briefly touch on the StatefulSet, which manages workloads that hold state.</p>








<section data-type="sect2" data-pdf-bookmark="Understanding Deployments"><div class="sect2" id="idm45322727295040">
<h2>Understanding Deployments</h2>

<p><a data-type="indexterm" data-primary="Deployments" data-secondary="about" id="idm45322727293728"/>The central API resource for running an application in a container is the Pod. Using a single instance of a Pod to operate an application has its flaws. It represents a single point of failure as all traffic targeting the application is funneled to this Pod. This behavior is specifically problematic when the load increases due to higher demand (e.g., during peak shopping season for an e-commerce application or when a central microservice like an authentication provider is used by an increasing number of other microservices within the system). Another important aspect of running an application in a Pod is failure tolerance. A Pod will not be rescheduled in the case of a node failure and therefore can lead to a system outage for end users. In this section, we’ll talk about the Kubernetes mechanics that support aspects such as application scalability and failure tolerance.</p>

<p><a data-type="indexterm" data-primary="ReplicaSet" id="idm45322727292368"/>A <em>ReplicaSet</em> is a Kubernetes API resource that controls multiple, identical instances of a Pod running the application, so-called replicas. It has the capability of scaling the number of replicas up or down on demand. Moreover, it knows how to roll out a new version of the application across all replicas.</p>

<p>A <em>Deployment</em> abstracts the functionality of ReplicaSet and manages it internally. In practice, this means that you do not have to create, modify, or delete ReplicaSet objects yourself. The Deployment keeps a history of application versions and can roll back to an older version to counteract a blocking or potentially costly production issue. Furthermore, it offers the capability of scaling the number of replicas.</p>

<p><a data-type="xref" href="#deployment_replicaset">Figure 3-1</a> illustrates the relationship between a Deployment, a ReplicaSet, and its controlled replicas.</p>

<figure><div id="deployment_replicaset" class="figure"><div class="border-box"><img src="Images/ckas_0301.png" alt="ckas 0301" width="898" height="589"/></div><h6><span class="label">Figure 3-1. </span>Relationship between a Deployment and a ReplicaSet</h6></div></figure>

<p>The following sections will explain how to manage Deployments, including scaling and rollout features.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating Deployments"><div class="sect2" id="idm45322727285952">
<h2>Creating Deployments</h2>

<p><a data-type="indexterm" data-primary="create deployment command" id="idm45322727284080"/><a data-type="indexterm" data-primary="commands" data-secondary="create deployment" id="idm45322727283360"/><a data-type="indexterm" data-primary="Deployments" data-secondary="creating" id="idm45322727282416"/>You can create a Deployment using the imperative command <code>create deployment</code>. The command offers a range of options, some of which are mandatory. At a minimum, you need to provide the name of the Deployment and the container image that should be used by the replicas. The default number of replicas created is 1; however, you can define a higher number of replicas using the option <code>--replicas</code>.</p>

<p>Let’s see the command in action. The following command creates the Deployment named <code>app-cache</code>, which runs the object cache <a href="https://memcached.org">Memcached</a> inside of the container on four replicas:</p>

<pre data-type="programlisting"><strong>$ kubectl create deployment app-cache --image=memcached:1.6.8 --replicas=4</strong>
deployment.apps/app-cache created</pre>

<p>The mapping between the Deployment and the replicas it controls happens through label selection. When you run the imperative command, <code>kubectl</code> already sets up the mapping for you. <a data-type="xref" href="#yaml_manifest_deployment">Example 3-1</a> shows the label selection in the YAML manifest. This YAML manifest can be used to create a Deployment declaratively or by inspecting the live object created by the previous imperative command.</p>
<div id="yaml_manifest_deployment" data-type="example">
<h5><span class="label">Example 3-1. </span>A YAML manifest for a Deployment</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">4</code><code class="w"/>
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memcached</code><code class="w"/>
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memcached:1.6.8</code><code class="w"/></pre></div>

<p class="pagebreak-before">When created by the imperative command, <code>app</code> is the label key the Deployment uses by default. You can find this key in three different places in the YAML output:</p>
<ol>
<li>
<p><code>metadata.labels</code></p>
</li>
<li>
<p><code>spec.selector.matchLabels</code></p>
</li>
<li>
<p><code>spec.template.metadata.labels</code></p>
</li>

</ol>

<p>For label selection to work properly, the assignment of <code>spec.selector.matchLabels</code> and <code>spec.template.metadata</code> needs to match, as shown in <a data-type="xref" href="#deployment_label_selection">Figure 3-2</a>.</p>

<figure><div id="deployment_label_selection" class="figure"><div class="border-box"><img src="Images/ckas_0302.png" alt="ckas 0302" width="1019" height="917"/></div><h6><span class="label">Figure 3-2. </span>Deployment label selection</h6></div></figure>

<p>The values of <code>metadata.labels</code> is irrelevant for mapping the Deployment to the Pod template. As you can see in <a data-type="xref" href="#deployment_label_selection">Figure 3-2</a>, the label assignment to <code>metadata.labels</code> has been changed deliberately to <code>deploy: app-cache</code> to underline that it is not important for the Deployment to Pod template selection.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Listing Deployments and Their Pods"><div class="sect2" id="idm45322727285360">
<h2>Listing Deployments and Their Pods</h2>

<p><a data-type="indexterm" data-primary="Deployments" data-secondary="listing" id="idm45322727216320"/><a data-type="indexterm" data-primary="commands" data-secondary="get deployments" id="idm45322727215344"/><a data-type="indexterm" data-primary="get deployments command" id="idm45322727129760"/><a data-type="indexterm" data-primary="Pods" data-secondary="listing" id="idm45322727129152"/>You can inspect a Deployment after its creation by using the <code>get deployments</code> command. The output of the command renders the important details of its replicas, as shown here:</p>

<pre data-type="programlisting"><strong>$ kubectl get deployments</strong>
NAME        READY   UP-TO-DATE   AVAILABLE   AGE
app-cache   4/4     4            4           125m</pre>

<p>You can observe the following column titles relevant to the replicas controlled by the Deployment in <a data-type="xref" href="#runtime_replica_information">Table 3-1</a>.</p>
<table id="runtime_replica_information">
<caption><span class="label">Table 3-1. </span>Runtime replica information when listing deployments</caption>
<thead>
<tr>
<th>Column Title</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>READY</p></td>
<td><p>Lists the number of replicas available to end users in the format of &lt;ready&gt;/&lt;desired&gt;. The number of desired replicas corresponds to the value of <code>spec.replicas</code>.</p></td>
</tr>
<tr>
<td><p>UP-TO-DATE</p></td>
<td><p>Lists the number of replicas that have been updated to achieve the desired state.</p></td>
</tr>
<tr>
<td><p>AVAILABLE</p></td>
<td><p>Lists the number of replicas available to end users.</p></td>
</tr>
</tbody>
</table>

<p>The Pods controlled by the Deployment can be identified by the naming prefix in their names. In the case of the previously created Deployment, the Pods’ names start with <code>app-cache-</code>. The hash following the prefix is autogenerated and assigned to the name upon creation:</p>

<pre data-type="programlisting"><strong>$ kubectl get pods</strong>
NAME                         READY   STATUS    RESTARTS   AGE
app-cache-596bc5586d-84dkv   1/1     Running   0          6h5m
app-cache-596bc5586d-8bzfs   1/1     Running   0          6h5m
app-cache-596bc5586d-rc257   1/1     Running   0          6h5m
app-cache-596bc5586d-tvm4d   1/1     Running   0          6h5m</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Rendering Deployment Details"><div class="sect2" id="idm45322727114080">
<h2>Rendering Deployment Details</h2>

<p><a data-type="indexterm" data-primary="Deployments" data-secondary="rendering details of" id="idm45322727112912"/>You can render the details of a Deployment. Those details include the label selection criteria that can be extremely valuable when troubleshooting a misconfigured Deployment. The following output provides the full gist:</p>

<pre data-type="programlisting"><strong>$ kubectl describe deployment app-cache</strong>
Name:                   app-cache
Namespace:              default
CreationTimestamp:      Sat, 07 Aug 2021 09:44:18 -0600
Labels:                 app=app-cache
Annotations:            deployment.kubernetes.io/revision: 1
Selector:               app=app-cache
Replicas:               4 desired | 4 updated | 4 total | 4 available | \
                        0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=app-cache
  Containers:
   memcached:
    Image:        memcached:1.6.10
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Progressing    True    NewReplicaSetAvailable
  Available      True    MinimumReplicasAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   app-cache-596bc5586d (4/4 replicas created)
Events:          &lt;none&gt;</pre>

<p><a data-type="indexterm" data-primary="ReplicaSet" id="idm45322727110608"/>You might have noticed that the output contains a reference to a ReplicaSet. The purpose of a ReplicaSet is to <em>replicate</em> a set of identical Pods. You do not need to deeply understand the core functionality of a ReplicaSet for the exam. Just be aware that the ReplicaSet is automatically created by a Deployment and uses the Deployment’s name as a prefix for the ReplicaSet similar to the Pods it controls. In the case of the previous Deployment named <code>app-cache</code>, the name of the ReplicaSet is <code>app-cache-596bc5586d</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deleting a Deployment"><div class="sect2" id="idm45322727108128">
<h2>Deleting a Deployment</h2>

<p><a data-type="indexterm" data-primary="Deployments" data-secondary="deleting" id="idm45322727106720"/>A Deployment takes full charge of the creation and deletion of the objects it controls, Pods and ReplicaSets. When you delete a Deployment, the corresponding objects are deleted as well. Say you are dealing with the following set of objects shown in the output:</p>

<pre data-type="programlisting"><strong>$ kubectl get deployments,pods,replicasets</strong>
NAME                        READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/app-cache   4/4     4            4           6h47m

NAME                             READY   STATUS    RESTARTS   AGE
pod/app-cache-596bc5586d-84dkv   1/1     Running   0          6h47m
pod/app-cache-596bc5586d-8bzfs   1/1     Running   0          6h47m
pod/app-cache-596bc5586d-rc257   1/1     Running   0          6h47m
pod/app-cache-596bc5586d-tvm4d   1/1     Running   0          6h47m

NAME                                   DESIRED   CURRENT   READY   AGE
replicaset.apps/app-cache-596bc5586d   4         4         4       6h47m</pre>

<p><a data-type="indexterm" data-primary="" data-startref="dep_man" id="idm45322727104416"/><a data-type="indexterm" data-primary="" data-startref="work_dep" id="idm45322727103440"/><a data-type="indexterm" data-primary="commands" data-secondary="delete deployment" id="idm45322727102496"/><a data-type="indexterm" data-primary="delete deployment command" id="idm45322727101552"/>Run the <code>delete deployment</code> command for a cascading deletion of its managed objects:</p>

<pre data-type="programlisting"><strong>$ kubectl delete deployment app-cache</strong>
deployment.apps "app-cache" deleted
<strong>$ kubectl get deployments,pods,replicasets</strong>
No resources found in default namespace.</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Performing Rolling Updates and Rollbacks"><div class="sect1" id="idm45322727098608">
<h1>Performing Rolling Updates and Rollbacks</h1>

<p><a data-type="indexterm" data-primary="rolling updates, performing" id="idm45322727097440"/><a data-type="indexterm" data-primary="rollbacks, performing" id="idm45322727096720"/><a data-type="indexterm" data-primary="workloads" data-secondary="performing rolling updates and rollbacks" id="idm45322727096048"/>Rollout and rollback capabilities are built into certain API resources. Once the definition of the Pod template in a Deployment has been changed, Kubernetes knows how to apply the change to all Pods managed by the object. In this section, we’ll talk about both scenarios: deploying a new version of an application and reverting to an old version of an application.</p>








<section data-type="sect2" data-pdf-bookmark="Rolling Out a New Revision"><div class="sect2" id="idm45322727094752">
<h2>Rolling Out a New Revision</h2>

<p><a data-type="indexterm" data-primary="revisions" data-secondary="rolling out new" id="idm45322727092944"/>Deployments make it very easy to roll out a new version of the application to all replicas it controls. Say you want to upgrade the version of Memcached from 1.6.8 to 1.6.10 to benefit from the latest features and bug fixes. All you need to do is to change the desired state of the object by updating the Pod template. The Deployment takes care of updating all replicas to the new version one by one. This process is called a <em>rolling update</em>.</p>

<p><a data-type="indexterm" data-primary="edit deployment command" id="idm45322727091136"/><a data-type="indexterm" data-primary="commands" data-secondary="edit deployment" id="idm45322727090432"/>At any time, you can modify the live object using the command <code>edit deployment</code>. Alternatively, the command <code>set image</code> offers a quick and convenient way to change the image of a Deployment, as shown in the following command:</p>

<pre data-type="programlisting"><strong>$ kubectl set image deployment app-cache memcached=memcached:1.6.10 --record</strong>
deployment.apps/app-cache image updated</pre>

<p>The flag <code>--record</code> is optional and defaults to the value <code>false</code>. If provided without a value or set to the value <code>true</code>, the command used for the change will be recorded. Internally, the <code>set image</code> command preserves the change cause by assigning the annotation with the key <code>kubernetes.io/change-cause</code> to the Deployment.</p>

<p><a data-type="indexterm" data-primary="commands" data-secondary="rollout status" id="idm45322727084448"/><a data-type="indexterm" data-primary="rollout status command" id="idm45322727083440"/>You can check the current status of a rollout while in progress. The command to use is <code>rollout status</code>. The output gives you an indication of the number of replicas that have already been updated since emitting the command:</p>

<pre data-type="programlisting"><strong>$ kubectl rollout status deployment app-cache</strong>
Waiting for rollout to finish: 2 out of 4 new replicas have been updated...
deployment "app-cache" successfully rolled out</pre>

<p>Kubernetes keeps track of the changes you make to a Deployment over time in the rollout history. Every change is represented by a so-called <em>revision</em>. You can check the rollout history by running the following command. You will see two revisions listed:</p>

<pre data-type="programlisting"><strong>$ kubectl rollout history deployment app-cache</strong>
deployment.apps/app-cache
REVISION  CHANGE-CAUSE
1         &lt;none&gt;
2         kubectl set image deployment app-cache memcached=memcached:1.6.10 \
          --record=true</pre>

<p>The first revision was recorded for the original state of the Deployment when you created the object. The second revision was added for changing the image tag. Note that the column “CHANGE-CAUSE” renders the command used for the change.</p>

<p>To get a more detailed view on the revision, run the following command. You can see that the image uses the value <code>memcached:1.6.10</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl rollout history deployments app-cache --revision=2</strong>
deployment.apps/app-cache with revision #2
Pod Template:
  Labels:	app=app-cache
	pod-template-hash=596bc5586d
  Annotations:	kubernetes.io/change-cause: kubectl set image deployment \
                app-cache memcached=memcached:1.6.10 --record=true
  Containers:
   memcached:
    Image:	memcached:1.6.10
    Port:	&lt;none&gt;
    Host Port:	&lt;none&gt;
    Environment:	&lt;none&gt;
    Mounts:	&lt;none&gt;
  Volumes:	&lt;none&gt;</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Rolling Back to a Previous Revision"><div class="sect2" id="idm45322727094160">
<h2>Rolling Back to a Previous Revision</h2>

<p><a data-type="indexterm" data-primary="revisions" data-secondary="rolling back to previous" id="idm45322727075056"/><a data-type="indexterm" data-primary="rollout undo command" id="idm45322727074032"/><a data-type="indexterm" data-primary="commands" data-secondary="rollout undo" id="idm45322727073360"/>Problems may arise in production that require swift action. For example, say that the container image that you just rolled out contains a crucial bug. Kubernetes gives you the option to roll back to one of the previous revisions in the rollout history. You can achieve this by using the <code>rollout undo</code> command. To pick a specific revision, provide the command-line option <code>--to-revision</code>. The command rolls back to the previous revision if you do not provide the option. Here, we are rolling back to revision 1:</p>

<pre data-type="programlisting"><strong>$ kubectl rollout undo deployment app-cache --to-revision=1</strong>
deployment.apps/app-cache rolled back</pre>

<p>As a result, Kubernetes performs a rolling update to all replicas with the revision 1. Checking the rollout history now lists revision 3. Given that we rolled back to revision 1, there’s no more need to keep that entry as a duplicate. Kubernetes simply turns revision 1 into 3 and removes 1 from the list:</p>

<pre data-type="programlisting"><strong>$ kubectl rollout history deployment app-cache</strong>
deployment.apps/app-cache
REVISION  CHANGE-CAUSE
2         kubectl set image deployment app-cache memcached=memcached:1.6.10 \
          --record=true
3         &lt;none&gt;</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Scaling Workloads"><div class="sect1" id="idm45322727068496">
<h1>Scaling Workloads</h1>

<p><a data-type="indexterm" data-primary="scaling workloads" id="sca_work"/><a data-type="indexterm" data-primary="workloads" data-secondary="scaling" id="work_sca"/>Scalability is one of Kubernetes’ built-in capabilities. We’ll learn how to manually scale the number of replicas as a reaction to increased load on the application. Furthermore, we’ll talk about the API resource Horizontal Pod Autoscaler, which allows to automatically scale the managed set of Pods based on resource thresholds like CPU and memory.</p>








<section data-type="sect2" data-pdf-bookmark="Manually Scaling a Deployment"><div class="sect2" id="idm45322727064736">
<h2>Manually Scaling a Deployment</h2>

<p><a data-type="indexterm" data-primary="Deployments" data-secondary="manually scaling" id="idm45322727063376"/><a data-type="indexterm" data-primary="commands" data-secondary="edit deployment" id="idm45322727062176"/><a data-type="indexterm" data-primary="edit deployment command" id="idm45322727061232"/><a data-type="indexterm" data-primary="scale deployment command" id="idm45322727060560"/><a data-type="indexterm" data-primary="commands" data-secondary="scale deployment" id="idm45322727059872"/>Scaling the number of replicas controlled by a Deployment up or down is a straightforward process. You can either manually edit the live object using <code>edit deployment</code> and change the value of the attribute <code>spec.replicas</code> or use the imperative <code>scale deployment</code> command. The following command increases the number of replicas from four to six:</p>

<pre data-type="programlisting"><strong>$ kubectl scale deployment app-cache --replicas=6</strong>
deployment.apps/app-cache scaled</pre>

<p>You can observe the creation of replicas in real time. If you are fast enough, you might still see the change of status for the newly created Pods turning from <code>ContainerCreating</code> to <code>Running</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl get pods</strong>
NAME                         READY   STATUS              RESTARTS   AGE
app-cache-5d6748d8b9-6cc4j   1/1     ContainerCreating   0          11s
app-cache-5d6748d8b9-6rmlj   1/1     Running             0          28m
app-cache-5d6748d8b9-6z7g5   1/1     ContainerCreating   0          11s
app-cache-5d6748d8b9-96dzf   1/1     Running             0          28m
app-cache-5d6748d8b9-jkjsv   1/1     Running             0          28m
app-cache-5d6748d8b9-svrxw   1/1     Running             0          28m
<strong>$ kubectl get pods</strong>
NAME                         READY   STATUS    RESTARTS   AGE
app-cache-5d6748d8b9-6cc4j   1/1     Running   0          3m17s
app-cache-5d6748d8b9-6rmlj   1/1     Running   0          32m
app-cache-5d6748d8b9-6z7g5   1/1     Running   0          3m17s
app-cache-5d6748d8b9-96dzf   1/1     Running   0          32m
app-cache-5d6748d8b9-jkjsv   1/1     Running   0          31m
app-cache-5d6748d8b9-svrxw   1/1     Running   0          32m</pre>

<p>Manually scaling the number of replicas takes a little bit of guesswork. You will still have to monitor the load on your system to see if your number of replicas is sufficient to handle the incoming traffic.</p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Manually Scaling a StatefulSet"><div class="sect2" id="idm45322727053136">
<h2>Manually Scaling a StatefulSet</h2>

<p><a data-type="indexterm" data-primary="StatefulSet, manually scaling" id="idm45322727051232"/>Another API resource that can be scaled manually is the StatefulSet. StatefulSets are meant for managing stateful applications by a set of Pods (e.g., databases). Similar to a Deployment, the StatefulSet defines a Pod template; however, each of its replicas guarantees a unique and persistent identity. Similar to a Deployment, a StatefulSet uses a ReplicaSet to manage the replicas.</p>

<p>We are not going to discuss StatefulSets in more detail, but you can read more about them in the <a href="https://oreil.ly/dXJhh">documentation</a>. The reason we are discussing the StatefulSet API resource here is that it can be manually scaled in a similar fashion as the Deployment.</p>

<p>Let’s say we’d deal with the YAML definition for a StatefulSet and a Service that run and expose a Redis database, as illustrated in <a data-type="xref" href="#yaml_manifest_statefulset_service">Example 3-2</a>.</p>
<div id="yaml_manifest_statefulset_service" data-type="example">
<h5><span class="label">Example 3-2. </span>A YAML manifest for a StatefulSet and Service</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">6379</code><code class="w"/>
<code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/>
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterIP</code><code class="w"/>
<code class="w">  </code><code class="nt">clusterIP</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">None</code><code class="w"/>
<code class="nn">---</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">StatefulSet</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"/>
<code class="w">  </code><code class="nt">serviceName</code><code class="p">:</code><code class="w"> </code><code class="s">"redis"</code><code class="w"/>
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis:6.2.5</code><code class="w"/>
<code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"redis-server"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"--appendonly"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"yes"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">6379</code><code class="w"/>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">web</code><code class="w"/>
<code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-vol</code><code class="w"/>
<code class="w">          </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/data</code><code class="w"/>
<code class="w">  </code><code class="nt">volumeClaimTemplates</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis-vol</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"ReadWriteOnce"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">      </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1Gi</code><code class="w"/></pre></div>

<p>After its creation, listing the StatefulSet shows the number of replicas in the “READY” column. As you can see in the following output, we set the number of replicas to 1:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f redis.yaml</strong>
service/redis created
statefulset.apps/redis created
<strong>$ kubectl get statefulset redis</strong>
NAME    READY   AGE
redis   1/1     2m10s
<strong>$ kubectl get pods</strong>
NAME      READY   STATUS    RESTARTS   AGE
redis-0   1/1     Running   0          2m</pre>

<p><a data-type="indexterm" data-primary="commands" data-secondary="scale" id="idm45322726974096"/><a data-type="indexterm" data-primary="scale command" id="idm45322726808656"/>The <code>scale</code> command we explored in the context of a Deployment works here as well. In the following command, we scale the number of replicas from one to three:</p>

<pre data-type="programlisting"><strong>$ kubectl scale statefulset redis --replicas=3</strong>
statefulset.apps/redis scaled
<strong>$ kubectl get statefulset redis</strong>
NAME    READY   AGE
redis   3/3     3m43s
<strong>$ kubectl get pods</strong>
NAME      READY   STATUS    RESTARTS   AGE
redis-0   1/1     Running   0          101m
redis-1   1/1     Running   0          97m
redis-2   1/1     Running   0          97m</pre>

<p>It’s important to mention that the process for scaling down a StatefulSet requires all replicas to be in a healthy state. Any long-term, unresolved issues in Pods controlled by a StatefulSet can lead to a situation that can result in the application becoming unavailable to end users.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Autoscaling a Deployment"><div class="sect2" id="idm45322727052512">
<h2>Autoscaling a Deployment</h2>

<p><a data-type="indexterm" data-primary="metrics server" id="idm45322726803792"/><a data-type="indexterm" data-primary="autoscaling Deployments" id="idm45322726803088"/><a data-type="indexterm" data-primary="Deployments" data-secondary="autoscaling" id="idm45322726802416"/><a data-type="indexterm" data-primary="HPA (Horizontal Pod Autoscaler)" data-secondary="about" id="idm45322726801472"/>Another way to scale a Deployment is with the help of a Horizontal Pod Autoscaler (HPA). The HPA is an API primitive that defines rules for automatically scaling the number of replicas under certain conditions. The only currently supported scaling condition in the stable API version of an HPA is CPU utilization. At runtime, the HPA checks the metrics collected by the <a href="https://oreil.ly/Lmamb">metrics server</a> to determine if the average maximum CPU usage across all replicas of a Deployment is less than or greater than the defined threshold. <a data-type="xref" href="#autoscaling_deployment">Figure 3-3</a> shows a high-level architecture diagram involving an HPA.</p>

<figure><div id="autoscaling_deployment" class="figure"><div class="border-box"><img src="Images/ckas_0303.png" alt="ckas 0303" width="1284" height="691"/></div><h6><span class="label">Figure 3-3. </span>Autoscaling a Deployment</h6></div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating Horizontal Pod Autoscalers"><div class="sect2" id="idm45322726796752">
<h2>Creating Horizontal Pod Autoscalers</h2>

<p><a data-type="indexterm" data-primary="HPA (Horizontal Pod Autoscaler)" data-secondary="creating" id="idm45322726795344"/>You can use the <code>autoscale deployment</code> command to create an HPA for an existing Deployment. The option <code>--cpu-percent</code> defines the average maximum CPU usage threshold. The options <code>--min</code> and <code>--max</code> provide the minimum number of replicas to scale down to and the maximum number of replicas the HPA can create to handle the increased load, respectively:</p>

<pre data-type="programlisting"><strong>$ kubectl autoscale deployment app-cache --cpu-percent=80 --min=3 --max=5</strong>
horizontalpodautoscaler.autoscaling/app-cache autoscaled</pre>

<p>The previous command is a great shortcut for creating an HPA for a Deployment. The YAML manifest representation of the HPA object looks like <a data-type="xref" href="#yaml_manifest_hpa">Example 3-3</a>.</p>
<div id="yaml_manifest_hpa" data-type="example" class="less_space pagebreak-before">
<h5><span class="label">Example 3-3. </span>A YAML manifest for an HPA</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">autoscaling/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">HorizontalPodAutoscaler</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">maxReplicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w"/>
<code class="w">  </code><code class="nt">minReplicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w"/>
<code class="w">  </code><code class="nt">scaleTargetRef</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="w">  </code><code class="nt">targetCPUUtilizationPercentage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre></div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Listing Horizontal Pod Autoscalers"><div class="sect2" id="idm45322726640512">
<h2>Listing Horizontal Pod Autoscalers</h2>

<p><a data-type="indexterm" data-primary="HPA (Horizontal Pod Autoscaler)" data-secondary="listing" id="idm45322726622864"/>The short-form command for a Horizontal Pod Autoscaler is <code>hpa</code>. Listing all of the HPA objects transparently describes their current state: the usage of CPU utilization and the number of replicas at this time:</p>

<pre data-type="programlisting"><strong>$ kubectl get hpa</strong>
NAME        REFERENCE              TARGETS         MINPODS   MAXPODS   REPLICAS \
  AGE
app-cache   Deployment/app-cache   &lt;unknown&gt;/80%   3         5         4        \
  58s</pre>

<p>If the Pod template of the Deployment does not define CPU resource requirements or if the CPU metrics cannot be retrieved from the metrics server, the left value of the column “TARGETS” says &lt;unknown&gt;. <a data-type="xref" href="#cpu_resource_requirements_pod_template">Example 3-4</a> sets the resource requirements for the Pod template so that the HPA can work properly.</p>
<div id="cpu_resource_requirements_pod_template" data-type="example">
<h5><span class="label">Example 3-4. </span>Setting CPU resource requirements for Pod template</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="c1"># ...</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="c1"># ...</code><code class="w"/>
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="c1"># ...</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memcached</code><code class="w"/>
<code class="w">        </code><code class="c1"># ...</code><code class="w"/>
<code class="w">        </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">250m</code><code class="w"/>
<code class="w">          </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500m</code><code class="w"/></pre></div>

<p>Once traffic hits the replicas, the current CPU usage is reflected in a percentage as shown in the following output. Here the average maximum CPU utilization is 15%:</p>

<pre data-type="programlisting"><strong>$ kubectl get hpa</strong>
NAME        REFERENCE              TARGETS   MINPODS   MAXPODS   REPLICAS   AGE
app-cache   Deployment/app-cache   15%/80%   3         5         4          58s</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Rendering Horizontal Pod Autoscaler Details"><div class="sect2" id="idm45322726552864">
<h2>Rendering Horizontal Pod Autoscaler Details</h2>

<p><a data-type="indexterm" data-primary="HPA (Horizontal Pod Autoscaler)" data-secondary="rendering details of" id="idm45322726551824"/>The event log of a HPA can provide additional insight into the rescaling activities. Rendering the HPA details can be a great tool for overseeing when the number of replicas was scaled up or down, as well as their scaling conditions:</p>

<pre data-type="programlisting"><strong>$ kubectl describe hpa app-cache</strong>
Name:                                                  app-cache
Namespace:                                             default
Labels:                                                &lt;none&gt;
Annotations:                                           &lt;none&gt;
CreationTimestamp:                                     Sun, 15 Aug 2021 \
                                                       15:54:11 -0600
Reference:                                             Deployment/app-cache
Metrics:                                               ( current / target )
  resource cpu on pods  (as a percentage of request):  0% (1m) / 80%
Min replicas:                                          3
Max replicas:                                          5
Deployment pods:                                       3 current / 3 desired
Conditions:
  Type            Status  Reason            Message
  ----            ------  ------            -------
  AbleToScale     True    ReadyForNewScale  recommended size matches current size
  ScalingActive   True    ValidMetricFound  the HPA was able to successfully \
  calculate a replica count from cpu resource utilization (percentage of request)
  ScalingLimited  True    TooFewReplicas    the desired replica count is less \
  than the minimum replica count
Events:
  Type    Reason             Age   From                       Message
  ----    ------             ----  ----                       -------
  Normal  SuccessfulRescale  13m   horizontal-pod-autoscaler  New size: 3; \
  reason: All metrics below target</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Using the Beta API Version of an Horizontal Pod Autoscaler"><div class="sect2" id="idm45322726548000">
<h2>Using the Beta API Version of an Horizontal Pod Autoscaler</h2>

<p><a data-type="indexterm" data-primary="HPA (Horizontal Pod Autoscaler)" data-secondary="using beta versions of" id="idm45322726546512"/>Kubernetes 1.12 introduced the beta API version <code>autoscaling/v2beta2</code> for a HPA, which became a final API named <code>autoscaling/v2</code> with Kubernetes 1.23. The YAML manifest of the API resource models observed metrics in a more generic way. As you can see in <a data-type="xref" href="#autoscaler_hpa">Example 3-5</a>, we are inspecting CPU and memory utilization to determine if the replicas of a Deployment need to be scaled up or down.</p>
<div id="autoscaler_hpa" data-type="example">
<h5><span class="label">Example 3-5. </span>A YAML manifest for a HPA using v2</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">autoscaling/v2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">HorizontalPodAutoscaler</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">scaleTargetRef</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app-cache</code><code class="w"/>
<code class="w">  </code><code class="nt">minReplicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w"/>
<code class="w">  </code><code class="nt">maxReplicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w"/>
<code class="w">  </code><code class="nt">metrics</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Resource</code><code class="w"/>
<code class="w">    </code><code class="nt">resource</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cpu</code><code class="w"/>
<code class="w">      </code><code class="nt">target</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Utilization</code><code class="w"/>
<code class="w">        </code><code class="nt">averageUtilization</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Resource</code><code class="w"/>
<code class="w">    </code><code class="nt">resource</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memory</code><code class="w"/>
<code class="w">      </code><code class="nt">target</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">AverageValue</code><code class="w"/>
<code class="w">        </code><code class="nt">averageValue</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500Mi</code><code class="w"/></pre></div>

<p>To ensure that the HPA determines the currently used resources, we’ll set the memory resource requirements for the Pod template as well, as shown in <a data-type="xref" href="#memory_resource_requirements_pod_template">Example 3-6</a>.</p>
<div id="memory_resource_requirements_pod_template" data-type="example">
<h5><span class="label">Example 3-6. </span>Setting memory resource requirements for Pod template</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="p">...</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/>
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p">...</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memcached</code><code class="w"/>
<code class="w">        </code><code class="p">...</code><code class="w"/>
<code class="w">        </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">250m</code><code class="w"/>
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">100Mi</code><code class="w"/>
<code class="w">          </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500m</code><code class="w"/>
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">500Mi</code><code class="w"/></pre></div>

<p class="pagebreak-before"><a data-type="indexterm" data-primary="" data-startref="sca_work" id="idm45322726273904"/><a data-type="indexterm" data-primary="" data-startref="work_sca" id="idm45322726243920"/>Listing the HPA renders both metrics in the “TARGETS” column, as in the output of the <code>get</code> command shown here:</p>

<pre data-type="programlisting"><strong>$ kubectl get hpa</strong>
NAME        REFERENCE              TARGETS                 MINPODS   MAXPODS \
  REPLICAS   AGE
app-cache   Deployment/app-cache   1994752/500Mi, 0%/80%   3         5       \
  3          2m14s</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Defining and Consuming Configuration Data"><div class="sect1" id="defining_consuming_configuration_data">
<h1>Defining and Consuming Configuration Data</h1>

<p><a data-type="indexterm" data-primary="configuration data, defining and consuming" id="cd_dc"/><a data-type="indexterm" data-primary="workloads" data-secondary="defining and consuming configuration data" id="work_dc"/>It’s common to encounter an application that evaluates environment variables to control its runtime behavior. For example, the application may define an environment variable that points to the URL of an external service, or it could inject an API key used to authenticate with another microservice.</p>

<p>Declaring environment variables for a container is easy. You simply list them as key-value pairs under the attribute <code>spec.containers[].env[]</code>. <a data-type="xref" href="#environment_variables_container">Example 3-7</a> defines the environment variables <code>MEMCACHED_CONNECTIONS</code> and <code>MEMCACHED_THREADS</code> for the container named <code>memcached</code>.</p>
<div id="environment_variables_container" data-type="example">
<h5><span class="label">Example 3-7. </span>Environment variables set for a container</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memcached</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memcached</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">memcached:1.6.8</code><code class="w"/>
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MEMCACHED_CONNECTIONS</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">"2048"</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MEMCACHED_THREADS</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">"150"</code><code class="w"/></pre></div>

<p>If those environment variables become a common commodity across multiple Pod manifests within the same namespace, there’s no way around copy-pasting the definition. For that particular use case, Kubernetes introduced the concept of configuration data represented by dedicated API resources.</p>

<p><a data-type="indexterm" data-primary="ConfigMap type" data-secondary="about" id="idm45322726191200"/><a data-type="indexterm" data-primary="Secret type" data-secondary="about" id="idm45322726122016"/>Those API resources are called ConfigMap and Secret. Both define a set of key-values pairs and can be injected into a container as environment variables or mounted as a volume. <a data-type="xref" href="#configuration_data">Figure 3-4</a> illustrates the options.</p>
<div data-type="tip"><h1>Values of a Secret are only encoded</h1>
<p>Secrets expect the value of each entry to be Base64-encoded. Base64 encodes only a value, but it doesn’t encrypt it. Therefore, anyone with access to its value can decode it without problems. A Secret is distributed only to the nodes running Pods that actually require access to it. Moreover, Secrets are stored in memory and are never written to physical storage.</p>
</div>

<figure><div id="configuration_data" class="figure"><div class="border-box"><img src="Images/ckas_0304.png" alt="ckas 0304" width="965" height="654"/></div><h6><span class="label">Figure 3-4. </span>Configuration data in Kubernetes</h6></div></figure>








<section data-type="sect2" data-pdf-bookmark="Creating a ConfigMap"><div class="sect2" id="idm45322726116528">
<h2>Creating a ConfigMap</h2>

<p><a data-type="indexterm" data-primary="ConfigMap type" data-secondary="creating" id="idm45322726115088"/><a data-type="indexterm" data-primary="create configmap command" id="idm45322726114112"/><a data-type="indexterm" data-primary="commands" data-secondary="create configmap" id="idm45322726113472"/>You can create a ConfigMap by emitting the imperative <code>create configmap</code> command. This command requires you to provide the source of the data as an option. Kubernetes distinguishes the four different options shown in <a data-type="xref" href="#source_options_configmap">Table 3-2</a>.</p>
<table id="source_options_configmap">
<caption><span class="label">Table 3-2. </span>Source options for data parsed by a ConfigMap</caption>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>--from-literal</code></p></td>
<td><p><code>--from-literal=locale=en_US</code></p></td>
<td><p>Literal values, which are key-value pairs as plain text</p></td>
</tr>
<tr>
<td><p><code>--from-env-file</code></p></td>
<td><p><code>--from-env-file=config.env</code></p></td>
<td><p>A file that contains key-value pairs and expects them to be environment variables</p></td>
</tr>
<tr>
<td><p><code>--from-file</code></p></td>
<td><p><code>--from-file=app-config.json</code></p></td>
<td><p>A file with arbitrary contents</p></td>
</tr>
<tr>
<td><p><code>--from-file</code></p></td>
<td><p><code>--from-file=config-dir</code></p></td>
<td><p>A directory with one or many files</p></td>
</tr>
</tbody>
</table>

<p>It’s easy to confuse the options <code>--from-env-file</code> and <code>--from-file</code>. The option <code>--from-env-file</code> expects a file that contains environment variables in the format <code>KEY=value</code> separated by a new line. The key-value pairs follow typical naming 
<span class="keep-together">conventions</span> for environment variables (e.g., the key is uppercased, and individual words are separated by an underscore character). Historically, this option has been used to process <a href="https://oreil.ly/Sd85f">Docker Compose <code>.env</code> file</a>, though you can use it for any other file containing environment variables. This option does not enforce or normalize the typical naming conventions for environment variables. The option <code>--from-file</code> points to a file or directory containing <em>any</em> arbitrary content. It’s an appropriate option for files with structured configuration data to be read by an application (e.g., a properties file, a JSON file, or an XML file).</p>

<p>The following command shows the creation of a ConfigMap in action. We are simply providing the key-value pairs as literals:</p>

<pre data-type="programlisting"><strong>$ kubectl create configmap db-config --from-literal=DB_HOST=mysql-service</strong> \
  <strong>--from-literal=DB_USER=backend</strong>
configmap/db-config created</pre>

<p>The resulting YAML object looks like the one shown in <a data-type="xref" href="#configmap_yaml_manifest">Example 3-8</a>. As you can see, the object defines the key-value pairs in a section named <code>data</code>. A ConfigMap does not have a <code>spec</code> section.</p>
<div id="configmap_yaml_manifest" data-type="example">
<h5><span class="label">Example 3-8. </span>ConfigMap YAML manifest</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-config</code><code class="w"/>
<code class="nt">data</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">DB_HOST</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-service</code><code class="w"/>
<code class="w">  </code><code class="nt">DB_USER</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/></pre></div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Consuming a ConfigMap as Environment Variables"><div class="sect2" id="idm45322726026736">
<h2>Consuming a ConfigMap as Environment Variables</h2>

<p><a data-type="indexterm" data-primary="ConfigMap type" data-secondary="consuming as environment variables" id="idm45322726059744"/><a data-type="indexterm" data-primary="environment variables" data-secondary="consuming ConfigMaps as" id="idm45322726049664"/>With the ConfigMap created, you can now inject its key-value pairs as environment variables into a container. <a data-type="xref" href="#injecting_configmap_environment_variables">Example 3-9</a> shows the use of <code>spec.containers[].envFrom[].configMapRef</code> to reference the ConfigMap by name.</p>
<div id="injecting_configmap_environment_variables" data-type="example">
<h5><span class="label">Example 3-9. </span>Injecting ConfigMap key-value pairs into the container</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/web-app:1.0.1</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="w">    </code><code class="nt">envFrom</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">configMapRef</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-config</code><code class="w"/></pre></div>

<p><a data-type="indexterm" data-primary="commands" data-secondary="env" id="idm45322726043008"/><a data-type="indexterm" data-primary="env command" id="idm45322725960784"/>After creating the Pod from the YAML manifest, you can inspect the environment variables available in the container by running the <code>env</code> Unix command:</p>

<pre data-type="programlisting"><strong>$ kubectl exec backend -- env</strong>
...
DB_HOST=mysql-service
DB_USER=backend
...</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Mounting a ConfigMap as a Volume"><div class="sect2" id="idm45322725958528">
<h2>Mounting a ConfigMap as a Volume</h2>

<p><a data-type="indexterm" data-primary="ConfigMap type" data-secondary="mounting as a volume" id="idm45322725957152"/><a data-type="indexterm" data-primary="mounting" data-secondary="ConfigMaps as volumes" id="idm45322725956176"/><a data-type="indexterm" data-primary="Volumes" data-secondary="mounting ConfigMaps as" id="idm45322725955232"/>Another way to configure applications at runtime is by processing a machine-readable configuration file. Say we have decided to store the database configuration in a JSON file named <code>db.json</code> with the structure shown in <a data-type="xref" href="#json_file_database_information">Example 3-10</a>.</p>
<div id="json_file_database_information" data-type="example">
<h5><span class="label">Example 3-10. </span>A JSON file used for configuring database information</h5>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"db"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">      </code><code class="nt">"host"</code><code class="p">:</code><code class="w"> </code><code class="s2">"mysql-service"</code><code class="p">,</code><code class="w"/>
<code class="w">      </code><code class="nt">"user"</code><code class="p">:</code><code class="w"> </code><code class="s2">"backend"</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre></div>

<p>Given that we are not dealing with literal key-value pairs, we need to provide the option <code>--from-file</code> when creating the ConfigMap object:</p>

<pre data-type="programlisting"><strong>$ kubectl create configmap db-config --from-file=db.json</strong>
configmap/db-config created</pre>

<p>The Pod mounts the ConfigMap as a volume to a specific path inside of the container. The assumption is that the application will read the configuration file when starting up. <a data-type="xref" href="#mounting_configmap_volume">Example 3-11</a> demonstrates the YAML definition.</p>
<div id="mounting_configmap_volume" data-type="example">
<h5><span class="label">Example 3-11. </span>Mounting a ConfigMap as a volume</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/web-app:1.0.1</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-config-volume</code><code class="w"/>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/config</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-config-volume</code><code class="w"/>
<code class="w">    </code><code class="nt">configMap</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-config</code><code class="w"/></pre></div>

<p>To verify the correct behavior, open an interactive shell to the container. As you can see in the following commands, the directory <code>/etc/config</code> contains a file with the key we used in the ConfigMap. The content represents the JSON configuration:</p>

<pre data-type="programlisting"><strong>$ kubectl exec -it backend -- /bin/sh</strong>
# ls -1 /etc/config
db.json
# cat /etc/config/db.json
{
    "db": {
      "host": "mysql-service",
      "user": "backend"
    }
}</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating a Secret"><div class="sect2" id="idm45322720774048">
<h2>Creating a Secret</h2>

<p><a data-type="indexterm" data-primary="Secret type" data-secondary="creating" id="idm45322720772512"/><a data-type="indexterm" data-primary="create secret command" id="idm45322720771536"/><a data-type="indexterm" data-primary="commands" data-secondary="create secret" id="idm45322720770864"/>You can create a Secret with the imperative command <code>create secret</code>. In addition, a mandatory subcommand needs to be provided that determines the type of the Secret. <a data-type="xref" href="#options_creating_secret">Table 3-3</a> lists the different types.</p>
<table id="options_creating_secret">
<caption><span class="label">Table 3-3. </span>Options for creating a Secret</caption>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>generic</code></p></td>
<td><p>Creates a secret from a file, directory, or literal value.</p></td>
</tr>
<tr>
<td><p><code>docker-registry</code></p></td>
<td><p>Creates a secret for use with a Docker registry.</p></td>
</tr>
<tr>
<td><p><code>tls</code></p></td>
<td><p>Creates a TLS secret.</p></td>
</tr>
</tbody>
</table>

<p>The most commonly used Secret type is <code>generic</code>. The options for a generic Secret are exactly the same as for a ConfigMap, as shown in <a data-type="xref" href="#source_options_data_secret">Table 3-4</a>.</p>
<table id="source_options_data_secret">
<caption><span class="label">Table 3-4. </span>Source options for data parsed by a Secret</caption>
<thead>
<tr>
<th>Option</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>--from-literal</code></p></td>
<td><p><code>--from-literal=password=secret</code></p></td>
<td><p>Literal values, which are key-value pairs as plain text</p></td>
</tr>
<tr>
<td><p><code>--from-env-file</code></p></td>
<td><p><code>--from-env-file=config.env</code></p></td>
<td><p>A file that contains key-value pairs and expects them to be environment variables</p></td>
</tr>
<tr>
<td><p><code>--from-file</code></p></td>
<td><p><code>--from-file=id_rsa=~/.ssh/id_rsa</code></p></td>
<td><p>A file with arbitrary contents</p></td>
</tr>
<tr>
<td><p><code>--from-file</code></p></td>
<td><p><code>--from-file=config-dir</code></p></td>
<td><p>A directory with one or many files</p></td>
</tr>
</tbody>
</table>

<p>To demonstrate the functionality, let’s create a Secret of type <code>generic</code>. The command sources the key-value pairs from the literals provided as a command-line option:</p>

<pre data-type="programlisting"><strong>$ kubectl create secret generic db-creds --from-literal=pwd=s3cre!</strong>
secret/db-creds created</pre>

<p>When created using the imperative command, a Secret will automatically Base64-encode the provided value. This can be observed by taking a look at the produced YAML manifest. You can see in <a data-type="xref" href="#secret_base64_encoded_values">Example 3-12</a> that the value <code>s3cre!</code> has been turned into <code>czNjcmUh</code>, the Base64-encoded equivalent.</p>
<div id="secret_base64_encoded_values" data-type="example">
<h5><span class="label">Example 3-12. </span>A Secret with Base64-encoded values</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-creds</code><code class="w"/>
<code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Opaque</code><code class="w"/>
<code class="nt">data</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">pwd</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">czNjcmUh</code><code class="w"/></pre></div>

<p>If you start with the YAML manifest to create the Secret object, you will need to create the Base64-encoded value yourself. A Unix tool that does the job is <code>base64</code>. The following command achieves exactly that:</p>
<pre data-type="programlisting">
<strong>$ echo -n 's3cre!' | base64</strong>
czNjcmUh
</pre>

<p>Alternatively, you can also use one of the specialized <a href="https://oreil.ly/e1Cfz">Secret types</a> to avoid having to provide a Base64-encoded value. The type <code>kubernetes.io/basic-auth</code> is meant for basic authentication and expects the keys <code>username</code> and <code>password</code>. The created object from this definition automatically Base64-encodes the values for both keys. <a data-type="xref" href="#secret_type_basic_auth">Example 3-13</a> illustrates a YAML manifest for a Secret with type <code>kubernetes.io/basic-auth</code>. Notice that the attribute defining the key-value pairs is called <code>stringData</code> instead of <code>data</code> as used by the <code>Opaque</code> Secret type.</p>
<div id="secret_type_basic_auth" data-type="example">
<h5><span class="label">Example 3-13. </span>Usage of the Secret type kubernetes.io/basic-auth</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secret-basic-auth</code><code class="w"/>
<code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubernetes.io/basic-auth</code><code class="w"/>
<code class="nt">stringData</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">username</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko</code><code class="w"/>
<code class="w">  </code><code class="nt">password</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secret</code><code class="w"/></pre></div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Consuming a Secret as Environment Variables"><div class="sect2" id="idm45322720773456">
<h2>Consuming a Secret as Environment Variables</h2>

<p><a data-type="indexterm" data-primary="environment variables" data-secondary="consuming Secrets as" id="idm45322720650768"/><a data-type="indexterm" data-primary="Secret type" data-secondary="consuming as environment variables" id="idm45322720649856"/>Consuming a Secret as environment variable works similar to the way you’d do it for ConfigMaps. Here, you’d use the YAML expression <code>spec.containers[].envFrom[].secretRef</code> to reference the name of the Secret. <a data-type="xref" href="#injecting_secret_container">Example 3-14</a> injects the Secret named <code>secret-basic-auth</code> as environment variables into the container named <code>backend</code>.</p>
<div id="injecting_secret_container" data-type="example">
<h5><span class="label">Example 3-14. </span>Injecting Secret key-value pairs into the container</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/web-app:1.0.1</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="w">    </code><code class="nt">envFrom</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">secretRef</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secret-basic-auth</code><code class="w"/></pre></div>

<p>Inspecting the environment variables in the container reveals that the Secret values do not have to be decoded. That’s something Kubernetes does automatically. Therefore, the running application doesn’t need to implement custom logic to decode the value. Note that Kubernetes does not verify nor normalize the typical naming conventions of environment variables, as you can see in the following output:</p>

<pre data-type="programlisting"><strong>$ kubectl exec backend -- env</strong>
...
username: bmuschko
password: secret
...</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Mounting a Secret as a Volume"><div class="sect2" id="idm45322720503408">
<h2>Mounting a Secret as a Volume</h2>

<p><a data-type="indexterm" data-primary="mounting" data-secondary="Secrets as volumes" id="idm45322720535040"/><a data-type="indexterm" data-primary="Secret type" data-secondary="mounting as volumes" id="idm45322720533840"/><a data-type="indexterm" data-primary="Volumes" data-secondary="mounting Secrets as" id="idm45322720532896"/>To demonstrate mounting a Secret as a volume, we’ll create a new Secret of type <code>kubernetes.io/ssh-auth</code>. This Secret type captures the value of an SSH private key that you can view using the command <code>cat ~/.ssh/id_rsa</code>. To process the SSH private key file with the <code>create secret</code> command, it needs to be available as a file with the name <code>ssh-privatekey</code>:</p>

<pre data-type="programlisting"><strong>$ cp ~/.ssh/id_rsa ssh-privatekey</strong>
<strong>$ kubectl create secret generic secret-ssh-auth --from-file=ssh-privatekey</strong> \
  <strong>--type=kubernetes.io/ssh-auth</strong>
secret/secret-ssh-auth created</pre>

<p>Mounting the Secret as a volume follows the two-step approach:  define the volume first and then reference it as a mount path for one or many containers. The volume type is called <code>secret</code> as used in <a data-type="xref" href="#mounting_secret_volume">Example 3-15</a>.</p>
<div id="mounting_secret_volume" data-type="example">
<h5><span class="label">Example 3-15. </span>Mounting a Secret as a volume</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/web-app:1.0.1</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">backend</code><code class="w"/>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ssh-volume</code><code class="w"/>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/app</code><code class="w"/>
<code class="w">      </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ssh-volume</code><code class="w"/>
<code class="w">    </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secret-ssh-auth</code><code class="w"/></pre></div>

<p><a data-type="indexterm" data-primary="" data-startref="ed_dc" id="idm45322720448960"/><a data-type="indexterm" data-primary="" data-startref="work_dc" id="idm45322720448112"/>You will find the file named <code>ssh-privatekey</code> in the mount path <code>/var/app</code>. To verify, open an interactive shell and render the file contents. The contents of the file are not Base64-encoded:</p>

<pre data-type="programlisting"><strong>$ kubectl exec -it backend -- /bin/sh</strong>
# ls -1 /var/app
ssh-privatekey
# cat /var/app/ssh-privatekey
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,8734C9153079F2E8497C8075289EBBF1
...
-----END RSA PRIVATE KEY-----</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45322726240496">
<h1>Summary</h1>

<p><a data-type="indexterm" data-primary="workloads" data-secondary="about" id="idm45322720410176"/>The workload portion covered by the CKA includes the API resources Deployment, ReplicaSet, and Pod. A Deployment controls a ReplicaSet responsible for managing multiple, identical Pods, so-called replicas. The number of replicas can be scaled up or down using the Deployment manually or automatically with the help of a Horizontal Pod Autoscaler. Any changes made to the replica template defined by the Deployment will be rolled out to the replicas. As an end user, you can inspect the rollout history, the current rollout status, and its progress.</p>

<p>Application runtime behavior can be controlled either by injecting configuration data as environment variables or by mounting a volume to a path. In Kubernetes, this configuration data is represented by the API resources ConfigMap and Secret in the form of key-value pairs. A ConfigMap is meant for plain-text data, and a Secret encodes the values in Base64 to obfuscate the values. Secrets are usually a better fit for sensitive information like credentials and SSH private keys.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Exam Essentials"><div class="sect1" id="idm45322720408432">
<h1>Exam Essentials</h1>
<dl>
<dt><a data-type="indexterm" data-primary="workloads" data-secondary="exam essentials" id="idm45322720406912"/><a data-type="indexterm" data-primary="exam essentials" data-secondary="workloads" id="idm45322720405936"/>Know how to scale a Deployment and roll out updates</dt>
<dd>
<p>Deployments have superior management capabilities for a set of Pods. Using them should be preferred over creating, updating, and deleting individual Pods. You need to be familiar with all aspects of a Deployment, which includes manually scaling the number of replicas or autoscaling them with the help of a Horizontal Pod Autoscaler. The rollout history keeps track of the revisions made to a Pod template. You can roll out new revisions or roll back to a previous revision. Practice those techniques and the effect it has on the replicas.</p>
</dd>
<dt>Practice the creation and usage of ConfigMaps and Secrets</dt>
<dd>
<p>Configuration data can be injected into a Pod using a ConfigMap or a Secret. Practice the creation of those objects using the imperative and declarative approach by providing different data sources (e.g., literal values, files, and directories). Secrets offer specialized types. Try the different ways those can be set up. You need to be proficient with the different ways of injecting the data defined by ConfigMaps and Secrets into a container.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Sample Exercises"><div class="sect1" id="idm45322720402368">
<h1>Sample Exercises</h1>

<p><a data-type="indexterm" data-primary="sample exercises" data-secondary="workloads" id="idm45322720366144"/><a data-type="indexterm" data-primary="workloads" data-secondary="sample exercises" id="idm45322720365296"/><a data-type="indexterm" data-primary="" data-startref="work_ch" id="idm45322720364448"/>Solutions to these exercises are available in the <a data-type="xref" href="app01.xhtml#appendix-a">Appendix</a>.</p>
<ol>
<li>
<p>Create a Deployment named <code>nginx</code> that uses the image <code>nginx:1.17.0</code>. Set two replicas to begin with.</p>
</li>
<li>
<p>Scale the Deployment to seven replicas using the <code>scale</code> command. Ensure that the correct number of Pods exist.</p>
</li>
<li>
<p>Create a Horizontal Pod Autoscaler named <code>nginx-hpa</code> for the Deployment with an average utilization of CPU to 65% and an average utilization of memory to 1Gi. Set the minimum number of replicas to 3 and the maximum number of replicas to 20.</p>
</li>
<li>
<p>Update the Pod template of the Deployment to use the image <code>nginx:1.21.1</code>. Make sure that the changes are recorded. Inspect the revision history. How many revisions should be rendered? Roll back to the first revision.</p>
</li>
<li>
<p>Create a new Secret named <code>basic-auth</code> of type <code>kubernetes.io/basic-auth</code>. Assign the key-value pairs <code>username=super</code> and <code>password=my-s8cr3t</code>. Mount the Secret as a volume with the path <code>/etc/secret</code> and read-only permissions to the Pods controlled by the Deployment.</p>
</li>

</ol>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45322720353328">
<h5>Interactive Exam Practice</h5>
<p>Get more hands-on training and test your CKA exam readiness by working through our interactive CKA labs. Each step of the lab must be completed correctly before you can move to the next step. If you get stuck, you can view the solution and learn how to complete the step.</p>

<p>The following labs cover material from this chapter:</p>

<ul>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095545">Creating and Manually Scaling a Deployment</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095552">Creating a Horizontal Pod Autoscaler</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095569">Rolling Out a New Revision for a Deployment</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095583">Creating a ConfigMap from Literal Values</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095590">Creating a Secret of Type kubernetes.io/basic-auth</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095606">Creating a Secret from SSH Private Key</a></p>
</li>
</ul>
</div></aside>
</div></section>







</div></section></div></body></html>