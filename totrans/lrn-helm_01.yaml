- en: Chapter 1\. Introducing Helm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章。介绍 Helm
- en: Helm is the package manager for Kubernetes. That is the way the Helm developers
    have described Helm since the very first commits to the Git repository. And that
    sentence is the topic of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是 Kubernetes 的包管理器。这是 Helm 开发者自 Git 仓库的第一次提交以来就一直在描述的方式。而这句话也是本章的主题。
- en: In this chapter, we will start with a conceptual look at the cloud native ecosystem,
    in which Kubernetes is a key technology. We will take a fresh look at what Kubernetes
    has to offer to set the stage for describing Helm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从概念上看云原生生态系统，其中 Kubernetes 是一个关键技术。我们将重新审视 Kubernetes 提供的功能，为描述 Helm
    做好准备。
- en: Next, we will look at the problems Helm sets out to solve. In this section,
    we will look at the concept of package management and why we have modeled Helm
    this way. We will also visit some of the unique facets of installing packages
    into a cluster management tool like Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 Helm 旨在解决的问题。在本节中，我们将看看包管理的概念以及为什么我们模仿 Helm 的方式进行建模。我们还将探讨将软件包安装到像
    Kubernetes 这样的集群管理工具中的一些独特方面。
- en: Finally, we will finish the chapter with a high-level look at Helm’s architecture,
    focusing on the concepts of charts, templates, and releases. By the end of the
    chapter, you will understand how Helm fits into the broader ecosystem of tools,
    and you will be familiar with the terminology and concepts we will be using throughout
    this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过高层次的方式来看 Helm 的架构，重点介绍图表、模板和发布的概念。通过本章的学习，你将理解 Helm 如何融入到更广泛的工具生态系统中，你将熟悉本书中将要使用的术语和概念。
- en: The Cloud Native Ecosystem
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生生态系统
- en: The emergence of cloud technologies has clearly changed the way the industry
    looks at hardware, system management, physical networking, and so on. Virtual
    machines replaced physical servers, storage services displaced talk of hard drives,
    and automation tools rose in prominence. This was perhaps an early change in the
    way the industry conceptualized the cloud. But as the strengths and weaknesses
    of this new approach became clearer, the practices of designing applications and
    services also began to shift.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 云技术的出现显然改变了行业对硬件、系统管理、物理网络等的看法。虚拟机取代了物理服务器，存储服务取代了硬盘的讨论，自动化工具日益突出。这或许是行业在概念化云时的早期变化。但随着这种新方法的优劣逐渐清晰，设计应用程序和服务的实践也开始转变。
- en: Developers and operators began to question the practice of building large single-binary
    applications that executed on beefy hardware. They recognized the difficulty of
    sharing data across different applications while retaining data integrity. Distributed
    locking, storage, and caching became mainstream problems instead of points of
    academic interest. Large software packages were broken down into smaller discrete
    executables. And, as Kubernetes founder Brendan Burns often puts it, “distributed
    computing went from an advanced topic to Computer Science 101.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者和运维人员开始质疑构建大型单一二进制应用程序的实践，这些应用程序在强大的硬件上执行。他们意识到在不同应用程序之间共享数据并保持数据完整性的困难。分布式锁定、存储和缓存成为主流问题，而不是学术兴趣点。大型软件包被分解为更小的离散可执行文件。正如
    Kubernetes 的创始人 Brendan Burns 经常所说，“分布式计算从高级话题变成了计算机科学 101。”
- en: The term *cloud native* captures this cognitive shift in what one might call
    our *architectural view* of the cloud. When we design our systems around the capabilities
    and constraints of the cloud, we are designing cloud native systems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “云原生”这一术语捕捉到了我们对云架构视角的这种认知转变。当我们围绕云的能力和约束设计我们的系统时，我们正在设计云原生系统。
- en: Containers and Microservices
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和微服务
- en: At the very heart of cloud native computing is this philosophical perspective
    that *smaller discrete standalone services* are preferable to *large monolithic
    services* that do everything. Instead of writing a single large application that
    handles everything from generating the user interface to processing task queues
    to interacting with databases and caches, the cloud native approach is to write
    a series of smaller services, each relatively special purpose, and then join these
    services together to serve a higher-level purpose. In such a model, one service
    might be the sole user of a relational database. Services that wish to access
    the data will contact that service over (typically) a representational state transfer
    (REST) API. And, using JavaScript Object Notation (JSON) over HTTP, these other
    services will query and update data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生计算的核心理念是：*更倾向于小型独立的单一服务*，而不是做一切的*大型单体服务*。不再编写一个处理从生成用户界面到处理任务队列再到与数据库和缓存交互的单一大型应用程序。云原生的方法是编写一系列较小、相对特定目的的服务，然后将这些服务组合在一起以实现更高层次的目的。在这种模型中，一个服务可能是关系数据库的唯一用户。希望访问数据的服务将通过（通常是）表述状态转移（REST）API联系该服务。然后，这些其他服务将使用基于JavaScript对象表示法（JSON）的HTTP查询和更新数据。
- en: This breakdown allows developers to hide the low-level implementation and instead
    offer a set of features specific to the business logic of the broader application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分解允许开发人员隐藏低级实现，而是提供一组特定于更广泛应用程序业务逻辑的功能。
- en: Microservices
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务
- en: Where once an application consisted of a single executable that did all of the
    work, cloud native applications are *distributed applications*. While separate
    programs each take responsibility for one or two discrete tasks, together these
    programs all form a single logical application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，一个应用程序由一个执行所有工作的单个可执行程序组成，云原生应用程序是*分布式应用程序*。虽然单独的程序分别负责一个或两个离散任务，但这些程序共同形成一个单一的逻辑应用程序。
- en: With all this theory, a simple example may better explain how this works. Imagine
    an ecommerce website. We can think of several tasks that jointly comprise this
    sort of website. There is a product catalog, user accounts and shopping carts,
    a payment processor that handles the security-sensitive process of monetary transactions,
    and a frontend through which customers view items and select their purchases.
    There is also an administrative interface where the store owners manage inventory
    and fulfill orders.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些理论，一个简单的例子可能更好地解释这是如何工作的。想象一个电子商务网站。我们可以认为一起组成这种网站的几个任务。有产品目录，用户账户和购物车，处理货币交易安全过程的支付处理器，以及顾客查看商品并选择购买的前端。还有一个管理界面，店主在其中管理库存和完成订单。
- en: Historically, applications like this were once built as one single program.
    The code responsible for each of these units of work was all compiled together
    into one large executable, which was then often run on a single large piece of
    hardware.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，这样的应用程序曾经被构建为一个单一的程序。负责每个工作单元的代码都被编译到一个大型可执行文件中，然后通常在单个大型硬件上运行。
- en: The cloud native approach to such an application, though, is to break this ecommerce
    application into multiple pieces. One handles payment transactions. Another tracks
    the product catalog. Yet another provides the administrative, and so on. These
    services then communicate with each other over the network using well-defined
    REST APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，云原生方法是将这个电子商务应用程序分解为多个部分。一个处理支付交易。另一个跟踪产品目录。再一个提供管理界面，等等。然后，这些服务通过网络使用明确定义的REST
    API彼此通信。
- en: Taken to an extreme, an application is broken down into its smallest constituent
    parts, and each part is a program. This is the *microservice architecture*. Standing
    at the opposite end of the spectrum of a monolithic application, a microservice
    is responsible for handling only one small part of the overall application’s processing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分解为最小的组成部分，并且每个部分都是一个程序，这是*微服务架构*的极端情况。微服务站在单体应用程序的相反极端，负责处理整体应用程序处理的一个小部分。
- en: The microservice concept has had an outsized influence on the evolution of cloud
    native computing. And nowhere is this more evident than in the emergence of *container
    computing*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务概念对云原生计算的演变产生了巨大影响。在*容器计算*的出现中，这一点表现得尤为明显。
- en: Containers
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: It is common to compare and contrast a container and a virtual machine. A virtual
    machine runs an entire operating system in an isolated environment on a host machine.
    A container, in contrast, has its own filesystem, but is executed in the same
    operating system kernel as the host.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器与虚拟机进行比较和对比是很常见的。虚拟机在主机机器上的隔离环境中运行整个操作系统。相比之下，容器有自己的文件系统，但在主机的操作系统内核中执行。
- en: But there is a second way of conceptualizing the container—one that may prove
    more beneficial for the present discussion. As its name suggests, a *container*
    provides a useful way of packaging up the runtime environment for a single program
    so that the executable is guaranteed to have all of its dependencies satisfied
    when it is moved from one host to another.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一种第二种概念化容器的方式——这种方式可能对当前的讨论更有益。正如其名称所示，*容器*提供了一种有用的方式，可以将单个程序的运行时环境打包起来，以便在将其从一个主机移动到另一个主机时，可以保证可执行文件的所有依赖项都得到满足。
- en: This is a more philosophical approach, perhaps, because it imposes some non-technical
    restrictions on a container. For example, one could package a dozen different
    programs in a single container and execute them all at the same time. But containers,
    at least as they were designed by Docker, were intended as a vehicle for one top-level
    program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更为哲学的方法，也许是因为它对容器施加了一些非技术性的限制。例如，一个容器可以打包十几个不同的程序，并同时执行它们。但是容器，至少按照Docker的设计初衷，是作为一个顶层程序的载体。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When we talk about programs here, we’re really thinking at a higher level of
    abstraction than “a binary.” Most Docker containers have at least a few executables
    that are there merely to assist the main program. But these executables are auxiliary
    to the primary function of the container. For example, a web server may require
    a few other local utilities for starting up or performing low-level tasks (Apache,
    for example, has tools for modules), but it is the web server itself that is the
    primary program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这里讨论程序时，我们实际上在思考比“一个二进制文件”更高层次的抽象。大多数Docker容器至少有几个可执行文件，它们只是为了辅助主程序存在。但这些可执行文件是辅助于容器的主要功能的。例如，一个Web服务器可能需要一些其他本地实用工具来启动或执行低级任务（例如Apache有模块工具），但主要程序还是Web服务器本身。
- en: Containers and microservices are, by design, a perfect match. Small discrete
    programs can be packaged, along with all their dependencies, into svelte containers.
    And those containers can be moved around from host to host. When executing a container,
    the host need not have all the tools required to execute the program because all
    of those tools are packaged within the container. The host merely must have the
    ability to run containers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和微服务从设计上来说是完美匹配的。小型独立程序可以打包，以及它们所有的依赖项，进入修长的容器中。并且这些容器可以从一个主机移动到另一个主机。在执行容器时，主机无需拥有执行程序所需的所有工具，因为所有这些工具都打包在容器内。主机只需要能够运行容器。
- en: For example, if a program is built in Python 3, the host does not need to install
    Python, configure it, and then install all the libraries that the program requires.
    All of that is packaged in the container. When the host executes the container,
    the correct version of Python 3 and each required library is already stored in
    the container.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个程序是在Python 3中构建的，主机不需要安装Python，配置它，然后安装程序所需的所有库。所有这些都打包在容器中。当主机执行容器时，正确版本的Python
    3和每个所需的库已经存储在容器中。
- en: Taking this one step further, a host can freely execute containers with competing
    requirements. A containerized Python 2 program can run in the same host as a containerized
    Python 3 requirement, and the host’s administrators need not do any special work
    to configure these competing requirements!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步说，主机可以自由地执行具有竞争需求的容器。一个容器化的Python 2程序可以在与容器化的Python 3需求相同的主机上运行，主机管理员无需进行任何特殊工作来配置这些竞争需求！
- en: 'These examples illustrate one of the features of the cloud native ecosystem:
    administrators, operators, and site reliability engineers (SREs) are no longer
    in the business of managing program dependencies. Instead, they are free to focus
    on a higher level of resource allocation. Rather than fretting over which versions
    of Python, Ruby, and Node are running on different servers, operators can focus
    on whether network, storage, and CPU resources are correctly allocated for these
    containerized workloads.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子说明了云原生生态系统的一个特性：管理员、运维人员和可靠性工程师（SREs）不再负责管理程序依赖关系。相反，他们可以自由地专注于更高级别的资源分配。运维人员不再为不同服务器上运行的Python、Ruby和Node的版本而烦恼，而是可以专注于网络、存储和CPU资源是否正确分配给这些容器化工作负载。
- en: Running a program in complete isolation is sometimes useful. But more often,
    we want to expose some aspects of this container to the outside world. We want
    to give it access to storage. We want to allow it to answer network connections.
    And we want to inject tidbits of configuration into the container based on our
    present needs. All of these tasks (and more still) are provided by the container
    runtime. When a container declares that it has a service that is internally listening
    on port 8080, the container runtime may grant it access on the host port 8000\.
    Thus, when the host gets a network request on port 8000, the container sees this
    as a request on its port 8080\. Likewise, a host can mount a filesystem into the
    container, or set specific environment variables inside of the container. In this
    way, a container can participate in the broader environment around it—including
    not just other containers on that host, but remote services on the local network
    or even the internet.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在完全隔离的环境中运行程序是有用的。但更常见的情况是，我们希望将容器的某些方面暴露给外部世界。我们希望它可以访问存储。我们希望允许它响应网络连接。我们希望根据我们目前的需求向容器中注入一些配置小贴士。所有这些任务（还有更多任务）由容器运行时提供。当容器声明其具有一个在端口8080上内部侦听的服务时，容器运行时可能会在主机端口8000上授予其访问权限。因此，当主机在端口8000上收到网络请求时，容器将其视为对其端口8080的请求。同样，主机可以将文件系统挂载到容器中，或在容器内设置特定的环境变量。通过这种方式，容器可以参与其周围更广泛的环境——包括不仅限于同一主机上的其他容器，还包括本地网络甚至互联网上的远程服务。
- en: Container images and registries
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器镜像和注册表
- en: Container technology is a sophisticated and fascinating space in its own right.
    But for our purposes, we only need to understand a few more things about how containers
    work before be can proceed to the next layer of the cloud native stack.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术本身就是一个复杂而引人入胜的领域。但就我们的目的而言，在我们继续到云原生堆栈的下一层之前，我们只需要理解一些关于容器如何工作的更多信息。
- en: As we discussed in the previous section, a container is a program together with
    its dependencies and environment. This whole thing can be packaged together into
    a portable representation called a *container image* (often just referred to as
    an *image*). Images are not packaged into one large binary; instead, they are
    packaged into discrete *layers*, each of which has its own unique identifier.
    When images are moved around, they are moved as a collection of layers, which
    provides a huge advantage. If one host has an image with five layers and another
    host needs the same image, it only needs to fetch the layers that it doesn’t already
    have. So if it has two of the five layers already, it only needs to fetch three
    layers to rebuild the entire container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的那样，容器是一个程序及其依赖项和环境的整体。这整个内容可以打包成一个称为*容器镜像*（通常简称为*镜像*）的可移植表示。镜像不是打包成一个大型二进制文件；而是打包成离散的*层*，每个层都有其自己的唯一标识符。当镜像被移动时，它们作为一组层移动，这提供了巨大的优势。如果一个主机有一个包含五层的镜像，而另一个主机需要相同的镜像，它只需获取它尚未具备的层。因此，如果它已经有了五层中的两层，它只需获取三层即可重建整个容器。
- en: There is a crucial piece of technology that provides the ability to move container
    images around. An *image registry* is a specialized piece of storage technology
    that houses containers, making them available for hosts. A host can *push* a container
    image to a registry, which transfers the layers to the registry. And then another
    host can *pull* the image from the registry to the host’s environment, after which
    the host can execute the container.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关键的技术组件提供了移动容器镜像的能力。*镜像注册表*是一种专门的存储技术，用于存储容器，使它们对主机可用。主机可以将容器镜像*推送*到注册表，将层传输到注册表。然后另一个主机可以从注册表*拉取*镜像到主机的环境中，之后主机可以执行容器。
- en: The registry manages the layers. When one host requests an image, the registry
    lets the host know which layers compose that image. The host can then determine
    which layers (if any) are missing and subsequently download just those layers
    from the registry.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表管理这些层。当一个主机请求一个镜像时，注册表会告诉主机组成该镜像的哪些层。然后主机可以确定缺少的层（如果有的话），并从注册表中仅下载那些层。
- en: 'A registry uses up to three pieces of information to identify a particular
    image:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表使用最多三个信息来标识特定的镜像：
- en: Name
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: 'An image *name* can range from simple to complex, depending on the registry
    that stores the image: `nginx`, `servers/nginx`, or `example.com/servers/nginx`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个镜像的*名称*可以是简单的也可以是复杂的，这取决于存储镜像的注册表：`nginx`，`servers/nginx`，或者 `example.com/servers/nginx`。
- en: Tag
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 标签
- en: The *tag* typically refers to the version of the software installed (`v1.2.3`),
    though tags are really just arbitrary strings. The tags `latest` and `stable`
    are often used to indicate “the most recent version” and “the most recent production-ready
    version,” respectively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签*通常指安装的软件版本（`v1.2.3`），尽管标签实际上只是任意的字符串。标签 `latest` 和 `stable` 通常用于表示“最新版本”和“最新的生产就绪版本”，分别。'
- en: Digest
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: Sometimes it is important to pull a very specific version of an image. Since
    tags are *mutable*, there is no guarantee that at any given time a tag refers
    to *exactly* a specific version of the software. So registries support fetching
    images by *digest*, which is a SHA-256 or SHA-512 digest of the image’s layer
    information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候拉取一个非常特定版本的镜像很重要。由于标签是*可变的*，不能保证在任何给定时间标签指向*确切*的软件版本。因此，注册表支持通过*摘要*来获取镜像，这是镜像层信息的
    SHA-256 或 SHA-512 摘要。
- en: Throughout this book, we will see images referenced using the three preceding
    pieces of information. The canonical format for combining these is `name:tag@digest`,
    where only `name` is required. Thus, `example.com/servers/nginx:latest` says “give
    me the tag `latest` for the image named `example.com/servers/nginx`.” And
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将看到使用前述三个信息引用的镜像。组合这些信息的规范格式是 `name:tag@digest`，其中只有 `name` 是必需的。因此，`example.com/servers/nginx:latest`
    表示“给我命名为 `example.com/servers/nginx` 的镜像的标签 `latest`。”以及
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: says “give me `example.com/my/app` with the exact digest given here.”
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉“给我`example.com/my/app`，并提供此处的确切摘要。”
- en: 'While there is plenty more to learn about images and containers, we have enough
    knowledge now to move on to the next important topic: schedulers. And in that
    section, we’ll discover Kubernetes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于镜像和容器还有很多要学习的内容，但我们现在已经有足够的知识来继续下一个重要的主题：调度器。在那一部分，我们将了解 Kubernetes。
- en: Schedules and Kubernetes
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划和 Kubernetes
- en: In the previous section we saw how containers encapsulate individual programs
    and their required environment. Containers can be executed locally on workstations
    or remotely on servers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到容器封装了单独的程序及其所需的环境。容器可以在工作站上本地执行，也可以在服务器上远程执行。
- en: As developers began packaging their applications into containers and operators
    began using containers as an artifact for deployment, a new set of questions emerged.
    How do we best execute lots of containers? How do we best facilitate a microservice
    architecture where lots of containers need to work together? How do we judiciously
    share access to things like network attached storage, load balancers, and gateways?
    How do we manage injecting configuration information into lots of containers?
    And perhaps most importantly, how do we manage resources like memory, CPU, network
    bandwidth, and storage space?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发人员开始将他们的应用程序打包成容器，并且操作人员开始使用容器作为部署的工件，出现了一系列新的问题。我们如何最好地执行大量容器？我们如何最好地支持需要共同工作的大量容器的微服务架构？我们如何明智地共享对像网络附加存储、负载均衡器和网关等的访问？我们如何管理向大量容器注入配置信息？也许最重要的是，我们如何管理内存、CPU、网络带宽和存储空间等资源？
- en: Moving even one level beyond, people began asking (based on their experiences
    with virtual machines) how one might manage distributing containers across multiple
    hosts, spreading the load equitably while still judiciously using resources? Or,
    more simply, how do we run the fewest possible hosts while running as many containers
    as we need?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，人们开始询问（基于他们对虚拟机的经验），如何在多个主机上管理分布式容器，如何在保证资源的合理使用的同时均匀分布负载？或者更简单地说，我们如何在运行尽可能少的主机的同时运行我们需要的尽可能多的容器？
- en: 'In 2015, the time was right: Docker containers were making inroads into the
    enterprise. And there was a clear need for a tool that could manage container
    scheduling and resource management across hosts. Multiple technologies landed
    on the scene: Mesos introduced Marathon; Docker created Swarm; Hashicorp released
    Nomad; and Google created an open source sibling to its internal Borg platform,
    and named this technology Kubernetes (the Greek word for a ship’s captain).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年，时机成熟：Docker 容器正在企业中取得进展。并且有一个明显的需求，即需要一种工具来管理跨主机的容器调度和资源管理。多种技术进入市场：Mesos
    推出了 Marathon；Docker 创建了 Swarm；Hashicorp 发布了 Nomad；Google 则为其内部 Borg 平台创建了一个开源版本，并将此技术命名为
    Kubernetes（希腊语中船长的意思）。
- en: All of these projects were providing an implementation of a clustered container
    management system that could schedule containers and wire them up for hosting
    sophisticated microservice-like distributed applications.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些项目都提供了一个集群化容器管理系统的实现，可以调度容器并为托管复杂的微服务式分布式应用程序连接它们。
- en: 'Each of these schedulers had strengths and weaknesses. But Kubernetes introduced
    two concepts that set it apart from the crowd: *declarative infrastructure* and
    the *reconciliation loop*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个调度器都有其优点和缺点。但是 Kubernetes 引入了两个概念使其脱颖而出：*声明性基础设施* 和 *协调循环*。
- en: Declarative infrastructure
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明性基础设施
- en: 'Consider the case of deploying a container. One might approach the process
    of deploying a container like this: I create the container. I open a port for
    it to listen on, and then I attach some storage at this particular place on the
    filesystem. Then I wait for everything to be initialized. Then I test it to see
    if the container is ready. Then I mark it as available.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑部署容器的情况。一个人可能会以如下方式处理部署容器的过程：我创建容器。我打开一个端口让它监听，并在文件系统的特定位置上附加一些存储。然后我等待所有初始化完成。然后我测试它以查看容器是否准备就绪。然后我标记它为可用。
- en: In this approach, we are thinking *procedurally* by focusing on the process
    of setting up a container. But Kubernetes’ design is that we think *declaratively*.
    We tell the scheduler (Kubernetes) what our desired state is, and Kubernetes takes
    care of converting that declarative statement into its own internal procedures.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们通过专注于设置容器的过程来*过程化*思考。但 Kubernetes 的设计是我们*声明式*地思考。我们告诉调度器（Kubernetes）我们的期望状态是什么，Kubernetes
    负责将该声明转换为其内部的操作流程。
- en: Installing a container on Kubernetes, then, is more a matter of saying, “I want
    this container running on this port with this amount of CPU and some storage mounted
    at this location on the filesystem.” Kubernetes works behind the scenes to wire
    everything up according to our declaration of what we want.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上安装容器更像是说：“我希望这个容器在这个端口上运行，使用这么多的 CPU 并且在文件系统的这个位置上挂载一些存储。” Kubernetes
    在幕后工作，根据我们声明的需求连接所有内容。
- en: The reconciliation loop
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协调循环
- en: How does Kubernetes work behind the scenes to do all of this? When we viewed
    things procedurally, there was a certain order of operations there. How does Kubernetes
    know the order? This is where the idea of the *reconciliation loop* comes into
    play.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 如何在幕后处理所有这些？当我们从过程的角度来看待事物时，那里有一定的操作顺序。Kubernetes 如何知道顺序？这就是 *协调循环*
    的概念发挥作用的地方。
- en: In a reconciliation loop, the scheduler says “here is the user’s desired state.
    Here is the current state. They are not the same, so I will take steps to reconcile
    them.” The user wants storage for the container. Currently there is no storage
    attached. So Kubernetes creates a unit of storage and attaches it to the container.
    The container needs a public network address. None exists. So a new address is
    attached to the container. Different subsystems in Kubernetes work to fulfill
    their individual part of the user’s overall declaration of desired state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在协调循环中，调度器会说：“这是用户的期望状态。这是当前的状态。它们不同，所以我将采取步骤来调和它们。” 用户需要容器的存储。目前没有附加存储。因此 Kubernetes
    创建了一个存储单元并将其附加到容器上。容器需要一个公共网络地址。目前不存在。因此将一个新的地址附加到容器上。Kubernetes 中的不同子系统会努力履行其用户期望状态的各个部分。
- en: Eventually, Kubernetes will either succeed in creating the user’s desired environment
    or will arrive at the conclusion that it cannot realize the user’s desires. Meanwhile,
    the user takes a passive role in observing the Kubernetes cluster and waiting
    for it to achieve success or mark the installation as failed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Kubernetes 将会成功创建用户期望的环境，或者得出无法实现用户愿望的结论。与此同时，用户在观察 Kubernetes 集群并等待其成功或标记安装失败时扮演被动角色。
- en: From containers to pods, services, deployments, etc.
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从容器到 pod、服务、部署等等。
- en: 'While concise, the preceding example is a little misleading. Kubernetes doesn’t
    necessarily treat the container as the unit of work. Instead, Kubernetes introduces
    a higher-level abstraction called a *pod*. A pod is an abstract envelope that
    describes a discrete unit of work. A pod describes not just a container, but one
    or more containers (as well as their configuration and requirements) that together
    perform one unit of work:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简洁，但上面的示例有些误导性。Kubernetes 并不一定把容器作为工作的单元。相反，Kubernetes 引入了一个更高级的抽象称为 *pod*。一个
    pod 是一个抽象的信封，描述了一个独立的工作单元。一个 pod 描述的不仅仅是一个容器，还包括一个或多个容器（以及它们的配置和需求），这些容器一起执行一个工作单元：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_introducing_helm_CO1-1)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_introducing_helm_CO1-1)'
- en: The first two lines define the Kubernetes kind (v1 Pod).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行定义了 Kubernetes 类型（v1 Pod）。
- en: '[![2](Images/2.png)](#co_introducing_helm_CO1-2)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_introducing_helm_CO1-2)'
- en: A pod can have one or more containers.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 pod 可以有一个或多个容器。
- en: Most frequently, a pod only has one container. But sometimes they have containers
    that do some preconfiguration for the main container, exiting before the main
    container comes online. These are called *init containers*. Other times, there
    are containers that run alongside the main container and provide auxiliary services.
    These are called *sidecar containers*. These are all considered part of the same
    pod.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，一个 pod 只有一个容器。但有时它们会有一些在主容器上线之前进行一些预配置的容器，然后退出。这些被称为 *init containers*。另外有时候还有运行在主容器旁边并提供辅助服务的容器。这些被称为
    *sidecar containers*。它们都被视为同一个 pod 的一部分。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the preceding code, we have written a definition of a Kubernetes `Pod` resource.
    These definitions, when expressed as YAML or JSON, are referred to as *manifests*.
    A manifest can contain one or more Kubernetes *resources* (also called *objects*
    or *resource definitions*). Each resource is associated with one of the Kubernetes
    *types*, such as a `Pod` or `Deployment`. In this book, we typically use *resource*
    because the word *object* is overloaded: YAML defines the word *object* to mean
    a named key/value structure.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们编写了一个 Kubernetes `Pod` 资源的定义。当这些定义表达为 YAML 或 JSON 时，被称为 *manifests*。一个
    manifest 可以包含一个或多个 Kubernetes *资源*（也称为 *对象* 或 *资源定义*）。每个资源与 Kubernetes 的一个 *类型*
    相关联，比如 `Pod` 或 `Deployment`。在本书中，我们通常使用 *资源*，因为 *对象* 这个词被重载了：YAML 将 *对象* 定义为一个命名的键/值结构。
- en: 'A `Pod` describes what configuration the container or containers need (such
    as network ports or filesystem mount points). Configuration information in Kubernetes
    may be stored in *ConfigMaps* or, for sensitive information, *Secrets*. And the
    `Pod`’s definition may then relate those `ConfigMap`s and `Secret`s to environment
    variables or files within each container. As Kubernetes sees those relationships,
    it will attempt to attach and configure the configuration data as described in
    the `Pod` definition:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pod` 描述了容器或容器需要的配置（如网络端口或文件系统挂载点）。在 Kubernetes 中，配置信息可以存储在 *ConfigMaps* 中，对于敏感信息，可以存储在
    *Secrets* 中。`Pod` 的定义可能会将这些 `ConfigMap` 和 `Secret` 关联到每个容器内的环境变量或文件中。当 Kubernetes
    看到这些关系时，它将尝试按照 `Pod` 的定义附加和配置配置数据：'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](Images/1.png)](#co_introducing_helm_CO2-1)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_introducing_helm_CO2-1)'
- en: In this case, we have declared a `v1 ConfigMap` object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们声明了一个 `v1 ConfigMap` 对象。
- en: '[![2](Images/2.png)](#co_introducing_helm_CO2-2)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_introducing_helm_CO2-2)'
- en: Inside of `data`, we declare some arbitrary name/value pairs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `data` 内部，我们声明了一些任意的名称/值对。
- en: A `Secret` is structurally similar to a `ConfigMap`, except that the values
    in the `data` section must be Base64 encoded.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Secret` 在结构上类似于 `ConfigMap`，不同之处在于 `data` 部分的值必须进行 Base64 编码。'
- en: '`Pod`s are linked to configuration objects (like `ConfigMap` or `Secret`) using
    *volumes*. In this example, we take the previous `Pod` example and attach the
    `Secret` above:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pod` 通过 *volumes* 与配置对象（如 `ConfigMap` 或 `Secret`）关联。在本例中，我们采用了上面的 `Pod` 示例，并附加了上述
    `Secret`：'
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_introducing_helm_CO3-1)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_introducing_helm_CO3-1)'
- en: The `volumes` section tells Kubernetes which storage sources this pod needs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes`部分告诉 Kubernetes 此 Pod 需要哪些存储源。'
- en: '[![2](Images/2.png)](#co_introducing_helm_CO3-2)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_introducing_helm_CO3-2)'
- en: The name `configuration-data` is the name of our `ConfigMap` we created in the
    previous example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`configuration-data`是我们在前面示例中创建的`ConfigMap`的名称。
- en: '[![3](Images/3.png)](#co_introducing_helm_CO3-3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_introducing_helm_CO3-3)'
- en: The `env` section injects environment variables into the container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`env`部分将环境变量注入到容器中。'
- en: '[![4](Images/4.png)](#co_introducing_helm_CO3-4)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_introducing_helm_CO3-4)'
- en: The environment variable will be named `BACKGROUND_COLOR` inside of the container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量在容器内将被命名为`BACKGROUND_COLOR`。
- en: '[![5](Images/5.png)](#co_introducing_helm_CO3-5)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_introducing_helm_CO3-5)'
- en: This is the name of the `ConfigMap` it will use. This map must be in `volumes`
    if we want to use it as a filesystem volume.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它将使用的`ConfigMap`的名称。如果我们希望将其作为文件系统卷使用，此映射必须在`volumes`中。
- en: '[![6](Images/6.png)](#co_introducing_helm_CO3-6)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_introducing_helm_CO3-6)'
- en: This is the name of the key inside the `data` section of the `ConfigMap`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ConfigMap`的`data`部分内键的名称。
- en: A pod is the “primitive” description of a runnable unit of work, with containers
    as part of that pod. But Kubernetes introduces higher-order concepts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Pod`是可运行工作单元的“原始”描述，其中包含容器。但是 Kubernetes 引入了更高级别的概念。
- en: Consider a web application. We might not want to run just one instance of this
    web application. If we ran just one, and it failed, our site would go down. And
    if we wanted to upgrade it, we would have to figure out how to do so without taking
    down the whole site. Thus, Kubernetes introduced the concept of a *Deployment*.
    A `Deployment` describes an application as a collection of identical pods. The
    `Deployment` is composed of some top-level configuration data as well as a template
    for how to construct a replica pod.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个 Web 应用程序。我们可能不希望只运行一个此 Web 应用程序的实例。如果我们只运行一个实例，如果它失败了，我们的站点将会宕机。如果我们想升级它，我们将不得不想办法在不关闭整个站点的情况下进行升级。因此，Kubernetes
    引入了*Deployment*的概念。`Deployment`描述了一个应用程序作为一组相同的`Pod`。`Deployment`由一些顶层配置数据组成，以及用于构建副本`Pod`的模板。
- en: 'With a `Deployment`, we can tell Kubernetes to create our app with a single
    pod. Then we can scale it up to five pods. And back down to three. We can attach
    a *HorizontalPodAutoscaler* (another Kubernetes type) and configure that to scale
    our pod based on resource usage. And when we upgrade the application, the `Deployment`
    can employ various strategies for incrementally upgrading individual pods without
    taking down our entire application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Deployment`，我们可以告诉 Kubernetes 创建我们的应用程序一个单独的`Pod`。然后我们可以将其扩展到五个`Pod`，再缩减到三个`Pod`。我们可以附加*HorizontalPodAutoscaler*（另一种
    Kubernetes 类型），并配置它根据资源使用情况扩展我们的`Pod`。当我们升级应用程序时，`Deployment`可以采用各种策略逐步升级单个`Pod`，而不会导致整个应用程序宕机：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](Images/1.png)](#co_introducing_helm_CO4-1)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_introducing_helm_CO4-1)'
- en: This is an `apps/v1 Deployment` object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`apps/v1 Deployment`对象。
- en: '[![2](Images/2.png)](#co_introducing_helm_CO4-2)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_introducing_helm_CO4-2)'
- en: Inside of the spec, we ask for three replicas of the following `template`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范内部，我们要求三个副本的以下`template`。
- en: '[![3](Images/3.png)](#co_introducing_helm_CO4-3)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_introducing_helm_CO4-3)'
- en: The template specifies how each replica pod should look.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模板指定每个副本`Pod`的外观应该如何。
- en: 'When it comes to attaching a Kubernetes application to other things on the
    network, Kubernetes provides *Service* definitions. A `Service` is a persistent
    network resource (sort of like a static IP) that persists even if the pod or pods
    attached to it go away. In this way, Kubernetes `Pod`s can come and go while the
    network layer can continue to route traffic to the same `Service` endpoint. While
    a `Service` is an abstract Kubernetes concept, behind the scenes it may be implemented
    as anything from a routing rule to an external load balancer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及将 Kubernetes 应用程序附加到网络上的其他内容时，Kubernetes 提供了*Service*定义。`Service`是一种持久的网络资源（类似于静态
    IP），即使与其连接的`Pod`或`Pods`消失，它也会持续存在。这样，Kubernetes `Pod`可以来去自如，而网络层仍然可以继续将流量路由到相同的`Service`端点。虽然`Service`是一个抽象的
    Kubernetes 概念，但在幕后它可以被实现为从路由规则到外部负载均衡器的任何内容：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](Images/1.png)](#co_introducing_helm_CO5-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_introducing_helm_CO5-1)'
- en: The kind is `v1 Service`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是`v1 Service`。
- en: '[![2](Images/2.png)](#co_introducing_helm_CO5-2)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_introducing_helm_CO5-2)'
- en: 'This `Service` will route to pods with the `app: my-deployment` label.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '这个`Service`将路由到具有`app: my-deployment`标签的`Pod`。'
- en: '[![3](Images/3.png)](#co_introducing_helm_CO5-3)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_introducing_helm_CO5-3)'
- en: 'TCP traffic to port `80` of this `Service` will be routed to port `8080` on
    the pods that match the `app: my-deployment` label.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'TCP 流量到这个 `Service` 的 `80` 端口将路由到与 `app: my-deployment` 标签匹配的 pods 的 `8080`
    端口。'
- en: The `Service` described will route traffic to the `Deployment` we created earlier.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的 `Service` 将流量路由到我们之前创建的 `Deployment`。
- en: We’ve introduced a few of the many Kubernetes types. There are dozens more that
    we could cover, but the most frequently used by far are `Pod`, `Deployment`, `ConfigMap`,
    `Secret`, and `Service`. In the next chapter we will begin working with these
    concepts more directly. But for now, armed with some generic information, we can
    introduce Helm.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了许多 Kubernetes 类型中的一些。还有很多我们可以覆盖的类型，但迄今为止使用最频繁的类型是 `Pod`, `Deployment`,
    `ConfigMap`, `Secret` 和 `Service`。在下一章中，我们将更直接地开始使用这些概念。但是现在，凭借一些通用信息，我们可以介绍 Helm。
- en: Helm’s Goals
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 目标
- en: Up to this point, we have focused on the broader cloud native ecosystem and
    on Kubernetes’ role within that ecosystem. In this section, we will change focus
    to Helm.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于更广泛的云原生生态系统及其在其中的角色。在本节中，我们将把焦点转向 Helm。
- en: 'In the previous section, we saw several distinct Kubernetes resources: A `Pod`,
    a `ConfigMap`, a `Deployment`, and a `Service`. Each of these performs some discrete
    role. But an *application* typically requires more than one of these.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了几个不同的 Kubernetes 资源：一个 `Pod`，一个 `ConfigMap`，一个 `Deployment` 和一个 `Service`。每一个资源都扮演着不同的角色。但是一个
    *应用程序* 通常需要其中多个。
- en: For example, the WordPress CMS system can be run inside of Kubernetes. But typically
    it would need at least a `Deployment` (for the WordPress server), a `ConfigMap`
    for configuration and probably a `Secret` (to keep passwords), a few `Service`
    objects, a `StatefulSet` running a database, and a few role-based access control
    (RBAC) rules. Already, a Kubernetes description of a basic WordPress site would
    span thousands of lines of YAML. At the very core of Helm is this idea that all
    of those objects can be packaged to be installed, updated, and deleted *together*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，WordPress CMS 系统可以在 Kubernetes 内部运行。但通常需要至少一个 `Deployment`（用于 WordPress 服务器），一个
    `ConfigMap` 用于配置，可能还需要一个 `Secret`（用于保存密码），几个 `Service` 对象，一个运行数据库的 `StatefulSet`，以及几个基于角色的访问控制（RBAC）规则。已经，一个基本的
    WordPress 站点的 Kubernetes 描述将涵盖数千行 YAML。Helm 的核心理念之一是，所有这些对象可以打包在一起进行安装、更新和删除。
- en: 'When we wrote Helm, we had three main goals:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写 Helm 时，我们有三个主要目标：
- en: Make it easy to go from “zero to Kubernetes”
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让从“零到 Kubernetes”变得更容易
- en: Provide a package management system like operating systems have
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供像操作系统那样的软件包管理系统
- en: Emphasize security and configurability for deploying applications to Kubernetes
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强调安全性和可配置性，用于部署应用到 Kubernetes
- en: 'We will look at each of these three goals, and then take a look at one other
    aspect of Helm’s usage: its participation in the life cycle management story.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将审视这三个目标，并看看 Helm 在生命周期管理故事中的参与情况。
- en: From Zero to Kubernetes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从零到 Kubernetes
- en: The Helm project started in 2015, a few months before the inaugural KubeCon.
    Kubernetes was difficult to set up, often requiring new users to compile the Kubernetes
    source code and then use some shell scripts to get Kubernetes running. And once
    the cluster was up, new users were expected to write YAML (as we did in previous
    sections) from scratch. There were few basic examples and no production-ready
    examples.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 项目始于2015年，比首届 KubeCon 会议早几个月。设置 Kubernetes 很困难，通常需要新用户编译 Kubernetes 源代码，然后使用一些
    shell 脚本来运行 Kubernetes。一旦集群启动，新用户就被期望从头开始编写 YAML（正如我们在之前的章节中所做的）。基本示例很少，没有生产就绪的示例。
- en: 'We wanted to invert the learning cycle: instead of requiring users to start
    with basic examples and try to construct their own applications, we wanted to
    provide users with ready-made production-ready examples. Users could install those
    examples, see them in action, and then learn how Kubernetes worked.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望颠覆学习周期：不再要求用户从基本示例开始构建他们自己的应用程序，而是提供用户现成的生产就绪示例。用户可以安装这些示例，看到它们运行，然后学习 Kubernetes
    如何工作。
- en: 'That was, and still is to this day, our first priority with Helm: make it easier
    to get going with Kubernetes. In our view, a new Helm user with an existing Kubernetes
    cluster should be able to go from download to an installed application in five
    minutes or less.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是，直到今天，我们与 Helm 的首要任务：使其更容易与 Kubernetes 配合使用。在我们看来，一个新的 Helm 用户在现有的 Kubernetes
    集群上应该能够在下载到安装应用程序不到五分钟内完成。
- en: But Helm isn’t *just* a learning tool. It is a package manager.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Helm 不仅仅是一个学习工具。它是一个软件包管理器。
- en: Package Management
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件包管理
- en: Kubernetes is like an operating system. At its foundation, an operating system
    provides an environment for executing programs. It provides the tools necessary
    to store, execute, and monitor the life cycle of a program.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes就像一个操作系统。在其基础上，操作系统为执行程序提供了环境。它提供了存储、执行和监视程序生命周期所需的工具。
- en: Instead of executing programs, it executes containers. But similar to an operating
    system, it provides the tools necessary to store, execute, and monitor those containers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是执行程序，而是执行容器。但与操作系统类似，它提供了存储、执行和监视这些容器所需的工具。
- en: Most operating systems are supported by a *package manager*. The job of the
    package manager is to make it easy to find, install, upgrade, and delete the programs
    on an operating system. Package managers provide semantics for bundling programs
    into installable applications, and they provide a scheme for storing and retrieving
    packages, as well as installing and managing them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都有一个*软件包管理器*。软件包管理器的工作是简化操作系统上程序的查找、安装、升级和删除。软件包管理器提供了打包程序成可安装应用程序的语义，并提供了存储和检索软件包以及安装和管理它们的方案。
- en: 'As we envisioned Kubernetes as an operating system, we quickly saw the need
    for a Kubernetes package manager. From the first commit to the Helm source code
    repository, we have consistently applied the package management metaphor to Helm:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将Kubernetes视为一个操作系统时，我们很快意识到需要一个Kubernetes软件包管理器。从Helm源代码库的第一个提交开始，我们始终将软件包管理隐喻应用于Helm：
- en: Helm provides package repositories and search capabilities to find what Kubernetes
    applications are available.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm提供了包仓库和搜索功能，用于查找可用的Kubernetes应用程序。
- en: Helm has the familiar install, upgrade, and delete commands.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm具有熟悉的安装、升级和删除命令。
- en: Helm defines a method for configuring packages prior to installing them.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm定义了一种在安装前配置软件包的方法。
- en: Additionally, Helm has tools for seeing what is already installed and how it
    is configured.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Helm还有工具用于查看已安装的内容及其配置。
- en: We initially modeled Helm after Homebrew (a package manager for macOS) and Apt
    (the package manager for Debian). But as Helm has matured, we have sought to learn
    from as many different package managers as we can.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将Helm建模为Homebrew（macOS的软件包管理器）和Apt（Debian的软件包管理器）。但随着Helm的成熟，我们已经努力从尽可能多的不同软件包管理器中学习。
- en: There are some differences between typical operating systems and Kubernetes.
    One of them is that Kubernetes supports running many instances of the same application.
    While I may only install the database MariaDB once on my workstation, a Kubernetes
    cluster could be running tens, hundreds, or even thousands of MariaDB installations—each
    with a different configuration or even a different version.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 典型操作系统和Kubernetes之间存在一些差异。其中之一是，Kubernetes支持运行多个相同应用程序的实例。而我可能只在工作站上安装MariaDB数据库一次，Kubernetes集群可以运行数十、数百甚至数千个MariaDB安装实例，每个实例可能有不同的配置或不同的版本。
- en: Another notion that is rare in typical operating systems, but is central to
    Kubernetes, is the idea of a *namespace*. In Kubernetes, a namespace is an arbitrary
    grouping mechanism that defines a boundary between the things inside the namespace
    and the things outside. There are many different ways to organize resources with
    namespaces, but oftentimes they are used as a fixture to which security is attached.
    For example, perhaps only specific users can access resources inside of a namespace.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在典型操作系统中罕见但在Kubernetes中很核心的概念是*命名空间*。在Kubernetes中，命名空间是一种任意的分组机制，用于定义命名空间内部和外部的事物之间的边界。有许多不同的方式可以通过命名空间组织资源，但通常它们被用作附着安全性的固定装置。例如，可能只有特定用户可以访问命名空间内的资源。
- en: These are just a few ways that Kubernetes differs from traditional operating
    systems. These and other differences have presented challenges in the design of
    Helm. We have had to build Helm to take advantage of these differences, but without
    giving up on our package management metaphor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是Kubernetes与传统操作系统不同的几种方式。这些以及其他差异在Helm的设计中提出了挑战。我们不得不建立Helm以利用这些差异，但又不放弃我们的软件包管理隐喻。
- en: For example, the Helm installation command requires not only the name of the
    package, but also a user-supplied name by which the installed version of that
    package will be referenced. In the next chapter, we’ll see examples of this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Helm安装命令不仅需要包的名称，还需要用户提供的名称，用于引用该包的安装版本。在下一章中，我们将看到这方面的例子。
- en: Likewise, operations in Helm are namespace-sensitive. One can install the same
    application into two different namespaces, and Helm provides tools to manage these
    different instances of the application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Helm 中的操作是命名空间敏感的。可以将同一个应用程序安装到两个不同的命名空间中，并且 Helm 提供工具来管理这些应用程序的不同实例。
- en: In the end, though, Helm remains firmly in the package management class of tools.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Helm 始终牢固地位于工具包管理类别中。
- en: Security, Reusability, and Configurability
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性、可重用性和可配置性
- en: 'Our third goal with Helm was to focus on three “must haves” for managing applications
    in a cluster:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 的第三个目标是专注于管理集群中应用程序的三个“必须具备的”功能：
- en: Security
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全性
- en: Reusability
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可重用性
- en: Configurability
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可配置性
- en: In short, we wanted to make Helm aware enough about these principles that Helm
    users can have confidence in the packages they use. A user should be able to *verify*
    that a package came from a trustworthy source (and was not tampered with), *reuse*
    the same package multiple times, and *configure* the package to fit their needs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们希望 Helm 对这些原则有足够的认识，以便 Helm 用户可以对他们使用的包有信心。用户应能够*验证*一个包来自可信任的来源（且未被篡改），*重复使用*同一个包多次，以及*配置*包以适应他们的需求。
- en: 'Whereas Helm’s developers have direct control over the previous two design
    goals, this one is unique: Helm can only provide the right tools for *package
    authors* and hope that these creators choose to realize these three “must haves.”'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 的开发者可以直接控制前两个设计目标，而这个是独一无二的：Helm 只能为*包作者*提供合适的工具，并希望这些创作者选择实现这三个“必须具备的”目标。
- en: Security
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性
- en: 'Security is a broad category. In this context, though, we are referring to
    the idea that when a user examines a package, the user has the ability to verify
    certain things about the package:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一个广泛的类别。在这个上下文中，我们指的是当用户检查一个包时，用户有能力验证关于包的某些事项：
- en: The package comes from a trusted source.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包来自可信任的来源。
- en: The network connection over which the package is pulled is secured.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取包的网络连接是安全的。
- en: The package has not been tampered with.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包没有被篡改。
- en: The package can be easily inspected so the user can see what it does.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以轻松检查包，以了解其功能。
- en: The user can see what configuration the package has, and see how different inputs
    impact the output of a package.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以查看包的配置，以及了解不同的输入如何影响包的输出。
- en: Throughout this book, and especially in [Chapter 6](ch06.xhtml#advanced_charts),
    we will cover security in more detail. But these five capabilities are things
    we believe we have provided with Helm.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，特别是在[第六章](ch06.xhtml#advanced_charts)，我们将更详细地讨论安全性。但这五个功能是我们认为 Helm 已经提供的内容。
- en: Helm provides a *provenance* feature to establish verification about a package’s
    origin, author, and integrity. Helm supports Secure Sockets Layer/Transport Layer
    Security (SSL/TLS) for securely sending data across the network. And Helm provides
    dry-run, template, and linting commands to examine packages and their possible
    permutations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了*来源*功能，用于建立有关包的来源、作者和完整性的验证。Helm 支持安全套接字层/传输层安全性（SSL/TLS），用于安全地通过网络发送数据。并且
    Helm 提供了干预运行、模板和清理命令，以检查包及其可能的排列组合。
- en: Reusability
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可重用性
- en: 'A virtue of package management is its ability to install the same thing repeatedly
    and predictably. With Helm, this idea is extended slightly: we may want to even
    install the same thing (repeatedly and predictably) into the same cluster or even
    same namespace in a cluster.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理的一个优点是可以重复和可预测地安装相同的内容。稍微扩展一下，使用 Helm，我们甚至可能希望将相同的内容（重复和可预测地）安装到同一个集群或同一个命名空间中。
- en: Helm charts are the key to reusability. A chart provides a pattern for producing
    the same Kubernetes manifests. But charts also allow users to provide additional
    configuration (which we will talk about in the next chapter). So Helm provides
    patterns for storing configuration so that the combination of a chart plus its
    configuration can even be done repeatedly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表是可重复使用的关键。一个图表提供了生成相同 Kubernetes 清单的模式。但图表还允许用户提供额外的配置（我们将在下一章讨论）。因此，Helm
    提供了存储配置的模式，使得可以重复执行图表加其配置的组合。
- en: In this way, Helm encourages Kubernetes users to package their YAML into charts
    so that these descriptions can be reused.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Helm 鼓励 Kubernetes 用户将他们的 YAML 打包成图表，以便可以重复使用这些描述。
- en: In the Linux world, each Linux distribution has its own package manager and
    repositories. This is not the case in the Kubernetes world. Helm was constructed
    so that all Kubernetes distributions could share the same package manager, and
    (with very, very few exceptions) the same packages as well. When there are differences
    between two different Kubernetes distributions, charts can accommodate this using
    templates (discussed more thoroughly in [Chapter 5](ch05.xhtml#developing_templates))
    coupled with configuration.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 世界中，每个 Linux 发行版都有自己的包管理器和仓库。而在 Kubernetes 世界中不是这样。Helm 被设计为所有 Kubernetes
    发行版可以共享相同的包管理器，以及（极少数例外情况除外）相同的包。当两个不同的 Kubernetes 发行版之间存在差异时，可以使用模板（在[第五章](ch05.xhtml#developing_templates)中详细讨论）与配置来适应这些差异。
- en: Configurability
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可配置性
- en: Helm provides patterns for taking a Helm chart and then supplying some additional
    configuration. For example, I might install a website with Helm, but want to set
    (at installation time) the name of that website. Helm provides tools to configure
    packages at installation time, and to reconfigure installations during upgrades.
    But a word of caution is in order.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了将 Helm 图表与一些额外配置结合的模式。例如，我可以使用 Helm 安装一个网站，并在安装时设置该网站的名称。Helm 提供了在安装和升级过程中重新配置包的工具。但需要注意一点。
- en: Helm is a package manager. Another class of software handles *configuration
    management*. This class of software, typified by Puppet, Ansible, and Chef, focuses
    on how a given piece of software (often packaged) is *specifically configured*
    for its host environment. Its responsibility is to manage configuration changes
    over time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是一个包管理器。另一类软件处理*配置管理*。这类软件，以 Puppet、Ansible 和 Chef 为代表，专注于如何为其主机环境*特定配置*的给定软件（通常打包）。其责任是管理随时间变化的配置。
- en: Helm was not designed to be a configuration management tool, though there is
    at least some overlap between package management and configuration management.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 并非设计成一个配置管理工具，尽管包管理和配置管理之间至少存在一定的重叠。
- en: 'Package management is typically confined to implementing three verbs: install,
    upgrade, and delete. Configuration management is a higher-order concept that focuses
    on managing an application or applications over time. This is sometimes called
    “day-two ops.”'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理通常限制于实施三个动作：安装、升级和删除。配置管理则是一个更高层次的概念，专注于长期管理一个或多个应用程序。有时候这被称为“第二天运维”。
- en: While Helm did not set out to be a configuration management tool, it is sometimes
    used as one. Organizations rely upon Helm not just to install, upgrade, and delete,
    but also to track changes over time, to track configuration, and to determine
    whether an application as a whole is running. Helm can be stretched this way,
    but if you want a strong configuration management solution, you may want to leverage
    other tools in the Helm ecosystem. Many tools like Helmfile, Flux, and Reckoner
    have filled in details in the larger configuration management story.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Helm 最初并非旨在成为配置管理工具，但有时会被用作此类工具。组织依赖于 Helm 不仅仅是为了安装、升级和删除，还用于跟踪时间变化、跟踪配置，并确定整个应用程序是否正在运行。Helm
    可以在这方面进行扩展，但如果你需要强大的配置管理解决方案，可能需要利用 Helm 生态系统中的其他工具。像 Helmfile、Flux 和 Reckoner
    等工具填补了更大配置管理故事中的细节。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Helm community has created a wealth of tools that interoperate with or augment
    Helm. The Helm project maintains a list of those tools in the [official documentation](https://oreil.ly/hOqca).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 社区创建了大量与 Helm 兼容或增强 Helm 的工具。Helm 项目在[官方文档](https://oreil.ly/hOqca)中维护了这些工具的列表。
- en: One of the common themes you will notice in Helm charts is that configuration
    options are often set up so that you can take the same chart and release a minimal
    version of it into your development environment, or (with different configuration
    options) a sophisticated version into your production environment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 Helm 图表中注意到的一个常见主题是，配置选项经常设置成可以将相同的图表发布到开发环境中的最小版本，或者（通过不同的配置选项）发布到生产环境中的复杂版本。
- en: Helm’s Architecture
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm 的架构
- en: In the final section of this chapter, we will briefly turn to the high-level
    architecture of Helm. As well as rounding out the conceptual discussion of cloud
    native Kubernetes applications and package management, this section paves the
    way for [Chapter 2](ch02.xhtml#Using_Helm), where we will dive into using Helm.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将简要介绍 Helm 的高级架构。除了完成云原生 Kubernetes 应用程序和软件包管理的概念讨论外，本节还为 [第 2 章](ch02.xhtml#Using_Helm)
    铺平了道路。
- en: Kubernetes Resources
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 资源
- en: We have had a look at several kinds of Kubernetes resources. We saw a couple
    of `Pod` definitions, a `ConfigMap`, a `Deployment`, and a `Service`. There are
    dozens more provided by Kubernetes. You can even use custom resource definitions
    (CRDs) for defining your own custom resource types. The main Kubernetes documentation
    provides both accessible guides and detailed API documentation on each kind.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了几种 Kubernetes 资源类型。我们看到了几个 `Pod` 定义，一个 `ConfigMap`，一个 `Deployment` 和一个
    `Service`。Kubernetes 还提供了几十种其他资源类型。您甚至可以使用自定义资源定义（CRD）来定义自己的自定义资源类型。主 Kubernetes
    文档提供了关于每种资源类型的可访问指南和详细的 API 文档。
- en: Throughout this book, we will use many different Kubernetes resource types.
    While we discuss them in context, you may find it beneficial to skim through the
    main Kubernetes document as you run across new resource definitions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用许多不同的 Kubernetes 资源类型。虽然我们在上下文中讨论它们，但您可能会发现在遇到新的资源定义时，浏览主 Kubernetes
    文档是有益的。
- en: As we discussed earlier, resource definitions are *declarative*. You, the user,
    describe for Kubernetes the desired state of a resource. For example, you can
    read the `Pod` definition we created earlier in the chapter as a statement that,
    “I want Kubernetes to make me a `Pod` that has these features.” It is up to Kubernetes
    to figure out how to configure and run a pod according to your specification.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，资源定义是*声明式*的。您作为用户描述了 Kubernetes 所需的资源的期望状态。例如，您可以把我们在本章早些时候创建的 `Pod`
    定义理解为一种声明，“我希望 Kubernetes 为我创建一个具有这些特性的 `Pod`”。Kubernetes 将根据您的规范来配置和运行 Pod。
- en: 'All Kubernetes resource definitions share a common subset of elements. The
    following manifest uses a `Deployment` to illustrate the main structural elements
    of a resource definition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Kubernetes 资源定义共享一个常见的元素子集。以下清单使用 `Deployment` 来说明资源定义的主要结构元素：
- en: '[PRE6]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_introducing_helm_CO6-1)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_introducing_helm_CO6-1)'
- en: The API family and version for this resource.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 该资源的 API 家族和版本。
- en: '[![2](Images/2.png)](#co_introducing_helm_CO6-2)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_introducing_helm_CO6-2)'
- en: The kind of resource. Combined with `apiVersion`, we get the “resource type”.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的类型。与 `apiVersion` 结合使用，我们得到“资源类型”。
- en: '[![3](Images/3.png)](#co_introducing_helm_CO6-3)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_introducing_helm_CO6-3)'
- en: The `metadata` section contains top-level data about the resource.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata` 部分包含有关资源的顶级数据。'
- en: '[![4](Images/4.png)](#co_introducing_helm_CO6-4)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_introducing_helm_CO6-4)'
- en: A `name` is required for almost every resource type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种资源类型都需要一个名称。
- en: '[![5](Images/5.png)](#co_introducing_helm_CO6-5)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](Images/5.png)](#co_introducing_helm_CO6-5)'
- en: Labels are used to give Kubernetes query-able “handles” to your resources.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 标签用于为您的资源提供 Kubernetes 可查询的“句柄”。
- en: '[![6](Images/6.png)](#co_introducing_helm_CO6-6)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](Images/6.png)](#co_introducing_helm_CO6-6)'
- en: Annotations provide a way for authors to attach their own keys and values to
    a resource.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注解提供了一种方式，供作者将他们自己的键和值附加到资源上。
- en: 'Of particular note, a *resource type* in Kubernetes is composed of three pieces
    of information:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，在 Kubernetes 中，*资源类型* 由三部分信息组成：
- en: API group (or family)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: API 组（或家族）
- en: Several base resource types like `Pod` and `ConfigMap` omit this name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `Pod` 和 `ConfigMap` 这样的几种基本资源类型省略了这个名称。
- en: API version
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: API 版本
- en: Expressed as a `v`, followed by a major version and an optional stability marker.
    For example, `v1` is a stable “version 1,” while `v1alpha` indicates an unstable
    “version 1 alpha 1.”
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 表示为 `v`，后跟主版本号和可选的稳定性标记。例如，`v1` 是稳定的“版本 1”，而 `v1alpha` 表示不稳定的“版本 1 alpha 1”。
- en: Resource kind
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 资源种类
- en: The (capitalized) name of the specific resource within the API group.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: API 组内特定资源的（大写）名称。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While a full resource type name is something like `apps/v1 Deployment` or `v1
    Pod` (for core types), Kubernetes users will often omit the group and version
    when talking or writing about well-known types. For example, in this book we simply
    write `Deployment` instead of `apps/v1 Deployment`. Fully qualified names are
    used when specifying an exact version or when discussing a resource type defined
    in a CRD.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的资源类型名称类似于 `apps/v1 Deployment` 或 `v1 Pod`（对于核心类型），Kubernetes 用户在谈论或写作时通常会省略组和版本。例如，在本书中，我们简单地写
    `Deployment` 而不是 `apps/v1 Deployment`。完全合格的名称用于指定确切的版本或讨论在 CRD 中定义的资源类型。
- en: Thus, `apps/v1 Deployment` indicates that the API group “apps” has a “version
    1” (stable) resource kind called “Deployment.”
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`apps/v1 Deployment` 表示 API 组 “apps” 有一个 “版本 1”（稳定的）资源类型称为 “Deployment”。
- en: 'Kubernetes supports two main formats for declaring the resources you want:
    JSON and YAML. Strictly speaking, YAML is a *superset* of JSON. All JSON documents
    are valid YAML, but YAML adds a number of additional features.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持两种主要格式来声明您所需的资源：JSON 和 YAML。严格来说，YAML 是 JSON 的 *超集*。所有的 JSON 文档都是有效的
    YAML，但 YAML 增加了许多额外的功能。
- en: In this book, we stick to the YAML format. We find it easier to read and write,
    and almost all Helm users choose YAML over JSON. However, should your preferences
    differ, both Kubernetes and Helm support plain JSON.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们坚持使用 YAML 格式。我们发现它更易于阅读和编写，几乎所有 Helm 用户选择 YAML 而不是 JSON。但是，如果您有不同的偏好，Kubernetes
    和 Helm 都支持纯粹的 JSON。
- en: Earlier, we introduced the term *manifest*. A manifest is just a Kubernetes
    resource serialized to either its JSON or YAML format. It would be fair to call
    our earlier `Pod`, `ConfigMap`, `Deployment`, and `Service` examples each a *Kubernetes
    manifest*, since they are resources expressed in YAML.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们介绍了术语 *清单*。清单只是 Kubernetes 资源序列化为其 JSON 或 YAML 格式。我们早先的 `Pod`、`ConfigMap`、`Deployment`
    和 `Service` 每个都可以称为 *Kubernetes 清单*，因为它们是用 YAML 表示的资源。
- en: Charts
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图表
- en: We have already talked about Helm packages in this chapter. In Helm’s vocabulary,
    a package is called a *chart*. The name is a play on the nautical nature of Kubernetes
    (which means “ship’s captain” in Greek) and Helm (which is the steering mechanism
    of a ship). A chart plots the way a Kubernetes application should be installed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讨论了 Helm 包。在 Helm 的术语中，一个包被称为 *图表*。这个名字是对 Kubernetes 的航海特性（希腊语中意为“船长”）和
    Helm（船舶的驾驶机制）的一种演绎。图表规划了 Kubernetes 应用程序的安装方式。
- en: A chart is a set of files and directories that adhere to the chart specification
    for describing the resources to be installed into Kubernetes. [Chapter 4](ch04.xhtml#building_a_chart)
    explains the chart structure in detail, but there are a few high-level concepts
    we will introduce here.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图表是一组文件和目录，遵循图表规范来描述要安装到 Kubernetes 中的资源。[第4章](ch04.xhtml#building_a_chart)详细解释了图表结构，但在这里我们会介绍几个高级概念。
- en: A chart contains a file called *Chart.yaml* that describes the chart. It has
    information about the chart version, the name and description of the chart, and
    who authored the chart.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图表包含一个名为 *Chart.yaml* 的文件，描述了图表。它包含关于图表版本、图表名称和描述以及图表作者的信息。
- en: A chart contains *templates* as well. These are Kubernetes manifests (like we
    saw earlier in this chapter) that are potentially annotated with templating directives.
    We will cover these in detail in [Chapter 5](ch05.xhtml#developing_templates).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图表也包含 *模板*。这些是 Kubernetes 清单（就像我们在本章早些时候看到的那样），可能带有模板化指令。我们将在[第5章](ch05.xhtml#developing_templates)详细介绍这些内容。
- en: A chart may also contain a *values.yaml* file that provides default configuration.
    This file contains parameters that you can override during installation and upgrade.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图表还可能包含一个 *values.yaml* 文件，提供默认配置。这个文件包含参数，您可以在安装和升级期间进行覆盖。
- en: These are the basic things you will find in a Helm chart, though there are others
    that we will cover in [Chapter 4](ch04.xhtml#building_a_chart). When you see a
    Helm chart, though, it may be presented in either unpacked or packed form.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您在 Helm 图表中找到的基本内容，尽管还有其他内容我们将在[第4章](ch04.xhtml#building_a_chart)中介绍。然而，当您看到一个
    Helm 图表时，它可能以解压或打包形式呈现。
- en: An *unpacked* Helm chart is just a directory. Inside, it will have a *Chart.yaml*,
    a *values.yaml*, a *templates/* directory, and perhaps other things as well. A
    *packed* Helm chart contains the same information as an unpacked one, but it is
    tarred and gzipped into a single file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*解压缩*的 Helm 图表只是一个目录。其中会包含一个*Chart.yaml*、一个*values.yaml*、一个*templates/*目录，以及可能的其他内容。*打包*的
    Helm 图表包含与解压缩版本相同的信息，但它被打包成一个压缩文件（tar.gz）。'
- en: 'An unpacked chart is represented by a directory with the name of the chart.
    For example, the chart named *mychart* will be unpacked into a directory named
    *mychart/*. In contrast, a packed chart has the name *and version* of the chart,
    as well as the `tgz` suffix: `mychart-1.2.3.tgz`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解压缩的图表表示为具有图表名称的目录。例如，名为*mychart*的图表将解压缩为一个名为*mychart/*的目录。相比之下，打包的图表具有图表的名称和版本，以及
    `tgz` 后缀：`mychart-1.2.3.tgz`。
- en: Charts are stored in *chart repositories*, which we will cover in [Chapter 7](ch07.xhtml#chart_repositories).
    Helm knows how to download and install charts from repositories.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图表存储在*图表仓库*中，我们将在[第7章](ch07.xhtml#chart_repositories)中详细介绍。Helm 知道如何从仓库中下载和安装图表。
- en: Resources, Installations, and Releases
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源、安装和发布
- en: 'To tie together the terminology introduced in this section, when a Helm chart
    is installed into Kubernetes, this is what happens:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将本节介绍的术语联系在一起，当将 Helm 图表安装到 Kubernetes 中时，将发生以下情况：
- en: Helm reads the chart (downloading if necessary).
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm 读取图表（必要时进行下载）。
- en: It sends the values into the templates, generating Kubernetes manifests.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将这些值传递给模板，生成 Kubernetes 清单。
- en: The manifests are sent to Kubernetes.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清单被发送到 Kubernetes。
- en: Kubernetes creates the requested resources inside of the cluster.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 在集群内创建所请求的资源。
- en: When a Helm chart is installed, Helm will generate as many resource definitions
    as it needs. Some may create one or two, others may create hundreds. When Kubernetes
    receives these definitions, it will create resources for them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装 Helm 图表时，Helm 会根据需要生成多个资源定义。有些可能会创建一个或两个，而其他可能会创建数百个。当 Kubernetes 收到这些定义时，它将为它们创建资源。
- en: A Helm chart may have many resource definitions. Kubernetes sees each of these
    as a discrete thing. But in Helm’s view all of the resources defined by a chart
    are related. For example, my WordPress application may have a `Deployment`, a
    `ConfigMap`, a `Service`, and so on. But they are all part of one *chart*. And
    when I install them, they are all part of the same *installation*. The same chart
    can be installed more than once (with a different name each time). Thus, I may
    have multiple installations of the same chart, just as I might have multiple resources
    of the same Kubernetes resource type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表可能包含多个资源定义。Kubernetes 将每个资源视为独立的实体。但在 Helm 的视角中，图表定义的所有资源都是相关联的。例如，我的
    WordPress 应用可能有一个`Deployment`、一个`ConfigMap`、一个`Service`等等。但它们都属于同一个*图表*。当我安装它们时，它们都属于同一个*安装*。同一个图表可以安装多次（每次使用不同的名称）。因此，我可能会有同一个图表的多个安装，就像我可能会有同一种
    Kubernetes 资源类型的多个资源一样。
- en: And this brings us to one final term. Once we install our WordPress chart, we
    have an installation of that chart. Then we upgrade that chart using `helm upgrade`.
    Now, that installation has two releases. A new *release* of an installation is
    created each time we use Helm to modify the installation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引出最后一个术语。一旦安装我们的 WordPress 图表，我们就拥有了该图表的一个安装。然后我们使用 `helm upgrade` 升级该图表。现在，该安装就有了两个发布。每次我们使用
    Helm 修改安装时，都会创建一个新的*发布*。
- en: A release is created when we install a new version of WordPress. But a release
    is also created when we merely change the configuration of an installation, or
    when we rollback an installation. This is an important feature of Helm that we
    will see again in [Chapter 7](ch07.xhtml#chart_repositories).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装 WordPress 的新版本时，将创建一个发布。但是，仅仅更改安装配置或回滚安装时也会创建一个发布。这是 Helm 的一个重要特性，我们将在[第7章](ch07.xhtml#chart_repositories)中再次看到。
- en: A Brief Note About Helm 2
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 2 简介
- en: Those familiar with Helm 2 may notice certain concepts missing from this book.
    There is no mention of Tiller or gRPC. These things were removed from Helm 3,
    which is the subject of the present book. Also, this version of the book focuses
    on version 2 Helm charts. As confusing as it is, the Helm chart version increments
    separately from the Helm version. So Helm v2 used Helm Charts v1, and Helm v3
    uses Helm Charts v2\. These differ in a few important ways from version 1 Helm
    Charts—most notably in the way dependencies are declared. Helm 2 and Helm Charts
    v1 are considered deprecated.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Helm 2 的人可能会注意到本书中缺少某些概念。书中没有提到 Tiller 或 gRPC。这些东西已经从 Helm 3 中移除，而 Helm 3
    则是本书的主题。此外，本书的这个版本侧重于 Helm Charts 的第 2 版。尽管这很令人困惑，但 Helm Chart 的版本增量与 Helm 版本是分开的。因此，Helm
    v2 使用 Helm Charts v1，而 Helm v3 使用 Helm Charts v2。这些与 Helm Charts 第 1 版在声明依赖项方式上有几个重要的不同。Helm
    2 和 Helm Charts v1 被视为不推荐使用。
- en: Conclusion
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: The material here should prepare you for the coming chapters. But we hope it
    also provided insight into why we built Helm the way we did. Helm is only successful
    if it makes Kubernetes more usable both for the first-time users and for the long-time
    operations teams and SREs that use Helm day to day. The remainder of this book
    is dedicated to explaining (with lots of examples) how to get the most out of
    Helm—and how to do so securely and idiomatically.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的材料应该为你准备好接下来的章节。但我们也希望它能让你了解为什么我们按照这样的方式构建了Helm。Helm 的成功仅在于它能够使 Kubernetes
    对于初次使用者和长期操作团队以及每天使用 Helm 的 SRE 更加易用。本书的其余部分致力于通过大量示例来解释如何充分利用 Helm，以及如何在安全和习惯的情况下这样做。
