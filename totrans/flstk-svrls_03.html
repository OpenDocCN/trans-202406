<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Creating Your First App"><div class="chapter" id="ch3">
<h1><span class="label">Chapter 3. </span>Creating Your First App</h1>


<p>In <a data-type="xref" href="ch02.xhtml#ch2">Chapter 2</a>, you created a basic API layer using a combination of API Gateway and serverless functions. This combination is very powerful, but you have not yet interacted with a real database.</p>

<p><a data-type="indexterm" data-primary="CRUD+L (create, read, update, delete, and list)" id="idm45364348275352"/>In this chapter, you will be creating a GraphQL API that interacts with a DynamoDB NoSQL database to perform CRUD+L (create, read, update, delete, and list) operations. You’ll learn what GraphQL is, why developers are adopting it, and how it works.</p>

<p>We will be building a notes app that will allow users to create, update, and delete notes. It will also have GraphQL subscriptions enabled in order to see updates in real time. If another user is interacting with the app and they create a new note, our app will update with the new values in real time.</p>






<section data-type="sect1" data-pdf-bookmark="Introduction to GraphQL"><div class="sect1" id="idm45364348273384">
<h1>Introduction to GraphQL</h1>

<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="about" id="idm45364348271944"/>GraphQL is an API implementation that is an alternative to REST. Let’s have a look at what GraphQL is, what a GraphQL API consists of, and how GraphQL works.</p>








<section data-type="sect2" data-pdf-bookmark="What Is GraphQL?"><div class="sect2" id="idm45364348270536">
<h2>What Is GraphQL?</h2>

<p>GraphQL is an API specification. It is a query language for APIs and a runtime for fulfilling those queries with your data. It is, and can be used as, a replacement for REST and has some similarities to REST.</p>

<p><a data-type="indexterm" data-primary="over-fetching" id="idm45364348268728"/><a data-type="indexterm" data-primary="under-fetching" id="idm45364348268024"/><a data-type="indexterm" data-primary="Facebook" id="idm45364348267352"/>GraphQL was introduced by Facebook in 2015, <a href="https://oreil.ly/KtnOq">though it had been used internally since 2012</a>. GraphQL allows clients to define the structure of the data that is required from an API call so that they can know exactly what data structure is going to be returned from the server. Requesting data in this way enables a much more efficient way for client-side applications to interact with backend APIs and services, reducing the amount of under-fetching of data, preventing the over-fetching of data, and preventing type errors.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="What Makes Up a GraphQL API?"><div class="sect2" id="idm45364348265192">
<h2>What Makes Up a GraphQL API?</h2>

<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="API" id="idm45364348263816"/><a data-type="indexterm" data-primary="APIs" data-secondary="GraphQL" id="idm45364348262840"/>A GraphQL API consists of three main parts: schema, resolvers, and data sources, as illustrated in <a data-type="xref" href="#fig3a">Figure 3-1</a>.</p>

<figure><div id="fig3a" class="figure">
<img src="Images/fssl_0301.png" alt="GraphQL API Design" width="847" height="230"/>
<h6><span class="label">Figure 3-1. </span>GraphQL API Design</h6>
</div></figure>

<p>The<a data-type="indexterm" data-primary="schema" id="idm45364348258440"/><a data-type="indexterm" data-primary="SDL (Schema Definition Language)" id="idm45364348257704"/> schema, written in GraphQL Schema Definition Language (SDL), defines the data model (types) and operations that can be executed against the API. The schema consists of base types (data models) and GraphQL operations like queries for fetching data; mutations for creating, updating, and deleting data; and subscriptions for subscribing to changes in data in real time.</p>

<p>Here is an example of a GraphQL schema:</p>

<pre data-type="programlisting"># base type
type Todo {
  id: ID
  name: String
  completed: Boolean
}

# Query definitions
type Query {
  getTodo(id: ID): Todo
  listTodos: [Todo]
}

# Mutation definitions
type Mutation {
  createTodo(input: Todo): Todo
}

# Subscription definitions
type Subscription {
  onCreateTodo: Todo
}</pre>

<p>Once the schema has been created, you can begin writing resolvers for the GraphQL operations defined in the schema (query, mutation, subscription). GraphQL resolvers tell the GraphQL operations what to do when being executed and will typically interact with some data source or another API, as shown in <a data-type="xref" href="#fig3b">Figure 3-2</a>.</p>

<figure><div id="fig3b" class="figure">
<img src="Images/fssl_0302.png" alt="How GraphQL Works" width="1020" height="508"/>
<h6><span class="label">Figure 3-2. </span>How GraphQL works</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="GraphQL Operations"><div class="sect2" id="idm45364348251512">
<h2>GraphQL Operations</h2>

<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="operations" id="idm45364348250008"/><a data-type="indexterm" data-primary="operations" data-secondary="GraphQL" id="idm45364348249032"/>GraphQL operations are how you interact with the API data sources. GraphQL operations can be similarly mapped to HTTP methods for RESTful APIs:</p>

<pre data-type="programlisting">GET -&gt; Query
PUT -&gt; Mutation
POST -&gt; Mutation
DELETE -&gt; Mutation
PATCH -&gt; Mutation</pre>

<p>A GraphQL request operation looks similar to a JavaScript object with only the keys and no values. The keys and values are returned in the GraphQL operation response. Here’s an example of a typical GraphQL query fetching an array of items:</p>

<pre data-type="programlisting">query {
  listTodos {
    id
    name
    completed
  }
}</pre>

<p>This request would return the following response:</p>

<pre data-type="programlisting">{
  "data": {
    "listTodos": [
      { "id": "0", "name": "buy groceries", "completed": false },
      { "id": "1", "name": "exercise", "completed": true }
    ]
  }
}</pre>

<p>You can also pass arguments into a GraphQL operation. The following operation is a query for a <code>Todo</code>, passing in the ID of the <code>Todo</code> we’d like to fetch:</p>

<pre data-type="programlisting">query {
  getTodo(id: "0") {
    name
    completed
  }
}</pre>

<p>This request would return the following response:</p>

<pre data-type="programlisting">{
  "data": {
    "getTodo": {
      "name": "buy groceries"
      "completed": false
    }
  }
}</pre>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="about" id="idm45364348240616"/>Though there are many ways to implement a GraphQL server, in this book we will be using AWS AppSync. AppSync is a managed service that allows us to deploy a GraphQL API, resolvers, and data sources quickly and easily using the Amplify CLI.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Creating the GraphQL API"><div class="sect1" id="idm45364348250856">
<h1>Creating the GraphQL API</h1>

<p><a data-type="indexterm" data-primary="creating" data-secondary="GraphQL API" id="idm45364348237720"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="creating" id="idm45364348236744"/>Now that you have a basic understanding of what GraphQL is, let’s go ahead and start using it to build the Notes app.</p>

<p><a data-type="indexterm" data-primary="UUID (universally unique identifier)" id="idm45364348235288"/>The first thing you need to do is create a new React application and install the necessary dependencies. This app will be using the AWS Amplify library to interact with the API, <code>uuid</code> for creating unique <code>id</code>s, and the Ant Design library for styling:</p>

<pre data-type="programlisting">~ npx create-react-app notesapp
~ cd notesapp
~ npm install aws-amplify antd uuid</pre>

<p>Now, within the root of the new app, you can create the Amplify project:</p>

<pre data-type="programlisting">~ amplify init

? Enter a name for the project: notesapp
? Enter a name for the environment: dev
? Choose your default editor: &lt;your editor of choice&gt;
? Choose the type of app that you're building: javascript
? What javascript framework are you using: react
? Source Directory Path: src
? Distribution Directory Path: build
? Build Command: npm run-script build
? Start Command: npm run-script start
? Do you want to use an AWS profile? Y</pre>

<p>With the Amplify project initialized, we can then add the GraphQL API:</p>

<pre data-type="programlisting">~ amplify add api

? Please select from one of the below mentioned services: GraphQL
? Provide API name: notesapi
? Choose the default authorization type for the API: API Key
? Enter a description for the API key: public (or some description)
? After how many days from now the API key should expire: 365 (or your
  preferred expiration)
? Do you want to configure advanced settings for the GraphQL API: N
? Do you have an annotated GraphQL schema? N
? Do you want a guided schema creation? Y
? What best describes your project: Single object with fields
? Do you want to edit the schema now? Y</pre>

<p>Next, open the base GraphQL schema (generated by the CLI), located at <em>notesapp/amplify/backend/api/notesapi/schema.graphql</em>, in your text editor. Update the schema to the following, and save it:</p>

<pre data-type="programlisting">type Note @model {
  id: ID!
  clientId: ID
  name: String!
  description: String
  completed: Boolean
}</pre>

<p>This schema has a main <code>Note</code> type containing five fields. A field can be either nullable (not required) or non-nullable (required). A non-nullable field is specified with a <code>!</code> character.</p>

<p><a data-type="indexterm" data-primary="@model directive" id="idm45364348225816"/>The <code>Note</code> type in this schema is annotated with an <code>@model</code> directive. This directive is not part of the GraphQL SDL; instead, it is part of the AWS Amplify GraphQL Transform library.</p>

<p><a data-type="indexterm" data-primary="Amplify GraphQL Transform library" id="idm45364348223656"/><a data-type="indexterm" data-primary="GraphQL Transform library" id="idm45364348222936"/>The GraphQL Transform library allows you to annotate a GraphQL schema with different directives like <code>@model</code>, <code>@connection</code>, <code>@auth</code>, and others.</p>

<p>The <code>@model</code> directive we used in this schema will transform the base <code>Note</code> type into an expanded AWS AppSync GraphQL API complete with:</p>
<ol class="less_space pagebreak-before">
<li>
<p>Additional schema definitions for queries and mutations (<code>Create</code>, <code>Read</code>, <code>Update</code>, <code>Delete</code>, and <code>List</code> operations)</p>
</li>
<li>
<p>Additional schema definitions for GraphQL subscriptions</p>
</li>
<li>
<p>DynamoDB database</p>
</li>
<li>
<p>Resolver code for all GraphQL operations mapped to DynamoDB database</p>
</li>

</ol>

<p><a data-type="indexterm" data-primary="push command" id="idm45364348212184"/><a data-type="indexterm" data-primary="deploying" data-secondary="GraphQL API" id="idm45364348211480"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="deploying" id="idm45364348210536"/>To deploy the API, you can run the <code>push</code> command:</p>

<pre data-type="programlisting">~ amplify push

? Are you sure you want to continue? Yes
? Do you want to generate code for your newly created GraphQL API: Yes
? Choose the code generation language target: javascript
? Enter the file name pattern of graphql queries, mutations and
  subscriptions: src/graphql/**/*.js
? Do you want to generate/update all possible GraphQL operations -
  queries, mutations and subscriptions: Y
? Enter maximum statement depth [increase from default if your schema is
  deeply nested]: 2</pre>

<p>Once the deployment has completed, the API and database have successfully been created in your account. Next, let’s open the newly created AppSync API in the AWS Console and test out a few GraphQL operations.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Viewing and Interacting with the GraphQL API"><div class="sect1" id="idm45364348238664">
<h1>Viewing and Interacting with the GraphQL API</h1>

<p><a data-type="indexterm" data-primary="GraphQL API" data-secondary="viewing" id="idm45364348205688"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="interacting with" id="idm45364348204712"/><a data-type="indexterm" data-primary="viewing GraphQL API" id="idm45364348203768"/>To open the API in the AWS Console at any time, you can use the following <span class="keep-together">command:</span></p>

<pre data-type="programlisting">- amplify console api

&gt; Choose GraphQL</pre>

<p>Once you’ve opened the AppSync console, click Queries in the lefthand menu to open the query editor. Here, you can test out GraphQL queries, mutations, and subscriptions using your API.</p>

<p>The first operation we’ll try out is a mutation to create a new note. In the query editor, execute the following mutation (see <a data-type="xref" href="#fig3c">Figure 3-3</a>):</p>

<pre data-type="programlisting">mutation createNote {
  createNote(input: {
    name: "Book flight"
    description: "Flying to Paris on June 1 returning June 10"
    completed: false
  }) {
    id name description completed
  }
}</pre>

<figure><div id="fig3c" class="figure">
<img src="Images/fssl_0303.png" alt="GraphQL mutation" width="1330" height="708"/>
<h6><span class="label">Figure 3-3. </span>GraphQL mutation</h6>
</div></figure>

<p>Now that you’ve created an item, you can try querying for it. Let’s try to query for all of the notes in the app:</p>

<pre data-type="programlisting">query listNotes {
  listNotes {
    items {
      id
      name
      description
      completed
    }
  }
}</pre>

<p>You can also try querying for a single note using the ID of one of the notes:</p>

<pre data-type="programlisting">query getNote {
  getNote(id: "&lt;NOTE_ID&gt;") {
    id
    name
    description
    completed
  }
}</pre>

<p>Now that we know the GraphQL API is deployed and functioning properly, let’s start writing some frontend code.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Building the React Application"><div class="sect1" id="idm45364348206632">
<h1>Building the React Application</h1>

<p><a data-type="indexterm" data-primary="creating" data-secondary="React application" id="cre_rea"/><a data-type="indexterm" data-primary="React application" data-secondary="creating" id="rea_cre"/>The first thing you will need to do is configure the React application to recognize the Amplify resources located at <em>src/aws-exports.js</em>. To do so, open <em>src/index.js</em> and add the following below the last import:</p>

<pre data-type="programlisting">import Amplify from 'aws-amplify'
import config from './aws-exports'
Amplify.configure(config)</pre>








<section data-type="sect2" data-pdf-bookmark="Listing Notes (GraphQL Query)"><div class="sect2" id="idm45364348187864">
<h2>Listing Notes (GraphQL Query)</h2>

<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="queries" id="gql_q"/><a data-type="indexterm" data-primary="listing notes" id="ln_ab"/><a data-type="indexterm" data-primary="notes" data-secondary="listing" id="n_li"/>Now that the application has been configured, you can begin making calls against the GraphQL API. The first operation we will be implementing will be a query to list all of the notes.</p>

<p>The query will return an array and we will map over all of the items in the array, showing the note name, description, and whether or not it is completed.</p>

<p>In <em>src/App.js</em>, first import the following at the top of the file:</p>

<pre data-type="programlisting">import React, {useEffect, useReducer} from 'react'
import { API } from 'aws-amplify'
import { List } from 'antd'
import 'antd/dist/antd.css'
import { listNotes } from './graphql/queries'</pre>

<p><a data-type="indexterm" data-primary="APIs" data-secondary="defined" id="idm45364348179592"/><a data-type="indexterm" data-primary="List" id="idm45364348178616"/><a data-type="indexterm" data-primary="listNotes" id="idm45364348177944"/><a data-type="indexterm" data-primary="useReducer hook" id="idm45364348177272"/>Let’s take a look at some of the terms used in the preceding:</p>
<dl>
<dt><code>useEffect</code> and <code>useReducer</code></dt>
<dd>
<p>React hooks</p>
</dd>
<dt><code>API</code></dt>
<dd>
<p>This is the GraphQL client that we will be using to interact with the AppSync endpoint (similar to <code>fetch</code> or <code>axios</code>)</p>
</dd>
<dt><code>List</code></dt>
<dd>
<p>UI component from the Ant Design library to render a list</p>
</dd>
<dt><code>listNotes</code></dt>
<dd>
<p>The GraphQL query operation for fetching an array of notes</p>
</dd>
</dl>

<p>Next, we will need to create a variable to hold our initial application state. Because our application will be holding and working with multiple state variables, we will use the <code>useReducer</code> hook from React to manage state.</p>

<p class="less_space pagebreak-before"><code>useReducer</code> has the following API:</p>

<pre data-type="programlisting">const [state, dispatch] = useReducer(reducer &lt;function&gt;, initialState &lt;any&gt;)</pre>

<p><code>useReducer</code> accepts a reducer function of type <code>(state, action) =&gt; newState</code> and <code>initialState</code> as arguments:</p>

<pre data-type="programlisting">/* Example of some basic state */
const initialState = { notes: [] }

/* Example of a basic reducer */
function reducer(state, action) {
  switch(action.type) {
    case 'SET_NOTES':
      return { ...state, notes: action.notes }
    default:
      return state
  }
}

/* Implementing useReducer */
const [state, dispatch] = useReducer(reducer: &lt;function&gt;, initialState: &lt;any&gt;)

/* Sending an update to the reducer */
const notes = [{ name: 'Hello World' }]
dispatch({ type: 'SET_NOTES', notes: notes })

/* Using the state in your app */
{
  state.notes.map(note =&gt; &lt;p&gt;{note.name}&lt;/p&gt;)
}</pre>

<p>When invoked, the <code>useReducer</code> hook returns an array containing two items:</p>

<ul>
<li>
<p>The application state</p>
</li>
<li>
<p>A <code>dispatch</code> function (this function allows you to update the application state)</p>
</li>
</ul>

<p>The initial state of our Notes application will hold an array for the notes, form values, error, and loading state.</p>

<p>In <em>src/App.js</em>, add the following <code>initialState</code> object after the last import:</p>

<pre data-type="programlisting">const initialState = {
  notes: [],
  loading: true,
  error: false,
  form: { name: '', description: '' }
}</pre>

<p class="less_space pagebreak-before">Then create<a data-type="indexterm" data-primary="creating" data-secondary="reducers" id="idm45364347864600"/><a data-type="indexterm" data-primary="reducers, creating" id="idm45364347863752"/> the reducer. For now, the reducer will only have cases to either set the notes array or set an error state:</p>

<pre data-type="programlisting">function reducer(state, action) {
  switch(action.type) {
    case 'SET_NOTES':
      return { ...state, notes: action.notes, loading: false }
    case 'ERROR':
      return { ...state, loading: false, error: true }
    default:
      return state
  }
}</pre>

<p>Next, update the main <code>App</code> function to create the state and dispatch variables by calling <code>useReducer</code> and passing in the <code>reducer</code> and <code>initialState</code>:</p>

<pre data-type="programlisting">export default function App() {
  const [state, dispatch] = useReducer(reducer, initialState)
}</pre>

<p><a data-type="indexterm" data-primary="fetchNotes function" id="idm45364347859080"/>To fetch the notes, create a <code>fetchNotes</code> function (in the main <code>App</code> function) that will call the AppSync API and set the notes array once the API call is successful:</p>

<pre data-type="programlisting">async function fetchNotes() {
  try {
    const notesData = await API.graphql({
      query: listNotes
    })
    dispatch({ type: 'SET_NOTES', notes: notesData.data.listNotes.items })
  } catch (err) {
    console.log('error: ', err)
    dispatch({ type: 'ERROR' })
  }
}</pre>

<p><a data-type="indexterm" data-primary="App function" id="idm45364347856296"/>Now, invoke the <code>fetchNotes</code> function by implementing the <code>useEffect</code> hook (in the main <code>App</code> function):</p>

<pre data-type="programlisting">useEffect(() =&gt; {
  fetchNotes()
}, [])</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="indexterm" data-primary="useEffect hook" id="idm45364347852776"/><code>useEffect</code> is similar to <code>componentDidMount</code>. <code>useEffect</code> will run after the initial render of the component is committed to the screen. The second argument to <code>useEffect</code> is an array of values, the effect of which depends on whether it is called again during a re-render. If the array is empty, it will not be called on additional renders. If the array contains values and those values change, the component will re-render.</p>
</div>

<p>The next thing you need to do is return the main UI for the component. In the main <code>App</code> function, add the following:</p>

<pre data-type="programlisting">return (
  &lt;div style={styles.container}&gt;
    &lt;List
      loading={state.loading}
      dataSource={state.notes}
      renderItem={renderItem}
    /&gt;
  &lt;/div&gt;
)</pre>

<p>Here we are using the <code>List</code> component from Ant Design. This component will map over an array (<code>dataSource</code>) and return an item for each item in the array by calling the <code>renderItem</code> function. Next, define <code>renderItem</code> (in the main <code>App</code> function):</p>

<pre data-type="programlisting">function renderItem(item) {
  return (
    &lt;List.Item style={styles.item}&gt;
      &lt;List.Item.Meta
        title={item.name}
        description={item.description}
      /&gt;
    &lt;/List.Item&gt;
  )
}</pre>

<p>Finally, create the styles for the components we will be using for this app:</p>

<pre data-type="programlisting">const styles = {
  container: {padding: 20},
  input: {marginBottom: 10},
  item: { textAlign: 'left' },
  p: { color: '#1890ff' }
}</pre>

<p><a data-type="indexterm" data-primary="start command" id="idm45364347842840"/>Now we are ready to run the app! In the terminal, run the <code>start</code> command:</p>

<pre data-type="programlisting">~ npm start</pre>

<p>When the app loads, you should see the current list of notes rendered to your screen, as illustrated in<a data-type="indexterm" data-primary="" data-startref="gql_q" id="idm45364347840264"/><a data-type="indexterm" data-primary="" data-startref="ln_ab" id="idm45364347839288"/><a data-type="indexterm" data-primary="" data-startref="n_li" id="idm45364347838344"/> <a data-type="xref" href="#fig3d">Figure 3-4</a>.</p>

<figure><div id="fig3d" class="figure">
<img src="Images/fssl_0304.png" alt="Notes List" width="1100" height="521"/>
<h6><span class="label">Figure 3-4. </span>Notes list</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating Notes (GraphQL Mutation)"><div class="sect2" id="idm45364348186920">
<h2>Creating Notes (GraphQL Mutation)</h2>

<p><a data-type="indexterm" data-primary="creating" data-secondary="notes" id="idm45364347832904"/><a data-type="indexterm" data-primary="notes" data-secondary="creating" id="idm45364347832024"/><a data-type="indexterm" data-primary="GraphQL" data-secondary="mutations" id="idm45364347831080"/>Now that you know how to query for a list of notes, let’s take a look at how to <em>create</em> a new note. To do so, you’ll need the following:</p>
<ol>
<li>
<p>A form to create a new note</p>
</li>
<li>
<p>A function to update the state as the user types into the form</p>
</li>
<li>
<p>A function to add the new note to the UI and send an API call to create a new note</p>
</li>

</ol>

<p><a data-type="indexterm" data-primary="UUID (universally unique identifier)" id="idm45364347826104"/><a data-type="indexterm" data-primary="unique identifier" id="idm45364347825336"/>First, import the UUID library so you can create a unique identifier for the client. We do this now so that later on when we implement subscriptions we can identify the client that created the note. We will also import the <code>Input</code> and <code>Button</code> components from Ant Design:</p>

<pre data-type="programlisting">import { v4 as uuid } from 'uuid'
import { List, Input, Button } from 'antd'</pre>

<p>Next, you will need to import the <code>createNote</code> mutation definition:</p>

<pre data-type="programlisting">import { createNote as CreateNote } from './graphql/mutations'</pre>

<p>Then, create a new <code>CLIENT_ID</code> variable below the last import:</p>

<pre data-type="programlisting">const CLIENT_ID = uuid()</pre>

<p>Update the switch statement in the reducer to add three new cases. We will need a new case for the following three actions:</p>
<ol class="less_space pagebreak-before">
<li>
<p>Adding a new note to the local state</p>
</li>
<li>
<p>Resetting the form state to clear out the form</p>
</li>
<li>
<p>Updating the form state when the user types</p>
</li>

</ol>

<pre data-type="programlisting">case 'ADD_NOTE':
  return { ...state, notes: [action.note, ...state.notes]}
case 'RESET_FORM':
  return { ...state, form: initialState.form }
case 'SET_INPUT':
  return { ...state, form: { ...state.form, [action.name]: action.value } }</pre>

<p>Next, create the <code>createNote</code> function in the main <code>App</code> function:</p>

<pre data-type="programlisting">async function createNote() {
  const { form } = state
  if (!form.name || !form.description) {
     return alert('please enter a name and description')
  }
  const note = { ...form, clientId: CLIENT_ID, completed: false, id: uuid() }
  dispatch({ type: 'ADD_NOTE', note })
  dispatch({ type: 'RESET_FORM' })
  try {
    await API.graphql({
      query: CreateNote,
      variables: { input: note }
    })
    console.log('successfully created note!')
  } catch (err) {
    console.log("error: ", err)
  }
}</pre>

<p><a data-type="indexterm" data-primary="optimistic response" id="idm45364347811592"/><a data-type="indexterm" data-primary="catch block" id="idm45364347810888"/>In this function, we are updating the local state before the API call is successful. This is known as an <em>optimistic response</em>. It is done because we want the UI to be fast and to update as soon as the user adds a new note. If the API call fails, you can then implement some functionality in the <code>catch</code> block to notify the user of the error if you would like.</p>

<p>Now, create an <code>onChange</code> handler in the main <code>App</code> function to update the form state when the user interacts with an input:</p>

<pre data-type="programlisting">function onChange(e) {
  dispatch({ type: 'SET_INPUT', name: e.target.name, value: e.target.value })
}</pre>

<p>Finally, we will update the UI to add the form components. Before the <code>List</code> component, add the following two inputs and button:</p>

<pre data-type="programlisting" class="less_space pagebreak-before">&lt;Input
  onChange={onChange}
  value={state.form.name}
  placeholder="Note Name"
  name='name'
  style={styles.input}
/&gt;
&lt;Input
  onChange={onChange}
  value={state.form.description}
  placeholder="Note description"
  name='description'
  style={styles.input}
/&gt;
&lt;Button
  onClick={createNote}
  type="primary"
&gt;Create Note&lt;/Button&gt;</pre>

<p>Now, we should be able to create new notes using the form, as shown in <a data-type="xref" href="#fig3e">Figure 3-5</a>.</p>

<figure><div id="fig3e" class="figure">
<img src="Images/fssl_0305.png" alt="Creating a note" width="1268" height="1053"/>
<h6><span class="label">Figure 3-5. </span>Creating a note</h6>
</div></figure>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Deleting Notes (GraphQL Mutation)"><div class="sect2" id="idm45364347833560">
<h2>Deleting Notes (GraphQL Mutation)</h2>

<p><a data-type="indexterm" data-primary="deleteNote function" id="idm45364347799688"/><a data-type="indexterm" data-primary="deleting" data-secondary="notes" id="idm45364347798984"/><a data-type="indexterm" data-primary="notes" data-secondary="deleting" id="idm45364347798040"/><a data-type="indexterm" data-primary="GraphQL" data-secondary="mutations" id="idm45364347797096"/>Next, let’s take a look at how to <em>delete</em> a note. To do so, we’ll need the following:</p>
<ol>
<li>
<p>A <code>deleteNote</code> function to delete the note both from the UI and from the GraphQL API</p>
</li>
<li>
<p>A button in each note to invoke the <code>deleteNote</code> function</p>
</li>

</ol>

<p>First, import the <code>deleteNote</code> mutation:</p>

<pre data-type="programlisting">import {
  createNote as CreateNote,
  deleteNote as DeleteNote
} from './graphql/mutations'</pre>

<p>Then, create a <code>deleteNote</code> function in the main <code>App</code> function:</p>

<pre data-type="programlisting">async function deleteNote({ id }) {
  const index = state.notes.findIndex(n =&gt; n.id === id)
  const notes = [
    ...state.notes.slice(0, index),
    ...state.notes.slice(index + 1)];
  dispatch({ type: 'SET_NOTES', notes })
  try {
    await API.graphql({
      query: DeleteNote,
      variables: { input: { id } }
    })
    console.log('successfully deleted note!')
    } catch (err) {
      console.log({ err })
  }
}</pre>

<p>In this function, we are finding the index of the note and creating a new notes array without the deleted note. We then dispatch the <code>SET_NOTES</code> action passing in the new notes array to update the local state and show an optimistic response. Next, we call the GraphQL API to delete the note in the AppSync API.</p>

<p><a data-type="indexterm" data-primary="renderItems function" id="idm45364347786728"/>Now, update the <code>List.Item</code> component in the <code>renderItem</code> function to add a delete button to the <code>actions</code> prop that will call the <code>deleteNote</code> function, passing in the item:</p>

<pre data-type="programlisting">&lt;List.Item
  style={styles.item}
  actions={[
    &lt;p style={styles.p} onClick={() =&gt; deleteNote(item)}&gt;Delete&lt;/p&gt;
  ]}
&gt;
  &lt;List.Item.Meta
   title={item.name}
   description={item.description}
  /&gt;
&lt;/List.Item&gt;</pre>

<p>Now, we should be able to delete notes (see <a data-type="xref" href="#fig3f">Figure 3-6</a>).</p>

<figure><div id="fig3f" class="figure">
<img src="Images/fssl_0306.png" alt="Deleting a note" width="1253" height="737"/>
<h6><span class="label">Figure 3-6. </span>Deleting a note</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Updating Notes (GraphQL Mutation)"><div class="sect2" id="idm45364347800872">
<h2>Updating Notes (GraphQL Mutation)</h2>

<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="mutations" id="idm45364347778344"/><a data-type="indexterm" data-primary="notes" data-secondary="updating" id="idm45364347777368"/><a data-type="indexterm" data-primary="updating" data-secondary="notes" id="idm45364347776424"/><a data-type="indexterm" data-primary="updateNote function" id="idm45364347775480"/>The next piece of functionality we want to add is the ability to <em>update</em> a note to be completed. To do so, you’ll need the following:</p>
<ol>
<li>
<p>An <code>updateNote</code> function to update the note in the UI and in the GraphQL API</p>
</li>
<li>
<p>A button in each note to invoke the <code>updateNote</code> function</p>
</li>

</ol>

<p>First, import the <code>updateNote</code> mutation:</p>

<pre data-type="programlisting">import {
  updateNote as UpdateNote,
  createNote as CreateNote,
  deleteNote as DeleteNote
} from './graphql/mutations'</pre>

<p><a data-type="indexterm" data-primary="App function" id="idm45364347768920"/>Next, create an <code>updateNote</code> function in the main <code>App</code> function:</p>

<pre data-type="programlisting">async function updateNote(note) {
  const index = state.notes.findIndex(n =&gt; n.id === note.id)
  const notes = [...state.notes]
  notes[index].completed = !note.completed
  dispatch({ type: 'SET_NOTES', notes})
  try {
    await API.graphql({
      query: UpdateNote,
      variables: { input: { id: note.id, completed: notes[index].completed } }
    })
    console.log('note successfully updated!')
  } catch (err) {
    console.log('error: ', err)
  }
}</pre>

<p>In this function, we are first finding the index of the selected note, then creating a copy of the notes array. We then update the completed value of the selected note to be the opposite of what it currently is. We then update the notes array with the new version of the note, set the notes array in the local state, and call the GraphQL API, passing in the note that needs to be updated in the API.</p>

<p>Finally, update the <code>List.Item</code> component to add an update button that will call the <code>updateNote</code> function, passing in the item. This component will render either <code>completed</code> or <code>mark complete</code> depending on the value of the <code>completed</code> Boolean of the item (based on whether <code>completed</code> is true or false):</p>

<pre data-type="programlisting">&lt;List.Item
  style={styles.item}
  actions={[
    &lt;p style={styles.p} onClick={() =&gt; deleteNote(item)}&gt;Delete&lt;/p&gt;,
    &lt;p style={styles.p} onClick={() =&gt; updateNote(item)}&gt;
      {item.completed ? 'completed' : 'mark completed'}
    &lt;/p&gt;
  ]}
&gt;</pre>

<p>Now, we should be able to update notes to be either <em>completed</em> or <em>not completed</em> (see <a data-type="xref" href="#fig3g">Figure 3-7</a>).</p>

<figure><div id="fig3g" class="figure">
<img src="Images/fssl_0307.png" alt="Updating a note" width="1259" height="892"/>
<h6><span class="label">Figure 3-7. </span>Updating a note</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Real-Time Data (GraphQL Subscriptions)"><div class="sect2" id="idm45364347779256">
<h2>Real-Time Data (GraphQL Subscriptions)</h2>

<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="subscriptions" id="idm45364347755288"/><a data-type="indexterm" data-primary="real-time data" id="idm45364347754312"/>The last piece of functionality we will implement is the ability to <em>subscribe to updates in real time</em>. The update that we’d like to subscribe to is when a new note has been added. When this happens, the functionality we’d like to implement is to have our application receive that new note, update the notes array with the new note, and render the updated notes array to our screen.</p>

<p>To do this, you will be implementing a GraphQL subscription. With GraphQL subscriptions, you can subscribe to different events. These events are usually some type of mutation (on create, on update, on delete). When one of these events happens, the data from the event gets sent to the client that initialized the subscription. It is then up to you to handle the data that comes in on the client.</p>

<p><a data-type="indexterm" data-primary="useEffect hook" id="idm45364347751656"/>To make this work, you’ll only need to initialize the subscription in the <code>useEffect</code> hook and dispatch the <code>ADD_NOTE</code> type along with the note data when a subscription is fired.</p>

<p>First, import the <code>onCreateNote</code> subscription:</p>

<pre data-type="programlisting">import { onCreateNote } from './graphql/subscriptions'</pre>

<p class="less_space pagebreak-before">Next, update the <code>useEffect</code> hook with the following code:</p>

<pre data-type="programlisting">useEffect(() =&gt; {
  fetchNotes()
  const subscription = API.graphql({
    query: onCreateNote
  })
    .subscribe({
      next: noteData =&gt; {
        const note = noteData.value.data.onCreateNote
        if (CLIENT_ID === note.clientId) return
        dispatch({ type: 'ADD_NOTE', note })
      }
    })
    return () =&gt; subscription.unsubscribe()
}, [])</pre>

<p><a data-type="indexterm" data-primary="onCreateNote event" id="idm45364347745720"/>In this subscription, we are subscribing to the <code>onCreateNote</code> event. When a new note is created, this event gets triggered and the <code>next</code> function is invoked, passing in the <code>note</code> data as the parameter.</p>

<p>We take the note data and check to see if our client is the application that created the note. If our client created the note, we return without going any further. If we are not the client that created the note, we dispatch the <code>ADD_NOTE</code> action, passing in the note data from the subscription.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45364347756200">
<h1>Summary</h1>

<p>Congratulations, you’ve deployed your first serverless GraphQL application!</p>

<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="queries" id="idm45364347740744"/><a data-type="indexterm" data-primary="GraphQL" data-secondary="mutations" id="idm45364347739768"/><a data-type="indexterm" data-primary="GraphQL" data-secondary="subscriptions" id="idm45364347738824"/><a data-type="indexterm" data-primary="useEffect hook" id="idm45364347737880"/><a data-type="indexterm" data-primary="useReducer hook" id="idm45364347737208"/>Here are a few things to keep in mind from this chapter<a data-type="indexterm" data-primary="" data-startref="cre_rea" id="idm45364347736344"/><a data-type="indexterm" data-primary="" data-startref="rea_cre" id="idm45364347735400"/>:</p>

<ul>
<li>
<p>The <code>useEffect</code> hook is similar to <code>componentDidMount</code> from the React lifecycle methods in that it runs after the component first renders.</p>
</li>
<li>
<p>The <code>useReducer</code> hook allows you to manage application state and is preferable to <code>useState</code> when having more complex application logic.</p>
</li>
<li>
<p>GraphQL <em>queries</em> are used for fetching data in a GraphQL API.</p>
</li>
<li>
<p>GraphQL <em>mutations</em> are used for creating, updating, or deleting data in a GraphQL API.</p>
</li>
<li>
<p>You can subscribe to API real-time events in a GraphQL API by using GraphQL <em>subscriptions</em>.</p>
</li>
</ul>
</div></section>







</div></section></div>



  </body></html>