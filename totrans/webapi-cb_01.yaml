- en: Chapter 1\. Asynchronous APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of the APIs covered in this book are *asynchronous*. When you call one
    of these functions or methods, you might not get the result back right away. Different
    APIs have different mechanisms to get the result back to you when it’s ready.
  prefs: []
  type: TYPE_NORMAL
- en: Callback Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most basic asynchronous pattern is a *callback function*. This is a function
    that you pass to an asynchronous API. When the work is complete, it calls your
    callback with the result. Callbacks can be used on their own or as part of other
    asynchronous patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many browser APIs are *event* based. An event is something that happens asynchronously.
    Some examples of events are:'
  prefs: []
  type: TYPE_NORMAL
- en: A button was clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mouse was moved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A network request was completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event has a name, such as `click` or `mouseover`, and an object with data
    about the event that occurred. This might include information such as what element
    was clicked or an HTTP status code. When you listen for an event, you provide
    a callback function that receives the event object as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Objects that emit events implement the `EventTarget` interface, which provides
    the `addEventListener` and `removeEventListener` methods. To listen for an event
    on an element or other object, you can call `addEventListener` on it, passing
    the name of the event and a handler function. The callback is called every time
    the event is triggered until it is removed. A listener can be removed manually
    by calling `removeEventListener`, or in many cases listeners are automatically
    removed by the browser when objects are destroyed or removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many newer APIs use `Promise`s. A `Promise` is an object, returned from a function,
    that is a placeholder for the eventual result of the asynchronous action. Instead
    of listening for an event, you call `then` on a `Promise` object. You pass a callback
    function to `then` that is eventually called with the result as its argument.
    To handle errors, you pass another callback function to the `Promise`’s `catch`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: A `Promise` is *fulfilled* when the operation completes successfully, and it
    is *rejected* when there’s an error. The fulfilled value is passed as an argument
    to the `then` callback, or the rejected value is passed as an argument to the
    `catch` callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few key differences between events and `Promise`s:'
  prefs: []
  type: TYPE_NORMAL
- en: Event handlers are fired multiple times, whereas a `then` callback is executed
    only once. You can think of a `Promise` as a one-time operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you call `then` on a `Promise`, you’ll always get the result (if there is
    one). This is different from events where, if an event occurs before you add a
    listener, the event is lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Promise`s have a built-in error-handling mechanism. With events, you typically
    need to listen for an error event to handle error conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to call an API that uses `Promise`s and retrieve the result.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Call `then` on the `Promise` object to handle the result in a callback function.
    To handle potential errors, add a call to `catch`.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a function `getUsers` that makes a network request to load
    a list of users. This function returns a `Promise` that eventually resolves to
    the user list (see [Example 1-1](#promiseGetUsers)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1\. Using a `Promise`-based API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Promise` returned from `getUsers` is an object with a `then` method. When
    the user list is loaded, the callback passed to `then` is executed with the user
    list as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: This `Promise` also has a `catch` method for handling errors. If an error occurs
    while loading the user list, the callback passed to `catch` is called with the
    error object. Only one of these callbacks is called, depending on the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Loading an Image with a Fallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to load an image to display on the page. If there’s an error loading
    the image, you want to use a known good image URL as a fallback.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an `Image` element programmatically, and listen for its `load` and `error`
    events. If the `error` event triggers, replace it with the fallback image. Once
    either the requested image or the placeholder image loads, add it to the DOM when
    desired.
  prefs: []
  type: TYPE_NORMAL
- en: For a cleaner API, you can wrap this in a `Promise`. The `Promise` either resolves
    with an `Image` to be added or rejects with an error if neither the image nor
    the fallback can be loaded (see [Example 1-2](#example1-2)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-2\. Loading an image with a fallback
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `loadImage` function takes a URL and a fallback URL and returns a `Promise`.
    Then it creates a new `Image` and sets its `src` attribute to the given URL. The
    browser attempts to load the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three possible outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: Success case
  prefs: []
  type: TYPE_NORMAL
- en: If the image loads successfully, the `load` event is triggered. The event handler
    resolves the `Promise` with the `Image`, which can then be inserted into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback case
  prefs: []
  type: TYPE_NORMAL
- en: If the image fails to load, the `error` event is triggered. The error handler
    sets the `src` attribute to the fallback URL, and the browser attempts to load
    the fallback image. If *that* is successful, the `load` event fires and resolves
    the `Promise` with the fallback `Image`.
  prefs: []
  type: TYPE_NORMAL
- en: Failure case
  prefs: []
  type: TYPE_NORMAL
- en: If neither the image nor the fallback image could be loaded, the error handler
    rejects the `Promise` with the `error` event.
  prefs: []
  type: TYPE_NORMAL
- en: The `error` event is triggered every time there’s a load error. The handler
    first checks if it’s the fallback URL that failed. If so, this means that the
    original URL and fallback URL both failed to load. This is the failure case, so
    the `Promise` is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: If it’s not the fallback URL, this means the requested URL failed to load. Now
    it sets the fallback URL and tries to load that.
  prefs: []
  type: TYPE_NORMAL
- en: The order of checks here is important. Without that first check, if the fallback
    fails to load, the error handler would trigger an infinite loop of setting the
    (invalid) fallback URL, requesting it, and firing the `error` event again.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-3](#example1-3) shows how to use this `loadImage` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-3\. Using the `loadImage` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Chaining Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to call several `Promise`-based APIs in sequence. Each operation depends
    on the result of the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a chain of `Promise`s to run the asynchronous tasks in sequence. Imagine
    a blog application with two APIs, both of which return `Promise`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getUser(id)`'
  prefs: []
  type: TYPE_NORMAL
- en: Loads a user with the given user ID
  prefs: []
  type: TYPE_NORMAL
- en: '`getPosts(user)`'
  prefs: []
  type: TYPE_NORMAL
- en: Loads all the blog posts for a given user
  prefs: []
  type: TYPE_NORMAL
- en: If you want to load the posts for a user, you first need to load the `user`
    object—you can’t call `getPosts` until the user details are loaded. You can do
    this by chaining the two `Promise`s together, as shown in [Example 1-4](#promiseChain).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-4\. Using a `Promise` chain
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The value returned from a `Promise`’s `then` handler is wrapped in a new `Promise`.
    This `Promise` is returned from the `then` method itself. This means the return
    value of `then` is also a `Promise`, so you can chain another `then` onto it.
    This is how you create a chain of `Promise`s.
  prefs: []
  type: TYPE_NORMAL
- en: '`getUser` returns a `Promise` that resolves to the `user` object. The `then`
    handler calls `getPosts` and returns the resulting `Promise`, which is returned
    again from `then`, so you can call `then` once more to get the final result, the
    array of posts.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chain is a call to `catch` to handle any errors. This works
    like a `try`/`catch` block. If an error occurs at any point within the chain,
    the `catch` handler is called with that error and the rest of the chain does not
    get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Using the async and await Keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working with an API that returns a `Promise`, but you want the code
    to read in a more linear, or synchronous, fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `await` keyword with the `Promise` instead of calling `then` on it (see
    [Example 1-5](#example1-5)). Consider again the `getUsers` function from [“Working
    with Promises”](#recipePromises). This function returns a `Promise` that resolves
    to a list of users.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-5\. Using the `await` keyword
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`await` is an alternative syntax for working with `Promise`s. Instead of calling
    `then` with a callback that takes the result as its argument, the expression effectively
    “pauses” execution of the rest of the function and returns the result when the
    `Promise` is fulfilled.'
  prefs: []
  type: TYPE_NORMAL
- en: If the `Promise` is rejected, the `await` expression throws the rejected value.
    This is handled with a standard `try`/`catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Using Promises in Parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to execute a series of asynchronous tasks in parallel using `Promise`s.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Collect all the `Promise`s, and pass them to `Promise.all`. This function takes
    an array of `Promise`s and waits for them all to complete. It returns a new `Promise`
    that is fulfilled once all the given `Promise`s are fulfilled, or rejects if any
    of the given `Promise`s are rejected (see [Example 1-6](#loadMultipleUsers)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-6\. Loading multiple users with `Promise.all`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have multiple tasks that don’t depend on one another, `Promise.all` is
    a good choice. [Example 1-6](#loadMultipleUsers) calls `getUser` three times,
    passing a different user ID each time. It collects these `Promise`s into an array
    that is passed to `Promise.all`. All three requests run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.all` returns another `Promise`. Once all three users have loaded successfully,
    this new `Promise` becomes fulfilled with an array containing the loaded users.
    The index of each result corresponds to the index of the `Promise` in the input
    array. In this case, it returns an array with users `1`, `2`, and `3`, in that
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: What if one or more of these users failed to load? Maybe one of the user IDs
    doesn’t exist or there was a temporary network error. If *any* of the `Promise`s
    passed to `Promise.all` are rejected, the new `Promise` immediately rejects as
    well. The rejection value is the same as that of the rejected `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: If one of the users fails to load, the `Promise` returned by `Promise.all` is
    rejected with the error that occurred. The results of the other `Promise`s are
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: If you still want to get the results of any resolved `Promises` (or errors from
    other rejected ones), you can instead use `Promise.allSettled`. With `Promise.allSettled`,
    a new `Promise` is returned just like with `Promise.all`. However, this `Promise`
    is always fulfilled, once all of the `Promise`s are settled (either fulfilled
    *or* rejected).
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Example 1-7](#example1-7), the resolved value is an array whose
    elements each have a `status` property. This is either `fulfilled` or `rejected`,
    depending on the result of that `Promise`. If the status is `fulfilled`, the object
    also has a `value` property that is the resolved value. On the other hand, if
    the status is `rejected`, it instead has a `reason` property, which is the rejected
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-7\. Using `Promise.allSettled`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Animating an Element with requestAnimationFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to animate an element in a performant way using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `requestAnimationFrame` function to schedule your animation updates
    to run at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a `div` element that you want to hide with a fade animation.
    This is done by adjusting the opacity at regular intervals, using a callback passed
    to `request​A⁠nimationFrame` (see [Example 1-8](#fade_requestAnimationFrame)).
    The duration of each interval depends on the desired frames per second (FPS) of
    the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-8\. Fade-out animation using `requestAnimationFrame`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a good, performant way to animate elements using JavaScript that has
    good browser support. Because it’s done asynchronously, this animation won’t block
    the browser’s main thread. If the user switches to another tab, the animation
    is paused and `requestAnimationFrame` isn’t called unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: When you schedule a function to run with `requestAnimationFrame`, the function
    is called before the next repaint operation. How often this happens depends on
    the browser and screen refresh rate.
  prefs: []
  type: TYPE_NORMAL
- en: Before animating, [Example 1-8](#fade_requestAnimationFrame) does some calculations
    based on a given animation duration (2 seconds) and frame rate (60 frames per
    second). It calculates the total number of frames, and uses the duration to calculate
    how long each frame runs. If you want a different frame rate that doesn’t match
    the system refresh rate, this keeps track of when the last animation update was
    performed to maintain your target frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Then, based on the number of frames, it calculates the opacity adjustment made
    in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: The `fade` function is scheduled by passing it to a `requestAnimationFrame`
    call. Each time the browser calls this function, it passes a timestamp. The `fade`
    function calculates how much time has elapsed since the last frame. If not enough
    time has passed yet, it doesn’t do anything and asks the browser to call again
    next time around.
  prefs: []
  type: TYPE_NORMAL
- en: Once enough time has passed, it performs an animation step. It takes the calculated
    opacity adjustment and applies it to the element’s style. Depending on the exact
    timing, this could result in an opacity less than 0, which is invalid. This is
    fixed by using `Math.max` to set a minimum value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: If the opacity hasn’t reached 0 yet, more animation frames need to be performed.
    It calls `requestAnimationFrame` again to schedule the next execution.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to this method, newer browsers support the Web Animations
    API, which you’ll learn about in [Chapter 8](ch08.html#ch_webAnimationsApi). This
    API lets you specify keyframes with CSS properties, and the browser handles updating
    the intermediate values for you.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping an Event API in a Promise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to wrap an event-based API to return a `Promise`.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new `Promise` object and register event listeners within its constructor.
    When you receive the event you’re waiting for, resolve the `Promise` with the
    value. Similarly, reject the `Promise` if an error event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes this is called “promisifying” a function. [Example 1-9](#example1-9)
    demonstrates promisifying the `XMLHttpRequest` API.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-9\. Promisifying the `XMLHttpRequest` API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 1-10](#example1-10) shows how to use the promisified `loadJSON` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-10\. Using the `loadJSON` helper
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You create a `Promise` by calling the `Promise` *constructor function* with
    the `new` operator. This function receives two arguments, a `resolve` and `reject`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `resolve` and `reject` functions are supplied by the JavaScript engine.
    Within the `Promise` constructor, you do your asynchronous work and listen for
    events. When the `resolve` function is called, the `Promise` immediately resolves
    to that value. Calling `reject` works the same way—it rejects the `Promise` with
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own `Promise` can help these types of situations, but in general
    you usually don’t need to create them manually like this. If an API already returns
    a `Promise`, you don’t need to wrap that in your own `Promise`—just use it directly.
  prefs: []
  type: TYPE_NORMAL
