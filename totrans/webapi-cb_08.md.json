["```\n@keyframes fade {\n  from {\n    opacity: 0;\n  }\n\n  to {\n    opacity: 1;\n  }\n}\n\n.some-element {\n  animation: fade 250ms;\n}\n```", "```\nconst element = document.querySelector('.some-element');\nelement.animate([\n  { opacity: 0 },\n  { opacity: 1 }\n], {\n  // Animate for 250 milliseconds\n  duration: 250\n});\n```", "```\n.ripple-button {\n  position: relative;\n  overflow: hidden;\n}\n\n.ripple {\n  background: white;\n  pointer-events: none;\n  transform-origin: center;\n  opacity: 0;\n  position: absolute;\n  border-radius: 50%;\n  width: 150px;\n  height: 150px;\n}\n```", "```\nbutton.addEventListener('click', async event => {\n  // Create the temporary element for the ripple, set its class, and\n  // add it to the button.\n  const ripple = document.createElement('div');\n  ripple.className = 'ripple';\n\n  // Find the largest dimension (width or height) of the button and\n  // use that as the ripple's size.\n  const rippleSize = Math.max(button.offsetWidth, button.offsetHeight);\n  ripple.style.width = `${rippleSize}px`;\n  ripple.style.height = `${rippleSize}px`;\n\n  // Center the ripple element on the click location.\n  ripple.style.top = `${event.offsetY - (rippleSize / 2)}px`;\n  ripple.style.left = `${event.offsetX - (rippleSize / 2)}px`;\n\n  button.appendChild(ripple);\n\n  // Perform the ripple animation and wait for it to complete.\n  await ripple.animate([\n    { transform: 'scale(0)', opacity: 0.5 },\n    { transform: 'scale(2.5)', opacity: 0 }\n  ], {\n    // Animate for 500 milliseconds.\n    duration: 500,\n    // Use the ease-in easing function.\n    easing: 'ease-in'\n  }).finished;\n\n  // All done, remove the ripple element.\n  ripple.remove();\n});\n```", "```\n/**\n * Given an animation, toggles the animation state.\n * If the animation is running, it will be paused.\n * If it is paused, it will be resumed.\n */\nfunction toggleAnimation(animation) {\n  if (animation.playState === 'running') {\n    animation.pause();\n  } else {\n    animation.play();\n  }\n}\n```", "```\n/**\n * Shows an element that was just added to the DOM with a fade-in animation.\n * @param element The element to show\n */\nfunction showElement(element) {\n  document.body.appendChild(element);\n  element.animate([\n    { opacity: 0 },\n    { opacity: 1 }\n  ], {\n    // Animate for 250 milliseconds.\n    duration: 250\n  });\n}\n```", "```\n/**\n * Removes an element from the DOM after performing a fade-out animation.\n * @param element The element to remove\n */\nasync function removeElement(element) {\n  // First, perform the animation and make the element disappear from view.\n  // The resulting animation's 'finished' property is a Promise.\n  await element.animate([\n    { opacity: 1 },\n    { opacity: 0 }\n  ], {\n    // Animate for 250 milliseconds.\n    duration: 250\n  }).finished;\n\n  // Animation is done, now remove the element from the DOM.\n  element.remove();\n}\n```", "```\nelement.addEventListener('mouseover', async () => {\n  if (animation) {\n    // There was already an animation in progress. Instead of starting a new\n    // animation, reverse the current one.\n    animation.reverse();\n  } else {\n    // Nothing is in progress, so start a new animation.\n    animation = element.animate([\n      { transform: 'scale(1)' },\n      { transform: 'scale(2)' }\n    ], {\n      // Animate for 1 second.\n      duration: 1000,\n      // Apply the initial and end styles.\n      fill: 'both'\n    });\n\n    // Once the animation finishes, set the current animation to null.\n    await animation.finished;\n    animation = null;\n  }\n});\n```", "```\nbutton.addEventListener('mouseout', async () => {\n  if (animation) {\n    // There was already an animation in progress. Instead of starting a new\n    // animation, reverse the current one.\n    animation.reverse();\n  } else {\n    // Nothing is in progress, so start a new animation.\n    animation = button.animate([\n      { transform: 'scale(2)' },\n      { transform: 'scale(1)' }\n    ], {\n      // Animate for 1 second.\n      duration: 1000,\n      // Apply the initial and end styles.\n      fill: 'both'\n    });\n\n    // Once the animation finishes, set the current animation to null.\n    await animation.finished;\n    animation = null;\n  }\n});\n```", "```\nasync function animate(element, direction) {\n  if (animation) {\n    animation.reverse();\n  } else {\n    animation = element.animate([\n      { transform: 'scale(1)' },\n      { transform: 'scale(2)' }\n    ], {\n      // Animate for 1 second.\n      duration: 1000,\n      // Apply the end style after the animation is done.\n      fill: 'forward',\n      // Run the animation forward (normal) or backward (reverse)\n      // depending on the direction argument.\n      direction\n    });\n\n    // Once the animation finishes, set the variable to\n    // null to signal that there is no animation in progress.\n    await animation.finished;\n    animation = null;\n  }\n}\n\nelement.addEventListener('mouseover', () => {\n  animate(element, 'normal');\n});\n\nelement.addEventListener('mouseout', () => {\n  animate(element, 'reverse');\n});\n```", "```\n.scroll-progress {\n  height: 8px;\n  transform-origin: left;\n  position: sticky;\n  top: 0;\n  transform: scaleX(0);\n  background: blue;\n}\n```", "```\nconst progress = document.querySelector('.scroll-progress');\n\n// Create a timeline that's linked to the document's\n// scroll position.\nconst timeline = new ScrollTimeline({\n  source: document.documentElement\n});\n\n// Start the animation, passing the timeline you just created.\nprogress.animate(\n  [\n    { transform: 'scaleX(0)' },\n    { transform: 'scaleX(1)' }\n  ],\n  { timeline });\n```", "```\nasync function animateBounce(element) {\n  const distances = [ '40px', '20px', '10px' ];\n  for (let distance of distances) {\n    // Wait for this animation to complete before continuing.\n    await element.animate([\n      // Start at the bottom.\n      { transform: 'translateY(0)' },\n\n      // Move up by the current distance.\n      { transform: `translateY(-${distance})`, offset: 0.5 },\n\n      // Back to the bottom\n      { transform: 'translateY(0)' }\n    ], {\n      // Animate for 250 milliseconds.\n      duration: 250,\n\n      // Use a more fluid easing function than linear\n      // (the default).\n      easing: 'ease-in-out'\n    }).finished;\n  }\n}\n```", "```\n// The first animation will move the element back and forth on the x-axis.\nelement.animate([\n  { transform: 'translateX(0)' },\n  { transform: 'translateX(250px)' }\n], {\n  // Animate for 5 seconds.\n  duration: 5000,\n  // Run the animation forward, then run it in reverse.\n  direction: 'alternate',\n  // Repeat the animation forever.\n  iterations: Infinity,\n  // Slow to start, fast in the middle, slow at the end.\n  easing: 'ease-in-out'\n});\n\n// The second animation rotates the element.\nelement.animate([\n  { transform: 'rotate(0deg)' },\n  { transform: 'rotate(360deg)' }\n], {\n  // Animate for 3 seconds.\n  duration: 3000,\n  // Repeat the animation forever.\n  iterations: Infinity,\n  // Combine the effects with other running animations.\n  composite: 'add'\n});\n```", "```\n<style>\n  #loader {\n    width: 64px;\n    height: 64px;\n\n    /* Make a circle shape */\n    border-radius: 50%;\n    border-width: 10px;\n    border-style: solid;\n    border-color: skyblue blue skyblue blue;\n\n    /* Set the initial opacity so the animation that appears is smooth */\n    opacity: 0;\n  }\n</style>\n\n<div id=\"loader\"></div>\n```", "```\nasync function showLoader(promise) {\n  const loader = document.querySelector('#loader');\n\n  // Start the spin animation before fading in.\n  const spin = loader.animate([\n    { transform: 'rotate(0deg)' },\n    { transform: 'rotate(360deg)' }\n  ], { duration: 1000, iterations: Infinity });\n\n  // Since the opacity is 0, the loader isn't visible yet.\n  // Show it with a fade-in animation.\n  // The loader will continue spinning as it fades in.\n  loader.animate([\n    { opacity: 0 },\n    { opacity: 1 }\n  ], { duration: 500, fill: 'both' });\n\n  // Wait for the Promise to resolve.\n  await promise;\n\n  // The Promise is done. Now fade the loader out.\n  // Don't stop the spin animation until the fade out is complete.\n  // You can wait by awaiting the 'finished' Promise.\n  await loader.animate([\n    { opacity: 1 },\n    { opacity: 0 }\n  ], { duration: 500, fill: 'both' }).finished;\n\n  // Finally, stop the spin animation.\n  spin.cancel();\n\n  // Return the original Promise to allow chaining.\n  return promise;\n}\n```", "```\nshowLoader(\n  fetch('https://example.com/api/users')\n    .then(response => response.json())\n);\n```", "```\nif (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n  // Reduced motion is not enabled, so animate normally.\n} else {\n  // Skip this animation or run a less intense one.\n}\n```"]