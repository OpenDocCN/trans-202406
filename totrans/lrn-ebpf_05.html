<html><head></head><body><section data-pdf-bookmark="Chapter 5. CO-RE, BTF, and Libbpf" data-type="chapter" epub:type="chapter"><div class="chapter" id="co_recomma_btfcomma_and_libbpf">&#13;
<h1><span class="label">Chapter 5. </span>CO-RE, BTF, and Libbpf</h1>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="basics" data-type="indexterm" id="idm46123199383696"/>In the previous chapter you encountered BTF (BPF Type Format) for the first time. This chapter discusses why it exists and how it’s used to make eBPF programs portable across different versions of the kernel. It’s a key part of BPF’s compile once, run everywhere (CO-RE) approach, which solves the problem of making eBPF programs portable across different kernel versions.</p>&#13;
<p>Many eBPF programs access kernel data structures, and an eBPF programmer would need to include relevant Linux header files so that their eBPF code can correctly locate fields within those data structures. However, the Linux kernel is under continuous development, which means internal data structures can change between different kernel versions. If you were to take an eBPF object file compiled on one machine<sup><a data-type="noteref" href="ch05.html#ch05fn1" id="ch05fn1-marker">1</a></sup> and load it onto a machine with a different kernel version, there would be no guarantee that the data structures would be the same.</p>&#13;
<p>The CO-RE approach is a huge step forward in addressing this portability issue in an efficient way. It allows eBPF programs to include information about the data structure layouts they were compiled with, and it provides a mechanism for adjusting how fields are accessed if the data structure layout is different on the target machine where they run. Provided the program doesn’t want to access a field or data structure that simply doesn’t exist in the target machine’s kernel, the program is portable across different kernel versions.</p>&#13;
<p>But before we dive into the details of how CO-RE works, let’s discuss why it was so desirable, by looking at the previous approach to kernel portability as originally implemented in the BCC project.</p>&#13;
<section data-pdf-bookmark="BCC’s Approach to Portability" data-type="sect1"><div class="sect1" id="bccapostrophes_approach_to_portability">&#13;
<h1>BCC’s Approach to Portability</h1>&#13;
<p><a contenteditable="false" data-primary="BCC framework" data-secondary="portability approach" data-type="indexterm" id="idm46123199378016"/>In <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a> I used <a href="https://oreil.ly/ReUtn">BCC</a> to show a basic “Hello World” example of an eBPF program. The BCC project was the first popular project for implementing eBPF programs, providing a framework for both the user space and kernel aspects that’s relatively accessible to programmers without much kernel experience. To address portability across kernels, BCC took the approach of compiling eBPF code at runtime, in situ on the destination machine. There are a number of issues with this approach:</p>&#13;
<ul>&#13;
<li><p>The compilation toolchain needs to be installed on every destination machine where you want the code to run, as well as the kernel header files (which aren’t always present by default).</p></li>&#13;
<li><p>You have to wait for the compilation to complete before the tool starts, which could mean a delay of several seconds, every time the tool is launched.</p></li>&#13;
<li><p>If you’re running the tool on a large fleet of identical machines, repeating the compilation on each machine is a waste of compute resources.</p></li>&#13;
<li><p>Some BCC-based projects package their eBPF source code and the toolchain into a container image, which makes distribution to each machine easier. But it doesn’t solve the problem of ensuring that the kernel headers are present, and it can even mean more duplication if several of these BCC containers are installed on each machine.</p></li>&#13;
<li><p>Embedded devices might not have sufficient memory resources to run the compilation step.</p></li>&#13;
</ul>&#13;
<p>Because of these issues, if you’re planning to embark on developing a significant new eBPF project, I would not recommend using this legacy BCC approach for it, especially if you’re planning to distribute it for others to use. In this book I’ve given some examples based on BCC because it’s a good approach for learning about the basic concepts of eBPF, particularly because the Python user space code is so compact and easy to read. It’s also a perfectly good choice if you’re more comfortable with it and you want to put something together quickly. But it’s not the best approach for serious modern eBPF development.</p>&#13;
<p>The CO-RE approach offers a much better solution to the problem of cross-kernel portability for eBPF programs.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The BCC project at <a href="https://oreil.ly/ReUtn"><em>github.com/iovisor/bcc</em></a> includes a wide range of command-line tools for observing all sorts of information about how a Linux machine is behaving. The original versions located in the <a href="https://oreil.ly/fI4w_"><em>tools</em></a> directory are mostly implemented in Python using this legacy approach to portability that I have described in this section.</p>&#13;
<p>In BCC’s <a href="https://oreil.ly/ke7yq"><em>libbpf-tools</em></a> directory, you’ll find updated versions of these tools written in C that take advantage of <em>libbpf</em> and CO-RE and that don’t suffer from the problems I’ve just listed. They are an incredibly useful set of utilities!</p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="CO-RE Overview" data-type="sect1"><div class="sect1" id="co_re_overviewpart_of_this_section_is_a">&#13;
<h1>CO-RE Overview</h1>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="overview" data-type="indexterm" id="idm46123199363392"/>The CO-RE approach consists of a few elements:<sup><a data-type="noteref" href="ch05.html#ch05fn2" id="ch05fn2-marker">2</a></sup><sup>,</sup><sup><a data-type="noteref" href="ch05.html#ch05fn3" id="ch05fn3-marker">3</a></sup></p>&#13;
<dl>&#13;
<dt>BTF</dt>&#13;
<dd><a href="https://oreil.ly/iRCuI">BTF</a> is a format for expressing the layout of data structures and function signatures. In CO-RE it’s used to determine any differences between the structures used at compilation time and at runtime. BTF is also used by tools like <code>bpftool</code> to dump data structures in human-readable formats. Linux kernels from 5.4 onward support BTF.</dd>&#13;
<dt>Kernel headers</dt>&#13;
<dd>The Linux kernel source code includes header files that describe the data structures it uses, and these headers can change between versions of Linux. eBPF programmers can choose to include individual header files, or, as you’ll see in this chapter, you can use <code>bpftool</code> to generate a header file called <em>vmlinux.h</em> from a running system, containing all the data structure information about a kernel that a BPF program might need.</dd>&#13;
<dt>Compiler support</dt>&#13;
<dd>The <a href="https://oreil.ly/6xFJm">Clang compiler was enhanced</a> so that when it compiles eBPF programs with the <code>-g</code> flag, it includes what are known as <a contenteditable="false" data-primary="CO-RE relocations" data-type="indexterm" id="idm46123199352624"/><em>CO-RE relocations</em>, derived from the BTF information describing the kernel data structures. The GCC compiler also added CO-RE support for BPF targets in <a href="https://oreil.ly/_6PEE">version 12</a>.</dd>&#13;
<dt>Library support for data structure relocations</dt>&#13;
<dd>At the point where a user space program loads an eBPF program into the kernel, the CO-RE approach requires the bytecode to be adjusted to compensate for any differences between the data structures present when it was compiled, and what’s on the destination machine where it’s about to run, based on the CO-RE relocation information compiled into the object. There are a few libraries that will take care of this: <a href="https://oreil.ly/E742u"><em>libbpf</em></a> was the original C library that includes this relocation capability, the Cilium eBPF library provides the same capability for Go programmers, and Aya does it for Rust.</dd>&#13;
<dt>Optionally, a BPF skeleton</dt>&#13;
<dd><a contenteditable="false" data-primary="skeleton code" data-secondary="auto-generation of" data-type="indexterm" id="idm46123199347584"/>A skeleton can be auto-generated from a compiled BPF object file, containing handy functions that user space code can call to manage the lifecycle of BPF programs—loading them into the kernel, attaching them to events, and so on. <a contenteditable="false" data-primary="bpftool" data-secondary="skeleton generation" data-type="indexterm" id="idm46123199346080"/>If you’re writing the user space code in C, you can generate the skeleton with <code>bpftool gen skeleton</code>. These functions are higher-level abstractions that can be more convenient for the developer than using the underlying library (<em>libbpf</em>, <em>cilium/ebpf</em>, etc.) directly.</dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Andrii Nakryiko wrote an <a href="https://oreil.ly/aeQJo">excellent blog post</a> that describes the background of CO-RE, as well as laying out how it works and how to use it. He also wrote the canonical <a href="https://oreil.ly/lbW_T">BPF CO-RE Reference Guide</a>, so please do read that if you’re embarking on writing code yourself. His <a href="https://oreil.ly/_jet-"><em>libbpf-bootstrap</em> guide</a> to building an eBPF app from scratch with CO-RE + <em>libbpf</em> + skeletons is another must-read.</p>&#13;
</div>&#13;
<p>Now that you have an overview of the elements of CO-RE, let’s dig in to see how they work, starting with an exploration of BTF.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BPF Type Format" data-type="sect1"><div class="sect1" id="bpf_type_format">&#13;
<h1>BPF Type Format</h1>&#13;
<p> <a contenteditable="false" data-primary="BTF (BPF Type Format)" data-type="indexterm" id="ch05.html0"/>BTF information describes how data structures and code are laid out in memory. This information can be put to a variety of different uses.</p>&#13;
<section data-pdf-bookmark="BTF Use Cases" data-type="sect2"><div class="sect2" id="btf_use_cases">&#13;
<h2>BTF Use Cases</h2>&#13;
<p><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="use cases" data-type="indexterm" id="idm46123199332912"/>The main reason for discussing BTF in this chapter on CO-RE is that knowing the differences between a structure’s layout where an eBPF program was compiled and where it is about to run allows for the appropriate adjustments to be made as the program is loaded into the kernel. I’ll discuss the relocation process later in this chapter, but for now, let’s also consider some of the other uses to which BTF information can be put.</p>&#13;
<p>Knowing how a structure is laid out, and the type of every field in that structure, makes it possible to pretty-print a structure’s contents in human-readable form. For example, a string is just a series of bytes from the computer’s point of view, but converting those bytes into characters makes the string much easier for humans to understand. You already saw an example of this in the previous chapter, where <code>bpftool</code> used BTF information to format the output of map dumps.</p>&#13;
<p>BTF information also includes the line and function information that enables <code>bpftool</code> to interleave source code within the output from translated or JITed program dumps, as you saw in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>. When you come to <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>, you’ll also see the source code information interleaved with the verifier log output, and again this comes from the BTF information.</p>&#13;
<p><a contenteditable="false" data-primary="spin locks" data-type="indexterm" id="idm46123199327168"/>BTF information is also required for BPF spin locks. <em>Spin locks</em> are used to stop two CPU cores from simultaneously accessing the same map values. The lock has to be part of the map’s value structure, like this:</p>&#13;
<pre data-type="programlisting">struct my_value {&#13;
     ... &lt;other fields&gt;&#13;
     struct bpf_spin_lock lock;&#13;
... &lt;other fields&gt;&#13;
};</pre>&#13;
<p>Within the kernel, eBPF programs use <code>bpf_spin_lock()</code> and <code>bpf_spin_unlock()</code> helper functions to acquire and release a lock. These helpers can be used only if BTF information is available to describe where the lock field is within the structure.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Spin lock support was added in kernel version 5.1. There are lots of restrictions on the use of spin locks: they can only be used on hash or array map types, and they can’t be used in tracing or socket filter type eBPF programs. Read more about spin locks in the <a href="https://oreil.ly/kAyAU">lwn.net article on concurrency management in BPF</a>.</p>&#13;
</div>&#13;
<p>Now that you know why BTF information is useful, let’s make it more concrete by looking at some examples.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Listing BTF Information with bpftool" data-type="sect2"><div class="sect2" id="listing_btf_information_with_bpftool">&#13;
<h2>Listing BTF Information with bpftool</h2>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="listing BTF information with" data-type="indexterm" id="ch05.html1"/><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="listing BTF information with bpftool" data-type="indexterm" id="ch05.html2"/>As with programs and maps, you can use the <code>bpftool</code> utility to show BTF information. The following command lists all the BTF data loaded into the kernel:</p>&#13;
<pre data-type="programlisting">bpftool btf list&#13;
1: name [vmlinux]  size 5843164B&#13;
2: name [aes_ce_cipher]  size 407B&#13;
3: name [cryptd]  size 3372B&#13;
...&#13;
149: name &lt;anon&gt;  size 4372B  prog_ids 319  map_ids 103&#13;
        pids hello-buffer-co(7660)&#13;
155: name &lt;anon&gt;  size 37100B&#13;
        pids bpftool(7784)</pre>&#13;
<p>(I’ve omitted many entries from the results for brevity.)</p>&#13;
<p>The first entry in the list is <code>vmlinux</code>, and it corresponds to the <em>vmlinux</em> file I mentioned earlier that holds the BTF information about the currently running kernel.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Some of the examples early in this chapter reuse the programs from <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>, and then later in this chapter you’ll find new examples for which the source is in the <em>chapter5</em> directory at <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a>.</p>&#13;
</div>&#13;
<p>To obtain this example output I ran this command while the <code>hello-buffer-config</code> example from <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a> was running. You can see the entry describing the BTF information that this process is using, on the line that starts with <code>149:</code>:</p>&#13;
<pre data-type="programlisting">149: name &lt;anon&gt;  size 4372B  prog_ids 319  map_ids 103&#13;
        pids hello-buffer-co(7660)</pre>&#13;
<p>Here’s what that line is telling us:</p>&#13;
<ul>&#13;
<li><p>This chunk of BTF information has ID 149.</p></li>&#13;
<li><p>It’s an anonymous blob of around 4 KB of BTF information.</p></li>&#13;
<li><p>It’s used by the BPF program with <code>prog_id 319</code> and the BPF map with <code>map_id 103</code>.</p></li>&#13;
<li><p>It’s also used by the process with ID 7660 (shown within parentheses) running the <code>hello-buffer-config</code> executable (whose name has been truncated to 15 characters).</p></li>&#13;
</ul>&#13;
<p>These program, map, and BTF identifiers match with the following output that <code>bpftool</code> shows about <code>hello-buffer-config</code>’s program called <code>hello</code>:</p>&#13;
<pre data-type="programlisting">bpftool prog show name hello&#13;
319: kprobe  name hello  tag a94092da317ac9ba  gpl&#13;
        loaded_at 2022-08-28T14:13:35+0000  uid 0&#13;
        xlated 400B  jited 428B  memlock 4096B  map_ids 103,104&#13;
        btf_id 149&#13;
        pids hello-buffer-co(7660)</pre>&#13;
<p>The only thing that doesn’t appear to match completely between these two sets of information is that the program refers to an extra <code>map_id</code>, <code>104</code>. That’s the perf event buffer map, and it doesn’t use BTF information; hence, it doesn’t appear in the BTF-related output.</p>&#13;
<p>Much like <code>bpftool</code> can dump the contents of programs and maps, it can also be used to view the BTF type information contained in a blob of data.<a contenteditable="false" data-primary="" data-startref="ch05.html2" data-type="indexterm" id="idm46123199294864"/><a contenteditable="false" data-primary="" data-startref="ch05.html1" data-type="indexterm" id="idm46123199293488"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BTF Types" data-type="sect2"><div class="sect2" id="btf_types">&#13;
<h2>BTF Types</h2>&#13;
<p><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="BTF types" data-type="indexterm" id="ch05.html3"/>Knowing the ID of the BTF information, you can inspect its contents with the command <code>bpftool btf dump id &lt;id&gt;</code>. When I ran this using the ID 149 that I obtained earlier, I got 69 lines of output, each of which is a type definition. I’ll just describe the first few lines, which should give you a good idea of how to interpret the rest. The BTF information from these first few lines relates to the <code>config</code> hash map, which was defined in the source code like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">];</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="n">BPF_HASH</code><code class="p">(</code><code class="n">config</code><code class="p">,</code><code class="w"> </code><code class="n">u32</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>This hash table has keys of type <code>u32</code> and values of type <code>struct user_msg_t</code>. That structure holds a 12-byte <code>message</code> field. Let’s see how these types are defined in the corresponding BTF information.</p>&#13;
<p>The first three lines of the BTF output are as follows:</p>&#13;
<pre data-type="programlisting">[1] TYPEDEF 'u32' type_id=2&#13;
[2] TYPEDEF '__u32' type_id=3&#13;
[3] INT 'unsigned int' size=4 bits_offset=0 nr_bits=32 encoding=(none)</pre>&#13;
<p>The number in square brackets at the start of each line is the type ID (so the first line, starting with <code>[1]</code>, defines <code>type_id 1</code>, etc.).  Let’s dive into these three types in more detail:</p>&#13;
<ul>&#13;
<li><p>Type 1 defines a type named <code>u32</code> and its type, defined by <code>type_id 2</code>, that is, the type defined in the line that starts with <code>[2]</code>. As you know, the keys in the hash table have this type <code>u32</code>.</p></li>&#13;
<li><p>Type 2 has the name <code>__u32</code> and the type defined by <code>type_id 3</code>.</p></li>&#13;
<li><p>Type 3 is an integer type with the name <code>unsigned int</code>, which is 4 bytes long.</p></li>&#13;
</ul>&#13;
<p>All three of these types are synonyms for a 32-bit unsigned integer type. In C, the lengths of integers are platform dependent, so Linux defines types like <code>u32</code> to explicitly define integers of specific lengths. On this machine, <code>u32</code> corresponds to an unsigned integer. User space code that refers to these should use the synonym prefixed with underscores, as in <code>__u32</code>.</p>&#13;
<p class="pagebreak-before">The next few types in the BTF output look like this:</p>&#13;
<pre data-type="programlisting">[4] STRUCT 'user_msg_t' size=12 vlen=1&#13;
        'message' type_id=6 bits_offset=0&#13;
[5] INT 'char' size=1 bits_offset=0 nr_bits=8 encoding=(none)&#13;
[6] ARRAY '(anon)' type_id=5 index_type_id=7 nr_elems=12&#13;
[7] INT '__ARRAY_SIZE_TYPE__' size=4 bits_offset=0 nr_bits=32 encoding=(none)</pre>&#13;
<p>These relate to the <code>user_msg_t</code> structure used for values in the <code>config</code> map:</p>&#13;
<ul>&#13;
<li><p>Type 4 is the <code>user_msg_t</code> structure itself, and in total it is 12 bytes long. It contains one field named <code>message</code>, which is defined by type 6. The <code>vlen</code> field indicates how many fields there are in this definition.</p></li>&#13;
<li><p>Type 5 is named <code>char</code> and is a 1-byte integer—exactly the definition a C programmer would expect for a type called “char.”</p></li>&#13;
<li><p>Type 6 defines the type for that <code>message</code> field as an array with 12 elements. Each element has type 5 (it’s a <code>char</code>), and the array is indexed by type 7.</p></li>&#13;
<li><p>Type 7 is a 4-byte integer.</p></li>&#13;
</ul>&#13;
<p>With these definitions, you can build a complete picture of how the <code>user_msg_t</code> structure is laid out in memory, as illustrated in <a data-type="xref" href="#a_user_msg_t_structure_takes_onetwo_byt">Figure 5-1</a>.</p>&#13;
<figure><div class="figure" id="a_user_msg_t_structure_takes_onetwo_byt">&#13;
<img alt="A user_msg_t structure takes 12 bytes of memory" src="assets/lebp_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>A <code>user_msg_t</code> structure takes 12 bytes of memory</h6>&#13;
</div></figure>&#13;
<p>So far, all the entries have <code>bits_offset</code> set to <code>0</code>, but the next line of output has a structure with more than one field:</p>&#13;
<pre data-type="programlisting">[8] STRUCT '____btf_map_config' size=16 vlen=2&#13;
        'key' type_id=1 bits_offset=0&#13;
        'value' type_id=4 bits_offset=32</pre>&#13;
<p>This is a structure definition for the key–value pairs stored in the map called <code>config</code>. I didn’t define this <code>____btf_map_config</code> type myself in the source code, but it has been generated by BCC. The key is of type <code>u32</code>, and the value is the <code>user_msg_t</code> structure. These correspond to the types 1 and 4 that you saw earlier.</p>&#13;
<p>The other important part of the BTF information about this structure is that the <code>value</code> field starts 32 bits after the start of the structure. That completely makes sense because the first 32 bits are needed to hold the <code>key</code> field.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In C, structure fields get automatically aligned to boundaries, so you can’t simply assume that one field always follows directly after the previous one in memory. For example, consider a structure like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">something</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kt">char</code><code class="w"> </code><code class="n">letter</code><code class="p">;</code><code class="w"> </code>&#13;
<code class="w">    </code><code class="n">u64</code><code class="w"> </code><code class="n">number</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>There would be 7 bytes of unused memory after the field called <code>letter</code> before the <code>number</code> field so that the 64-bit number can be aligned to a memory location divisible by 8.</p>&#13;
<p>It’s possible in some circumstances to turn on compiler packing to avoid this unused space, but it generally results in lower performance and—at least in my experience—it’s unusual to do so. More often, C programmers will design structures by hand to make efficient use of space.<a contenteditable="false" data-primary="" data-startref="ch05.html3" data-type="indexterm" id="idm46123199172864"/></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Maps with BTF Information" data-type="sect2"><div class="sect2" id="maps_with_btf_information">&#13;
<h2>Maps with BTF Information</h2>&#13;
<p><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="maps with BTF information" data-type="indexterm" id="idm46123199166848"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="maps with BTF information" data-type="indexterm" id="idm46123199165504"/>You’ve just seen the BTF information associated with a map. Now let’s see how this BTF data is passed to the kernel when the map is created.</p>&#13;
<p>You saw in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a> that maps are created using the <code>bpf(BPF_MAP_CREATE)</code> syscall. This takes a <code>bpf_attr</code> structure as a parameter, <a href="https://oreil.ly/PLrYG">defined in the kernel</a> like this (some details omitted):</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="cm">/* anonymous struct used by BPF_MAP_CREATE command */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w">   </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/map_type"><code class="n">map_type</code></a><code class="p">;</code><code class="w">             </code><code class="cm">/* one of enum bpf_map_type */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w">   </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/key_size"><code class="n">key_size</code></a><code class="p">;</code><code class="w">             </code><code class="cm">/* size of key in bytes */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w">   </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/value_size"><code class="n">value_size</code></a><code class="p">;</code><code class="w">           </code><code class="cm">/* size of value in bytes */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w">   </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/max_entries"><code class="n">max_entries</code></a><code class="p">;</code><code class="w">          </code><code class="cm">/* max number of entries in a map */</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="w">    </code><code class="kt">char</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/map_name"><code class="n">map_name</code></a><code class="p">[</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/BPF_OBJ_NAME_LEN"><code class="n">BPF_OBJ_NAME_LEN</code></a><code class="p">]</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w">   </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/btf_fd"><code class="n">btf_fd</code></a><code class="p">;</code><code class="w">               </code><code class="cm">/* fd pointing to a BTF type data */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w">   </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/btf_key_type_id"><code class="n">btf_key_type_id</code></a><code class="p">;</code><code class="w">      </code><code class="cm">/* BTF type_id of the key */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w">   </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/btf_value_type_id"><code class="n">btf_value_type_id</code></a><code class="p">;</code><code class="w">    </code><code class="cm">/* BTF type_id of the value */</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code></pre>&#13;
<p>Before the introduction of BTF, the <code>btf_*</code> fields weren’t present in this <code>bpf_attr</code> structure, and the kernel had no knowledge of the structure of keys or values. The <code>key_size</code> and <code>value_size</code> fields defined how much memory was required for them, but they were just treated as so many bytes. By additionally passing in the BTF information defining the types of the keys and values, the kernel can introspect them, and utilities like <code>bpftool</code> can retrieve the type information for pretty-printing, as discussed earlier. However, it’s interesting to note that separate BTF <code>type _id</code>s are passed in for the key and the value. The <code>____btf_map_config</code> structure that you just saw defined isn’t used by the kernel for the map definition; it’s just used by BCC on the user space side.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BTF Data for Functions and Function Prototypes" data-type="sect2"><div class="sect2" id="btf_data_for_functions_and_function_pro">&#13;
<h2>BTF Data for Functions and Function Prototypes</h2>&#13;
<p><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="data for functions/function prototypes" data-type="indexterm" id="idm46123199044544"/><a contenteditable="false" data-primary="functions and function prototypes, BTF data for" data-type="indexterm" id="idm46123199043200"/>So far the BTF data in this example output has related to data types, but the BTF data also contains information about functions and function prototypes. Here’s the information from the same BTF data blob that describes the <code>hello</code> function:</p>&#13;
<pre data-type="programlisting">[31] FUNC_PROTO '(anon)' ret_type_id=23 vlen=1&#13;
        'ctx' type_id=10&#13;
[32] FUNC 'hello' type_id=31 linkage=static</pre>&#13;
<p>In type 32 you can see the function named <code>hello</code> is defined as having the type defined in the previous line. That’s a <em>function prototype</em>, which returns a value of type ID <code>23</code> and takes a single parameter (<code>vlen=1</code>) called <code>ctx</code> with type ID <code>10</code>. For completeness, here are the definitions of those types from earlier in the output:</p>&#13;
<pre data-type="programlisting">[10] PTR '(anon)' type_id=0&#13;
 &#13;
[23] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED</pre>&#13;
<p>Type 10 is an anonymous pointer with the default type of <code>0</code>, which isn’t explicitly included in the BTF output but is defined as a void pointer.<sup><a data-type="noteref" href="ch05.html#ch05fn4" id="ch05fn4-marker">4</a></sup></p>&#13;
<p class="pagebreak-before">The return value with type 23 is a 4-byte integer, and <code>encoding=SIGNED</code> indicates that it’s a signed integer; that is, it can have either a positive or negative value. This corresponds to the function definition in the source code of <em>hello-buffer-config.py</em>, which looks like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="n">hello</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>The example BTF information I’ve shown so far comes from listing the contents of a blob of BTF data. Let’s see how to obtain just the BTF information that relates to a particular map or program.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Inspecting BTF Data for Maps and Programs" data-type="sect2"><div class="sect2" id="inspecting_btf_data_for_maps_and_progra">&#13;
<h2>Inspecting BTF Data for Maps and Programs</h2>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="inspecting BTF types with" data-type="indexterm" id="idm46123198968848"/><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="inspecting BTF data for maps and programs" data-type="indexterm" id="idm46123198967504"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="inspecting BTF data for" data-type="indexterm" id="idm46123198966160"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="inspecting BTF data for" data-type="indexterm" id="idm46123198964784"/>If you want to inspect the BTF types associated with a particular map, <code>bpftool</code> makes that easy. For example, here’s the output for the <code>config</code> map:</p>&#13;
<pre data-type="programlisting">bpftool btf dump map name config&#13;
[1] TYPEDEF 'u32' type_id=2&#13;
[4] STRUCT 'user_msg_t' size=12 vlen=1&#13;
        'message' type_id=6 bits_offset=0</pre>&#13;
<p>Similarly, you can inspect the BTF information related to a particular program with <code>bpftool btf dump prog &lt;prog identity&gt;</code>. I’ll leave you to check out the <a href="https://oreil.ly/lCoV5">manpage</a> for additional details.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’d like to better understand how the BTF type data is generated and de-duplicated, there is another <a href="https://oreil.ly/0-a9g">excellent blog post from Andrii Nakryiko</a> on the subject.</p>&#13;
</div>&#13;
<p>By this stage you should have an understanding of how BTF describes the format of data structures and functions. An eBPF program written in C needs header files that define the types and structures. Let’s see how easy it is to generate a header file for any kernel data types that an eBPF program might need.<a contenteditable="false" data-primary="" data-startref="ch05.html0" data-type="indexterm" id="idm46123198936528"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Generating a Kernel Header File" data-type="sect1"><div class="sect1" id="generating_a_kernel_header_file">&#13;
<h1>Generating a Kernel Header File</h1>&#13;
<p><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="kernel headers" data-type="indexterm" id="ch05.html4"/><a contenteditable="false" data-primary="header files, C" data-secondary="generating a kernel header file" data-type="indexterm" id="ch05.html5"/><a contenteditable="false" data-primary="kernel" data-secondary="generating a kernel header file" data-type="indexterm" id="ch05.html6"/><a contenteditable="false" data-primary="kernel header file" data-type="indexterm" id="ch05.html20"/>If you run <code>bpftool btf list</code> on a BTF-enabled kernel, you’ll see lots of preexisting blobs of BTF data that look like this:</p>&#13;
<pre data-type="programlisting">$ bpftool btf list&#13;
1: name [vmlinux]  size 5842973B&#13;
2: name [aes_ce_cipher]  size 407B&#13;
3: name [cryptd]  size 3372B&#13;
...</pre>&#13;
<p>The first item in this list, with ID 1 and named <code>vmlinux</code>, is the BTF information about all the data types, structures, and function definitions used by the kernel that’s running on this (virtual) machine.<sup><a data-type="noteref" href="ch05.html#ch05fn5" id="ch05fn5-marker">5</a></sup></p>&#13;
<p>An eBPF program needs the definitions of any kernel data structures and types that it is going to refer to. Before the days of CO-RE, you’d typically have to figure out which of the many individual header files in the Linux kernel source held the definition for the structures you were interested in, but now there is a much easier way, as BTF-enabled tools can generate an appropriate header file from the BTF information included with the kernel.</p>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="kernel header file generation" data-type="indexterm" id="idm46123198922512"/>This header file is conventionally called <em>vmlinux.h</em>, and you can generate it with <code>bpftool</code> like this:</p>&#13;
<pre data-type="programlisting">bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</pre>&#13;
<p>This file defines all the kernel’s data types, so including this generated <em>vmlinux.h</em> file in your eBPF program source supplies the definitions of any Linux data structures you might need. When you compile the source into an eBPF object file, that object will include BTF information that matches the definitions used in this header file. Later, when the program is run on a target machine, the user space program that loads it into the kernel will make adjustments to account for differences between this build-time BTF information and the BTF information for the kernel that’s running on that target machine.</p>&#13;
<p>BTF information in the form of the <em>/sys/kernel/btf/vmlinux</em> file has been included in the Linux kernel since version 5.4,<sup><a data-type="noteref" href="ch05.html#ch05fn6" id="ch05fn6-marker">6</a></sup> but raw BTF data that <em>libbpf</em> can make use of can also be generated for older kernels. In other words, if you want to run a CO-RE–enabled eBPF program on a target machine that doesn’t have BTF information already, you might be able to provide the BTF data for that target yourself. There’s information on how to generate BTF files, and an archive of files for a variety of Linux distributions, on the <a href="https://oreil.ly/mPSO0">BTFHub</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The BTFHub repo also includes further reading about <a href="https://oreil.ly/CfyQh">BTF internals</a> should you want to dive deeper into this topic.<a contenteditable="false" data-primary="" data-startref="ch05.html20" data-type="indexterm" id="idm46123198912624"/><a contenteditable="false" data-primary="" data-startref="ch05.html6" data-type="indexterm" id="idm46123198911248"/><a contenteditable="false" data-primary="" data-startref="ch05.html5" data-type="indexterm" id="idm46123198909872"/><a contenteditable="false" data-primary="" data-startref="ch05.html4" data-type="indexterm" id="idm46123198908496"/></p>&#13;
</div>&#13;
<p>Next, let’s look at how this and other tactics are used to write eBPF programs to be portable across kernels using CO-RE.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="CO-RE eBPF Programs" data-type="sect1"><div class="sect1" id="co_re_ebpf_programs">&#13;
<h1>CO-RE eBPF Programs</h1>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-type="indexterm" id="ch05.html7"/>You’ll recall that eBPF programs run in the kernel. Later in this chapter I’ll show some user space code that will interact with the code running in the kernel, but in this section I’m concentrating on the kernel side.</p>&#13;
<p>As you’ve already seen, eBPF programs are compiled to eBPF bytecode, and (at least at the time of this writing) the compilers that support this are Clang or gcc for compiling C code, and the Rust compiler. I’ll discuss some of your options for using Rust in <a data-type="xref" href="ch10.html#ebpf_programming">Chapter 10</a>, but for the purposes of this chapter I’ll assume you’re writing in C and using Clang, along with the <em>libbpf</em> library.</p>&#13;
<p>For the remainder of this chapter, let’s consider an example application called <em>hello-buffer-config</em>. It’s very similar to the <em>hello-buffer-config.py</em> example from the previous chapter that used the BCC framework, but this version is written in C to use <em>libbpf</em> and CO-RE.</p>&#13;
<p>If you have BCC-based eBPF code that you want to migrate to <em>libbpf</em>, check out the excellent and comprehensive <a href="https://oreil.ly/iWDcv">guide by Andrii Nakryiko on his website</a>. BCC provides some convenient shortcuts that aren’t handled in quite the same way using <em>libbpf</em>; conversely, <em>libbpf</em> provides its own set of macros and library functions to make life easier for the eBPF programmer. As I walk through the example, I will point out a few differences between the BCC and <em>libbpf</em> approaches.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You’ll find the example C eBPF program to accompany this section in the <em>chapter5</em> directory of the <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a> repo.</p>&#13;
</div>&#13;
<p>First let’s look at <em>hello-buffer-config.bpf.c</em>, which implements the eBPF program that runs in the kernel. Later in the chapter I’ll show you the user space code in <em>hello-buffer-config.c</em> that loads the program and displays output, much as the Python code did in the BCC implementation of this example in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>.</p>&#13;
<p>Like any C program, an eBPF program will need to include some header files.</p>&#13;
<section data-pdf-bookmark="Header Files" data-type="sect2"><div class="sect2" id="header_files">&#13;
<h2>Header Files</h2>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="header files" data-type="indexterm" id="ch05.html8"/><a contenteditable="false" data-primary="header files, C" data-secondary="for CO-RE eBPF programs" data-type="indexterm" id="ch05.html9"/>The first few lines of <em>hello-buffer-config.bpf.c</em> specify the header files that it needs:</p>&#13;
<pre data-type="programlisting">#include "vmlinux.h"&#13;
#include &lt;bpf/bpf_helpers.h&gt;&#13;
#include &lt;bpf/bpf_tracing.h&gt;&#13;
#include &lt;bpf/bpf_core_read.h&gt;&#13;
#include "hello-buffer-config.h"</pre>&#13;
<p>These five files are the <em>vmlinux.h</em> file, a few headers from <em>libbpf</em>, and an application-specific header file that I wrote myself. Let’s see why this is a typical pattern for the header files needed for a <em>libbpf</em> program.</p>&#13;
<section data-pdf-bookmark="Kernel header information" data-type="sect3"><div class="sect3" id="kernel_header_information">&#13;
<h3>Kernel header information</h3>&#13;
<p><a contenteditable="false" data-primary="header files, C" data-secondary="kernel headers" data-type="indexterm" id="idm46123198880416"/>If you’re writing an eBPF program that refers to any kernel data structures or types, the easiest option is to include the <em>vmlinux.h</em> file described earlier in this chapter. Alternatively, it’s possible to include individual header files from the Linux source, or to define the types by hand in your own code if you really want to go to that trouble. If you’re going to use any BPF helper functions from <em>libbpf</em>, you’ll need to include either <em>vmlinux.h</em> or <em>linux/types.h</em> to get the definitions for types like <code>u32</code>, <code>u64</code>, and so on, that the BPF helper source refers to.</p>&#13;
<p>The <em>vmlinux.h</em> file is derived from the kernel source headers, but it doesn’t include <code>#define</code>’d values from them. For example, if your eBPF program parses Ethernet packets, you’ll probably need the constant definitions that tell you what protocol the packet contains (such as <code>0x0800</code> to indicate that it’s an IP packet, or <code>0x0806</code> for an ARP packet). There is a series of constant values that you’ll need to duplicate in your own code, if you don’t include the <a href="https://oreil.ly/hoZzP"><em>if_ether.h</em> file</a> that defines these values for the kernel. I didn’t need any of these value definitions for <em>hello-buffer-config</em>, but you’ll see another example in <a data-type="xref" href="ch08.html#ebpf_for_networking">Chapter 8</a> where this is relevant.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Headers from libbpf" data-type="sect3"><div class="sect3" id="headers_from_libbpf">&#13;
<h3>Headers from libbpf</h3>&#13;
<p><a contenteditable="false" data-primary="header files, C" data-secondary="headers from libbpf" data-type="indexterm" id="idm46123198869504"/><a contenteditable="false" data-primary="libbpf" data-secondary="header files for helper functions" data-type="indexterm" id="idm46123198868128"/><a contenteditable="false" data-primary="libbpf" data-secondary="headers from" data-type="indexterm" id="idm46123198866784"/>To use any BPF helper functions in your eBPF code, you’ll need to include the header files from <em>libbpf</em> that give you their definitions.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>One thing that can be slightly confusing about <em>libbpf</em> is that it’s not just a user space library. You’ll find yourself including header files from <em>libbpf</em> in both user space and eBPF C code.</p>&#13;
</div>&#13;
<p>At the time of this writing, it is common to see eBPF projects including <em>libbpf</em> as a submodule and building/installing from source—this is what I have done in the example repository for this book. If you include it as a submodule, you’ll simply need to run <code>make install</code> from the <em>libbpf/src</em> directory. I don’t think it will be long before it’s more common to see <em>libbpf</em> widely available as a package on common Linux distributions, particularly since <em>libbpf</em> has now passed the milestone of a <a href="https://oreil.ly/8BFq6">version 1.0 release</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Application-specific headers" data-type="sect3"><div class="sect3" id="application_specific_headers">&#13;
<h3>Application-specific headers</h3>&#13;
<p><a contenteditable="false" data-primary="header files, C" data-secondary="application-specific headers" data-type="indexterm" id="idm46123198857392"/>It’s very common to have an application-specific header file that defines any structures that are used by both the user space and eBPF parts of your app. In my example, the <em>hello-buffer-config.h</em> header file defines the <code>data_t</code> structure that I’m using to pass event data from the eBPF program to user space. It’s almost the same structure you saw in the BCC version of this code, and it looks like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">data_t</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">pid</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">int</code><code class="w"> </code><code class="n">uid</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">command</code><code class="p">[</code><code class="mi">16</code><code class="p">];</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">];</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">path</code><code class="p">[</code><code class="mi">16</code><code class="p">];</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
<p>The only difference from the version you saw before is that I have added a field called <code>path</code>.</p>&#13;
<p>The reason to pull this structure definition into a separate header file is that I will also refer to it from the user space code in <em>hello-buffer-config.c</em>. In the BCC version, the kernel and user space code were both defined in a single file, and BCC did some work behind the scenes to make the structure available to the Python user space code.<a contenteditable="false" data-primary="" data-startref="ch05.html9" data-type="indexterm" id="idm46123198799520"/><a contenteditable="false" data-primary="" data-startref="ch05.html8" data-type="indexterm" id="idm46123198798208"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Defining Maps" data-type="sect2"><div class="sect2" id="defining_maps">&#13;
<h2>Defining Maps</h2>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="defining maps" data-type="indexterm" id="idm46123198825264"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="defining for CO-RE programs" data-type="indexterm" id="idm46123198823920"/>After including the header files, the next few lines of the source code in <em>hello-buffer-config.bpf.c</em> define the structures used for maps, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">__uint</code><code class="p">(</code><code class="n">type</code><code class="p">,</code><code class="w"> </code><code class="n">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">__uint</code><code class="p">(</code><code class="n">key_size</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">u32</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">__uint</code><code class="p">(</code><code class="n">value_size</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">u32</code><code class="p">));</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"> </code><code class="n">output</code><code class="w"> </code><code class="n">SEC</code><code class="p">(</code><code class="s">".maps"</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">];</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="k">struct</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">__uint</code><code class="p">(</code><code class="n">type</code><code class="p">,</code><code class="w"> </code><code class="n">BPF_MAP_TYPE_HASH</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">__uint</code><code class="p">(</code><code class="n">max_entries</code><code class="p">,</code><code class="w"> </code><code class="mi">10240</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">__type</code><code class="p">(</code><code class="n">key</code><code class="p">,</code><code class="w"> </code><code class="n">u32</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">__type</code><code class="p">(</code><code class="n">value</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"> </code><code class="n">my_config</code><code class="w"> </code><code class="n">SEC</code><code class="p">(</code><code class="s">".maps"</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>This requires more lines of code than I needed in the equivalent BCC example! With BCC, the map called <code>config</code> was created with the following macro:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">BPF_HASH</code><code class="p">(</code><code class="n">config</code><code class="p">,</code><code class="w"> </code><code class="n">u64</code><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>This macro isn’t available when you’re not using BCC, so in C you have to write it out longhand. You’ll see that I have used <code>__uint</code> and <code>__type</code>. These are defined in <a href="https://oreil.ly/2FgjB"><em>bpf/bpf_helpers_def.h</em></a> along with <code>__array</code>, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="cp">#</code><code class="cp">define </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.4/C/ident/__uint"><code class="cp">__uint</code></a><code class="cp">(name, val) int (*name)[val]</code><code class="cp">&#13;
</code><code class="cp">#</code><code class="cp">define </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.4/C/ident/__type"><code class="cp">__type</code></a><code class="cp">(name, val) </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.4/C/ident/typeof"><code class="cp">typeof</code></a><code class="cp">(val) *name</code><code class="cp">&#13;
</code><code class="cp">#</code><code class="cp">define </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.4/C/ident/__array"><code class="cp">__array</code></a><code class="cp">(name, val) </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.4/C/ident/typeof"><code class="cp">typeof</code></a><code class="cp">(val) *name[]</code></pre>&#13;
<p>These macros generally seem to be used by convention in <em>libbpf</em>-based programs, and I think they make the map definitions a little easier to read.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The name “config” clashed with a definition in <em>vmlinux.h</em>, so I renamed the map “my_config” for this example.</p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="eBPF Program Sections" data-type="sect2"><div class="sect2" id="ebpf_program_sections">&#13;
<h2>eBPF Program Sections</h2>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="eBPF program sections" data-type="indexterm" id="ch05.html10"/><a contenteditable="false" data-primary="SEC()" data-type="indexterm" id="idm46123198555520"/><a contenteditable="false" data-primary="program sections" data-type="indexterm" id="ch05.html21"/><a contenteditable="false" data-primary="programs,  eBPF" data-secondary="sections" data-type="indexterm" id="ch05.html22"/>Use of <em>libbpf</em> requires each eBPF program to be marked with a <code>SEC()</code> macro that defines the program type, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"kprobe"</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>This results in a section called <code>kprobe</code> in the compiled ELF object, so <em>libbpf</em> knows to load this as a <code>BPF_PROG_TYPE_KPROBE</code>. We’ll discuss different program types further in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.</p>&#13;
<p>Depending on the program type, you can also use the section name to specify what event the program will be attached to. The <em>libbpf</em> library will use this information to set up the attachment automatically, rather than leaving you to do it explicitly in your user space code. So, for example, to auto-attach to the kprobe for the <code>execve</code> syscall on an ARM-based machine, you could specify the section like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"kprobe/__arm64_sys_execve"</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>This requires you to know the function name for the syscall on that architecture (or figure it out, perhaps by looking at the <em>/proc/kallsyms</em> file on your target machine, which lists all the kernel symbols, including its function names). But <em>libbpf</em> can make life even easier for you with the <code>k(ret)syscall</code> section name, which tells the loader to attach to the kprobe in the architecture-specific function automatically:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"ksyscall/execve"</code><code class="p">)</code><code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The valid section names and formats are listed in the <a href="https://oreil.ly/FhHrm"><em>libbpf</em> documentation</a>. In the past, the requirements for section names were much looser, so you may come across eBPF programs written before <em>libbpf 1.0</em> with section names that don’t match the valid set. Don’t let them confuse you!</p>&#13;
</div>&#13;
<p>The section definition declares where the eBPF program should be attached, and then the program itself follows. As before, the eBPF program itself is written as a C function. In the example code it’s called <code>hello()</code>, and it’s extremely similar to the <code>hello()</code> function you saw in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>. Let’s consider the differences between that previous version and the version here:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"</code><code class="s">ksyscall/execve</code><code class="s">"</code><code class="p">)</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="n">BPF_KPROBE_SYSCALL</code><code class="p">(</code><code class="n">hello</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="o">*</code><code class="n">pathname</code><code class="p">)</code><code class="w">                   </code><a class="co" href="#list_id_5_1" id="code_id_5_1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="p">{</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">data_t</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">user_msg_t</code><code class="w"> </code><code class="o">*</code><code class="n">p</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">data</code><code class="p">.</code><code class="n">pid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_pid_tgid</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="o">&gt;</code><code class="w"> </code><code class="mi">32</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">data</code><code class="p">.</code><code class="n">uid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_uid_gid</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="mh">0xFFFFFFFF</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">bpf_get_current_comm</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">bpf_probe_read_user_str</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">path</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">path</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">pathname</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#list_id_5_2" id="code_id_5_2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_config</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">uid</code><code class="p">)</code><code class="p">;</code><code class="w">                    </code><a class="co" href="#list_id_5_3" id="code_id_5_3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">p</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">     </code><code class="n">bpf_probe_read_kernel</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">p</code><code class="o">-</code><code class="o">&gt;</code><code class="n">message</code><code class="p">)</code><code class="p">;</code><code class="w">      </code><code class="w">&#13;
</code><code class="w">  </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">     </code><code class="n">bpf_probe_read_kernel</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">message</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">bpf_perf_event_output</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">output</code><code class="p">,</code><code class="w"> </code><code class="n">BPF_F_CURRENT_CPU</code><code class="p">,</code><code class="w">             </code><a class="co" href="#list_id_5_4" id="code_id_5_4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">                        </code><code class="o">&amp;</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><code class="w">&#13;
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_5_1" id="list_id_5_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>I’ve taken advantage of a <a href="https://oreil.ly/pgI1B"><code>BPF_KPROBE_SYSCALL</code></a> macro defined in <em>libbpf</em> that makes it easy to access the arguments to a syscall by name. For <code>execve()</code>, the first argument is the pathname for the program that’s going to be executed. The eBPF program name is <code>hello</code>.</dd>&#13;
<dt><a class="co" href="#code_id_5_2" id="list_id_5_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Since the macro has made it so easy to access that pathname argument to <code>execve()</code>, I’m including it in the data sent to the perf buffer output. Notice that copying memory requires the use of a BPF helper function.</dd>&#13;
<dt class="pagebreak-before"><a class="co" href="#code_id_5_3" id="list_id_5_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Here, <code>bpf_map_lookup_elem()</code> is the BPF helper function for looking up values in a map, given a key. BCC’s equivalent of this would be <code>p = my_config.lookup(&amp;data.uid)</code>. BCC rewrites this to use the underlying <code>bpf_map_lookup_elem()</code> function before it passes the C code to the compiler. When you’re using <em>libbpf</em>, there is no rewriting of the code before compilation,<sup><a data-type="noteref" href="ch05.html#ch05fn7" id="ch05fn7-marker">7</a></sup> so you have to write directly to the helper functions.</dd>&#13;
<dt><a class="co" href="#code_id_5_4" id="list_id_5_4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>Here’s another similar example where I have written directly to the helper function <code>bpf_perf_event_output()</code>, where BCC gave me the convenient equivalent <code>output.perf_submit(ctx, &amp;data, sizeof(data))</code>.</dd>&#13;
</dl>&#13;
<p>The only other difference is that in the BCC version, I defined the message string as a local variable within the <code>hello()</code> function. BCC doesn’t (at least at the time of this writing) support global variables. In this version I have defined it as a global variable, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Hello World"</code><code class="p">;</code><code class="w"/></pre>&#13;
<p>In <em>chapter4/hello-buffer-config.py</em> the <code>hello</code> function was defined rather differently, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="n">hello</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>The <code>BPF_KPROBE_SYSCALL</code> macro is one of the convenient additions from <em>libbpf</em> that I mentioned. You’re not required to use the macro, but it makes life easier. It does all the heavy lifting to provide named arguments for all the parameters passed to a syscall. In this case, it supplies a <code>pathname</code> argument that points to a string holding the path of the executable that is about to be run, which is the first argument to the <code>execve()</code> syscall.</p>&#13;
<p>If you’re paying very close attention you might notice that the <code>ctx</code> variable isn’t visibly defined in my source code for <em>hello-buffer-config.bpf.c</em>, but nevertheless, I’ve been able to use it when submitting data to the output perf buffer, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">bpf_perf_event_output</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">output</code><code class="p">,</code><code class="w"> </code><code class="n">BPF_F_CURRENT_CPU</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">));</code><code class="w"/></pre>&#13;
<p>The <code>ctx</code> variable does exist, hidden within the <code>BPF_KPROBE_SYSCALL</code> macro definition inside <a href="https://oreil.ly/pgI1B"><em>bpf/bpf_tracing.h</em></a>, in <em>libbpf</em>, where you’ll also find some commentary about this. It can be slightly confusing to use a variable that’s not visibly defined, but it’s very helpful that it can be accessed.<a contenteditable="false" data-primary="" data-startref="ch05.html10" data-type="indexterm" id="idm46123198007040"/><a contenteditable="false" data-primary="" data-startref="ch05.html22" data-type="indexterm" id="idm46123198005664"/><a contenteditable="false" data-primary="" data-startref="ch05.html21" data-type="indexterm" id="idm46123198004288"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Memory Access with CO-RE" data-type="sect2"><div class="sect2" id="memory_access_with_co_re">&#13;
<h2>Memory Access with CO-RE</h2>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="memory access with" data-type="indexterm" id="ch05.html11"/><a contenteditable="false" data-primary="memory access" data-secondary="with CO-RE" data-type="indexterm" id="ch05.html12"/>eBPF programs for tracing have restricted access to memory, via a BPF helper function from the <code>bpf_probe_read_*()</code> family.<sup><a data-type="noteref" href="ch05.html#ch05fn8" id="ch05fn8-marker">8</a></sup> (There is also a <code>bpf_probe_write_user()</code> helper function, but it’s only <a href="https://oreil.ly/ibcy1">“meant for experiments”</a>). The problem is that, as you’ll see in the next chapter, the eBPF verifier generally won’t let you simply read memory through a pointer as you usually can in C (e.g., <code>x = p-&gt;y</code>).<sup><a data-type="noteref" href="ch05.html#ch05fn9" id="ch05fn9-marker">9</a></sup></p>&#13;
<p>The <em>libbpf</em> library provides CO-RE wrappers around the <code>bpf_probe_read_*()</code> helpers to take advantage of the BTF information and make memory access calls portable across different kernel versions. Here’s an example of one of those wrappers, as defined in the <a href="https://oreil.ly/XWWyc"><em>bpf_core_read.h</em> header file</a>:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="cp">#define bpf_core_read(dst, sz, src)                        \</code>&#13;
<code class="cp">    bpf_probe_read_kernel(dst, sz,                         \</code>&#13;
<code class="cp">                              (const void *)__builtin_preserve_access_index(src))</code></pre>&#13;
<p>As you can see, <code>bpf_core_read()</code> calls directly to <code>bpf_probe_read_kernel()</code>, the only difference being that it wraps the <code>src</code> field with <code>__builtin_preserve_access_index()</code>. <a contenteditable="false" data-primary="Clang compiler" data-type="indexterm" id="idm46123197983696"/>This tells Clang to emit a CO-RE relocation entry along with the eBPF instruction that accesses this address in memory.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This <code>__builtin_preserve_access_index()</code> instruction is an extension to “regular” C code, and adding it to eBPF also required changes to the Clang compiler to support it and emit these CO-RE relocation entries. Extensions like these are examples of why some C compilers cannot (today, at least) generate eBPF bytecode. Read more about the Clang changes required for eBPF CO-RE support on the <a href="https://oreil.ly/jHTHE">LLVM mailing list</a>.</p>&#13;
</div>&#13;
<p>As you’ll see later in this chapter, the CO-RE relocation entry tells <em>libbpf</em> to rewrite the address, as it’s loading the eBPF program into the kernel, to take account of any BTF differences. If the offset of <code>src</code> within its containing structure is different on the target kernel, the rewritten instruction will take that into account.</p>&#13;
<p>The <em>libbpf</em> library provides a <code>BPF_CORE_READ()</code> macro so that you can write several <code>bpf_core_read()</code> calls in a single line rather than needing a separate helper function call for every pointer dereference. For example, if you wanted to do something like <code>d = a-&gt;b-&gt;c-&gt;d</code>, you could write the following code:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">b_t</code><code class="w"> </code><code class="o">*</code><code class="n">b</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">struct</code><code class="w"> </code><code class="nc">c_t</code><code class="w"> </code><code class="o">*</code><code class="n">c</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="n">bpf_core_read</code><code class="p">(</code><code class="o">&amp;</code><code class="n">b</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">a</code><code class="o">-&gt;</code><code class="n">b</code><code class="p">);</code><code class="w"/>&#13;
<code class="n">bpf_core_read</code><code class="p">(</code><code class="o">&amp;</code><code class="n">c</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">b</code><code class="o">-&gt;</code><code class="n">c</code><code class="p">);</code><code class="w"/>&#13;
<code class="n">bpf_core_read</code><code class="p">(</code><code class="o">&amp;</code><code class="n">d</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">c</code><code class="o">-&gt;</code><code class="n">d</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>But it’s much more compact to use:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BPF_CORE_READ</code><code class="p">(</code><code class="n">a</code><code class="p">,</code><code class="w"> </code><code class="n">b</code><code class="p">,</code><code class="w"> </code><code class="n">c</code><code class="p">,</code><code class="w"> </code><code class="n">d</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>You can then read from point <code>d</code> using the <code>bpf_probe_read_kernel()</code> helper function.</p>&#13;
<p>There’s a good description of this in Andrii’s <a href="https://oreil.ly/tU0Gb">guide</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="License Definition" data-type="sect2"><div class="sect2" id="license_definition">&#13;
<h2>License Definition</h2>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="license definition" data-type="indexterm" id="idm46123197834464"/><a contenteditable="false" data-primary="licenses" data-secondary="CO-RE and" data-type="indexterm" id="idm46123197833120"/>As you already know from <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>, the eBPF program has to declare its license. The example code does it like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">char</code><code class="w"> </code><code class="n">LICENSE</code><code class="p">[]</code><code class="w"> </code><code class="n">SEC</code><code class="p">(</code><code class="s">"license"</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"Dual BSD/GPL"</code><code class="p">;</code><code class="w"/></pre>&#13;
<p>You’ve now seen all the code in the <em>hello-buffer-config.bpf.c</em> example. Now let’s compile it into an object file<a contenteditable="false" data-primary="" data-startref="ch05.html12" data-type="indexterm" id="idm46123197824624"/><a contenteditable="false" data-primary="" data-startref="ch05.html11" data-type="indexterm" id="idm46123197799392"/>.<a contenteditable="false" data-primary="" data-startref="ch05.html7" data-type="indexterm" id="idm46123197797888"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Compiling eBPF Programs for CO-RE" data-type="sect1"><div class="sect1" id="compiling_ebpf_programs_for_co_re">&#13;
<h1>Compiling eBPF Programs for CO-RE</h1>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="compiling eBPF programs for" data-type="indexterm" id="ch05.html13"/><a contenteditable="false" data-primary="compilation to eBPF byte code" data-type="indexterm" id="ch05.html14"/>In <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a> you saw an extract from a Makefile that compiles C to eBPF bytecode. Let’s dig into the options used and see why they are necessary for CO-RE/<em>libbpf</em> <span class="keep-together">programs</span>.</p>&#13;
<section data-pdf-bookmark="Debug Information" data-type="sect2"><div class="sect2" id="debug_information">&#13;
<h2>Debug Information</h2>&#13;
<p><a contenteditable="false" data-primary="compilation to eBPF byte code" data-secondary="debug information" data-type="indexterm" id="idm46123197764704"/><a contenteditable="false" data-primary="debugging" data-type="indexterm" id="idm46123197763360"/>You have to pass the <code>-g</code> flag to Clang so that it includes debug information, which is necessary for BTF. However, the <code>-g</code> flag also adds DWARF debugging information to the output object file, but that’s not needed by eBPF programs, so you can reduce the size of the object by running the following command to strip it out:</p>&#13;
<pre data-type="programlisting">llvm-strip -g &lt;object file&gt;</pre>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Optimization" data-type="sect2"><div class="sect2" id="optimization">&#13;
<h2>Optimization</h2>&#13;
<p><a contenteditable="false" data-primary="compilation to eBPF byte code" data-secondary="optimization" data-type="indexterm" id="idm46123197758736"/><a contenteditable="false" data-primary="optimization" data-type="indexterm" id="idm46123197757392"/>The <code>-O2</code> optimization flag (level 2 or higher) is required for Clang to produce BPF bytecode that will pass the verifier. One example of this being necessary is that, by default, Clang will output <code>callx &lt;register&gt;</code> to call helper functions, but eBPF doesn’t support calling addresses from registers.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Target Architecture" data-type="sect2"><div class="sect2" id="target_architecture">&#13;
<h2>Target Architecture</h2>&#13;
<p><a contenteditable="false" data-primary="compilation to eBPF byte code" data-secondary="target architecture" data-type="indexterm" id="idm46123197753392"/><a contenteditable="false" data-primary="target architecture, specifying for CO-RE programs" data-type="indexterm" id="idm46123197751824"/>If you’re using certain macros defined by <em>libbpf</em>, you’ll need to specify the target architecture at compile time. The <em>libbpf</em> header file <em>bpf/bpf_tracing.h</em> defines several macros that are platform specific, such as <code>BPF_KPROBE</code> and <code>BPF_KPROBE_SYSCALL</code> that I’ve used in this example. The <code>BPF_KPROBE</code> macro can be used for eBPF programs that are being attached to kprobes, and <code>BPF_KPROBE_SYSCALL</code> is a variant specifically for syscall kprobes.</p>&#13;
<p>The argument to a kprobe is a <code>pt_regs</code> structure that holds a copy of the contents of the CPU registers. Since registers are architecture specific, the <code>pt_regs</code> structure definition depends on the architecture you’re running on. This means that if you want to use these macros, you’ll need to also tell the compiler what the target architecture is. You can do this by setting <code>-D __TARGET_ARCH_($ARCH)</code> where <code>$ARCH</code> is an architecture name like arm64, amd64, and so on.</p>&#13;
<p>Also note that if you didn’t use the macro, you’d need architecture-specific code to access the register information anyway for a kprobe.</p>&#13;
<p>Perhaps “compile once <em>per architecture</em>, run everywhere” would have been a bit of a mouthful!</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Makefile" data-type="sect2"><div class="sect2" id="makefile">&#13;
<h2>Makefile</h2>&#13;
<p><a contenteditable="false" data-primary="compilation to eBPF byte code" data-secondary="Makefile instruction" data-type="indexterm" id="idm46123197742432"/><a contenteditable="false" data-primary="Makefile" data-type="indexterm" id="idm46123197741040"/>The following is an example Makefile instruction for compiling CO-RE objects (taken from the Makefile in the <em>chapter5</em> directory of the GitHub repo for this book):</p>&#13;
<pre data-code-language="make" data-type="programlisting"><code class="nf">hello-buffer-config.bpf.o</code><code class="o">:</code> %.<code class="n">o</code>: %.<code class="n">c</code>&#13;
   clang \<code class="w"/>&#13;
       -target bpf \<code class="w"/>&#13;
       -D __TARGET_ARCH_<code class="k">$(</code><code class="nv">ARCH</code><code class="k">)</code> \<code class="w"/>&#13;
       -I/usr/include/<code class="k">$(</code><code class="nv">shell</code> <code class="nv">uname</code> -<code class="nv">m</code><code class="k">)</code>-linux-gnu \<code class="w"/>&#13;
       -Wall \<code class="w"/>&#13;
       -O2 -g \<code class="w"/>&#13;
       -c <code class="k">$&lt;</code> -o <code class="k">$@</code><code class="w"/>&#13;
   llvm-strip -g <code class="k">$@</code><code class="w"/></pre>&#13;
<p>If you’re using the example code, you should be able to build the eBPF object file <em>hello-buffer-config.bpf.o</em> (and its companion user space executable that I’ll describe shortly) by running <code>make</code> in the <em>chapter5</em> directory. Let’s inspect that object file to see that it includes BTF information.</p>&#13;
</div></section>&#13;
<section class="pagebreak-before" data-pdf-bookmark="BTF Information in the Object File" data-type="sect2"><div class="sect2" id="btf_information_in_the_object_file">&#13;
<h2 class="less_space">BTF Information in the Object File</h2>&#13;
<p><a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="information in object file" data-type="indexterm" id="idm46123197712576"/><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="BTF information in object file" data-type="indexterm" id="idm46123197708864"/>The <a href="https://oreil.ly/5QrBy">kernel documentation for BTF</a> describes how BTF data is encoded in an ELF object file in two sections: <em>.BTF</em>, which contains the data and string information, and <em>.BTF.ext</em>, which covers function and line information. You can use <code>readelf</code> to see that these sections have been added to the object file, like this:</p>&#13;
<pre data-type="programlisting">$ readelf -S hello-buffer-config.bpf.o | grep BTF&#13;
  [10] .BTF              PROGBITS         0000000000000000  000002c0&#13;
  [11] .rel.BTF          REL              0000000000000000  00000e50&#13;
  [12] .BTF.ext          PROGBITS         0000000000000000  00000b18&#13;
  [13] .rel.BTF.ext      REL              0000000000000000  00000ea0</pre>&#13;
<p>The <code>bpftool</code> utility lets us examine the BTF data from an object file, like this:</p>&#13;
<pre data-type="programlisting">bpftool btf dump file hello-buffer-config.bpf.o</pre>&#13;
<p>The output looks just like the output you get from dumping BTF info from loaded programs and maps, as you saw earlier in this chapter.</p>&#13;
<p>Let’s see how this BTF information can be used to allow the program to run on another machine with a different kernel version and different data structures.<a contenteditable="false" data-primary="" data-startref="ch05.html14" data-type="indexterm" id="idm46123197702656"/><a contenteditable="false" data-primary="" data-startref="ch05.html13" data-type="indexterm" id="idm46123197701280"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BPF Relocations" data-type="sect1"><div class="sect1" id="bpf_relocations">&#13;
<h1>BPF Relocations</h1>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="BPF relocation information" data-type="indexterm" id="idm46123197697504"/><a contenteditable="false" data-primary="relocations, BPF" data-type="indexterm" id="idm46123197696192"/>The <em>libbpf</em> library adapts eBPF programs to work with the data structure layout on the target kernel where they run, even if this layout is different from the kernel where the code was compiled. To do this, <em>libbpf</em> needs the BPF CO-RE relocation information generated by Clang as part of the compilation process.</p>&#13;
<p>You can learn more about how the relocations work from the definition of <code>struct bpf_core_relo</code> in the <a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/source/include/uapi/linux/bpf.h#L6711"><em>linux/bpf.h</em></a> header file:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/bpf_core_relo"><code class="nc">bpf_core_relo</code></a><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/insn_off"><code class="n">insn_off</code></a><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/type_id"><code class="n">type_id</code></a><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/access_str_off"><code class="n">access_str_off</code></a><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">enum</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/bpf_core_relo_kind"><code class="n">bpf_core_relo_kind</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/v5.19.17/C/ident/kind"><code class="n">kind</code></a><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code></pre>&#13;
<p>The CO-RE relocation data for an eBPF program consists of one of these structures for each instruction that needs relocation. Suppose the instruction is setting a register to the value of a field within a structure. The <code>bpf_core_relo</code> structure for that instruction (identified by the <code>insn_off</code> field) encodes the BTF type of that structure (the <code>type_id</code> field) and also indicates how the field is accessed relative to that structure (<code>access_str_off</code>).</p>&#13;
<p>As you’ve just seen, the relocation data for the kernel data structures is generated automatically by Clang and encoded in the ELF object file. It’s the following line, which you’ll find near the start of the <em>vmlinux.h</em> file, that causes Clang to do this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="cp">#pragma clang attribute push (__attribute__((preserve_access_index)), \</code>&#13;
<code class="cp">                                                               apply_to = record)</code></pre>&#13;
<p>The <code>preserve_access_index</code> attribute tells Clang to generate BPF CO-RE relocations for a type definition. The <code>clang attribute push</code> part says that this attribute should be applied to all definitions until a <code>clang attribute pop</code>, which appears at the end of the file. That means Clang generates the relocation information for all the types defined in <em>vmlinux.h</em>.</p>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="BPF relocations" data-type="indexterm" id="idm46123197586640"/>You can see the relocations taking place when you load a BPF program, by using <code>bpftool</code> and turning on the debug information with the <code>-d</code> flag, like this:</p>&#13;
<pre data-type="programlisting">bpftool -d prog load hello.bpf.o /sys/fs/bpf/hello</pre>&#13;
<p>This generates a lot of output, but the parts relating to relocation look like this:</p>&#13;
<pre data-type="programlisting">libbpf: CO-RE relocating [24] struct user_pt_regs: found target candidate [205]&#13;
struct user_pt_regs in [vmlinux]&#13;
libbpf: prog 'hello': relo #0: &lt;byte_off&gt; [24] struct user_pt_regs.regs[0]&#13;
(0:0:0 @ offset 0)&#13;
libbpf: prog 'hello': relo #0: matching candidate #0 &lt;byte_off&gt; [205] struct&#13;
user_pt_regs.regs[0] (0:0:0 @ offset 0)&#13;
libbpf: prog 'hello': relo #0: patched insn #1 (LDX/ST/STX) off 0 -&gt; 0</pre>&#13;
<p>In this example you can see that type ID 24 from the <code>hello</code> program’s BTF information refers to the structure called <code>user_pt_regs</code>. The <em>libbpf</em> library has matched this against a kernel structure, also called <code>user_pt_regs</code>, that has type ID 205 in the <em>vmlinux</em> BTF data set. In practice, because I compiled and loaded the program on the same machine, the type definitions are identical, so in this example the offset of 0 from the start of the structure remains unchanged, and the “patch” to instruction #1 leaves it unchanged.</p>&#13;
<p>In many applications you won’t want to ask users to run <code>bpftool</code> to load an eBPF program. Instead, you’ll want to build this functionality into a dedicated user space program that you supply as an executable. Let’s consider how to write this user space code.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="CO-RE User Space Code" data-type="sect1"><div class="sect1" id="co_re_user_space_code">&#13;
<h1>CO-RE User Space Code</h1>&#13;
<p><a contenteditable="false" data-primary="CO-RE (compile once, run everywhere) programs" data-secondary="user space code" data-type="indexterm" id="idm46123197576928"/><a contenteditable="false" data-primary="user space" data-secondary="CO-RE" data-type="indexterm" id="idm46123197575360"/>There are a few different frameworks in different programming languages that support CO-RE by implementing the relocations as they load eBPF programs into the kernel. In this chapter I’ll show C code that uses <em>libbpf</em>; other options include the Go packages <em>cilium/ebpf</em> and <em>libbpfgo</em>, and Aya for Rust. I’ll discuss those options further in <a data-type="xref" href="ch10.html#ebpf_programming">Chapter 10</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="The Libbpf Library for User Space" data-type="sect1"><div class="sect1" id="the_libbpf_library_for_user_space">&#13;
<h1>The Libbpf Library for User Space</h1>&#13;
<p><a contenteditable="false" data-primary="libbpf" data-secondary="user space" data-type="indexterm" id="ch05.html15"/><a contenteditable="false" data-primary="user space" data-secondary="libbpf library for" data-type="indexterm" id="ch05.html16"/>The <em>libbpf</em> library is a user space library you can use directly if you’re writing the user space part of your application in C. If you want to, you can use this library without using CO-RE. There’s an example of this in <a href="https://oreil.ly/b3v7B">Andrii Nakryiko’s excellent blog post on <em>libbpf-bootstrap</em></a>.</p>&#13;
<p><a contenteditable="false" data-primary="bpf() system calls" data-secondary="libppf wrapper around" data-type="indexterm" id="idm46123197548544"/>This library provides functions that wrap the <code>bpf()</code> and related syscalls that you met in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a> to perform operations like loading programs into the kernel and attaching them to events, or accessing map information from user space. The conventional and easiest way to use these abstractions is through auto-generated BPF skeleton code.</p>&#13;
<section data-pdf-bookmark="BPF Skeletons" data-type="sect2"><div class="sect2" id="bpf_skeletons">&#13;
<h2>BPF Skeletons</h2>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="auto-generating BPF skeleton code with" data-type="indexterm" id="ch05.html17"/><a contenteditable="false" data-primary="libbpf" data-secondary="BPF skeletons" data-type="indexterm" id="ch05.html18"/><a contenteditable="false" data-primary="skeleton code" data-secondary="bpftool for auto-generating" data-type="indexterm" id="ch05.html19"/>You can use <code>bpftool</code> to auto-generate this skeleton code from existing eBPF objects in ELF file format, like this:</p>&#13;
<pre data-type="programlisting">bpftool gen skeleton hello-buffer-config.bpf.o &gt; hello-buffer-config.skel.h</pre>&#13;
<p>Look into this skeleton header and you’ll see that it contains structure definitions for the eBPF programs and maps, as well as several functions that all start with the name <code>hello_buffer_config_bpf__</code> (based on the name of the object file). These functions manage the lifecycle of the eBPF programs and maps. You don’t have to use the skeleton code—you can make calls to <em>libbpf</em> directly if you prefer—but the auto-generated code will typically save you some typing.</p>&#13;
<p>Toward the end of the generated skeleton file you’ll see a function called <code>hello_buffer_config_bpf__elf_bytes</code> that returns the byte contents of the ELF object file <em>hello-buffer-config.bpf.o</em>. Once the skeleton has been generated, we don’t really need that object file anymore. You can test this by running <code>make</code> to generate the <code>hello-buffer-config</code> executable and then deleting the <em>.o</em> file; the executable has the eBPF bytecode contained within it.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you prefer, you can use the <em>libbpf</em> function <code>bpf_object__open_file</code> to load the eBPF programs and maps from an ELF file rather than using the bytes from a skeleton file.</p>&#13;
</div>&#13;
<p>Here’s the outline of the user space code that manages the lifecycle of the eBPF program and maps for this example, using the generated skeleton code. I have omitted some of the details and error handling for clarity, but you’ll find the full source code in <em>chapter5/hello-buffer-config.c</em>.</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w"> </code><code class="p">[</code><code class="n">other</code><code class="w"> </code><code class="err">#</code><code class="n">includes</code><code class="p">]</code><code class="w">&#13;
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">"hello-buffer-config.h"</code><code class="c1">                                       </code><a class="co" href="#list_id_5_5" id="code_id_5_5"><img alt="1" src="assets/1.png"/></a><code class="cp">&#13;
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">"hello-buffer-config.skel.h"</code><code class="cp">&#13;
</code><code class="w">&#13;
</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w"> </code><code class="p">[</code><code class="n">some</code><code class="w"> </code><code class="n">callback</code><code class="w"> </code><code class="n">functions</code><code class="p">]</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="n">main</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">{</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">hello_buffer_config_bpf</code><code class="w"> </code><code class="o">*</code><code class="n">skel</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">perf_buffer</code><code class="w"> </code><code class="o">*</code><code class="n">pb</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">NULL</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">err</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">libbpf_set_print</code><code class="p">(</code><code class="n">libbpf_print_fn</code><code class="p">)</code><code class="p">;</code><code class="w">                                 </code><a class="co" href="#list_id_5_6" id="code_id_5_6"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">skel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">hello_buffer_config_bpf__open_and_load</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">                   </code><a class="co" href="#list_id_5_7" id="code_id_5_7"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">err</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">hello_buffer_config_bpf__attach</code><code class="p">(</code><code class="n">skel</code><code class="p">)</code><code class="p">;</code><code class="w">                       </code><a class="co" href="#list_id_5_8" id="code_id_5_8"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">pb</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">perf_buffer__new</code><code class="p">(</code><code class="n">bpf_map__fd</code><code class="p">(</code><code class="n">skel</code><code class="o">-</code><code class="o">&gt;</code><code class="n">maps</code><code class="p">.</code><code class="n">output</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="n">handle_event</code><code class="p">,</code><code class="w">&#13;
</code><code class="w">                                                         </code><code class="n">lost_event</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">)</code><code class="p">;</code><code class="w">                                              </code><code class="w">&#13;
</code><code class="w">                                                                      </code><a class="co" href="#list_id_5_9" id="code_id_5_9"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nb">true</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">                                                     </code><a class="co" href="#list_id_5_10" id="code_id_5_10"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">       </code><code class="n">err</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">perf_buffer__poll</code><code class="p">(</code><code class="n">pb</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">perf_buffer__free</code><code class="p">(</code><code class="n">pb</code><code class="p">)</code><code class="p">;</code><code class="w">                                             </code><a class="co" href="#list_id_5_11" id="code_id_5_11"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="n">hello_buffer_config_bpf__destroy</code><code class="p">(</code><code class="n">skel</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="o">-</code><code class="n">err</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_5_5" id="list_id_5_5"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>This file includes the auto-generated skeleton header, as well as the header file I wrote manually for data structures shared between the user space and kernel code.</dd>&#13;
<dt><a class="co" href="#code_id_5_6" id="list_id_5_6"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>This code sets a callback function that will print any log messages generated by <em>libbpf</em>.</dd>&#13;
<dt><a class="co" href="#code_id_5_7" id="list_id_5_7"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Here a <code>skel</code> structure is created that represents all the maps and programs defined in the ELF bytes and loads them into the kernel.</dd>&#13;
<dt><a class="co" href="#code_id_5_8" id="list_id_5_8"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>Programs are auto-attached to the appropriate events.</dd>&#13;
<dt><a class="co" href="#code_id_5_9" id="list_id_5_9"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd>This function creates a structure for handling the perf buffer output.</dd>&#13;
<dt><a class="co" href="#code_id_5_10" id="list_id_5_10"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd>Here that perf buffer is continuously polled.</dd>&#13;
<dt><a class="co" href="#code_id_5_11" id="list_id_5_11"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd>This is the clean-up code.</dd>&#13;
</dl>&#13;
<p>Let’s dive into some of those steps in more detail.</p>&#13;
<section data-pdf-bookmark="Loading programs and maps into the kernel" data-type="sect3"><div class="sect3" id="loading_programs_and_maps_into_the_kern">&#13;
<h3>Loading programs and maps into the kernel</h3>&#13;
<p><a contenteditable="false" data-primary="libbpf" data-secondary="loading programs/maps into kernel" data-type="indexterm" id="idm46123197241552"/><a contenteditable="false" data-primary="skeleton code" data-secondary="loading programs/maps into kernel" data-type="indexterm" id="idm46123197240272"/>The first call to an auto-generated function is this one:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">skel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">hello_buffer_config_bpf__open_and_load</code><code class="p">();</code><code class="w"/></pre>&#13;
<p>As its name suggests, this function covers two phases: opening and loading. The “open” phase involves reading the ELF data and converting its sections into structures that represent eBPF programs and maps. The “load” phase loads those maps and programs into the kernel, performing any CO-RE fixups as necessary.</p>&#13;
<p>These two phases can easily be handled separately, as the skeleton code provides separate <code>name__open()</code> and <code>name__load()</code> functions. This gives you the option to manipulate the eBPF information before loading it. This is commonly done to configure a program before loading it. For example, I could initialize a counter global variable <code>c</code> to some value, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">skel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">hello_buffer_config_bpf__open</code><code class="p">();</code><code class="w"/>&#13;
<code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="n">skel</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Error ...</code>&#13;
<code class="p">}</code><code class="w">   </code>&#13;
<code class="n">skel</code><code class="o">-&gt;</code><code class="n">data</code><code class="o">-&gt;</code><code class="n">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"/>&#13;
<code class="n">err</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">hello_buffer_config_bpf__load</code><code class="p">(</code><code class="n">skel</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>The data type returned by <code>hello_buffer_config_bpf__open()</code>, and also by <code>hello_buffer_config_bpf__load()</code>, is a structure called <code>hello_buffer_config_bpf</code> defined in the skeleton header to include information about all the maps, programs, and data defined in the object file.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The skeleton object (<code>hello_buffer_config_bpf</code> in this example) is just a user space representation of information from the ELF bytes. Once it has been loaded into the kernel, if you change a value in the object, it won’t have any effect on the kernel-side data. So, for example, changing <code>skel-&gt;data-&gt;c</code> after loading will not have any effect.</p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Accessing existing maps" data-type="sect3"><div class="sect3" id="accessing_existing_maps">&#13;
<h3>Accessing existing maps</h3>&#13;
<p><a contenteditable="false" data-primary="libbpf" data-secondary="accessing maps" data-type="indexterm" id="idm46123197168160"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="accessing" data-type="indexterm" id="idm46123197166560"/><a contenteditable="false" data-primary="skeleton code" data-secondary="accessing maps" data-type="indexterm" id="idm46123197165184"/>By default, <em>libbpf</em> will also create any maps that are defined in the ELF bytes, but sometimes you might want to write an eBPF program that reuses an existing map. You already saw an example of this in the previous chapter, where you saw <code>bpftool</code> iterating through all the maps, looking for the one that matched a specified name. Another common reason to use a map is to share information between two different eBPF programs, so only one program should create the map. The <code>bpf_map__set_autocreate()</code> function allows you to override <em>libbpf</em>’s auto-creation.</p>&#13;
<p>So how do you access an existing map? Maps can be pinned, and if you know the pinned path, you can get a file descriptor to an existing map with <code>bpf_obj_get()</code>. Here’s a very simple example (available in the GitHub repository as <em>chapter5/find-map.c</em>):</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><code class="nc">bpf_map_info</code><code class="w"> </code><code class="n">info</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{};</code><code class="w"/>&#13;
<code class="kt">unsigned</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">len</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">info</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">findme</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_obj_get</code><code class="p">(</code><code class="s">"/sys/fs/bpf/findme"</code><code class="p">);</code><code class="w"/>&#13;
<code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">findme</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">printf</code><code class="p">(</code><code class="s">"No FD</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">bpf_obj_get_info_by_fd</code><code class="p">(</code><code class="n">findme</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">info</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">len</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">printf</code><code class="p">(</code><code class="s">"Name: %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">info</code><code class="p">.</code><code class="n">name</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>To try this out you can create a map using <code>bpftool</code>, like this:</p>&#13;
<pre data-type="programlisting">$ bpftool map create /sys/fs/bpf/findme type array key 4 value 32 entries 4&#13;
name findme</pre>&#13;
<p>Running the find-map executable will print out:</p>&#13;
<pre data-type="programlisting">Name: findme</pre>&#13;
<p>Let’s get back to the <em>hello-buffer-config</em> example and the skeleton code.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Attaching to events" data-type="sect3"><div class="sect3" id="attaching_to_events">&#13;
<h3>Attaching to events</h3>&#13;
<p><a contenteditable="false" data-primary="execve syscall function" data-type="indexterm" id="idm46123196998976"/><a contenteditable="false" data-primary="skeleton code" data-secondary="attaching program to events" data-type="indexterm" id="idm46123196998000"/>The next skeleton function in the example attaches the program to the <code>execve</code> syscall function:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">err</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">hello_buffer_config_bpf__attach</code><code class="p">(</code><code class="n">skel</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>The <em>libbpf</em> library automatically takes the attachment point from the <code>SEC()</code> definition for this program. If you didn’t define the attachment point fully, there are a whole series of <em>libbpf</em> functions, such as <code>bpf_program__attach_kprobe</code>, <code>bpf_program__attach_xdp</code>, and so on, for attaching different program types.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Managing an event buffer" data-type="sect3"><div class="sect3" id="managing_an_event_buffer">&#13;
<h3>Managing an event buffer</h3>&#13;
<p><a contenteditable="false" data-primary="event buffer" data-type="indexterm" id="idm46123196975296"/><a contenteditable="false" data-primary="perf buffers" data-secondary="managing" data-type="indexterm" id="idm46123196974192"/><a contenteditable="false" data-primary="skeleton code" data-secondary="managing an event buffer" data-type="indexterm" id="idm46123196972816"/>Setting up the perf buffer uses a function defined in <em>libbpf</em> itself, rather than in the skeleton:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">pb</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">perf_buffer__new</code><code class="p">(</code><code class="n">bpf_map__fd</code><code class="p">(</code><code class="n">skel</code><code class="o">-&gt;</code><code class="n">maps</code><code class="p">.</code><code class="n">output</code><code class="p">),</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="n">handle_event</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                                                         </code><code class="n">lost_event</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">,</code><code class="w"> </code><code class="nb">NULL</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>You can see the <code>perf_buffer__new()</code> function takes the file descriptor for the “output” map as the first argument. The <code>handle_event</code> argument is a callback function that gets called when new data arrives in the perf buffer, and <code>lost_event</code> gets called if there isn’t enough room in the perf buffer for the kernel to write a data entry. In my example these functions just write messages to the screen.</p>&#13;
<p>Finally, the program has to poll the perf buffer repeatedly:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nb">true</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">err</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">perf_buffer__poll</code><code class="p">(</code><code class="n">pb</code><code class="p">,</code><code class="w"> </code><code class="mi">100</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="p">...</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>The 100 is a timeout in milliseconds. The callback functions previously set up will get called as appropriate when data arrives or when the buffer is full.</p>&#13;
<p>Finally, to clean up I free the perf buffer and destroy the eBPF programs and maps in the kernel, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">perf_buffer__free</code><code class="p">(</code><code class="n">pb</code><code class="p">);</code><code class="w"/>&#13;
<code class="n">hello_buffer_config_bpf__destroy</code><code class="p">(</code><code class="n">skel</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>There are a whole set of <code>perf_buffer_*</code>- and <code>ring_buffer_*</code>-related functions in <em>libbpf</em> to help you manage event buffers.</p>&#13;
<p>If you make and run this example <code>hello-buffer-config</code> program, you’ll see the following output (that’s very similar to what you saw in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>):<a contenteditable="false" data-primary="" data-startref="ch05.html19" data-type="indexterm" id="idm46123196836480"/><a contenteditable="false" data-primary="" data-startref="ch05.html18" data-type="indexterm" id="idm46123196835104"/><a contenteditable="false" data-primary="" data-startref="ch05.html17" data-type="indexterm" id="idm46123196833728"/></p>&#13;
<pre data-type="programlisting">23664  501    bash             Hello World&#13;
23665  501    bash             Hello World&#13;
23667  0      cron             Hello World&#13;
23668  0      sh               Hello World</pre>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Libbpf Code Examples" data-type="sect2"><div class="sect2" id="libbpf_code_examples">&#13;
<h2>Libbpf Code Examples</h2>&#13;
<p><a contenteditable="false" data-primary="libbpf" data-secondary="code examples" data-type="indexterm" id="idm46123196808752"/>There are lots of great examples of <em>libbpf</em>-based eBPF programs available that you can use as inspiration and guidance for writing your own:</p>&#13;
<ul>&#13;
<li><p>The <a href="https://oreil.ly/zB0Co"><em>libbpf-bootstrap</em></a> project is intended to help you get off the ground with a set of example programs.</p></li>&#13;
<li><p>The BCC project has many of the original BCC-based tools migrated to a <em>libbpf</em> version. You’ll find them in the <a href="https://oreil.ly/Z9xDX"><em>libbpf-tools</em> directory</a>.<a contenteditable="false" data-primary="" data-startref="ch05.html16" data-type="indexterm" id="idm46123196803104"/><a contenteditable="false" data-primary="" data-startref="ch05.html15" data-type="indexterm" id="idm46123196801696"/></p></li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000014">&#13;
<h1>Summary</h1>&#13;
<p>CO-RE enables eBPF programs that can run on kernel versions different from the versions on which they were built. This massively improves the portability of eBPF and makes life much easier for tool developers who want to deliver production-ready tooling to their users and customers.</p>&#13;
<p>In this chapter you saw how CO-RE achieves this by encoding type information into the compiled object file and using relocations to rewrite instructions as they are loaded into the kernel. You also had an introduction to writing code in C that uses <em>libbpf</em>: both the eBPF programs that run in the kernel and the user space programs that manage the lifecycle of those programs, based on auto-generated BPF skeleton code. In the next chapter you’ll learn how the kernel verifies that eBPF programs are safe to run.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="exercises_id000004">&#13;
<h1>Exercises</h1>&#13;
<p>Here are a few things you can do to further explore BTF, CO-RE, and <em>libbpf</em>:</p>&#13;
<ol>&#13;
<li><p>Experiment with <code>bpftool btf dump map</code> and <code>bpftool btf dump prog</code> to see the BTF information associated with maps and programs, respectively. Remember that you can specify individual maps and programs in more than one way.</p></li>&#13;
<li><p>Compare the output from <code>bpftool btf dump file</code> and <code>bpftool btf dump prog</code> for the same program in its ELF object file form and after it has been loaded into the kernel. They should be identical.</p></li>&#13;
<li><p>Examine the debug output from <em>bpftool -d prog load hello-buffer-config.bpf.o /sys/fs/bpf/hello</em>. You’ll see each section being loaded, checks on the license, and relocations taking place, as well as output describing each BPF program instruction.</p></li>&#13;
<li><p>Try building a BPF program against a different <em>vmlinux</em> header file from BTFHub, and look in the debug output from <code>bpftool</code> for relocations that change offsets.</p></li>&#13;
<li><p>Modify the <em>hello-buffer-config.c</em> program so that you can configure different messages for different user IDs using the map (similar to the <em>hello-buffer-config.py</em> example in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>).</p></li>&#13;
<li><p>Try changing the section name in the <code>SEC();</code>, perhaps to your own name. When you come to load the program into the kernel you should see an error because <em>libbpf</em> doesn’t recognize the section name. This illustrates how <em>libbpf</em> uses the section name to work out what kind of BPF program this is. You could try writing your own attachment code to explicitly attach to an event of your choice rather than relying on <em>libbpf</em>’s auto-attachment.</p></li>&#13;
</ol>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch05fn1"><sup><a href="ch05.html#ch05fn1-marker">1</a></sup> Strictly speaking, the data structure definitions come from kernel header files, and you could choose to compile based on a set of these header files that is different from what was used to build the kernel running on that machine. To work correctly (without the CO-RE mechanisms described in this chapter), the kernel headers have to be compatible with the kernel on the target machine where the eBPF program will run.</p><p data-type="footnote" id="ch05fn2"><sup><a href="ch05.html#ch05fn2-marker">2</a></sup> Part of this section is adapted from “What Is eBPF?” by Liz Rice. Copyright © 2022 O’Reilly Media. Used with permission.</p><p data-type="footnote" id="ch05fn3"><sup><a href="ch05.html#ch05fn3-marker">3</a></sup> A small and unscientific survey suggests that most people pronounce this the same as the word <em>core</em> rather than in two syllables.</p><p data-type="footnote" id="ch05fn4"><sup><a href="ch05.html#ch05fn4-marker">4</a></sup> See the kernel documentation at <a href="https://docs.kernel.org/bpf/btf.html#type-encoding"><em class="hyperlink">https://docs.kernel.org/bpf/btf.html#type-encoding</em></a>.</p><p data-type="footnote" id="ch05fn5"><sup><a href="ch05.html#ch05fn5-marker">5</a></sup> The kernel needs to have been built with the <code>CONFIG_DEBUG_INFO_BTF</code> option enabled.</p><p data-type="footnote" id="ch05fn6"><sup><a href="ch05.html#ch05fn6-marker">6</a></sup> Which is the oldest Linux kernel version that can support BTF? See <a href="https://oreil.ly/HML9m"><em class="hyperlink">https://oreil.ly/HML9m</em></a>.</p><p data-type="footnote" id="ch05fn7"><sup><a href="ch05.html#ch05fn7-marker">7</a></sup> Well, normal C preprocessing applies so that you can do things like <code>#define</code>. But there’s no <em>special</em> rewriting like there is when you use BCC.</p><p data-type="footnote" id="ch05fn8"><sup><a href="ch05.html#ch05fn8-marker">8</a></sup> eBPF programs handling network packets don’t get to use this helper function and can only access the network packet memory.</p><p data-type="footnote" id="ch05fn9"><sup><a href="ch05.html#ch05fn9-marker">9</a></sup> It is permitted in certain BTF-enabled program types such as <code>tp_btf</code>, <code>fentry</code>, and <code>fexit</code>.</p></div></div></section></body></html>