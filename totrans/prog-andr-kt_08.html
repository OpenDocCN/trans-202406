<html><head></head><body><section data-pdf-bookmark="Chapter 8. Structured Concurrency with Coroutines" data-type="chapter" epub:type="chapter"><div class="chapter" id="coroutines_in_practice_id">&#13;
<h1><span class="label">Chapter 8. </span>Structured Concurrency with Coroutines</h1>&#13;
&#13;
&#13;
<p><a data-primary="structured concurrency with coroutines" data-type="indexterm" id="ix_ch08-asciidoc0"/>In the previous chapter, we introduced a new asynchronous programming &#13;
<span class="keep-together">paradigm—coroutines.</span> When using coroutines,&#13;
it’s important to know how to use suspending functions appropriately; we’ll cover that topic in this chapter. As most programs have to deal with&#13;
exception handling and cancellation, we’ll also cover these topics—and you’ll see that, in this regard, coroutines have&#13;
their own set of rules you should be aware of.</p>&#13;
&#13;
<p>The first section of this chapter covers the idiomatic usage of suspending functions. We’ll take the&#13;
example of a hiking app to compare two implementations: one based on threads and the other one based on suspending functions&#13;
and coroutines. You’ll see how this comparison highlights the power of coroutines in some situations.</p>&#13;
&#13;
<p>As is common for most mobile apps, the hiking example requires a <em>cancellation mechanism</em>.  We’ll cover all you need to&#13;
know about cancellation with coroutines. In order to prepare for most situations, we’ll then cover <em>parallel decomposition</em>&#13;
and <em>supervison</em>. Using these concepts, you’ll be able to implement&#13;
complex concurrent logic if you need to.</p>&#13;
&#13;
<p>Finally, this chapter ends with an explanation of exception handling with coroutines.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Suspending Functions" data-type="sect1"><div class="sect1" id="idm46669749588176">&#13;
<h1>Suspending Functions</h1>&#13;
&#13;
<p><a data-primary="structured concurrency with coroutines" data-secondary="suspending functions" data-type="indexterm" id="ix_ch08-asciidoc1"/><a data-primary="suspending functions" data-secondary="structured concurrency with coroutines" data-type="indexterm" id="ix_ch08-asciidoc2"/>Imagine that you’re developing an application to help users plot, plan, track, draw, and share information about hiking.&#13;
Your users should be able to navigate to any of the hikes they’ve already completed or that are in progress. Before going out&#13;
for a given hike, some basic statistics are useful, like:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Total distance</p>&#13;
</li>&#13;
<li>&#13;
<p>The length of the last hike in both time and distance</p>&#13;
</li>&#13;
<li>&#13;
<p>The current weather along the trail they chose</p>&#13;
</li>&#13;
<li>&#13;
<p>Favorite hikes</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Such an application would require various interactions between the client and server(s) for meteorological&#13;
data and user information. How might we choose to store data for such an application?</p>&#13;
&#13;
<p>We may choose to store this data locally for later use, or on remote servers (which is referred to as&#13;
<em>persistence strategies</em>). Longer-running tasks, especially networking or IO tasks, can take shape with&#13;
background jobs like reading from a database, a local file, or a protobuf; or querying&#13;
a remote server. At its core, reading data from a host device will always be faster than reading the same data from the&#13;
network.</p>&#13;
&#13;
<p>So, the retrieved data may come at variable rates, depending on the nature of the query. Our worker logic must be&#13;
resilient and flexible enough to support and survive this situation, and tough enough to handle circumstances&#13;
beyond our control or even awareness.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Set the Scene" data-type="sect2"><div class="sect2" id="idm46669749577216">&#13;
<h2>Set the Scene</h2>&#13;
&#13;
<p>You need to build out a feature that allows users to retrieve their favorite hikes along with the current weather for each&#13;
of those hikes.</p>&#13;
&#13;
<p>We’ve already gone ahead and provided some library code of the application described in the beginning of the chapter.&#13;
The following is a set of classes and functions already made available to you:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Hike</code><code class="p">(</code>&#13;
   <code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
   <code class="k">val</code> <code class="py">miles</code><code class="p">:</code> <code class="n">Float</code><code class="p">,</code>&#13;
   <code class="k">val</code> <code class="py">ascentInFeet</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Weather</code> <code class="c1">// Implementation removed for brevity</code>&#13;
&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">HikeData</code><code class="p">(</code><code class="k">val</code> <code class="py">hike</code><code class="p">:</code> <code class="n">Hike</code><code class="p">,</code> <code class="k">val</code> <code class="py">weather</code><code class="p">:</code> <code class="n">Weather</code><code class="p">?)</code></pre>&#13;
&#13;
<p><code>Weather</code> isn’t a Kotlin data class, because we need a name for a type for the weather attribute for <code>HikeData</code> (if&#13;
 we had declared <code>Weather</code> as a data class without providing attributes, the code wouldn’t compile).</p>&#13;
&#13;
<p class="pagebreak-before">A <code>Hike</code>, in this example, is only:</p>&#13;
<ol>&#13;
<li>&#13;
<p>A name</p>&#13;
</li>&#13;
<li>&#13;
<p>A total number of miles</p>&#13;
</li>&#13;
<li>&#13;
<p>The total ascent in feet</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>A <code>HikeData</code> pairs a <code>Hike</code> object with a <em>nullable</em> <code>Weather</code> instance (if we couldn’t get the weather data for some&#13;
reason).</p>&#13;
&#13;
<p>We are also provided with the methods to fetch the list of a <code>Hike</code> given a user id along with weather data for a hike:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">fetchHikesForUser</code><code class="p">(</code><code class="n">userId</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Hike</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// implementation removed for brevity</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">fetchWeather</code><code class="p">(</code><code class="n">hike</code><code class="p">:</code> <code class="n">Hike</code><code class="p">):</code> <code class="n">Weather</code> <code class="p">{</code>&#13;
    <code class="c1">// implementation removed for brevity</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Those two functions might be long-running operations—like querying a database or an API. In order to avoid blocking&#13;
the UI thread while fetching the list of hikes or the current weather, we’ll leverage suspending functions.</p>&#13;
&#13;
<p>We believe that the best way to understand how to use suspending functions is to compare the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A “traditional” approach using threads and <code>Handler</code></p>&#13;
</li>&#13;
<li>&#13;
<p>An implementation using suspending functions with coroutines</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>First we’ll show you how the traditional approach has its limitations in some situations, and that it’s not easy to overcome them. Then we’ll show you how using suspending functions and coroutines changes the way we implement asynchronous&#13;
logic and how we can solve all the problems we had with the traditional approach.</p>&#13;
&#13;
<p>Let’s start with the thread-based implementation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Traditional Approach Using java.util.concurrent.ExecutorService" data-type="sect2"><div class="sect2" id="idm46669749576592">&#13;
<h2>Traditional Approach Using java.util.concurrent.ExecutorService</h2>&#13;
&#13;
<p><a data-primary="suspending functions" data-secondary="java.util.concurrent.ExecutorService approach for" data-type="indexterm" id="ix_ch08-asciidoc3"/><code>fetchHikesForUser</code> and <code>fetchWeather</code> functions should be invoked from a background thread. In Android, that might be&#13;
done in any number of ways. Java has the traditional <code>Thread</code> library of course, and the <code>Executors</code> framework. The Android&#13;
standard library has the (now legacy) <code>AsyncTask</code>, <code>HandlerThread</code>, as well as the &#13;
<span class="keep-together"><code>ThreadPoolExecutor</code></span> class.</p>&#13;
&#13;
<p>Among all those possibilities, we want to take the best implementation in terms of expressiveness, readability, and&#13;
control. For those reasons, we decided to leverage the <code>Executors</code> framework.</p>&#13;
&#13;
<p>Inside a <code>ViewModel</code>, suppose you use one of the factory methods for <code>ExecutorService</code> from the <code>Executors</code> class&#13;
to get back a <code>ThreadPoolExecutor</code> for performing asynchronous work using the traditional thread-based model.</p>&#13;
&#13;
<p>In the following, we’ve chosen a <em>work-stealing</em> pool. Compared to a simple-thread pool with a blocking queue, a work-stealing pool can reduce contention while keeping a targeted number of threads active. The idea behind this is that enough work queues are maintained so that an overwhelmed worker<sup><a data-type="noteref" href="ch08.html#idm46669749430800" id="idm46669749430800-marker">1</a></sup> might have one of its tasks “stolen” by another worker which is less loaded:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">HikesViewModel</code> <code class="p">:</code> <code class="n">ViewModel</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">ioThreadPool</code><code class="p">:</code> <code class="n">ExecutorService</code> <code class="p">=</code>&#13;
        <code class="n">Executors</code><code class="p">.</code><code class="n">newWorkStealingPool</code><code class="p">(</code><code class="m">10</code><code class="p">)</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">fetchHikesAsync</code><code class="p">(</code><code class="n">userId</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">ioThreadPool</code><code class="p">.</code><code class="n">submit</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">hikes</code> <code class="p">=</code> <code class="n">fetchHikesForUser</code><code class="p">(</code><code class="n">userId</code><code class="p">)</code>&#13;
            <code class="n">onHikesFetched</code><code class="p">(</code><code class="n">hikes</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">onHikesFetched</code><code class="p">(</code><code class="n">hikes</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Hike</code><code class="p">&gt;)</code> <code class="p">{</code>&#13;
        <code class="c1">// Continue with the rest of the view-model logic</code>&#13;
        <code class="c1">// Beware, this code is executed from a background thread</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When performing IO operations, having 10 threads is reasonable, even on Android devices. In the case of&#13;
<code>Executors.newWorkStealingPool</code>, the actual number of threads grows and shrinks dynamically, depending on the load.&#13;
Do note, however, that a work-stealing pool makes no guarantees about the order in which submitted tasks are executed.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We could also have leveraged the Android primitive<a data-primary="ThreadPoolExecutor" data-type="indexterm" id="idm46669749331872"/> <code>ThreadPoolExecutor</code> class. More specifically, we could have&#13;
created our thread pool this way:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">val</code> <code class="py">ioThreadPool</code><code class="p">:</code> <code class="n">ExecutorService</code> <code class="p">=</code>&#13;
    <code class="n">ThreadPoolExecutor</code><code class="p">(</code>&#13;
        <code class="m">4</code><code class="p">,</code>   <code class="c1">// Initial pool size</code>&#13;
        <code class="m">10</code><code class="p">,</code>  <code class="c1">// Maximum pool size</code>&#13;
        <code class="m">1L</code><code class="p">,</code>&#13;
        <code class="n">TimeUnit</code><code class="p">.</code><code class="n">SECONDS</code><code class="p">,</code>&#13;
        <code class="n">LinkedBlockingQueue</code><code class="p">()</code>&#13;
    <code class="p">)</code></pre>&#13;
&#13;
<p>The usage is then exactly the same. Even if there are subtle differences with the work-stealing pool we initially&#13;
created, what’s important to notice here is how you can submit tasks to the thread pool.</p>&#13;
</div>&#13;
&#13;
<p>Using a thread pool just for <code>fetchHikesForUser</code> could be overkill—especially if you don’t invoke&#13;
<code>fetchHikesForUser</code> for different users concurrently.&#13;
Consider the rest of the implementation that uses an <code>ExecutorService</code> for more sophisticated concurrent work, as shown&#13;
in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">HikesViewModel</code><code> </code><code class="p">:</code><code> </code><code class="n">ViewModel</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="c1">// other attributes&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">hikeDataList</code><code> </code><code class="p">=</code><code> </code><code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">HikeData</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">hikeLiveData</code><code> </code><code class="p">=</code><code> </code><code class="n">MutableLiveData</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">HikeData</code><code class="p">&gt;</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">fun</code><code> </code><code class="nf">fetchHikesAsync</code><code class="p">(</code><code class="n">userId</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><code class="c1">// content hidden }&#13;
</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">fun</code><code> </code><code class="nf">onHikesFetched</code><code class="p">(</code><code class="n">hikes</code><code class="p">:</code><code> </code><code class="n">List</code><code class="p">&lt;</code><code class="n">Hike</code><code class="p">&gt;</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="n">hikes</code><code class="p">.</code><code class="n">forEach</code><code> </code><code class="p">{</code><code> </code><code class="n">hike</code><code>  </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>            </code><code class="n">ioThreadPool</code><code class="p">.</code><code class="n">submit</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                </code><code class="k">val</code><code> </code><code class="py">weather</code><code> </code><code class="p">=</code><code> </code><code class="n">fetchWeather</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code><code>         </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO1-1" id="co_structured_concurrency_with_coroutines_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>                </code><code class="k">val</code><code> </code><code class="py">hikeData</code><code> </code><code class="p">=</code><code> </code><code class="n">HikeData</code><code class="p">(</code><code class="n">hike</code><code class="p">,</code><code> </code><code class="n">weather</code><code class="p">)</code><code>   </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO1-2" id="co_structured_concurrency_with_coroutines_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>                </code><code class="n">hikeDataList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">hikeData</code><code class="p">)</code><code>               </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO1-3" id="co_structured_concurrency_with_coroutines_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>                </code><code class="n">hikeLiveData</code><code class="p">.</code><code class="n">postValue</code><code class="p">(</code><code class="n">hikeDataList</code><code class="p">)</code><code>     </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO1-4" id="co_structured_concurrency_with_coroutines_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">For each <code>Hike</code>, a new task is submitted. This new task:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO1-1" id="callout_structured_concurrency_with_coroutines_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Fetches weather information</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO1-2" id="callout_structured_concurrency_with_coroutines_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Stores <code>Hike</code> and <code>Weather</code> objects inside a <code>HikeData</code> container</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO1-3" id="callout_structured_concurrency_with_coroutines_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Adds the <code>HikeData</code> instance to an internal list</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO1-4" id="callout_structured_concurrency_with_coroutines_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Notifies the view that the <code>HikeData</code> list has changed, which will pass the newly updated state of that list data</p></dd>&#13;
</dl>&#13;
&#13;
<p>We explicitly left a common mistake in the preceding code.  Can you spot it?&#13;
Although it runs fine as is, imagine that we add a public method to add a new hike:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">addHike</code><code class="p">(</code><code class="n">hike</code><code class="p">:</code> <code class="n">Hike</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">hikeDataList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">HikeData</code><code class="p">(</code><code class="n">hike</code><code class="p">,</code> <code class="k">null</code><code class="p">))</code>&#13;
    <code class="c1">// then fetch Weather and notify view using hikeLiveData</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In step 3 in the <code>onHikesFetched</code> method, we added a new element to&#13;
&#13;
<span class="keep-together"><code>hikeDataList</code></span> from one of the background threads of <code>ioThreadPool</code>.&#13;
What could go wrong with such a harmless method?</p>&#13;
&#13;
<p>You could try to invoke <code>addHike</code> from the main thread while <code>hikeDataList</code> is being modified by a background thread.</p>&#13;
&#13;
<p>Nothing enforces the thread from which the public <code>addHike</code> is going to be called. In Kotlin on the JVM, a mutable list&#13;
is backed by an<a data-primary="ArrayList" data-type="indexterm" id="idm46669749244576"/> <code>ArrayList</code>. However, an <code>ArrayList</code> isn’t <em>thread-safe</em>. Actually, this isn’t the only&#13;
mistake we’ve made. <code>hikeDataList</code> isn’t correctly published—there’s no guarantee that in step 4 the background&#13;
thread sees an updated value for <code>hikeDataList</code>. There is no <em>happens before</em><sup><a data-type="noteref" href="ch08.html#idm46669749241152" id="idm46669749241152-marker">2</a></sup>&#13;
enforcement here from the Java memory model—the background thread might not see an up-to-date state of <code>hikeDataList</code>,&#13;
even if the main thread put a new element in the list &#13;
<span class="keep-together">beforehand.</span></p>&#13;
&#13;
<p>Consequently, the iterator within the <code>onHikesFetched</code> chain will throw a <code>ConcurrentModificationException</code> when it&#13;
realizes the collection has been “magically” modified. Populating <code>hikeDataList</code> from a background thread isn’t safe in&#13;
this case (see <a data-type="xref" href="#fig8_1">Figure 8-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig8_1">&#13;
<img alt="AddHike ConcurrenctModificationException" src="assets/pawk_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span><code>addHike</code> adds to the existing <code>hikeDataList</code> that is already being modified in the background thread.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Falling into this pattern, even when safe, increases the likelihood that habit overtakes sensibility&#13;
and that during the same day or week or month, this mistake repeats in a less safe circumstance.&#13;
Consider other team members with edit access to the same codebase and you can see that we quickly lose control.</p>&#13;
&#13;
<p>Thread safety matters anytime multiple threads are attempting to access the same resource at the same time, and it’s hard&#13;
to get right. This is why <em>defaulting to the main thread</em><sup><a data-type="noteref" href="ch08.html#idm46669749034928" id="idm46669749034928-marker">3</a></sup>&#13;
is considered a good practice.</p>&#13;
&#13;
<p>So how would you do this? Are you able to get the background thread to tell the main thread “add this element to&#13;
this list whenever you can, then notify the view with the updated list of <code>HikeData</code>”? For this purpose, you can use&#13;
the handy <code>HandlerThread</code> and <code>Handler</code> classes.<a data-startref="ix_ch08-asciidoc3" data-type="indexterm" id="idm46669749031072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Reminder About HandlerThread" data-type="sect2"><div class="sect2" id="idm46669749471808">&#13;
<h2>A Reminder About HandlerThread</h2>&#13;
&#13;
<p><a data-primary="HandlerThread" data-type="indexterm" id="ix_ch08-asciidoc4"/><a data-primary="suspending functions" data-secondary="HandlerThread" data-type="indexterm" id="ix_ch08-asciidoc5"/>A <code>HandlerThread</code> is a thread to which a “message loop” is attached. It’s an&#13;
implementation of the producer-consumer design pattern, where the <code>HandlerThread</code> is the consumer. A <code>Handler</code> sits&#13;
between the actual message queue and other threads that can send new messages. Internally,&#13;
the loop that consumes the message queue is created using the<a data-primary="Looper class" data-type="indexterm" id="idm46669749024576"/> <code>Looper</code> class (also called “looper”). A <code>HandlerThread</code>&#13;
completes when you invoke its <code>quit</code> or <code>quickSafely</code> method. Paraphrasing Android’s documentation, the <code>quit</code> method causes&#13;
the handler thread’s looper to terminate without processing any more messages in the message queue. The<a data-primary="quitSafely" data-type="indexterm" id="idm46669749021392"/> <code>quitSafely</code>&#13;
method causes the handler thread’s looper to terminate as soon as all remaining messages in the message queue, that are&#13;
already due to be delivered, have been handled.</p>&#13;
&#13;
<p>Be really careful about remembering to stop a <code>HandlerThread</code>. For example, imagine you start a <code>HandlerThread</code> within&#13;
the lifecycle of an activity (say, in an <code>onCreate</code> method of a fragment). If you rotate the device, the activity&#13;
is destroyed and then re-created. A new <code>HandlerThread</code> instance is then created and started while the old one is still&#13;
running, leading to a serious memory leak (see <a data-type="xref" href="#fig_8_2">Figure 8-2</a>)!</p>&#13;
&#13;
<figure><div class="figure" id="fig_8_2">&#13;
<img alt="HandlerThread" src="assets/pawk_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>A <code>HandlerThread</code> consumes tasks coming from the <code>MessageQueue</code>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>On Android, the main thread is a <code>HandlerThread</code>. Because creating a <code>Handler</code> to post messages to the main thread&#13;
is very common, a static method on the <code>Looper</code> class exists to get the reference on the main thread’s <code>Looper</code> instance. Using a <code>Handler</code>, you can post a <code>Runnable</code> to be executed on the thread that the <code>Looper</code> instance associated with the <code>Handler</code> is attached to. The Java signature is:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">final</code> <code class="kt">boolean</code> <code class="nf">post</code><code class="o">(</code><code class="nd">@NonNull</code> <code class="n">Runnable</code> <code class="n">r</code><code class="o">)</code> <code class="o">{</code> <code class="o">...</code> <code class="o">}</code></pre>&#13;
&#13;
<p>Since a <code>Runnable</code> only has one abstract method, <code>run</code>, it can be nice and syntactically sweetened  in Kotlin using a&#13;
lambda, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Direct translation in Kotlin (though not idiomatic)</code>&#13;
<code class="n">handler</code><code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="k">object</code><code class="p">:</code> <code class="n">Runnable</code> <code class="p">{</code>&#13;
      <code class="k">override</code> <code class="k">fun</code> <code class="nf">run</code><code class="p">()</code> <code class="p">{</code>&#13;
         <code class="c1">// content of run</code>&#13;
      <code class="p">}</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// ..which can be nicely simplified into:</code>&#13;
<code class="n">handler</code><code class="p">.</code><code class="n">post</code> <code class="p">{</code>&#13;
    <code class="c1">// content of `run` method</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">In practice, you just create it like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">handler</code><code class="p">:</code> <code class="n">Handler</code> <code class="p">=</code> <code class="n">Handler</code><code class="p">(</code><code class="n">Looper</code><code class="p">.</code><code class="n">getMainLooper</code><code class="p">())</code></pre>&#13;
&#13;
<p>Then you can can utilize the loop handler in the previous example, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">HikesViewModel</code><code> </code><code class="p">:</code><code> </code><code class="n">ViewModel</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">ioThreadPool</code><code class="p">:</code><code> </code><code class="n">ExecutorService</code><code> </code><code class="p">=</code><code> </code><code class="n">Executors</code><code class="p">.</code><code class="n">newWorkStealingPool</code><code class="p">(</code><code class="m">1</code><code class="m">0</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">hikeDataList</code><code> </code><code class="p">=</code><code> </code><code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">HikeData</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">hikeLiveData</code><code> </code><code class="p">=</code><code> </code><code class="n">MutableLiveData</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">HikeData</code><code class="p">&gt;</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">handler</code><code class="p">:</code><code> </code><code class="n">Handler</code><code> </code><code class="p">=</code><code> </code><code class="n">Handler</code><code class="p">(</code><code class="n">Looper</code><code class="p">.</code><code class="n">getMainLooper</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">fun</code><code> </code><code class="nf">onHikesFetched</code><code class="p">(</code><code class="n">hikes</code><code class="p">:</code><code> </code><code class="n">List</code><code class="p">&lt;</code><code class="n">Hike</code><code class="p">&gt;</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="n">hikes</code><code class="p">.</code><code class="n">forEach</code><code> </code><code class="p">{</code><code> </code><code class="n">hike</code><code>  </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>            </code><code class="n">ioThreadPool</code><code class="p">.</code><code class="n">submit</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                </code><code class="k">val</code><code> </code><code class="py">weather</code><code> </code><code class="p">=</code><code> </code><code class="n">fetchWeather</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code><code>&#13;
</code><code>                </code><code class="k">val</code><code> </code><code class="py">hikeData</code><code> </code><code class="p">=</code><code> </code><code class="n">HikeData</code><code class="p">(</code><code class="n">hike</code><code class="p">,</code><code> </code><code class="n">weather</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>                </code><code class="c1">// Here we post a Runnable&#13;
</code><code>                </code><code class="n">handler</code><code class="p">.</code><code class="n">post</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                    </code><code class="n">hikeDataList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">hikeData</code><code class="p">)</code><code>           </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO2-1" id="co_structured_concurrency_with_coroutines_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>                    </code><code class="n">hikeLiveData</code><code class="p">.</code><code class="n">value</code><code> </code><code class="p">=</code><code> </code><code class="n">hikeDataList</code><code>    </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO2-2" id="co_structured_concurrency_with_coroutines_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>                </code><code class="p">}</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="c1">// other methods removed for brevity&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>This time, we post a <code>Runnable</code> to the main thread, in which:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO2-1" id="callout_structured_concurrency_with_coroutines_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>A new <code>HideData</code> instance is added to <code>hikeDataList</code>.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO2-2" id="callout_structured_concurrency_with_coroutines_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>hikeLiveData</code> is given the <code>hikeDataList</code> as an updated value. Notice that we &#13;
<span class="keep-together">can use</span> the highly readable and intuitive assignment operator here: &#13;
<span class="keep-together"><code>hikeLiveData.value</code> <code>=</code> <code>..</code>,</span>&#13;
which is nicer than &#13;
<span class="keep-together"><code>hikeLiveData.postValue(..)</code>.</span> This is because the <code>Runnable</code> will be&#13;
executed from the main thread—<code>postValue</code> is only useful when updating the value of a <code>LiveData</code> from a background thread.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Doing this, all accessors of <code>hikeDataList</code> are <em>thread-confined</em> to the main thread (see <a data-type="xref" href="#thread_confined_id">Figure 8-3</a>),&#13;
eliminating all possible concurrency hazards.</p>&#13;
&#13;
<figure><div class="figure" id="thread_confined_id">&#13;
<img alt="Thread-confined" src="assets/pawk_0803.png"/>&#13;
<h6><span class="label">Figure 8-3. </span>The main thread can only access <code>hikeDataList</code>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>That’s it for the “traditional” approach. Other libraries like <em>RxJava/RxKotlin</em> and <em>Arrow</em> could have been used to perform&#13;
essentially the same thing. The logic is made of several steps. You start the first one, giving it a callback containing the&#13;
set of instructions to run when the background job is done. Each step is connected to the next by the code&#13;
inside the callbacks. We’ve discussed it in <a data-type="xref" href="ch06.html#handling_concurrency_id">Chapter 6</a>, and we hope that we’ve illuminated&#13;
some potential pitfalls and given you the tools to avoid them.</p>&#13;
&#13;
<p>Interestingly, callback complexity doesn’t seem to be an issue in this example—everything is done with two methods,&#13;
a <code>Handler</code> and a <code>ExecutorService</code>. However, an insidious situation arises in the following scenario:</p>&#13;
&#13;
<p>A user navigates to a list of hikes, then <code>fetchHikesAsync</code> is called on the <code>ViewModel</code>. The user just installed the&#13;
application on a new device; thus the history isn’t in cache, so the app has to access remote APIs to fetch&#13;
fresh data from some remote service.</p>&#13;
&#13;
<p>Let’s assume that the wireless network is slow, but not so slow as to cause IO timeout errors. The view keeps showing&#13;
that the list is updating, and the user might think that there is in fact a suppressed error, and retry the fetch&#13;
(which might be available using some refresh UI like a <code>SwipeRefreshLayout</code>, an explicit refresh button, or even&#13;
just using  navigation to reenter the UI and presume a fetch will be called implicitly).</p>&#13;
&#13;
<p>Unfortunately, nothing in our implementation anticipates this. When <code>fetchHikesAsync</code> is called, a workflow is&#13;
launched and cannot be stopped. Imagining the worst case, every time a user navigates back and reenters in the hike&#13;
list view, a new workflow is launched. This is clearly poor design.</p>&#13;
&#13;
<p>A cancellation mechanism might be one possible solution. We might implement a cancellation mechanism by ensuring that&#13;
every new call of <code>fetchHikesAsync</code> cancels any previous in-flight or pending call. Alternatively, you could discard&#13;
new calls of <code>fetchHikesAsync</code> while a previous call is still running. Implementing that in this context requires&#13;
thoughtfulness and deliberation.</p>&#13;
&#13;
<p>A cancellation mechanism isn’t as fire-and-forget as we might find in other flows, because you have to ensure that&#13;
<em>every</em> background thread effectively stops their &#13;
<span class="keep-together">execution.</span></p>&#13;
&#13;
<p>As you know from the previous chapter, coroutines and suspending functions can be a great fit here, and in similar&#13;
circumstances. We chose this hiking app example because we have a great opportunity to use suspending functions.<a data-startref="ix_ch08-asciidoc5" data-type="indexterm" id="idm46669748850256"/><a data-startref="ix_ch08-asciidoc4" data-type="indexterm" id="idm46669748849552"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Suspending Functions and Coroutines" data-type="sect2"><div class="sect2" id="idm46669749029424">&#13;
<h2>Using Suspending Functions and Coroutines</h2>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="suspending functions" data-type="indexterm" id="ix_ch08-asciidoc6"/><a data-primary="suspending functions" data-secondary="and coroutines" data-type="indexterm" id="ix_ch08-asciidoc7"/>As a reminder, we’ll now implement the exact same logic; but this time we’ll be using suspending functions and coroutines.</p>&#13;
&#13;
<p>You declare a suspending function when the function may not return immediately. Therefore, any blocking function&#13;
is eligible to be rewritten as a suspending function.</p>&#13;
&#13;
<p>The <code>fetchHikesForUser</code> function is a good example because it blocks the calling thread until it returns a list of <code>Hike</code>&#13;
 instances. Therefore, it can be expressed as a suspending function, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">hikesForUser</code><code class="p">(</code><code class="n">userId</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Hike</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">fetchHikesForUser</code><code class="p">(</code><code class="n">userId</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We had to pick another name for the suspending function. In this example, blocking calls are prefixed with “fetch”&#13;
by convention.</p>&#13;
&#13;
<p>Similarly, as shown in <a data-type="xref" href="#weather_for_hike_id">Example 8-1</a>, you can declare the equivalent for <code>fetchWeather</code>.</p>&#13;
<div data-type="example" id="weather_for_hike_id">&#13;
<h5><span class="label">Example 8-1. </span><code>fetchWeather</code> as suspending function</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">weatherForHike</code><code class="p">(</code><code class="n">hike</code><code class="p">:</code> <code class="n">Hike</code><code class="p">):</code> <code class="n">Weather</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">fetchWeather</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Those suspending functions are wrappers around their blocking counterpart. When invoked from inside a coroutine, the&#13;
<a data-primary="Dispatcher" data-type="indexterm" id="idm46669748766304"/><code>Dispatcher</code> supplied to the<a data-primary="withContext" data-type="indexterm" id="idm46669748765312"/> <code>withContext</code> function determines which thread pool the blocking call is executed on. Here,&#13;
<code>Dispatchers.IO</code> is a perfect fit and is very similar to the work-stealing pool seen earlier.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Once you’ve wrapped blocking calls in suspending blocks like the suspending <code>weatherForHike</code> function, you’re now ready&#13;
to use those suspending functions inside coroutines—as you’ll see shortly.</p>&#13;
&#13;
<p>Actually, there’s a convention with suspending functions to make everyone’s life simpler: <em>a suspending function never blocks the calling thread</em>. In the case of <code>weatherForHike</code>, this is indeed the case, since regardless of which thread invokes <code>weatherForHike</code> from within a coroutine, the <code>withContext(Dispatchers.IO)</code> statement causes the execution to jump to another thread.<sup><a data-type="noteref" href="ch08.html#idm46669748759888" id="idm46669748759888-marker">4</a></sup></p>&#13;
</div>&#13;
&#13;
<p>Everything we’ve done using the callback pattern can now fit in a single public <code>update</code> method, which reads like&#13;
procedural code. This is possible thanks to the suspending functions, as shown in <a data-type="xref" href="#example8_8">Example 8-2</a>.</p>&#13;
<div data-type="example" id="example8_8">&#13;
<h5><span class="label">Example 8-2. </span>Using suspending functions in the view-model</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">HikesViewModel</code><code> </code><code class="p">:</code><code> </code><code class="n">ViewModel</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">hikeDataList</code><code> </code><code class="p">=</code><code> </code><code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">HikeData</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">hikeLiveData</code><code> </code><code class="p">=</code><code> </code><code class="n">MutableLiveData</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">HikeData</code><code class="p">&gt;</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">fun</code><code> </code><code class="nf">update</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="n">viewModelScope</code><code class="p">.</code><code class="n">launch</code><code> </code><code class="p">{</code><code>                                 </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO3-1" id="co_structured_concurrency_with_coroutines_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>            </code><code class="cm">/* Step 1: get the list of hikes */</code><code>&#13;
</code><code>            </code><code class="k">val</code><code> </code><code class="py">hikes</code><code> </code><code class="p">=</code><code> </code><code class="n">hikesForUser</code><code class="p">(</code><code class="s">"userId"</code><code class="p">)</code><code>                  </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO3-2" id="co_structured_concurrency_with_coroutines_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>&#13;
</code><code>            </code><code class="cm">/* Step 2: for each hike, get the weather, wrap into a&#13;
             * container, update hikeDataList, then notify view&#13;
             * listeners by updating the corresponding LiveData */</code><code>&#13;
</code><code>            </code><code class="n">hikes</code><code class="p">.</code><code class="n">forEach</code><code> </code><code class="p">{</code><code> </code><code class="n">hike</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>                             </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO3-3" id="co_structured_concurrency_with_coroutines_CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>                </code><code class="n">launch</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                    </code><code class="k">val</code><code> </code><code class="py">weather</code><code> </code><code class="p">=</code><code> </code><code class="n">weatherForHike</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code><code>          </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO3-4" id="co_structured_concurrency_with_coroutines_CO3-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>                    </code><code class="k">val</code><code> </code><code class="py">hikeData</code><code> </code><code class="p">=</code><code> </code><code class="n">HikeData</code><code class="p">(</code><code class="n">hike</code><code class="p">,</code><code> </code><code class="n">weather</code><code class="p">)</code><code>&#13;
</code><code>                    </code><code class="n">hikeDataList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">hikeData</code><code class="p">)</code><code>&#13;
</code><code>                    </code><code class="n">hikeLiveData</code><code class="p">.</code><code class="n">value</code><code> </code><code class="p">=</code><code> </code><code class="n">hikeDataList</code><code>&#13;
</code><code>                </code><code class="p">}</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
&#13;
<p class="pagebreak-before">We’re going to provide the details of <a data-type="xref" href="#example8_8">Example 8-2</a> step by step:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO3-1" id="callout_structured_concurrency_with_coroutines_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>When <code>update</code> is called, it immediately starts a coroutine, using the <code>launch</code> coroutine builder. As you know, a&#13;
coroutine is never launched out of the blue. As we’ve seen in <a data-type="xref" href="ch07.html#coroutine_concepts">Chapter 7</a>, a coroutine must always be&#13;
started within a<a data-primary="CoroutineScope" data-type="indexterm" id="idm46669748410208"/> <code>CoroutineScope</code>. Here, we’re using <code>viewModelScope</code>.</p>&#13;
&#13;
<p>Where does this scope come from? The Android Jetpack team from Google know that using Kotlin and coroutines&#13;
requires a <code>CoroutineScope</code>. To ease &#13;
<span class="keep-together">your life,</span> they maintain <a href="https://oreil.ly/e3sqR">Android KTX</a>,&#13;
which is a set of Kotlin extensions on the Android platform and other APIs. The goal is to use Kotlin idioms while still&#13;
integrating nicely with the Android framework. They leverage extension functions, lambdas, parameter default values,&#13;
and coroutines.&#13;
Android KTX is made of several libraries. In this example, we used <em>lifecycle-viewmodel-ktx</em>.&#13;
To use it in your app, you should add the following to your dependencies listed in your &#13;
<span class="keep-together"><code>build.gradle</code></span> (use a newer version if available):&#13;
<code>implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0"</code>.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO3-2" id="callout_structured_concurrency_with_coroutines_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The line <code>val hikes = hikesForUser("userId")</code> is the first suspension point. The coroutine started by <code>launch</code> is&#13;
stopped until <code>hikesForUser</code> returns.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO3-3" id="callout_structured_concurrency_with_coroutines_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>You’ve got your list of <code>Hike</code> instances. Now you can <em>concurrently</em> fetch the weather data for each of them. We can use&#13;
a loop and start a new coroutine for each hike using <code>launch</code>.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO3-4" id="callout_structured_concurrency_with_coroutines_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p><code>val weather = weatherForHike(hike)</code> is another suspension point. Each of the coroutines started in the <code>for</code> loop will&#13;
reach this suspension point.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Let’s have a closer look at the coroutine started for each <code>Hike</code> instance in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">weather</code> <code class="p">=</code> <code class="n">weatherForHike</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">hikeData</code> <code class="p">=</code> <code class="n">HikeData</code><code class="p">(</code><code class="n">hike</code><code class="p">,</code> <code class="n">weather</code><code class="p">)</code>&#13;
    <code class="n">hikeDataList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">hikeData</code><code class="p">)</code>&#13;
    <code class="n">hikeLiveData</code><code class="p">.</code><code class="n">value</code> <code class="p">=</code> <code class="n">hikeDataList</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Since the parent scope (<code>viewModelScope</code>) defaults to the main thread, every single line inside the launch block is&#13;
executed on the main thread, except the content of &#13;
<span class="keep-together">the suspending</span> function <code>weatherForHike</code>, which uses <code>Dispatchers.IO</code> (see <a data-type="xref" href="#weather_for_hike_id">Example 8-1</a>).&#13;
The assignment of <code>weather</code> is done on the main thread. Therefore, the usages of <code>hikeDataList</code> are confined to the main&#13;
thread—there are no thread-safety issues. As for <code>hikeLiveData</code>, you can use&#13;
the setter of its <code>value</code> (and since we’re in Kotlin, that means the assignment operator), instead of <code>postValue</code>, since&#13;
we know we’re calling this from the main thread.<a data-startref="ix_ch08-asciidoc7" data-type="indexterm" id="idm46669748281984"/><a data-startref="ix_ch08-asciidoc6" data-type="indexterm" id="idm46669748281280"/></p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>When using a coroutine scope, you should always be conscious &#13;
<span class="keep-together">of how it</span> manages your coroutines, especially knowing what &#13;
<span class="keep-together"><code>Dispatcher</code></span> the scope uses. The following code shows how it’s declared in the source code of the library:</p>&#13;
<pre data-code-language="kotlin" data-type="programlisting">&#13;
<code class="k">val</code> <code class="py">ViewModel</code><code class="p">.</code><code class="n">viewModelScope</code><code class="p">:</code> <code class="n">CoroutineScope</code>&#13;
  <code class="k">get</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">scope</code><code class="p">:</code> <code class="n">CoroutineScope</code><code class="p">?</code> <code class="p">=</code> <code class="k">this</code><code class="p">.</code><code class="n">getTag</code><code class="p">(</code><code class="n">JOB_KEY</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">scope</code> <code class="p">!=</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code>&#13;
       <code class="k">return</code> <code class="n">scope</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">setTagIfAbsent</code><code class="p">(</code>&#13;
       <code class="n">JOB_KEY</code><code class="p">,</code>&#13;
       <code class="n">CloseableCoroutineScope</code><code class="p">(</code>&#13;
          <code class="n">SupervisorJob</code><code class="p">()</code> <code class="p">+</code>  <code class="n">Dispatchers</code><code class="p">.</code><code class="n">Main</code><code class="p">.</code><code class="n">immediate</code><code class="p">))</code>&#13;
  <code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>As you can see in this example,<a data-primary="viewModelScope" data-type="indexterm" id="idm46669750362864"/> <code>viewModelScope</code> is declared as an extension property on the <code>ViewModel</code> class. Even if the <code>ViewModel</code> class has absolutely no notion of <code>CoroutineScope</code>, declaring it in this manner enables the syntax in our example. Then,&#13;
an internal store is consulted to check whether a scope has already been created or not. If not, a new one is created using<a data-primary="CloseableCoroutineScope(..)" data-type="indexterm" id="idm46669748191904"/> <code>CloseableCoroutineScope(..)</code>.<sup><a data-type="noteref" href="ch08.html#idm46669748190592" id="idm46669748190592-marker">5</a></sup> For instance, don’t pay attention to <code>SupervisorJob</code>—we’ll explain its role later when we discuss cancellation. What’s particularly relevant here is <code>Dispatchers.Main.immediate</code>, a variation of <code>Dispatcher.Main</code>, which executes coroutines immediately when they are launched from the main thread. Consequently, this scope defaults to the main thread.  This is a critical piece of information that you’ll need to&#13;
know moving forward from here.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary of Suspending Functions Versus Traditional Threading" data-type="sect2"><div class="sect2" id="idm46669748848624">&#13;
<h2>Summary of Suspending Functions Versus Traditional Threading</h2>&#13;
&#13;
<p><a data-primary="suspending functions" data-secondary="traditional threading versus" data-type="indexterm" id="idm46669748185856"/><a data-primary="threading, suspending functions versus" data-type="indexterm" id="idm46669748184864"/>Thanks to suspending functions, asynchronous logic can be written like procedural code. Since the Kotlin compiler generates all the necessary callbacks and boilerplate code under the hood, the code you write using a cancellation mechanism can be much more concise.<sup><a data-type="noteref" href="ch08.html#idm46669748183760" id="idm46669748183760-marker">6</a></sup> For example, a coroutine scope that uses <code>Dispatchers.Main</code> doesn’t need <code>Handler</code>s or&#13;
other communication primitives to pass data to and from a background thread to the main thread, as is still&#13;
the case with purely multithreaded environments (without coroutines).&#13;
Actually, all the problems we had in the thread-based approach are now nicely solved using coroutines—and that&#13;
includes the cancellation mechanism.</p>&#13;
&#13;
<p>Code using coroutines and suspending functions can also be more readable, as there can be far fewer implicit or&#13;
indirect instructions (like nested calls, or SAM instances, as described in <a data-type="xref" href="ch06.html#handling_concurrency_id">Chapter 6</a>). Moreover,&#13;
IntelliJ and Android Studio make those suspending calls stand out with a special icon in the margin.</p>&#13;
&#13;
<p>In this section, we only scratched the surface of cancellation. The following section covers all you need to know about cancellation with coroutines.<a data-startref="ix_ch08-asciidoc2" data-type="indexterm" id="idm46669748179440"/><a data-startref="ix_ch08-asciidoc1" data-type="indexterm" id="idm46669748178736"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cancellation" data-type="sect1"><div class="sect1" id="idm46669749587584">&#13;
<h1>Cancellation</h1>&#13;
&#13;
<p><a data-primary="cancellation" data-type="indexterm" id="ix_ch08-asciidoc8"/><a data-primary="structured concurrency with coroutines" data-secondary="cancellation" data-type="indexterm" id="ix_ch08-asciidoc9"/>Handling task cancellation is a critical part of an Android application.&#13;
When a user navigates for the first time to the view displaying the list of hikes along with statistics and weather, a&#13;
decent number of coroutines are started from the view-model. If for some reason the user decides to leave the view,&#13;
then the tasks launched by the view-model are probably running for nothing. Unless of course the user later navigates&#13;
back to the view, but it’s dangerous to assume that. To avoid wasting resources, a good practice in this scenario is to&#13;
cancel all ongoing tasks related to views no longer needed. This is a good example of cancellation you might implement&#13;
yourself, as part of your application design.&#13;
There’s another kind of cancellation: the one that happens when something bad happens.&#13;
So we’ll distinguish the two types here:</p>&#13;
<dl>&#13;
<dt>Designed cancellation</dt>&#13;
<dd>&#13;
<p>For example, a task that’s cancelled after a user taps a “Cancel” button in a&#13;
custom or arbitrary  UI.</p>&#13;
</dd>&#13;
<dt>Failure cancellation</dt>&#13;
<dd>&#13;
<p><a data-primary="cancellation" data-secondary="failure" data-type="indexterm" id="idm46669748170528"/><a data-primary="failure cancellation" data-type="indexterm" id="idm46669748169552"/>For example, a cancellation that’s caused by exceptions, either intentionally (thrown) or unexpectedly (unhandled).</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Keep those two types of cancellation in mind, as you’ll see that the coroutine framework handles them differently.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Coroutine Lifecycle" data-type="sect2"><div class="sect2" id="idm46669748167728">&#13;
<h2>Coroutine Lifecycle</h2>&#13;
&#13;
<p><a data-primary="cancellation" data-secondary="coroutine lifecycle" data-type="indexterm" id="ix_ch08-asciidoc10"/><a data-primary="coroutines" data-secondary="lifecycle" data-type="indexterm" id="ix_ch08-asciidoc11"/><a data-primary="structured concurrency with coroutines" data-secondary="coroutine lifecycle" data-type="indexterm" id="ix_ch08-asciidoc12"/>To understand how cancellation works, you need to be aware that a coroutine has a lifecycle, which is shown in&#13;
<a data-type="xref" href="#coroutine_lifecycle_id">Figure 8-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="coroutine_lifecycle_id">&#13;
<img alt="Lifecyle" src="assets/pawk_0804.png"/>&#13;
<h6><span class="label">Figure 8-4. </span>Coroutine lifecycle.</h6>&#13;
</div></figure>&#13;
&#13;
<p>When a coroutine is created, for example, with the<a data-primary="launch {..} function" data-type="indexterm" id="idm46669748158960"/> <code>launch {..}</code> function with no additional context or arguments, it’s&#13;
created in the <code>Active</code> state. That means it starts immediately when <code>launch</code> is called. This is also called <em>eagerly</em>&#13;
started. In some situations, you might want to start a coroutine <em>lazily</em>, which means it won’t do anything until you&#13;
manually start it. To do this, <code>launch</code> and <code>async</code> can both take a named argument “start,” of type <code>CoroutineStart</code>.&#13;
The default value is <code>CoroutineStart.DEFAULT</code> (eager start), but you can use <code>CoroutineStart.LAZY</code>, as in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code><code class="p">(</code><code class="n">start</code> <code class="p">=</code> <code class="n">CoroutineStart</code><code class="p">.</code><code class="n">LAZY</code><code class="p">)</code> <code class="p">{</code> <code class="p">...</code> <code class="p">}</code>&#13;
<code class="c1">// some work</code>&#13;
<code class="n">job</code><code class="p">.</code><code class="n">start</code><code class="p">()</code></pre>&#13;
&#13;
<p>Don’t forget to call<a data-primary="job.start()" data-type="indexterm" id="idm46669748134288"/> <code>job.start()</code>! Because when started lazily, a coroutine needs to be explicitly started.<sup><a data-type="noteref" href="ch08.html#idm46669748133168" id="idm46669748133168-marker">7</a></sup> You don’t have to do this by default, as a coroutine&#13;
is created in the <code>Active</code> state.</p>&#13;
&#13;
<p>When a coroutine is done with its work, it remains in the <code>Completing</code> state until all of its children reach the&#13;
<code>Completed</code> state (see <a data-type="xref" href="ch07.html#coroutine_concepts">Chapter 7</a>). Only then does it reach the &#13;
<span class="keep-together"><code>Completed</code></span> state. As usual, let’s crack open the source code and take a look at the &#13;
<span class="keep-together">following:</span></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">viewModelScope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">fetchData</code><code class="p">()</code>   <code class="c1">// might take some time</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">fetchOtherData</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This <code>viewModelScope.launch</code> completes its work almost instantly: it only starts two child coroutines and does nothing&#13;
else on its own. It quickly reaches the <code>Completing</code> state and moves to the <code>Completed</code> state only when the child&#13;
coroutines complete.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Coroutine cancellation" data-type="sect3"><div class="sect3" id="idm46669748082832">&#13;
<h3>Coroutine cancellation</h3>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="cancellation" data-type="indexterm" id="idm46669748081776"/>While in <code>Active</code> or <code>Completing</code> state, if an exception is thrown or the logic calls &#13;
<span class="keep-together"><code>cancel()</code>,</span> the coroutine transitions to <code>Cancelling</code> state. If required, this is when you perform necessary cleanup. The coroutine remains in this <code>Cancelling</code> state until the cleanup job is done with its work. Only then will the coroutine transition to the &#13;
<span class="keep-together"><code>Cancelled</code></span> state.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Job holds the state" data-type="sect3"><div class="sect3" id="idm46669748076544">&#13;
<h3>Job holds the state</h3>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="Job" data-type="indexterm" id="idm46669748075344"/>Internally, all those states of the lifecycle are held by the <code>Job</code> of the coroutine. The <code>Job</code> doesn’t have a property&#13;
named “state” (whose values would range from “NEW” to “COMPLETED”). Instead, the state is represented by three Booleans&#13;
(flags): &#13;
<span class="keep-together"><code>isActive</code>,</span> <code>isCancelled</code>, and <code>isCompleted</code>. Each state is represented by a combination of those flags, as you can see in <a data-type="xref" href="#table_ch8">Table 8-1</a>.</p>&#13;
<table id="table_ch8">&#13;
<caption><span class="label">Table 8-1. </span><code>Job</code> states</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>State</th>&#13;
<th><code>isActive</code></th>&#13;
<th><code>isCompleted</code></th>&#13;
<th><code>isCancelled</code></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>New (optional initial state)</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>false</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Active (default initial state)</p></td>&#13;
<td><p>true</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>false</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Completing (transient state)</p></td>&#13;
<td><p>true</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>false</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Cancelling (transient state)</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>true</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Cancelled (final state)</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>true</p></td>&#13;
<td><p>true</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Completed (final state)</p></td>&#13;
<td><p>false</p></td>&#13;
<td><p>true</p></td>&#13;
<td><p>false</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>As you can see, there is no way to distinguish the <code>Completing</code> state from the <code>Active</code> state using only those Booleans.&#13;
Anyway, in most cases what you will really care about is the value of a particular flag, rather than the state itself.&#13;
For example, if you check for <code>isActive</code>, you’re actually checking for <code>Active</code> and <code>Completing</code> states at the same time.&#13;
More on that in the next section.<a data-startref="ix_ch08-asciidoc12" data-type="indexterm" id="idm46669748019968"/><a data-startref="ix_ch08-asciidoc11" data-type="indexterm" id="idm46669748019264"/><a data-startref="ix_ch08-asciidoc10" data-type="indexterm" id="idm46669748018592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cancelling a Coroutine" data-type="sect2"><div class="sect2" id="idm46669748167104">&#13;
<h2>Cancelling a Coroutine</h2>&#13;
&#13;
<p><a data-primary="cancellation" data-secondary="coroutine" data-type="indexterm" id="ix_ch08-asciidoc13"/><a data-primary="cancellation" data-secondary="task delegated to a third-party library" data-type="indexterm" id="ix_ch08-asciidoc14"/><a data-primary="coroutines" data-secondary="cancellation" data-type="indexterm" id="ix_ch08-asciidoc15"/><a data-primary="structured concurrency with coroutines" data-secondary="cancelling a task delegated to a third-party library" data-type="indexterm" id="ix_ch08-asciidoc16"/><a data-primary="structured concurrency with coroutines" data-secondary="coroutine cancellation" data-type="indexterm" id="ix_ch08-asciidoc17"/>Let’s take a look at the following example, where we have a coroutine which simply prints on the console <code>"job: I'm working.."</code> twice per second. The parent coroutine waits a little before cancelling this coroutine:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">startTime</code> <code class="p">=</code> <code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">()</code>&#13;
<code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">nextPrintTime</code> <code class="p">=</code> <code class="n">startTime</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">()</code> <code class="p">&gt;=</code> <code class="n">nextPrintTime</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"job: I'm working.."</code><code class="p">)</code>&#13;
            <code class="n">nextPrintTime</code> <code class="p">+=</code> <code class="m">500</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="n">delay</code><code class="p">(</code><code class="m">1200</code><code class="p">)</code>&#13;
<code class="n">println</code><code class="p">(</code><code class="s">"main: I'm going to cancel this job"</code><code class="p">)</code>&#13;
<code class="n">job</code><code class="p">.</code><code class="n">cancel</code><code class="p">()</code>&#13;
<code class="n">println</code><code class="p">(</code><code class="s">"main: Done"</code><code class="p">)</code></pre>&#13;
&#13;
<p>You can see that the instance of <code>Job</code> returned by <code>launch</code> has a <code>cancel()</code> method. As its name suggests, it cancels&#13;
the running coroutine. By the way, a <code>Deferred</code> instance—which is returned by the <code>async</code> coroutine builder—also&#13;
has this <code>cancel()</code> method since a <code>Deferred</code> instance is a specialized <code>Job</code>.</p>&#13;
&#13;
<p>Back to our example: you might expect this little piece of code to print “job: I’m working..” three times. Actually,&#13;
the output is:</p>&#13;
&#13;
<pre data-type="programlisting">job: I'm working..&#13;
job: I'm working..&#13;
job: I'm working..&#13;
main: I'm going to cancel this job&#13;
main: Done&#13;
job: I'm working..&#13;
job: I'm working..</pre>&#13;
&#13;
<p>So the child coroutine is still running despite the cancellation from the parent. This is because the child coroutine&#13;
isn’t cooperative with cancellation. There are several ways to change that. The first one is by periodically checking for the cancellation status of the coroutine, using<a data-primary="isActive" data-type="indexterm" id="idm46669747903376"/> <code>isActive</code>, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">nextPrintTime</code> <code class="p">=</code> <code class="n">startTime</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">()</code> <code class="p">&gt;=</code> <code class="n">nextPrintTime</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"job: I'm working.."</code><code class="p">)</code>&#13;
            <code class="n">nextPrintTime</code> <code class="p">+=</code> <code class="m">500</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can call <code>isActive</code> this way because it’s an extension property on <code>CoroutineScope</code>, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Returns true when the current Job is still active (has not</code>&#13;
<code class="cm"> * completed and was not cancelled yet).</code>&#13;
<code class="cm"> */</code>&#13;
<code class="k">val</code> <code class="py">CoroutineScope</code><code class="p">.</code><code class="n">isActive</code><code class="p">:</code> <code class="n">Boolean</code> <code class="p">(</code><code class="n">source</code><code class="p">)</code></pre>&#13;
&#13;
<p>Now that the code is cooperative with cancellation, the result is:</p>&#13;
&#13;
<pre data-type="programlisting">job: I'm working..&#13;
job: I'm working..&#13;
job: I'm working..&#13;
main: I'm going to cancel this job&#13;
main: Done</pre>&#13;
&#13;
<p>Using <code>isActive</code> is simply reading a Boolean value. Determining whether the job should be stopped, and both the setup and execution of that logic, is your r[.keep-together]&#13;
esponsibility.</p>&#13;
&#13;
<p>In lieu of <code>isActive</code>,<a data-primary="ensureActive" data-type="indexterm" id="idm46669747816000"/> <code>ensureActive</code> can be used. The difference between <code>isActive</code> and <code>ensureActive</code>&#13;
is that the latter immediately throws a &#13;
<span class="keep-together"><code>CancellationException</code></span> if the job is no longer active.</p>&#13;
&#13;
<p>So <code>ensureActive</code> is a drop-in replacement of the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">if</code> <code class="p">(!</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="n">CancellationException</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Similarly to <code>Thread.yield()</code>, there is a third possibility:<a data-primary="yield()" data-type="indexterm" id="idm46669747809488"/> <code>yield()</code>, which is a &#13;
<span class="keep-together">suspending</span> function. In addition to&#13;
checking the cancellation status of the job, the underlying thread is released and is made available for other coroutines.&#13;
This is especially useful when performing CPU-intensive computations inside a coroutine using &#13;
<span class="keep-together"><code>Dispatchers.Default</code></span>&#13;
(or similar). Placing <code>yield()</code> at strategic places, you can avoid exhausting the thread pool. In other words, you probably&#13;
don’t want a coroutine to be too selfish, and keep a core busy with specific contextual responsibilities for an &#13;
<span class="keep-together">extended</span>&#13;
period of time, if those resources could be better served in another process. To be more cooperative, a greedy CPU-bound&#13;
coroutine should <code>yield()</code> from time to time, giving other coroutines the opportunity to run.</p>&#13;
&#13;
<p>Those ways of interrupting a coroutine are perfect when the cancellation is happening inside your code. What if you&#13;
just delegated some work to a third-party library, like an HTTP client?<a data-startref="ix_ch08-asciidoc17" data-type="indexterm" id="idm46669747775360"/><a data-startref="ix_ch08-asciidoc16" data-type="indexterm" id="idm46669747774656"/><a data-startref="ix_ch08-asciidoc15" data-type="indexterm" id="idm46669747773984"/><a data-startref="ix_ch08-asciidoc14" data-type="indexterm" id="idm46669747773312"/><a data-startref="ix_ch08-asciidoc13" data-type="indexterm" id="idm46669747772640"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cancelling a Task Delegated to a Third-Party Library" data-type="sect2"><div class="sect2" id="idm46669748017328">&#13;
<h2>Cancelling a Task Delegated to a Third-Party Library</h2>&#13;
&#13;
<p><code>OkHttp</code> is a widely deployed HTTP client on Android. If you’re not familiar with this library, the following is a snippet taken from the&#13;
official documentation, to perform an synchronous GET:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">run</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">request</code> <code class="p">=</code> <code class="n">Request</code><code class="p">.</code><code class="n">Builder</code><code class="p">()</code>&#13;
        <code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="s">"https://publicobject.com/helloworld.txt"</code><code class="p">)</code>&#13;
        <code class="p">.</code><code class="n">build</code><code class="p">()</code>&#13;
&#13;
    <code class="n">client</code><code class="p">.</code><code class="n">newCall</code><code class="p">(</code><code class="n">request</code><code class="p">).</code><code class="n">execute</code><code class="p">().</code><code class="n">use</code> <code class="p">{</code> <code class="n">response</code> <code class="p">-&gt;</code>&#13;
      <code class="k">if</code> <code class="p">(!</code><code class="n">response</code><code class="p">.</code><code class="n">isSuccessful</code><code class="p">)</code>&#13;
          <code class="k">throw</code> <code class="n">IOException</code><code class="p">(</code><code class="s">"Unexpected code $response"</code><code class="p">)</code>&#13;
&#13;
      <code class="k">for</code> <code class="p">((</code><code class="n">name</code><code class="p">,</code> <code class="n">value</code><code class="p">)</code> <code class="k">in</code> <code class="n">response</code><code class="p">.</code><code class="n">headers</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"$name: $value"</code><code class="p">)</code>&#13;
      <code class="p">}</code>&#13;
&#13;
      <code class="n">println</code><code class="p">(</code><code class="n">response</code><code class="p">.</code><code class="n">body</code><code class="o">?.</code><code class="n">string</code><code class="p">())</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This example is pretty straightforward. <code>client.newCall(request)</code> returns an instance of <code>Call</code>. You enqueue an instance&#13;
of <code>Callback</code> while your code proceeds unfazed. Is this cancellable? Yes. A <code>Call</code> can be manually cancelled using &#13;
<span class="keep-together"><code>call.cancel()</code>.</span></p>&#13;
&#13;
<p>When using coroutines, the preceding example is the kind of code you might write inside a coroutine. It would be ideal if&#13;
this cancellation was done automatically upon cancellation of the coroutine inside of which the HTTP request is done.&#13;
Otherwise, the following shows what you would have to write:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">if</code> <code class="p">(!</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">call</code><code class="p">.</code><code class="n">cancel</code><code class="p">()</code>&#13;
    <code class="k">return</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The obvious caveat is that it pollutes your code—not to mention that you could forget to add this check, or have it at&#13;
the wrong place. There must be a better solution to this.</p>&#13;
&#13;
<p>Thankfully, the coroutine framework comes with functions specifically designed to turn a function that&#13;
expects a callback into a suspending function. They come in several flavors including <code>suspendCancellableCoroutine</code>.&#13;
The latter is designed to craft a suspending function which is <em>cooperative with cancellation</em>.</p>&#13;
&#13;
<p>The following code shows how to create a suspending function as an extension function of <code>Call</code>, which is cancellable and suspends&#13;
until you get the response of your HTTP request, or an exception occurs:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">Call</code><code class="p">.</code><code class="n">await</code><code class="p">()</code> <code class="p">=</code> <code class="n">suspendCancellableCoroutine</code><code class="p">&lt;</code><code class="n">ResponseBody</code><code class="p">?&gt;</code> <code class="p">{</code>&#13;
    <code class="n">continuation</code> <code class="p">-&gt;</code>&#13;
&#13;
    <code class="n">continuation</code><code class="p">.</code><code class="n">invokeOnCancellation</code> <code class="p">{</code>&#13;
        <code class="n">cancel</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">enqueue</code><code class="p">(</code><code class="k">object</code> <code class="err">: </code><code class="nc">Callback</code> <code class="p">{</code>&#13;
        <code class="k">override</code> <code class="k">fun</code> <code class="nf">onResponse</code><code class="p">(</code><code class="n">call</code><code class="p">:</code> <code class="n">Call</code><code class="p">,</code> <code class="n">response</code><code class="p">:</code> <code class="n">Response</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">continuation</code><code class="p">.</code><code class="n">resume</code><code class="p">(</code><code class="n">response</code><code class="p">.</code><code class="n">body</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="k">override</code> <code class="k">fun</code> <code class="nf">onFailure</code><code class="p">(</code><code class="n">call</code><code class="p">:</code> <code class="n">Call</code><code class="p">,</code> <code class="n">e</code><code class="p">:</code> <code class="n">IOException</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">continuation</code><code class="p">.</code><code class="n">resumeWithException</code><code class="p">(</code><code class="n">e</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">})</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you’ve never seen code like this, it’s natural to be afraid of its off-putting complexity. The great news is that this function is fully generic—it only needs to be written once. You can have&#13;
it inside a “util” package of your project if you want, or in your parallelism package; or just remember the basics&#13;
and use some version of it when performing conversions like that.</p>&#13;
&#13;
<p>Before showing the benefits of such a utility method, we owe you a detailed &#13;
<span class="keep-together">explanation.</span></p>&#13;
&#13;
<p>In <a data-type="xref" href="ch07.html#coroutine_concepts">Chapter 7</a>, we explained how the Kotlin compiler generates a <code>Continuation</code> instance&#13;
for each suspending function. The <code>suspendCancellableCoroutine</code> function gives you the opportunity to use this instance&#13;
of <code>Continuation</code>. It accepts a lambda with <code>CancellableContinuation</code> as receiver, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">public</code> <code class="n">suspend</code> <code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">suspendCancellableCoroutine</code><code class="p">(</code>&#13;
    <code class="n">crossinline</code> <code class="n">block</code><code class="p">:</code> <code class="p">(</code><code class="n">CancellableContinuation</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;)</code> <code class="p">-&gt;</code> <code class="n">Unit</code>&#13;
<code class="p">):</code> <code class="n">T</code></pre>&#13;
&#13;
<p>A<a data-primary="CancellableContinuation" data-type="indexterm" id="idm46669747462224"/> <code>CancellableContinuation</code> is a <code>Continuation</code> that is cancellable. We can register a callback that will be invoked&#13;
upon cancellation, using <code>invokeOnCancellation { .. }</code>. In this case, all we want is to cancel the <code>Call</code>. Since we’re&#13;
inside an extension function of <code>Call</code>, we add the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">continuation</code><code class="p">.</code><code class="n">invokeOnCancellation</code> <code class="p">{</code>&#13;
    <code class="n">cancel</code><code class="p">()</code>   <code class="c1">// Call.cancel()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>After we’ve specified what should happen upon cancellation of the suspending &#13;
<span class="keep-together">function,</span>  we  perform  the  actual  HTTP  request  by  invoking<a data-primary="Call.enqueue()" data-type="indexterm" id="idm46669747425456"/>  <code>Call.enqueue()</code>,  giving &#13;
<span class="keep-together">a <code>Callback</code></span> instance. A suspending function “resumes” or “stops suspending” when &#13;
<span class="keep-together">the corresponding</span> <code>Continuation</code> is resumed, with either <code>resume</code> or &#13;
<span class="keep-together"><code>resumeWithException</code>.</span></p>&#13;
&#13;
<p>When you get the result of your HTTP request, either <code>onResponse</code> or <code>onFailure</code> will be called on the <code>Callback</code>&#13;
instance you provided. If <code>onResponse</code> is called, this is the “happy path.” You got a response and you should now&#13;
resume the continuation with a result of your choice. As shown in <a data-type="xref" href="#happy_path_sad_path">Figure 8-5</a>, we chose the body of the HTTP response.&#13;
Meanwhile, on the “sad path,” <code>onFailure</code> is called, and <code>OkHttp API</code> gives you an instance of an <code>IOException</code>.</p>&#13;
&#13;
<figure><div class="figure" id="happy_path_sad_path">&#13;
<img alt="Happy Path/Sad Path" src="assets/pawk_0805.png"/>&#13;
<h6><span class="label">Figure 8-5. </span>(1) First, a device will send an HTTP request to the server. (2) The type of the response being returned will determine what happens next. (3) If the request is a success, then <code>onResponse</code> is called. Otherwise, <code>onFailure</code> is executed.</h6>&#13;
</div></figure>&#13;
&#13;
<p>It is important to resume the continuation with this exception, using&#13;
&#13;
<span class="keep-together"><code>resumeWithException</code>.</span> This way, the coroutine framework knows about the failure of this suspending function and will&#13;
propagate this event all the way up the coroutine hierarchy.</p>&#13;
&#13;
<p>Now, for the best part: a showcase of how to use it inside a coroutine, as shown in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">runBlocking</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">job</code><code> </code><code class="p">=</code><code> </code><code class="n">launch</code><code> </code><code class="p">{</code><code>                                        </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO4-1" id="co_structured_concurrency_with_coroutines_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="k">val</code><code> </code><code class="py">response</code><code> </code><code class="p">=</code><code> </code><code class="n">performHttpRequest</code><code class="p">(</code><code class="p">)</code><code>                   </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO4-2" id="co_structured_concurrency_with_coroutines_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">println</code><code class="p">(</code><code class="s">"Got response ${response?.string()}"</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="n">delay</code><code class="p">(</code><code class="m">2</code><code class="m">0</code><code class="m">0</code><code class="p">)</code><code>                                                </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO4-3" id="co_structured_concurrency_with_coroutines_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>    </code><code class="n">job</code><code class="p">.</code><code class="n">cancelAndJoin</code><code class="p">(</code><code class="p">)</code><code>                                       </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO4-4" id="co_structured_concurrency_with_coroutines_CO4-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>    </code><code class="n">println</code><code class="p">(</code><code class="s">"Done"</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="k">val</code><code> </code><code class="py">okHttpClient</code><code> </code><code class="p">=</code><code> </code><code class="n">OkHttpClient</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code class="k">val</code><code> </code><code class="py">request</code><code> </code><code class="p">=</code><code> </code><code class="n">Request</code><code class="p">.</code><code class="n">Builder</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="s">"http://publicobject.com/helloworld.txt"</code><code>&#13;
</code><code class="p">)</code><code class="p">.</code><code class="n">build</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="n">suspend</code><code> </code><code class="k">fun</code><code> </code><code class="nf">performHttpRequest</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">ResponseBody</code><code class="p">?</code><code> </code><code class="p">{</code><code>&#13;
</code><code>     </code><code class="k">return</code><code> </code><code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>         </code><code class="k">val</code><code> </code><code class="py">call</code><code> </code><code class="p">=</code><code> </code><code class="n">okHttpClient</code><code class="p">.</code><code class="n">newCall</code><code class="p">(</code><code class="n">request</code><code class="p">)</code><code>&#13;
</code><code>         </code><code class="n">call</code><code class="p">.</code><code class="n">await</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>     </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO4-1" id="callout_structured_concurrency_with_coroutines_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We start off by launching a coroutine with <code>launch</code>.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO4-2" id="callout_structured_concurrency_with_coroutines_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Inside the coroutine returned by <code>launch</code>, we invoke a suspending function <code>performHttpRequest</code>, which uses <code>Dispatchers.IO</code>.&#13;
This suspending function creates a new <code>Call</code> instance and then invokes our suspending<a data-primary="await()" data-type="indexterm" id="idm46669747239392"/> <code>await()</code> on it. At this point, an&#13;
HTTP request is performed.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO4-3" id="callout_structured_concurrency_with_coroutines_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Concurrently, and while step 2 is done on some thread of <code>Dispatchers.IO</code>, our main thread proceeds execution&#13;
of the main method, and immediately encounters <code>delay(200)</code>. The coroutine running on the main thread is suspended for &#13;
<span class="keep-together">200 ms.</span></p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO4-4" id="callout_structured_concurrency_with_coroutines_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>After 200 ms have passed, we invoke<a data-primary="job.cancelAndJoin()" data-type="indexterm" id="idm46669747203376"/> <code>job.cancelAndJoin()</code>, which is a convenience method for <code>job.cancel()</code>, then <code>job.join()</code>.&#13;
Consequently, if the HTTP request takes longer than 200 ms, the coroutine started by <code>launch</code> is still in the <code>Active</code> state.&#13;
The suspending <code>performHttpRequest</code> hasn’t returned yet. Calling <code>job.cancel()</code> cancels the coroutine. Thanks to&#13;
structured concurrency, the coroutine knows about all of its children. The cancellation is propagated all the way down&#13;
the hierarchy. The <code>Continuation</code> of <code>performHttpRequest</code> gets cancelled, and so does the HTTP request. If the HTTP&#13;
request takes less than 200 ms, &#13;
<span class="keep-together"><code>job.cancelAndJoin()</code></span> has no effect.</p></dd>&#13;
</dl>&#13;
&#13;
<p>No matter how deep in the coroutine hierarchy the HTTP request is performed, if our predefined <code>Call.await()</code> is used,&#13;
the cancellation of the <code>Call</code> is triggered if a parent coroutine is cancelled.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Coroutines That Are Cooperative with Cancellation" data-type="sect2"><div class="sect2" id="idm46669747771056">&#13;
<h2>Coroutines That Are Cooperative with Cancellation</h2>&#13;
&#13;
<p><a data-primary="coroutines" data-secondary="cooperative with cancellation" data-type="indexterm" id="ix_ch08-asciidoc19"/><a data-primary="structured concurrency with coroutines" data-secondary="coroutines which are cooperative with cancellation" data-type="indexterm" id="ix_ch08-asciidoc20"/>You’ve just seen the various techniques to make a coroutine cancellable. Actually, the coroutine framework has a&#13;
convention: a well-behaved cancellable coroutine throws a <code>CancellationException</code> when it’s cancelled. Why? Let’s look&#13;
at this suspending function in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">wasteCpu</code><code class="p">()</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">nextPrintTime</code> <code class="p">=</code> <code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">()</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">()</code> <code class="p">&gt;=</code> <code class="n">nextPrintTime</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"job: I'm working.."</code><code class="p">)</code>&#13;
            <code class="n">nextPrintTime</code> <code class="p">+=</code> <code class="m">500</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It is indeed cancellable thanks to the <code>isActive</code> check. Imagine that you need to do some cleanup when this function&#13;
is cancelled. You know when this function is cancelled when <code>isActive == false</code>, so you can add a cleanup block at the&#13;
end, as shown in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">wasteCpu</code><code class="p">()</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">nextPrintTime</code> <code class="p">=</code> <code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">()</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">()</code> <code class="p">&gt;=</code> <code class="n">nextPrintTime</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"job: I'm working.."</code><code class="p">)</code>&#13;
            <code class="n">nextPrintTime</code> <code class="p">+=</code> <code class="m">500</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// cleanup</code>&#13;
    <code class="k">if</code> <code class="p">(!</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Sometimes you’ll need to have the cleanup logic outside the cancelled function; &#13;
<span class="keep-together">for example,</span> when this function comes&#13;
from an external dependency. So you need &#13;
<span class="keep-together">to find</span> a way to notify the call stack that this function is cancelled.&#13;
Exceptions are perfect for this. This is why the coroutine framework follows this convention<a data-primary="CancellationException" data-type="indexterm" id="idm46669747024272"/> of throwing &#13;
<span class="keep-together">a <code>CancellationException</code>.</span> Actually, <em>all</em> suspending functions from the &#13;
<span class="keep-together"><em>kotlinx.coroutines</em></span> package are cancellable and&#13;
throw <code>CancellationException</code> when cancelled. &#13;
<span class="keep-together"><code>withContext</code></span> is one of them, so you could react to <code>wasteCpu</code> cancellation&#13;
higher in the call stack, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="k">try</code> <code class="p">{</code>&#13;
            <code class="n">wasteCpu</code><code class="p">()</code>&#13;
        <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">CancellationException</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="c1">// handle cancellation</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">delay</code><code class="p">(</code><code class="m">200</code><code class="p">)</code>&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">cancelAndJoin</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Done"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you run this code, you’ll find that a <code>CancellationException</code> is caught. Even though we never explicitly threw a&#13;
<code>CancellationException</code> from inside <code>wasteCpu()</code>, <code>withContext</code> did it for us.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>By throwing <code>CancellationException</code> only  in case of cancellation, the coroutine framework is able to differentiate a&#13;
simple cancellation from a failure of a coroutine. In the latter case, an exception will be raised that isn’t a subtype&#13;
of <code>CancellationException</code>.</p>&#13;
&#13;
<p>If you wish to investigate coroutine cancellation, you can <em>name</em> your coroutines and enable debugging of coroutines inside the IDE by adding the VM option &#13;
<span class="keep-together"><code>-Dkotlinx.coroutines.debug</code>.</span> To name a coroutine, simply add a <code>CoroutineName</code> context element like so: <code>val</code> <code>job</code> <code>=</code> <code>launch(CoroutineName("wasteCpu"))</code> <code>{..}</code>.&#13;
This way, when catching a &#13;
<span class="keep-together"><code>CancellationException</code>,</span> the stacktrace is much more explicit and begins with the following line:</p>&#13;
&#13;
<pre data-type="programlisting">kotlinx.coroutines.JobCancellationException: StandaloneCoroutine was cancelled; job="wasteCpu#2":StandaloneCoroutine{Cancelling}@53bd815b</pre>&#13;
</div>&#13;
&#13;
<p>In the previous example, if you swap <code>wasteCpu()</code> with <code>performHttpRequest()</code>—the suspending function we made earlier&#13;
with <code>suspendCancellableCoroutine</code>—you will also find that a <code>CancellationException</code> is caught. So a suspending&#13;
function made with <code>suspendCancellableCoroutine</code> also throws a <code>CancellationException</code> when cancelled.<a data-startref="ix_ch08-asciidoc20" data-type="indexterm" id="idm46669746934000"/><a data-startref="ix_ch08-asciidoc19" data-type="indexterm" id="idm46669746933264"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="delay Is Cancellable" data-type="sect2"><div class="sect2" id="idm46669747196448">&#13;
<h2>delay Is Cancellable</h2>&#13;
&#13;
<p><a data-primary="cancellation" data-secondary="delay" data-type="indexterm" id="idm46669746931472"/><a data-primary="delay function" data-type="indexterm" id="idm46669746930464"/><a data-primary="structured concurrency with coroutines" data-secondary="delay cancellation" data-type="indexterm" id="idm46669746929792"/>Remember <code>delay()</code>? Its signature is shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">public</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">delay</code><code class="p">(</code><code class="n">timeMillis</code><code class="p">:</code> <code class="n">Long</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">timeMillis</code> <code class="p">&lt;=</code> <code class="m">0</code><code class="p">)</code> <code class="k">return</code> <code class="c1">// don't delay</code>&#13;
    <code class="k">return</code> <code class="n">suspendCancellableCoroutine</code> <code class="n">sc</code><code class="err">@</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>suspendCancellableCoroutine</code> again! So this means that anywhere you use <code>delay</code>, you’re giving a coroutine or suspending&#13;
function the opportunity to cancel. Building on this, we could rewrite <code>wasteCpu()</code> as in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code><code> </code><code class="n">suspend</code><code> </code><code class="k">fun</code><code> </code><code class="nf">wasteCpu</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">var</code><code> </code><code class="py">nextPrintTime</code><code> </code><code class="p">=</code><code> </code><code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">while</code><code> </code><code class="p">(</code><code class="k">true</code><code class="p">)</code><code> </code><code class="p">{</code><code>       </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO5-1" id="co_structured_concurrency_with_coroutines_CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">delay</code><code class="p">(</code><code class="m">1</code><code class="m">0</code><code class="p">)</code><code>        </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO5-2" id="co_structured_concurrency_with_coroutines_CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">&gt;</code><code class="p">=</code><code> </code><code class="n">nextPrintTime</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="n">println</code><code class="p">(</code><code class="s">"job: I'm working.."</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="n">nextPrintTime</code><code> </code><code class="p">+</code><code class="p">=</code><code> </code><code class="m">5</code><code class="m">0</code><code class="m">0</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>Notice that:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO5-1" id="callout_structured_concurrency_with_coroutines_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We removed the <code>isActive</code> check.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO5-2" id="callout_structured_concurrency_with_coroutines_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Then we added a simple <code>delay</code>, with a small enough sleep time (so the behavior is similar to the previous implementation).</p></dd>&#13;
</dl>&#13;
&#13;
<p>This new version of <code>wasCpu</code> turns out to be cancellable just like the original, and throws <code>CancellationException</code>&#13;
when cancelled. This is because this suspending function spends most of its time in the <code>delay</code> function.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>To summarize this section, you should strive to make your suspending functions cancellable. A suspending function can&#13;
be made of several suspending functions. All of them should be cancellable. For example, if you need to perform a CPU-heavy computation, then you should use<a data-primary="yield()" data-type="indexterm" id="idm46669746793904"/> <code>yield()</code> or<a data-primary="ensureActive" data-type="indexterm" id="idm46669746754896"/> <code>ensureActive()</code> at strategic places. For example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">compute</code><code class="p">()</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
     <code class="n">blockingCall</code><code class="p">()</code>  <code class="c1">// a regular blocking call, hopefully not blocking too long</code>&#13;
     <code class="n">yield</code><code class="p">()</code>  <code class="c1">// give the opportunity to cancel</code>&#13;
     <code class="n">anotherBlockingCall</code><code class="p">()</code>   <code class="c1">// because why not</code>&#13;
<code class="p">}</code></pre>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handling Cancellation" data-type="sect2"><div class="sect2" id="idm46669746745696">&#13;
<h2>Handling Cancellation</h2>&#13;
&#13;
<p><a data-primary="cancellation" data-secondary="handling" data-type="indexterm" id="idm46669746733024"/><a data-primary="structured concurrency with coroutines" data-secondary="handling cancellation" data-type="indexterm" id="idm46669746732048"/>In the previous section, you learned that it is possible to react to cancellation using a try/catch statement. However,&#13;
imagine that inside the code handling the cancellation, you need to call some other suspending functions.&#13;
You could be tempted to implement the strategy shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="n">suspendCall</code><code class="p">()</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">CancellationException</code><code class="p">)</code> <code class="p">{</code>&#13;
       <code class="c1">// handle cancellation</code>&#13;
       <code class="n">anotherSuspendCall</code><code class="p">()</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Sadly, the preceding code doesn’t compile. Why? Because <em>a cancelled coroutine isn’t allowed to suspend</em>. This is another&#13;
rule from the coroutine framework. The solution is to use <code>withContext(NonCancellable)</code>, as shown in the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="n">suspendCall</code><code class="p">()</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">CancellationException</code><code class="p">)</code> <code class="p">{</code>&#13;
       <code class="c1">// handle cancellation</code>&#13;
       <code class="n">withContext</code><code class="p">(</code><code class="n">NonCancellable</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">anotherSuspendCall</code><code class="p">()</code>&#13;
       <code class="p">}</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>NonCancellable</code> is specifically designed for <code>withContext</code> to make sure the supplied block of code won’t be cancelled.<sup><a data-type="noteref" href="ch08.html#idm46669746634112" id="idm46669746634112-marker">8</a></sup></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Causes of Cancellation" data-type="sect2"><div class="sect2" id="idm46669746631872">&#13;
<h2>Causes of Cancellation</h2>&#13;
&#13;
<p><a data-primary="structured concurrency with coroutines" data-secondary="causes of cancellation" data-type="indexterm" id="ix_ch08-asciidoc22"/>As we’ve seen before, there are two kinds of cancellation: <em>by design</em> and <em>by failure</em>. Initially, we said that a failure is encountered when an exception is thrown. It was a bit of an overstatement. You’ve just&#13;
seen that, when voluntarily cancelling a coroutine, a <code>CancellationException</code> is thrown. This is in fact what distinguishes&#13;
the two kinds of cancellation.</p>&#13;
&#13;
<p>When cancelling a coroutine<a data-primary="Job.cancel" data-type="indexterm" id="idm46669746596272"/> <code>Job.cancel</code> (by design), the coroutine terminates without affecting its parent. If the&#13;
parent also has other child coroutines, they also aren’t affected by this cancellation. The following code illustrates&#13;
this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">child1</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="n">delay</code><code class="p">(</code><code class="n">Long</code><code class="p">.</code><code class="n">MAX_VALUE</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
        <code class="k">val</code> <code class="py">child2</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="n">child1</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Child 1 is cancelled"</code><code class="p">)</code>&#13;
&#13;
            <code class="n">delay</code><code class="p">(</code><code class="m">100</code><code class="p">)</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Child 2 is still alive!"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Cancelling child 1.."</code><code class="p">)</code>&#13;
        <code class="n">child1</code><code class="p">.</code><code class="n">cancel</code><code class="p">()</code>&#13;
        <code class="n">child2</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Parent is not cancelled"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output of this program is:</p>&#13;
&#13;
<pre data-type="programlisting">Cancelling child 1..&#13;
Child 1 is cancelled&#13;
Child 2 is still alive!&#13;
Parent is not cancelled</pre>&#13;
&#13;
<p><code>child1</code> delays forever while <code>child2</code> waits for <code>child1</code> to proceed. The parent quickly cancels <code>child1</code>, and we can see&#13;
that <code>child1</code> is indeed cancelled since <code>child2</code> continues its execution. Finally, the output “Parent is not cancelled” is&#13;
proof that the parent wasn’t affected by this cancellation (nor was <code>child2</code>, by the way).</p>&#13;
&#13;
<p>On the other hand, in the case of a failure (if an exception different from &#13;
<span class="keep-together"><code>CancellationException</code></span> was thrown), the&#13;
default behavior is that the parent gets cancelled with that exception. If the parent also has other child coroutines,&#13;
they are also cancelled. Let’s try to illustrate this. Spoiler alert—don’t do what we show in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">runBlocking</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">scope</code><code> </code><code class="p">=</code><code> </code><code class="n">CoroutineScope</code><code class="p">(</code><code class="n">coroutineContext</code><code> </code><code class="p">+</code><code> </code><code class="n">Job</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>    </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO6-1" id="co_structured_concurrency_with_coroutines_CO6-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">job</code><code> </code><code class="p">=</code><code> </code><code class="n">scope</code><code class="p">.</code><code class="n">launch</code><code> </code><code class="p">{</code><code>                                </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO6-2" id="co_structured_concurrency_with_coroutines_CO6-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">launch</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="k">try</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                </code><code class="n">delay</code><code class="p">(</code><code class="n">Long</code><code class="p">.</code><code class="n">MAX_VALUE</code><code class="p">)</code><code>                       </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO6-3" id="co_structured_concurrency_with_coroutines_CO6-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>            </code><code class="p">}</code><code> </code><code class="k">finally</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                </code><code class="n">println</code><code class="p">(</code><code class="s">"Child 1 was cancelled"</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="n">launch</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="n">delay</code><code class="p">(</code><code class="m">1</code><code class="m">0</code><code class="m">0</code><code class="m">0</code><code class="p">)</code><code>                                     </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO6-4" id="co_structured_concurrency_with_coroutines_CO6-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>            </code><code class="k">throw</code><code> </code><code class="n">IOException</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="n">job</code><code class="p">.</code><code class="n">join</code><code class="p">(</code><code class="p">)</code><code>                                              </code><a class="co" href="#callout_structured_concurrency_with_coroutines_CO6-5" id="co_structured_concurrency_with_coroutines_CO6-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>What we’re trying to create is a circumstance in which a child fails after some time, and we want to check that it&#13;
causes the parent to fail. Then we need to confirm that all other child coroutines of that parent should be cancelled&#13;
too, assuming that’s the cancellation policy we passed.</p>&#13;
&#13;
<p>At first glance, this code looks OK:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO6-1" id="callout_structured_concurrency_with_coroutines_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We’re creating the parent scope.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO6-2" id="callout_structured_concurrency_with_coroutines_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We’re starting a new coroutine inside this scope.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO6-3" id="callout_structured_concurrency_with_coroutines_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The first child waits indefinitely. If this child gets cancelled, it should print “Child 1 was cancelled” since a&#13;
<code>CancellationException</code> would have been thrown from the <code>delay(Long.MAX_VALUE)</code>.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO6-4" id="callout_structured_concurrency_with_coroutines_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Another child throws an <code>IOException</code> after a delay of 1 second.</p></dd>&#13;
<dt><a class="co" href="#co_structured_concurrency_with_coroutines_CO6-5" id="callout_structured_concurrency_with_coroutines_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Wait for the coroutine started in step 2. If you don’t do this, the execution of <code>runBlocking</code> terminates and the program&#13;
stops.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Running this program, you indeed see “Child 1 was cancelled,” though the program crashes right after with an uncaught <code>IOException</code>. Even if you surround <code>job.join()</code> with a <code>try</code>/<code>catch</code> block, you’ll still get the crash.</p>&#13;
&#13;
<p>What we’re missing here is the origination of the exception. It was thrown from inside a <code>launch</code>, which propagates exceptions upward through the coroutine hierarchy until it reaches the parent scope. This behavior cannot be overridden. Once that <code>scope</code> sees the exception, it cancels itself and all its children, then propagates the exception to its parent, which is the scope of <code>runBlocking</code>.</p>&#13;
&#13;
<p>It’s important to realize that trying to catch the exception isn’t going to change the fact that the root coroutine of&#13;
<code>runBlocking</code> is going to be cancelled with that exception.</p>&#13;
&#13;
<p>In some cases, you might consider this as an acceptable scenario: any unhandled exception leads to a program crash.&#13;
However, in other scenarios you might prefer to prevent the failure of <code>scope</code> to propagate to the main coroutine.&#13;
To this purpose, you need to register a <code>CoroutineExceptionHandler</code> (CEH):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">ceh</code> <code class="p">=</code> <code class="n">CoroutineExceptionHandler</code> <code class="p">{</code> <code class="n">_</code><code class="p">,</code> <code class="n">exception</code> <code class="p">-&gt;</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Caught original $exception"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">coroutineContext</code> <code class="p">+</code> <code class="n">ceh</code> <code class="p">+</code> <code class="n">Job</code><code class="p">())</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
         <code class="c1">// same as in the previous code sample</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A<a data-primary="CoroutineExceptionHandler" data-type="indexterm" id="idm46669746321184"/> <code>CoroutineExceptionHandler</code> is conceptually very similar to <code>Thread.UncaughtExceptionHandler</code>—except it’s intended for coroutines. It’s a <code>Context</code> element, which should be added to the context of a scope or a coroutine. The scope&#13;
should create its own <code>Job</code> instance, as a CEH only takes effect when installed at the top of a coroutine hierarchy. In the preceding example, we added the CEH to the context of the scope. We could very well have added it to the context of the first <code>launch</code>, like so:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">ceh</code> <code class="p">=</code> <code class="n">CoroutineExceptionHandler</code> <code class="p">{</code> <code class="n">_</code><code class="p">,</code> <code class="n">exception</code> <code class="p">-&gt;</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Caught original $exception"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// The CEH can also be part of the scope</code>&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">coroutineContext</code> <code class="p">+</code> <code class="n">Job</code><code class="p">())</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code><code class="p">(</code><code class="n">ceh</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c1">// same as in the previous code sample</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Running this sample with the exception handler, the output of the program now is:</p>&#13;
&#13;
<pre data-type="programlisting">Child 1 was cancelled&#13;
Caught original java.io.IOException</pre>&#13;
&#13;
<p>The program no longer crashes. From inside the CEH implementation, you could retry the previously failed operations.</p>&#13;
&#13;
<p>This example demonstrates that <em>by default</em>, the failure of a coroutine causes its parent to cancel itself along with&#13;
all the other children of that parent. What if this behavior doesn’t match your application design? Sometimes the&#13;
failure of a coroutine is acceptable and doesn’t require the cancellation of all other coroutines started inside the&#13;
same scope. This is called <em>supervision</em> in the coroutine framework<a data-startref="ix_ch08-asciidoc22" data-type="indexterm" id="idm46669746163248"/>.<a data-startref="ix_ch08-asciidoc9" data-type="indexterm" id="idm46669746162416"/><a data-startref="ix_ch08-asciidoc8" data-type="indexterm" id="idm46669746161712"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Supervision" data-type="sect1"><div class="sect1" id="idm46669748177344">&#13;
<h1>Supervision</h1>&#13;
&#13;
<p><a data-primary="structured concurrency with coroutines" data-secondary="supervision" data-type="indexterm" id="ix_ch08-asciidoc23"/><a data-primary="supervision" data-type="indexterm" id="ix_ch08-asciidoc24"/>Consider the real-world example of loading a fragment’s layout. Each child <code>View</code> might require some background&#13;
processing to be fully constructed. Assuming you’re using a scope which defaults to the main thread, and child coroutines&#13;
for the background tasks, the failure of one of those tasks shouldn’t cause the failure of the parent scope. Otherwise,&#13;
the whole fragment would become unresponsive to the user.</p>&#13;
&#13;
<p>To implement this cancellation strategy, you can use<a data-primary="SupervisorJob" data-type="indexterm" id="idm46669746156320"/> <code>SupervisorJob</code>, which is a <code>Job</code> for which the failure or cancellation&#13;
of a child doesn’t affect other children; <em>nor</em> does it affect the scope itself. A <code>SupervisorJob</code> is typically used as a&#13;
drop-in replacement for <code>Job</code> when building a <code>CoroutineScope</code>. The resulting scope is then called a “supervisor scope.”&#13;
Such a scope propagates cancellation downward only, as shown in the following code:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">ceh</code> <code class="p">=</code> <code class="n">CoroutineExceptionHandler</code> <code class="p">{</code> <code class="n">_</code><code class="p">,</code> <code class="n">e</code> <code class="p">-&gt;</code> <code class="n">println</code><code class="p">(</code><code class="s">"Handled $e"</code><code class="p">)</code> <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">supervisor</code> <code class="p">=</code> <code class="n">SupervisorJob</code><code class="p">()</code>&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">coroutineContext</code> <code class="p">+</code> <code class="n">ceh</code> <code class="p">+</code> <code class="n">supervisor</code><code class="p">)</code>&#13;
    <code class="n">with</code><code class="p">(</code><code class="n">scope</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">firstChild</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"First child is failing"</code><code class="p">)</code>&#13;
            <code class="k">throw</code> <code class="n">AssertionError</code><code class="p">(</code><code class="s">"First child is cancelled"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="k">val</code> <code class="py">secondChild</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="n">firstChild</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
&#13;
            <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code> <code class="c1">// playing nice with hypothetical cancellation</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"First child is cancelled: ${firstChild.isCancelled}, but second one is still active"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="c1">// wait until the second child completes</code>&#13;
        <code class="n">secondChild</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output of this sample is:</p>&#13;
&#13;
<pre data-type="programlisting">First child is failing&#13;
Handled java.lang.AssertionError: First child is cancelled&#13;
First child is cancelled: true, but second one is still active</pre>&#13;
&#13;
<p>Notice that we’ve installed a CEH in the context of the scope. Why? The first child throws an exception that is never caught. Even if a supervisor scope isn’t affected by the failure of a child, it still propagates unhandled exceptions—which, as you know, might cause the program to crash. This is precisely the purpose of a CEH: to handle uncaught exceptions. Interestingly enough, the CEH could also have been installed into the context of the first <code>launch</code>, with the same result, as shown in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">ceh</code> <code class="p">=</code> <code class="n">CoroutineExceptionHandler</code> <code class="p">{</code> <code class="n">_</code><code class="p">,</code> <code class="n">e</code> <code class="p">-&gt;</code> <code class="n">println</code><code class="p">(</code><code class="s">"Handled $e"</code><code class="p">)</code> <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">supervisor</code> <code class="p">=</code> <code class="n">SupervisorJob</code><code class="p">()</code>&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">coroutineContext</code> <code class="p">+</code> <code class="n">supervisor</code><code class="p">)</code>&#13;
    <code class="n">with</code><code class="p">(</code><code class="n">scope</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">firstChild</code> <code class="p">=</code> <code class="n">launch</code><code class="p">(</code><code class="n">ceh</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"First child is failing"</code><code class="p">)</code>&#13;
            <code class="k">throw</code> <code class="n">AssertionError</code><code class="p">(</code><code class="s">"First child is cancelled"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="k">val</code> <code class="py">secondChild</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="n">firstChild</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
&#13;
            <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"First child is cancelled: ${firstChild.isCancelled}, but second one is still active"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="c1">// wait until the second child completes</code>&#13;
        <code class="n">secondChild</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A CEH is intended to be installed at the top of a coroutine hierarchy, as this is the place where uncaught exceptions&#13;
can be handled.</p>&#13;
&#13;
<p>In this example, the CEH is installed on a direct child of the coroutine scope. You can install it on a nested coroutine, as in&#13;
the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">firstChild</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"First child is failing"</code><code class="p">)</code>&#13;
    <code class="n">launch</code><code class="p">(</code><code class="n">ceh</code><code class="p">)</code> <code class="p">{</code>&#13;
       <code class="k">throw</code> <code class="n">AssertionError</code><code class="p">(</code><code class="s">"First child is cancelled"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this case, the CEH isn’t accounted for, and the program might crash.<a data-startref="ix_ch08-asciidoc24" data-type="indexterm" id="idm46669745872640"/><a data-startref="ix_ch08-asciidoc23" data-type="indexterm" id="idm46669745872032"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="supervisorScope Builder" data-type="sect1"><div class="sect1" id="idm46669746160784">&#13;
<h1>supervisorScope Builder</h1>&#13;
&#13;
<p><a data-primary="structured concurrency with coroutines" data-secondary="supervisorScope builder" data-type="indexterm" id="idm46669745870256"/><a data-primary="supervisorScope" data-type="indexterm" id="idm46669745869120"/>Similarly to <code>coroutineScope</code> builder—which inherits the current context and creates a new <code>Job</code>—<code>supervisorScope</code>&#13;
creates a <code>SupervisorJob</code>. Just like <code>coroutineScope</code>, it waits for all children to complete. One crucial difference&#13;
with<a data-primary="coroutineScope" data-type="indexterm" id="idm46669745866144"/> <code>coroutineScope</code> is that it only propagates cancellation downward, and cancels all children only if it has failed&#13;
itself. Another difference with <code>coroutineScope</code> is how exceptions are handled. We’ll delve into that in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parallel Decomposition" data-type="sect1"><div class="sect1" id="idm46669745864208">&#13;
<h1>Parallel Decomposition</h1>&#13;
&#13;
<p><a data-primary="parallel decomposition" data-type="indexterm" id="idm46669745834064"/><a data-primary="structured concurrency with coroutines" data-secondary="parallel decomposition" data-type="indexterm" id="idm46669745833328"/>Imagine that a suspending function has to run multiple tasks in parallel before returning its result. Take, for example,&#13;
the suspending function <code>weatherForHike</code> from our hiking app at the beginning of this chapter. Fetching the weather could involve&#13;
multiple APIs, depending on the nature of the data. Wind data and temperature could be fetched separately, from separate&#13;
data sources.</p>&#13;
&#13;
<p>Assuming you have suspending functions <code>fetchWind</code> and <code>fetchTemperatures</code>, you could implement <code>weatherForHike</code> as follows:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">weatherForHike</code><code class="p">(</code><code class="n">hike</code><code class="p">:</code> <code class="n">Hike</code><code class="p">):</code> <code class="n">Weather</code> <code class="p">=</code>&#13;
        <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="k">val</code> <code class="py">deferredWind</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code> <code class="n">fetchWind</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code> <code class="p">}</code>&#13;
   <code class="k">val</code> <code class="py">deferredTemp</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code> <code class="n">fetchTemperatures</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code> <code class="p">}</code>&#13;
   <code class="k">val</code> <code class="py">wind</code> <code class="p">=</code> <code class="n">deferredWind</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
   <code class="k">val</code> <code class="py">temperatures</code> <code class="p">=</code> <code class="n">deferredTemp</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
   <code class="n">Weather</code><code class="p">(</code><code class="n">wind</code><code class="p">,</code> <code class="n">temperatures</code><code class="p">)</code> <code class="c1">// assuming Weather can be built that way</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>async</code> can also be used in this example because <code>withContext</code> provides a <code>CoroutineScope</code>—its last&#13;
argument is a suspending lambda with <code>CoroutineScope</code> as the receiver. Without <code>withContext</code>, this sample wouldn’t compile,&#13;
because there wouldn’t be any scope provided for <code>async</code>.</p>&#13;
&#13;
<p><code>withContext</code> is particularly useful when you need to change the dispatcher inside your suspending function.&#13;
What if you don’t need to change your dispatcher? The suspending <code>weatherForHike</code> could very well be called from a&#13;
coroutine which is already dispatched to the IO dispatcher. Then, using <code>withContext(Dispatchers.IO)</code> would be redundant.&#13;
In such situations, you could use <code>coroutineScope</code> instead of or in conjunction with <code>withContext</code>. It’s a <code>CoroutineScope</code>&#13;
builder, which you use as in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">weatherForHike</code><code class="p">(</code><code class="n">hike</code><code class="p">:</code> <code class="n">Hike</code><code class="p">):</code> <code class="n">Weather</code> <code class="p">=</code> <code class="n">coroutineScope</code> <code class="p">{</code>&#13;
    <code class="c1">// Wind and temperature fetch are performed concurrently</code>&#13;
    <code class="k">val</code> <code class="py">deferredWind</code> <code class="p">=</code> <code class="n">async</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">fetchWind</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">val</code> <code class="py">deferredTemp</code> <code class="p">=</code> <code class="n">async</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">fetchTemperatures</code><code class="p">(</code><code class="n">hike</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
   <code class="k">val</code> <code class="py">wind</code> <code class="p">=</code> <code class="n">deferredWind</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
   <code class="k">val</code> <code class="py">temperatures</code> <code class="p">=</code> <code class="n">deferredTemp</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
   <code class="n">Weather</code><code class="p">(</code><code class="n">wind</code><code class="p">,</code> <code class="n">temperatures</code><code class="p">)</code> <code class="c1">// assuming Weather can be built that way</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, <code>coroutineScope</code> replaces <code>withContext</code>. What does this <code>coroutineScope</code> do? First of all, have a look at its signature:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">public</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">R</code><code class="p">&gt;</code> <code class="n">coroutineScope</code><code class="p">(</code><code class="n">block</code><code class="p">:</code> <code class="n">suspend</code> <code class="n">CoroutineScope</code><code class="p">.()</code> <code class="p">-&gt;</code> <code class="n">R</code><code class="p">):</code> <code class="n">R</code></pre>&#13;
&#13;
<p>From the official documentation, this function creates a <code>CoroutineScope</code> and calls the specified <code>suspend</code> block with&#13;
this scope. The provided scope inherits its&#13;
&#13;
<span class="keep-together"><code>coroutineContext</code></span> from the outer scope, but overrides the context’s <code>Job</code>.</p>&#13;
&#13;
<p>This function is designed for <em>parallel decomposition</em> of work. When any child coroutine in this scope fails, this scope&#13;
fails and all the rest of the children are cancelled (for a different behavior, use supervisorScope). This function&#13;
returns as soon as the given block and all its child coroutines are completed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Automatic Cancellation" data-type="sect1"><div class="sect1" id="idm46669745834784">&#13;
<h1>Automatic Cancellation</h1>&#13;
&#13;
<p><a data-primary="automatic cancellation" data-type="indexterm" id="idm46669745598880"/><a data-primary="cancellation" data-secondary="automatic" data-type="indexterm" id="idm46669745597952"/><a data-primary="structured concurrency with coroutines" data-secondary="automatic cancellation" data-type="indexterm" id="idm46669745597008"/>Applied to our example, if <code>fetchWind</code> fails, the scope provided by <code>coroutineScope</code> fails and&#13;
<code>fetchTemperatures</code> is subsequently cancelled. If <code>fetchTemperatures</code> involves allocating heavy objects, you can see&#13;
the benefit of the cancellation.</p>&#13;
&#13;
<p><code>coroutineScope</code> really shines when you need to <em>perform several tasks concurrently</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exception Handling" data-type="sect1"><div class="sect1" id="idm46669745592912">&#13;
<h1>Exception Handling</h1>&#13;
&#13;
<p><a data-primary="exception handling" data-type="indexterm" id="ix_ch08-asciidoc25"/><a data-primary="structured concurrency with coroutines" data-secondary="exception handling" data-type="indexterm" id="ix_ch08-asciidoc26"/>Exception handling is an important part of your application design. Sometimes you will just catch exceptions immediately&#13;
after they’re raised, while other times you’ll let them bubble up the hierarchy until the dedicated component handles it.&#13;
To that extent, the language construct <code>try</code>/<code>catch</code> is probably what you’ve used so far. However, in the coroutine&#13;
framework, there’s a catch (pun intended). We could have started this chapter with it, but we needed to introduce you&#13;
to <em>supervision</em> and &#13;
<span class="keep-together"><code>CoroutineExceptionHandler</code></span> first.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Unhandled Versus Exposed Exceptions" data-type="sect2"><div class="sect2" id="idm46669745559136">&#13;
<h2>Unhandled Versus Exposed Exceptions</h2>&#13;
&#13;
<p><a data-primary="exception handling" data-secondary="unhandled versus exposed exceptions" data-type="indexterm" id="ix_ch08-asciidoc27"/><a data-primary="exposed exceptions" data-type="indexterm" id="ix_ch08-asciidoc32"/><a data-primary="structured concurrency with coroutines" data-secondary="unhandled versus exposed exceptions" data-type="indexterm" id="ix_ch08-asciidoc29"/><a data-primary="unhandled exceptions" data-secondary="exposed versus" data-type="indexterm" id="ix_ch08-asciidoc30"/>When it comes to exception propagation, uncaught exceptions can be treated by the coroutine machinery as on of the following:</p>&#13;
<dl>&#13;
<dt>Unhandled to the client code</dt>&#13;
<dd>&#13;
<p><em>Unhandled</em> exceptions can only be handled by a <code>CoroutineExceptionHandler</code>.</p>&#13;
</dd>&#13;
<dt>Exposed to the client code</dt>&#13;
<dd>&#13;
<p><em>Exposed</em> exceptions are the ones the client code can handle using <code>try</code>/<code>catch</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In this matter, we can distinguish two categories of coroutine builders based on how they treat uncaught exceptions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Unhandled (<code>launch</code> is one of them)</p>&#13;
</li>&#13;
<li>&#13;
<p>Exposed (<code>async</code> is one of them)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>First of all, do note that we’re talking about uncaught exceptions. If you catch an exception <em>before</em> it is handled by&#13;
a coroutine builder, everything works as usual—you catch it, so the coroutine machinery isn’t aware of it. The following&#13;
shows an example with <code>launch</code> and <code>try</code>/<code>catch</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="n">regularFunctionWhichCanThrowException</code><code class="p">()</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c1">// handle exception</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This example works as you would expect, <em>if</em> <code>regularFunctionWhichCanThrowException</code> is, as its name suggests, a regular&#13;
function which does not involve, directly or indirectly, other coroutine builders—in which case, special rules can apply&#13;
(as we’ll see later in this chapter).</p>&#13;
&#13;
<p>The same idea applies to the <code>async</code> builder, as shown in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">itemCntDeferred</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code>&#13;
        <code class="k">try</code> <code class="p">{</code>&#13;
            <code class="n">getItemCount</code><code class="p">()</code>&#13;
        <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="c1">// Something went wrong. Suppose you don't care and consider it should return 0.</code>&#13;
            <code class="m">0</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">count</code> <code class="p">=</code> <code class="n">itemCntDeferred</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Item count: $count"</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">getItemCount</code><code class="p">():</code> <code class="n">Int</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="n">Exception</code><code class="p">()</code>&#13;
    <code class="m">1</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output of this program is, as you can easily guess:</p>&#13;
&#13;
<pre data-type="programlisting">Item count: 0</pre>&#13;
&#13;
<p>Alternatively, instead of <code>try</code>/<code>catch</code>, you could use<a data-primary="runCatching" data-type="indexterm" id="idm46669745406560"/> <code>runCatching</code>. It allows for a nicer syntax if you consider that&#13;
the happy path is when no exception is thrown:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
     <code class="k">val</code> <code class="py">result</code> <code class="p">=</code> <code class="n">runCatching</code> <code class="p">{</code>&#13;
           <code class="n">regularFunctionWhichCanThrowException</code><code class="p">()</code>&#13;
     <code class="p">}</code>&#13;
&#13;
     <code class="k">if</code> <code class="p">(</code><code class="n">result</code><code class="p">.</code><code class="n">isSuccess</code><code class="p">)</code> <code class="p">{</code>&#13;
         <code class="c1">// no exception was thrown</code>&#13;
     <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
         <code class="c1">// exception was thrown</code>&#13;
     <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Under the hood, <code>runCatching</code> is nothing but a <code>try</code>/<code>catch</code>, returning a <code>Result</code> object, which offers some sugar methods&#13;
like <code>getOrNull()</code> and <code>exceptionOrNull()</code>, as in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Calls the specified function [block] with `this` value as its receiver</code>&#13;
<code class="cm"> * and returns its encapsulated result if invocation was successful,</code>&#13;
<code class="cm"> * catching and encapsulating any thrown exception as a failure.</code>&#13;
<code class="cm"> */</code>&#13;
<code class="k">public</code> <code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">,</code> <code class="n">R</code><code class="p">&gt;</code> <code class="n">T</code><code class="p">.</code><code class="n">runCatching</code><code class="p">(</code><code class="n">block</code><code class="p">:</code> <code class="n">T</code><code class="p">.()</code> <code class="p">-&gt;</code> <code class="n">R</code><code class="p">):</code> <code class="n">Result</code><code class="p">&lt;</code><code class="n">R</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="n">Result</code><code class="p">.</code><code class="n">success</code><code class="p">(</code><code class="n">block</code><code class="p">())</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">Result</code><code class="p">.</code><code class="n">failure</code><code class="p">(</code><code class="n">e</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Some extension functions are defined on the <code>Result</code> and available out of the box, like <code>getOrDefault</code> which returns&#13;
the encapsulated value of the <code>Result</code> instance if <code>Result.isSuccess</code> is <code>true</code> or a provided default value otherwise.<a data-startref="ix_ch08-asciidoc30" data-type="indexterm" id="idm46669745255728"/><a data-startref="ix_ch08-asciidoc29" data-type="indexterm" id="idm46669745254992"/><a data-startref="ix_ch08-asciidoc27" data-type="indexterm" id="idm46669745254320"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exposed Exceptions" data-type="sect2"><div class="sect2" id="idm46669745558544">&#13;
<h2>Exposed Exceptions</h2>&#13;
&#13;
<p><a data-primary="exception handling" data-secondary="exposed exceptions" data-type="indexterm" id="ix_ch08-asciidoc31"/><a data-primary="structured concurrency with coroutines" data-secondary="exposed exceptions" data-type="indexterm" id="ix_ch08-asciidoc33"/>As we stated before, you can catch <em>exposed</em> exceptions using built-in language support: <code>try</code>/<code>catch</code>. The following code shows where we have created our own scope inside of which two concurrent tasks, <code>task1</code> and <code>task2</code>, are started in a <code>supervisorScope</code>. <code>task2</code> immediately fails:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">Job</code><code class="p">())</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">supervisorScope</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">task1</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
                <code class="c1">// simulate a background task</code>&#13;
                <code class="n">delay</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
                <code class="n">println</code><code class="p">(</code><code class="s">"Done background task"</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="k">val</code> <code class="py">task2</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code>&#13;
                <code class="c1">// try to fetch some count, but it fails</code>&#13;
                <code class="k">throw</code> <code class="n">Exception</code><code class="p">()</code>&#13;
                <code class="m">1</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="k">try</code> <code class="p">{</code>&#13;
                <code class="n">task2</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
            <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="n">println</code><code class="p">(</code><code class="s">"Caught exception $e"</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
            <code class="n">task1</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Program ends"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output of this program is:</p>&#13;
&#13;
<pre data-type="programlisting">Caught exception java.lang.Exception&#13;
Done background task&#13;
Program ends</pre>&#13;
&#13;
<p>This example demonstrates that inside a<a data-primary="supervisorScope" data-type="indexterm" id="idm46669745116000"/> <code>supervisorScope</code>, <code>async</code> <em>exposes</em> uncaught exceptions in the <code>await</code> call.&#13;
If you don’t surround the <code>await</code> call with a <code>try</code>/<code>catch</code> block, then the scope of <code>supervisorScope</code> fails and cancels&#13;
<code>task1</code>, then <em>exposes</em> to its parent the exception that caused its failure.&#13;
So this means that even when using a <code>supervisorScope</code>, unhandled exceptions in a scope lead to the cancellation of the&#13;
entire coroutine hierarchy beneath that scope—and the exception is propagated up. By handling the exception the way we did in this&#13;
example, task 2 fails while task 1 isn’t affected.</p>&#13;
&#13;
<p>Interestingly enough, if you don’t invoke <code>task2.await()</code>, the program executes as if no exception was ever—thrown`task2`&#13;
silently fails.</p>&#13;
&#13;
<p>Now we’ll use the exact same example, but with a <code>coroutineScope</code> instead of &#13;
<span class="keep-together"><code>supervisorScope</code>:</span></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">Job</code><code class="p">())</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">coroutineScope</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">task1</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
                <code class="n">delay</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
                <code class="n">println</code><code class="p">(</code><code class="s">"Done background task"</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="k">val</code> <code class="py">task2</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code>&#13;
                <code class="k">throw</code> <code class="n">Exception</code><code class="p">()</code>&#13;
                <code class="m">1</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="k">try</code> <code class="p">{</code>&#13;
                <code class="n">task2</code><code class="p">.</code><code class="n">await</code><code class="p">()</code>&#13;
            <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="n">println</code><code class="p">(</code><code class="s">"Caught exception $e"</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
            <code class="n">task1</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Program ends"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output of this program is:</p>&#13;
&#13;
<pre data-type="programlisting">Caught exception java.lang.Exception</pre>&#13;
&#13;
<p>Then the program crashes on Android due to <code>java.lang.Exception</code>—we’ll explain this shortly.</p>&#13;
&#13;
<p>From this you can learn that inside a <code>coroutineScope</code>, <code>async</code> <em>exposes</em> uncaught exceptions but also notifies its&#13;
parent. If you don’t call <code>task2.await()</code>, the program still crashes because <code>coroutineScope</code> fails and <em>exposes</em> to&#13;
its parent the exception that caused its failure. Then, <code>scope.launch</code> treats this exception as <em>unhandled</em>.<a data-startref="ix_ch08-asciidoc33" data-type="indexterm" id="idm46669744975120"/><a data-startref="ix_ch08-asciidoc32" data-type="indexterm" id="idm46669744974384"/><a data-startref="ix_ch08-asciidoc31" data-type="indexterm" id="idm46669744973712"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Unhandled Exceptions" data-type="sect2"><div class="sect2" id="idm46669745253184">&#13;
<h2>Unhandled Exceptions</h2>&#13;
&#13;
<p><a data-primary="exception handling" data-secondary="unhandled exceptions" data-type="indexterm" id="ix_ch08-asciidoc34"/><a data-primary="structured concurrency with coroutines" data-secondary="unhandled exceptions" data-type="indexterm" id="ix_ch08-asciidoc35"/><a data-primary="unhandled exceptions" data-secondary="about" data-type="indexterm" id="ix_ch08-asciidoc36"/>The coroutine framework treats unhandled exceptions in a specific way: it tries to use a CEH if the coroutine context&#13;
has one. If not, it delegates to the <em>global handler</em>. This handler calls a customizable set of CEH <em>and</em> calls the&#13;
standard mechanism of unhandled exceptions: <code>Thread.uncaughtExceptionHandler</code>. By default on Android, the previously&#13;
mentioned set of handlers is only made of a single CEH which prints the stacktrace of the unhandled exception.&#13;
However, it is possible to register a custom handler which will be called in addition to the one that prints the&#13;
stacktrace. So you should remember that if you don’t handle an exception, the <code>Thread.uncaughtExceptionHandler</code> <em>will</em>&#13;
be invoked.</p>&#13;
&#13;
<p>The default<a data-primary="UncaughtExceptionHandler" data-type="indexterm" id="idm46669744964720"/> <code>UncaughtExceptionHandler</code> on Android makes your application crash, while on the JVM,<sup><a data-type="noteref" href="ch08.html#idm46669744963376" id="idm46669744963376-marker">9</a></sup> the default handler prints the stacktrace to the console. Consequently, if you execute this program not on Android&#13;
but on the JVM, the output is:<sup><a data-type="noteref" href="ch08.html#idm46669744962560" id="idm46669744962560-marker">10</a></sup></p>&#13;
&#13;
<pre data-type="programlisting">Caught exception java.lang.Exception&#13;
(stacktrace of java.lang.Exception)&#13;
Program ends</pre>&#13;
&#13;
<p>Back to Android. How could you handle this exception? Since <code>coroutineScope</code> &#13;
<span class="keep-together"><em>exposes</em></span> exceptions, you could wrap <code>coroutineScope</code> inside a <code>try</code>/<code>catch</code> statement. Alternatively, if you don’t handle it correctly, the preceding <code>coroutineScope</code>,&#13;
<code>scope.launch</code>, treats this exception as unhandled. Then your last chance to handle this exception is to register a CEH. There are at least two reasons you would do that: first, to stop the exception’s propagation and avoid a program crash; and second, to notify your crash analytics and rethrow the exception—potentially making the application crash.&#13;
In any case, we’re not advocating for silently catching exceptions. If you do want to use CEH, there are a couple of&#13;
things you should know. A CEH only works when registered to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>launch</code> (not <code>async</code>) when <code>launch</code> is a root coroutine builder<sup><a data-type="noteref" href="ch08.html#idm46669744952688" id="idm46669744952688-marker">11</a></sup></p>&#13;
</li>&#13;
<li>&#13;
<p>A scope</p>&#13;
</li>&#13;
<li>&#13;
<p><code>supervisorScope</code><em>s</em> direct child</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In our example, the CEH should be registered either on <code>scope.launch</code> or on the scope itself. The following code shows this on the root coroutine:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">ceh</code> <code class="p">=</code> <code class="n">CoroutineExceptionHandler</code> <code class="p">{</code> <code class="n">_</code><code class="p">,</code> <code class="n">t</code> <code class="p">-&gt;</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"CEH handle $t"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">Job</code><code class="p">())</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code><code class="p">(</code><code class="n">ceh</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">coroutineScope</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">task1</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
                <code class="n">delay</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
                <code class="n">println</code><code class="p">(</code><code class="s">"Done background task"</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="k">val</code> <code class="py">task2</code> <code class="p">=</code> <code class="n">async</code> <code class="p">{</code>&#13;
                <code class="k">throw</code> <code class="n">Exception</code><code class="p">()</code>&#13;
                <code class="m">1</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="n">task1</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Program ends"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output of this program is:</p>&#13;
&#13;
<pre data-type="programlisting">Caught exception java.lang.Exception&#13;
CEH handle java.lang.Exception&#13;
Program ends</pre>&#13;
&#13;
<p>Here is the same example, this time with the CEH registered on the scope:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">ceh</code> <code class="p">=</code> <code class="n">CoroutineExceptionHandler</code> <code class="p">{</code> <code class="n">_</code><code class="p">,</code> <code class="n">t</code> <code class="p">-&gt;</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"CEH handle $t"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">Job</code><code class="p">()</code> <code class="p">+</code> <code class="n">ceh</code><code class="p">)</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
       <code class="c1">// same as previous example</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, we illustrate the use of a CEH on a <code>supervisorScope</code> direct child:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">ceh</code> <code class="p">=</code> <code class="n">CoroutineExceptionHandler</code> <code class="p">{</code> <code class="n">_</code><code class="p">,</code> <code class="n">t</code> <code class="p">-&gt;</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"CEH handle $t"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">scope</code> <code class="p">=</code> <code class="n">CoroutineScope</code><code class="p">(</code><code class="n">Job</code><code class="p">())</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">supervisorScope</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">task1</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
                <code class="c1">// simulate a background task</code>&#13;
                <code class="n">delay</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
                <code class="n">println</code><code class="p">(</code><code class="s">"Done background task"</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="k">val</code> <code class="py">task2</code> <code class="p">=</code> <code class="n">launch</code><code class="p">(</code><code class="n">ceh</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="c1">// try to fetch some count, but it fails</code>&#13;
                <code class="k">throw</code> <code class="n">Exception</code><code class="p">()</code>&#13;
            <code class="p">}</code>&#13;
&#13;
            <code class="n">task1</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
            <code class="n">task2</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Program ends"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice that the coroutine builder on which the CEH is registered is a <code>launch</code>. It wouldn’t have been taken into account&#13;
with an <code>async</code>, which <em>exposes</em> uncaught exceptions, which can be handled with <code>try</code>/<code>catch</code><a data-startref="ix_ch08-asciidoc36" data-type="indexterm" id="idm46669744614992"/><a data-startref="ix_ch08-asciidoc35" data-type="indexterm" id="idm46669744614368"/><a data-startref="ix_ch08-asciidoc34" data-type="indexterm" id="idm46669744613696"/>.<a data-startref="ix_ch08-asciidoc26" data-type="indexterm" id="idm46669744612896"/><a data-startref="ix_ch08-asciidoc25" data-type="indexterm" id="idm46669744612192"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669744972576">&#13;
<h1>Summary</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>When a function might not return immediately, it’s a good candidate to be implemented as a suspending function. However,&#13;
the <code>suspend</code> modifier doesn’t magically turn a blocking call into a nonblocking one. Use <code>withContext</code> along with&#13;
the appropriate <code>Dispatcher</code>, and/or call other suspending functions.</p>&#13;
</li>&#13;
<li>&#13;
<p>A coroutine can be deliberately cancelled using <code>Job.cancel()</code> for <code>launch</code>, or <code>Deferred.cancel()</code> for <code>async</code>.&#13;
If you need to call some suspending functions inside your cleanup code, make sure you wrap your cleanup logic inside a&#13;
<code>withContext(NonCancellable) { .. }</code> block. The cancelled coroutine will remain in the cancelling state until the cleanup&#13;
exits. After the cleanup is done, the aforementioned coroutine goes to the cancelled state.</p>&#13;
</li>&#13;
<li>&#13;
<p>A coroutine always waits for its children to complete before completing itself. So cancelling a coroutine also cancels&#13;
all of its children.</p>&#13;
</li>&#13;
<li>&#13;
<p>Your coroutines should be cooperative with cancellation. All suspending functions from the <em>kotlinx.coroutines</em>&#13;
package are cancellable. This notably includes <code>withContext</code>. If you’re implementing your own suspending function, make&#13;
sure it is cancellable by checking <code>isActive</code> or calling <code>ensureActive()</code> or <code>yield()</code> at appropriate steps.</p>&#13;
</li>&#13;
<li>&#13;
<p>There are two categories of coroutine scope: the scopes using <code>Job</code> and the ones using <code>SupervisorJob</code> (also&#13;
called supervisor scopes). They differ in how cancellation is performed and in exception handling. If the failure of a child&#13;
should also cancel other children, use a regular scope. Otherwise, use a supervisor scope.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>launch</code> and <code>async</code> differ in how they treat uncaught exceptions. <code>async</code> <em>exposes</em> exceptions, which can be caught&#13;
by wrapping the <code>await</code> call in a <code>try</code>/<code>catch</code>. On the other hand, <code>launch</code> treats uncaught exceptions as unhandled,&#13;
which can be handled using a CEH.</p>&#13;
</li>&#13;
<li>&#13;
<p>A CEH is optional. It should only be used when you really need to do something with unhandled exceptions. Unhandled&#13;
exceptions typically should make your application crash. Or, at least, recovering from some exceptions might leave your&#13;
application in an undetermined state. Nevertheless, if you decide to use a CEH, then it should be installed at the top&#13;
of the coroutine hierarchy—typically into the topmost scope. It can also be installed on a <code>supervisorScope</code> direct child.</p>&#13;
</li>&#13;
<li>&#13;
<p>If a coroutine fails because of an uncaught exception, it gets cancelled along with all of its children and the&#13;
exceptions propagate up.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Closing Thoughts" data-type="sect1"><div class="sect1" id="idm46669744590464">&#13;
<h1>Closing Thoughts</h1>&#13;
&#13;
<p>You learned how to write your own suspending functions, and how to use them inside coroutines. Your coroutines live within&#13;
scopes. In order to implement the desired cancellation policy, you know how to choose between &#13;
<span class="keep-together"><code>coroutineScope</code></span> and&#13;
&#13;
<span class="keep-together"><code>supervisorScope</code>.</span> The scopes you create are children of other scopes higher in the hierarchy.&#13;
In Android, those “root” scopes are library-provided—you don’t create them yourself. A good example is the&#13;
<code>viewModelScope</code> available in any <code>ViewModel</code> instance.</p>&#13;
&#13;
<p>Coroutines are a perfect fit for one-time or repetitive tasks. However, we often have to work with asynchronous streams&#13;
of data. <code>Channel</code>s and <code>Flow</code>s are designed for that, and will be covered in the next two chapters.<a data-startref="ix_ch08-asciidoc0" data-type="indexterm" id="idm46669744584544"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669749430800"><sup><a href="ch08.html#idm46669749430800-marker">1</a></sup> When performing CPU-bound tasks, a worker is bound to a CPU core.</p><p data-type="footnote" id="idm46669749241152"><sup><a href="ch08.html#idm46669749241152-marker">2</a></sup> See <em>Java Concurrency in Practice</em> (Addison-Wesley), Brian Goetz et al., 16.2.2.</p><p data-type="footnote" id="idm46669749034928"><sup><a href="ch08.html#idm46669749034928-marker">3</a></sup> We mentioned this in <a data-type="xref" href="ch05.html#thread_safety_id">Chapter 5</a>. In this case, it means that we add a new element to <code>hikeDataList</code> from the main thread.</p><p data-type="footnote" id="idm46669748759888"><sup><a href="ch08.html#idm46669748759888-marker">4</a></sup> Unless the <code>Dispatchers.IO</code> suffers from thread starvation, which is highly unlikely.</p><p data-type="footnote" id="idm46669748190592"><sup><a href="ch08.html#idm46669748190592-marker">5</a></sup> It’s just a subclass of the regular <code>CoroutineScope</code>, which invokes <code>coroutineContext.cancel()</code> inside its <code>close()</code> method.</p><p data-type="footnote" id="idm46669748183760"><sup><a href="ch08.html#idm46669748183760-marker">6</a></sup> Notice that the material on the suspending functions approach is relatively shorter (three and a half pages compared to seven pages for the traditional approach)—probably because suspending functions is an easier (and easier-to-explain) solution.</p><p data-type="footnote" id="idm46669748133168"><sup><a href="ch08.html#idm46669748133168-marker">7</a></sup> When started lazily, a coroutine is in the <code>New</code> state. Only after invoking <code>job.start()</code> does the coroutine move to the <code>Active state</code>. Calling <code>job.join()</code> also starts the coroutine.</p><p data-type="footnote" id="idm46669746634112"><sup><a href="ch08.html#idm46669746634112-marker">8</a></sup> <code>NonCancellable</code> is actually a special implementation of <code>Job</code> which is always in <code>Active</code> state. So suspending functions that use <code>ensureActive()</code> under this context are never cancelled.</p><p data-type="footnote" id="idm46669744963376"><sup><a href="ch08.html#idm46669744963376-marker">9</a></sup> By JVM, we mean on a desktop application, or on the server side.</p><p data-type="footnote" id="idm46669744962560"><sup><a href="ch08.html#idm46669744962560-marker">10</a></sup> “Program ends” is printed because the <em>unhandled</em> exception makes <code>scope</code> fail, not the scope from  <span class="keep-together"><code>runBlocking</code>.</span></p><p data-type="footnote" id="idm46669744952688"><sup><a href="ch08.html#idm46669744952688-marker">11</a></sup> A root coroutine builder is a scope’s direct child. In the previous example, at the line <code>val job = scope.launch {..}</code>, <code>launch</code> is a root coroutine builder.</p></div></div></section></body></html>