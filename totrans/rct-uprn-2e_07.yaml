- en: Chapter 7\. Building the App’s Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know all the basics of creating custom React components (and using
    the built-in ones), using JSX to define the user interfaces, and using `create-react-app`
    for building and deploying the results, it’s time to start building a more complete
    app.
  prefs: []
  type: TYPE_NORMAL
- en: The app is called “Whinepad,” and it allows users to keep notes and rate the
    wines they are trying. It doesn’t have to be wines, really; it could be anything
    they’d like to *whine* about. It should do all you would expect from a create,
    read, update, and delete (CRUD) application. It should also be a client-side app,
    storing the data on the client. The goal is to learn React, so the non-React parts
    (e.g., server-side storage, CSS presentation) of the narrative are kept to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: When building an app, it’s a good idea to start with small, reusable components
    and combine them to form the whole. The more independent and reusable these components
    are, the better. This chapter focuses on creating the components, one at a time,
    and the next chapter puts them all together.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, initialize and start the new CRA app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start Coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just to verify that all is working as expected, open *~/reactbook/whinepad/public/index.html*
    and change the title of the document to match the new app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The browser auto-reloads and you can see the title change (shown in [Figure 7-1](#FIG0701)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0701](Images/rur2_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. The beginning of a new app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, for the purposes of organization, let’s keep all the React components
    and their corresponding CSS inside a new directory *whinepad/src/components*.
    Any other code that is not strictly components, like various utilities you might
    need, can go in *whinepad/src/modules*. The root *src* contains all the files
    CRA generated. You can change them, of course, but any new code goes in either
    of the two new directories `components` or `modules`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring the Excel Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s get Whinepad off the ground. It’s a rating app where you take notes. So
    how about having the welcome screen be the list of stuff you’ve already rated
    in a nice table? This means reusing the `<Excel>` component from [Chapter 4](ch04.xhtml#ch4).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s grab a version of `Excel` (extracted from the file *04.10.fn.table-reducer.html*
    as it appears toward the end of [Chapter 4](ch04.xhtml#ch4)) and copy it over
    to *whinepad/src/components/Excel.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '`Excel` can now be a reusable standalone component that doesn’t know anything
    about where data is coming from and how the content is inserted into an HTML page.
    It’s just a React component, one of the building blocks of the app. And you already
    know that a usable component has three jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: Import dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do the work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Export the component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ignoring the dependencies part for a minute, now `Excel` can look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to the dependencies. Before, when dealing with pure HTML, `React` was
    a global variable and so was `PropTypes`. Now you `import` them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use the state hook via `React.useState()`. However it’s often convenient
    to assign some of the React properties using the *named import* syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And now you can use the state hook with the shorter `useState()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s move the object cloning helper into its own module, since it’s
    not really `Excel`’s job, and moving it will make it easier to replace the quick-and-dirty
    implementation with a proper library at any time later on. This means importing
    a new `clone` module from `Excel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the clone module lives in *modules/* directory, the place
    designed for modules. In other words, it’s a JavaScript file with no dependencies
    named *whinepad/src/modules/clone.js* that looks like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When importing JavaScript files, you can omit the *.js* extension. You can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And so the new `Excel` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Version 0.0.1 of the New App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now you have a standalone reusable component. So let’s use it. The *App.js*
    file that was generated by CRA is the top-level component for the application,
    and you can import `Excel` there. Deleting the CRA-generated code and replacing
    with `Excel` and some temporary data, you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this, you have a working app, shown in [Figure 7-2](#FIG0702). It’s fairly
    modest, but it can still search and edit data.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0702](Images/rur2_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. A new app is born
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in [Chapter 6](ch06.xhtml#ch6), let’s have one CSS file per component.
    So *Excel.js* component should come (if needed) with an *Excel.css*. Any class
    names in *Excel.js* should be prefixed with *Excel-*. In the current implementation
    from [Chapter 4](ch04.xhtml#ch4), elements are styled using the HTML selectors
    (e.g. `table th {...}`), but in a real app consisting of reusable elements, the
    styles should be scoped to components so they don’t interfere with other components.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are many options when it comes to styling your app. But for the purposes
    of this discussion, let’s focus on the React parts. A simple CSS naming convention
    will do the trick.
  prefs: []
  type: TYPE_NORMAL
- en: Any “global” styles can go in the CRA-created *App.css*, but these should be
    limited to a small set of really generic styles, for example the fonts for the
    whole app. CRA also generates an *index.css* but to avoid confusion about which
    global styles go where, let’s delete it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the top-level `<div>` that `Excel` renders becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can scope the styles to apply only to this component by using the `Excel`
    prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Local Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep the discussion limited to React as much as possible, let’s keep all
    the data in the browser and not worry about the server-side parts. But instead
    of hardcoding the data in the app, let’s use `localStorage`. If the storage is
    empty, one default should be enough to hint to the user about the purpose of the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data retrieval can happen in the top-level *App.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s also just remove the “search” button from `Excel`; it should become a
    part of its own component, better separated from the `Excel` component.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, you’re on a path to a great new app (see [Figure 7-3](#FIG0703)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0703](Images/rur2_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. An app with style
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know the setup is working, it’s time to build all the components
    that make up the app. Figures [7-4](#FIG0704) and [7-5](#FIG0705) show screenshots
    of the app-to-be.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0704](Images/rur2_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. The Whinepad app to be built
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0705](Images/rur2_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Editing items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reusing the existing `<Excel>` component is one way to get started; however,
    this component is doing too much. It’s better to “divide and conquer” by splitting
    it into small, reusable components. For example, the buttons should be their own
    components so they can be reused outside of the context of the `Excel` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the app needs some other specialized components such as a rating
    widget that shows emojis instead of just a number, a dialog component, and so
    on. Before getting started with new components, let’s add one more helper—a component
    discovery tool. Its goals are to:'
  prefs: []
  type: TYPE_NORMAL
- en: Let you develop and test components in isolation. Often using a component in
    an app leads you to “marry” the component to the app and reduce its reusability.
    Having the component by itself forces you to make better decisions about decoupling
    it from the environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let other team members discover and reuse existing components. As your app grows,
    so does the team. To minimize the risk of two people working on strikingly similar
    components and to promote component reuse (which leads to faster app development),
    it’s a good idea to have all components in one place, together with examples of
    how they are meant to be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are tools available that allow for component discovery and testing, but
    let’s not introduce another dependency. Instead, let’s take a lightweight do-it-yourself
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A discovery tool can be implemented as a new component that lives together with
    the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task can be as simple as creating a new component (*src/components/Discovery.js*)
    where you list all your components. You can even render the same component with
    different props to demonstrate various uses of a component. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can load the discovery component instead of the real app, by using
    the URL as a condition in your *App.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you load *http://localhost:3000/discovery* instead of *http://localhost:3000/*,
    you can see all the components you’ve added to the `<Discovery>`. At this point
    there’s only a single component, but this page will grow soon enough. Your new
    component discovery tool (see [Figure 7-6](#FIG0706)) is the place to start playing
    with your new components as they come to life. Let’s get to work and build them—one
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0706](Images/rur2_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Whinepad’s component discovery tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Logo and a Body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with a few simple components you can verify that things are working
    and to get excited as you see quick progress. Here are two new components that
    every app needs:'
  prefs: []
  type: TYPE_NORMAL
- en: Logo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *components/Logo.js* doesn’t need much. And just to show it’s possible, let’s
    use an arrow function to define this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The image files you need you can store in *src/images/*, siblings to the components
    found in *src/components/*.
  prefs: []
  type: TYPE_NORMAL
- en: Body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The body is also a simple place for a few styles, and it merely renders the
    children passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the *Body.css*, you refer to images the same way as in a JavaScript file:
    relative to where the CSS is located. The build process takes care to extract
    the images referred to in the code and package them with the rest of the app in
    the *build/* directory (as you saw in the previous chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Discoverable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are really simple components (and maybe unnecessary, you may argue, but
    apps do tend to grow), and they illustrate how you start assembling the app from
    little puzzle pieces. And since they exist, they should be in the discovery tool
    (as shown in [Figure 7-7](#FIG0707)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![rur2 0707](Images/rur2_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. Starting to build the library of components
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: <Button> Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s not an exaggeration to generalize that every app needs a button. It’s often
    a nicely styled vanilla HTML `<button>`, but sometimes it may have to be an `<a>`,
    as was necessary in [Chapter 3](ch03.xhtml#ch3) for the download buttons. How
    about making the new shiny `<Button>` take an optional `href` property? If present,
    it renders an `<a>` underneath it all.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the spirit of test-driven development (TDD), you can start backwards by
    defining example usage of the component in the `<Discovery>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: (Should we call it discovery-driven development, or DDD, then?)
  prefs: []
  type: TYPE_NORMAL
- en: Button.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see *components/Button.js* in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This component is short, but there are a few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses the `classnames` module (more to follow).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a *function expression* syntax (`const Button = () => {}` as opposed
    to `function Button() {}`). There’s really no reason to use this syntax in this
    context; it’s up to you which syntax you prefer, but it’s nice to know it’s possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It uses the spread operator `...props` as a convenient way to say: whatever
    properties were passed to `Button`, carry them over to the underlying HTML element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: classnames Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember this line?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `classnames` package gives you a helpful function when dealing with CSS
    class names. It helps with the common task of having your component use its own
    classes but is also flexible enough to allow customization via class names passed
    by the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bringing in the package to your CRA setup involves running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Notice that your *package.json* is updated with the new dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the package’s only function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This line merges the `Button` class name with any (if any) class names passed
    as properties when creating the component (see [Figure 7-8](#FIG0708)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0708](Images/rur2_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. `<Button>` with a custom class name
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can always do it yourself and concatenate class names, but `classnames`
    is a tiny package that makes it more convenient to do this common task. It also
    lets you set class names conditionally, which is convenient too, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s move on to the next task, which is essential to any data-entry app: dealing
    with forms. As app developers, we’re rarely satisfied with the look and feel of
    the browser’s built-in form inputs and we tend to create our own versions. The
    Whinepad app could not possibly be an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a generic `<FormInput>` component—a factory, if you will. Depending
    on its `type` property, this component should delegate the input creation to more
    specialized components, for example, `<Suggest>` input, `<Rating>` input, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the lower-level components.
  prefs: []
  type: TYPE_NORMAL
- en: <Suggest>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fancy auto-suggest (a.k.a. typeahead) inputs are common on the Web, but let’s
    keep it simple (as in [Figure 7-9](#FIG0709)) and piggyback on what the browser
    already provides—namely, a [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist)
    HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first—update the discovery app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now off to implementing the component in *components/Suggest.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding code demonstrates, there’s nothing special about this component;
    it’s just a wrapper around an `<input>` with a `<datalist>` attached to it (via
    the `randomid`).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0709](Images/rur2_0709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. The `<Suggest>` input in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In terms of JavaScript syntax, this example shows how it’s possible to use
    the *destructuring assignment* to assign more than one property to a variable
    and at the same time define default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: <Rating> Component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The app is about taking notes of things you try. The laziest way to take notes
    is by using star ratings, for example a scale of whole numbers from 1 through
    5, with 5 being the highest/best rating.
  prefs: []
  type: TYPE_NORMAL
- en: 'This highly reusable component can be configured to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use any number of “stars.” Default is 5, but why not, say, 11?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be read-only, because sometimes you don’t want accidental clicks on the stars
    to change that all-important rating data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test the component in the discovery tool (see [Figure 7-10](#FIG0710)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![rur2 0710](Images/rur2_0710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10\. A rating widget
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The bare necessities of the implementation include setting up properties, their
    types and default values, as well as the state to be maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Properties are self-explanatory: `max` is the number of stars, and `readonly`
    makes the widget, well, read-only. The state contains `rating`, which is the current
    value of stars assigned, and `tempRating`, which is to be used when the user moves
    the mouse around the component but is not yet ready to click and commit to a rating.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the rendering. It has:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A loop to make stars between 1 and `props.max`. The stars are just the emoji
    symbol `&#128514;`. When the `RatingOn` style is *not* applied, the stars become
    grey with the help of a CSS filter (`filter: grayscale(0.9);`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A hidden input to act as a real form input and let the value be harvestable
    in a generic fashion (just like any old `<input>`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When the user moves the mouse over the component, the `tempRating` state is
    getting updated, which changes the `RatingOn` class name. When the user clicks,
    the real `rating` state is getting updated, which also updates the hidden input.
    Leaving the component (on mouse out) abandons the `tempRating`, making it the
    same as the `rating`.
  prefs: []
  type: TYPE_NORMAL
- en: Here you can also see an example of using conditional CSS class names with the
    `classNames` function. The class `Rating` is always applied while the `RatingReadonly`
    is applied only when the `readonly` prop is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the relevant part of the CSS that deals with read-only and mouseover
    behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A <FormInput> “Factory”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next comes a generic `<FormInput>` that is capable of producing different inputs
    based on the given properties. This will allow you to generalize the whole app
    and turn it from taking wine notes to, say, managing your personal book library
    via a simple configuration. More on this in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the `<FormInput>` in the discovery app (see [Figure 7-11](#FIG0711)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![rur2 0711](Images/rur2_0711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11\. Form inputs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The implementation of `<FormInput>` (found in *components/FormInput.js*) requires
    the usual boilerplate of import, export, and `propTypes` for validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note `PropTypes.oneOfType([])` in the prop types; it allows the component to
    accept either strings or numbers for default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rendering is one big `switch` statement, which delegates the individual
    input creation to a more specific component or falls back to the built-in DOM
    elements `<input>` and `<textarea>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, not much going on here; this component is just a convenience
    wrapper that allows for implementation-agnostic definition of forms.
  prefs: []
  type: TYPE_NORMAL
- en: <Form>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you have:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom inputs (e.g., `<Rating>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in inputs (e.g., `<textarea>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<FormInput>`—a factory that makes inputs based on the `type` property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s time to make them all work together in a `<Form>` (see [Figure 7-12](#FIG0712)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0712](Images/rur2_0712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-12\. Form elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The form component should be reusable, so there shouldn’t be anything hardcoded
    about the wine rating app. (To take it one step further, nothing about wine is
    to be hardcoded, so the app can be repurposed to *whine* about anything.) The
    `<Form>` component can be configured via an array of `fields`, where each field
    is defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  prefs: []
  type: TYPE_NORMAL
- en: The default is “input.”
  prefs: []
  type: TYPE_NORMAL
- en: '`id`'
  prefs: []
  type: TYPE_NORMAL
- en: This is used so that the input can be found later.
  prefs: []
  type: TYPE_NORMAL
- en: '`label`'
  prefs: []
  type: TYPE_NORMAL
- en: This is placed next to the input.
  prefs: []
  type: TYPE_NORMAL
- en: '`options`'
  prefs: []
  type: TYPE_NORMAL
- en: These are passed to the auto-suggest input.
  prefs: []
  type: TYPE_NORMAL
- en: The `<Form>` also takes a map of default values and is capable of rendering
    read-only, so the user cannot edit the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the boilerplate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Before moving on, let’s review a few new things in this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types: shape, objectOf, arrayOf'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note the use of `PropTypes.shape` in the prop types. It lets you be specific
    in what you expect in a map/object. It’s more strict than just generalizing like
    `PropTypes.object` and is certain to catch more errors before they occur as other
    developers start using your components. Also note the use of the `PropTypes.objectOf`.
    It’s similar to `arrayOf`, which lets you define that you expect an array containing
    certain types of data. Here `objectOf` means that the component expects a `fields`
    prop that is an object. And for every key-value pair in `fields`, the value is
    expected to be another object that has `label`, `type`, and `options` properties,
    something similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize: `PropTypes.object` is any object, `PropTypes.shape` is an object
    with predefined key (property) names, and `PropTypes.objectOf` is an object with
    unknown keys but known types of values.'
  prefs: []
  type: TYPE_NORMAL
- en: Refs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'And what about that `ref` business? Ref (short for reference) allows you to
    access the underlying DOM element from React. It’s not recommended to overuse
    this where you can rely on React. However, in this case we want to allow code
    outside the form to do a generic loop over form inputs and collect the form data.
    And there’s a bit of chain (or parents/children) to get there. For example, we
    want the `<Discovery>` component to collect the form data. So the chain looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Refs allows `Discovery` to get the input’s `value` in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: A ref object is created in `<Discovery>` using the hook `useRef()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ref is passed to `<Form>` which grabs it thanks to the `forwardRef()` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ref is *forwarded* to the HTML/DOM `<form>` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<Discovery>` now has access to the underlying form DOM element via the `.current`
    property of the ref object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of using `<Form>` in the discovery tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now you can add a button that collects the data in the form using the `form`
    ref and its property `form.current`. Because `form.current` gives you access to
    the native form DOM node and native forms contain an array-like collection of
    inputs, this means you can convert the form to an array (with `Array.from()`)
    and iterate over this array. Each element in the array is a native DOM input element
    and you can grab the value of the inputs using their `value` property. That was
    also the reason why even “fancy” form inputs such as `Rating` also contain (and
    update the value of) a hidden input element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Clicking the button shows a message with a JSON string like `{"rateme":"4","freetext":"Hello"}`.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up <Form>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now back to the rendering part of the `<Form>`. It’s a loop over the `fields`
    prop and renders either a read-only version of the `initialData` prop or a working
    form by passing each field info to `<FormInput>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can see it’s relatively simple; the only complexity comes from rendering
    the read-only rating widget instead of a simple value.
  prefs: []
  type: TYPE_NORMAL
- en: <Actions>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next to each row in the data table there should be actions (see [Figure 7-13](#FIG0713))
    you can take on each row: delete, edit, and view (when not all the information
    can fit in a row).'
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0713](Images/rur2_0713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-13\. Actions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here’s the `<Actions>` component being tested in the discovery tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And the component in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the actions are implemented as buttons. The component takes
    a callback function as its `onAction` prop. When the user clicks a button, the
    callback is invoked, passing a string identifying which button was clicked: `''info''`,
    `''edit''`, or `''delete''`. This is a simple pattern for a child to inform its
    parent of a change within the component. As you see, custom events (like `onAction`,
    `onAlienAttack`, etc.) are just that simple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next chapter is all about the data flow in your React app, but you already
    know two ways to exchange data between parents and children: callback properties
    (like `onAction`) and refs.'
  prefs: []
  type: TYPE_NORMAL
- en: Dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let’s build a generic dialog component to be used for any sort of messages
    (instead of `alert()`) or pop-ups (as depicted in [Figure 7-14](#FIG0714)). For
    example, all add/edit forms could be presented in a modal dialog on top of the
    data table.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0714](Images/rur2_0714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-14\. Dialogs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To test the dialogs in the `Discovery` component, just a bit of state is required
    to manage if they are open or closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of a dialog doesn’t need to be too complicated, but let’s
    make it interesting and add a few nice-to-have features:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a header with a title string coming from the the `header` prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a body that is simply the children passed to `<Dialog>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The footer has *OK*/*Cancel* buttons: let’s call them `confirm` and `dismiss`.
    Sometimes a dialog is merely an info message and you need only one button. The
    prop `hasCancel` can define this. If it’s `false`, only the OK button is shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `confirm` button can change the label via the `confirmLabel` prop. The `dismiss`
    button always reads “Cancel.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialog may be “modal,” meaning it takes over the whole app and nothing really
    happens until it’s dismissed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `onAction` prop (similar to the `<Actions>` component) can pass the user’s
    action to the parent component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can dismiss the dialog by hitting Escape or clicking outside the dialog.
    This is a nice and expected feature but sometimes may not be desirable. For example,
    what if you type extensively in a dialog, producing some of your best prose, and
    suddenly you hit Escape? All is lost! The decision about the behavior of the dialog
    should be left to the developer using the component. The `Dialog` can merely enable
    this *extended* behavior (hitting Escape or clicking outside) if requested by
    the developer via the `extendedDismiss` prop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `import`/`export`/`props` setup could look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendering is not too complicated; it’s a conditional CSS when the dialog
    is modal and some conditional buttons display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the *extended* functionality where the user can interact with the
    Escape key or click outside the dialog body is implemented in a `useEffect()`
    hook. This hook will be executed only once, when the dialog renders, and is responsible
    for setting up (and cleaning up) DOM event listeners. As you already know, the
    general `useEffect()` template is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Armed with this template, the implementation could be something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of alternative ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a single `onAction`, another option is to provide `onConfirm` (user
    clicks OK) and `onDismiss`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wrapper `div` has a conditional and a non-conditional class name. The component
    could possibly benefit from the `classnames` module, as follows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, all the lowest-level components are done. Before tackling the
    big one, `Excel`, let’s add a convenient `Header` component made up of logo, search
    box, and an “Add” button to add new records to the data table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the header doesn’t do any searching or adding to the data, but
    it offers callbacks for its parent to do the data management.
  prefs: []
  type: TYPE_NORMAL
- en: App Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be a good idea to divorce the Whinepad app from the wine-specific subject
    matter and make it a reusable CRUD way of managing any sort of data. There should
    be no hardcoded data fields. Instead, a `schema` object can be a description of
    the type of data you want to deal with in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example (*src/config/schema.js*) to get you off the ground with a
    wine-oriented app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an example of one of the simplest ECMAScript modules you can imagine—one
    that exports a single variable. It also imports another simple module that contains
    some lengthy options to prefill in the forms (*src/config/classification.js*).
    Just to keep the `schema` shorter and easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: With the help of the `schema` module, you can now configure what type of data
    you want to manage in the app.
  prefs: []
  type: TYPE_NORMAL
- en: '<Excel>: New and Improved'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And now comes the meat of the app, the data table that does most of the work:
    everything in CRUD, except the C (create).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the new `<Excel>` in `<Discovery>` so it can be tested independently
    of the whole app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the data configuration comes from the `schema`, including
    three samples of the data being passed as the `initialData` prop to be used for
    testing. And then there’s the `onDataChange` callback prop, which enables the
    parent of the component to manage the data as a whole and perform tasks such as
    writing it to a database or `localStorage`. For the purposes of discovery and
    testing, `console.log()` is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Figures [7-15](#FIG0715) through [7-18](#FIG0718) show how `Excel` looks and
    behaves in the discovery tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0715](Images/rur2_0715.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-15\. `Excel` component rendered in `Discovery` with sample data coming
    from `schema`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0716](Images/rur2_0716.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-16\. Editing an item using `Form` in a `Dialog`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0717](Images/rur2_0717.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-17\. Viewing details for an item: same `Form` but rendered read-only'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![rur2 0718](Images/rur2_0718.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-18\. Confirmation when clicking the delete `Action`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Overall Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The familiar structure is imports at the top, export at the end, and an `Excel`
    function for the rendering. Additionally, the component manages a bit of state:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the data sorted? How?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a dialog open? What’s in it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the user editing inline in the table?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data state is managed by a reducer and for everything else, there’s `useState()`.
    Inline in the `Excel` function there are a few helper functions to isolate some
    of the state handling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the rendering portion of the component. There’s an overall
    `div` to help with the styling and in it there’s a `table` and (optionally) a
    dialog, the content of which comes from the `dialog` state. This means that when
    calling `setDialog()` (given by `useState()`), you pass the content of the dialog
    to be rendered (e.g., `setDialog(<Dialog />)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Rendering the table head
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The table head is similar to what you’ve seen in previous chapters except now
    the header labels come from `schema` passed as a prop to `Excel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sorting` variable comes from the state and affects which headers get a
    sorting arrow and in which direction. The whole header (`<thead>`) has an `onClick`
    handler that calls the `sort()` helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Rendering the table body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The table body (`<tbody>`) consists of table rows (`<tr>`) with table cells
    within them (`<td>`). The last cell in each row is reserved for `<Actions>`. You
    need two loops, one for rows and one for cells (columns) within the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some tweaking of the content of each cell (you’ll see it in the next
    section), you’re ready to define the `<td>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Most of the effort goes to defining CSS class names. They are conditional on
    the `schema`, for example how the various data is aligned in the cells (left of
    center).
  prefs: []
  type: TYPE_NORMAL
- en: The oddest-looking class name definition is the `schema-${cell}`. This is optional
    but a nice touch that provides an extra CSS class name for each data type in case
    the developer needs something specific. The syntax may look odd, but it’s the
    ECMAScript way of defining dynamic (*computed*) object property names using the
    `[]` in combination with a template string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, the resulting DOM of an example cell would look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: All the cells are editable except the hard-coded actions and the ratings because
    you don’t want accidental clicks to change the rating.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking and filtering of content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s address the two `TODO` comments in the table rendering. First the tweaking
    of content, which happens in the inner loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You have a boolean `show` config coming from the schema. It’s helpful when you
    have too many columns to show in a single table. In this case, the comments for
    each item in the table may be too long and make the table hard to parse by the
    user. So it’s not shown in the table, though it’s still available (in the View
    Details action) and editable via the Edit action.
  prefs: []
  type: TYPE_NORMAL
- en: Next, if the user has double-clicked to edit the data inline (bringing the table
    into an edit state), you show a form. Otherwise, just the text content, unless
    it’s the rating cell. It’s friendlier to show the “star” rating component, rather
    than simple text (e.g., “5” or “2”) like all other cells.
  prefs: []
  type: TYPE_NORMAL
- en: As for the second `TODO`, it’s the filtering of the data as a result of the
    user’s search string. In the previous chapter there were separate input fields
    for filtering per column. In the real app, let’s have a single search input in
    the header and pass what the user types to the data table. The implementation
    is about going through each column in a row and attempting to match with the search
    string passed as a `filter` prop. If no match is found, the whole row is removed
    from the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And why is this filtering done here, as opposed to in the reducer function?
    It’s a personal choice dictated to an extent by the double-calling of the reducer,
    which React does in “strict” mode.
  prefs: []
  type: TYPE_NORMAL
- en: React.Strict and Reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Excel` uses a `reducer()` for various data manipulations. At the end of every
    manipulation, it invokes the `onDataChange` callback passed to the component.
    That’s how parents of `Excel` can be notified about data changes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what was in `<Discovery>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If you test the component with the console open, you’ll see that for every change
    there are two identical entries in the log (see [Figure 7-19](#FIG0719) for an
    example).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0719](Images/rur2_0719.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-19\. Two console messages after changing “$2 Chuck” to “$2 Chucks”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This happens because in strict mode while in development, React calls your
    reducer twice. If you look back to *index.js* generated by CRA, the whole app
    is wrapped in `<React.StrictMode>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove the wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now the console will have only one log message.
  prefs: []
  type: TYPE_NORMAL
- en: 'This double invocation is React helping you uncover impurities in your reducer.
    The reducer must be *pure*: given the same data, it should return the same results.
    This is a great (again, development-only) feature and you should be on the lookout
    for impurities. Once you build your app, there’s no more double-calling.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case (logging changes) the impurity is tolerable. But in other cases,
    it may not be. For example, let’s say you pass an array to the reducer and it
    removes the last array element before returning the array. The returned array
    is the same object in memory and if you pass it again to the reducer, it will
    remove yet another element. This is not the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter you’ll see a different way (using *contexts*) to communicate
    between parent and child components, beyond the callback props you’ve seen so
    far in the book. This will help avoid the double-calling problem. Still, for education
    purposes and for simple callbacks (e.g., `<Dialog onAction...>`), using props
    is fine, so let’s continue with them for just a bit longer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: “What’s with the timeout?” you may ask. Whenever there is a `setTimeout` with
    no 0 milliseconds actual timeout, chances are there’s a bit of a workaround going
    on. This code is no exception and it has to do, again, with the parent-child communication.
    We will discuss and fix this in Chapter 8.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we uncovered the interesting problem that comes with reducers
    and strict mode. And in the future you’ll know where to look for potential reducer
    problems in your apps. If you see something off and it looks like something is
    happening twice, a quick debug exercise is to remove `<React.StrictMode>` and
    see if the problem goes away. If so, time for another look at your reducers.
  prefs: []
  type: TYPE_NORMAL
- en: Excel’s Little Helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now back to `Excel`. At this point the rendering is done. It’s time to take
    a look at a few functions that you saw commented out in the initial code listing,
    namely the `reducer()` function and the helpers `sort()`, `showEditor()`, `save()`,
    and `handleAction()`.
  prefs: []
  type: TYPE_NORMAL
- en: sort()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In fact, there was already a discussion of `sort()`. It’s a callback for clicking
    on table headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The general task is to figure out what happened (user clicked a header, which
    one?), then update the state (call `setSorting()` provided by `useState()` to
    draw the sorting arrows) and `dispatch()` an event to be handled by the reducer.
    The reducer’s task is to do the actual sorting.
  prefs: []
  type: TYPE_NORMAL
- en: showEditor()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another short helper function is `showEditor()`. It’s called when the user
    double-clicks a cell and changes the state so an inline input field is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Because this function is called for all clicks anywhere in the table (`<tbody
    onDoubleClick={showEditor}>`) you need to filter out cases where no inline form
    is desirable, namely, the rating (no inline rating of items) and anywhere in the
    action column. Action columns don’t have associated schema configuration so `!config`
    takes care of this case. For all other cells, `setEdit()` is called, which updates
    the state identifying which cell is to be edited. Since this is a rendering-only
    change, the reducer doesn’t get involved and so no `dispatch()` is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: save()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, the `save()` helper. It’s invoked when the user is done with inline editing
    and submits the inline form by hitting Enter (`<form onSubmit={save}>`). Similarly
    to `sort()`, `save()` needs to know what happened (what was submitted) and then
    update the state (`setEdit()`) and `dispatch()` an event for the reducer to update
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Figuring out the `valueType` helps the reducer write integers versus strings
    in the data, since all form values come as strings from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: handleAction()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, the `handleAction()` method. It is the longest, but it’s not too complex.
    It needs to deal with three types of actions: delete, edit, and view info. Edit
    and info are close in implementation as the info is a read-only form. Let’s start
    with deleting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Clicking the Delete action brings up a `<Dialog>` saying “Are you sure?” by
    updating the state with `setDialog()` and passing a `<Dialog>` component as the
    dialog state. Regardless of the answer (the dialog’s `onAction`) the dialog is
    dismissed by passing a `null` dialog (`setDialog(null)`). But if the action was
    “confirm,” then an event is dispatched to the reducer.
  prefs: []
  type: TYPE_NORMAL
- en: If the user’s action is for editing or viewing a data row, a new `<Dialog>`
    is created, one that has a form for editing. The form is read-only when simply
    viewing the data. The user can then dismiss the dialog, abandoning any changes
    (which is the only option when viewing) or saving the changes. Saving means another
    dispatch, which includes a `ref` to the form, so the reducer can harvest the form
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: reducer()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the almighty reducer. It’s similar to what you already saw toward
    the end of [Chapter 4](ch04.xhtml#ch4). The sorting and inline editing parts are
    pretty much the same, the filtering is gone and moved to the rendering of the
    table, and there’s now a way to delete rows and to save the editing form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The last two lines were already discussed above. The rest is all about array
    manipulation. The reducer is called with the current data and some payload describing
    what happened, and it acts on that information.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note is how the *delete* action is the only one doing the cloning
    of the original array. This goes back to the discussion above about the double-calling
    of the reducer. All other actions can get away with modifying the array as they
    have an exact row/column to modify. Or, in the case of sorting, no data pieces
    are being modified. So asking twice, “Please update column 1, row 2, with value
    2018” has the same effect every time. However, all the rows are just zero-indexed
    array elements. When you have elements 0, 1, and 2 and you delete 1, then you
    have 0, 1\. And so deleting `id` 1 twice deletes two elements. Cloning the array
    before deletion solves this by producing a new array object. The double-calling
    happens both times with the original `data`, not with the `data` returned by the
    first call, so removing `id` 1 from 0, 1, 2 and again from 0, 1, 2\. Tiny details
    like this when it’s a combination of React strict and the way objects (and arrays
    are objects too) work in JavaScript may cause trouble. So be extra diligent when
    modifying with arrays and objects in your reducers.
  prefs: []
  type: TYPE_NORMAL
- en: And with this, the last component in the app is done and it’s time to put them
    all together to create a working app.
  prefs: []
  type: TYPE_NORMAL
