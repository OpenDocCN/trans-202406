<html><head></head><body><section data-pdf-bookmark="Chapter 3. Functional Programming with JavaScript" data-type="chapter" epub:type="chapter"><div class="chapter" id="functional-programming-with-javascript">&#13;
<h1><span class="label">Chapter 3. </span>Functional Programming with JavaScript</h1>&#13;
&#13;
&#13;
<p>When<a data-primary="functional programming" data-secondary="introduction to" data-type="indexterm" id="idm45901652159400"/> you start to explore React, you’ll likely notice that the topic of&#13;
functional programming comes up a lot. Functional techniques are being&#13;
used more and more in JavaScript projects, particularly React projects.</p>&#13;
&#13;
<p>It’s likely that you’ve already written functional JavaScript code&#13;
without thinking about it. If you’ve mapped or reduced an array, then&#13;
you’re already on your way to becoming a functional JavaScript&#13;
programmer. Functional programming techniques are core not only to React&#13;
but to many of the libraries in the React ecosystem as well.</p>&#13;
&#13;
<p>If you’re wondering where this functional trend came from, the answer&#13;
is the 1930s, with the invention of <em>lambda calculus</em>, or λ-calculus.<sup><a data-type="noteref" href="ch03.html#idm45901652156344" id="idm45901652156344-marker">1</a></sup> Functions have been a part of calculus since it emerged in the&#13;
17th century. Functions can be sent to functions as arguments or&#13;
returned from functions as results.  More complex functions, called<a data-primary="higher-order functions" data-type="indexterm" id="idm45901652154696"/><a data-primary="functions" data-secondary="higher-order" data-type="indexterm" id="idm45901652154024"/>&#13;
<em>higher-order functions</em>, can manipulate functions and use them as&#13;
either arguments or results or both. In the 1930s, Alonzo Church was at&#13;
Princeton experimenting with these higher-order functions when he&#13;
invented lambda calculus.</p>&#13;
&#13;
<p>In the late 1950s, John McCarthy took the concepts derived from&#13;
λ-calculus and applied them to a new programming language called Lisp. Lisp implemented the concept of higher-order functions and functions as<a data-primary="first-class members/functions" data-type="indexterm" id="idm45901652151672"/>&#13;
<em>first-class members</em> or <em>first-class citizens</em>. A function is considered&#13;
a first-class member when it can be declared as a variable and sent to&#13;
functions as an argument. These functions can even be returned from&#13;
functions.</p>&#13;
&#13;
<p>In this chapter, we’re going to go over some of the key concepts of&#13;
functional programming, and we’ll cover how to implement functional&#13;
techniques with JavaScript.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What It Means to Be Functional" data-type="sect1"><div class="sect1" id="what-it-means-to-be-functional">&#13;
<h1>What It Means to Be Functional</h1>&#13;
&#13;
<p>JavaScript<a data-primary="functional programming" data-secondary="definition of term" data-type="indexterm" id="idm45901652146744"/> supports functional programming because JavaScript functions&#13;
are first-class citizens. This means that functions can do the same&#13;
things that variables can do. The latest JavaScript syntax adds language&#13;
improvements that can beef up your functional programming techniques,&#13;
including arrow functions, promises, and the spread operator.</p>&#13;
&#13;
<p>In JavaScript, functions can represent data in your application. You may&#13;
have noticed that you can declare functions with the <code>var</code>, <code>let</code>, or&#13;
<code>const</code> keywords the same way you can declare strings, numbers, or any&#13;
other variables:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">var</code> <code class="nx">log</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">log</code><code class="p">(</code><code class="s2">"In JavaScript, functions are variables"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// In JavaScript, functions are variables</code></pre>&#13;
&#13;
<p>We can write the same function using an arrow function. Functional&#13;
programmers write a lot of small functions, and the arrow function&#13;
syntax makes that much easier:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">log</code> <code class="o">=</code> <code class="nx">message</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Since functions are variables, we can add them to objects:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="s2">"They can be added to objects like variables"</code><code class="p">,</code>&#13;
  <code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">obj</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">obj</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// They can be added to objects like variables</code></pre>&#13;
&#13;
<p>Both of these statements do the same thing: they store a function in a&#13;
variable called <code>log</code>. Additionally, the <code>const</code> keyword was used to&#13;
declare the second function, which will prevent it from being&#13;
overwritten.</p>&#13;
&#13;
<p>We can also add functions to arrays in JavaScript:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">messages</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="s2">"They can be inserted into arrays"</code><code class="p">,</code>&#13;
  <code class="nx">message</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">),</code>&#13;
  <code class="s2">"like variables"</code><code class="p">,</code>&#13;
  <code class="nx">message</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="nx">messages</code><code class="p">[</code><code class="mi">1</code><code class="p">](</code><code class="nx">messages</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code> <code class="c1">// They can be inserted into arrays</code>&#13;
<code class="nx">messages</code><code class="p">[</code><code class="mi">3</code><code class="p">](</code><code class="nx">messages</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code> <code class="c1">// like variables</code></pre>&#13;
&#13;
<p>Functions can be sent to other functions as arguments, just like other&#13;
variables:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">insideFn</code> <code class="o">=</code> <code class="nx">logger</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">logger</code><code class="p">(</code><code class="s2">"They can be sent to other functions as arguments"</code><code class="p">);</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">insideFn</code><code class="p">(</code><code class="nx">message</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// They can be sent to other functions as arguments</code></pre>&#13;
&#13;
<p>They can also be returned from other functions, just like variables:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">createScream</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">logger</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kd">function</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">logger</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="o">+</code> <code class="s2">"!!!"</code><code class="p">);</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">scream</code> <code class="o">=</code> <code class="nx">createScream</code><code class="p">(</code><code class="nx">message</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">));</code>&#13;
&#13;
<code class="nx">scream</code><code class="p">(</code><code class="s2">"functions can be returned from other functions"</code><code class="p">);</code>&#13;
<code class="nx">scream</code><code class="p">(</code><code class="s2">"createScream returns a function"</code><code class="p">);</code>&#13;
<code class="nx">scream</code><code class="p">(</code><code class="s2">"scream invokes that returned function"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// FUNCTIONS CAN BE RETURNED FROM OTHER FUNCTIONS!!!</code>&#13;
<code class="c1">// CREATESCREAM RETURNS A FUNCTION!!!</code>&#13;
<code class="c1">// SCREAM INVOKES THAT RETURNED FUNCTION!!!</code></pre>&#13;
&#13;
<p>The last two examples were of<a data-primary="higher-order functions" data-type="indexterm" id="idm45901651831800"/><a data-primary="functions" data-secondary="higher-order" data-type="indexterm" id="idm45901651763880"/> higher-order functions: functions that&#13;
either take or return other functions. We could describe the same&#13;
<code>createScream</code> higher-order function with arrows:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">createScream</code> <code class="o">=</code> <code class="nx">logger</code> <code class="o">=&gt;</code> <code class="nx">message</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">logger</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="o">+</code> <code class="s2">"!!!"</code><code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>If you see more than one arrow used during a function declaration, this&#13;
means that you’re using a higher-order function.</p>&#13;
&#13;
<p>We can say that JavaScript supports functional programming because its&#13;
functions are first-class citizens. This means that functions are data.&#13;
They can be saved, retrieved, or flow through your applications just&#13;
like variables.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Imperative Versus Declarative" data-type="sect1"><div class="sect1" id="imperative-versus-declarative">&#13;
<h1>Imperative Versus Declarative</h1>&#13;
&#13;
<p>Functional programming<a data-primary="declarative programming" data-type="indexterm" id="declarp03"/><a data-primary="imperative programming" data-type="indexterm" id="imper03"/><a data-primary="functional programming" data-secondary="imperative versus declarative programming" data-type="indexterm" id="FPimper03"/> is a part of a larger programming paradigm:&#13;
<em>declarative programming</em>. Declarative programming is a style of&#13;
programming where applications are structured in a way that prioritizes&#13;
describing <em>what</em> should happen over defining <em>how</em> it should happen.</p>&#13;
&#13;
<p>In order to understand declarative programming, we’ll contrast it with&#13;
<em>imperative programming</em>, or a style of programming that’s only&#13;
concerned with how to achieve results with code. Let’s consider a common&#13;
task: making a string URL-friendly. Typically, this can be accomplished&#13;
by replacing all of the spaces in a string with hyphens, since spaces&#13;
are not URL-friendly. First, let’s examine an imperative approach to&#13;
this task:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">string</code> <code class="o">=</code> <code class="s2">"Restaurants in Hanalei"</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">urlFriendly</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>&#13;
&#13;
<code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">string</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">string</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">===</code> <code class="s2">" "</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">urlFriendly</code> <code class="o">+=</code> <code class="s2">"-"</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="nx">urlFriendly</code> <code class="o">+=</code> <code class="nx">string</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">urlFriendly</code><code class="p">);</code> <code class="c1">// "Restaurants-in-Hanalei"</code></pre>&#13;
&#13;
<p>In this example, we loop through every character in the string,&#13;
replacing spaces as they occur. The structure of this program is only&#13;
concerned with how such a task can be achieved. We use a <code>for</code> loop and&#13;
an <code>if</code> statement and set values with an equality operator. Just&#13;
looking at the code alone does not tell us much. Imperative programs&#13;
require lots of comments in order to understand what’s going on.</p>&#13;
&#13;
<p>Now let’s look at a declarative approach to the same problem:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">string</code> <code class="o">=</code> <code class="s2">"Restaurants in Hanalei"</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">urlFriendly</code> <code class="o">=</code> <code class="nx">string</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="sr">/ /g</code><code class="p">,</code> <code class="s2">"-"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">urlFriendly</code><code class="p">);</code></pre>&#13;
&#13;
<p>Here we are using <code>string.replace</code> along with a regular expression to&#13;
replace all instances of spaces with hyphens. Using <code>string.replace</code> is&#13;
a way of describing what’s supposed to happen: spaces in the string&#13;
should be replaced. The details of how spaces are dealt with are&#13;
abstracted away inside the <code>replace</code> function. In a declarative program,&#13;
the syntax itself describes what should happen, and the details of how&#13;
things happen are abstracted away.</p>&#13;
&#13;
<p>Declarative programs are easy to reason about because the code itself&#13;
describes what is happening. For example, read the syntax in the&#13;
following sample. It details what happens after members are loaded from&#13;
an API:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">loadAndMapMembers</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code>&#13;
  <code class="nx">combineWith</code><code class="p">(</code><code class="nx">sessionStorage</code><code class="p">,</code> <code class="s2">"members"</code><code class="p">),</code>&#13;
  <code class="nx">save</code><code class="p">(</code><code class="nx">sessionStorage</code><code class="p">,</code> <code class="s2">"members"</code><code class="p">),</code>&#13;
  <code class="nx">scopeMembers</code><code class="p">(</code><code class="nb">window</code><code class="p">),</code>&#13;
  <code class="nx">logMemberInfoToConsole</code><code class="p">,</code>&#13;
  <code class="nx">logFieldsToConsole</code><code class="p">(</code><code class="s2">"name.first"</code><code class="p">),</code>&#13;
  <code class="nx">countMembersBy</code><code class="p">(</code><code class="s2">"location.state"</code><code class="p">),</code>&#13;
  <code class="nx">prepStatesForMapping</code><code class="p">,</code>&#13;
  <code class="nx">save</code><code class="p">(</code><code class="nx">sessionStorage</code><code class="p">,</code> <code class="s2">"map"</code><code class="p">),</code>&#13;
  <code class="nx">renderUSMap</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="nx">getFakeMembers</code><code class="p">(</code><code class="mi">100</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">loadAndMapMembers</code><code class="p">);</code></pre>&#13;
&#13;
<p>The declarative approach is more readable and, thus, easier to reason&#13;
about. The details of how each of these functions is implemented are&#13;
abstracted away. Those tiny functions are named well and combined in a&#13;
way that describes how member data goes from being loaded to being saved&#13;
and printed on a map, and this approach does not require many comments.&#13;
Essentially, declarative programming produces applications that are&#13;
easier to reason about, and when it’s easier to reason about an&#13;
application, that application is easier to scale. Additional details&#13;
about the declarative programming paradigm can be found at the&#13;
<a href="https://oreil.ly/7MbkB">Declarative Programming&#13;
wiki</a>.</p>&#13;
&#13;
<p>Now, let’s consider the task of building a document object model, or&#13;
<a href="https://www.w3.org/DOM">DOM</a>. An imperative approach would be concerned&#13;
with how the DOM is constructed:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">target</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"target"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">wrapper</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"div"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">headline</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">wrapper</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="s2">"welcome"</code><code class="p">;</code>&#13;
<code class="nx">headline</code><code class="p">.</code><code class="nx">innerText</code> <code class="o">=</code> <code class="s2">"Hello World"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">wrapper</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">headline</code><code class="p">);</code>&#13;
<code class="nx">target</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">wrapper</code><code class="p">);</code></pre>&#13;
&#13;
<p>This code is concerned with creating elements, setting elements, and&#13;
adding them to the document. It would be very hard to make changes, add&#13;
features, or scale 10,000 lines of code where the DOM is constructed&#13;
imperatively.</p>&#13;
&#13;
<p>Now let’s take a look at how we can construct a DOM declaratively using&#13;
a React component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="p">{</code> <code class="nx">render</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">ReactDOM</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Welcome</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">id</code><code class="o">=</code><code class="s2">"welcome"</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Hello</code> <code class="nx">World</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
  <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Welcome</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"target"</code><code class="p">));</code></pre>&#13;
&#13;
<p>React is declarative. Here, the <code>Welcome</code> component describes the DOM&#13;
that should be rendered. The <code>render</code> function uses the instructions&#13;
declared in the component to build the DOM, abstracting away the details&#13;
of how the DOM is to be rendered. We can clearly see that we want to&#13;
render our <code>Welcome</code> component into the element with the ID of <code>target</code>.<a data-primary="" data-startref="imper03" data-type="indexterm" id="idm45901651320504"/><a data-primary="" data-startref="declarp03" data-type="indexterm" id="idm45901651319640"/><a data-primary="" data-startref="FPimper03" data-type="indexterm" id="idm45901651318696"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Concepts" data-type="sect1"><div class="sect1" id="functional-concepts">&#13;
<h1>Functional Concepts</h1>&#13;
&#13;
<p>Now that you’ve been introduced to functional programming and what it&#13;
means to be “functional” or “declarative,” we’ll move on to&#13;
introducing the core concepts of functional programming: immutability,&#13;
purity, data transformation, higher-order functions, and recursion.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Immutability" data-type="sect2"><div class="sect2" id="immutability">&#13;
<h2>Immutability</h2>&#13;
&#13;
<p>To<a data-primary="functional programming" data-secondary="core concepts" data-tertiary="immutability" data-type="indexterm" id="idm45901651313112"/><a data-primary="immutability" data-type="indexterm" id="idm45901651311944"/> mutate is to change, so to be <em>immutable</em> is to be unchangeable. In a&#13;
functional program, data is immutable. It never changes.</p>&#13;
&#13;
<p>If you need to share your birth certificate with the public but want to&#13;
redact or remove private information, you essentially have two choices:&#13;
you can take a big Sharpie to your original birth certificate and cross&#13;
out your private data, or you can find a copy machine. Finding a copy&#13;
machine, making a copy of your birth certificate, and writing all over&#13;
that copy with that big Sharpie would be preferable. This way you can&#13;
have a redacted birth certificate to share and your original that’s&#13;
still intact.</p>&#13;
&#13;
<p>This is how immutable data works in an application. Instead of changing&#13;
the original data structures, we build changed copies of those data&#13;
structures and use them instead.</p>&#13;
&#13;
<p>To understand how immutability works, let’s take a look at what it means&#13;
to mutate data. Consider an object that represents the color <code>lawn</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">let</code> <code class="nx">color_lawn</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">title</code><code class="o">:</code> <code class="s2">"lawn"</code><code class="p">,</code>&#13;
  <code class="nx">color</code><code class="o">:</code> <code class="s2">"#00FF00"</code><code class="p">,</code>&#13;
  <code class="nx">rating</code><code class="o">:</code> <code class="mi">0</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>We could build a function that would rate colors and use that function&#13;
to change the rating of the <code>color</code> object:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">rateColor</code><code class="p">(</code><code class="nx">color</code><code class="p">,</code> <code class="nx">rating</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">color</code><code class="p">.</code><code class="nx">rating</code> <code class="o">=</code> <code class="nx">rating</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nx">color</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rateColor</code><code class="p">(</code><code class="nx">color_lawn</code><code class="p">,</code> <code class="mi">5</code><code class="p">).</code><code class="nx">rating</code><code class="p">);</code> <code class="c1">// 5</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color_lawn</code><code class="p">.</code><code class="nx">rating</code><code class="p">);</code> <code class="c1">// 5</code></pre>&#13;
&#13;
<p>In JavaScript, function arguments are references to the actual data.&#13;
Setting the color’s rating like this changes or mutates the original&#13;
color object. (Imagine if you tasked a business with redacting and&#13;
sharing your birth certificate and they returned your original birth&#13;
certificate with black marker covering the important details. You’d hope&#13;
that a business would have the common sense to make a copy of your birth&#13;
certificate and return the original unharmed.) We can rewrite the&#13;
<code>rateColor</code> function so that it does not harm the original goods (the&#13;
<code>color</code> object):</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">rateColor</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">color</code><code class="p">,</code> <code class="nx">rating</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">color</code><code class="p">,</code> <code class="p">{</code> <code class="nx">rating</code><code class="o">:</code> <code class="nx">rating</code> <code class="p">});</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">rateColor</code><code class="p">(</code><code class="nx">color_lawn</code><code class="p">,</code> <code class="mi">5</code><code class="p">).</code><code class="nx">rating</code><code class="p">);</code> <code class="c1">// 5</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">color_lawn</code><code class="p">.</code><code class="nx">rating</code><code class="p">);</code> <code class="c1">// 0</code></pre>&#13;
&#13;
<p>Here, we used <code>Object.assign</code> to change the color rating.&#13;
<code>Object.assign</code> is the copy machine. It takes a blank object, copies the&#13;
color to that object, and overwrites the rating on the copy. Now we can&#13;
have a newly rated color object without having to change the original.</p>&#13;
&#13;
<p>We can write the same function using an arrow function along with the&#13;
object spread operator. This <code>rateColor</code> function uses the spread&#13;
operator to copy the color into a new object and then overwrite its&#13;
rating:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">rateColor</code> <code class="o">=</code> <code class="p">(</code><code class="nx">color</code><code class="p">,</code> <code class="nx">rating</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
  <code class="p">...</code><code class="nx">color</code><code class="p">,</code>&#13;
  <code class="nx">rating</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>This version of the <code>rateColor</code> function is exactly the same as the&#13;
previous one. It treats color as an immutable object, does so with less&#13;
syntax, and looks a little bit cleaner. Notice that we wrap the returned&#13;
object in parentheses. With arrow functions, this is a required step&#13;
since the arrow can’t just point to an object’s curly braces.</p>&#13;
&#13;
<p>Let’s consider an array of color names:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">let</code> <code class="nx">list</code> <code class="o">=</code> <code class="p">[{</code> <code class="nx">title</code><code class="o">:</code> <code class="s2">"Rad Red"</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">title</code><code class="o">:</code> <code class="s2">"Lawn"</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">title</code><code class="o">:</code> <code class="s2">"Party Pink"</code> <code class="p">}];</code></pre>&#13;
&#13;
<p>We could create a function that will add colors to that array using&#13;
<code>Array.push</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">addColor</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">title</code><code class="p">,</code> <code class="nx">colors</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">colors</code><code class="p">.</code><code class="nx">push</code><code class="p">({</code> <code class="nx">title</code><code class="o">:</code> <code class="nx">title</code> <code class="p">});</code>&#13;
  <code class="k">return</code> <code class="nx">colors</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">addColor</code><code class="p">(</code><code class="s2">"Glam Green"</code><code class="p">,</code> <code class="nx">list</code><code class="p">).</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// 4</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">list</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// 4</code></pre>&#13;
&#13;
<p>However, <code>Array.push</code> is not an immutable function. This <code>addColor</code>&#13;
function changes the original array by adding another field to it. In&#13;
order to keep the <code>colors</code> array immutable, we must use <code>Array.concat</code>&#13;
instead:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">addColor</code> <code class="o">=</code> <code class="p">(</code><code class="nx">title</code><code class="p">,</code> <code class="nx">array</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">concat</code><code class="p">({</code> <code class="nx">title</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">addColor</code><code class="p">(</code><code class="s2">"Glam Green"</code><code class="p">,</code> <code class="nx">list</code><code class="p">).</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// 4</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">list</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code> <code class="c1">// 3</code></pre>&#13;
&#13;
<p><code>Array.concat</code> concatenates arrays. In this case, it takes a new object&#13;
with a new color title and adds it to a copy of the original array.</p>&#13;
&#13;
<p>You can also use the spread operator to concatenate arrays in the same&#13;
way it can be used to copy objects. Here’s the emerging JavaScript&#13;
equivalent of the previous <code>addColor</code> function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">addColor</code> <code class="o">=</code> <code class="p">(</code><code class="nx">title</code><code class="p">,</code> <code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">[...</code><code class="nx">list</code><code class="p">,</code> <code class="p">{</code> <code class="nx">title</code> <code class="p">}];</code></pre>&#13;
&#13;
<p>This function copies the original list to a new array and then adds a&#13;
new object containing the color’s title to that copy. It is immutable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pure Functions" data-type="sect2"><div class="sect2" id="pure-functions">&#13;
<h2>Pure Functions</h2>&#13;
&#13;
<p>A <em>pure function</em> is<a data-primary="functional programming" data-secondary="core concepts" data-tertiary="pure functions" data-type="indexterm" id="idm45901650823112"/><a data-primary="pure functions" data-type="indexterm" id="idm45901650821832"/><a data-primary="functions" data-secondary="pure functions" data-type="indexterm" id="idm45901650821160"/> a function that returns a value that’s computed&#13;
based on its arguments. Pure functions take at least one argument and&#13;
always return a value or another function. They do not cause side&#13;
effects, set global variables, or change anything about application&#13;
state. They treat their arguments as immutable data.</p>&#13;
&#13;
<p>In order to understand pure functions, let’s first take a look at an&#13;
impure function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">frederick</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Frederick Douglass"</code><code class="p">,</code>&#13;
  <code class="nx">canRead</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="nx">canWrite</code><code class="o">:</code> <code class="kc">false</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">selfEducate</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">frederick</code><code class="p">.</code><code class="nx">canRead</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="nx">frederick</code><code class="p">.</code><code class="nx">canWrite</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nx">frederick</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">selfEducate</code><code class="p">();</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">frederick</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// {name: "Frederick Douglass", canRead: true, canWrite: true}</code></pre>&#13;
&#13;
<p>The <code>selfEducate</code> function is not a pure function. It does not take any&#13;
arguments, and it does not return a value or a function. It also changes&#13;
a variable outside of its scope: <code>Frederick</code>. Once the <code>selfEducate</code>&#13;
function is invoked, something about the “world” has changed. It causes&#13;
side effects:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">frederick</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Frederick Douglass"</code><code class="p">,</code>&#13;
  <code class="nx">canRead</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="nx">canWrite</code><code class="o">:</code> <code class="kc">false</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">selfEducate</code> <code class="o">=</code> <code class="nx">person</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">person</code><code class="p">.</code><code class="nx">canRead</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="nx">person</code><code class="p">.</code><code class="nx">canWrite</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nx">person</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">selfEducate</code><code class="p">(</code><code class="nx">frederick</code><code class="p">));</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">frederick</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// {name: "Frederick Douglass", canRead: true, canWrite: true}</code>&#13;
<code class="c1">// {name: "Frederick Douglass", canRead: true, canWrite: true}</code></pre>&#13;
<div data-type="note" epub:type="note"><h1>Pure Functions Are Testable</h1>&#13;
<p>Pure functions are naturally <em>testable</em>. They do not change anything&#13;
about their environment or “world,” and therefore do not require a&#13;
complicated test setup or teardown. Everything a pure function needs to&#13;
operate it accesses via arguments. When testing a pure function, you&#13;
control the arguments, and thus you can estimate the outcome.&#13;
This <code>selfEducate</code> function is also impure: it causes side effects.&#13;
Invoking this function mutates the objects that are sent to it. If we&#13;
could treat the arguments sent to this function as immutable data, then&#13;
we would have a pure function.</p>&#13;
</div>&#13;
&#13;
<p>Let’s have this function take an argument:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">frederick</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Frederick Douglass"</code><code class="p">,</code>&#13;
  <code class="nx">canRead</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="nx">canWrite</code><code class="o">:</code> <code class="kc">false</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">selfEducate</code> <code class="o">=</code> <code class="nx">person</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
  <code class="p">...</code><code class="nx">person</code><code class="p">,</code>&#13;
  <code class="nx">canRead</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nx">canWrite</code><code class="o">:</code> <code class="kc">true</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">selfEducate</code><code class="p">(</code><code class="nx">frederick</code><code class="p">));</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">frederick</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// {name: "Frederick Douglass", canRead: true, canWrite: true}</code>&#13;
<code class="c1">// {name: "Frederick Douglass", canRead: false, canWrite: false}</code></pre>&#13;
&#13;
<p>Finally, this version of <code>selfEducate</code> is a pure function. It computes a&#13;
value based on the argument that was sent to it: the <code>person</code>. It&#13;
returns a new <code>person</code> object without mutating the argument sent to it&#13;
and therefore has no side effects.</p>&#13;
&#13;
<p>Now let’s examine an impure function that mutates the DOM:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Header</code><code class="p">(</code><code class="nx">text</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">h1</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">);</code>&#13;
  <code class="nx">h1</code><code class="p">.</code><code class="nx">innerText</code> <code class="o">=</code> <code class="nx">text</code><code class="p">;</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">h1</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">Header</code><code class="p">(</code><code class="s2">"Header() caused side effects"</code><code class="p">);</code></pre>&#13;
&#13;
<p>The <code>Header</code> function creates a heading—one element with specific text—and adds it to the DOM. This function is impure. It does not return a&#13;
function or a value, and it causes side effects: a changed DOM.</p>&#13;
&#13;
<p>In React, the UI is expressed with pure functions. In the following&#13;
sample, <code>Header</code> is a pure function that can be used to create <code>h1</code>&#13;
elements just like in the previous example. However, this function on&#13;
its own does not cause side effects because it does not mutate the DOM.&#13;
This function will create an <code>h1</code> element, and it’s up to some other&#13;
part of the application to use that element to change the DOM:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Header</code> <code class="o">=</code> <code class="nx">props</code> <code class="o">=&gt;</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">title</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code></pre>&#13;
&#13;
<p>Pure functions are another core concept of functional programming. They&#13;
will make your life much easier because they will not affect your&#13;
application’s state. When writing functions, try to follow these three&#13;
rules:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The function should take in at least one argument.</p>&#13;
</li>&#13;
<li>&#13;
<p>The function should return a value or another function.</p>&#13;
</li>&#13;
<li>&#13;
<p>The function should not change or mutate any of its arguments.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Transformations" data-type="sect2"><div class="sect2" id="data-transformations">&#13;
<h2>Data Transformations</h2>&#13;
&#13;
<p>How<a data-primary="map and reduce" data-type="indexterm" id="mapred03"/><a data-primary="functional programming" data-secondary="core concepts" data-tertiary="data transformations" data-type="indexterm" id="FPcoretrans03"/><a data-primary="data transformations" data-type="indexterm" id="dtrans03"/> does anything change in an application if the data is immutable?&#13;
Functional programming is all about transforming data from one form to&#13;
another. We’ll produce transformed copies using functions. These&#13;
functions make our code less imperative and thus reduce complexity.</p>&#13;
&#13;
<p>You do not need a special framework to understand how to produce one&#13;
dataset that is based upon another. JavaScript already has the necessary&#13;
tools for this task built into the language. There<a data-primary="Array.map function" data-type="indexterm" id="idm45901650451448"/><a data-primary="Array.reduce function" data-type="indexterm" id="idm45901650450744"/> are two core&#13;
functions that you must master in order to be proficient with functional&#13;
JavaScript: <code>Array.map</code> and <code>Array.reduce</code>.</p>&#13;
&#13;
<p>In this section, we’ll take a look at how these and some other core&#13;
functions transform data from one type to another.</p>&#13;
&#13;
<p>Consider this array of high schools:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">schools</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"Yorktown"</code><code class="p">,</code> <code class="s2">"Washington &amp; Liberty"</code><code class="p">,</code> <code class="s2">"Wakefield"</code><code class="p">];</code></pre>&#13;
&#13;
<p>We<a data-primary="Array.join function" data-type="indexterm" id="idm45901650494680"/> can get a comma-delimited list of these and some other strings by&#13;
using the <code>Array.join</code> function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">schools</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">", "</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// "Yorktown, Washington &amp; Liberty, Wakefield"</code></pre>&#13;
&#13;
<p><code>Array.join</code> is a built-in JavaScript array method that we can use to&#13;
extract a delimited string from our array. The original array is still&#13;
intact; <code>join</code> simply provides a different take on it. The details of&#13;
how this string is produced are abstracted away from the programmer.</p>&#13;
&#13;
<p>If<a data-primary="Array.filter function" data-type="indexterm" id="idm45901650417016"/> we wanted to create a function that creates a new array of the&#13;
schools that begin with the letter “W,” we could use the <code>Array.filter</code>&#13;
method:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">wSchools</code> <code class="o">=</code> <code class="nx">schools</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">school</code> <code class="o">=&gt;</code> <code class="nx">school</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"W"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">wSchools</code><code class="p">);</code>&#13;
<code class="c1">// ["Washington &amp; Liberty", "Wakefield"]</code></pre>&#13;
&#13;
<p><code>Array.filter</code> is a built-in JavaScript function that produces a new&#13;
array from a source array. This function takes a<a data-primary="predicates" data-type="indexterm" id="idm45901650381560"/> <em>predicate</em> as its only&#13;
argument. A predicate is a function that always returns a Boolean value:&#13;
<code>true</code> or <code>false</code>. <code>Array.filter</code> invokes this predicate once for every&#13;
item in the array. That item is passed to the predicate as an argument,&#13;
and the return value is used to decide if that item will be added to&#13;
the new array. In this case, <code>Array.filter</code> is checking every school to&#13;
see if its name begins with a “W.”</p>&#13;
&#13;
<p>When<a data-primary="Array.pop function" data-type="indexterm" id="idm45901650352680"/><a data-primary="Array.splice function" data-type="indexterm" id="idm45901650352056"/> it’s time to remove an item from an array, we should use&#13;
<code>Array.filter</code> over <code>Array.pop</code> or <code>Array.splice</code> because <code>Array.filter</code>&#13;
is immutable. In this next sample, the <code>cutSchool</code> function returns new&#13;
arrays that filter out specific school names:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">cutSchool</code> <code class="o">=</code> <code class="p">(</code><code class="nx">cut</code><code class="p">,</code> <code class="nx">list</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">list</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">school</code> <code class="o">=&gt;</code> <code class="nx">school</code> <code class="o">!==</code> <code class="nx">cut</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">cutSchool</code><code class="p">(</code><code class="s2">"Washington &amp; Liberty"</code><code class="p">,</code> <code class="nx">schools</code><code class="p">).</code><code class="nx">join</code><code class="p">(</code><code class="s2">", "</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// "Yorktown, Wakefield"</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">schools</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// Yorktown</code>&#13;
<code class="c1">// Washington &amp; Liberty</code>&#13;
<code class="c1">// Wakefield</code></pre>&#13;
&#13;
<p>In this case, the <code>cutSchool</code> function is used to return a new array&#13;
that does not contain “Washington &amp; Liberty.” Then, the <code>join</code> function is&#13;
used with this new array to create a string out of the&#13;
remaining two school names. <code>cutSchool</code> is a pure function. It takes a&#13;
list of schools and the name of the school that should be removed and&#13;
returns a new array without that specific school.</p>&#13;
&#13;
<p>Another<a data-primary="Array.map function" data-type="indexterm" id="arraymap03"/> array function that is essential to functional programming is&#13;
<code>Array.map</code>. Instead of a predicate, the <code>Array.map</code> method takes a&#13;
function as its argument. This function will be invoked once for every&#13;
item in the array, and whatever it returns will be added to the new&#13;
array:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">highSchools</code> <code class="o">=</code> <code class="nx">schools</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">school</code> <code class="o">=&gt;</code> <code class="sb">`</code><code class="si">${</code><code class="nx">school</code><code class="si">}</code><code class="sb"> High School`</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">highSchools</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// Yorktown High School</code>&#13;
<code class="c1">// Washington &amp; Liberty High School</code>&#13;
<code class="c1">// Wakefield High School</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">schools</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// Yorktown</code>&#13;
<code class="c1">// Washington &amp; Liberty</code>&#13;
<code class="c1">// Wakefield</code></pre>&#13;
&#13;
<p>In this case, the <code>map</code> function was used to append “High School” to&#13;
each school name. The <code>schools</code> array is still intact.</p>&#13;
&#13;
<p>In the last example, we produced an array of strings from an array of&#13;
strings. The <code>map</code> function can produce an array of objects, values,&#13;
arrays, other functions—any JavaScript type. Here’s an example of the&#13;
<code>map</code> function returning an object for every school:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">highSchools</code> <code class="o">=</code> <code class="nx">schools</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">school</code> <code class="o">=&gt;</code> <code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">school</code> <code class="p">}));</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">highSchools</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// [</code>&#13;
<code class="c1">// { name: "Yorktown" },</code>&#13;
<code class="c1">// { name: "Washington &amp; Liberty" },</code>&#13;
<code class="c1">// { name: "Wakefield" }</code>&#13;
<code class="c1">// ]</code></pre>&#13;
&#13;
<p>An array containing objects was produced from an array that contains&#13;
strings.</p>&#13;
&#13;
<p>If you need to create a pure function that changes one object in an&#13;
array of objects, <code>map</code> can be used for this, too. In the following&#13;
example, we’ll change the school with the name of “Stratford” to “HB&#13;
Woodlawn” without mutating the <code>schools</code> array:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">let</code> <code class="nx">schools</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Yorktown"</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stratford"</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Washington &amp; Liberty"</code> <code class="p">},</code>&#13;
  <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Wakefield"</code> <code class="p">}</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">updatedSchools</code> <code class="o">=</code> <code class="nx">editName</code><code class="p">(</code><code class="s2">"Stratford"</code><code class="p">,</code> <code class="s2">"HB Woodlawn"</code><code class="p">,</code> <code class="nx">schools</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">updatedSchools</code><code class="p">[</code><code class="mi">1</code><code class="p">]);</code> <code class="c1">// { name: "HB Woodlawn" }</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">schools</code><code class="p">[</code><code class="mi">1</code><code class="p">]);</code> <code class="c1">// { name: "Stratford" }</code></pre>&#13;
&#13;
<p>The <code>schools</code> array is an array of objects. The <code>updatedSchools</code>&#13;
variable calls the <code>editName</code> function and we send it the school we want&#13;
to update, the new school, and the <code>schools</code> array. This changes the new&#13;
array but makes no edits to the original:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">editName</code> <code class="o">=</code> <code class="p">(</code><code class="nx">oldName</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">arr</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">arr</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">item</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">item</code><code class="p">.</code><code class="nx">name</code> <code class="o">===</code> <code class="nx">oldName</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="p">{</code>&#13;
        <code class="p">...</code><code class="nx">item</code><code class="p">,</code>&#13;
        <code class="nx">name</code>&#13;
      <code class="p">};</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">item</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">});</code></pre>&#13;
&#13;
<p>Within <code>editName</code>, the <code>map</code> function is used to create a new array of&#13;
objects based upon the original array. The <code>editName</code> function can be&#13;
written entirely in one line. Here’s an example of the same function&#13;
using a shorthand <code>if/else</code> statement:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">editName</code> <code class="o">=</code> <code class="p">(</code><code class="nx">oldName</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">arr</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">arr</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">item</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">item</code><code class="p">.</code><code class="nx">name</code> <code class="o">===</code> <code class="nx">oldName</code> <code class="o">?</code> <code class="p">{</code> <code class="p">...</code><code class="nx">item</code><code class="p">,</code> <code class="nx">name</code> <code class="p">}</code> <code class="o">:</code> <code class="nx">item</code><code class="p">));</code></pre>&#13;
&#13;
<p>If you need to transform an array into an object, you can use&#13;
<code>Array.map</code> in conjunction with <code>Object.keys</code>. <code>Object.keys</code> is a method&#13;
that can be used to return an array of keys from an object.</p>&#13;
&#13;
<p>Let’s say we needed to transform the <code>schools</code> object into an array of&#13;
schools:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">schools</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Yorktown</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code>&#13;
  <code class="s2">"Washington &amp; Liberty"</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">Wakefield</code><code class="o">:</code> <code class="mi">5</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">schoolArray</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">schools</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">key</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">key</code><code class="p">,</code>&#13;
  <code class="nx">wins</code><code class="o">:</code> <code class="nx">schools</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>&#13;
<code class="p">}));</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">schoolArray</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// [</code>&#13;
<code class="c1">// {</code>&#13;
<code class="c1">// name: "Yorktown",</code>&#13;
<code class="c1">// wins: 10</code>&#13;
<code class="c1">// },</code>&#13;
<code class="c1">// {</code>&#13;
<code class="c1">// name: "Washington &amp; Liberty",</code>&#13;
<code class="c1">// wins: 2</code>&#13;
<code class="c1">// },</code>&#13;
<code class="c1">// {</code>&#13;
<code class="c1">// name: "Wakefield",</code>&#13;
<code class="c1">// wins: 5</code>&#13;
<code class="c1">// }</code>&#13;
<code class="c1">// ]</code></pre>&#13;
&#13;
<p>In this example, <code>Object.keys</code> returns an array of school names, and we&#13;
can use <code>map</code> on that array to produce a new array of the same length.&#13;
The <code>name</code> of the new object will be set using the key, and <code>wins</code> is&#13;
set equal to the value.</p>&#13;
&#13;
<p>So far, we’ve learned that we can transform arrays with <code>Array.map</code> and&#13;
<code>Array.filter</code>. We’ve also learned that we can change arrays into&#13;
objects by combining <code>Object.keys</code> with <code>Array.map</code>. The final tool that&#13;
 we need in our functional arsenal is the ability to transform&#13;
arrays into primitives and other objects.<a data-primary="" data-startref="arraymap03" data-type="indexterm" id="idm45901649804920"/></p>&#13;
&#13;
<p>The<a data-primary="Array.reduce function" data-type="indexterm" id="reduce03"/><a data-primary="Array.reduceRight function" data-type="indexterm" id="reduceright03"/> <code>reduce</code> and <code>reduceRight</code> functions can be used to transform an&#13;
array into any value, including a number, string, boolean, object, or&#13;
even a function.</p>&#13;
&#13;
<p>Let’s say we need to find the maximum number in an array of numbers.&#13;
We need to transform an array into a number; therefore, we can use&#13;
<code>reduce</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">ages</code> <code class="o">=</code> <code class="p">[</code><code class="mi">21</code><code class="p">,</code> <code class="mi">18</code><code class="p">,</code> <code class="mi">42</code><code class="p">,</code> <code class="mi">40</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">63</code><code class="p">,</code> <code class="mi">34</code><code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">maxAge</code> <code class="o">=</code> <code class="nx">ages</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">max</code><code class="p">,</code> <code class="nx">age</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">age</code><code class="si">}</code><code class="sb"> &gt; </code><code class="si">${</code><code class="nx">max</code><code class="si">}</code><code class="sb"> = </code><code class="si">${</code><code class="nx">age</code> <code class="o">&gt;</code> <code class="nx">max</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">age</code> <code class="o">&gt;</code> <code class="nx">max</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">age</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">max</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">},</code> <code class="mi">0</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"maxAge"</code><code class="p">,</code> <code class="nx">maxAge</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// 21 &gt; 0 = true</code>&#13;
<code class="c1">// 18 &gt; 21 = false</code>&#13;
<code class="c1">// 42 &gt; 21 = true</code>&#13;
<code class="c1">// 40 &gt; 42 = false</code>&#13;
<code class="c1">// 64 &gt; 42 = true</code>&#13;
<code class="c1">// 63 &gt; 64 = false</code>&#13;
<code class="c1">// 34 &gt; 64 = false</code>&#13;
<code class="c1">// maxAge 64</code></pre>&#13;
&#13;
<p>The <code>ages</code> array has been reduced into a single value: the maximum age,&#13;
<code>64</code>. <code>reduce</code> takes two arguments: a callback function and an original&#13;
value. In this case, the original value is <code>0</code>, which sets the initial&#13;
maximum value to <code>0</code>. The callback is invoked once for every item in the&#13;
array. The first time this callback is invoked, <code>age</code> is equal to <code>21</code>,&#13;
the first value in the array, and <code>max</code> is equal to <code>0</code>, the initial&#13;
value. The callback returns the greater of the two numbers, <code>21</code>, and&#13;
that becomes the <code>max</code> value during the next iteration. Each iteration&#13;
compares each <code>age</code> against the <code>max</code> value and returns the greater of&#13;
the two. Finally, the last number in the array is compared and returned&#13;
from the previous callback.</p>&#13;
&#13;
<p>If we remove the <code>console.log</code> statement from the preceding function and&#13;
use a shorthand <code>if/else</code> statement, we can calculate the max value in&#13;
any array of numbers with the following syntax:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">max</code> <code class="o">=</code> <code class="nx">ages</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">max</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">value</code> <code class="o">&gt;</code> <code class="nx">max</code> <code class="o">?</code> <code class="nx">value</code> <code class="o">:</code> <code class="nx">max</code><code class="p">),</code> <code class="mi">0</code><code class="p">);</code></pre>&#13;
<div data-type="note" epub:type="note"><h1>Array.reduceRight</h1>&#13;
<p><code>Array.reduceRight</code> works the same way as <code>Array.reduce</code>; the difference&#13;
is that it starts reducing from the end of the array rather than the&#13;
beginning.</p>&#13;
</div>&#13;
&#13;
<p>Sometimes we need to transform an array into an object. The following&#13;
example uses <code>reduce</code> to transform an array that contains colors into a&#13;
hash:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"xekare"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"rad red"</code><code class="p">,</code>&#13;
    <code class="nx">rating</code><code class="o">:</code> <code class="mi">3</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"jbwsof"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"big blue"</code><code class="p">,</code>&#13;
    <code class="nx">rating</code><code class="o">:</code> <code class="mi">2</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"prigbj"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"grizzly grey"</code><code class="p">,</code>&#13;
    <code class="nx">rating</code><code class="o">:</code> <code class="mi">5</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"ryhbhsl"</code><code class="p">,</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"banana"</code><code class="p">,</code>&#13;
    <code class="nx">rating</code><code class="o">:</code> <code class="mi">1</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">hashColors</code> <code class="o">=</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">hash</code><code class="p">,</code> <code class="p">{</code> <code class="nx">id</code><code class="p">,</code> <code class="nx">title</code><code class="p">,</code> <code class="nx">rating</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">hash</code><code class="p">[</code><code class="nx">id</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">title</code><code class="p">,</code> <code class="nx">rating</code> <code class="p">};</code>&#13;
  <code class="k">return</code> <code class="nx">hash</code><code class="p">;</code>&#13;
<code class="p">},</code> <code class="p">{});</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">hashColors</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// {</code>&#13;
<code class="c1">// "xekare": {</code>&#13;
<code class="c1">// title:"rad red",</code>&#13;
<code class="c1">// rating:3</code>&#13;
<code class="c1">// },</code>&#13;
<code class="c1">// "jbwsof": {</code>&#13;
<code class="c1">// title:"big blue",</code>&#13;
<code class="c1">// rating:2</code>&#13;
<code class="c1">// },</code>&#13;
<code class="c1">// "prigbj": {</code>&#13;
<code class="c1">// title:"grizzly grey",</code>&#13;
<code class="c1">// rating:5</code>&#13;
<code class="c1">// },</code>&#13;
<code class="c1">// "ryhbhsl": {</code>&#13;
<code class="c1">// title:"banana",</code>&#13;
<code class="c1">// rating:1</code>&#13;
<code class="c1">// }</code>&#13;
<code class="c1">// }</code></pre>&#13;
&#13;
<p>In this example, the second argument sent to the <code>reduce</code> function is an&#13;
empty object. This is our initial value for the hash. During each&#13;
iteration, the callback function adds a new key to the hash using&#13;
bracket notation and sets the value for that key to the <code>id</code> field of&#13;
the array. <code>Array.reduce</code> can be used in this way to reduce an array to&#13;
a single value—in this case, an object.</p>&#13;
&#13;
<p>We can even transform arrays into completely different arrays using&#13;
<code>reduce</code>. Consider reducing an array with multiple instances of the&#13;
same value to an array of unique values. The <code>reduce</code> method can be used&#13;
to accomplish this task:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">colors</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"red"</code><code class="p">,</code> <code class="s2">"red"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">,</code> <code class="s2">"blue"</code><code class="p">,</code> <code class="s2">"green"</code><code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">uniqueColors</code> <code class="o">=</code> <code class="nx">colors</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code>&#13;
  <code class="p">(</code><code class="nx">unique</code><code class="p">,</code> <code class="nx">color</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
    <code class="nx">unique</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">color</code><code class="p">)</code> <code class="o">!==</code> <code class="o">-</code><code class="mi">1</code> <code class="o">?</code> <code class="nx">unique</code> <code class="o">:</code> <code class="p">[...</code><code class="nx">unique</code><code class="p">,</code> <code class="nx">color</code><code class="p">],</code>&#13;
  <code class="p">[]</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">uniqueColors</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// ["red", "green", "blue"]</code></pre>&#13;
&#13;
<p>In this example, the <code>colors</code> array is reduced to an array of distinct&#13;
values. The second argument sent to the <code>reduce</code> function is an empty&#13;
array. This will be the initial value for <code>distinct</code>. When the&#13;
<code>distinct</code> array does not already contain a specific color, it will be&#13;
added. Otherwise, it will be skipped, and the current <code>distinct</code> array&#13;
will be returned.</p>&#13;
&#13;
<p><code>map</code> and <code>reduce</code> are the main weapons of any functional programmer,&#13;
and JavaScript is no exception. If you want to be a proficient&#13;
JavaScript engineer, then you must master these functions. The ability&#13;
to create one dataset from another is a required skill and is useful for&#13;
any type of programming paradigm.<a data-primary="" data-startref="dtrans03" data-type="indexterm" id="idm45901649393112"/><a data-primary="" data-startref="FPcoretrans03" data-type="indexterm" id="idm45901649392136"/><a data-primary="" data-startref="reduceright03" data-type="indexterm" id="idm45901649391192"/><a data-primary="" data-startref="reduce03" data-type="indexterm" id="idm45901649390248"/><a data-primary="" data-startref="mapred03" data-type="indexterm" id="idm45901649389304"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Higher-Order Functions" data-type="sect2"><div class="sect2" id="higher-order-functions">&#13;
<h2>Higher-Order Functions</h2>&#13;
&#13;
<p>The<a data-primary="functional programming" data-secondary="core concepts" data-tertiary="higher-order functions" data-type="indexterm" id="idm45901649387464"/><a data-primary="higher-order functions" data-type="indexterm" id="idm45901649386184"/><a data-primary="functions" data-secondary="higher-order" data-type="indexterm" id="idm45901649385512"/> use of <em>higher-order functions</em> is also essential to functional&#13;
programming. We’ve already mentioned higher-order functions, and we’ve&#13;
even used a few in this chapter. Higher-order functions are functions&#13;
that can manipulate other functions. They can take functions in as&#13;
arguments or return functions or both.</p>&#13;
&#13;
<p>The first category of higher-order functions are functions that expect&#13;
other functions as arguments. <code>Array.map</code>, <code>Array.filter</code>, and&#13;
<code>Array.reduce</code> all take functions as arguments. They are higher-order&#13;
functions.</p>&#13;
&#13;
<p>Let’s take a look at how we can implement a higher-order function. In&#13;
the following example, we create an <code>invokeIf</code> callback function that will test a condition and invoke a callback function when it’s true and another callback function when the condition is false:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">invokeIf</code> <code class="o">=</code> <code class="p">(</code><code class="nx">condition</code><code class="p">,</code> <code class="nx">fnTrue</code><code class="p">,</code> <code class="nx">fnFalse</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">condition</code> <code class="o">?</code> <code class="nx">fnTrue</code><code class="p">()</code> <code class="o">:</code> <code class="nx">fnFalse</code><code class="p">();</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">showWelcome</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Welcome!!!"</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">showUnauthorized</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Unauthorized!!!"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">invokeIf</code><code class="p">(</code><code class="kc">true</code><code class="p">,</code> <code class="nx">showWelcome</code><code class="p">,</code> <code class="nx">showUnauthorized</code><code class="p">);</code> <code class="c1">// "Welcome!!!"</code>&#13;
<code class="nx">invokeIf</code><code class="p">(</code><code class="kc">false</code><code class="p">,</code> <code class="nx">showWelcome</code><code class="p">,</code> <code class="nx">showUnauthorized</code><code class="p">);</code> <code class="c1">// "Unauthorized!!!"</code></pre>&#13;
&#13;
<p><code>invokeIf</code> expects two functions: one for true and one for false. This&#13;
is demonstrated by sending both <code>showWelcome</code> and <code>showUnauthorized</code> to&#13;
<code>invokeIf</code>. When the condition is true, <code>showWelcome</code> is invoked. When&#13;
it’s false, <code>showUnauthorized</code> is invoked.</p>&#13;
&#13;
<p>Higher-order functions that return other functions can help us handle&#13;
the complexities associated with asynchronicity in JavaScript. They can&#13;
help us create functions that can be used or reused at our convenience.</p>&#13;
&#13;
<p><em>Currying</em> is a functional technique that involves the use of&#13;
higher-order functions.</p>&#13;
&#13;
<p>The following is an example of currying. The <code>userLogs</code> function hangs&#13;
on to some information (the username) and returns a function that can be&#13;
used and reused when the rest of the information (the message) is made&#13;
available. In this example, log <span class="keep-together">messages</span> will all be prepended with the&#13;
associated username. Notice that we’re using the <code>getFakeMembers</code>&#13;
function that returns a promise from <a data-type="xref" href="ch02.html#javascript-for-react">Chapter 2</a>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">userLogs</code> <code class="o">=</code> <code class="nx">userName</code> <code class="o">=&gt;</code> <code class="nx">message</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">userName</code><code class="si">}</code><code class="sb"> -&gt; </code><code class="si">${</code><code class="nx">message</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">log</code> <code class="o">=</code> <code class="nx">userLogs</code><code class="p">(</code><code class="s2">"grandpa23"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">log</code><code class="p">(</code><code class="s2">"attempted to load 20 fake members"</code><code class="p">);</code>&#13;
<code class="nx">getFakeMembers</code><code class="p">(</code><code class="mi">20</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code>&#13;
  <code class="nx">members</code> <code class="o">=&gt;</code> <code class="nx">log</code><code class="p">(</code><code class="sb">`successfully loaded </code><code class="si">${</code><code class="nx">members</code><code class="p">.</code><code class="nx">length</code><code class="si">}</code><code class="sb"> members`</code><code class="p">),</code>&#13;
  <code class="nx">error</code> <code class="o">=&gt;</code> <code class="nx">log</code><code class="p">(</code><code class="s2">"encountered an error loading members"</code><code class="p">)</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="c1">// grandpa23 -&gt; attempted to load 20 fake members</code>&#13;
<code class="c1">// grandpa23 -&gt; successfully loaded 20 members</code>&#13;
&#13;
<code class="c1">// grandpa23 -&gt; attempted to load 20 fake members</code>&#13;
<code class="c1">// grandpa23 -&gt; encountered an error loading members</code></pre>&#13;
&#13;
<p><code>userLogs</code> is the higher-order function. The <code>log</code> function is produced&#13;
from <code>userLogs</code>, and every time the <code>log</code> function is used, “grandpa23”&#13;
is prepended to the message.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Recursion" data-type="sect2"><div class="sect2" id="recursion">&#13;
<h2>Recursion</h2>&#13;
&#13;
<p>Recursion<a data-primary="functional programming" data-secondary="core concepts" data-tertiary="recursion" data-type="indexterm" id="FPcorerecur03"/><a data-primary="recursion" data-type="indexterm" id="recurs03"/> is a technique that involves creating functions that recall&#13;
themselves. Often, when faced with a challenge that involves a loop, a&#13;
recursive function can be used instead. Consider the task of counting&#13;
down from 10. We could create a <code>for</code> loop to solve this problem, or we&#13;
could alternatively use a recursive function. In this example,&#13;
<code>countdown</code> is the recursive function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">countdown</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="nx">value</code> <code class="o">&gt;</code> <code class="mi">0</code> <code class="o">?</code> <code class="nx">countdown</code><code class="p">(</code><code class="nx">value</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">fn</code><code class="p">)</code> <code class="o">:</code> <code class="nx">value</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">countdown</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="nx">value</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">));</code>&#13;
&#13;
<code class="c1">// 10</code>&#13;
<code class="c1">// 9</code>&#13;
<code class="c1">// 8</code>&#13;
<code class="c1">// 7</code>&#13;
<code class="c1">// 6</code>&#13;
<code class="c1">// 5</code>&#13;
<code class="c1">// 4</code>&#13;
<code class="c1">// 3</code>&#13;
<code class="c1">// 2</code>&#13;
<code class="c1">// 1</code>&#13;
<code class="c1">// 0</code></pre>&#13;
&#13;
<p><code>countdown</code> expects a number and a function as arguments. In this&#13;
example, it’s invoked with a value of <code>10</code> and a callback function.&#13;
When <code>countdown</code> is invoked, the callback is invoked, which logs the&#13;
current value. Next, <code>countdown</code> checks the value to see if it’s&#13;
greater than <code>0</code>. If it is, <code>countdown</code> recalls itself with a&#13;
decremented value. Eventually, the value will be <code>0</code>, and <code>countdown</code>&#13;
will return that value all the way back up the call stack.</p>&#13;
&#13;
<p>Recursion is a pattern that works particularly well with asynchronous&#13;
processes. Functions can recall themselves when they’re ready, like when&#13;
the data is available or when a timer has finished.</p>&#13;
&#13;
<p>The <code>countdown</code> function can be modified to count down with a delay.&#13;
This modified version of the <code>countdown</code> function can be used to create&#13;
a countdown clock:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">countdown</code> <code class="o">=</code> <code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">fn</code><code class="p">,</code> <code class="nx">delay</code> <code class="o">=</code> <code class="mi">1000</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">fn</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="nx">value</code> <code class="o">&gt;</code> <code class="mi">0</code>&#13;
    <code class="o">?</code> <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">countdown</code><code class="p">(</code><code class="nx">value</code> <code class="o">-</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">fn</code><code class="p">,</code> <code class="nx">delay</code><code class="p">),</code> <code class="nx">delay</code><code class="p">)</code>&#13;
    <code class="o">:</code> <code class="nx">value</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">log</code> <code class="o">=</code> <code class="nx">value</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
<code class="nx">countdown</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="nx">log</code><code class="p">);</code></pre>&#13;
&#13;
<p>In this example, we create a 10-second countdown by initially invoking&#13;
<code>countdown</code> once with the number <code>10</code> in a function that logs the&#13;
countdown. Instead of recalling itself right away, the <code>countdown</code>&#13;
function waits one second before recalling itself, thus creating a&#13;
clock.</p>&#13;
&#13;
<p>Recursion is a good technique for searching data structures. You can use&#13;
recursion to iterate through subfolders until a folder that contains&#13;
only files is identified. You can also use recursion to iterate though&#13;
the HTML DOM until you find an element that does not contain any&#13;
children. In the next example, we’ll use recursion to iterate deeply&#13;
into an object to retrieve a nested value:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">dan</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s2">"person"</code><code class="p">,</code>&#13;
  <code class="nx">data</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">gender</code><code class="o">:</code> <code class="s2">"male"</code><code class="p">,</code>&#13;
    <code class="nx">info</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="mi">22</code><code class="p">,</code>&#13;
      <code class="nx">fullname</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">first</code><code class="o">:</code> <code class="s2">"Dan"</code><code class="p">,</code>&#13;
        <code class="nx">last</code><code class="o">:</code> <code class="s2">"Deacon"</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">deepPick</code><code class="p">(</code><code class="s2">"type"</code><code class="p">,</code> <code class="nx">dan</code><code class="p">);</code> <code class="c1">// "person"</code>&#13;
<code class="nx">deepPick</code><code class="p">(</code><code class="s2">"data.info.fullname.first"</code><code class="p">,</code> <code class="nx">dan</code><code class="p">);</code> <code class="c1">// "Dan"</code></pre>&#13;
&#13;
<p><code>deepPick</code> can be used to access <code>Dan</code>’s type, stored immediately in the&#13;
first object, or to dig down into nested objects to locate <code>Dan</code>’s first&#13;
name. Sending a string that uses dot notation, we can specify where to&#13;
locate values that are nested deep within an object:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">deepPick</code> <code class="o">=</code> <code class="p">(</code><code class="nx">fields</code><code class="p">,</code> <code class="nx">object</code> <code class="o">=</code> <code class="p">{})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">remaining</code><code class="p">]</code> <code class="o">=</code> <code class="nx">fields</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">"."</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="nx">remaining</code><code class="p">.</code><code class="nx">length</code>&#13;
    <code class="o">?</code> <code class="nx">deepPick</code><code class="p">(</code><code class="nx">remaining</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"."</code><code class="p">),</code> <code class="nx">object</code><code class="p">[</code><code class="nx">first</code><code class="p">])</code>&#13;
    <code class="o">:</code> <code class="nx">object</code><code class="p">[</code><code class="nx">first</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The <code>deepPick</code> function is either going to return a value or recall&#13;
itself until it eventually returns a value. First, this function splits&#13;
the dot-notated fields string into an array and uses array destructuring&#13;
to separate the first value from the remaining values. If there are&#13;
remaining values, <code>deepPick</code> recalls itself with slightly different&#13;
data, allowing it to dig one level deeper.</p>&#13;
&#13;
<p>This function continues to call itself until the fields string no longer&#13;
contains dots, meaning that there are no more remaining fields. In this&#13;
sample, you can see how the values for <code>first</code>, <code>remaining</code>, and&#13;
<code>object[first]</code> change as <code>deepPick</code> iterates through:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">deepPick</code><code class="p">(</code><code class="s2">"data.info.fullname.first"</code><code class="p">,</code> <code class="nx">dan</code><code class="p">);</code> <code class="c1">// "Dan"</code>&#13;
&#13;
<code class="c1">// First Iteration</code>&#13;
<code class="c1">// first = "data"</code>&#13;
<code class="c1">// remaining.join(".") = "info.fullname.first"</code>&#13;
<code class="c1">// object[first] = { gender: "male", {info} }</code>&#13;
&#13;
<code class="c1">// Second Iteration</code>&#13;
<code class="c1">// first = "info"</code>&#13;
<code class="c1">// remaining.join(".") = "fullname.first"</code>&#13;
<code class="c1">// object[first] = {id: 22, {fullname}}</code>&#13;
&#13;
<code class="c1">// Third Iteration</code>&#13;
<code class="c1">// first = "fullname"</code>&#13;
<code class="c1">// remaining.join("." = "first"</code>&#13;
<code class="c1">// object[first] = {first: "Dan", last: "Deacon" }</code>&#13;
&#13;
<code class="c1">// Finally...</code>&#13;
<code class="c1">// first = "first"</code>&#13;
<code class="c1">// remaining.length = 0</code>&#13;
<code class="c1">// object[first] = "Deacon"</code></pre>&#13;
&#13;
<p>Recursion is a powerful functional technique that’s fun to implement.<a data-primary="" data-startref="recurs03" data-type="indexterm" id="idm45901648733944"/><a data-primary="" data-startref="FPcorerecur03" data-type="indexterm" id="idm45901648714120"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Composition" data-type="sect2"><div class="sect2" id="composition">&#13;
<h2>Composition</h2>&#13;
&#13;
<p>Functional<a data-primary="functional programming" data-secondary="core concepts" data-tertiary="composition" data-type="indexterm" id="FPcccompo03"/><a data-primary="composition" data-type="indexterm" id="comp03"/> programs break up their logic into small, pure functions that&#13;
are focused on specific tasks. Eventually, you’ll need to put these&#13;
smaller functions together. Specifically, you may need to combine them,&#13;
call them in series or parallel, or compose them into larger functions&#13;
until you eventually have an application.</p>&#13;
&#13;
<p>When it comes to composition, there are a number of different&#13;
implementations, patterns, and techniques. One that you may be familiar&#13;
with is chaining. In JavaScript, functions can be chained together using&#13;
dot notation to act on the return value of the previous function.</p>&#13;
&#13;
<p>Strings have a replace method. The replace method returns a template&#13;
string, which will also have a replace method. Therefore, we can chain&#13;
together replace methods with dot notation to transform a string:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">template</code> <code class="o">=</code> <code class="s2">"hh:mm:ss tt"</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">clockTime</code> <code class="o">=</code> <code class="nx">template</code>&#13;
  <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"hh"</code><code class="p">,</code> <code class="s2">"03"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"mm"</code><code class="p">,</code> <code class="s2">"33"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"ss"</code><code class="p">,</code> <code class="s2">"33"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"tt"</code><code class="p">,</code> <code class="s2">"PM"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">clockTime</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// "03:33:33 PM"</code></pre>&#13;
&#13;
<p>In this example, the template is a string. By chaining replace methods&#13;
to the end of the template string, we can replace hours, minutes,&#13;
seconds, and time of day in the string with new values. The template&#13;
itself remains intact and can be reused to create more clock time&#13;
displays.</p>&#13;
&#13;
<p>The <code>both</code> function is one function that pipes a value through two&#13;
separate functions. The output of civilian hours becomes the input&#13;
for <code>appendAMPM</code>, and we can change a date using both of these functions&#13;
combined into one:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">both</code> <code class="o">=</code> <code class="nx">date</code> <code class="o">=&gt;</code> <code class="nx">appendAMPM</code><code class="p">(</code><code class="nx">civilianHours</code><code class="p">(</code><code class="nx">date</code><code class="p">));</code></pre>&#13;
&#13;
<p>However, this syntax is hard to comprehend and therefore tough to&#13;
maintain or scale. What happens when we need to send a value through 20&#13;
different functions?</p>&#13;
&#13;
<p>A more elegant approach is to create a higher-order function we can use&#13;
to compose functions into larger functions:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">both</code> <code class="o">=</code> <code class="nx">compose</code><code class="p">(</code>&#13;
  <code class="nx">civilianHours</code><code class="p">,</code>&#13;
  <code class="nx">appendAMPM</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="nx">both</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">());</code></pre>&#13;
&#13;
<p>This approach looks much better. It’s easy to scale because we can add&#13;
more functions at any point. This approach also makes it easy to change&#13;
the order of the composed functions.</p>&#13;
&#13;
<p>The <code>compose</code> function is a higher-order function. It takes functions as&#13;
arguments and returns a single value:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">compose</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">fns</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">arg</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">fns</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">composed</code><code class="p">,</code> <code class="nx">f</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">f</code><code class="p">(</code><code class="nx">composed</code><code class="p">),</code> <code class="nx">arg</code><code class="p">);</code></pre>&#13;
&#13;
<p><code>compose</code> takes in functions as arguments and returns a single function.&#13;
In this implementation, the spread operator is used to turn those&#13;
function arguments into an array called <code>fns</code>. A function is then returned&#13;
that expects one argument, <code>arg</code>. When this function is invoked, the <code>fns</code>&#13;
array is piped starting with the argument we want to send through the&#13;
function. The argument becomes the initial value for <code>compose</code>, then&#13;
each iteration of the reduced callback returns. Notice that the callback&#13;
takes two arguments: composed and a function <code>f</code>. Each function is invoked&#13;
with <code>compose</code>, which is the result of the previous function’s output.&#13;
Eventually, the last function will be invoked and the last result&#13;
returned.</p>&#13;
&#13;
<p>This is a simple example of a <code>compose</code> function designed to illustrate&#13;
composition techniques. This function becomes more complex when it’s&#13;
time to handle more than one argument or deal with arguments that are&#13;
not functions.<a data-primary="" data-startref="comp03" data-type="indexterm" id="idm45901648478792"/><a data-primary="" data-startref="FPcccompo03" data-type="indexterm" id="idm45901648477816"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Putting It All Together" data-type="sect2"><div class="sect2" id="putting-it-all-together">&#13;
<h2>Putting It All Together</h2>&#13;
&#13;
<p>Now<a data-primary="functional programming" data-secondary="core concepts" data-tertiary="ticking clock program example" data-type="indexterm" id="FPccclock03"/> that we’ve been introduced to the core concepts of functional&#13;
programming, let’s put those concepts to work for us and build a small&#13;
JavaScript application.</p>&#13;
&#13;
<p>Our challenge is to build a ticking clock. The clock needs to display&#13;
hours, minutes, seconds, and time of day in civilian time. Each field&#13;
must always have double digits, meaning leading zeros need to be applied&#13;
to single-digit values like 1 or 2. The clock must also tick and change&#13;
the display every second.</p>&#13;
&#13;
<p>First, let’s review an imperative solution for the clock:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Log Clock Time every Second</code>&#13;
<code class="nx">setInterval</code><code class="p">(</code><code class="nx">logClockTime</code><code class="p">,</code> <code class="mi">1000</code><code class="p">);</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">logClockTime</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="c1">// Get Time string as civilian time</code>&#13;
  <code class="kd">let</code> <code class="nx">time</code> <code class="o">=</code> <code class="nx">getClockTime</code><code class="p">();</code>&#13;
&#13;
  <code class="c1">// Clear the Console and log the time</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">clear</code><code class="p">();</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">time</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">getClockTime</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="c1">// Get the Current Time</code>&#13;
  <code class="kd">let</code> <code class="nx">date</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">();</code>&#13;
  <code class="kd">let</code> <code class="nx">time</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// Serialize clock time</code>&#13;
  <code class="kd">let</code> <code class="nx">time</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">hours</code><code class="o">:</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getHours</code><code class="p">(),</code>&#13;
    <code class="nx">minutes</code><code class="o">:</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getMinutes</code><code class="p">(),</code>&#13;
    <code class="nx">seconds</code><code class="o">:</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getSeconds</code><code class="p">(),</code>&#13;
    <code class="nx">ampm</code><code class="o">:</code> <code class="s2">"AM"</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="c1">// Convert to civilian time</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">hours</code> <code class="o">==</code> <code class="mi">12</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">time</code><code class="p">.</code><code class="nx">ampm</code> <code class="o">=</code> <code class="s2">"PM"</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">hours</code> <code class="o">&gt;</code> <code class="mi">12</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">time</code><code class="p">.</code><code class="nx">ampm</code> <code class="o">=</code> <code class="s2">"PM"</code><code class="p">;</code>&#13;
    <code class="nx">time</code><code class="p">.</code><code class="nx">hours</code> <code class="o">-=</code> <code class="mi">12</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// Prepend a 0 on the hours to make double digits</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">hours</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">time</code><code class="p">.</code><code class="nx">hours</code> <code class="o">=</code> <code class="s2">"0"</code> <code class="o">+</code> <code class="nx">time</code><code class="p">.</code><code class="nx">hours</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// prepend a 0 on the minutes to make double digits</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">minutes</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">time</code><code class="p">.</code><code class="nx">minutes</code> <code class="o">=</code> <code class="s2">"0"</code> <code class="o">+</code> <code class="nx">time</code><code class="p">.</code><code class="nx">minutes</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// prepend a 0 on the seconds to make double digits</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">seconds</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">time</code><code class="p">.</code><code class="nx">seconds</code> <code class="o">=</code> <code class="s2">"0"</code> <code class="o">+</code> <code class="nx">time</code><code class="p">.</code><code class="nx">seconds</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// Format the clock time as a string "hh:mm:ss tt"</code>&#13;
  <code class="k">return</code> <code class="nx">time</code><code class="p">.</code><code class="nx">hours</code> <code class="o">+</code> <code class="s2">":"</code> <code class="o">+</code> <code class="nx">time</code><code class="p">.</code><code class="nx">minutes</code> <code class="o">+</code> <code class="s2">":"</code> <code class="o">+</code> <code class="nx">time</code><code class="p">.</code><code class="nx">seconds</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="nx">time</code><code class="p">.</code><code class="nx">ampm</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This solution works, and the comments&#13;
help us understand what’s happening. However, these functions are large&#13;
and complicated. Each function does a lot. They’re hard to comprehend,&#13;
they require comments, and they’re tough to maintain. Let’s see how a&#13;
functional approach can produce a more scalable application.</p>&#13;
&#13;
<p>Our goal will be to break the application logic up into smaller parts:&#13;
functions. Each function will be focused on a single task, and we’ll&#13;
compose them into larger functions that we can use to create the clock.</p>&#13;
&#13;
<p>First, let’s create some functions that give us values and manage the&#13;
console. We’ll need a function that gives us one second, a function that&#13;
gives us the current time, and a couple of functions that will log&#13;
messages on a console and clear the console. In functional programs, we&#13;
should use functions over values wherever possible. We’ll invoke the&#13;
function to obtain the value when needed:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">oneSecond</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">1000</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">getCurrentTime</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">();</code>&#13;
<code class="kr">const</code> <code class="nx">clear</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">clear</code><code class="p">();</code>&#13;
<code class="kr">const</code> <code class="nx">log</code> <code class="o">=</code> <code class="nx">message</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code></pre>&#13;
&#13;
<p>Next, we’ll need some functions for transforming data. These three&#13;
functions will be used to mutate the <code>Date</code> object into an object that&#13;
can be used for our clock:</p>&#13;
<dl>&#13;
<dt><code>serializeClockTime</code></dt>&#13;
<dd>&#13;
<p>Takes a date object and returns an object for&#13;
clock time that contains hours, minutes, and seconds.</p>&#13;
</dd>&#13;
<dt><code>civilianHours</code></dt>&#13;
<dd>&#13;
<p>Takes the clock time object and returns an object&#13;
where hours are converted to civilian time. For example: 1300 becomes&#13;
1:00.</p>&#13;
</dd>&#13;
<dt><code>appendAMPM</code></dt>&#13;
<dd>&#13;
<p>Takes the clock time object and appends time of day (AM&#13;
or PM) to that object.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">serializeClockTime</code> <code class="o">=</code> <code class="nx">date</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
  <code class="nx">hours</code><code class="o">:</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getHours</code><code class="p">(),</code>&#13;
  <code class="nx">minutes</code><code class="o">:</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getMinutes</code><code class="p">(),</code>&#13;
  <code class="nx">seconds</code><code class="o">:</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getSeconds</code><code class="p">()</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">civilianHours</code> <code class="o">=</code> <code class="nx">clockTime</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
  <code class="p">...</code><code class="nx">clockTime</code><code class="p">,</code>&#13;
  <code class="nx">hours</code><code class="o">:</code> <code class="nx">clockTime</code><code class="p">.</code><code class="nx">hours</code> <code class="o">&gt;</code> <code class="mi">12</code> <code class="o">?</code> <code class="nx">clockTime</code><code class="p">.</code><code class="nx">hours</code> <code class="o">-</code> <code class="mi">12</code> <code class="o">:</code> <code class="nx">clockTime</code><code class="p">.</code><code class="nx">hours</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">appendAMPM</code> <code class="o">=</code> <code class="nx">clockTime</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
  <code class="p">...</code><code class="nx">clockTime</code><code class="p">,</code>&#13;
  <code class="nx">ampm</code><code class="o">:</code> <code class="nx">clockTime</code><code class="p">.</code><code class="nx">hours</code> <code class="o">&gt;=</code> <code class="mi">12</code> <code class="o">?</code> <code class="s2">"PM"</code> <code class="o">:</code> <code class="s2">"AM"</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>These three functions are used to transform data without changing the&#13;
original. They treat their arguments as immutable objects.</p>&#13;
&#13;
<p>Next, we’ll need a few higher-order functions:</p>&#13;
<dl>&#13;
<dt><code>display</code></dt>&#13;
<dd>&#13;
<p>Takes a target function and returns a function that will&#13;
send a time to the target. In this example, the target will be&#13;
<code>console.log</code>.</p>&#13;
</dd>&#13;
<dt><code>formatClock</code></dt>&#13;
<dd>&#13;
<p>Takes a template string and uses it to return clock&#13;
time formatted based on the criteria from the string. In this example,&#13;
the template is “hh:mm:ss tt”. From there, <code>formatClock</code> will replace the&#13;
placeholders with hours, minutes, seconds, and time of day.</p>&#13;
</dd>&#13;
<dt><code>prependZero</code></dt>&#13;
<dd>&#13;
<p>Takes an object’s key as an argument and prepends a&#13;
zero to the value stored under that object’s key. It takes in a key to a&#13;
specific field and prepends values with a zero if the value is less than&#13;
10.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">display</code> <code class="o">=</code> <code class="nx">target</code> <code class="o">=&gt;</code> <code class="nx">time</code> <code class="o">=&gt;</code> <code class="nx">target</code><code class="p">(</code><code class="nx">time</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">formatClock</code> <code class="o">=</code> <code class="nx">format</code> <code class="o">=&gt;</code> <code class="nx">time</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">format</code>&#13;
    <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"hh"</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">hours</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"mm"</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">minutes</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"ss"</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">seconds</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"tt"</code><code class="p">,</code> <code class="nx">time</code><code class="p">.</code><code class="nx">ampm</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">prependZero</code> <code class="o">=</code> <code class="nx">key</code> <code class="o">=&gt;</code> <code class="nx">clockTime</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
  <code class="p">...</code><code class="nx">clockTime</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="nx">clockTime</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">&lt;</code> <code class="mi">10</code> <code class="o">?</code> <code class="s2">"0"</code> <code class="o">+</code> <code class="nx">clockTime</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">:</code> <code class="nx">clockTime</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>These higher-order functions will be invoked to create the functions&#13;
that will be reused to format the clock time for every tick. Both <code>formatClock</code> and <code>prependZero</code> will be invoked once, initially setting up the&#13;
required template or key. The inner functions they return will be&#13;
invoked once every second to format the time for display.</p>&#13;
&#13;
<p>Now that we have all of the functions required to build a ticking clock,&#13;
we’ll need to compose them. We’ll use the <code>compose</code> function that we&#13;
defined in the last section to handle composition:</p>&#13;
<dl>&#13;
<dt><code>convertToCivilianTime</code></dt>&#13;
<dd>&#13;
<p>A single function that takes clock time&#13;
as an argument and transforms it into civilian time by using both&#13;
civilian hours.</p>&#13;
</dd>&#13;
<dt><code>doubleDigits</code></dt>&#13;
<dd>&#13;
<p>A single function that takes civilian clock time&#13;
and makes sure the hours, minutes, and seconds display double digits by&#13;
prepending zeros where needed.</p>&#13;
</dd>&#13;
<dt><code>startTicking</code></dt>&#13;
<dd>&#13;
<p>Starts the clock by setting an interval that&#13;
invokes a callback every second. The callback is composed using all our functions. Every second the console is cleared, <code>currentTime</code> is&#13;
obtained, converted, civilianized, formatted, and displayed.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">convertToCivilianTime</code> <code class="o">=</code> <code class="nx">clockTime</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">compose</code><code class="p">(</code>&#13;
    <code class="nx">appendAMPM</code><code class="p">,</code>&#13;
    <code class="nx">civilianHours</code>&#13;
  <code class="p">)(</code><code class="nx">clockTime</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">doubleDigits</code> <code class="o">=</code> <code class="nx">civilianTime</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">compose</code><code class="p">(</code>&#13;
    <code class="nx">prependZero</code><code class="p">(</code><code class="s2">"hours"</code><code class="p">),</code>&#13;
    <code class="nx">prependZero</code><code class="p">(</code><code class="s2">"minutes"</code><code class="p">),</code>&#13;
    <code class="nx">prependZero</code><code class="p">(</code><code class="s2">"seconds"</code><code class="p">)</code>&#13;
  <code class="p">)(</code><code class="nx">civilianTime</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">startTicking</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">setInterval</code><code class="p">(</code>&#13;
    <code class="nx">compose</code><code class="p">(</code>&#13;
      <code class="nx">clear</code><code class="p">,</code>&#13;
      <code class="nx">getCurrentTime</code><code class="p">,</code>&#13;
      <code class="nx">serializeClockTime</code><code class="p">,</code>&#13;
      <code class="nx">convertToCivilianTime</code><code class="p">,</code>&#13;
      <code class="nx">doubleDigits</code><code class="p">,</code>&#13;
      <code class="nx">formatClock</code><code class="p">(</code><code class="s2">"hh:mm:ss tt"</code><code class="p">),</code>&#13;
      <code class="nx">display</code><code class="p">(</code><code class="nx">log</code><code class="p">)</code>&#13;
    <code class="p">),</code>&#13;
    <code class="nx">oneSecond</code><code class="p">()</code>&#13;
  <code class="p">);</code>&#13;
&#13;
<code class="nx">startTicking</code><code class="p">();</code></pre>&#13;
&#13;
<p>This<a data-primary="functional programming" data-secondary="imperative versus declarative programming" data-type="indexterm" id="idm45901647810184"/><a data-primary="declarative programming" data-type="indexterm" id="idm45901647729784"/> declarative version of the clock achieves the same results as the&#13;
imperative version. However, there quite a few benefits to this&#13;
approach. First, all of these functions are easily testable and&#13;
reusable. They can be used in future clocks or other digital displays.&#13;
Also, this program is easily scalable. There are no side effects. There&#13;
are no global variables outside of functions themselves. There could&#13;
still be bugs, but they’ll be easier to find.<a data-primary="" data-startref="FPccclock03" data-type="indexterm" id="idm45901647728552"/></p>&#13;
&#13;
<p>In this chapter, we’ve introduced functional programming principles.&#13;
Throughout the book when we discuss best practices in React, we’ll&#13;
continue to demonstrate how many React concepts are based in functional&#13;
techniques. In the next chapter, we’ll dive into React officially with&#13;
an improved understanding of the principles that guided its development.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45901652156344"><sup><a href="ch03.html#idm45901652156344-marker">1</a></sup> Dana S. Scott, <a href="https://oreil.ly/k0EpX">“λ-Calculus: Then &amp; Now”</a>.</p></div></div></section></body></html>