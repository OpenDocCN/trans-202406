- en: Chapter 2\. The Docker Landscape
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. Docker 的概览
- en: Before you dive into configuring and installing Docker, a broad survey is in
    order to explain what Docker is and what it brings to the table. It is a powerful
    technology but not a tremendously complicated one at its core. In this chapter,
    we’ll cover the generalities of how Docker and Linux containers work, what makes
    them powerful, and some of the reasons you might use them. If you’re reading this,
    you probably have your reasons to use containers, but it never hurts to augment
    your understanding before you jump in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在你深入配置和安装 Docker 之前，需要进行广泛的调研来解释 Docker 的含义及其带来的益处。它是一项强大的技术，但在其核心并不是非常复杂。在这一章中，我们将涵盖
    Docker 和 Linux 容器的工作原理，它们的强大之处，以及你可能使用它们的一些理由。如果你正在阅读本书，你可能已经有了使用容器的理由，但在你深入之前增加对其的理解从来不会有什么坏处。
- en: Don’t worry—this chapter should not hold you up for too long. In the next chapter,
    we’ll dive right into getting Docker installed and running on your system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心 —— 这一章不会占用你太长时间。在下一章中，我们将直接开始安装并在你的系统上运行 Docker。
- en: Process Simplification
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程简化
- en: 'Because Docker is a piece of software, it may not be obvious that it can also
    have a big positive impact on company and team processes if it is adopted and
    implemented well. So, let’s dig in and see how Docker and Linux containers can
    simplify both workflows and communication. This usually starts with the deployment
    story. Traditionally, the cycle of getting an application to production often
    looks something like the following (illustrated in [Figure 2-1](#figure2-1)):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Docker 是一款软件，也许不明显的是，如果它被采纳和实施得当，它也可能对公司和团队的流程产生重大积极影响。所以，让我们深入了解一下 Docker
    和 Linux 容器如何简化工作流程和沟通。通常这从部署的故事开始。传统上，将一个应用程序部署到生产环境的周期通常看起来像下面这样（见 [图 2-1](#figure2-1)）：
- en: Application developers request resources from operations engineers.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序开发者从运维工程师那里请求资源。
- en: Resources are provisioned and handed over to developers.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源被配置并交给开发者。
- en: Developers script and tool their deployment.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者通过脚本和工具进行部署。
- en: Operations engineers and developers tweak the deployment repeatedly.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运维工程师和开发者反复调整部署。
- en: Additional application dependencies are discovered by developers.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发者会发现额外的应用程序依赖关系。
- en: Operations engineers work to install the additional requirements.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运维工程师致力于安装额外的要求。
- en: Loop over steps 4 through 6 *n* more times.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复执行步骤 4 至 6 *n* 次。
- en: The application is deployed.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已被部署。
- en: '![A Non-Docker deployment workflow](assets/dur3_0201.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![一个非 Docker 的部署工作流程](assets/dur3_0201.png)'
- en: Figure 2-1\. A traditional deployment workflow (without Docker)
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 传统的部署工作流程（没有 Docker）
- en: Our experience has shown that when you are following traditional processes,
    deploying a brand-new application into production can take the better part of
    a week for a complex new system. That’s not very productive, and even though DevOps
    practices work to alleviate many of the barriers, it often still requires a lot
    of effort and communication between teams of people. This process can be both
    technically challenging and expensive, but even worse, it can limit the kinds
    of innovation that development teams will undertake in the future. If deploying
    new software is hard, time-consuming, and dependent on resources from another
    team, then developers may just build everything into the existing application
    in order to avoid suffering the new deployment penalty, or even worse, they may
    simply avoid solving problems that require new development efforts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的经验表明，当你遵循传统流程时，将全新的应用程序部署到生产环境可能需要一周时间，特别是对于一个复杂的新系统。这并不高效，即使 DevOps 实践试图消除许多障碍，它通常仍然需要大量的工作和团队之间的沟通。这个过程既具有技术挑战，也很昂贵，更糟糕的是，它可能会限制开发团队未来承担的创新类型。如果部署新软件很困难、耗时且依赖于其他团队的资源，那么开发者可能会选择将所有内容都集成到现有的应用程序中，以避免承受新部署的惩罚，或者更糟的是，他们可能会避免解决需要新开发工作的问题。
- en: Push-to-deploy systems like [Heroku](https://www.heroku.com) have shown developers
    what the world can look like if you are in control of your application and a majority
    of your dependencies. Talking with developers about deployment will often turn
    up discussions of how easy things are on Heroku or similar systems. If you’re
    an operations engineer, you’ve probably heard complaints about how much slower
    your internal systems are compared with “push-button” solutions like Heroku, which
    are built on top of Linux container technology.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 像[Heroku](https://www.heroku.com)这样的一键部署系统向开发人员展示了如果你能控制应用程序及其大部分依赖关系时世界会是什么样子。与开发人员讨论部署问题时，经常会提到在Heroku或类似系统上事情有多么容易。如果你是一名运维工程师，你可能听到过有关内部系统与“一键式”解决方案如Heroku在速度上有多慢的抱怨，后者建立在Linux容器技术之上。
- en: Heroku is a whole environment, not just a container engine. While Docker doesn’t
    try to be everything that is included in Heroku, it provides a clean separation
    of responsibilities and encapsulation of dependencies, which results in a similar
    boost in productivity. Docker also allows even more fine-grained control than
    Heroku by putting developers in control of everything, down to the exact files
    and package versions that ship alongside their application. Some of the tooling
    and orchestrators that have been built on top of Docker (e.g., Kubernetes, Docker
    Swarm mode, and Mesos) aim to replicate the simplicity of systems like Heroku.
    But even though these platforms wrap more around Docker to provide a more capable
    and complex environment, a simple platform that uses only Docker still provides
    all of the core process benefits without the added complexity of a larger system.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku不仅仅是一个容器引擎，而是一个完整的环境。虽然Docker并不试图包含Heroku中包含的一切，但它提供了责任的清晰分离和依赖关系的封装，这导致了类似的生产力提升。Docker还允许比Heroku更精细的控制，通过让开发人员控制一切，甚至到确切的文件和软件包版本，这些与他们的应用程序一起运行。一些构建在Docker之上的工具和编排器（例如Kubernetes、Docker
    Swarm模式和Mesos）旨在复制像Heroku这样的系统的简单性。尽管这些平台包裹了更多的Docker功能，提供了更强大和复杂的环境，但仅使用Docker的简单平台仍然提供了所有核心流程优势，而不增加更大系统的复杂性。
- en: 'As a company, Docker adopts an approach of “batteries included but removable.”
    This means that its tools come with everything most people need to get the job
    done while still being built from interchangeable parts that can easily be swapped
    in and out to support custom solutions. By using an image repository as the hand-off
    point, Docker allows the responsibility of building the application image to be
    separated from the deployment and operation of the container. What this means
    in practice is that development teams can build their application with all of
    its dependencies, run it in development and test environments, and then just ship
    the exact same bundle of application and dependencies to production. Because those
    bundles all look the same from the outside, operations engineers can then build
    or install standard tooling to deploy and run the applications. The cycle described
    in [Figure 2-1](#figure2-1) then looks somewhat like this (illustrated in [Figure 2-2](#figure2-2)):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家公司，Docker采用了“电池包含但可移除”的方法。这意味着它的工具包含了大多数人完成工作所需的一切，同时仍然是由可互换部件构建而成，可以轻松地替换以支持定制解决方案。通过使用镜像仓库作为交接点，Docker允许将构建应用程序镜像的责任与容器的部署和运行分开。实际上，开发团队可以构建带有所有依赖关系的应用程序，在开发和测试环境中运行它，然后将完全相同的应用程序和依赖项捆绑包装到生产中。由于这些捆绑看起来在外观上都一样，运维工程师可以构建或安装标准工具来部署和运行应用程序。所描述的循环在[图2-1](#figure2-1)中看起来类似于以下内容（在[图2-2](#figure2-2)中有示例）：
- en: Developers build the Docker image and ship it to the registry.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员构建Docker镜像并将其推送到注册表。
- en: Operations engineers provide configuration details to the container and provision
    resources.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运维工程师为容器提供配置细节并配置资源。
- en: Developers trigger deployment.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员触发部署。
- en: '![A Docker deployment workflow](assets/dur3_0202.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![一个Docker部署工作流程](assets/dur3_0202.png)'
- en: Figure 2-2\. A Docker deployment workflow
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-2\. 一个Docker部署工作流程
- en: This is possible because Docker allows all of the dependency issues to be discovered
    during the development and test cycles. By the time the application is ready for
    its first deployment, that work has already been done. And it usually doesn’t
    require as many handoffs between the development and operations teams. In a well-refined
    pipeline, this can completely alleviate the need for anyone other than the development
    team to be involved in the creation and deployment of a new service. That’s a
    lot simpler and saves a lot of time. Better yet, it leads to more robust software
    through testing of the deployment environment before release.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 允许在开发和测试周期中发现所有依赖问题，因此这种方式变为可能。当应用程序准备好进行首次部署时，这项工作已经完成。通常不需要在开发和运维团队之间频繁传递。在一个完善的流水线中，这完全可以消除除开发团队以外的任何人参与新服务的创建和部署的需要。这样做起来更加简单，也节省了很多时间。更好的是，它通过在发布前测试部署环境，带来了更加健壮的软件。
- en: Broad Support and Adoption
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广泛的支持和采用
- en: Docker is well supported, with the majority of the large public clouds offering
    some direct support for it. For example, Docker and Linux containers have been
    used in Amazon Web Services (AWS) via multiple products like Amazon Elastic Container
    Service (Amazon ECS), Amazon Elastic Kubernetes Service (Amazon EKS), Amazon Fargate,
    and Amazon Elastic Beanstalk. Linux containers can also be used on Google App
    Engine (GAE), Google Kubernetes Engine, Red Hat OpenShift, IBM Cloud, Microsoft
    Azure, and many more. At DockerCon 2014, Google’s Eric Brewer announced that Google
    would be supporting Docker as its primary internal container format. Rather than
    just being good PR for these companies, what this meant for the Docker community
    was that a lot of money began to back the stability and success of the Docker
    platform.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 得到了广泛支持，在大多数大型公共云中都提供了一些直接支持。例如，Docker 和 Linux 容器已经通过多个产品在亚马逊网络服务 (AWS)
    中得到了使用，比如亚马逊弹性容器服务 (Amazon ECS)，亚马逊弹性 Kubernetes 服务 (Amazon EKS)，亚马逊 Fargate 和亚马逊弹性
    Beanstalk。Linux 容器也可以在 Google 应用引擎 (GAE)，Google Kubernetes 引擎，红帽 OpenShift，IBM
    Cloud，Microsoft Azure 等平台上使用。在 DockerCon 2014 上，Google 的 Eric Brewer 宣布 Google
    将支持 Docker 作为其主要的内部容器格式。这不仅仅是对这些公司的良好公关，对 Docker 社区来说意味着大量资金开始支持 Docker 平台的稳定性和成功。
- en: Further building its influence, Docker’s image format for Linux containers has
    become the lingua franca among cloud providers, offering the potential for “write
    once, run anywhere” cloud applications. When Docker released its `libswarm` development
    library, an engineer from Orchard demonstrated deploying a Linux container to
    a heterogeneous mix of cloud providers at the same time. This kind of orchestration
    had not been easy before because every cloud provider offered a different API
    or toolset for managing instances, which were usually the smallest item you could
    manage with an API. What was only a promise from Docker in 2014 has since become
    fully mainstream as the largest companies continue to invest in the platform,
    support, and tooling. With most providers offering some form of Docker and Linux
    container orchestration as well as the container runtime itself, Docker is well
    supported for nearly any kind of workload in common production environments. If
    all of your tooling is built around Docker and Linux containers, then your applications
    can be deployed in a cloud-agnostic manner, allowing for new flexibility that
    was not previously possible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步扩大其影响力，Docker 的 Linux 容器镜像格式已成为云服务提供商之间的通用语言，为“一次编写，到处运行”云应用程序提供了潜力。当 Docker
    发布其 `libswarm` 开发库时，Orchard 的一名工程师演示了将 Linux 容器同时部署到不同云服务提供商的异构环境中。在此之前，这种编排并不容易，因为每个云服务提供商都提供了不同的
    API 或工具集来管理实例，而这些实例通常是可以通过 API 管理的最小单位。2014 年 Docker 提出的承诺现在已经完全成为主流，因为大公司继续在平台、支持和工具上投入资金。由于大多数提供商在容器编排以及容器运行时本身方面都提供了某种形式的
    Docker 和 Linux 容器支持，因此 Docker 在常见生产环境中几乎可以支持任何类型的工作负载。如果您所有的工具都围绕 Docker 和 Linux
    容器构建，那么您的应用程序可以以与云无关的方式部署，从而提供了以前无法实现的新灵活性。
- en: In 2017, [Docker donated its `containerd` runtime](https://thenewstack.io/docker-donate-container-runtime-containerd-cloud-native-computing-foundation)
    to the [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io), and in
    2019, it was elevated to the graduated project status.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 2017 年，[Docker 将其 `containerd` 运行时捐赠给了](https://thenewstack.io/docker-donate-container-runtime-containerd-cloud-native-computing-foundation)
    [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io)，并于 2019 年提升为成熟项目状态。
- en: Today, the use of Linux containers in development, delivery, and production
    is bigger than ever. In 2022, we saw that Docker started to lose a share of the
    server market to the newest versions of Kubernetes that no longer require the
    Docker daemon, but even these releases of Kubernetes rely very heavily on the
    `containerd` runtime, which was initially developed by Docker. Docker also continues
    to have a very strong presence in many developer and CI/CD workflows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，在开发、交付和生产中使用 Linux 容器的规模比以往任何时候都要大。2022 年，我们看到 Docker 开始在服务器市场上失去份额，新版本的
    Kubernetes 不再需要 Docker 守护程序，但即使这些 Kubernetes 的发布版本也非常依赖于最初由 Docker 开发的 `containerd`
    运行时。Docker 在许多开发者和 CI/CD 工作流中仍然具有非常强大的影响力。
- en: So, what about OS vendor support and adoption? The Docker client runs directly
    on most major operating systems, and the server can run on Linux or Windows Server.
    The vast majority of the ecosystem is built around Linux servers, but other platforms
    are increasingly being supported. The beaten path is and will likely continue
    to revolve around Linux servers running Linux containers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，操作系统供应商的支持和采用情况如何呢？Docker 客户端可以直接在大多数主流操作系统上运行，服务器可以在 Linux 或 Windows Server
    上运行。绝大多数生态系统都围绕 Linux 服务器构建，但其他平台的支持越来越广泛。通行的道路是并且很可能将继续围绕运行 Linux 容器的 Linux 服务器展开。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to run Windows containers natively (without a VM) on 64-bit versions
    of Windows Server 2016+. However, 64-bit versions of Windows 10+ Professional
    still require Hyper-V to provide the Windows Server kernel that is used for Windows
    containers. We will dive into a little more detail about this in [“Windows Containers”](ch05.html#windows_containers).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位版本的 Windows Server 2016+ 上，可以原生地（无需虚拟机）运行 Windows 容器。然而，64 位版本的 Windows
    10+ 专业版仍然需要 Hyper-V 来提供用于 Windows 容器的 Windows Server 内核。我们将在 [“Windows 容器”](ch05.html#windows_containers)
    中详细讨论这个问题。
- en: It is also worth noting here that Windows can run Linux containers outside a
    virtual machine by leveraging WSL 2 (Windows Subsystem for Linux, version 2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，Windows 可以通过利用 WSL 2（Windows Subsystem for Linux，版本 2）在虚拟机外运行 Linux
    容器。
- en: To support the growing demand for Docker tooling in development environments,
    Docker has released easy-to-use implementations for macOS and Windows. These appear
    to run natively but are still utilizing a small Linux virtual machine to provide
    the Docker server and Linux kernel. Docker has traditionally been developed on
    the Ubuntu Linux distribution, but most Linux distributions and other major operating
    systems are now supported where possible. Red Hat, for example, has gone all in
    on containers, and all of its platforms have first-class support for Docker. With
    the near-ubiquity of containers in the Linux realm, we now have distributions
    like Red Hat’s Fedora CoreOS, which is built entirely for Linux container workloads.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持在开发环境中对 Docker 工具的不断增长的需求，Docker 发布了适用于 macOS 和 Windows 的易于使用的实现。这些实现看起来在本地运行，但仍然利用了一个小型的
    Linux 虚拟机来提供 Docker 服务器和 Linux 内核。Docker 传统上是在 Ubuntu Linux 发行版上开发的，但现在几乎所有的 Linux
    发行版和其他主要操作系统都在可能的情况下提供支持。例如，Red Hat 完全投入到容器中，其所有平台都对 Docker 提供一流的支持。随着 Linux 领域容器的普及，我们现在有了像
    Red Hat 的 Fedora CoreOS 这样专门用于 Linux 容器工作负载的发行版。
- en: In the first years after Docker’s release, a set of competitors and service
    providers voiced concerns about Docker’s proprietary image format. Containers
    on Linux did not have a standard image format, so Docker, Inc., created its own
    according to the needs of its business.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 发布后的最初几年，一些竞争对手和服务提供商对 Docker 的专有镜像格式表示了担忧。Linux 上的容器并没有一个标准的镜像格式，因此
    Docker 公司根据其业务需求创建了自己的格式。
- en: Service providers and commercial vendors were particularly reluctant to build
    platforms that might be subject to the whims of a company with overlapping interests
    to their own. Docker as a company faced some public challenges in that period
    as a result. To gain some goodwill and support wider adoption in the marketplace,
    Docker, Inc., decided to help sponsor [the Open Container Initiative (OCI)](https://www.opencontainers.org)
    in June of 2015\. The first full specification from that effort was released in
    July 2017 and was based in large part on version 2 of the Docker image format.
    It is now possible to apply for OCI certification for both container images and
    container runtimes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供商和商业供应商特别不愿意建立可能受制于具有重叠利益的公司的平台。正因如此，Docker作为一家公司在那段时间面临了一些公开挑战。为了获得一些善意并支持市场上更广泛的采用，Docker公司决定在2015年6月帮助赞助[Open
    Container Initiative (OCI)](https://www.opencontainers.org)。从那次努力中发布的第一个完整规范是在2017年7月发布的，它在很大程度上基于Docker镜像格式的第2版。现在可以申请OCI认证，既适用于容器镜像又适用于容器运行时。
- en: 'This is the primary high-level OCI-certified runtime:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的高级OCI认证运行时：
- en: '[`containerd`](https://containerd.io), which is the default high-level runtime
    in modern versions of Docker and Kubernetes.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`containerd`](https://containerd.io)是现代版本的Docker和Kubernetes中的默认高级运行时。'
- en: 'These lower-level OCI-certified runtimes can be used by `containerd` to manage
    and create containers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些低级OCI认证运行时可以被`containerd`用来管理和创建容器：
- en: '[`runc`](https://github.com/opencontainers/runc) is often used as the default
    lower-level runtime by `containerd`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`runc`](https://github.com/opencontainers/runc)通常作为`containerd`的默认低级运行时使用。'
- en: '[`crun`](https://github.com/containers/crun) is written in C and designed to
    be fast and have a small memory footprint.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`crun`](https://github.com/containers/crun)是用C语言编写的，旨在快速且具有较小的内存占用。'
- en: '[Kata Containers](https://katacontainers.io) from Intel, Hyper, and the OpenStack
    Foundation is a virtualized runtime that can run a mix of containers and virtual
    machines.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kata Containers](https://katacontainers.io)来自Intel、Hyper和OpenStack Foundation，是一个虚拟化运行时，可以运行容器和虚拟机的混合体。'
- en: '[gVisor](https://github.com/google/gvisor) from Google is a sandboxed runtime,
    implemented entirely in user space.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Google的[gVisor](https://github.com/google/gvisor)是一个完全在用户空间实现的沙盒运行时。
- en: '[Nabla Containers](https://nabla-containers.github.io) provide another sandboxed
    runtime designed to significantly reduce the attack surface of Linux containers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Nabla Containers](https://nabla-containers.github.io)提供另一种沙盒运行时，旨在显著减少Linux容器的攻击面。'
- en: The space around deploying containers and orchestrating entire systems of containers
    continues to expand, too. Many of these are open source and available both on
    premises and as cloud or software as a service (SaaS) offerings from various providers,
    either in their clouds or yours. Given the amount of investment continuing to
    pour into the Linux container space, it’s likely that Docker will continue to
    have an important role in the modern internet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署容器和编排整个容器系统的空间也在继续扩展。其中许多是开源的，并且可以在本地部署，也可以作为云端或软件即服务（SaaS）提供商的提供物，无论是在他们的云端还是你的云端。鉴于继续投入Linux容器空间的资金量，很可能Docker将继续在现代互联网中发挥重要作用。
- en: Architecture
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: Docker is a powerful technology, and that often indicates both tools and processes
    that come with a high level of complexity. And, under the hood, Docker is fairly
    complex; however, its fundamental user-facing structure is indeed a simple client/server
    model. Several pieces are sitting behind the Docker API, including `containerd`
    and `runc`, but the basic system interaction is a client talking over an API to
    a server. Underneath this simple exterior, Docker heavily leverages kernel mechanisms
    such as iptables, virtual bridging, Linux control groups (cgroups), Linux namespaces,
    Linux capabilities, secure computing mode, various filesystem drivers, and more.
    We’ll talk about some of these in [Chapter 11](ch11.html#advanced_topics). For
    now, we’ll go over how the client and server work and give a brief introduction
    to the network layer that sits underneath a Linux container in Docker.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一项强大的技术，通常意味着具有高复杂性的工具和流程。在幕后，Docker 确实很复杂；然而，它面向用户的基本结构确实是一个简单的客户端/服务器模型。Docker
    API 后面有几个组件，包括 `containerd` 和 `runc`，但基本的系统交互是客户端通过 API 与服务器通信。在这个简单的外观背后，Docker
    大量利用内核机制，如 iptables、虚拟桥接、Linux 控制组 (cgroups)、Linux 命名空间、Linux 能力、安全计算模式、各种文件系统驱动程序等。我们将在[第
    11 章](ch11.html#advanced_topics)讨论其中一些。现在，我们将介绍客户端和服务器的工作方式，并对 Docker 中 Linux
    容器下的网络层进行简要介绍。
- en: Client/Server Model
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器模型
- en: 'It’s easiest to think of Docker as consisting of two parts: the client and
    the server/daemon (see [Figure 2-3](#figure2-3)). Optionally there is a third
    component called the *registry*, which stores Docker images and their metadata.
    The server does the ongoing work of building, running, and managing your containers,
    and you use the client to tell the server what to do. The Docker [daemon](https://en.wikipedia.org/wiki/Daemon_(computing))
    can run on any number of servers in the infrastructure, and a single client can
    address any number of servers. Clients drive all of the communication, but Docker
    servers can talk directly to image registries when told to do so by the client.
    Clients are responsible for telling servers what to do, and servers focus on hosting
    and managing containerized applications.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的是将 Docker 视为由两部分组成：客户端和服务器/守护进程（参见[图 2-3](#figure2-3)）。可选地，还有一个称为*注册表*的第三组件，用于存储
    Docker 映像及其元数据。服务器负责构建、运行和管理您的容器的持续工作，您可以使用客户端告诉服务器要做什么。Docker [守护进程](https://en.wikipedia.org/wiki/Daemon_(computing))可以在基础架构中的任意数量的服务器上运行，单个客户端可以连接任意数量的服务器。客户端驱动所有通信，但在被客户端告知时，Docker
    服务器可以直接与镜像注册表通信。客户端负责告诉服务器要做什么，而服务器则专注于托管和管理容器化应用程序。
- en: '![Docker Client/Server Model](assets/dur3_0203.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Docker 客户端/服务器模型](assets/dur3_0203.png)'
- en: Figure 2-3\. Docker client/server model
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. Docker 客户端/服务器模型
- en: Docker is a little different in structure from some other client/server software.
    It has a `docker` client and a `dockerd` server, but rather than being entirely
    monolithic, the server then orchestrates a few other components behind the scenes
    on behalf of the client, including `containerd-shim-runc-v2`, which is used to
    interact with `runc` and `containerd`. Docker cleanly hides any complexity behind
    the simple server API, though, so you can just think of it as a straightforward
    client and server for most purposes. Each Docker host will normally have one Docker
    server running that can manage any number of containers. You can then use the
    `docker` command-line tool to talk to the server, either from the server itself
    or, if properly secured, from a remote client. We’ll talk more about that shortly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在结构上与一些其他客户端/服务器软件有所不同。它有一个 `docker` 客户端和一个 `dockerd` 服务器，但与其完全单片化不同，服务器背后还通过
    `containerd-shim-runc-v2` 等组件代表客户端协调几个其他组件，用于与 `runc` 和 `containerd` 交互。然而，Docker
    通过简单的服务器 API 干净地隐藏了任何复杂性，因此在大多数情况下，您可以将其视为一个简单的客户端和服务器。每个 Docker 主机通常会运行一个 Docker
    服务器，可以管理任意数量的容器。然后，您可以使用 `docker` 命令行工具与服务器通信，无论是从服务器本身还是（如果正确安全）从远程客户端。我们稍后会详细讨论这一点。
- en: Network Ports and Unix Sockets
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络端口和Unix套接字
- en: 'The `docker` command-line tool and `dockerd` daemon can talk to each other
    over Unix sockets and network ports. Docker, Inc., has registered three ports
    with the [Internet Assigned Numbers Authority (IANA)](https://www.iana.org) for
    use by the Docker daemon and client: TCP port 2375 for unencrypted traffic, port
    2376 for encrypted SSL connections, and port 2377 for Docker Swarm mode. Using
    a different port is easily configurable for scenarios where you need to use different
    settings. The default setting for the Docker installer is to only use a Unix socket
    for communication with the local Docker daemon. This ensures that the system defaults
    to the most secure installation possible. This is also easily configurable, but
    it is highly recommended that network ports are not used with Docker, due to the
    lack of user authentication and role-based access controls within the Docker daemon.
    The Unix socket can be located in different paths on different operating systems,
    but in most cases, it can be found here: */var/run/docker.sock*. If you have strong
    preferences for a different location, you can usually specify this at install
    time or simply change the server configuration afterward and restart the daemon.
    If you don’t, then the defaults will probably work for you. As with most software,
    following the defaults will save you a lot of trouble if you don’t need to change
    them.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker` 命令行工具和 `dockerd` 守护进程可以通过 Unix 套接字和网络端口进行通信。Docker 公司已向 [互联网编号分配机构
    (IANA)](https://www.iana.org) 注册了三个端口，供 Docker 守护程序和客户端使用：TCP 端口 2375 用于未加密流量，端口
    2376 用于加密 SSL 连接，端口 2377 用于 Docker Swarm 模式。在需要使用不同设置的场景中，可以轻松配置不同的端口。Docker 安装程序的默认设置是仅使用
    Unix 套接字与本地 Docker 守护程序进行通信。这确保系统默认采用可能的最安全安装。虽然这也是可以轻松配置的，但强烈建议不要在 Docker 中使用网络端口，因为
    Docker 守护程序内部缺乏用户认证和基于角色的访问控制。Unix 套接字在不同操作系统上的路径可能不同，但在大多数情况下，可以在此找到：*/var/run/docker.sock*。如果您对其他位置有强烈偏好，通常可以在安装时指定此位置，或者稍后更改服务器配置并重新启动守护进程。如果没有特别要求，那么默认设置可能适合您。与大多数软件一样，如果不需要更改，遵循默认设置将节省大量麻烦。'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Recent versions of Docker Desktop may create the *docker.sock* file in the user’s
    home directory inside *.docker/run/* and then simply link *_/var/run/docker.sock*
    to this location.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最近版本的 Docker Desktop 可能会在用户的主目录内的 *.docker/run/* 中创建 *docker.sock* 文件，然后简单地将
    *_/var/run/docker.sock* 链接到此位置。
- en: Robust Tooling
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强大的工具集
- en: Among the many things that have led to Docker’s strong adoption is its simple
    and powerful tooling. Since its initial release, its capabilities have been expanding
    ever wider, thanks to efforts from the Docker community at large. The tooling
    that Docker ships with supports building Docker images, basic deployment to individual
    Docker daemons, a distributed mode called Swarm mode, and all the functionality
    needed to manage a remote Docker server. Beyond the included Swarm mode, community
    efforts have focused on managing whole fleets (or clusters) of Docker servers
    and scheduling and orchestrating container deployments.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 导致 Docker 广泛采用的许多因素之一是其简单而强大的工具集。自首次发布以来，由于 Docker 社区的努力，其功能已不断扩展。Docker 提供的工具支持构建
    Docker 镜像、基本部署到单个 Docker 守护进程、称为 Swarm 模式的分布式模式，以及管理远程 Docker 服务器所需的所有功能。除了包含的
    Swarm 模式外，社区还专注于管理整个 Docker 服务器群集，并调度和编排容器部署。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When we talk about [Docker Swarm or Swarm mode](https://docs.docker.com/engine/swarm)
    in this book, we are referring to the built-in Swarm functionality in the Docker
    client and server, which leverages another underlying library called SwarmKit.
    When searching for articles on the internet, you may find references to an older
    standalone version of Docker Swarm, which is often referred to as [Docker Swarm
    “Classic”](https://github.com/docker-archive/classicswarm) nowadays.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当本书中谈论 [Docker Swarm 或 Swarm 模式](https://docs.docker.com/engine/swarm) 时，我们指的是
    Docker 客户端和服务器内置的 Swarm 功能，它利用了另一个称为 SwarmKit 的底层库。在搜索互联网文章时，您可能会发现有关旧版独立版 Docker
    Swarm 的引用，该版本现在通常被称为 [Docker Swarm “Classic”](https://github.com/docker-archive/classicswarm)。
- en: Docker has also launched its own orchestration toolset, including [Compose](https://github.com/docker/compose),
    [Docker Desktop](https://www.docker.com/products/docker-desktop), and [Swarm mode](https://docs.docker.com/engine/swarm),
    which creates a cohesive deployment story for developers. Docker’s offerings in
    the production orchestration space have been largely overshadowed by Google’s
    Kubernetes, although it should be noted that [Kubernetes relied heavily on Docker
    until v1.24 was released in early 2022](https://kubernetes.io/blog/2020/12/02/dockershim-faq).
    But Docker’s orchestration tools remain useful, with Compose being particularly
    handy for local development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 还推出了自己的编排工具集，包括[Compose](https://github.com/docker/compose)、[Docker Desktop](https://www.docker.com/products/docker-desktop)和[Swarm
    mode](https://docs.docker.com/engine/swarm)，为开发人员提供了一致的部署方案。尽管 Docker 在生产编排领域的产品被
    Google 的 Kubernetes 遮掩，但需要注意的是，[Kubernetes 在 2022 年初发布 v1.24 之前广泛依赖于 Docker](https://kubernetes.io/blog/2020/12/02/dockershim-faq)。但
    Docker 的编排工具仍然很有用，特别是 Compose 在本地开发中特别方便。
- en: Because Docker provides both a command-line tool and a remote REST API, it is
    easy to add further tooling in any language. The command-line tool lends itself
    well to shell scripting, and anything the client can do can also be done programmatically
    via the REST API. The Docker CLI is so well-known that many other Linux container
    CLI tools, like [`podman`](https://podman.io) and [`nerdctl`](https://github.com/containerd/nerdctl),
    mimic its arguments for compatibility and easy adoption.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Docker 提供了命令行工具和远程 REST API，所以很容易在任何语言中添加更多的工具。命令行工具非常适合 shell 脚本编写，客户端可以做的任何事情也可以通过
    REST API 编程方式完成。Docker CLI 如此著名，以至于许多其他 Linux 容器 CLI 工具，如 [`podman`](https://podman.io)
    和 [`nerdctl`](https://github.com/containerd/nerdctl)，模仿其参数以实现兼容性和易用性采纳。
- en: Docker Command-Line Tool
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 命令行工具
- en: 'The command-line tool `docker` is the main interface that most people will
    have with Docker. The Docker client is a [Go program](https://golang.org) that
    compiles and runs on all common architectures and operating systems. The command-line
    tool is available as part of the main Docker distribution on various platforms
    and also compiles directly from the Go source. Some of the things you can typically
    do with the Docker command-line tool include, but are not limited to, the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具 `docker` 是大多数人与 Docker 交互的主要界面。Docker 客户端是一个[Go 程序](https://golang.org)，可以在所有常见的架构和操作系统上编译和运行。这个命令行工具作为主要
    Docker 发行版的一部分在各种平台上都可以使用，并且可以直接从 Go 源代码编译。你通常可以使用 Docker 命令行工具做以下一些事情，但不限于：
- en: Building a container image
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Pulling images from a registry to a Docker daemon or pushing them up to a registry
    from the Docker daemon
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从注册表拉取镜像到 Docker 守护程序或将其推送到注册表
- en: Starting a container on a Docker server either in the foreground or background
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker 服务器上启动容器，可以是前台或后台
- en: Retrieving the Docker logs from a remote server
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程服务器检索 Docker 日志
- en: Interactively running a command inside a running container on a remote server
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程服务器上交互式地运行容器内正在运行的命令
- en: Monitoring statistics about your container
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控关于你的容器的统计数据
- en: Getting a process listing from your container
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取容器中的进程列表
- en: You can probably see how these can be composed into a workflow for building,
    deploying, and observing applications. But the Docker command-line tool is not
    the only way to interact with Docker, and it’s not necessarily the most powerful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到这些如何组合成一个用于构建、部署和观察应用程序的工作流程。但 Docker 命令行工具并不是与 Docker 交互的唯一方式，也不一定是最强大的方式。
- en: Docker Engine API
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 引擎 API
- en: Like many other pieces of modern software, the Docker daemon has an API. This
    is in fact what the Docker command-line tool uses to communicate with the daemon.
    But because the API is documented and public, it’s quite common for external tooling
    to use the API directly. This provides a convenient mechanism that allows any
    tool to create, inspect, and manage all of the images and containers that are
    under the Docker daemon’s management. While it’s unlikely that beginners will
    initially want to talk directly to the Docker API, it’s a great tool to have available.
    As your organization embraces Docker over time, you will increasingly find the
    API to be a good integration point for this tooling.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多现代软件的其他部分一样，Docker守护程序具有API。这实际上是Docker命令行工具用来与守护程序通信的方式。但由于API是公开文档的，外部工具直接使用API是相当常见的。这提供了一个方便的机制，允许任何工具创建、检查和管理Docker守护程序管理下的所有镜像和容器。虽然初学者可能不会最初想要直接与Docker
    API交互，但它是一个非常有用的工具。随着您的组织随着时间的推移越来越多地采用Docker，您会发现API是这些工具的一个很好的集成点。
- en: Extensive documentation for the [API](https://dockr.ly/2wxCHnx) is on the Docker
    site. As the ecosystem has matured, robust implementations of Docker API libraries
    have emerged for all popular languages. Docker maintains [SDKs for Python and
    Go](https://dockr.ly/2wxCHnx), and there are additional libraries maintained by
    third parties that are worth considering. For example, over the years we have
    used these [Go](https://github.com/fsouza/go-dockerclient) and [Ruby](https://github.com/upserve/docker-api)
    libraries and have found them to be both robust and rapidly updated as new versions
    of Docker are released.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[API](https://dockr.ly/2wxCHnx)的详细文档位于Docker网站上。随着生态系统的成熟，针对所有流行语言已经出现了稳健的Docker
    API库的实现。Docker维护着Python和Go的[SDKs](https://dockr.ly/2wxCHnx)，还有由第三方维护的其他值得考虑的库。例如，多年来我们使用了这些[Go](https://github.com/fsouza/go-dockerclient)和[Ruby](https://github.com/upserve/docker-api)库，并发现它们既稳健又在新版本的Docker发布时迅速更新。'
- en: 'Most of the things you can do with the Docker command-line tooling are supported
    relatively easily via the API. Two notable exceptions are the endpoints that require
    streaming or terminal access: running remote shells or executing the container
    in interactive mode. In these cases, it’s often easier to use one of these solid
    client libraries or the command-line tool.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可以通过Docker命令行工具完成的事情都可以相对轻松地通过API支持。有两个显著的例外是需要流式处理或终端访问的端点：运行远程shell或以交互模式执行容器。在这些情况下，通常更容易使用这些可靠的客户端库或命令行工具。
- en: Container Networking
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器网络
- en: Even though Linux containers are largely made up of processes running on the
    host system itself, they usually behave quite differently from other processes
    at the network layer. Docker initially supported a single networking model but
    now supports a robust assortment of configurations that handle most application
    requirements. Most people run their containers in the default configuration, called
    *bridge mode*. So let’s take a look at how it works.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linux容器主要由在主机系统上运行的进程组成，但它们在网络层通常表现得与其他进程非常不同。Docker最初支持了单一的网络模型，但现在支持了处理大多数应用需求的强大的配置组合。大多数人在默认配置下运行其容器，称为*桥接模式*。让我们看看它是如何工作的。
- en: To understand bridge mode, it’s easiest to think of each of your Linux containers
    as behaving like a host on a private network. The Docker server acts as a virtual
    bridge, and the containers are clients behind it. A bridge is just a network device
    that repeats traffic from one side to another. So you can think of it like a mini
    virtual network, with each container acting like a host attached to that network.
    The actual implementation (see [Figure 2-4](#figure02-1)) is that each container
    has a virtual Ethernet interface connected to the Docker bridge and an IP address
    allocated to the virtual interface. Docker lets you bind and expose individual
    or groups of ports on the host to the container so that the outside world can
    reach your container on those ports. The traffic is largely managed by the [vpnkit](https://github.com/moby/vpnkit)
    library.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 理解桥接模式最简单的方法是将您的每个 Linux 容器视为私有网络上的主机。Docker 服务器充当虚拟桥接，而容器则是其后的客户端。桥接只是一个网络设备，将一侧的流量转发到另一侧。因此，您可以将其视为一个小型虚拟网络，其中每个容器像连接到该网络的主机一样运行。实际实现（见
    [图 2-4](#figure02-1)）是每个容器都有一个连接到 Docker 桥接的虚拟以太网接口，并分配给虚拟接口的 IP 地址。Docker 允许您绑定和显露主机上的单个或一组端口给容器，以便外部世界可以通过这些端口访问您的容器。流量主要由
    [vpnkit](https://github.com/moby/vpnkit) 库管理。
- en: Docker allocates the private subnet from an unused [RFC 1918](https://www.rfc-editor.org/rfc/rfc1918)
    private subnet block. It detects which network blocks are unused on the host and
    allocates one of those to the virtual network. That is bridged to the host’s local
    network through an interface on the server called `docker0`. This means that,
    by default, all of the containers are on a network together and can talk to one
    another directly. But to get to the host or the outside world, they go over the
    `docker0` virtual bridge interface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 从未使用的 [RFC 1918](https://www.rfc-editor.org/rfc/rfc1918) 私有子网块中分配私有子网。它检测主机上未使用的网络块，并为虚拟网络分配其中之一。这通过服务器上的
    `docker0` 接口桥接到主机的本地网络。这意味着，默认情况下，所有容器都在同一个网络上，并可以直接相互通信。但要访问主机或外部世界，则通过 `docker0`
    虚拟桥接接口。
- en: '![The network on a typical Docker server](assets/dur3_0204.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![典型 Docker 服务器上的网络](assets/dur3_0204.png)'
- en: Figure 2-4\. The network on a typical Docker server
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 典型 Docker 服务器上的网络
- en: There is a dizzying array of ways in which you can configure Docker’s network
    layer, from allocating your own network blocks to configuring your own custom
    bridge interface. People often run with the default mechanisms, but there are
    times when something more complex or specific to your application is required.
    You can find much more detail about Docker networking in the [documentation](https://dockr.ly/2otp461),
    and we will cover more details in [Chapter 11](ch11.html#advanced_topics).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以配置 Docker 的网络层，从分配您自己的网络块到配置自定义桥接接口。人们通常使用默认机制运行，但在需要更复杂或特定于应用程序的情况下，还有其他选择。您可以在
    [文档](https://dockr.ly/2otp461) 中找到关于 Docker 网络的更多详细信息，我们将在 [第 11 章](ch11.html#advanced_topics)
    中涵盖更多细节。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When developing your Docker workflow, you should get started with the default
    networking approach. You might later find that you don’t want or need this default
    virtual network. Networking is configurable per container, and you can switch
    off the whole virtual network layer entirely for a container using the `--net=host`
    switch to `docker container run`. When running in that mode, Linux containers
    use the host’s own network devices and addresses, and no virtual interfaces or
    bridges are provisioned. Note that host networking has security implications you
    might need to consider. Other network topologies are possible and discussed in
    [Chapter 11](ch11.html#advanced_topics).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Docker 工作流程时，您应该从默认的网络方法开始。您可能会发现，您不希望或不需要这个默认的虚拟网络。每个容器的网络是可配置的，您可以通过使用
    `docker container run` 的 `--net=host` 开关完全关闭容器的整个虚拟网络层。在这种模式下运行时，Linux 容器使用主机自己的网络设备和地址，没有虚拟接口或桥接被预配。请注意，主机网络具有您可能需要考虑的安全性影响。还有其他可能性的网络拓扑，可以在
    [第 11 章](ch11.html#advanced_topics) 中讨论。
- en: Getting the Most from Docker
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充分利用 Docker
- en: Like most tools, Docker has a number of great use cases, and others that aren’t
    so good. You can, for example, open a glass jar with a hammer. But that has its
    downsides. Understanding how to best use the tool, or even simply determining
    if it’s the right tool, can get you on the correct path much more quickly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数工具一样，Docker 有许多优秀的用例，也有一些不那么好的用例。例如，你可以用锤子打开玻璃罐。但这也有其缺点。理解如何最好地使用这个工具，甚至简单地确定它是否是合适的工具，可以让你更快地找到正确的路径。
- en: To begin with, Docker’s architecture is aimed squarely at applications that
    are either stateless or where the state is externalized into data stores like
    databases or caches. Those are the easiest to containerize. Docker enforces some
    good development principles for this class of application, and we’ll talk later
    about how that’s powerful. But this means that doing things like putting a database
    engine inside Docker is a bit like swimming against the current. It’s not that
    you can’t do it, or even that you shouldn’t do it; it’s just that this is not
    the most obvious use case for Docker, so if it’s the one you start with, you may
    find yourself disappointed early on. Databases that run well in Docker are now
    often deployed this way, but this is not the simple path. Some good applications
    for beginning with Docker include web frontends, backend APIs, and short-running
    tasks like maintenance scripts that might normally be handled by `cron`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Docker 的架构专注于无状态或状态外部化到数据存储（如数据库或缓存）的应用程序。这些是最容易容器化的。Docker 强制执行一些对于这类应用程序有益的开发原则，稍后我们将讨论这点的强大之处。但这意味着在
    Docker 中放置数据库引擎之类的操作有点像逆水行舟。并不是说你不能这样做，甚至不应该这样做；只是这不是 Docker 的最明显的用例，所以如果你从这个开始，你可能会在早期感到失望。现在在
    Docker 中运行良好的数据库通常是以这种方式部署的，但这并不是简单的路径。一些适合初学者使用 Docker 的好应用包括 Web 前端、后端 API 和短期运行的任务，比如通常由
    `cron` 处理的维护脚本。
- en: If you focus first on building an understanding of running stateless or externalized-state
    applications inside containers, you will have a foundation on which to start considering
    other use cases. We strongly recommend starting with stateless applications and
    learning from that experience before tackling other use cases. The community is
    continuously working on how to better support stateful applications in Docker,
    and there are likely to be many developments in this area.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先专注于在容器中运行无状态或外部状态应用程序的理解，那么你将有一个基础来考虑其他用例。我们强烈建议先从无状态应用程序开始，并从中积累经验，然后再考虑其他用例。社区正在不断努力以更好地支持
    Docker 中的有状态应用程序，并且在这个领域可能会有很多发展。
- en: Containers Are Not Virtual Machines
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器不是虚拟机。
- en: 'A good way to start shaping your understanding of how to leverage Docker is
    to think of Linux containers not as virtual machines (VMs) but as very lightweight
    wrappers around a single Unix process. During actual implementation, that process
    might spawn other processes, but on the other hand, one statically compiled binary
    could be all that’s inside your container (see [“Outside Dependencies”](ch09.html#dependencies)
    for more information). Containers are also ephemeral: they may come and go much
    more readily than a traditional virtual machine.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的方法来开始塑造你对如何利用 Docker 的理解是将 Linux 容器视为非虚拟机（VMs），而是非常轻量级的包装器，包裹着一个单一的 Unix
    进程。在实际实施中，这个进程可能会衍生出其他进程，但另一方面，一个静态编译的二进制文件可能是容器中全部的内容（查看[“外部依赖”](ch09.html#dependencies)获取更多信息）。容器也是短暂的：它们可能会更容易地出现和消失，远比传统的虚拟机快。
- en: Virtual machines are by design a stand-in for real hardware that you might throw
    in a rack and leave there for a few years. Because a real server is what they’re
    abstracting, virtual machines are often long-lived in nature. Even in the cloud
    where companies often spin virtual machines up and down on demand, they usually
    have a running life span of days or more. On the other hand, a particular container
    might exist for months, or it may be created, run a task for a minute, and then
    be destroyed. All of that is OK, but it’s a fundamentally different approach than
    the one virtual machines are typically used for.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机从设计上是真实硬件的替代品，你可以将其放入机架并在那里使用几年。由于它们抽象了真实服务器，虚拟机通常具有长期的生命周期。即使在云中，公司经常根据需求启动和关闭虚拟机，它们通常也会有几天或更长时间的运行生命周期。另一方面，特定的容器可能会存在几个月，或者它可能被创建，运行一分钟的任务，然后被销毁。所有这些都是可以接受的，但这与虚拟机通常用于的方式根本不同。
- en: To help drive this differentiation home, if you run Docker on a mac or Windows
    system, you are leveraging a Linux virtual machine to run `dockerd`, the Docker
    server. However, on Linux, `dockerd` can be run natively, and therefore there
    is no need for a virtual machine to be run anywhere on the system (see [Figure 2-5](#figure2-4)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在帮助加深这种区分的过程中，如果您在 Mac 或 Windows 系统上运行 Docker，则利用 Linux 虚拟机来运行`dockerd`，即 Docker
    服务器。然而，在 Linux 上，`dockerd`可以本地运行，因此系统中无需运行虚拟机（参见 [图2-5](#figure2-4)）。
- en: '![Typical Docker Installations](assets/dur3_0205.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![典型的 Docker 安装](assets/dur3_0205.png)'
- en: Figure 2-5\. Typical Docker installations
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-5\. 典型的 Docker 安装
- en: Limited Isolation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限的隔离
- en: Containers are isolated from one another, but that isolation is probably more
    limited than you might expect. While you can put limits on their resources, the
    default container configuration just has them all sharing CPU and memory on the
    host system, much as you would expect from colocated Unix processes. This means
    that unless you constrain them, containers can compete for resources on your production
    machines. That might be fine for your use case, but it impacts your design decisions.
    Limits on CPU and memory use are encouraged through Docker, but in most cases,
    they are not the default like they would be with a virtual machine.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 容器彼此之间是隔离的，但这种隔离可能比您预期的要有限。虽然您可以限制它们的资源，但默认的容器配置仅使它们在主机系统上共享 CPU 和内存，就像您期望的那样与
    Unix 进程共同放置。这意味着除非对其进行限制，否则容器可能会在您的生产机器上竞争资源。对 CPU 和内存使用的限制是通过 Docker 鼓励的，但在大多数情况下，它们不像虚拟机那样成为默认选项。
- en: It’s often the case that many containers share one or more common filesystem
    layers. That’s one of the more powerful design decisions in Docker, but it also
    means that if you update a shared image, you may also need to rebuild and redeploy
    containers that are still utilizing the older image.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 很多情况下，许多容器共享一个或多个常见的文件系统层。这是 Docker 中更强大的设计决策之一，但这也意味着，如果您更新了共享的映像，可能还需要重新构建和部署仍在使用旧映像的容器。
- en: Containerized processes are just processes on the Docker server itself. They
    are running on the same instance of the Linux kernel as the host operating system.
    All container processes show up in the normal `ps` output on the Docker server.
    That is utterly different from a hypervisor, where the depth of process isolation
    usually includes running an entirely separate instance of the operating system
    kernel for each virtual machine.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化进程仅仅是在 Docker 服务器上的进程。它们与主机操作系统上的 Linux 内核实例上运行的进程相同。所有容器进程都会显示在 Docker 服务器的正常`ps`输出中。这与虚拟化管理程序完全不同，后者通常包括为每个虚拟机运行一个完全独立的操作系统内核实例。
- en: This light containment can lead to the tempting option of exposing more resources
    from the host, such as shared filesystems to allow the storage of state. But you
    should think hard before further exposing resources from the host into the container
    unless they are used exclusively by the container. We’ll talk about the security
    of containers later, but generally, you might consider helping to enforce isolation
    further by applying [Security-Enhanced Linux (SELinux)](https://www.redhat.com/en/topics/linux/what-is-selinux)
    or [AppArmor](https://apparmor.net) policies rather than compromising the existing
    barriers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轻量级的封装可能会导致诱人的选项，即从主机公开更多资源，例如共享文件系统以允许状态存储。但是，在将主机资源进一步公开到容器之前，除非它们专门由容器使用，您应该认真考虑。我们将稍后讨论容器的安全性，但通常情况下，您可能会考虑通过应用[安全增强型
    Linux (SELinux)](https://www.redhat.com/en/topics/linux/what-is-selinux)或[AppArmor](https://apparmor.net)策略来进一步强制执行隔离，而不是牺牲现有的屏障。
- en: Warning
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: By default, many containers use UID 0 to launch processes. Because the container
    is *contained*, this seems safe, but in reality, it isn’t very safe. Because everything
    is running on the same kernel, many types of security vulnerabilities or simple
    misconfiguration can give the container’s `root` user unauthorized access to the
    host’s system resources, files, and processes. Refer to [“Security”](ch11.html#security)
    for a discussion of how to mitigate this.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，许多容器使用 UID 0 来启动进程。因为容器是*被包含的*，这看起来很安全，但实际上并不是很安全。因为一切都在同一个内核上运行，许多类型的安全漏洞或简单的配置错误都可能导致容器的`root`用户未经授权地访问主机的系统资源、文件和进程。请参考[“安全性”](ch11.html#security)以讨论如何减轻这种情况。
- en: Containers Are Lightweight
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器轻量化
- en: We’ll get more into the details of how this works later, but creating a new
    container can take up very little disk space. A quick test reveals that a newly
    created container from an existing image takes a whopping 12 kilobytes of disk
    space. That’s pretty lightweight. On the other hand, a new virtual machine created
    from a golden image might require hundreds or thousands of megabytes, since at
    a minimum it requires a full operating install to exist on that disk. The new
    container, on the other hand, is so small because it is just a reference to a
    layered filesystem image and some metadata about the configuration. By default,
    no copy of the data is allocated to the container. Containers are just processes
    on the existing system that may only need to read information from the disk, so
    there may not be a need to copy any data for the exclusive use of the container,
    until a time when it needs to write data that is unique to that container instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更详细地讨论这个工作原理，但创建一个新容器可能占用很少的磁盘空间。快速测试表明，从现有镜像创建的新容器只需 12 千字节的磁盘空间。这非常轻量。另一方面，从黄金镜像创建的新虚拟机可能需要数百或数千兆字节，因为至少需要完整的操作系统安装在该磁盘上。另一方面，新容器之所以如此小，是因为它只是对分层文件系统镜像的引用以及一些关于配置的元数据。默认情况下，不会为容器分配数据的副本。容器只是现有系统上的进程，可能只需要从磁盘读取信息，因此在容器独占使用数据之前，可能不需要复制任何数据。
- en: The lightness of containers means that you can use them for situations where
    creating another virtual machine would be too heavyweight or where you need something
    to be truly ephemeral. You probably wouldn’t, for instance, spin up an entire
    virtual machine to run a `curl` command to a website from a remote location, but
    you might spin up a new container for this purpose.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的轻量性意味着你可以在创建另一个虚拟机太重或需要真正短暂性的情况下使用它们。例如，你可能不会启动整个虚拟机来从远程位置运行`curl`命令访问网站，但你可能会为此目的启动一个新的容器。
- en: Toward an Immutable Infrastructure
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 走向不可变基础设施
- en: By deploying most of your applications within containers, you can start simplifying
    your configuration management story by moving toward an immutable infrastructure,
    where components are replaced entirely rather than changed in place. The idea
    of an immutable infrastructure has gained popularity in response to how difficult
    it is, in reality, to maintain a truly idempotent configuration management codebase.
    As your configuration management codebase grows, it can become as unwieldy and
    unmaintainable as large, monolithic legacy applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在容器内部部署大部分应用程序，你可以通过向不可变基础设施转移来简化配置管理故事，即组件完全被替换而不是在原地更改。在现实中，要维护一个真正幂等的配置管理代码库是多么困难，不难理解为何不可变基础设施的概念越来越受欢迎。随着配置管理代码库的增长，它可能变得像大型、单片式的遗留应用程序一样笨重和难以维护。
- en: With Docker, it is possible to deploy a very lightweight Docker server that
    needs almost no configuration management, or in many cases, none at all. You handle
    all of your application management simply by deploying and redeploying containers
    to the server. When the server needs an important update to something like the
    Docker daemon or the Linux kernel, you can simply bring up a new server with the
    changes, deploy your containers there, and then decommission or reinstall the
    old server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker，可以部署一个非常轻量的 Docker 服务器，几乎不需要配置管理，或者在许多情况下根本不需要。你只需通过部署和重新部署容器来简单地处理所有应用管理。当服务器需要对
    Docker 守护程序或 Linux 内核进行重要更新时，你可以简单地启动一个带有变更的新服务器，在那里部署你的容器，然后停用或重新安装旧服务器。
- en: Container-based Linux distributions like [Red Hat’s Fedora CoreOS](https://getfedora.org/en/coreos)
    are designed around this principle. But rather than requiring you to decommission
    the instance, Fedora CoreOS can entirely update itself and switch to the updated
    OS. Your configuration and workload largely remain in your containers, and you
    don’t have to configure the OS very much at all.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基于容器的 Linux 发行版如[红帽的 Fedora CoreOS](https://getfedora.org/en/coreos)就是围绕这一原则设计的。但与其要求你停用实例不同，Fedora
    CoreOS 可以完全更新自身并切换到更新的操作系统。你的配置和工作负载主要留在容器中，你几乎不需要对操作系统进行太多配置。
- en: Because of this clean separation between deployment and configuration of your
    servers, many container-based production systems are using tools such as [HashiCorp’s
    Packer](https://www.packer.io/intro/index.html) to build cloud virtual server
    images, and then leveraging Docker to nearly or entirely avoid configuration management
    systems.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在部署和配置服务器方面有着清晰的分离，许多基于容器的生产系统正在使用诸如[HashiCorp 的 Packer](https://www.packer.io/intro/index.html)
    这样的工具来构建云虚拟服务器镜像，然后利用 Docker 几乎或完全避免配置管理系统。
- en: Stateless Applications
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态应用
- en: A good example of the kind of application that containerizes well is a web application
    that keeps its state in a database. Stateless applications are normally designed
    to immediately answer a single self-contained request and have no need to track
    information between requests from one or more clients. You might also run something
    like ephemeral [Memcached](https://memcached.org) instances in containers. If
    you think about your web application, though, it probably has some local state
    that you rely on, like configuration files. That might not seem like a lot of
    state, but if you bake that configuration into your images, it means that you’ve
    limited the reusability of your image and made it more challenging to deploy into
    different environments, without maintaining multiple images for different deployment
    targets.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容器化效果良好的应用的典型例子是将其状态保存在数据库中的 Web 应用程序。无状态应用通常设计为立即响应单个自包含请求，并且不需要在一个或多个客户端的请求之间跟踪信息。你也许会在容器中运行类似临时的[Memcached](https://memcached.org)
    实例。不过，如果考虑你的 Web 应用程序，它可能有一些你依赖的本地状态，比如配置文件。这可能看起来不像是很多状态，但如果把这些配置嵌入到镜像中，意味着你限制了镜像的重用性，并且增加了在不同环境中部署的挑战，因为需要维护多个针对不同部署目标的镜像。
- en: In many cases, the process of containerizing your application means that you
    move configuration state into environment variables that can be passed to your
    application at runtime. Rather than baking the configuration into the container,
    you apply the configuration to the container when it is deployed. This allows
    you to easily do things like use the same container to run in either production
    or staging environments. In most companies, those environments would require many
    different configuration settings like the connection URLs for various external
    services that the application utilizes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，将应用程序容器化的过程意味着将配置状态转移到可以在运行时传递给应用程序的环境变量中。而不是把配置信息固定到容器中，你可以在部署容器时应用配置。这使得你能够轻松地在生产环境或者演示环境中使用相同的容器运行应用程序。在大多数公司中，这些环境可能需要许多不同的配置设置，比如应用程序使用的各种外部服务的连接
    URL。
- en: With containers, you might also find that you are always decreasing the size
    of your containerized application as you optimize it down to the bare essentials
    required to run. We have found that thinking of anything that you need to run
    in a distributed way as a container can lead to some interesting design decisions.
    If, for example, you have a service that collects some data, processes it, and
    returns the result, you might configure containers on many servers to run the
    job and then aggregate the response on another container.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器，你可能会发现在优化下你的容器化应用程序的同时，不断减少其大小，使其仅包含运行所需的基本要素。我们发现，将需要以分布方式运行的任何东西视为容器可以引导出一些有趣的设计决策。例如，如果有一个收集数据、处理数据并返回结果的服务，你可以在许多服务器上配置容器来运行任务，然后在另一个容器上聚合响应。
- en: Externalizing State
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部化状态
- en: If Docker works best for stateless applications, how do you best store state
    when you need to? Configuration is typically passed by environment variables,
    for example. Docker supports environment variables natively, and they are stored
    in the metadata that makes up a container configuration. This means that restarting
    the container will ensure that the same configuration is passed to your application
    each time. It also makes the configuration of the container easily observable
    while it’s running, which can make debugging a lot easier, although there are
    some security concerns around exposing secrets in environment variables. It is
    also possible to store and retrieve your application configuration inside an external
    datastore, like [Consul](https://www.consul.io) or [PostgreSQL](https://www.postgresql.org).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Docker 对于无状态应用程序效果最好，那么在需要时如何最好地存储状态呢？例如，配置通常通过环境变量传递。Docker 原生支持环境变量，并将它们存储在构成容器配置的元数据中。这意味着重新启动容器将确保每次都将相同的配置传递给您的应用程序。它还使得在运行时轻松观察容器的配置，这可以大大简化调试过程，尽管在环境变量中暴露秘密信息存在一些安全问题。还可以将应用程序配置存储和检索到外部数据存储中，比如[Consul](https://www.consul.io)或[PostgreSQL](https://www.postgresql.org)。
- en: Databases are often where scaled applications store state, and nothing in Docker
    interferes with doing that for containerized applications. Applications that need
    to store files, however, face some challenges. Storing things to the container’s
    filesystem is not performant, will be limited by space, and will not preserve
    state when a container is re-created. If you redeploy a stateful service without
    utilizing storage external to the container, you will lose all of that state.
    Applications that need to store filesystem state should be carefully considered
    before you put them into Docker. If you decide that you can benefit from Linux
    containers in these cases, it’s best to design a solution where the state can
    be stored in a centralized location that could be accessed regardless of which
    host a container runs on. In certain cases, this might mean using a service like
    Amazon Simple Storage Service (Amazon S3), OpenStack Swift, or a local block store,
    or even mounting EBS volumes or iSCSI disks inside the container. [Docker volume
    plug-ins](https://docs.docker.com/engine/extend/plugins_volume) provide some additional
    options and are briefly discussed in [Chapter 11](ch11.html#advanced_topics).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常是扩展应用程序存储状态的地方，而 Docker 并不会干扰容器化应用程序进行这样的操作。然而，需要存储文件的应用程序面临一些挑战。将数据存储到容器的文件系统中性能不佳，会受到空间限制，并且在容器重新创建时不会保留状态。如果重新部署一个有状态的服务而不利用容器外部的存储，将会丢失所有状态。在将需要存储文件系统状态的应用程序放入
    Docker 之前，应仔细考虑。如果您决定在这些情况下从 Linux 容器中受益，最好设计一个解决方案，其中状态可以存储在一个集中位置，无论容器运行在哪个主机上都可以访问。在某些情况下，这可能意味着使用像亚马逊简单存储服务（Amazon
    S3）、OpenStack Swift 或本地块存储，甚至在容器内挂载 EBS 卷或 iSCSI 磁盘。[Docker 卷插件](https://docs.docker.com/engine/extend/plugins_volume)提供了一些额外的选项，并在[第
    11 章](ch11.html#advanced_topics)中简要讨论了它们。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Although it is possible to externalize state on the host’s local filesystem,
    it is not generally encouraged by the community and should be considered an advanced
    use case. It is strongly recommended that you start with applications that don’t
    need persistent state. There are multiple reasons why this is typically discouraged,
    but in almost all cases it is because it introduces dependencies between the container
    and the host that interfere with using Docker as a truly dynamic, horizontally
    scalable application delivery service. If your container maintains state on the
    local host filesystem, then it can only be deployed to the system that houses
    that local filesystem. Remote volumes that can be dynamically attached are a good
    solution but also an advanced use case.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以在主机的本地文件系统上外部化状态，但社区通常不建议这样做，并且应视为高级用例。强烈建议您首先使用不需要持久状态的应用程序。通常不鼓励这样做有多个原因，但几乎所有情况下的原因都是因为它引入了容器和主机之间的依赖关系，这些依赖关系会干扰
    Docker 作为真正动态、横向可扩展的应用程序交付服务的使用。如果您的容器在本地主机文件系统上维护状态，则只能部署到托管该本地文件系统的系统上。可以动态挂载的远程卷是一个不错的解决方案，但也是一个高级用例。
- en: The Docker Workflow
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 工作流程
- en: Like many tools, Docker strongly encourages a particular workflow. It’s a very
    enabling workflow that maps well to how many companies are organized, but it’s
    probably a little different than what you or your team are doing now. Having adapted
    our own organizations’ workflows to the Docker approach, we can confidently say
    that this is a change that can have a wide-reaching positive impact on many teams
    in your organization. If the workflow is implemented well, it can help you realize
    the promise of reduced communication overhead between teams.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多工具一样，Docker 强烈推荐一种特定的工作流。这是一种非常有效的工作流，非常适合许多公司的组织方式，但可能与你或你的团队目前的做法有所不同。通过将我们自己组织的工作流程适应
    Docker 方法，我们可以自信地说，这是对你组织中许多团队产生广泛积极影响的一种改变。如果工作流程实施得当，它可以帮助你实现减少团队间沟通开销的承诺。
- en: Revision Control
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修订控制
- en: The first thing that Docker gives you out of the box is two forms of revision
    control. One of them is used to track the filesystem layers that each Docker image
    is comprised of, and the other is a tagging system for those images.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供的第一个功能是两种形式的修订控制。其中一种用于跟踪每个 Docker 镜像所包含的文件系统层，另一种是针对这些镜像的标记系统。
- en: Filesystem layers
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件系统层
- en: Linux containers are made up of stacked filesystem layers, each identified by
    a unique hash, where each new set of changes made during the build process is
    laid on top of the previous changes. That’s great because it means that when you
    do a new build, you only have to rebuild the layers that follow the change you’re
    deploying. This saves time and bandwidth because containers are shipped around
    as layers, and you don’t have to ship layers that a server already has stored.
    If you’ve done deployments with many classic deployment tools, you know that you
    can end up shipping hundreds of megabytes of the same data to a server over and
    over with each deployment. That’s incredibly inefficient, and worse, you can’t
    be sure exactly what changed between deployments. Because of the layering effect,
    and because Linux containers include all of the application dependencies, with
    Docker you can be more confident about the changes that you are shipping to production.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器由堆叠的文件系统层组成，每一层由唯一的哈希标识，构建过程中的每组新变更都叠加在先前的变更之上。这样做的好处在于，当你进行新的构建时，只需要重建跟随你部署变更的层。这样可以节省时间和带宽，因为容器以层的形式进行传输，你无需传输服务器已存储的层。如果你使用过许多传统部署工具进行部署，你会知道每次部署都可能重复向服务器传输数百兆相同的数据。这非常低效，更糟糕的是，你不能确定各个部署之间到底有什么变化。由于分层效应以及
    Linux 容器包含所有应用程序依赖项的特性，使用 Docker，你可以更加自信地发布变更到生产环境。
- en: To simplify this a bit, remember that a Docker image contains everything required
    to run your application. If you change one line of code, you certainly don’t want
    to waste time rebuilding every dependency that your code requires into a new image.
    Instead, by leveraging the build cache, Docker can ensure that only the layers
    affected by the code change are rebuilt.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，一个 Docker 镜像包含运行你的应用程序所需的所有内容。如果你修改了一行代码，肯定不希望浪费时间重新构建每个依赖项进入新的镜像中。通过利用构建缓存，Docker
    可以确保只重新构建受代码更改影响的层。
- en: Image tags
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜像标签
- en: 'The second kind of revision control offered by Docker makes it easy to answer
    an important question: what was the previous version of the application that was
    deployed? That’s not always easy to answer. There are a lot of solutions for non-containerized
    applications, from Git tags for each release, to deployment logs, to tagged builds
    for deployment, and many more. If you’re coordinating your deployment with [Capistrano](https://capistranorb.com),
    for example, it will handle this for you by keeping a set number of previous releases
    on the server and then using symlinks to make one of them the current release.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供的第二种修订控制方式使得回答一个重要问题变得简单：之前部署的应用程序版本是什么？这并不总是容易回答的问题。对于非容器化应用程序，有许多解决方案，从为每个发布创建
    Git 标签，到部署日志，到带有标记的构建以供部署使用等等。例如，如果你正在使用 [Capistrano](https://capistranorb.com)
    协调部署，它会通过在服务器上保留一定数量的先前版本，并使用符号链接将其中一个设为当前版本来处理这个问题。
- en: 'But what you find in any scaled production environment is that each application
    has a unique way of handling deployment revisions. Many of them do the same thing,
    but some may be different. Worse, in heterogeneous language environments, the
    deployment tools are often entirely different between applications, and very little
    is shared. So the question “What was the previous version?” can have many answers
    depending on whom you ask and which application you’re referring to. Docker has
    a built-in mechanism for handling this: image tagging a standard build step. You
    can easily leave multiple revisions of your application on the server so that
    performing a rollback is trivial. This is not rocket science, and it’s not functionality
    that is hard to find in other deployment tooling, but with container images, it
    can easily be made standard across all of your applications, and everyone can
    have the same expectations about how things will be tagged for all applications.
    This makes communication easier between teams, and it makes tooling much simpler
    because there is one source of truth for application releases.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但在任何规模化生产环境中，每个应用程序都有处理部署修订版的独特方式。其中许多应用程序做同样的事情，但有些可能不同。更糟糕的是，在异构语言环境中，应用程序之间的部署工具通常完全不同，并且很少共享。因此，“上一个版本是什么？”这个问题可能会因询问的人和所指的应用程序而有不同的答案。Docker有一个内置机制来处理这个问题：使用镜像标签作为标准构建步骤。您可以轻松地在服务器上保留多个应用程序修订版，因此进行回滚变得微不足道。这不是火箭科学，也不是在其他部署工具中难以找到的功能，但是使用容器镜像，可以轻松地在所有应用程序中标准化，每个人都可以对应用程序的标记有相同的期望。这使得团队之间的沟通更容易，工具更简单，因为应用发布有一个真正的来源。
- en: Warning
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'In many examples online and in this book, you will see people use the `latest`
    tag for a container image. This is useful when you’re getting started and when
    you’re writing examples, as it will always grab the most recent build of an image.
    But since this is a floating tag, it is a really bad idea to use `latest` in most
    production workflows, as your dependencies can get updated out from under you,
    and it is impossible to roll back to `latest` because the old version is no longer
    the one tagged `latest`. It also makes it hard to verify if the same image is
    running on different servers. The rule of thumb is: don’t use the `latest` tag
    in production. It’s not even a good idea to use the `latest` tag from upstream
    images, for the same reasons.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多在线示例和本书中，您会看到人们为容器镜像使用`latest`标签。当您刚开始使用和编写示例时，这很有用，因为它始终会获取最新构建的镜像。但是由于这是一个浮动标签，在大多数生产工作流程中使用`latest`是一个非常糟糕的主意，因为您的依赖项可能会在您不知情的情况下更新，而且无法回滚到`latest`，因为旧版本不再是标记为`latest`的版本。它还使得很难验证是否在不同的服务器上运行相同的镜像。经验法则是：在生产环境中不要使用`latest`标签。甚至从上游镜像使用`latest`标签也不是一个好主意，原因如上。
- en: It is highly recommended that you tag your CI/CD builds with something that
    uniquely identifies the exact source code commit that was used to build them.
    In a `git` workflow, this could be the git hash related to the commit. Once you
    are ready to release an image, the recommendation is that you use [semantic versioning](https://semver.org)
    and provide your image with tags, like 1.4.3, 2.0.0, etc.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您使用能够唯一标识用于构建的确切源代码提交的东西来标记您的CI/CD构建。在`git`工作流程中，这可以是与提交相关的git哈希。一旦您准备释放一个镜像，建议使用[语义化版本](https://semver.org)为您的镜像提供标签，如1.4.3、2.0.0等。
- en: Pinning versions requires a bit more work to keep them current, but it will
    also prevent many unfortunate and poorly timed surprises during builds and deployments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定版本需要更多的工作来保持其更新，但它也会防止在构建和部署过程中发生许多不幸和不合时宜的惊喜。
- en: Building
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建
- en: Building applications is a black art in many organizations, where a few people
    know all the levers to pull and knobs to turn to spit out a well-formed, shippable
    artifact. Part of the heavy cost of getting a new application deployed is getting
    the build just right. Docker doesn’t solve all of these problems, but it does
    provide a standardized tool configuration and toolset for builds. That makes it
    a lot easier for people to learn how to build your applications and to get new
    builds up and running.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多组织中，构建应用程序是一门黑艺术，只有少数人知道所有操作和参数来生成一个格式良好、可交付的工件。部署新应用程序的重大成本之一是确保构建正确。Docker并不能解决所有这些问题，但它确实提供了标准化的工具配置和工具集来进行构建。这使得人们更容易学习如何构建您的应用程序，并使新构建能够快速运行起来。
- en: The Docker command-line tool contains a `build` flag that will consume a *Dockerfile*
    and produce a Docker image. Each command in a *Dockerfile* generates a new layer
    in the image, so it’s easy to reason about what the build is going to do by looking
    at the *Dockerfile* itself. The great part of all of this standardization is that
    any engineer who has worked with a *Dockerfile* can dive right in and modify the
    build of any other application. Because the Docker image is a standardized artifact,
    all of the tooling behind the build will be the same regardless of the development
    language or base image that is being used or the number of layers needed. The
    *Dockerfile* is usually checked into a revision control system, which also means
    that tracking changes to the build is simplified. Modern multistage Docker builds
    also allow you to define the build environment separately from the final artifact
    image. This provides huge “configure ability” for your build environment just
    like you’d have for a production container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令行工具包含一个`build`标志，它将消耗一个*Dockerfile*并生成一个Docker镜像。*Dockerfile*中的每个命令都会在镜像中生成一个新的层，因此通过查看*Dockerfile*本身，很容易理解构建将要做什么。所有这些标准化的重要部分是，任何曾经使用过*Dockerfile*的工程师都可以直接参与并修改任何其他应用程序的构建。由于Docker镜像是一个标准化的构件，无论使用的开发语言或基础镜像是什么，或者需要多少层次，构建背后的所有工具都是相同的。*Dockerfile*通常被提交到版本控制系统中，这也意味着跟踪构建的变化变得简单。现代的多阶段Docker构建还允许您将构建环境与最终构件镜像分开定义，这就像为生产容器定义“配置能力”一样提供了巨大的便利性。
- en: Many Docker builds are a single invocation of the `docker image build` command
    and generate a single artifact, the container image. Because it’s usually the
    case that most of the logic about the build is wholly contained in the *Dockerfile*,
    it’s easy to create standard build jobs for any team to use in build systems like
    [Jenkins](https://jenkins-ci.org). As a further standardization of the build process,
    many companies—eBay, for example—have standardized Linux containers to do the
    image builds from a *Dockerfile*. SaaS build offerings like [Travis CI](https://travis-ci.com)
    and [CodeShip](https://codeship.com) also have first-class support for Docker
    builds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Docker构建只需一次调用`docker image build`命令并生成单个构件，即容器镜像。因为通常情况下构建的大部分逻辑完全包含在*Dockerfile*中，所以很容易为任何团队在构建系统（如[Jenkins](https://jenkins-ci.org)）中创建标准构建任务。作为进一步的构建流程标准化，许多公司（例如eBay）已经将Linux容器标准化为从*Dockerfile*进行镜像构建的工具。像[Travis
    CI](https://travis-ci.com)和[CodeShip](https://codeship.com)这样的SaaS构建服务也全面支持Docker构建。
- en: It is also possible to automate the creation of multiple images that support
    different underlying compute architectures, like x86 and ARM, by utilizing the
    newer [BuildKit](https://github.com/moby/buildkit) support in Docker.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化创建支持不同底层计算架构（如x86和ARM）的多个镜像也是可能的，这是通过在Docker中利用新的[BuildKit](https://github.com/moby/buildkit)支持实现的。
- en: Testing
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: While Docker itself does not include a built-in framework for testing, the way
    containers are built lends some advantages to testing with Linux containers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker本身不包括用于测试的内置框架，但构建容器的方式为使用Linux容器进行测试带来了一些优势。
- en: Testing a production application can take many forms, from unit testing to full
    integration testing in a semi-live environment. Docker facilitates better testing
    by guaranteeing that the artifact that passed testing will be the one that ships
    to production. This can be guaranteed because we can either use the Docker SHA
    for the container, or a custom tag to make sure we’re consistently shipping the
    same version of the application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 测试生产应用程序可以采用多种形式，从单元测试到在半实时环境中进行完整集成测试。Docker通过保证测试通过的构件就是部署到生产环境的构件来促进更好的测试。这可以得到保证，因为我们可以使用Docker
    SHA或自定义标签，以确保我们始终将应用程序的相同版本一致地部署到生产环境。
- en: Since, by design, containers include all of their dependencies, tests run on
    containers are very reliable. If a unit test framework says tests were successful
    against a container image, you can be sure that you will not experience a problem
    with the versioning of an underlying library at deployment time, for example.
    That’s not easy with most other technologies, and even Java WAR (Java Web application
    ARchive) files, for example, don’t include testing of the application server itself.
    That same Java application deployed in a Linux container will generally also include
    an application server like Tomcat, and the whole stack can be smoke tested before
    shipping to production.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器设计上包含了所有依赖关系，因此在容器上运行的测试非常可靠。如果一个单元测试框架表示在容器镜像上测试成功，你可以确信，在部署时不会出现例如基础库版本问题的情况。这对大多数其他技术来说并不容易，甚至
    Java WAR 文件，例如，也不包括对应用服务器本身的测试。同样的 Java 应用在 Linux 容器中部署时通常也会包含像 Tomcat 这样的应用服务器，整个堆栈可以在进入生产之前进行烟火测试。
- en: A secondary benefit of shipping applications in Linux containers is that in
    places where there are multiple applications that talk to one another remotely
    via something like an API, developers of one application can easily develop against
    a version of the other service that is currently tagged for the environment they
    require, like production or staging. Developers on each team don’t have to be
    experts in how the other service works or is deployed just to do development on
    their own application. If you expand this to a service-oriented architecture with
    innumerable microservices, Linux containers can be a real lifeline to developers
    or QA engineers who need to wade into the swamp of inter-microservice API calls.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 容器中运行应用程序的另一个好处是，在那些通过类似 API 远程通信的多个应用程序的地方，一个应用程序的开发人员可以轻松地针对当前标记为所需环境（如生产或分段）的另一个服务版本进行开发。每个团队的开发人员不必成为其他服务如何工作或部署的专家，只需开发自己的应用程序即可。如果将这个扩展到具有无数微服务的服务导向架构，Linux
    容器对于需要处理微服务间 API 调用的开发人员或 QA 工程师来说是一个真正的生命线。
- en: A common practice in organizations that run Linux containers in production is
    for automated integration tests to pull down a versioned set of Linux containers
    for different services, matching the current deployed versions. The new service
    can then be integration-tested against the very same versions it will be deployed
    alongside. Doing this in a heterogeneous language environment would previously
    have required a lot of custom tooling, but it becomes reasonably simple to implement
    because of the standardization provided by Linux containers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行 Linux 容器的组织中，一个常见的做法是进行自动化集成测试，拉取一组经过版本化的不同服务的 Linux 容器，与当前部署的版本匹配。新服务随后可以与将要部署的完全相同版本进行集成测试。在异构语言环境中，这样做以前需要大量定制工具支持，但由于
    Linux 容器提供的标准化，现在实现起来相当简单。
- en: Packaging
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包
- en: 'Docker builds produce an image that can be treated as a single build artifact,
    although technically they may consist of multiple filesystem layers. No matter
    which language your application is written in or which distribution of Linux you
    run it on, you get a layered Docker image as the result of your build. And it
    is all built and handled by the Docker tooling. That build image is the shipping
    container metaphor that Docker is named for: a single, transportable unit that
    universal tooling can handle, regardless of what it contains. Like oceanic cargo
    ships that package everything into steel containers, your Docker tooling will
    only ever have to deal with one kind of package: the Docker image. That’s powerful,
    because it’s a huge facilitator of tool reuse between applications, and it means
    that someone else’s off-the-shelf container tools will work with your build images.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 构建生成的镜像可以看作是一个单一的构建产物，尽管在技术上它们可能由多个文件系统层组成。无论你的应用程序使用哪种语言编写，或者在哪个 Linux
    发行版上运行，构建的结果都是一个分层的 Docker 镜像。所有这些都由 Docker 工具处理和构建。这种构建镜像就像 Docker 命名的船运集装箱隐喻：一个单一的、可传输的单元，通用工具可以处理，无论它包含什么内容。这是非常强大的，因为它大大促进了应用程序之间工具重用，意味着别人的现成容器工具也能与你的构建镜像一起工作。
- en: Applications that traditionally took a lot of custom configuration to deploy
    onto a new host or development system become very portable with Docker. Once a
    container is built, it can easily be deployed on any system with a running Docker
    server on the same architecture.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上需要大量定制配置才能部署到新主机或开发系统的应用，在 Docker 上变得非常可移植。一旦构建了容器，它就可以轻松地部署到具有相同架构上运行 Docker
    服务器的任何系统上。
- en: Deploying
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: Deployments are handled by so many kinds of tools in different shops that it
    would be impossible to list them here. Some of these tools include shell scripting,
    [Capistrano](https://capistranorb.com), [Fabric](https://www.fabfile.org), [Ansible](https://www.ansible.com),
    and in-house custom tooling. In our experience with multiteam organizations, there
    are usually one or two people on each team who know the magical incantation to
    get deployments to work. When something goes wrong, the team is dependent on them
    to get it running again. As you probably expect by now, Docker makes most of that
    a nonissue. The built-in tooling supports a simple, one-line deployment strategy
    to get a build onto a host and up and running. The standard Docker client handles
    deploying only to a single host at a time, but there is a large array of tools
    available that make it easy to deploy into a cluster of Docker or other compatible
    Linux container hosts. Because of the standardization Docker provides, your build
    can be deployed into any of these systems, with low complexity on the part of
    the development teams.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 部署由不同商店中的许多种工具处理，这里不可能列出它们。其中一些工具包括 shell 脚本，[Capistrano](https://capistranorb.com)，[Fabric](https://www.fabfile.org)，[Ansible](https://www.ansible.com)
    和内部定制工具。根据我们与多团队组织的经验，通常每个团队都有一两个人知道如何进行部署以使其正常工作。一旦出现问题，团队就依赖于他们来让它再次运行起来。正如您现在可能期望的那样，Docker
    大部分时间都不成问题。内置工具支持简单的一行部署策略，以将构建部署到主机并启动。标准的 Docker 客户端一次仅处理到一个主机的部署，但有大量的工具可用，使得在
    Docker 集群或其他兼容的 Linux 容器主机中部署变得非常简单。由于 Docker 提供的标准化，您的构建可以部署到这些系统中的任何一个，开发团队的复杂性很低。
- en: The Docker Ecosystem
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 生态系统
- en: Over the years, a wide community has formed around Docker, driven by both developers
    and system administrators. Like the DevOps movement, this has facilitated better
    tools by applying code to operations problems. Where there are gaps in the tooling
    provided by Docker, other companies and individuals have stepped up to the plate.
    Many of these tools are also open source. That means they are expandable and can
    be modified by any other company to fit its needs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，围绕 Docker 形成了一个广泛的社区，由开发人员和系统管理员共同推动。类似于 DevOps 运动，这促进了通过将代码应用于运维问题来改进工具。在
    Docker 提供的工具中存在空白的地方，其他公司和个人也站了出来。其中许多工具也是开源的。这意味着它们是可扩展的，可以被任何其他公司修改以适应其需求。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Docker is a commercial company that has contributed much of the core Docker
    source code to the open source community. Companies are strongly encouraged to
    join the community and contribute back to the open source efforts. If you are
    looking for supported versions of the core Docker tools, you can find out more
    about its offerings at the [Docker website](https://www.docker.com/support).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是一家商业公司，已将其大部分核心 Docker 源代码贡献给开源社区。强烈鼓励公司加入社区，并回馈开源努力。如果您正在寻找核心 Docker
    工具的支持版本，可以在[Docker 网站](https://www.docker.com/support)了解更多信息。
- en: Orchestration
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编排
- en: The first important category of tools that add functionality to the core Docker
    distribution and Linux container experience contains orchestration and mass deployment
    tools. Early mass deployment tools like [New Relic’s Centurion](https://github.com/newrelic/centurion),
    [Spotify’s Helios](https://github.com/spotify/helios), and the [Ansible Docker
    tooling](https://oreil.ly/V8X_f)^([1](ch02.html#idm46803169305904)) still work
    largely like traditional deployment tools but leverage the container as the distribution
    artifact. They take a fairly simple, easy-to-implement approach. You get a lot
    of the benefits of Docker without much complexity, but many of these tools have
    been replaced by more robust and flexible tools, like Kubernetes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 核心发行版和 Linux 容器体验的第一个重要工具类别是增加功能的工具，包括编排和大规模部署工具。早期的大规模部署工具如 [New Relic’s
    Centurion](https://github.com/newrelic/centurion)，[Spotify’s Helios](https://github.com/spotify/helios)，以及
    [Ansible Docker 工具集](https://oreil.ly/V8X_f)^([1](ch02.html#idm46803169305904))
    仍然像传统部署工具一样工作，但利用容器作为分发工件。它们采用相对简单、易于实施的方法。你可以获得 Docker 的许多优点，而不增加太多复杂性，但这些工具中的许多已被更强大和更灵活的工具（比如
    Kubernetes）取代。
- en: Fully automatic schedulers like [Kubernetes](https://kubernetes.io) or [Apache
    Mesos](https://mesos.apache.org) with the [Marathon scheduler](https://mesosphere.github.io/marathon)
    are more powerful options that take nearly complete control of a pool of hosts
    on your behalf. Other commercial entries are widely available, such as [HashiCorp’s
    Nomad](https://www.nomadproject.io), [Mesosphere’s DC/OS (Datacenter Operating
    System)](https://dcos.io), and [Rancher](https://rancher.com).^([2](ch02.html#idm46803169292128))
    The ecosystems of both free and commercial options continue to grow rapidly.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 像 [Kubernetes](https://kubernetes.io) 或 [Apache Mesos](https://mesos.apache.org)
    与 [Marathon 调度器](https://mesosphere.github.io/marathon) 这样的全自动调度器是更强大的选择，它们几乎完全控制了一组主机的池。其他商业产品也广泛可用，如
    [HashiCorp’s Nomad](https://www.nomadproject.io)，[Mesosphere’s DC/OS（数据中心操作系统）](https://dcos.io)，以及
    [Rancher](https://rancher.com)^([2](ch02.html#idm46803169292128))。自由和商业选项的生态系统继续快速增长。
- en: Immutable atomic hosts
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变的原子主机
- en: One additional idea that you can leverage to enhance your Docker experience
    is immutable atomic hosts. Traditionally, servers and virtual machines are systems
    that an organization will carefully assemble, configure, and maintain to provide
    a wide variety of functionality that supports a broad range of usage patterns.
    Updates must often be applied via nonatomic operations, and there are many ways
    in which host configurations can diverge and introduce unexpected behavior into
    the system. Most running systems are patched and updated in place in today’s world.
    Conversely, in the world of software deployments, most people deploy an entire
    copy of their application, rather than trying to apply patches to a running system.
    Part of the appeal of containers is that they help make applications even more
    atomic than traditional deployment models.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以利用来增强 Docker 使用体验的想法是不可变的原子主机。传统上，服务器和虚拟机是组织精心组装、配置和维护的系统，以提供支持广泛使用模式的各种功能。更新通常必须通过非原子操作应用，主机配置可能会分歧，导致系统出现意外行为。在今天的世界中，大多数正在运行的系统是通过就地打补丁和更新来更新的。相比之下，在软件部署的世界中，大多数人部署整个应用的完整副本，而不是尝试向运行中的系统应用补丁。容器的吸引力部分在于它们帮助使应用比传统部署模型更加原子化。
- en: What if you could extend that core container pattern down into the operating
    system? Instead of relying on configuration management to try to update, patch,
    and coalesce changes to your OS components, what if you could simply pull down
    a new, thin OS image and reboot the server? And then if something breaks, easily
    roll back to the exact image you were previously using?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能将核心容器模式扩展到操作系统中，会怎样？与其依赖配置管理尝试更新、打补丁和合并 OS 组件的变更，不如简单地下载一个新的轻量级 OS 镜像并重新启动服务器。然后，如果出现问题，可以轻松地回滚到之前使用的确切镜像。
- en: This is one of the core ideas behind Linux-based atomic host distributions,
    like [Red Hat’s Fedora CoreOS](https://getfedora.org/en/coreos), [Bottlerocket
    OS](https://github.com/bottlerocket-os/bottlerocket), and others. Not only should
    you be able to easily tear down and redeploy your applications, but the same philosophy
    should apply for the whole software stack. This pattern helps provide very high
    levels of consistency and resilience to the whole stack.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基于Linux的原子主机发行版（例如[红帽的Fedora CoreOS](https://getfedora.org/en/coreos)，[Bottlerocket
    OS](https://github.com/bottlerocket-os/bottlerocket)等）的核心理念之一。不仅应该能够轻松拆卸和重新部署应用程序，而且整个软件堆栈也应该适用相同的哲学。这种模式有助于为整个堆栈提供非常高的一致性和韧性。
- en: Some of the typical characteristics of an immutable or [atomic host](https://gist.github.com/jzb/0f336c6f23a0ba145b0a)
    are a minimal footprint, a design focused on supporting Linux containers and Docker,
    and atomic OS updates and rollbacks that can easily be controlled via multihost
    orchestration tools on both bare-metal and common virtualization platforms.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变或[原子主机](https://gist.github.com/jzb/0f336c6f23a0ba145b0a)的典型特征包括最小的足迹、专注于支持Linux容器和Docker的设计，以及可以通过多主机编排工具在裸金属和常见虚拟化平台上轻松控制的原子操作系统更新和回滚。
- en: In [Chapter 3](ch03.html#installing_docker), we will discuss how you can easily
    use these immutable hosts in your development process. If you are also using these
    hosts as deployment targets, this process creates a previously unheard-of amount
    of software stack symmetry between your development and production environments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](ch03.html#installing_docker)中，我们将讨论如何在开发过程中轻松使用这些不可变主机。如果您还将这些主机用作部署目标，则此过程在您的开发和生产环境之间创造了前所未有的软件堆栈对称性。
- en: Additional tools
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加工具
- en: Docker is not just a standalone solution. It has a massive feature set, but
    there is always a case where someone needs more than it can deliver on its own.
    There is a wide ecosystem of tools to either improve or augment Docker’s functionality.
    Some good production tools leverage the Docker API, like [Prometheus](https://prometheus.io)
    for monitoring and [Ansible](https://www.ansible.com) for simple orchestration.
    Others leverage Docker’s plug-in architecture. Plug-ins are executable programs
    that conform to a specification for receiving and returning data to Docker.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Docker不仅仅是一个独立的解决方案。它拥有庞大的功能集，但总会有一些情况需要比它本身提供的更多。有一个广泛的工具生态系统，可以改进或增强Docker的功能。一些优秀的生产工具利用Docker
    API，比如[Prometheus](https://prometheus.io)用于监控和[Ansible](https://www.ansible.com)用于简单编排。其他工具利用了Docker的插件架构。插件是符合规范的可执行程序，用于接收和返回数据给Docker。
- en: Warning
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Many of the Docker plug-ins are considered legacy and are being replaced with
    better approaches. Make sure that you perform adequate research before deciding
    on a plug-in that you are going to utilize, to ensure that it is the best option
    and is not going to be unsupported or quickly replaced.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Docker插件被认为是遗留的，并正在被更好的方法取代。在决定要使用的插件之前，请务必进行充分的研究，以确保它是最佳选项，并且不会不受支持或迅速被替换。
- en: There are many more good tools that either talk to the API or run as plug-ins.
    Many of these have sprung up to make life with Docker easier on the various cloud
    providers. These help with seamless integration between Docker and the cloud.
    As the community continues to innovate, the ecosystem continues to grow. There
    are new solutions and tools available in this space on an ongoing basis. If you
    find you are struggling with something in your environment, look to the ecosystem!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他优秀的工具，它们要么与API交互，要么作为插件运行。这些工具在各种云提供商上使与Docker的集成更加轻松。随着社区的不断创新，生态系统也在不断增长。在这个领域，有新的解决方案和工具不断涌现。如果您发现在您的环境中遇到问题，请查看生态系统！
- en: Wrap-Up
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'There you have it: a quick tour through Docker. We’ll return to this discussion
    later on with a slightly deeper dive into the architecture of Docker, more examples
    of how to use the community tooling, and an exploration of some of the thinking
    behind designing robust container platforms. But you’re probably itching to try
    it all out, so in the next chapter, we’ll get Docker installed and running.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Docker的快速介绍。稍后我们将深入探讨Docker的架构，介绍更多社区工具的使用示例，并探索设计强大的容器平台背后的一些思考。但您可能已经迫不及待想要尝试它们了，所以下一章我们将安装并运行Docker。
- en: '^([1](ch02.html#idm46803169305904-marker)) Full URL: [*https://docs.ansible.com/ansible/latest/collections/community/docker/docsite/scenario_guide.html#ansible-collections-community-docker-docsite-scenario-guide*](https://docs.ansible.com/ansible/latest/collections/community/docker/docsite/scenario_guide.html#ansible-collections-community-docker-docsite-scenario-guide)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm46803169305904-marker)) 完整网址：[*https://docs.ansible.com/ansible/latest/collections/community/docker/docsite/scenario_guide.html#ansible-collections-community-docker-docsite-scenario-guide*](https://docs.ansible.com/ansible/latest/collections/community/docker/docsite/scenario_guide.html#ansible-collections-community-docker-docsite-scenario-guide)
- en: ^([2](ch02.html#idm46803169292128-marker)) Some of these commercial offerings
    have free editions of their platforms.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm46803169292128-marker)) 其中一些商业产品提供其平台的免费版本。
