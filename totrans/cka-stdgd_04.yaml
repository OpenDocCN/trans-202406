- en: Chapter 4\. Scheduling and Tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scheduling portion of the CKA focuses on the effects of defining resource
    boundaries when evaluated by the Kubernetes scheduler. The default runtime behavior
    of the scheduler can also be modified by defining node affinity rules, as well
    as taints and tolerations. Of those concepts, you are expected only to understand
    the nuances of resource boundaries and their effect on the scheduler in different
    scenarios. Finally, this domain of the curriculum mentions high-level knowledge
    of manifest management and templating tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource boundaries for Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative and declarative manifest management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common templating tools like Kustomize, `yq`, and Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding How Resource Limits Affect Pod Scheduling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Kubernetes cluster can consist of multiple nodes. Depending on a variety of
    rules (e.g., [node selectors](https://oreil.ly/m5eep), [node affinity](https://oreil.ly/9Gf7E),
    [taints and tolerations](https://oreil.ly/2SkeO)), the Kubernetes scheduler decides
    which node to pick for running the workload. The CKA exam doesn’t ask you to understand
    the scheduling concepts mentioned previously, but it would be helpful to have
    a rough idea how they work on a high level.
  prefs: []
  type: TYPE_NORMAL
- en: One metric that comes into play for workload scheduling is the resource *request*
    defined by the containers in a Pod. Commonly used resources that can be specified
    are CPU and memory. The scheduler ensures that the node’s resource capacity can
    fulfill the resource requirements of the Pod. More specifically, the scheduler
    determines the sum of resource requests per type across all containers defined
    in the Pod and compares them with the node’s available resources. [Figure 4-1](#pod_scheduling)
    illustrates the scheduling process based on the resource requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0401](Images/ckas_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Pod scheduling based on resource requests
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Defining Container Resource Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each container in a Pod can define its own resource requests. [Table 4-1](#options_resource_requests)
    describes the available options including an example value.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Options for resource requests
  prefs: []
  type: TYPE_NORMAL
- en: '| YAML Attribute | Description | Example Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.cpu` | CPU resource type | `500m` (five
    hundred millicpu) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  prefs: []
  type: TYPE_TB
- en: Kubernetes uses resource units for resource types that deviate from standard
    resource units like megabytes and gigabytes. Explaining all intricacies of those
    units goes beyond the scope this book, but you can read up on the details in the
    [documentation](https://oreil.ly/bweuT).
  prefs: []
  type: TYPE_NORMAL
- en: To make the use of those resource requests transparent, we’ll take a look at
    an example definition. The Pod YAML manifest shown in [Example 4-1](#setting_container_resource_requests)
    defines two containers, each with their own resource requests. Any node that is
    allowed to run the Pod needs to be able to support a minimum memory capacity of
    320Mi and 1250m CPU, the sum of resources across both containers.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Setting container resource requests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, we are dealing with a Minikube Kubernetes cluster consisting
    of three nodes, one control plane node, and two worker nodes. The following command
    lists all nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we’ll create the Pod from the YAML manifest. The scheduler
    places the Pod on the node named `minikube-m03`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon further inspection of the node, you can inspect its maximum capacity,
    how much of this capacity is allocatable, and the memory requests of the Pods
    scheduled on the node. The following command lists the information and condenses
    the output to the relevant bits and pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It’s certainly possible that a Pod cannot be scheduled due to insufficient resources
    available on the nodes. In those cases, the event log of the Pod will indicate
    this situation with the reasons `PodExceedsFreeCPU` or `PodExceedsFreeMemory`.
    For more information on how to troubleshoot and resolve this situation, see the
    relevant [section in the documentation](https://oreil.ly/ZzK0B).
  prefs: []
  type: TYPE_NORMAL
- en: Defining Container Resource Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another metric you can set for a container are its resource *limits*. Resource
    limits ensure that the container cannot consume more than the allotted resource
    amounts. For example, you could express that the application running in the container
    should be constrained to 1000m of CPU and 512Mi of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the container runtime used by the cluster, exceeding any of the
    allowed resource limits results in a termination of the application process running
    in the container or results in the system preventing the allocation of resources
    beyond the limits altogether. For an in-depth discussion on how resource limits
    are treated by the container runtime Docker, see the [documentation](https://oreil.ly/szUaM).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-2](#options_resource_limits) describes the available options including
    an example value.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. Options for resource limits
  prefs: []
  type: TYPE_NORMAL
- en: '| YAML Attribute | Description | Example Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.cpu` | CPU resource type | `500m` (500
    millicpu) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  prefs: []
  type: TYPE_TB
- en: '[Example 4-2](#setting_container_resource_limits) shows the definition of limits
    in action. Here, the container named `business-app` cannot use more than 512Mi
    of memory and 2000m of CPU. The container named `ambassador` defines a limit of
    128Mi of memory and 500m of CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. Setting container resource limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume that the Pod was scheduled on the node `minikube-m03`. Describing the
    node’s details reveals that the CPU and memory limits took effect. But there’s
    more. Kubernetes automatically assigns the same amount of resources for the requests
    if you only define the limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Defining Container Resource Requests and Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s recommended practice that you specify resource requests and limits for
    every container. Determining those resource expectations is not always easy, specifically
    for applications that haven’t been exercised in a production environment yet.
    Load testing the application early on during the development cycle can help with
    analyzing the resource needs. Further adjustments can be made by monitoring the
    application’s resource consumption after deploying it to the cluster. [Example 4-3](#settings_container_resource_requests_limits)
    combines resource requests and limits in a single YAML manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. Setting container resource requests and limits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you can see the different settings for resource requests and limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Managing Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes objects can be created, modified, and deleted by using imperative
    `kubectl` commands or by running a `kubectl` command against a configuration file
    declaring the desired state of an object, a so-called manifest. The primary definition
    language of a manifest is YAML, though you can opt for JSON, which is the less
    widely adopted format among the Kubernetes community. It’s recommended that development
    teams commit and push those configuration files to version control repositories
    as it will help with tracking and auditing changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling an application in Kubernetes often requires a set of supporting objects,
    each of which can have their own manifest. For example, you may want to create
    a Deployment that runs the application on five Pods, a ConfigMap to inject configuration
    data as environment variables, and a Service for exposing network access.
  prefs: []
  type: TYPE_NORMAL
- en: This section primarily focuses on the declarative object management support
    with the help of manifests. For a deeper discussion on the imperative support,
    see the relevant portions in the [documentation](https://oreil.ly/Slw0h). Furthermore,
    we’ll touch on tools like Kustomize and Helm to give you an impression of their
    benefits, capabilities, and workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative Object Management Using Configuration Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declarative object management requires one or several configuration files in
    the format of YAML or JSON describing the desired state of an object. You create,
    update, and delete objects with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create new objects, run the `apply` command by pointing to a file, a directory
    of files, or a file referenced by an HTTP(S) URL using the `-f` option. If one
    or many of the objects already exist, the command will synchronize the changes
    made to the configuration with the live object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the functionality, we’ll assume the following directories and
    configuration files. The following commands create objects from a single file,
    from all files within a directory, and from all files in a directory recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an object from a single file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating objects from multiple files within a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating objects from a recursive directory tree containing files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating objects from a file referenced by an HTTP(S) URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` command keeps track of the changes by adding or modifying the annotation
    with the key `kubectl.kubernetes.io/last-applied-configuration`. You can find
    an example of the annotation in the output of the `get pod` command here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Updating objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Updating an existing object is done with the same `apply` command. All you need
    to do is to change the configuration file and then run the command against it.
    [Example 4-4](#modified_configuration_file_deployment) modifies the existing configuration
    of a Deployment in the file `nginx-deployment.yaml`. We added a new label with
    the key `team` and changed the number of replicas from 3 to 5.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. Modified configuration file for a Deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command applies the changed configuration file. As a result,
    the number of Pods controlled by the underlying ReplicaSet is 5\. The Deployment’s
    annotation `kubectl.kubernetes.io/last-applied-configuration` reflects the latest
    change to the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Deleting objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While there is a way to delete objects using the `apply` command by providing
    the options `--prune -l <labels>`, it is recommended to delete an object using
    the `delete` command and point it to the configuration file. The following command
    deletes a Deployment and the objects it controls (ReplicaSet and Pods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Declarative Object Management Using Kustomize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kustomize is a tool introduced with Kubernetes 1.14 that aims to make manifest
    management more convenient. It supports three different use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating manifests from other sources. For example, creating a ConfigMap and
    populating its key-value pairs from a properties file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding common configuration across multiple manifests. For example, adding a
    namespace and a set of labels for a Deployment and a Service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing and customizing a collection of manifests. For example, setting resource
    boundaries for multiple Deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The central file needed for Kustomize to work is the *kustomization file*. The
    standardized name for the file is `kustomization.yaml` and cannot be changed.
    A kustomization file defines the processing rules Kustomize works upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kustomize is fully integrated with `kubectl` and can be executed in two modes:
    rendering the processing output on the console or creating the objects. Both modes
    can operate on a directory, tarball, Git archive, or URL as long as they contain
    the kustomization file and referenced resource files:'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the produced output
  prefs: []
  type: TYPE_NORMAL
- en: 'The first mode uses the `kustomize` subcommand to render the produced result
    on the console but does not create the objects. This command works similar to
    the dry-run option you might know from the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Creating the objects
  prefs: []
  type: TYPE_NORMAL
- en: 'The second mode uses the `apply` command in conjunction with the `-k` command-line
    option to apply the resources processed by Kustomize, as explained in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The following sections demonstrate each of the use cases by a single example.
    For a full coverage on all possible scenarios, refer to the [documentation](https://oreil.ly/JUHXj)
    or the [Kustomize GitHub repository](https://oreil.ly/4MirA).
  prefs: []
  type: TYPE_NORMAL
- en: Composing Manifests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the core functionalities of Kustomize is to create a composed manifest
    from other manifests. Combining multiple manifests into a single one may not seem
    that useful by itself, but many of the other features described later will build
    upon this capability. Say you wanted to compose a manifest from a Deployment and
    a Service resource file. All you need to do is to place the resource files into
    the same folder as the kustomization file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The kustomization file lists the resources in the `resources` section, as shown
    in [Example 4-5](#kustomization_file_combining).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. A kustomization file combining two manifests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the `kustomize` subcommand renders the combined manifest containing
    all of the resources separated by three hyphens (`---`) to denote the different
    object definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Generating manifests from other sources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier in this chapter, we learned that ConfigMaps and Secrets can be created
    by pointing them to a file containing the actual configuration data for it. Kustomize
    can help with the process by mapping the relationship between the YAML manifest
    of those configuration objects and their data. Furthermore, we’ll want to inject
    the created ConfigMap and Secret in a Pod as environment variables. In this section,
    you will learn how to achieve this with the help of Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file and directory structure contains the manifest file for the
    Pod and the configuration data files we need for the ConfigMap and Secret. The
    mandatory kustomization file lives on the root level of the directory tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In `kustomization.yaml`, you can define that the ConfigMap and Secret object
    should be generated with the given name. The name of the ConfigMap is supposed
    to be `db-config`, and the name of the Secret is going to be `db-creds`. Both
    of the generator attributes, `configMapGenerator` and `secretGenerator`, reference
    an input file used to feed in the configuration data. Any additional resources
    can be spelled out with the `resources` attribute. [Example 4-6](#kustomization_file_configmap_secret)
    shows the contents of the kustomization file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6\. A kustomization file using a ConfigMap and Secret generator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Kustomize generates ConfigMaps and Secrets by appending a suffix to the name.
    You can see this behavior when creating the objects using the `apply` command.
    The ConfigMap and Secret can be referenced by name in the Pod manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This naming strategy can be configured with the attribute `generatorOptions`
    in the kustomization file. See the [documentation](https://oreil.ly/M7tlD) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also try the `kustomize` subcommand. Instead of creating the objects,
    the command renders the processed output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Adding common configuration across multiple manifests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application developers usually work on an application stack set comprised of
    multiple manifests. For example, an application stack could consist of a frontend
    microservice, a backend microservice, and a database. It’s common practice to
    use the same, cross-cutting configuration for each of the manifests. Kustomize
    offers a range of supported fields (e.g., namespace, labels, or annotations).
    Refer to the [documentation](https://oreil.ly/OyNbh) to learn about all supported
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next example, we’ll assume that a Deployment and a Service live in
    the same namespace and use a common set of labels. The namespace is called `persistence`
    and the label is the key-value pair `team: helix`. [Example 4-7](#kustomization_file_common_fields)
    illustrates how to set those common fields in the kustomization file.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7\. A kustomization file using a common field
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the referenced objects in the kustomization file, run the `apply`
    command. Make sure to create the `persistence` namespace beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML representation of the processed files looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Customizing a collection of manifests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kustomize can merge the contents of a YAML manifest with a code snippet from
    another YAML manifest. Typical use cases include adding security context configuration
    to a Pod definition or setting resource boundaries for a Deployment. The kustomization
    file allows for specifying different patch strategies like `patchesStrategicMerge`
    and `patchesJson6902`. For a deeper discussion on the differences between patch
    strategies, refer to the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-8](#kustomization_file_patch) shows the contents of a kustomization
    file that patches a Deployment definition in the file `nginx-deployment.yaml`
    with the contents of the file `security-context.yaml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8\. A kustomization file defining a patch
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The patch file shown in [Example 4-9](#path_yaml_manifest) defines a security
    context on the container-level for the Pod template of the Deployment. At runtime,
    the patch strategy tries to find the container named `nginx` and enhances the
    additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9\. The patch YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a patched Deployment definition, as shown in the output of the
    `kustomize` subcommand shown next. The patch mechanism can be applied to other
    files that require a uniform security context definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Common Templating Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in the previous section, Kustomize offers templating functionality.
    The Kubernetes ecosystem offers other solutions to the problem that we will discuss
    here. We will touch on the YAML processor `yq` and the templating engine Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Using the YAML Processor yq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tool `yq` is used to read, modify, and enhance the contents of a YAML file.
    This section will demonstrate all three use cases. For a detailed list of usage
    example, see the [GitHub repository](https://oreil.ly/ORZDV). During the CKA exam,
    you may be asked to apply those techniques though you are not expected to understand
    all intricacies of the tools at hand. The version of `yq` used to describe the
    functionality below is 4.2.1.
  prefs: []
  type: TYPE_NORMAL
- en: Reading values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reading values from an existing YAML file requires the use of a YAML path expression.
    A path expression allows you to deeply navigate the YAML structure and extract
    the value of an attribute you are searching for. [Example 4-10](#yaml_manifest_pod)
    shows the YAML manifest of a Pod that defines two environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10\. The YAML manifest of a Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To read a value, use the command `eval` or the short form `e`, provide the
    YAML path expression, and point it to the source file. The following two commands
    read the Pod’s name and the value of the second environment variable defined by
    a single container. Notice that the path expression needs to start with a mandatory
    dot character (`.`) to denote the root node of the YAML structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Modifying values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modifying an existing value is as easy as using the same command and adding
    the `-i` flag. The assignment of the new value to an attribute happens by assigning
    it to the path expression. The following command changes the second environment
    variable of the Pod YAML file to the value 1.6.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Merging YAML files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to Kustomize, `yq` can merge multiple YAML files. Kustomize is definitely
    more powerful and convenient to use; however, `yq` can come in handy for smaller
    projects. Say you wanted to merge the sidecar container definition shown in [Example 4-11](#yaml_manifest_container)
    into the Pod YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11\. The YAML manifest of a container definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The command to achieve this is `eval-all`. We won’t go into details given the
    multitude of configuration options for this command. For a deep dive, check the
    `yq` user manual on the [“Multiply (Merge)” operation](https://oreil.ly/2I6ir).
    The following command appends the sidecar container to the existing container
    array of the Pod manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Helm](https://helm.sh) is a templating engine and package manager for a set
    of Kubernetes manifests. At runtime, it replaces placeholders in YAML template
    files with actual, end-user defined values. The artifact produced by the Helm
    executable is a so-called *chart file* bundling the manifests that comprise the
    API resources of an application. This chart file can be uploaded to a package
    manager to be used during the deployment process. The Helm ecosystem offers a
    wide range of reusable charts for common use cases on a [central chart repository](https://oreil.ly/1OLIi)
    (e.g., for running Grafana or PostgreSQL).'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the wealth of functionality available to Helm, we’ll discuss only the
    very basics. The CKA exam does not expect you be a Helm expert; rather, it wants
    to be familiar with the benefits and concepts. For more detailed information on
    Helm, see the [user documentation](https://helm.sh/docs). The version of Helm
    used to describe the functionality here is 3.7.0.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Chart Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A chart needs to follow a predefined directory structure. You can choose any
    name for the root directory. Within the directory, two files need to exist: `Chart.yaml`
    and `values.yaml`. The file `Chart.yaml` describes the meta information of the
    chart (e.g., name and version). The file `values.yaml` contains the key-value
    pairs used at runtime to replace the placeholders in the YAML manifests. Any template
    file meant to be packaged into the chart archive file needs to be put in the `templates`
    directory. Files located in the `template` directory do not have to follow any
    naming conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following directory structure shows an example chart. The `templates` directory
    contains a file for a Pod and a Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The chart file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file `Chart.yaml` describes the chart on a high level. Mandatory attributes
    include the chart’s API version, the name, and the version. Additionally, optional
    attributes can be provided. For a full list of attributes, see the relevant [documentation](https://oreil.ly/VUrm1).
    [Example 4-12](#basic_helm_chart_file) shows the bare minimum of a chart file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12\. A basic Helm chart file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The values file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file `values.yaml` defines key-value pairs to be used to replace placeholders
    in the YAML template files. [Example 4-13](#helm_values_file) specifies four key-value
    pairs. Be aware that the file can be empty if you don’t want to replace values
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13\. A Helm values file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The template files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template files need to live in the `templates` directory. A template file is
    a regular YAML manifest that can (optionally) define placeholders with the help
    of double curly braces (`{{ }}`). To reference a value from the `values.yaml`
    file, use the expression `{{ .Values.<key> }}`. For example, to replace the value
    of the key `db_host` at runtime, use the expression `{{ .Values.db_host }}`. [Example 4-14](#yaml_template_manifest_pod)
    defines a Pod as a template while defining three placeholders that reference values
    from `values.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14\. The YAML template manifest of a Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Executing Helm commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Helm executable comes with a wide range of commands. Let’s demonstrate
    some of them. The `template` command renders the chart templates locally and displays
    results on the console. You can see the operation in action in the following output.
    All placeholders have been replaced by their actual values sourced from the `values.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are happy with the result, you’ll want to bundle the template files
    into a chart archive file. The chart archive file is a compressed TAR file with
    the file ending `.tgz`. The `package` command evaluates the metadata information
    from `Chart.yaml` to derive the chart archive filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For a full list of commands and typical workflows, refer to the Helm [documentation
    page](https://oreil.ly/Jz6eD).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource boundaries are one of the many factors that the kube-scheduler algorithm
    considers when making decisions on which node a Pod can be scheduled. A container
    can specify resource requests and limits. The scheduler chooses a node based on
    its available hardware capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative manifest management is the preferred way of creating, modifying,
    and deleting objects in real-world, cloud-native projects. The underlying YAML
    manifest is meant to be checked into version control and automatically tracks
    the changes made to a object including its timestamp for a corresponding commit
    hash. The `kubectl apply` and `delete` command can perform those operations for
    one or many YAML manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tools emerged for more convenient manifest management. Kustomize
    is fully integrated with the `kubectl` tool chain. It helps with the generation,
    composition, and customization of manifests. Tools with templating capabilities
    like `yq` and Helm can further ease various workflows for managing application
    stacks represented by a set of manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the effects of resource boundaries on scheduling
  prefs: []
  type: TYPE_NORMAL
- en: A container defined by a Pod can specify resource requests and limits. Work
    through scenarios where you define those boundaries individually and together
    for single- and multi-container Pods. Upon creation of the Pod, you should be
    able to see the effects on scheduling the object on a node. Furthermore, practice
    how to identify the available resource capacity of a node.
  prefs: []
  type: TYPE_NORMAL
- en: Manage objects using the imperative and declarative approach
  prefs: []
  type: TYPE_NORMAL
- en: YAML manifests are essential for expressing the desired state of an object.
    You will need to understand how to create, update, and delete objects using the
    `kubectl apply` command. The command can point to a single manifest file or a
    directory containing multiple manifest files.
  prefs: []
  type: TYPE_NORMAL
- en: Have a high-level understanding of common templating tools
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize, `yg`, and Helm are established tools for managing YAML manifests.
    Their templating functionality supports complex scenarios like composing and merging
    multiple manifests. For the exam, take a practical look at the tools, their functionality,
    and the problems they solve.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: Write a manifest for a new Pod named `ingress-controller` with a single container
    that uses the image `bitnami/nginx-ingress-controller:1.0.0`. For the container,
    set the resource request to 256Mi for memory and 1 CPU. Set the resource limits
    to 1024Mi for memory and 2.5 CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the manifest, schedule the Pod on a cluster with three nodes. Once created,
    identify the node that runs the Pod. Write the node name to the file `node.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the directory named `manifests`. Within the directory, create two files:
    `pod.yaml` and `configmap.yaml`. The `pod.yaml` file should define a Pod named
    `nginx` with the image `nginx:1.21.1`. The `configmap.yaml` file defines a ConfigMap
    named `logs-config` with the key-value pair `dir=/etc/logs/traffic.log`. Create
    both objects with a single, declarative command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the ConfigMap manifest by changing the value of the key `dir` to `/etc/logs/traffic-log.txt`.
    Apply the changes. Delete both objects with a single declarative command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Kustomize to set a common namespace `t012` for the resource file `pod.yaml`.
    The file `pod.yaml` defines the Pod named `nginx` with the image `nginx:1.21.1`
    without a namespace. Run the Kustomize command that renders the transformed manifest
    on the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
