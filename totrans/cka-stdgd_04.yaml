- en: Chapter 4\. Scheduling and Tooling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scheduling portion of the CKA focuses on the effects of defining resource
    boundaries when evaluated by the Kubernetes scheduler. The default runtime behavior
    of the scheduler can also be modified by defining node affinity rules, as well
    as taints and tolerations. Of those concepts, you are expected only to understand
    the nuances of resource boundaries and their effect on the scheduler in different
    scenarios. Finally, this domain of the curriculum mentions high-level knowledge
    of manifest management and templating tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Resource boundaries for Pods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative and declarative manifest management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common templating tools like Kustomize, `yq`, and Helm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding How Resource Limits Affect Pod Scheduling
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Kubernetes cluster can consist of multiple nodes. Depending on a variety of
    rules (e.g., [node selectors](https://oreil.ly/m5eep), [node affinity](https://oreil.ly/9Gf7E),
    [taints and tolerations](https://oreil.ly/2SkeO)), the Kubernetes scheduler decides
    which node to pick for running the workload. The CKA exam doesn’t ask you to understand
    the scheduling concepts mentioned previously, but it would be helpful to have
    a rough idea how they work on a high level.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: One metric that comes into play for workload scheduling is the resource *request*
    defined by the containers in a Pod. Commonly used resources that can be specified
    are CPU and memory. The scheduler ensures that the node’s resource capacity can
    fulfill the resource requirements of the Pod. More specifically, the scheduler
    determines the sum of resource requests per type across all containers defined
    in the Pod and compares them with the node’s available resources. [Figure 4-1](#pod_scheduling)
    illustrates the scheduling process based on the resource requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0401](Images/ckas_0401.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Pod scheduling based on resource requests
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Defining Container Resource Requests
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each container in a Pod can define its own resource requests. [Table 4-1](#options_resource_requests)
    describes the available options including an example value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Options for resource requests
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '| YAML Attribute | Description | Example Value |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.cpu` | CPU resource type | `500m` (five
    hundred millicpu) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.requests.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: Kubernetes uses resource units for resource types that deviate from standard
    resource units like megabytes and gigabytes. Explaining all intricacies of those
    units goes beyond the scope this book, but you can read up on the details in the
    [documentation](https://oreil.ly/bweuT).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: To make the use of those resource requests transparent, we’ll take a look at
    an example definition. The Pod YAML manifest shown in [Example 4-1](#setting_container_resource_requests)
    defines two containers, each with their own resource requests. Any node that is
    allowed to run the Pod needs to be able to support a minimum memory capacity of
    320Mi and 1250m CPU, the sum of resources across both containers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Setting container resource requests
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this scenario, we are dealing with a Minikube Kubernetes cluster consisting
    of three nodes, one control plane node, and two worker nodes. The following command
    lists all nodes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the next step, we’ll create the Pod from the YAML manifest. The scheduler
    places the Pod on the node named `minikube-m03`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Upon further inspection of the node, you can inspect its maximum capacity,
    how much of this capacity is allocatable, and the memory requests of the Pods
    scheduled on the node. The following command lists the information and condenses
    the output to the relevant bits and pieces:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s certainly possible that a Pod cannot be scheduled due to insufficient resources
    available on the nodes. In those cases, the event log of the Pod will indicate
    this situation with the reasons `PodExceedsFreeCPU` or `PodExceedsFreeMemory`.
    For more information on how to troubleshoot and resolve this situation, see the
    relevant [section in the documentation](https://oreil.ly/ZzK0B).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Defining Container Resource Limits
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another metric you can set for a container are its resource *limits*. Resource
    limits ensure that the container cannot consume more than the allotted resource
    amounts. For example, you could express that the application running in the container
    should be constrained to 1000m of CPU and 512Mi of memory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the container runtime used by the cluster, exceeding any of the
    allowed resource limits results in a termination of the application process running
    in the container or results in the system preventing the allocation of resources
    beyond the limits altogether. For an in-depth discussion on how resource limits
    are treated by the container runtime Docker, see the [documentation](https://oreil.ly/szUaM).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-2](#options_resource_limits) describes the available options including
    an example value.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. Options for resource limits
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '| YAML Attribute | Description | Example Value |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.cpu` | CPU resource type | `500m` (500
    millicpu) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.memory` | Memory resource type | `64Mi`
    (2^26 bytes) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.hugepages-<size>` | Huge page resource
    type | `hugepages-2Mi: 60Mi` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `spec.containers[].resources.limits.ephemeral-storage` | Ephemeral storage
    resource type | `4Gi` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '[Example 4-2](#setting_container_resource_limits) shows the definition of limits
    in action. Here, the container named `business-app` cannot use more than 512Mi
    of memory and 2000m of CPU. The container named `ambassador` defines a limit of
    128Mi of memory and 500m of CPU.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. Setting container resource limits
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Assume that the Pod was scheduled on the node `minikube-m03`. Describing the
    node’s details reveals that the CPU and memory limits took effect. But there’s
    more. Kubernetes automatically assigns the same amount of resources for the requests
    if you only define the limits:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Defining Container Resource Requests and Limits
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s recommended practice that you specify resource requests and limits for
    every container. Determining those resource expectations is not always easy, specifically
    for applications that haven’t been exercised in a production environment yet.
    Load testing the application early on during the development cycle can help with
    analyzing the resource needs. Further adjustments can be made by monitoring the
    application’s resource consumption after deploying it to the cluster. [Example 4-3](#settings_container_resource_requests_limits)
    combines resource requests and limits in a single YAML manifest.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. Setting container resource requests and limits
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a result, you can see the different settings for resource requests and limits:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Managing Objects
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes objects can be created, modified, and deleted by using imperative
    `kubectl` commands or by running a `kubectl` command against a configuration file
    declaring the desired state of an object, a so-called manifest. The primary definition
    language of a manifest is YAML, though you can opt for JSON, which is the less
    widely adopted format among the Kubernetes community. It’s recommended that development
    teams commit and push those configuration files to version control repositories
    as it will help with tracking and auditing changes over time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Modeling an application in Kubernetes often requires a set of supporting objects,
    each of which can have their own manifest. For example, you may want to create
    a Deployment that runs the application on five Pods, a ConfigMap to inject configuration
    data as environment variables, and a Service for exposing network access.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: This section primarily focuses on the declarative object management support
    with the help of manifests. For a deeper discussion on the imperative support,
    see the relevant portions in the [documentation](https://oreil.ly/Slw0h). Furthermore,
    we’ll touch on tools like Kustomize and Helm to give you an impression of their
    benefits, capabilities, and workflows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Declarative Object Management Using Configuration Files
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declarative object management requires one or several configuration files in
    the format of YAML or JSON describing the desired state of an object. You create,
    update, and delete objects with this approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create new objects, run the `apply` command by pointing to a file, a directory
    of files, or a file referenced by an HTTP(S) URL using the `-f` option. If one
    or many of the objects already exist, the command will synchronize the changes
    made to the configuration with the live object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新对象，请使用`apply`命令，指向一个文件、文件目录或通过HTTP(S) URL引用的文件，并使用`-f`选项。如果一个或多个对象已经存在，则命令将会同步配置所做的更改与实时对象。
- en: 'To demonstrate the functionality, we’ll assume the following directories and
    configuration files. The following commands create objects from a single file,
    from all files within a directory, and from all files in a directory recursively:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示功能，我们假设以下目录和配置文件。以下命令从单个文件创建对象，从目录中的所有文件创建对象，以及递归目录中的所有文件创建对象：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Creating an object from a single file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从单个文件创建对象：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Creating objects from multiple files within a directory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录中的多个文件创建对象：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Creating objects from a recursive directory tree containing files:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含文件的递归目录树创建对象：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Creating objects from a file referenced by an HTTP(S) URL:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从通过HTTP(S) URL引用的文件创建对象：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `apply` command keeps track of the changes by adding or modifying the annotation
    with the key `kubectl.kubernetes.io/last-applied-configuration`. You can find
    an example of the annotation in the output of the `get pod` command here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`命令通过添加或修改带有键`kubectl.kubernetes.io/last-applied-configuration`的注释来跟踪更改。您可以在此处`get
    pod`命令的输出中找到注释的示例：'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Updating objects
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新对象
- en: Updating an existing object is done with the same `apply` command. All you need
    to do is to change the configuration file and then run the command against it.
    [Example 4-4](#modified_configuration_file_deployment) modifies the existing configuration
    of a Deployment in the file `nginx-deployment.yaml`. We added a new label with
    the key `team` and changed the number of replicas from 3 to 5.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有对象使用相同的`apply`命令完成。您只需更改配置文件，然后运行该命令。[示例 4-4](#modified_configuration_file_deployment)修改了文件`nginx-deployment.yaml`中部署的现有配置。我们添加了一个新标签，键为`team`，并将副本数从3修改为5。
- en: Example 4-4\. Modified configuration file for a Deployment
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 修改后的部署配置文件
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following command applies the changed configuration file. As a result,
    the number of Pods controlled by the underlying ReplicaSet is 5\. The Deployment’s
    annotation `kubectl.kubernetes.io/last-applied-configuration` reflects the latest
    change to the configuration:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令应用了更改后的配置文件。结果，由底层副本集控制的Pod数量为5。部署的注释`kubectl.kubernetes.io/last-applied-configuration`反映了配置的最新更改：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deleting objects
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除对象
- en: 'While there is a way to delete objects using the `apply` command by providing
    the options `--prune -l <labels>`, it is recommended to delete an object using
    the `delete` command and point it to the configuration file. The following command
    deletes a Deployment and the objects it controls (ReplicaSet and Pods):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用`apply`命令删除对象，提供选项`--prune -l <labels>`，但建议使用`delete`命令删除对象，并指向配置文件。以下命令删除一个部署及其控制的对象（副本集和Pod）：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Declarative Object Management Using Kustomize
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kustomize进行声明式对象管理
- en: 'Kustomize is a tool introduced with Kubernetes 1.14 that aims to make manifest
    management more convenient. It supports three different use cases:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize是一个引入于Kubernetes 1.14的工具，旨在使清单管理更加方便。它支持三种不同的使用场景：
- en: Generating manifests from other sources. For example, creating a ConfigMap and
    populating its key-value pairs from a properties file.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他来源生成清单。例如，创建一个ConfigMap，并从属性文件填充其键值对。
- en: Adding common configuration across multiple manifests. For example, adding a
    namespace and a set of labels for a Deployment and a Service.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加多个清单中的通用配置。例如，为部署和服务添加命名空间和一组标签。
- en: Composing and customizing a collection of manifests. For example, setting resource
    boundaries for multiple Deployments.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和自定义一组清单。例如，为多个部署设置资源边界。
- en: The central file needed for Kustomize to work is the *kustomization file*. The
    standardized name for the file is `kustomization.yaml` and cannot be changed.
    A kustomization file defines the processing rules Kustomize works upon.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize正常工作所需的中心文件是*kustomization文件*。该文件的标准名称为`kustomization.yaml`，不可更改。一个kustomization文件定义了Kustomize处理的处理规则。
- en: 'Kustomize is fully integrated with `kubectl` and can be executed in two modes:
    rendering the processing output on the console or creating the objects. Both modes
    can operate on a directory, tarball, Git archive, or URL as long as they contain
    the kustomization file and referenced resource files:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize与`kubectl`完全集成，可以以两种模式执行：在控制台上呈现处理输出或创建对象。只要它们包含kustomization文件和引用的资源文件，这两种模式都可以操作目录、tarball、Git存档或URL：
- en: Rendering the produced output
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现生成的输出
- en: 'The first mode uses the `kustomize` subcommand to render the produced result
    on the console but does not create the objects. This command works similar to
    the dry-run option you might know from the `run` command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种模式使用`kustomize`子命令在控制台上呈现生成的结果，但不创建对象。此命令类似于您可能从`run`命令中了解的干运行选项：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating the objects
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'The second mode uses the `apply` command in conjunction with the `-k` command-line
    option to apply the resources processed by Kustomize, as explained in the previous
    section:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式使用`apply`命令与`-k`命令行选项结合使用，以应用Kustomize处理的资源，如前一节所述：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The following sections demonstrate each of the use cases by a single example.
    For a full coverage on all possible scenarios, refer to the [documentation](https://oreil.ly/JUHXj)
    or the [Kustomize GitHub repository](https://oreil.ly/4MirA).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分通过单个示例演示了每个用例。要全面覆盖所有可能的场景，请参阅[文档](https://oreil.ly/JUHXj)或[Kustomize GitHub存储库](https://oreil.ly/4MirA)。
- en: Composing Manifests
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合清单
- en: 'One of the core functionalities of Kustomize is to create a composed manifest
    from other manifests. Combining multiple manifests into a single one may not seem
    that useful by itself, but many of the other features described later will build
    upon this capability. Say you wanted to compose a manifest from a Deployment and
    a Service resource file. All you need to do is to place the resource files into
    the same folder as the kustomization file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize的核心功能之一是从其他清单创建组合清单。将多个清单合并为一个可能看起来并不那么有用，但稍后描述的许多其他功能将基于这种能力构建。假设您想要从一个部署和一个服务资源文件中组合清单。您所需做的就是将资源文件放入与kustomization文件相同的文件夹中：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The kustomization file lists the resources in the `resources` section, as shown
    in [Example 4-5](#kustomization_file_combining).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: kustomization文件在`resources`部分列出了资源，如[示例 4-5](#kustomization_file_combining)所示。
- en: Example 4-5\. A kustomization file combining two manifests
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 结合两个清单的kustomization文件
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a result, the `kustomize` subcommand renders the combined manifest containing
    all of the resources separated by three hyphens (`---`) to denote the different
    object definitions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`kustomize`子命令呈现了包含所有资源的组合清单，这些资源由三个连字符（`---`）分隔以表示不同的对象定义：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Generating manifests from other sources
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从其他来源生成清单
- en: Earlier in this chapter, we learned that ConfigMaps and Secrets can be created
    by pointing them to a file containing the actual configuration data for it. Kustomize
    can help with the process by mapping the relationship between the YAML manifest
    of those configuration objects and their data. Furthermore, we’ll want to inject
    the created ConfigMap and Secret in a Pod as environment variables. In this section,
    you will learn how to achieve this with the help of Kustomize.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早些时候，我们了解到ConfigMaps和Secrets可以通过将它们指向包含实际配置数据的文件来创建。Kustomize可以通过映射这些配置对象的YAML清单与它们的数据之间的关系来帮助处理这个过程。此外，我们还希望将创建的ConfigMap和Secret作为环境变量注入到Pod中。在本节中，您将学习如何借助Kustomize实现此目标。
- en: 'The following file and directory structure contains the manifest file for the
    Pod and the configuration data files we need for the ConfigMap and Secret. The
    mandatory kustomization file lives on the root level of the directory tree:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的文件和目录结构包含了Pod的清单文件以及我们需要用于ConfigMap和Secret的配置数据文件。强制的kustomization文件位于目录树的根级别：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In `kustomization.yaml`, you can define that the ConfigMap and Secret object
    should be generated with the given name. The name of the ConfigMap is supposed
    to be `db-config`, and the name of the Secret is going to be `db-creds`. Both
    of the generator attributes, `configMapGenerator` and `secretGenerator`, reference
    an input file used to feed in the configuration data. Any additional resources
    can be spelled out with the `resources` attribute. [Example 4-6](#kustomization_file_configmap_secret)
    shows the contents of the kustomization file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6\. A kustomization file using a ConfigMap and Secret generator
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Kustomize generates ConfigMaps and Secrets by appending a suffix to the name.
    You can see this behavior when creating the objects using the `apply` command.
    The ConfigMap and Secret can be referenced by name in the Pod manifest:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This naming strategy can be configured with the attribute `generatorOptions`
    in the kustomization file. See the [documentation](https://oreil.ly/M7tlD) for
    more information.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also try the `kustomize` subcommand. Instead of creating the objects,
    the command renders the processed output on the console:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Adding common configuration across multiple manifests
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application developers usually work on an application stack set comprised of
    multiple manifests. For example, an application stack could consist of a frontend
    microservice, a backend microservice, and a database. It’s common practice to
    use the same, cross-cutting configuration for each of the manifests. Kustomize
    offers a range of supported fields (e.g., namespace, labels, or annotations).
    Refer to the [documentation](https://oreil.ly/OyNbh) to learn about all supported
    fields.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next example, we’ll assume that a Deployment and a Service live in
    the same namespace and use a common set of labels. The namespace is called `persistence`
    and the label is the key-value pair `team: helix`. [Example 4-7](#kustomization_file_common_fields)
    illustrates how to set those common fields in the kustomization file.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7\. A kustomization file using a common field
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To create the referenced objects in the kustomization file, run the `apply`
    command. Make sure to create the `persistence` namespace beforehand:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The YAML representation of the processed files looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Customizing a collection of manifests
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kustomize can merge the contents of a YAML manifest with a code snippet from
    another YAML manifest. Typical use cases include adding security context configuration
    to a Pod definition or setting resource boundaries for a Deployment. The kustomization
    file allows for specifying different patch strategies like `patchesStrategicMerge`
    and `patchesJson6902`. For a deeper discussion on the differences between patch
    strategies, refer to the documentation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-8](#kustomization_file_patch) shows the contents of a kustomization
    file that patches a Deployment definition in the file `nginx-deployment.yaml`
    with the contents of the file `security-context.yaml`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8\. A kustomization file defining a patch
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The patch file shown in [Example 4-9](#path_yaml_manifest) defines a security
    context on the container-level for the Pod template of the Deployment. At runtime,
    the patch strategy tries to find the container named `nginx` and enhances the
    additional configuration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9\. The patch YAML manifest
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The result is a patched Deployment definition, as shown in the output of the
    `kustomize` subcommand shown next. The patch mechanism can be applied to other
    files that require a uniform security context definition:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Common Templating Tools
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in the previous section, Kustomize offers templating functionality.
    The Kubernetes ecosystem offers other solutions to the problem that we will discuss
    here. We will touch on the YAML processor `yq` and the templating engine Helm.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Using the YAML Processor yq
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tool `yq` is used to read, modify, and enhance the contents of a YAML file.
    This section will demonstrate all three use cases. For a detailed list of usage
    example, see the [GitHub repository](https://oreil.ly/ORZDV). During the CKA exam,
    you may be asked to apply those techniques though you are not expected to understand
    all intricacies of the tools at hand. The version of `yq` used to describe the
    functionality below is 4.2.1.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Reading values
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reading values from an existing YAML file requires the use of a YAML path expression.
    A path expression allows you to deeply navigate the YAML structure and extract
    the value of an attribute you are searching for. [Example 4-10](#yaml_manifest_pod)
    shows the YAML manifest of a Pod that defines two environment variables.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10\. The YAML manifest of a Pod
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To read a value, use the command `eval` or the short form `e`, provide the
    YAML path expression, and point it to the source file. The following two commands
    read the Pod’s name and the value of the second environment variable defined by
    a single container. Notice that the path expression needs to start with a mandatory
    dot character (`.`) to denote the root node of the YAML structure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Modifying values
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modifying an existing value is as easy as using the same command and adding
    the `-i` flag. The assignment of the new value to an attribute happens by assigning
    it to the path expression. The following command changes the second environment
    variable of the Pod YAML file to the value 1.6.0:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Merging YAML files
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to Kustomize, `yq` can merge multiple YAML files. Kustomize is definitely
    more powerful and convenient to use; however, `yq` can come in handy for smaller
    projects. Say you wanted to merge the sidecar container definition shown in [Example 4-11](#yaml_manifest_container)
    into the Pod YAML file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11\. The YAML manifest of a container definition
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The command to achieve this is `eval-all`. We won’t go into details given the
    multitude of configuration options for this command. For a deep dive, check the
    `yq` user manual on the [“Multiply (Merge)” operation](https://oreil.ly/2I6ir).
    The following command appends the sidecar container to the existing container
    array of the Pod manifest:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using Helm
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Helm](https://helm.sh) is a templating engine and package manager for a set
    of Kubernetes manifests. At runtime, it replaces placeholders in YAML template
    files with actual, end-user defined values. The artifact produced by the Helm
    executable is a so-called *chart file* bundling the manifests that comprise the
    API resources of an application. This chart file can be uploaded to a package
    manager to be used during the deployment process. The Helm ecosystem offers a
    wide range of reusable charts for common use cases on a [central chart repository](https://oreil.ly/1OLIi)
    (e.g., for running Grafana or PostgreSQL).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Due to the wealth of functionality available to Helm, we’ll discuss only the
    very basics. The CKA exam does not expect you be a Helm expert; rather, it wants
    to be familiar with the benefits and concepts. For more detailed information on
    Helm, see the [user documentation](https://helm.sh/docs). The version of Helm
    used to describe the functionality here is 3.7.0.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Standard Chart Structure
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A chart needs to follow a predefined directory structure. You can choose any
    name for the root directory. Within the directory, two files need to exist: `Chart.yaml`
    and `values.yaml`. The file `Chart.yaml` describes the meta information of the
    chart (e.g., name and version). The file `values.yaml` contains the key-value
    pairs used at runtime to replace the placeholders in the YAML manifests. Any template
    file meant to be packaged into the chart archive file needs to be put in the `templates`
    directory. Files located in the `template` directory do not have to follow any
    naming conventions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The following directory structure shows an example chart. The `templates` directory
    contains a file for a Pod and a Service:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The chart file
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file `Chart.yaml` describes the chart on a high level. Mandatory attributes
    include the chart’s API version, the name, and the version. Additionally, optional
    attributes can be provided. For a full list of attributes, see the relevant [documentation](https://oreil.ly/VUrm1).
    [Example 4-12](#basic_helm_chart_file) shows the bare minimum of a chart file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12\. A basic Helm chart file
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The values file
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file `values.yaml` defines key-value pairs to be used to replace placeholders
    in the YAML template files. [Example 4-13](#helm_values_file) specifies four key-value
    pairs. Be aware that the file can be empty if you don’t want to replace values
    at runtime.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13\. A Helm values file
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The template files
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template files need to live in the `templates` directory. A template file is
    a regular YAML manifest that can (optionally) define placeholders with the help
    of double curly braces (`{{ }}`). To reference a value from the `values.yaml`
    file, use the expression `{{ .Values.<key> }}`. For example, to replace the value
    of the key `db_host` at runtime, use the expression `{{ .Values.db_host }}`. [Example 4-14](#yaml_template_manifest_pod)
    defines a Pod as a template while defining three placeholders that reference values
    from `values.yaml`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模板文件需要存放在 `templates` 目录中。模板文件是一个常规的YAML清单，可以（可选地）使用双大括号(`{{ }}`)定义占位符。要从 `values.yaml`
    文件中引用值，请使用表达式 `{{ .Values.<key> }}`。例如，要在运行时替换 `db_host` 键的值，请使用表达式 `{{ .Values.db_host
    }}`。 [示例 4-14](#yaml_template_manifest_pod) 定义了一个Pod作为模板，同时定义了三个引用 `values.yaml`
    中值的占位符。
- en: Example 4-14\. The YAML template manifest of a Pod
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. Pod的YAML模板清单
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Executing Helm commands
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行Helm命令
- en: 'The Helm executable comes with a wide range of commands. Let’s demonstrate
    some of them. The `template` command renders the chart templates locally and displays
    results on the console. You can see the operation in action in the following output.
    All placeholders have been replaced by their actual values sourced from the `values.yaml`
    file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Helm可执行文件配备广泛的命令。我们来演示其中一些。 `template` 命令在本地渲染图表模板并在控制台显示结果。您可以在以下输出中看到操作的实际效果。所有占位符都已由
    `values.yaml` 文件中的实际值替换：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once you are happy with the result, you’ll want to bundle the template files
    into a chart archive file. The chart archive file is a compressed TAR file with
    the file ending `.tgz`. The `package` command evaluates the metadata information
    from `Chart.yaml` to derive the chart archive filename:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您满意结果，您将希望将模板文件打包成图表存档文件。图表存档文件是一个以 `.tgz` 结尾的压缩TAR文件。 `package` 命令评估 `Chart.yaml`
    中的元数据信息以导出图表存档文件名：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For a full list of commands and typical workflows, refer to the Helm [documentation
    page](https://oreil.ly/Jz6eD).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解所有命令和典型工作流程的完整列表，请参阅Helm [文档页面](https://oreil.ly/Jz6eD)。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Resource boundaries are one of the many factors that the kube-scheduler algorithm
    considers when making decisions on which node a Pod can be scheduled. A container
    can specify resource requests and limits. The scheduler chooses a node based on
    its available hardware capacity.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 资源边界是 kube-scheduler 算法在决定可以将Pod调度到哪个节点时考虑的众多因素之一。容器可以指定资源请求和限制。调度程序根据其可用的硬件容量选择节点。
- en: Declarative manifest management is the preferred way of creating, modifying,
    and deleting objects in real-world, cloud-native projects. The underlying YAML
    manifest is meant to be checked into version control and automatically tracks
    the changes made to a object including its timestamp for a corresponding commit
    hash. The `kubectl apply` and `delete` command can perform those operations for
    one or many YAML manifests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式清单管理是在实际的云原生项目中创建、修改和删除对象的首选方法。底层的YAML清单应存入版本控制，并自动跟踪对对象所做的更改，包括其相应提交哈希的时间戳。
    `kubectl apply` 和 `delete` 命令可以对一个或多个YAML清单执行这些操作。
- en: Additional tools emerged for more convenient manifest management. Kustomize
    is fully integrated with the `kubectl` tool chain. It helps with the generation,
    composition, and customization of manifests. Tools with templating capabilities
    like `yq` and Helm can further ease various workflows for managing application
    stacks represented by a set of manifests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了更多方便的清单管理工具。Kustomize与 `kubectl` 工具链完全集成。它帮助生成、组合和定制清单。具有模板功能的工具如 `yq` 和
    Helm 可进一步简化管理应用程序堆栈的各种工作流程所需的清单。
- en: Exam Essentials
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考试要点
- en: Understand the effects of resource boundaries on scheduling
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 理解资源边界对调度的影响
- en: A container defined by a Pod can specify resource requests and limits. Work
    through scenarios where you define those boundaries individually and together
    for single- and multi-container Pods. Upon creation of the Pod, you should be
    able to see the effects on scheduling the object on a node. Furthermore, practice
    how to identify the available resource capacity of a node.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由Pod定义的容器可以指定资源请求和限制。通过定义单容器和多容器Pod的边界，分析能看到在节点上调度对象的效果。此外，练习如何识别节点的可用资源容量。
- en: Manage objects using the imperative and declarative approach
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令式和声明式方法管理对象
- en: YAML manifests are essential for expressing the desired state of an object.
    You will need to understand how to create, update, and delete objects using the
    `kubectl apply` command. The command can point to a single manifest file or a
    directory containing multiple manifest files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Have a high-level understanding of common templating tools
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize, `yg`, and Helm are established tools for managing YAML manifests.
    Their templating functionality supports complex scenarios like composing and merging
    multiple manifests. For the exam, take a practical look at the tools, their functionality,
    and the problems they solve.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Write a manifest for a new Pod named `ingress-controller` with a single container
    that uses the image `bitnami/nginx-ingress-controller:1.0.0`. For the container,
    set the resource request to 256Mi for memory and 1 CPU. Set the resource limits
    to 1024Mi for memory and 2.5 CPU.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the manifest, schedule the Pod on a cluster with three nodes. Once created,
    identify the node that runs the Pod. Write the node name to the file `node.txt`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the directory named `manifests`. Within the directory, create two files:
    `pod.yaml` and `configmap.yaml`. The `pod.yaml` file should define a Pod named
    `nginx` with the image `nginx:1.21.1`. The `configmap.yaml` file defines a ConfigMap
    named `logs-config` with the key-value pair `dir=/etc/logs/traffic.log`. Create
    both objects with a single, declarative command.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the ConfigMap manifest by changing the value of the key `dir` to `/etc/logs/traffic-log.txt`.
    Apply the changes. Delete both objects with a single declarative command.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Kustomize to set a common namespace `t012` for the resource file `pod.yaml`.
    The file `pod.yaml` defines the Pod named `nginx` with the image `nginx:1.21.1`
    without a namespace. Run the Kustomize command that renders the transformed manifest
    on the console.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
