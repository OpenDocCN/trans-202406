["```\ntype Poet = {\n  born: number;\n  name: string;\n};\n```", "```\ninterface Poet {\n  born: number;\n  name: string;\n}\n```", "```\nlet valueLater: Poet;\n\n// Ok\nvalueLater = {\n  born: 1935,\n  name: 'Sara Teasdale',\n};\n\nvalueLater = \"Emily Dickinson\";\n// Error: Type 'string' is not assignable to 'Poet'.\n\nvalueLater = {\n  born: true,\n  // Error: Type 'boolean' is not assignable to type 'number'.\n  name: 'Sappho'\n};\n```", "```\ninterface Book {\n  author?: string;\n  pages: number;\n};\n\n// Ok\nconst ok: Book = {\n    author: \"Rita Dove\",\n    pages: 80,\n};\n\nconst missing: Book = {\n    pages: 80\n};\n// Error: Property 'author' is missing in type\n// '{ pages: number; }' but required in type 'Book'.\n```", "```\ninterface Page {\n    readonly text: string;\n}\n\nfunction read(page: Page) {\n    // Ok: reading the text property doesn't attempt to modify it\n    console.log(page.text);\n\n    page.text += \"!\";\n    //   ~~~~\n    // Error: Cannot assign to 'text'\n    // because it is a read-only property.\n}\n```", "```\nconst pageIsh = {\n  text: \"Hello, world!\",\n};\n\n// Ok: messengerIsh is an inferred object type with text, not a Page\npage.text += \"!\";\n\n// Ok: read takes in Page, which happens to\n// be a more specific version of pageIsh's type\nread(messengerIsh);\n```", "```\ninterface HasBothFunctionTypes {\n  property: () => string;\n  method(): string;\n}\n\nconst hasBoth: HasBothFunctionTypes = {\n  property: () => \"\",\n  method() {\n    return \"\";\n  }\n};\n\nhasBoth.property(); // Ok\nhasBoth.method(); // Ok\n```", "```\ninterface OptionalReadonlyFunctions {\n  optionalProperty?: () => string;\n  optionalMethod?(): string;\n}\n```", "```\ntype FunctionAlias = (input: string) => number;\n\ninterface CallSignature {\n  (input: string): number;\n}\n\n// Type: (input: string) => number\nconst typedFunctionAlias: FunctionAlias = (input) => input.length; // Ok\n\n// Type: (input: string) => number\nconst typedCallSignature: CallSignature = (input) => input.length; // Ok\n```", "```\ninterface FunctionWithCount {\n  count: number;\n  (): void;\n}\n\nlet hasCallCount: FunctionWithCount;\n\nfunction keepsTrackOfCalls() {\n  keepsTrackOfCalls.count += 1;\n  console.log(`I've been called ${keepsTrackOfCalls.count} times!`);\n}\n\nkeepsTrackOfCalls.count = 0;\n\nhasCallCount = keepsTrackOfCalls; // Ok\n\nfunction doesNotHaveCount() {\n  console.log(\"No idea!\");\n}\n\nhasCallCount = doesNotHaveCount;\n// Error: Property 'count' is missing in type\n// '() => void' but required in type 'FunctionWithCalls'\n```", "```\ninterface WordCounts {\n  [i: string]: number;\n}\n\nconst counts: WordCounts = {};\n\ncounts.apple = 0; // Ok\ncounts.banana = 1; // Ok\n\ncounts.cherry = false;\n// Error: Type 'boolean' is not assignable to type 'number'.\n```", "```\ninterface DatesByName {\n  [i: string]: Date;\n}\n\nconst publishDates: DatesByName = {\n  Frankenstein: new Date(\"1 January 1818\"),\n};\n\npublishDates.Frankenstein; // Type: Date\nconsole.log(publishDates.Frankenstein.toString()); // Ok\n\npublishDates.Beloved; // Type: Date, but runtime value of undefined!\nconsole.log(publishDates.Beloved.toString()); // Ok in the type system, but...\n// Runtime error: Cannot read property 'toString'\n// of undefined (reading publishDates.Beloved)\n```", "```\ninterface HistoricalNovels {\n  Oroonoko: number;\n  [i: string]: number;\n}\n\n// Ok\nconst novels: HistoricalNovels = {\n  Outlander: 1991,\n  Oroonoko: 1688,\n};\n\nconst missingOroonoko: HistoricalNovels = {\n  Outlander: 1991,\n};\n// Error: Property 'Oroonoko' is missing in type\n// '{ Outlander: number; }' but required in type 'HistoricalNovels'.\n```", "```\ninterface ChapterStarts {\n  preface: 0;\n  [i: string]: number;\n}\n\nconst correctPreface: ChapterStarts = {\n  preface: 0,\n  night: 1,\n  shopping: 5\n};\n\nconst wrongPreface: ChapterStarts = {\n  preface: 1,\n  // Error: Type '1' is not assignable to type '0'.\n};\n```", "```\n// Ok\ninterface MoreNarrowNumbers {\n  [i: number]: string;\n  [i: string]: string | undefined;\n}\n\n// Ok\nconst mixesNumbersAndStrings: MoreNarrowNumbers = {\n  0: '',\n  key1: '',\n  key2: undefined,\n}\n\ninterface MoreNarrowStrings {\n  [i: number]: string | undefined;\n  // Error: 'number' index type 'string | undefined'\n  // is not assignable to 'string' index type 'string'.\n  [i: string]: string;\n}\n```", "```\ninterface Novel {\n    author: {\n        name: string;\n    };\n    setting: Setting;\n}\n\ninterface Setting {\n    place: string;\n    year: number;\n}\n\nlet myNovel: Novel;\n\n// Ok\nmyNovel = {\n    author: {\n        name: 'Jane Austen',\n    },\n    setting: {\n        place: 'England',\n        year: 1812,\n    }\n};\n\nmyNovel = {\n    author: {\n        name: 'Emily BrontÃ«',\n    },\n    setting: {\n        place: 'West Yorkshire',\n    },\n    // Error: Property 'year' is missing in type\n    // '{ place: string; }' but required in type 'Setting'.\n};\n```", "```\ninterface Writing {\n    title: string;\n}\n\ninterface Novella extends Writing {\n    pages: number;\n}\n\n// Ok\nlet myNovella: Novella = {\n    pages: 195,\n    title: \"Ethan Frome\",\n};\n\nlet missingPages: Novella = {\n // ~~~~~~~~~~~~\n // Error: Property 'pages' is missing in type\n // '{ title: string; }' but required in type 'Novella'.\n    title: \"The Awakening\",\n}\n\nlet extraProperty: Novella = {\n // ~~~~~~~~~~~~~\n // Error: Type '{ genre: string; name: string; strategy: string; }'\n // is not assignable to type 'Novella'.\n //   Object literal may only specify known properties,\n //   and 'genre' does not exist in type 'Novella'.\n    pages: 300,\n    strategy: \"baseline\",\n    style: \"Naturalism\"\n};\n```", "```\ninterface WithNullableName {\n    name: string | null;\n}\n\ninterface WithNonNullableName extends WithNullableName {\n    name: string;\n}\n\ninterface WithNumericName extends WithNullableName {\n    name: number | string;\n}\n// Error: Interface 'WithNumericName' incorrectly\n// extends interface 'WithNullableName'.\n//   Types of property 'name' are incompatible.\n//     Type 'string | number' is not assignable to type 'string | null'.\n//       Type 'number' is not assignable to type 'string'.\n```", "```\ninterface GivesNumber {\n  giveNumber(): number;\n}\n\ninterface GivesString {\n  giveString(): string;\n}\n\ninterface GivesBothAndEither extends GivesNumber, GivesString {\n  giveEither(): number | string;\n}\n\nfunction useGivesBoth(instance: GivesBothAndEither) {\n  instance.giveEither(); // Type: number | string\n  instance.giveNumber(); // Type: number\n  instance.giveString(); // Type: string\n}\n```", "```\ninterface Merged {\n  fromFirst: string;\n}\n\ninterface Merged {\n  fromSecond: number;\n}\n\n// Equivalent to:\n// interface Merged {\n//   fromFirst: string;\n//   fromSecond: number;\n// }\n```", "```\ninterface Window {\n  myEnvironmentVariable: string;\n}\n\nwindow.myEnvironmentVariable; // Type: string\n```", "```\ninterface MergedProperties {\n  same: (input: boolean) => string;\n  different: (input: string) => string;\n}\n\ninterface MergedProperties {\n  same: (input: boolean) => string; // Ok\n\n  different: (input: number) => string;\n  // Error: Subsequent property declarations must have the same type.\n  // Property 'different' must be of type '(input: string) => string',\n  // but here has type '(input: number) => string'.\n}\n```", "```\ninterface MergedMethods {\n  different(input: string): string;\n}\n\ninterface MergedMethods {\n  different(input: number): string; // Ok\n}\n```"]