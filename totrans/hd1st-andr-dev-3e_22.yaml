- en: 'Chapter 19\. Integrating Compose with views: *Perfect Harmony*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章。将 Compose 与视图集成：*完美的和谐*
- en: '![image](Images/f0811-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0811-01.png)'
- en: '**You get the best results when things work together.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**当事物协同工作时，你会得到最好的结果。**'
- en: So far, you’ve learned how to build a UI using views or composables. But what
    if you want to use **both**? In this chapter, you’ll find out how to get **the
    best of both worlds** by **adding composables to a View-based UI**. You’ll discover
    techniques for making **composables work with view models**. You’ll even find
    out how to make them **respond to *LiveData* updates**. By the end of the chapter,
    you’ll have all the tools you need to **use composables with views**, or even
    **migrate to a pure Compose UI**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何使用视图或可组合项构建 UI。但如果你想同时使用 **两者** 呢？在本章中，你将了解如何通过 **向基于视图的 UI 添加可组合项**
    来 **兼顾两者** 的最佳实践。你将探索使 **可组合项与视图模型协同工作** 的技术。你甚至会了解到如何使它们响应 *LiveData* 更新。通过本章的学习，你将掌握使用可组合项与视图的所有技能，甚至可以
    **完全迁移到 Compose UI**。
- en: You can add composables to View-based UIs
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以将可组合项添加到基于视图的 UI 中
- en: In the previous chapter, you learned how to implement a Compose UI by building
    a brand new Temperature Converter app. Instead of adding views to a layout file,
    you created the UI by calling composables in the activity’s Kotlin code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何通过构建全新的温度转换器应用程序来实现 Compose UI。你没有向布局文件中添加视图，而是通过在活动的 Kotlin 代码中调用可组合项来创建
    UI。
- en: There are times, however, when you might want to use views *and* composables
    in the same UI. This may be because you want to use components that are only available
    as views or composables, for example, or you want to migrate parts of your app
    to Compose.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能希望在同一个 UI 中同时使用视图 *和* 可组合项。这可能是因为你希望使用仅作为视图或可组合项提供的组件，或者你希望将应用的部分迁移到
    Compose 中。
- en: The great news is that you can add composables to a UI that’s defined in a layout
    file. We’ll show you how this is done by taking the Guessing Game app we created
    earlier in the book, and migrating it to Compose.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 令人兴奋的消息是，你可以将可组合项添加到在布局文件中定义的 UI 中。我们将向你展示如何通过将我们之前在本书中创建的猜词游戏应用迁移到 Compose
    来实现这一点。
- en: The Guessing Game app revisited
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视猜词游戏应用
- en: As we’re sure you remember, the Guessing Game app lets the user guess which
    letters are included in a secret word. She wins the game if she guesses all the
    letters, and loses if she runs out of lives.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得，猜词游戏应用允许用户猜测哪些字母包含在秘密单词中。如果她猜对所有字母，则赢得游戏；如果耗尽生命，则输掉游戏。
- en: 'Here’s what the game currently looks like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目前游戏的外观如下：
- en: '![image](Images/f0812-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0812-01.png)'
- en: Before we start replacing the app’s views with composables, let’s quickly review
    how the app is constructed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始用可组合项替换应用的视图之前，让我们快速回顾一下应用的构造。
- en: The Guessing Game app structure
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猜词游戏应用的结构
- en: 'The Guessing Game app uses two fragments for its UI: `GameFragment` and `ResultFragment`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 猜词游戏应用使用两个片段作为其 UI：`GameFragment` 和 `ResultFragment`。
- en: '`GameFragment` is the app’s main screen, which the user interacts with to play
    the game. It displays information—such as the number of lives left and any incorrect
    guesses the user has made—and lets the user make guesses. It also includes a button
    that, when clicked, lets the user immediately finish the game without making any
    more guesses.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameFragment` 是应用的主屏幕，用户通过它与游戏进行交互。它显示信息，例如剩余生命和用户的任何错误猜测，并允许用户进行猜测。它还包括一个按钮，用户点击它可以立即结束游戏，而不再进行任何猜测。'
- en: '`ResultFragment` is displayed when the game is over. It shows the user if she
    has won or lost the game, along with the secret word.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultFragment` 游戏结束时显示，向用户展示她是否赢得游戏以及秘密单词。'
- en: 'The app also include two view models—`GameViewModel` and `ResultViewModel`—which
    hold the app’s game logic and data, and maintain its state when the app is rotated.
    `GameFragment` uses `GameViewModel`, and `ResultFragment` uses `ResultViewModel`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用还包括两个视图模型——`GameViewModel` 和 `ResultViewModel`——它们保存应用的游戏逻辑和数据，并在应用旋转时维护其状态。`GameFragment`
    使用 `GameViewModel`，而 `ResultFragment` 使用 `ResultViewModel`：
- en: '![image](Images/f0813-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0813-01.png)'
- en: Let’s run through the steps we’ll take to update the app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们将更新应用程序的步骤。
- en: Here’s what we’re going to do
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将要做的事情
- en: 'We’re going to replace the Guessing Game app’s views with composables in two
    main steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两个主要步骤用可组合项替换猜词游戏应用的视图：
- en: '**Replace ResultFragment’s views with composables.**'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用可组合项替换 ResultFragment 的视图。**'
- en: We’ll add the Compose libraries to the app’s *build.gradle* files, and then
    add composables to `ResultFragment`’s layout to replicate the current views. When
    we’re satisfied that the composables do what we want, we’ll remove the views from
    its UI.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将向应用的 *build.gradle* 文件中添加 Compose 库，并且向 `ResultFragment` 的布局中添加组合物以复制当前的视图。当我们满意组合物的表现时，将从其
    UI 中删除视图。
- en: '![image](Images/f0814-01.png)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0814-01.png)'
- en: '**Replace GameFragment’s views with composables.**'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用组合物替换 GameFragment 的视图。**'
- en: We’ll then go through a similar process for `GameFragment`. We’ll add composables
    to its layout to reproduce its current views, and when we’re certain that they
    work in the way we want, we’ll remove the views from its UI.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们会对 `GameFragment` 进行类似的操作。我们将向其布局中添加组合物以重现其当前的视图，并且当我们确信它们按我们想要的方式工作时，我们将从其
    UI 中删除视图。
- en: '![image](Images/f0814-02.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0814-02.png)'
- en: Let’s start by adding the Compose libraries to the app’s *build.gradle* files.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将 Compose 库添加到应用的 *build.gradle* 文件中。
- en: '![image](Images/f0814-03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0814-03.png)'
- en: Update the project build.gradle file…
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新项目的 build.gradle 文件…
- en: '![image](Images/f0815-01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0815-01.png)'
- en: 'We’ll first add a new variable to the project’s *build.gradle* file to specify
    which version of Compose we’ll use. Open the file *GuessingGame/build.gradle*,
    and add the line below (in bold) to the `buildscript` section:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要在项目的 *build.gradle* 文件中添加一个新变量，以指定我们将使用的 Compose 版本。打开文件 *GuessingGame/build.gradle*，在
    `buildscript` 部分添加以下行（加粗部分）：
- en: '![image](Images/f0815-02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0815-02.png)'
- en: …and update the app build.gradle file, too
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …并且也更新应用的 build.gradle 文件
- en: 'In the app’s *build.gradle* file, we need to add a bunch of Compose options
    and libraries, and make sure the minimum SDK is 21\. Open the file *GuessingGame/app/build.gradle*,
    and add the following lines (in bold) to the appropriate sections:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的 *build.gradle* 文件中，我们需要添加一堆 Compose 选项和库，并确保最低 SDK 版本是 21。打开文件 *GuessingGame/app/build.gradle*，在适当的部分添加以下行（加粗部分）：
- en: '![image](Images/f0815-03.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0815-03.png)'
- en: Once you’ve made these changes, click on the Sync Now option.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些更改后，点击“立即同步”选项。
- en: We’ll replace ResultFragment’s views with composables
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将用组合物替换 `ResultFragment` 的视图
- en: '![image](Images/f0816-01.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0816-01.png)'
- en: Now that we’ve updated the *build.gradle* files to include Compose, we can start
    replacing the app’s views with composables. We’ll begin with `ResultFragment`,
    as this is the simplest fragment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了 *build.gradle* 文件以包含 Compose，我们可以开始用组合物替换应用的视图。我们将从 `ResultFragment`
    开始，因为这是最简单的片段。
- en: 'As you may recall, `ResultFragment`’s layout includes a `TextView` to display
    the game’s result, and a `Button` to let the user start a new game. It looks like
    this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的那样，`ResultFragment` 的布局包括一个 `TextView` 来显示游戏的结果，以及一个 `Button` 让用户开始新游戏。它看起来像这样：
- en: '![image](Images/f0816-02.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0816-02.png)'
- en: 'We can replace these views with composables by using a `Text` composable instead
    of the `TextView`, and a `Button` composable instead of the `Button` view. This
    is what the new UI will look like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `Text` 组合物而不是 `TextView`，以及使用 `Button` 组合物而不是 `Button` 视图来用组合物替换这些视图。这是新
    UI 的样子：
- en: We’ll build the new UI bit by bit so that at first, `ResultFragment` will use
    both views and composables. Let’s begin by finding out how to add composables
    to a layout file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步构建新的 UI，所以一开始，`ResultFragment` 将同时使用视图和组合物。让我们先找出如何将组合物添加到布局文件中。
- en: A ComposeView lets you add composables to a layout
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 ComposeView 允许你将组合物添加到布局中
- en: 'If you want to add composables to a `View`-based UI, you can do so by adding
    a `**ComposeView**` element to the layout file. This is a type of view that can
    display composables, and the code looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想向基于 `View` 的 UI 添加组合物，可以通过向布局文件添加一个 `**ComposeView**` 元素来实现。这是一种可以显示组合物的视图类型，代码如下：
- en: '![image](Images/f0817-01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0817-01.png)'
- en: You can think of a `ComposeView` as a type of view that acts as a placeholder
    for any composables you want to add to the UI in your Kotlin code. When the app
    runs, it displays the layout’s views, and populates the `ComposeView` with composables.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `ComposeView` 理解为一种视图类型，用作在 Kotlin 代码中向 UI 添加任何组合物的占位符。当应用运行时，它会显示布局的视图，并填充
    `ComposeView` 中的组合物。
- en: '**A ComposeView is a View that acts as a placeholder for composables. It lets
    you use Compose in a View-based UI.**'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ComposeView 是一个作为组合物占位符的视图。它让你在基于 View 的 UI 中使用 Compose。**'
- en: We’ll add a ComposeView to fragment_result.xml
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将向 fragment_result.xml 添加一个 ComposeView
- en: We want to add `Text` and `Button` composables to `ResultFragment`’s UI, so
    we need to add a `ComposeView` to its layout file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望向 `ResultFragment` 的 UI 添加 `Text` 和 `Button` 可组合项，因此我们需要在其布局文件中添加一个 `ComposeView`。
- en: 'Here’s the updated code for *fragment_result.xml*; update the file to include
    the changes below (in bold):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *fragment_result.xml* 的更新代码；请更新文件以包括下面的更改（用粗体标记）：
- en: '![image](Images/f0817-02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0817-02.png)'
- en: Now that we’ve added the `ComposeView`, let’s add some composables to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 `ComposeView`，让我们向其添加一些可组合项。
- en: Add composables using Kotlin code
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin 代码添加组件
- en: '![image](Images/f0818-01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0818-01.png)'
- en: 'Once the layout includes a `ComposeView`, you can add composables to it in
    the fragment’s `onCreateView()` method using code like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦布局包含 `ComposeView`，您可以在片段的 `onCreateView()` 方法中使用如下代码向其添加可组合项：
- en: '![image](Images/f0818-02.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0818-02.png)'
- en: 'The code calls `setContent()` on the layout’s `ComposeView`, which tells it
    what composables it needs to include. It then applies this to the fragment’s inflated
    layout. If you wanted to add a `Text` composable to `ResultFragment`’s layout,
    for example, you’d use the code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码在布局的 `ComposeView` 上调用 `setContent()`，告诉它需要包含哪些可组合项。然后将其应用于片段的膨胀布局。例如，如果您想向
    `ResultFragment` 的布局添加一个 `Text` 可组合项，您可以使用以下代码：
- en: '![image](Images/f0818-03.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0818-03.png)'
- en: 'Running this code would display the `Text` composable in the layout’s `ComposeView`
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将在布局的 `ComposeView` 中显示 `Text` 可组合项，如下所示：
- en: '![image](Images/f0818-04.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0818-04.png)'
- en: Add a composable function for the fragment’s content
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为片段内容添加一个可组合函数
- en: '![image](Images/f0819-01.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0819-01.png)'
- en: Now that you’ve learned how to add composables to a `ComposeView`, let’s use
    the one we’ve added to *fragment_result.xml* to replicate its existing views.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何将可组合项添加到 `ComposeView`，让我们使用已添加到 *fragment_result.xml* 的可组合项来复制其现有视图。
- en: We’ll begin by adding a new composable function to *ResultFragment.kt* named
    `ResultFragmentContent`, which we’ll use for the fragment’s UI. We’ll call it
    from `setContent()` so that any composables we add to it will run when `ResultFragment`
    gets displayed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *ResultFragment.kt* 中添加一个名为 `ResultFragmentContent` 的新可组合函数，用于片段的 UI。我们将从
    `setContent()` 中调用它，以便任何添加到其中的可组合项在显示 `ResultFragment` 时运行。
- en: 'Here’s what the new code looks like; we’ll add it to *ResultFragment.kt* a
    few pages ahead:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新代码的样子；我们将在 *ResultFragment.kt* 中添加它，距离前几页：
- en: '![image](Images/f0819-02.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0819-02.png)'
- en: Reproduce the Start New Game button
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重现开始新游戏按钮
- en: Now that we’ve added the `ResultFragmentContent` composable function to *ResultFragment.kt*,
    we can use it to add composables to the UI. We’ll begin by adding a button.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `ResultFragmentContent` 可组合函数添加到 *ResultFragment.kt* 中，我们可以使用它来向 UI
    添加可组合项。我们将首先添加一个按钮。
- en: '![image](Images/f0820-01.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0820-01.png)'
- en: '`ResultFragment` currently includes a button `View` labeled “Start new game”
    that uses the following `OnClickListener` to navigate to `GameFragment` when clicked:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultFragment` 当前包含一个名为“开始新游戏”的按钮 `View`，点击时使用以下 `OnClickListener` 导航到 `GameFragment`：'
- en: '![image](Images/f0820-02.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0820-02.png)'
- en: We can reproduce the button in Compose by creating a new composable function
    named `NewGameButton` that we’ll run from `ResultFragmentContent`. We’ll add a
    lambda argument to `NewGameButton` so that `ResultFragmentContent` can tell it
    what to do when it’s clicked.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个名为 `NewGameButton` 的新可组合函数在 `ResultFragmentContent` 中重现 Compose 中的按钮。我们将为
    `NewGameButton` 添加一个 lambda 参数，以便 `ResultFragmentContent` 在其被点击时告诉它要做什么。
- en: 'Here’s what the new code looks like; we’ll add it to *ResultFragment.kt* a
    couple pages ahead:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新代码的样子；我们将在 *ResultFragment.kt* 中添加它，距离前几页：
- en: '![image](Images/f0820-03.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0820-03.png)'
- en: That’s the button sorted. What about the layout’s text?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮已经设置好了。布局的文本呢？
- en: Reproduce ResultFragment’s TextView
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重现 ResultFragment 的 TextView
- en: 'As you may recall, `ResultFragment` uses a `TextView` in its layout to display
    the game’s result. It’s defined using this code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的那样，`ResultFragment` 在其布局中使用 `TextView` 来显示游戏的结果。它使用以下代码定义：
- en: '![image](Images/f0821-02.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0821-02.png)'
- en: Instead of using a `TextView` to display the text, we can define a new `ResultText`
    composable function that displays the text in a `Text` composable. We’ll add a
    `String` argument to `ResultText` that `ResultFragmentContent` will use to pass
    it the text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不再使用 `TextView` 显示文本，我们可以定义一个新的 `ResultText` 可组合函数，用 `Text` 可组合项显示文本。我们将向 `ResultText`
    添加一个 `String` 参数，以便 `ResultFragmentContent` 将文本传递给它。
- en: 'Here’s the new code; we’ll add it to *ResultFragment.kt* on the next page:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新代码；我们将在下一页上将其添加到*ResultFragment.kt*中：
- en: '![image](Images/f0821-03.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0821-03.png)'
- en: That’s all the code that we need to reproduce all of `ResultFragment`’s views
    with composables. Let’s see what the code looks like.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要用组合重现所有`ResultFragment`视图的所有代码。让我们看看代码是什么样子的。
- en: The updated code for ResultFragment.kt
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResultFragment.kt的更新代码
- en: 'Here’s the updated code for *ResultFragment.kt*; update the file to include
    the changes below (in bold):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*ResultFragment.kt*的更新代码；请更新文件以包含以下更改（用粗体标出）：
- en: '![image](Images/f0822-02.png)![image](Images/f0823-02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0822-02.png)![图像](Images/f0823-02.png)'
- en: Let’s take the app for a test drive.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试驾这个应用程序。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![图像](Images/car.png) 试驾'
- en: When we run the app, `GameFragment` is displayed. When we click on its Finish
    Game button, it navigates to `ResultFragment`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，将显示`GameFragment`。当我们点击其“完成游戏”按钮时，它将导航到`ResultFragment`。
- en: '`ResultFragment` displays the original views, and the composables we just added.
    The `Text` composable displays the correct text, and the `Button` composable navigates
    to `GameFragment` when it’s clicked.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultFragment`显示了原始视图和我们刚刚添加的组合视图。`Text`组合显示了正确的文本，而`Button`组合在点击时导航到`GameFragment`。'
- en: '![image](Images/f0824-02.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0824-02.png)'
- en: The composables we added to `ResultFragment` work exactly how we want them to,
    so the next thing we’ll do is remove the views.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到`ResultFragment`的组合视图的工作方式正是我们想要的，因此我们接下来要做的就是移除视图。
- en: We need to remove ResultFragment’s views…
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要移除ResultFragment的视图...
- en: 'You can remove a fragment or activity’s views in a couple ways:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下几种方式之一移除片段或活动的视图：
- en: '**By removing any views you don’t need from the layout file**'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过从布局文件中移除您不需要的任何视图**'
- en: This approach is useful if the UI contains a mix of views and composables.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果UI包含混合视图和组合，则此方法非常有用。
- en: '**By removing the entire layout file**'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过删除整个布局文件**'
- en: If the UI *only* includes composables, you can delete the layout file, and remove
    any references to it in the activity or fragment’s Kotlin code.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果UI**仅**包含组合，则可以删除布局文件，并在活动或片段的Kotlin代码中删除对其的任何引用。
- en: In the Guessing Game app, we’ve reproduced all of `ResultFragment`’s views with
    composables, so we no longer need any of its original views. This means that we
    can delete its layout file *fragment_result.xml* so that the UI only includes
    composables.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在猜谜游戏应用程序中，我们使用组合重现了`ResultFragment`的所有视图，因此我们不再需要任何原始视图。这意味着我们可以删除其布局文件*fragment_result.xml*，以便UI仅包含组合。
- en: …and update ResultFragment.kt
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '...并更新ResultFragment.kt'
- en: Before we delete the layout file, we first need to remove any references to
    its views from *ResultFragment.kt*, and stop using view binding.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除布局文件之前，我们首先需要从*ResultFragment.kt*中删除对其视图的任何引用，并停止使用视图绑定。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: View binding gives your activity and fragment code an easier way to access a
    layout file’s views. As we’re removing ResultFragment’s layout file, it no longer
    needs to use view binding.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 视图绑定为您的活动和片段代码提供了一种更容易访问布局文件视图的方式。由于我们正在删除ResultFragment的布局文件，因此它不再需要使用视图绑定。
- en: We also need to tweak the fragment’s `onCreateView()` method so that instead
    of inflating a layout file, it adds the composables to the fragment’s UI.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整片段的`onCreateView()`方法，以便不再膨胀布局文件，而是将组合添加到片段的UI中。
- en: 'As you learned in [Chapter 18](ch18.xhtml#jetpack_composecolon_compose_yourself),
    you can do this with an *activity* by simply calling `setContent()` from its `onCreate()`
    method like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第18章](ch18.xhtml#jetpack_composecolon_compose_yourself)中学到的，您可以通过简单调用其`onCreate()`方法中的`setContent()`来对*活动*执行此操作，如下所示：
- en: '![image](Images/f0825-03.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0825-03.png)'
- en: When you’re dealing with a fragment, however, you need a slightly different
    approach. To find out what this is and why, let’s revisit the fragment’s `onCreateView()`
    method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您处理片段时，您需要采用稍微不同的方法。要找出这是什么以及为什么，请让我们重新审视片段的`onCreateView()`方法。
- en: onCreateView() returns the UI’s root view
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`onCreateView()`返回UI的根视图'
- en: As you know, a fragment’s `onCreateView()` method gets called when an activity
    needs to display the fragment’s UI.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，当活动需要显示片段的UI时，片段的`onCreateView()`方法会被调用。
- en: When the UI is defined with a layout file, code in the `onCreateView()` method
    inflates the layout into a hierarchy of views, and returns the root view. The
    root view gets added to the activity’s layout, which displays the fragment’s UI.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用布局文件定义UI时，`onCreateView()`方法中的代码会将布局膨胀为视图层次结构，并返回根视图。根视图会添加到活动的布局中，从而显示片段的UI。
- en: But what if there’s no layout file?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果没有布局文件怎么办？
- en: Return a ComposeView for Compose UIs
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Compose UI 返回一个 ComposeView
- en: If the fragment’s UI is just made up of composables and has no layout file,
    **the** `**onCreateView()**` **method must still return a** `**View?**`**, or
    the code won’t compile**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果片段的 UI 仅由组件组成且没有布局文件，**`**onCreateView()**`** 方法仍必须返回一个**`**View?**`**，否则代码无法编译**。
- en: 'You deal with this by making the method return a `ComposeView` that includes
    all of the UI’s composables. Here’s what the code for this looks like:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使方法返回一个 `ComposeView`，该方法包含所有 UI 的组件，来处理此问题。下面是这段代码的样子：
- en: '![image](Images/f0826-02.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0826-02.png)'
- en: When the activity needs to display the fragment’s UI, it calls the fragment’s
    `onCreateView()` method as before. The method returns a `ComposeView` that includes
    the fragment’s composables, which are then displayed by the activity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动需要显示片段的 UI 时，它像以前一样调用片段的 `onCreateView()` 方法。该方法返回一个 `ComposeView`，其中包含片段的组件，然后活动显示这些组件。
- en: That’s everything you need to know to complete the code for *ResultFragment.kt*.
    We’ll show you the full code over the next few pages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你完成 *ResultFragment.kt* 代码所需知道的所有内容。接下来的几页我们会展示完整的代码。
- en: The full code for ResultFragment.kt
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ResultFragment.kt 的完整代码
- en: 'Here’s the complete code for *ResultFragment.kt*; update the file to include
    the changes below (in bold):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*ResultFragment.kt* 的完整代码如下；请更新文件以包含以下更改（用粗体标出）：'
- en: '![image](Images/f0827-02.png)![image](Images/f0828-02.png)![image](Images/f0829-02.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0827-02.png)![image](Images/f0828-02.png)![image](Images/f0829-02.png)'
- en: We can delete fragment_result.xml
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以删除 fragment_result.xml
- en: Now that `ResultFragment` is no longer using its layout file, we’ll remove any
    references to *fragment_result.xml* from the navigation graph, and delete the
    layout file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ResultFragment` 不再使用其布局文件，我们将从导航图中删除对 *fragment_result.xml* 的任何引用，并删除布局文件。
- en: 'First, open *nav_graph.xml* in the *app/src/main/res/navigation* folder, and
    remove the reference to `"@layout/fragment_result"` from the `ResultFragment`
    section like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 *app/src/main/res/navigation* 文件夹中的 *nav_graph.xml*，并从 `ResultFragment`
    部分中移除对 `"@layout/fragment_result"` 的引用，就像这样：
- en: '![image](Images/f0829-03.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0829-03.png)'
- en: Then right-click on *fragment_result.xml* in the explorer, choose Refactor,
    and then select the Safe Delete option. When you click on the OK button and choose
    the option to do the refactor, the file is deleted.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在资源管理器中右键单击 *fragment_result.xml*，选择“重构”，然后选择“安全删除”选项。点击“确定”按钮并选择重构选项，文件就会被删除。
- en: Let’s go through what happens when we run the app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行应用程序时会发生什么。
- en: What happens when the app runs
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序运行时会发生什么
- en: '![image](Images/f0830-01.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0830-01.png)'
- en: 'The following things happen when the app runs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行时会发生以下事情：
- en: '**MainActivity launches and displays GameFragment in its layout.**'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**MainActivity 启动并在其布局中显示 GameFragment。**'
- en: '![image](Images/f0830-02.png)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0830-02.png)'
- en: '**When the user clicks on the Finish Game button, or wins or loses the game,
    the app navigates to ResultFragment and calls its onCreateView() method.**'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当用户点击完成游戏按钮，或者赢得或输掉游戏时，应用程序导航到 ResultFragment 并调用其 onCreateView() 方法。**'
- en: '![image](Images/f0830-03.png)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0830-03.png)'
- en: '**The onCreateView() method creates a ComposeView.**'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**onCreateView() 方法创建一个 ComposeView。**'
- en: '![image](Images/f0830-04.png)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0830-04.png)'
- en: '**The onCreateView() method sets the ComposeView’s content to ResultFragmentContent.**'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**onCreateView() 方法将 ComposeView 的内容设置为 ResultFragmentContent。**'
- en: '![image](Images/f0830-05.png)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0830-05.png)'
- en: '**When ResultFragmentContent runs, it calls the ResultText and NewGameButton
    composables.**'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当 ResultFragmentContent 运行时，它会调用 ResultText 和 NewGameButton 组件。**'
- en: The composables are added to the `ComposeView`.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 组件添加到 `ComposeView` 中。
- en: '![image](Images/f0831-02.png)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0831-02.png)'
- en: '**The onCreateView() method returns the ComposeView to MainActivity.**'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**onCreateView() 方法将 ComposeView 返回给 MainActivity。**'
- en: '![image](Images/f0831-03.png)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0831-03.png)'
- en: '**MainActivity displays the ComposeView in its layout.**'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**MainActivity 在其布局中显示 ComposeView。**'
- en: The `ComposeView`’s composables are displayed on the device.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ComposeView` 的组件显示在设备上。'
- en: '![image](Images/f0831-04.png)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0831-04.png)'
- en: Let’s take the app for a test drive.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下这个应用程序。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: When we run the app and click on `GameFragment`’s Finish Game button, it navigates
    to `ResultFragment` as before. This time, however, the UI is just made up of composables.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序并点击 `GameFragment` 的“完成游戏”按钮时，它会像以前一样导航到 `ResultFragment`。但这次，UI 只由组件组成。
- en: '![image](Images/f0832-02.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0832-02.png)'
- en: That’s everything we need to make `ResultFragment` use a Compose UI. Before
    we get to work on `GameFragment`, have a go at the exercise on the next page.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们让`ResultFragment`使用Compose UI所需的一切。在我们开始`GameFragment`之前，先试一试下一页上的练习。
- en: Pool Puzzle
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题
- en: '![image](Images/common01.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common01.png)'
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in the code below. You may **not** use the same snippet more than
    once, and you won’t need to use all the snippets. Your **goal** is to write the
    code for a fragment named `MusicFragment` that has no layout file and uses a composable
    function named `MusicFragmentContent` for its UI. A theme named `MusicTheme` needs
    to be applied to the UI, including any surfaces.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**任务**是从池中取出代码片段，并将其放入下面代码中的空白行中。你不能多次使用同一片段，并且不需要使用所有片段。你的**目标**是为名为`MusicFragment`的片段编写代码，该片段没有布局文件，并使用名为`MusicFragmentContent`的组合函数进行其UI显示。需要将名为`MusicTheme`的主题应用到UI中，包括任何表面。
- en: '[PRE0]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![image](Images/f0833-01.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0833-01.png)'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note: each thing from the pool can only be used once!**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：池中的每个物品只能使用一次！**'
- en: '![Images](Images/arr.png) **Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution-id00328).**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![Images](Images/arr.png) **答案请参阅[“Pool Puzzle Solution”](#pool_puzzle_solution-id00328)。**'
- en: Next we’ll make GameFragment use composables too
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来我们将让`GameFragment`也使用组合部件
- en: '![image](Images/f0834-01.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0834-01.png)'
- en: Now that we’ve made `ResultFragment` use composables instead of views, we can
    do a similar thing for `GameFragment`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让`ResultFragment`使用组合部件而不是视图，我们可以对`GameFragment`做类似的事情。
- en: 'As you may recall, `GameFragment`’s layout includes `TextView`s, `Button`s,
    and an `EditText` to let the user play the guessing game. Here’s a reminder of
    what it looks like:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的那样，`GameFragment`的布局包括`TextView`、`Button`和一个`EditText`，让用户进行猜谜游戏。这是其外观的提醒：
- en: '![image](Images/f0834-02.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0834-02.png)'
- en: 'Over the next few pages, we’re going to replace these views with composables.
    Here’s what the new UI will look like when we’ve finished:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将用组合部件替换这些视图。完成后，新的UI将如下所示：
- en: '![image](Images/f0834-03.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0834-03.png)'
- en: As before, we’ll begin by adding new composables to `GameFragment`’s UI, which
    means we need to add a `ComposeView` to its layout. We’ll show you the code for
    this on the next page.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们将首先向`GameFragment`的UI添加新的组合部件，这意味着我们需要在其布局中添加一个`ComposeView`。我们将在下一页展示此代码。
- en: We’ll add a ComposeView to fragment_game.xml
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将向fragment_game.xml添加一个ComposeView
- en: '![image](Images/f0835-01.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0835-01.png)'
- en: 'Here’s the code to add a `ComposeView` to `GameFragment`’s layout; update the
    file *fragment_game.xml* to include the changes below (in bold):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将`ComposeView`添加到`GameFragment`的布局中的代码；更新文件*fragment_game.xml*以包含以下更改（用粗体标出）：
- en: '![image](Images/f0835-02.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0835-02.png)'
- en: Now that we’ve updated the layout file, let’s start adding composables to it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了布局文件，让我们开始向其添加组合部件。
- en: Add a composable function for GameFragment’s content
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为GameFragment的内容添加一个组合函数
- en: '![image](Images/f0836-01.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0836-01.png)'
- en: Just as we did with *ResultFragment.kt*, we’ll add a new composable function
    to *GameFragment.kt* that we’ll use for the fragment’s UI. We’ll name the function
    `GameFragmentContent`, and call it from `setContent()` so that any composables
    we add to it will run when `GameFragment` gets displayed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在*ResultFragment.kt*中所做的那样，我们将向*GameFragment.kt*添加一个新的组合函数，用于片段的UI。我们将命名该函数为`GameFragmentContent`，并从`setContent()`中调用它，以便我们添加到其中的任何组合部件在显示`GameFragment`时运行。
- en: 'Here’s what the new code looks like; we’ll add it to *GameFragment.kt* a few
    pages ahead:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新代码的样子；我们将在几页后将其添加到*GameFragment.kt*中：
- en: '![image](Images/f0836-02.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0836-02.png)'
- en: Reproduce the Finish Game button
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制完成游戏按钮
- en: Just as we did with `ResultFragment`, we’ll add composables to the `GameFragmentContent`
    composable function so that they’re displayed in `GameFragment`’s UI. We’ll begin
    by reproducing the Finish Game button.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`ResultFragment`中所做的那样，我们将向`GameFragmentContent`的组合函数添加组合部件，以便它们显示在`GameFragment`的UI中。我们将从复制完成游戏按钮开始。
- en: 'The Finish Game button is defined using the following code in the fragment’s
    layout:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结束游戏按钮在片段布局中的定义如下所示：
- en: '![image](Images/f0837-02.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0837-02.png)'
- en: As you can see, when the button is clicked, it calls `GameViewModel`’s `finishGame()`
    method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，当按钮被点击时，它会调用`GameViewModel`的`finishGame()`方法。
- en: 'We can reproduce this in Compose by creating a new composable function named
    `FinishGameButton` that we’ll run from `GameFragmentContent`. Here’s what the
    new code looks like; we’ll add it to *GameFragment.kt* a few pages ahead:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个名为`FinishGameButton`的新组合函数来在Compose中复制这个功能，我们将从`GameFragmentContent`运行它。这是新代码的样子；我们将在接下来的*GameFragment.kt*几页上添加它：
- en: '![image](Images/f0837-03.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0837-03.png)'
- en: Reproduce the EditText with a TextField
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制带有TextField的EditText
- en: 'The next view we’ll reproduce is the `EditText` that lets the user enter a
    letter. We’ll create a new composable function named `EnterGuess` that uses a
    `TextField`, and accepts two arguments: a `String` for the user’s guess, and a
    lambda that specifies what should happen when the value changes.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将复制的视图是允许用户输入字母的`EditText`。我们将创建一个名为`EnterGuess`的新组合函数，它使用一个`TextField`，并接受两个参数：一个用于用户猜测的`String`，以及一个指定值更改时应发生的操作的lambda函数。
- en: '![image](Images/f0838-02.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0838-02.png)'
- en: We’ll run the `EnterGuess` function from `GameFragmentContent` so that it’s
    added to the fragment’s UI. We’ll also add a `MutableState` object named `guess`
    to `GameFragmentContent,` which we’ll use to manage the `TextField`’s state.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`GameFragmentContent`运行`EnterGuess`函数，以便将其添加到片段的UI中。我们还将在`GameFragmentContent`中添加一个名为`guess`的`MutableState`对象，我们将用它来管理`TextField`的状态。
- en: '![image](Images/f0838-03.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0838-03.png)'
- en: 'Here’s what the new code looks like; we’ll add it to *GameFragment.kt* a couple
    pages ahead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新代码的样子；我们将它添加到稍后的*GameFragment.kt*页面上：
- en: '![image](Images/f0838-04.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0838-04.png)'
- en: Reproduce the Guess button
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制猜测按钮
- en: Now that we’ve added a `TextField` to the UI that lets the user enter a letter,
    we’ll add a `Button` composable that passes the letter to the view model’s `makeGuess()`
    method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在UI中添加了一个允许用户输入字母的`TextField`，我们将添加一个`Button`组合项，将字母传递给视图模型的`makeGuess()`方法。
- en: '![image](Images/f0839-02.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0839-02.png)'
- en: 'We’ll add the `Button` using a new composable function named `GuessButton`
    that we’ll run from `GameFragmentContent`. Here’s what the new code looks like;
    we’ll add it to *GameFragment.kt* on the next page:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为`GuessButton`的新组合函数添加`Button`，我们将从`GameFragmentContent`运行。这是新代码的样子；我们将在接下来的*GameFragment.kt*页面上添加它：
- en: '![image](Images/f0839-03.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0839-03.png)'
- en: We’ve now reproduced three of `GameFragment`’s views with composables. Before
    we tackle the remaining ones, let’s update *GameFragment.kt* and take the app
    for a test drive.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经用组合项复制了`GameFragment`的三个视图。在我们处理剩余部分之前，让我们更新*GameFragment.kt*并进行测试。
- en: The updated code for GameFragment.kt
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于GameFragment.kt的更新代码
- en: 'Here’s the code so far for *GameFragment.kt*; update the file to include the
    changes below (in bold):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止*GameFragment.kt*的代码；更新文件以包括以下更改（用**粗体**表示）：
- en: '![image](Images/f0840-02.png)![image](Images/f0841-02.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0840-02.png)![image](Images/f0841-02.png)'
- en: Let’s take the app for a test drive.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下这个应用程序。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驱动'
- en: When we run the app, `GameFragment` is displayed. It includes all its original
    views, along with three extra composables that let us make guesses and finish
    the game.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，显示`GameFragment`。它包括所有原始视图，以及三个额外的组合项，让我们可以猜测和完成游戏。
- en: When we use the `EnterGuess` and `GuessButton` composables to guess which letters
    the secret word contains, the app registers each guess. If we make a correct guess,
    the letter is added to the secret word display, and if we make a wrong guess,
    the number of lives left is updated and the letter is added to the list of incorrect
    guesses.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`EnterGuess`和`GuessButton`组合项猜测秘密单词中包含的字母时，应用程序会注册每次猜测。如果我们猜对了，该字母将被添加到秘密单词显示中；如果我们猜错了，剩余生命次数将被更新，并且该字母将被添加到错误猜测列表中。
- en: '![image](Images/f0842-02.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0842-02.png)'
- en: Now that we know the three composables we’ve added work, let’s tackle the remaining
    ones.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们添加的三个组合项有效的方法，让我们来处理剩下的部分。
- en: We’ll display the incorrect guesses in a Text composable
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们将在Text组合中显示错误的猜测
- en: The next view we’ll reproduce is a `TextView` that uses live data to display
    the user’s incorrect guesses. Each time the user makes a wrong guess, it gets
    added to the `incorrectGuesses` property in the view model, and the `TextView`
    responds by updating the text it displays.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制的下一个视图是一个使用LiveData来显示用户错误猜测的`TextView`。每次用户猜错时，它会将其添加到视图模型的`incorrectGuesses`属性中，而`TextView`则通过更新其显示的文本来响应。
- en: 'Here’s a reminder of the `TextView`’s code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`TextView`的代码的提醒：
- en: '![image](Images/f0843-02.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0843-02.png)'
- en: We can replace the `TextView` with a `Text` composable so that it displays the
    same text, but how do we make sure the text gets updated when the `incorrectGuesses`
    property value changes?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`Text`可组合项替换`TextView`，以便显示相同的文本，但如何确保在`incorrectGuesses`属性值更改时更新文本？
- en: Respond to LiveData using observeAsState()
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`observeAsState()`响应`LiveData`
- en: As you learned in [Chapter 18](ch18.xhtml#jetpack_composecolon_compose_yourself),
    composables are recomposed when any `State` or `MutableState` objects they depend
    on get new values. This *doesn’t* happen, however, for `LiveData` objects—like
    the view model’s `incorrectGuesses` property. If you try to use a `LivaData` object’s
    value with a composable, it won’t get redrawn when its value changes; it will
    just keep using the object’s initial value, so it won’t stay up-to-date.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第18章](ch18.xhtml#jetpack_composecolon_compose_yourself)中学到的那样，当依赖于`State`或`MutableState`对象的可组合项获得新值时，它们会被重新组合。然而，对于`LiveData`对象，却不会发生这种情况——比如视图模型的`incorrectGuesses`属性。如果尝试在可组合项中使用`LiveData`对象的值，当其值更改时不会重新绘制；它将继续使用对象的初始值，因此不会保持最新状态。
- en: If you want to make a composable respond to `LiveData` updates, you can do so
    using the `**observeAsState()**` function. This function returns a `State` version
    of a `LiveData` object so that any composables that depend on it are recomposed
    when its value changes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让可组合项响应`LiveData`更新，可以使用`**observeAsState()**`函数实现。此函数返回`LiveData`对象的`State`版本，因此任何依赖于它的可组合项在其值更改时都会重新组合。
- en: 'You use the `observeAsState()` function with code like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码使用`observeAsState()`函数：
- en: '![image](Images/f0843-04.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0843-04.png)'
- en: This defines a variable (whose type is `State`) that observes the view model’s
    `incorrectGuesses LiveData` property. It means that when its value changes, composables
    can respond.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个变量（其类型为`State`），该变量观察视图模型的`incorrectGuesses LiveData`属性。这意味着当其值更改时，可组合项可以做出响应。
- en: Let’s put this into practice by reproducing `GameFragment`’s incorrect guesses
    `TextView` in Compose.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在Compose中复制`GameFragment`的错误猜测`TextView`来将其付诸实践。
- en: Create an IncorrectGuessesText composable function
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个名为`IncorrectGuessesText`的可组合函数
- en: To reproduce the incorrect guesses `TextView`, we’ll define a new composable
    function named `IncorrectGuessesText`. The function will accept a `GameViewModel`
    argument, observe its `incorrectGuesses` property, and use a `Text` composable
    to display its value in the UI. Each time the property’s value gets updated, the
    `Text` will be recomposed and display the updated text.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制错误猜测的`TextView`，我们将定义一个名为`IncorrectGuessesText`的新可组合函数。该函数将接受一个`GameViewModel`参数，观察其`incorrectGuesses`属性，并使用`Text`可组合项在UI中显示其值。每次属性的值更新时，`Text`将重新组合并显示更新的文本。
- en: 'Here’s what the `IncorrectGuessesText` function looks like:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`IncorrectGuessesText`函数的样子：
- en: '![image](Images/f0844-02.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0844-02.png)'
- en: As you can see, the `Text` composable in the above code uses a function named
    `stringResource()` to set its text. This function lets you use `String` resources
    with composables, and pass arguments to them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，上述代码中的`Text`可组合项使用了一个名为`stringResource()`的函数来设置其文本。该函数允许您在可组合项中使用字符串资源，并向其传递参数。
- en: Run IncorrectGuessesText from GameFragmentContent
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从`GameFragmentContent`中运行`IncorrectGuessesText`
- en: 'Just like the other composable functions we’ve created, we’ll add `IncorrectGuessesText`
    to `GameFragment`’s UI by running it from the `GameFragmentContent` composable
    function. The new code looks like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们创建的其他可组合函数一样，通过从`GameFragmentContent`可组合函数运行`IncorrectGuessesText`，我们将它添加到`GameFragment`的UI中。新代码如下所示：
- en: '![image](Images/f0844-03.png)![image](Images/f0844-04.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0844-03.png)![image](Images/f0844-04.png)'
- en: We’ll update *GameFragment.kt* a few pages ahead. First, see if you can piece
    together the code for the remaining two composables by having a go at the following
    exercise.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的几页更新*GameFragment.kt*。首先，请尝试通过以下练习来组合剩余两个可组合项的代码。
- en: Compose Magnets
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合磁铁
- en: '![image](Images/common02.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common02.png)'
- en: Someone used fridge magnets to create two new composable functions (named `SecretWordDisplay`
    and `LivesLeftText`) that reproduce `GameFragment`’s two remaining views. Unfortunately
    some of the magnets fell off when someone unleashed the kitchen kraken. Can you
    piece the code back together again?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有人使用冰箱磁铁创建了两个新的可组合函数（名为`SecretWordDisplay`和`LivesLeftText`），用来复制`GameFragment`的两个剩余视图。不幸的是，当有人释放厨房的海怪时，其中一些磁铁掉落了。您能够重新组合代码吗？
- en: The `SecretWordDisplay` function needs to display the `secretWordDisplay LiveData<String>`
    property from `GameViewModel`. The `LivesLeftText` function needs to display the
    `lives_left String` resource, and pass it `GameViewModel`’s `livesLeft LiveData<Int>`
    property. Both functions need to be able to respond to live data updates.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecretWordDisplay`函数需要显示来自`GameViewModel`的`secretWordDisplay LiveData<String>`属性。`LivesLeftText`函数需要显示`lives_left
    String`资源，并传递给`GameViewModel`的`livesLeft LiveData<Int>`属性。这两个函数都需要能够响应实时数据更新。'
- en: '[PRE1]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![image](Images/f0845-01.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0845-01.png)'
- en: Compose Magnets Solution
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合磁铁解决方案
- en: '![image](Images/common02.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common02.png)'
- en: Someone used fridge magnets to create two new composable functions (named `SecretWordDisplay`
    and `LivesLeftText`) that reproduce `GameFragment`’s two remaining views. Unfortunately
    some of the magnets fell off when someone unleashed the kitchen kraken. Can you
    piece the code back together again?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有人使用冰箱磁铁创建了两个新的可组合函数（名为`SecretWordDisplay`和`LivesLeftText`），复制了`GameFragment`的两个剩余视图。不幸的是，当有人释放厨房大章鱼时，一些磁铁掉了下来。你能把代码拼回去吗？
- en: The `SecretWordDisplay` function needs to display the `secretWordDisplay LiveData<String>`
    property from `GameViewModel`. The `LivesLeftText` function needs to display the
    `lives_left String` resource, and pass it `GameViewModel`’s `livesLeft LiveData<Int>`
    property. Both functions need to be able to respond to live data updates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecretWordDisplay`函数需要显示来自`GameViewModel`的`secretWordDisplay LiveData<String>`属性。`LivesLeftText`函数需要显示`lives_left
    String`资源，并传递给`GameViewModel`的`livesLeft LiveData<Int>`属性。这两个函数都需要能够响应实时数据更新。'
- en: '![image](Images/f0846-01.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0846-01.png)'
- en: The updated code for GameFragment.kt
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameFragment.kt的更新代码
- en: 'You now know how to reproduce all of `GameFragment`’s views with composables,
    so let’s add them to *GameFragment.kt*. Update the file to include the changes
    below (in bold):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何用可组合部分重现所有`GameFragment`的视图了，让我们将它们添加到*GameFragment.kt*中。更新文件以包含下面显示的所有更改（**粗体部分**）。
- en: '![image](Images/f0847-02.png)![image](Images/f0848-02.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0847-02.png)![image](Images/f0848-02.png)'
- en: Let’s take the app for a test drive.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下这个应用程序。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: When we run the app, `GameFragment` includes all its original views, and their
    Compose equivalents.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，`GameFragment`包括所有原始视图及其Compose等效部分。
- en: When we try to guess which letters the secret word contains, the text in the
    `SecretWordDisplay`, `LivesLeftText`, and `IncorrectGuessesText` composables is
    automatically updated.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试猜测秘密单词包含的字母时，`SecretWordDisplay`、`LivesLeftText`和`IncorrectGuessesText`中的文本可组合部分会自动更新。
- en: '![image](Images/f0849-02.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0849-02.png)'
- en: We’ve now made sure that all of `GameFragment`’s composables work just the way
    we want. All that’s left is for us to remove the fragment’s views.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 确保现在所有`GameFragment`的可组合部分都按我们的意愿工作。剩下的就是删除片段的视图。
- en: Remove views from GameFragment.kt
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从GameFragment.kt中删除视图
- en: Just as we did with `ResultFragment`, we’ll remove `GameFragment`’s views by
    deleting its layout file. Before we can do this, however, we need to remove any
    references to the views from *GameFragment.kt*. We’ll also stop using data binding,
    as this is no longer needed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们处理`ResultFragment`一样，我们将通过删除其布局文件来删除`GameFragment`的视图。但在此之前，我们需要从*GameFragment.kt*中移除对视图的任何引用。由于不再需要数据绑定，我们也将停止使用它。
- en: 'Here’s the full code for the file; update *GameFragment.kt* to include all
    the changes shown below (in bold):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文件的完整代码；更新*GameFragment.kt*以包含下面显示的所有更改（**粗体部分**）：
- en: '![image](Images/f0850-02.png)![image](Images/f0851-02.png)![image](Images/f0852-02.png)![image](Images/f0853-02.png)![image](Images/f0854-02.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0850-02.png)![image](Images/f0851-02.png)![image](Images/f0852-02.png)![image](Images/f0853-02.png)![image](Images/f0854-02.png)'
- en: Those are all the changes we need to make to *GameFragment.kt* so that it doesn’t
    inflate its layout or reference any of its views.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们需要对*GameFragment.kt*进行的更改，以便它不再填充其布局或引用任何视图。
- en: As the fragment no longer needs to have a layout file, we can go ahead and delete
    it after we’ve removed any references to it from the navigation graph. We’ll do
    this on the next page.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该片段不再需要有布局文件，我们可以在从导航图中删除引用之后立即删除它。我们将在下一页上执行此操作。
- en: Delete fragment_game.xml
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除fragment_game.xml
- en: The navigation graph includes a reference to the layout file *fragment_game.xml*.
    We need to remove this before we can remove the layout file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 导航图包括对布局文件*fragment_game.xml*的引用。在删除布局文件之前，我们需要移除这个引用。
- en: 'Open *nav_graph.xml* in the *app/src/main/res/navigation* folder, and remove
    the line that references `"@layout/fragment_game"` from the `GameFragment` section
    like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*app/src/main/res/navigation*文件夹中的*nav_graph.xml*，并从`GameFragment`部分中删除引用`"@layout/fragment_game"`的行，如下所示：
- en: '![image](Images/f0855-02.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0855-02.png)'
- en: Then right-click on *fragment_game.xml* in the explorer, choose Refactor, and
    select the Safe Delete option. When you click on the OK button and choose the
    option to do the refactor, the file is deleted.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在资源管理器中右键单击*fragment_game.xml*，选择重构，然后选择安全删除选项。 单击“确定”按钮并选择重构选项后，文件将被删除。
- en: We can also switch off data binding
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们还可以关闭数据绑定
- en: One final change we can make to the Guessing Game app is to disable data binding.
    As you may recall, we originally enabled data binding so that views in *fragment_game.xml*
    and *fragment_result.xml* could interact with each fragment’s view model. Now
    that we’ve deleted the layout files, data binding is no longer required.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对猜谜游戏应用程序进行最后一次更改，即禁用数据绑定。 您可能还记得，最初我们启用了数据绑定，以便*fragment_game.xml*和*fragment_result.xml*中的视图可以与每个片段的视图模型交互。
    现在我们已经删除了布局文件，因此不再需要数据绑定。
- en: 'To switch off data binding, open the file *GuessingGame/app/build.gradle*,
    and remove the data binding line from the `buildFeatures` section like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭数据绑定，请打开文件*GuessingGame/app/build.gradle*，并从`buildFeatures`部分中删除数据绑定行，如下所示：
- en: '![image](Images/f0855-03.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0855-03.png)'
- en: When you’ve done this, click on the Sync Now option to sync the change with
    the rest of the project.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击“立即同步”选项，将更改与项目的其余部分同步。
- en: Let’s take the app for a final test drive.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对应用程序进行最后一次测试。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: When we run the app, `GameFragment` is displayed. This time, its UI is just
    made up of composables. They work exactly how we want them to.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，显示`GameFragment`。 这次，它的用户界面仅由可组合项组成。 它们的功能正是我们想要的。
- en: '![image](Images/f0856-02.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0856-02.png)'
- en: Congratulations! You’ve now learned how to add composables to an existing `View`-based
    UI, and even replace your UI with one that just uses Compose.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！ 您现在已经学会如何向现有的基于`View`的UI添加可组合项，甚至用仅使用Compose的UI替换您的UI。
- en: We think Compose has a bright future ahead of it, and you can find out more
    about it in the appendix. In the meantime, why not try adding composables to some
    of the other apps you’ve built in this book?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为Compose的未来一片光明，您可以在附录中了解更多信息。与此同时，为什么不尝试将可组合项添加到您在本书中构建的其他一些应用程序中呢？
- en: Pool Puzzle Solution
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池谜题解
- en: '![image](Images/common01.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common01.png)'
- en: Your **job** is to take code snippets from the pool and place them into the
    blank lines in the code below. You may **not** use the same snippet more than
    once, and you won’t need to use all the snippets. Your **goal** is to write the
    code for a fragment named `MusicFragment` that has no layout file and uses a composable
    function named `MusicFragmentContent` for its UI. A theme named `MusicTheme` needs
    to be applied to the UI, including any surfaces.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您的**任务**是从池中获取代码片段，并将它们放入下面代码中的空白行中。 您不能多次使用相同的代码片段，并且不需要使用所有的片段。 您的**目标**是编写一个名为`MusicFragment`的片段代码，该片段没有布局文件，并使用名为`MusicFragmentContent`的可组合函数来构建其用户界面。
    UI还需要应用名为`MusicTheme`的主题，包括任何表面。
- en: '![image](Images/f0857-01.png)![image](Images/f0857-02.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0857-01.png)![image](Images/f0857-02.png)'
- en: Your Android Toolbox
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Android工具箱
- en: '![image](Images/tools.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/tools.png)'
- en: '**You’ve got [Chapter 19](#integrating_compose_with_viewscolon_perf) under
    your belt and now you’ve added integrating Jetpack Compose to your toolbox.**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**您已掌握[第19章](#integrating_compose_with_viewscolon_perf)，现在还添加了将Jetpack Compose集成到您的工具箱中。**'
- en: '![image](Images/f0858-01.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0858-01.png)'
- en: Leaving town
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离开城市
- en: '![image](Images/f0859-01.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0859-01.png)'
- en: It’s been great having you here in Androidville
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Androidville的这段时间真是太棒了
- en: '**We’re sad to see you leave,** but there’s nothing like taking what you’ve
    learned and putting it to good use. There are still a few more gems for you in
    the back of the book and a handy index to study, and then it’s time to take all
    these new ideas and put them into practice. Bon voyage!'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们很难过看到您离开**，但没有什么比学到的东西付诸实践更好了。 本书的尾声还有一些宝贵的信息和一个便捷的索引供您学习，然后就是将所有这些新想法付诸实践的时候了。
    一路顺风！'
