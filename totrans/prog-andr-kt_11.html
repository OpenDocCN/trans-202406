<html><head></head><body><section data-pdf-bookmark="Chapter 11. Performance Considerations with &#10;Android Profiling Tools" data-type="chapter" epub:type="chapter"><div class="chapter" id="android_profiling_tools">&#13;
<h1><span class="label">Chapter 11. </span>Performance Considerations with &#13;
<span class="keep-together">Android Profiling Tools</span></h1>&#13;
&#13;
&#13;
<p><a data-primary="Android profiling tools" data-type="indexterm" id="ix_ch11-asciidoc0"/>Using proficient concurrency in Android leads to better performance in your application. This is why we have made Kotlin&#13;
concurrency in Android the primary focus of this book. In order to provide a solution for performance bottlenecks, you have to be able to&#13;
spot them in the first place. Have no worry: this chapter looks at popular Android tooling commonly used to&#13;
check for potential problems in performance.</p>&#13;
&#13;
<p>Out in the wild, Android faces real-life challenges that affect performance and battery life. For example,&#13;
not everyone has unlimited data in their mobile plans, or reliable connectivity. The reality is that&#13;
Android apps must compete with one another for limited resources. Performance should be a serious consideration&#13;
for any Android application. Android development doesn’t stop at creating an app. Effective development&#13;
also ensures a smooth and seamless user experience. Even if you have a deep understanding of Android development,&#13;
your application may have issues such as:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Decrease in performance</p>&#13;
</li>&#13;
<li>&#13;
<p>Slow startup/slow response to user interactions</p>&#13;
</li>&#13;
<li>&#13;
<p>Battery drain</p>&#13;
</li>&#13;
<li>&#13;
<p>Wasteful use of resources, and clogged memory</p>&#13;
</li>&#13;
<li>&#13;
<p>UI bugs that don’t force a crash or generate an exception, but nevertheless affect user experience</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This list of sudden, strange behaviors in an app is by no means exhaustive. As previous chapters showed, managing multithreading can become complex when there are also interacting Android components to keep track of. Even if you have a solid understanding of multithreading, it’s hard to say how an application really works until we&#13;
analyze performance with profiling tools. To answer these kinds of ambiguities, there are several useful tools for profiling various aspects of Android. Four of them can be retrieved and used right in Android Studio, as diagrammed in <a data-type="xref" href="#android_profiler">Figure 11-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="android_profiler">&#13;
<img alt="Android Studio profilers" src="assets/pawk_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>Android Studio profilers and LeakCanary are useful for identifying performance bottlenecks.</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this chapter, we look at profiling tools in Android Studio’s <em>Android Profiler</em> and a popular open source library called&#13;
<em>LeakCanary</em>. We explore each one by profiling a real-life application for potential performance bottlenecks. Remember&#13;
the hiking application described in previous chapters? Surprise! It was inspired by<a data-primary="TrekMe" data-type="indexterm" id="idm46669737457552"/> <em>TrekMe.</em> TrekMe is an Android&#13;
trail-trekking app, an open source Android project where users download interactive topographical hiking routes to use&#13;
offline later while on hikes. TrekMe started as a Java project, but its codebase is currently 80%+ Kotlin. Here are some&#13;
important features of TrekMe that users of the application can enjoy:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Download topographical maps for offline use.</p>&#13;
</li>&#13;
<li>&#13;
<p>Get the device’s live position even when there’s no network, while the app tries its best to preserve battery life.</p>&#13;
</li>&#13;
<li>&#13;
<p>Track hikes in great detail without draining the device’s battery when you need it most.</p>&#13;
</li>&#13;
<li>&#13;
<p>Access other useful information without needing an internet connection (save for creating the map).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We encourage you to explore TrekMe so you can follow along with this chapter. You can <a href="https://oreil.ly/j7KbY">retrieve the source&#13;
code from GitHub</a>. Once you’ve cloned the project, open it with Android Studio. Finally, run an instance of an emulator from the <em>Android Virtual Device (AVD) Manager</em> that you intend to run TrekMe on.</p>&#13;
&#13;
<p>Performance considerations are crucial. It;s not uncommon to find performance lag in any application, but such a&#13;
“fishing expedition” must be approached with care. It’s up to the developer to decide on the most relevant&#13;
tooling, and which optimizations outweigh in benefits the cost of their creation. Profiling your app allows you to&#13;
investigate application performance objectively. To give some examples of the kinds of surprises you might&#13;
encounter, we’ll look at TrekMe with Android Profiler.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android Profiler" data-type="sect1"><div class="sect1" id="_android_profiler">&#13;
<h1>Android Profiler</h1>&#13;
&#13;
<p><a data-primary="Android Profiler" data-type="indexterm" id="ix_ch11-asciidoc2"/><a data-primary="Android profiling tools" data-secondary="Android Profiler" data-type="indexterm" id="ix_ch11-asciidoc3"/><em>Android Profiler</em> <a data-primary="Android Profiler" data-secondary="about" data-type="indexterm" id="ix_ch11-asciidoc4"/>analyzes an application’s session to generate real-time feeds for CPU usage and memory&#13;
usage, as well as network and energy profiling. <a data-type="xref" href="#android_profiler_intro">Figure 11-2</a> shows Android Studio with&#13;
the TrekMe application runtime showing in the bottom half of the console.</p>&#13;
&#13;
<figure><div class="figure" id="android_profiler_intro">&#13;
<img alt="Android Profiler" src="assets/pawk_1102.png"/>&#13;
<h6><span class="label">Figure 11-2. </span>A profiling session records profiling data. The active session attaches to the running app in the emulator (not pictured).</h6>&#13;
</div></figure>&#13;
&#13;
<p>Android profiling can be instantiated in three ways:</p>&#13;
<ol>&#13;
<li>&#13;
<p>If your application is not running, click the Profile app icon in the upper-right corner to instantiate the app&#13;
and the profiler at once. This action builds and compiles a new running instance of the application. Android Studio will&#13;
then open a new session giving you a stream of your data in real time.</p>&#13;
</li>&#13;
<li>&#13;
<p>If your application is already running, click the + icon and select the running emulator.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can also import a previously saved profiling session with the <code>+</code> icon. From there, you can load the&#13;
previously saved <em>.hprof</em> file.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>You can record and store data in each session. In <a data-type="xref" href="#extra_data_in_sessions">Figure 11-3</a>, we show a screenshot of saved profiling&#13;
sessions with different kinds of data that can be recorded with Android Profiler.</p>&#13;
&#13;
<figure class="width-50"><div class="figure" id="extra_data_in_sessions">&#13;
<img alt="pawk 1103" src="assets/pawk_1103.png"/>&#13;
<h6><span class="label">Figure 11-3. </span>Save heap dumps, or different kinds of CPU traces.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Both<a data-primary="method tracing" data-type="indexterm" id="idm46669737430320"/> <em>method traces</em>  and<a data-primary="heap dumps" data-type="indexterm" id="idm46669737429040"/> <em>heap dumps</em> can be saved as separate entries within a running session. Method traces show a&#13;
stacktrace of methods and functions that can be recorded in CPU profiling. Meanwhile, a heap dump refers to the data&#13;
collected from <em>garbage collection</em>, allowing us to analyze what objects are taking up unnecessary space in memory.</p>&#13;
&#13;
<p>Android Profiler records one application session at a time. However, you can save multiple recordings and switch between them&#13;
to compare the data. A bright dot &#13;
<span class="keep-together">indicates</span> the recording of an active session.&#13;
In <a data-type="xref" href="#extra_data_in_sessions">Figure 11-3</a>, there are three recorded sessions. The last recorded session has a saved heap&#13;
dump, which refers to a log of stored memory in the JVM at the time of the snapshot. We’ll cover this in more detail in <a data-type="xref" href="#_memory_profiler">“Memory Profiler”</a>. The first&#13;
recorded session saved different kinds of CPU recordings. This will be discussed in <a data-type="xref" href="#_cpu_usage_profiler">“CPU Profiler”</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Android Studio caches sessions only for the lifetime of the Android Studio instance. If Android Studio is restarted,&#13;
the recorded sessions will not save.</p>&#13;
</div>&#13;
&#13;
<p>The following sections show in more detail how Android Profiler evaluates device resources in the virtual machine&#13;
at runtime. There are four profilers we’ll use: <em>Network Profiler</em>, <em>CPU Profiler</em>, <em>Energy Profiler</em>, and <em>Memory Profiler</em>.&#13;
All of these profilers record streams of data during an application’s runtime, which can be accessed in greater detail in&#13;
their own special views.</p>&#13;
&#13;
<p>By design, <a data-primary="TrekMe" data-type="indexterm" id="idm46669737418896"/>TrekMe encourages users to download detailed topographical maps directly to their devices while they’re at home and can do so easily. Creating new topographical maps in TrekMe is the feature that consumes the most resources in this process. The maps can then be rendered when the user is hiking, even if mobile coverage is unreliable.&#13;
TrekMe’s map creation feature allows you to select an official map generator like the <em>Instituto Geografico Nacional</em>&#13;
(IGN) or <em>U.S. Geological Survey</em> (USGS) or some other map provider, as shown in <a data-type="xref" href="#overview">Figure 11-4</a>. TrekMe will then&#13;
load the selected service’s map in square tiles, one by one.</p>&#13;
&#13;
<figure class="width-45"><div class="figure" id="overview">&#13;
<img alt="pawk 1104" src="assets/pawk_1104.png"/>&#13;
<h6><span class="label">Figure 11-4. </span>TrekMe allows you to create and download a map from different services.</h6>&#13;
</div></figure>&#13;
&#13;
<p>For the remainder of this chapter, we’ll profile TrekMe while creating a map via IGN to study the time it takes to load a&#13;
map, and to ensure that it is optimal. With Android profiling, we can explore questions like:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Are we making fast network calls?</p>&#13;
</li>&#13;
<li>&#13;
<p>Is the data we get in our response returned in the most efficient format?</p>&#13;
</li>&#13;
<li>&#13;
<p>What parts of the application are the most CPU-intensive?</p>&#13;
</li>&#13;
<li>&#13;
<p>Which Android actions drain the most battery?</p>&#13;
</li>&#13;
<li>&#13;
<p>What objects are eating up the most memory in heap?</p>&#13;
</li>&#13;
<li>&#13;
<p>What consumes the most memory?</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In the next section, we answer the first two questions with Network Profiler.&#13;
We explore the remainder of these questions in later sections.<a data-startref="ix_ch11-asciidoc4" data-type="indexterm" id="idm46669737406528"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network Profiler" data-type="sect2"><div class="sect2" id="_network_profiler">&#13;
<h2>Network Profiler</h2>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="Network Profiler" data-type="indexterm" id="ix_ch11-asciidoc5"/><a data-primary="Android profiling tools" data-secondary="Network Profiler" data-type="indexterm" id="ix_ch11-asciidoc6"/><a data-primary="Network Profiler" data-type="indexterm" id="ix_ch11-asciidoc7"/>When a network call is made, the radio in the Android device powers up to allow for network communication. This radio&#13;
then stays powered on for a short time to ensure there are no additional requests to listen for. On some phones,&#13;
using the network every two minutes keeps the device at full power forever. Too many network calls can be expensive&#13;
for Android resources, so it is important to analyze and optimize network use in an application.</p>&#13;
&#13;
<p><em>Network Profiler</em> generates connection breakdowns used by  <em>HttpURLConnection</em> or <em>OkHttp</em> libraries. It can give&#13;
you information like network request/response time, headers, cookies, data formats, the call stack, and more. When you&#13;
record a session, Network Profiler generates interactive visual data while you continue to interact with the application.</p>&#13;
&#13;
<p>When we create a map using IGN, TrekMe renders the map on the screen in square tiles, one by one. Sometimes, though, the&#13;
tile rendering seems to take a long time. <a data-type="xref" href="#network_profiler">Figure 11-5</a> shows the profiler capturing incoming/outgoing&#13;
network requests, and shows the connections that are available while creating a map on TrekMe via IGN:</p>&#13;
&#13;
<p>You can highlight a selected range of the timeline to drill into these connections further, which will expand a&#13;
new view of the Network Profiler workspace, allowing you to access the <em>Connection View</em> and <em>Thread View</em> tabs to&#13;
analyze these network calls further.</p>&#13;
&#13;
<figure><div class="figure" id="network_profiler">&#13;
<img alt="pawk 1105" src="assets/pawk_1105.png"/>&#13;
<h6><span class="label">Figure 11-5. </span>Network Profiler timeline records IGN Spain map creation on TrekMe. In the upper-left corner of the chat, the long line under the label <code>MainActivity</code> represents an active <code>Activity</code> session while the short, thick line above the <code>MainActivity</code> label with a dot at the left represents user touch events.</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Viewing network calls with Connection View and Thread View" data-type="sect3"><div class="sect3" id="idm46669737391376">&#13;
<h3>Viewing network calls with Connection View and Thread View</h3>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="viewing network calls with Connection View and Thread View" data-type="indexterm" id="idm46669737389872"/><a data-primary="Connection View" data-type="indexterm" id="idm46669737388848"/><a data-primary="network calls" data-secondary="viewing" data-type="indexterm" id="idm46669737388176"/><a data-primary="Network Profiler" data-secondary="viewing network calls with Connection View and Thread View" data-type="indexterm" id="idm46669737387232"/><a data-primary="Thread View, viewing network calls with" data-type="indexterm" id="idm46669737386240"/>Connection View shows the data that was sent/received. You can see this in <a data-type="xref" href="#connection_view">Figure 11-6</a> in the highlighted portion of the timeline. Perhaps what is most notable is&#13;
Connection View’s ability to sort resource files by size, status, and time. Clicking&#13;
the header of each section will organize the ordering of the desired filter. The timeline section represents the&#13;
timing of the request/response bars split into two colors. The lighter portion represents the duration of the request,&#13;
while the darker portion represents the duration of the response.</p>&#13;
&#13;
<figure><div class="figure" id="connection_view">&#13;
<img alt="Connection View" src="assets/pawk_1106.png"/>&#13;
<h6><span class="label">Figure 11-6. </span>Connection View shows a list of individual network calls.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Connection View looks similar to the timeline in Thread View, but they’re not quite the same. Thread View&#13;
shows the network calls being made within the designated initiating threads, which can show multiple network calls&#13;
running in parallel time. The screenshot shown in <a data-type="xref" href="#thread_view">Figure 11-7</a> is the complement of the previous image, using the same data set.</p>&#13;
&#13;
<figure><div class="figure" id="thread_view">&#13;
<img alt="pawk 1107" src="assets/pawk_1107.png"/>&#13;
<h6><span class="label">Figure 11-7. </span>Thread View shows a list of network calls made within each thread.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Seeing how worker threads divide labor in real time can help to reveal areas for improvement. TrekMe’s pooled threads are&#13;
responsible for automatically breaking up, as needed, the work of downloading all these images.</p>&#13;
&#13;
<p>Both images show roughly 23 seconds of network calls, with response times showing a similar trend. Compared to the&#13;
requests, responses appear to take up a disproportionate amount of the time it takes to complete an entire network call. There&#13;
could be several reasons for this: for example, the server connection might be weaker if a device attempts to pull&#13;
this data from a distant country. Perhaps there are inefficiencies with the query call in the backend. Regardless&#13;
of the reason, we can say that our network calls may not be fastest. However, the presence of fast request&#13;
times <em>and</em> slow response times indicates external factors that are out of the device’s control.</p>&#13;
&#13;
<p>We now turn to our second question: are we using the most efficient data format? Let’s look at the connection type&#13;
in the Connection View tab as pictured in <a data-type="xref" href="#connection_view">Figure 11-6</a>. If you don’t need transparency in your images, avoid using PNG files since the file format doesn’t compress as well as&#13;
JPEG or WebP. In our case, the network calls return a JPEG-formatted payload. We want files that provide consistent and good image quality to enable users to zoom in to the details of those images as much as they need to. Using a JPEG file also takes up less memory than a&#13;
PNG file would.</p>&#13;
&#13;
<p>We can get more granular detail on each network call and its payload by selecting any item: this opens&#13;
a new view within Network Profiler on the right side, showing tabs for Overview, Response, Request,&#13;
and Callstack. In the next section, we’ll be able to look into the specifics of a single network call and&#13;
locate where the network call is made in the code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network call, expanded: Overview | Response | Request | Callstack" data-type="sect3"><div class="sect3" id="idm46669737373696">&#13;
<h3>Network call, expanded: Overview | Response | Request | Callstack</h3>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="network calls and" data-type="indexterm" id="ix_ch11-asciidoc8"/><a data-primary="network calls" data-secondary="about" data-type="indexterm" id="ix_ch11-asciidoc9"/><a data-primary="Network Profiler" data-secondary="and network calls" data-type="indexterm" id="ix_ch11-asciidoc10"/>Android developers are used to working with other platforms in order to achieve feature parity and&#13;
more. Suppose a network call starts returning the wrong kind of information for a network request. The API team is in need&#13;
of specifics for the network request and response you’re getting on the client side. How can you send them&#13;
over the necessary request parameters and content headers they need to investigate on their side?</p>&#13;
&#13;
<p>Network Profiler gives us the ability to inspect network responses and requests on the right-side panel in Connection View or Thread View, as shown in <a data-type="xref" href="#network_profiler_expanded">Figure 11-8</a>.</p>&#13;
&#13;
<p>The <em>Overview</em> tab details notable highlights captured in the request and response:</p>&#13;
<dl>&#13;
<dt>Request</dt>&#13;
<dd>&#13;
<p>The path and potential query parameters</p>&#13;
</dd>&#13;
<dt>Status</dt>&#13;
<dd>&#13;
<p>The HTTP status code returned within the resulting response</p>&#13;
</dd>&#13;
<dt>Method</dt>&#13;
<dd>&#13;
<p>The type of method used</p>&#13;
</dd>&#13;
<dt>Content type</dt>&#13;
<dd>&#13;
<p>The media type of the resource</p>&#13;
</dd>&#13;
<dt>Size</dt>&#13;
<dd>&#13;
<p>The size of the resource returned in the resulting response</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div class="figure" id="network_profiler_expanded">&#13;
<img alt="pawk 1108" src="assets/pawk_1108.png"/>&#13;
<h6><span class="label">Figure 11-8. </span>Network Profiler allows you to inspect response and request information.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <em>Request</em> and <em>Response</em> tabs show a breakdown of headers, parameters, body data, etc. In <a data-type="xref" href="#response">Figure 11-9</a>, we&#13;
show the exact network call as in the previous image, except with the Response tab selected.</p>&#13;
&#13;
<p>As you can see in the network response, TrekMe uses a basic HTTP API. Other types of API data formats return&#13;
HTML, JSON, and other resources. When applicable, the Request and Response tabs offer body data as a&#13;
formatted or raw representation. In our case, the resource media returns JPEGs.</p>&#13;
&#13;
<figure><div class="figure" id="response">&#13;
<img alt="pawk 1109" src="assets/pawk_1109.png"/>&#13;
<h6><span class="label">Figure 11-9. </span>Network Profiler captures network calls to render map.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Finally, the <em>Call Stack</em> tab, shows the stacktrace for the relevant calls made to execute a network connection, as&#13;
pictured in <a data-type="xref" href="#call_stack">Figure 11-10</a>. The calls that are not faded represent the method calls within the call stack coming from your own code. You can&#13;
right-click the calls indicated to be able to jump to the source code with ease.</p>&#13;
&#13;
<p>Network Profiler is useful for more than just analytics. As you can see for yourself, you’re able to process a lot of information quickly. From caching repetitive calls to confirming API contracts, Network Profiler is a tool worth keeping in your &#13;
<span class="keep-together">toolbox.</span></p>&#13;
&#13;
<figure><div class="figure" id="call_stack">&#13;
<img alt="pawk 1110" src="assets/pawk_1110.png"/>&#13;
<h6><span class="label">Figure 11-10. </span>Call Stack tab.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Poor networking is not the only culprit when it comes to slow rendering times. The task of creating a&#13;
brand new topographical map is heavy in itself, but as we have determined from a networking stance,&#13;
no further action is required to improve &#13;
<span class="keep-together">loading</span> times or data format. However, we would be remiss to chalk&#13;
up slow loading times to slow response time alone. After TrekMe receives the network data, it must then process&#13;
the data to render the UI. For this reason, we should check for potential inefficiencies in drawing the map out after&#13;
the network calls. <em>CPU Profiler</em> is able to provide insight for this. In the next section, we will examine, using CPU Profiler, the processing consumption of the rendering of the IGN Spain map<a data-startref="ix_ch11-asciidoc10" data-type="indexterm" id="idm46669737343520"/><a data-startref="ix_ch11-asciidoc9" data-type="indexterm" id="idm46669737342816"/><a data-startref="ix_ch11-asciidoc8" data-type="indexterm" id="idm46669737342144"/>.<a data-startref="ix_ch11-asciidoc7" data-type="indexterm" id="idm46669737341344"/><a data-startref="ix_ch11-asciidoc6" data-type="indexterm" id="idm46669737340640"/><a data-startref="ix_ch11-asciidoc5" data-type="indexterm" id="idm46669737339968"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CPU Profiler" data-type="sect2"><div class="sect2" id="_cpu_usage_profiler">&#13;
<h2>CPU Profiler</h2>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="CPU Profiler" data-type="indexterm" id="ix_ch11-asciidoc11"/><a data-primary="Android profiling tools" data-secondary="CPU Profiler" data-type="indexterm" id="ix_ch11-asciidoc12"/><a data-primary="CPU Profiler" data-type="indexterm" id="ix_ch11-asciidoc13"/>While Network Profiler is able to give information about network calls, it is not able to paint a full picture about where&#13;
the time goes. We have a call stack for our network calls, but we don’t know how long certain methods actually run. This is where CPU Profiler comes in. CPU Profiler helps identify greedy consumption of resources by analyzing how much time has passed  on function execution and tracks which thread a call executes on. Why does this matter? If TrekMe consumes too&#13;
much processing, the application slow downs, impacting the user experience. The more CPU power that is used, the more quickly the battery drains.</p>&#13;
&#13;
<p>CPU Profiler allows you to examine CPU recordings and livestream data by examining the call stack by the thread,&#13;
as shown in <a data-type="xref" href="#intro_to_cpu_profiler">Figure 11-11</a>.</p>&#13;
&#13;
<p>In the following sections, we break down the CPU timeline, Thread activity timeline, and Analysis panels. Because&#13;
TrekMe seems to spend a lot of time offloading work to background threads, we will select one to look into more closely.</p>&#13;
&#13;
<figure><div class="figure" id="intro_to_cpu_profiler">&#13;
<img alt="Introduction to the CPU Profiler" src="assets/pawk_1111.png"/>&#13;
<h6><span class="label">Figure 11-11. </span>CPU Profiler shows the call stack and recorded times for methods &#13;
<span class="keep-together">executed.</span></h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CPU timeline" data-type="sect3"><div class="sect3" id="idm46669737328688">&#13;
<h3>CPU timeline</h3>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="CPU timeline" data-type="indexterm" id="idm46669737327488"/><a data-primary="CPU Profiler" data-secondary="CPU timeline" data-type="indexterm" id="idm46669737326512"/>The CPU timeline organizes regional call stacks into recorded threads in the Threads pane. The graph in <a data-type="xref" href="#cpu_timeline">Figure 11-12</a> shows spikes of CPU usage, where the number is a percentage of available CPU. If you have made a trace&#13;
recording, you should be able to highlight the CPU timeline to see more information.</p>&#13;
&#13;
<figure><div class="figure" id="cpu_timeline">&#13;
<img alt="CPU timeline" src="assets/pawk_1112.png"/>&#13;
<h6><span class="label">Figure 11-12. </span>CPU timeline.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Android Studio allows you to drag-and-click over a recorded sample from the CPU timeline to show the Call Chart.&#13;
Clicking on Record brings you to a separate trace CPU recording screen (covered in greater&#13;
detail in <em>Record Traces</em>). To create the more granular call charts we explore in the next section, it helps to&#13;
highlight smaller portions of the recorded CPU trace.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Thread activity timeline" data-type="sect3"><div class="sect3" id="idm46669737320864">&#13;
<h3>Thread activity timeline</h3>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="thread activity timeline" data-type="indexterm" id="idm46669737319520"/><a data-primary="CPU Profiler" data-secondary="thread activity timeline" data-type="indexterm" id="idm46669737318576"/><a data-primary="thread activity timeline" data-type="indexterm" id="idm46669737317664"/>The Thread activity timeline accompanies the CPU timeline showing every running thread in the app. If a section&#13;
was trace-recorded, you should be able to select a thread to view the call stack captured within the selected&#13;
time range. In <a data-type="xref" href="#thread_activity_timeline">Figure 11-13</a>, 31 threads have been created and used within the application. These&#13;
threads have been created either by your code, the Android OS, or a third-party library.</p>&#13;
&#13;
<figure><div class="figure" id="thread_activity_timeline">&#13;
<img alt="Thread activity timeline" src="assets/pawk_1113.png"/>&#13;
<h6><span class="label">Figure 11-13. </span>Thread activity timeline.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The lightest-colored blocks represent a running or active thread. There’s not a lot to see on the Main thread, but&#13;
remember, this image captures a CPU trace of the network request downloading the map images. In this case, we expect&#13;
background threads to do the necessary work to download the network data. It seems we have the main thread waiting on&#13;
one of the DefaultDispatcher threads for half the time.  Double-clicking on an individual thread expands the&#13;
call stack.</p>&#13;
&#13;
<p>Below the Thread activity timeline is the <a data-primary="Call Chart" data-type="indexterm" id="idm46669737312432"/>Call Chart (see <a data-type="xref" href="#call_chart">Figure 11-14</a>).</p>&#13;
&#13;
<figure><div class="figure" id="call_chart">&#13;
<img alt="Call Chart" src="assets/pawk_1114.png"/>&#13;
<h6><span class="label">Figure 11-14. </span>The Call Chart shows a top-down representation of captured methods.</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">The Call Chart shows a call stack&#13;
of the segmented range of time for CPU usage. The top boxes represent the encapsulating parent method, while the methods&#13;
below are child methods that were called. The parent method waits on the child methods to &#13;
<span class="keep-together">finish</span> executing, so this is a good&#13;
place to see which of TrekMe’s methods could be executing for a long time, like the method <code>TileStreamProviderHttp</code>.</p>&#13;
&#13;
<p>If you’re reading the printed book, be aware that the bars are color coded. Android OS methods are orange,&#13;
methods you’ve written are green, and third-party libraries are blue. Within this coroutine, the longest amount of&#13;
execution time is with &#13;
<span class="keep-together"><code>TileStreamProviderHttp.getTileStream(...)</code>.</span> This is expected, given that this call makes&#13;
individual network requests per tile.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Analysis panel" data-type="sect3"><div class="sect3" id="idm46669737304640">&#13;
<h3>Analysis panel</h3>&#13;
&#13;
<p><a data-primary="Analysis Panel" data-type="indexterm" id="ix_ch11-asciidoc14"/><a data-primary="Android Profiler" data-secondary="Analysis Panel" data-type="indexterm" id="ix_ch11-asciidoc15"/><a data-primary="CPU Profiler" data-secondary="Analysis Panel" data-type="indexterm" id="ix_ch11-asciidoc16"/>The <em>Analysis panel</em> presents a layered tab view. The top of the pane highlights the active set of thread(s).&#13;
Beneath the tabbed menu sits a search bar above the stacktrace. You can use the search bar to filter trace data&#13;
related to a particular call. Below that is a set of tabs intended to render visual data from method tracing in three&#13;
views: <em>Top Down</em>, <em>Bottom Up</em>, and <em>Flame Chart</em>.</p>&#13;
&#13;
<p>Top Down renders a graphical representation of method traces from the top to the bottom of the chart. Any&#13;
call made within a method renders as a child underneath the original method. Shown in <a data-type="xref" href="#top_down">Figure 11-15</a>, the method&#13;
<code>getTileStream</code> used in TrekMe waits for a series of calls for internet connection and reading from a data stream.</p>&#13;
&#13;
<p>The Top Down view shows how CPU time breaks down in three ways:</p>&#13;
<dl>&#13;
<dt>Self</dt>&#13;
<dd>&#13;
<p><a data-primary="self CPU time" data-type="indexterm" id="idm46669737293328"/>The method execution time itself</p>&#13;
</dd>&#13;
<dt>Children</dt>&#13;
<dd>&#13;
<p><a data-primary="children CPU time" data-type="indexterm" id="idm46669737291344"/>The time it takes to execute callee methods</p>&#13;
</dd>&#13;
<dt>Total</dt>&#13;
<dd>&#13;
<p><a data-primary="total CPU time" data-type="indexterm" id="idm46669737289296"/>Combined time of self and children</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div class="figure" id="top_down">&#13;
<img alt="pawk 1115" src="assets/pawk_1115.png"/>&#13;
<h6><span class="label">Figure 11-15. </span>Top Down view.</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the case of <code>getTileStream</code>, the majority of the time is spent on the network calls themselves: in particular, the&#13;
connection request and <code>getInputStream</code> to receive incoming data from the network. For the IGN Spain server, these times&#13;
can vary when accessed in another country and at different times of the day. Because it is the client consuming server data,&#13;
TrekMe has no control over how the server performs.</p>&#13;
&#13;
<p>Contrary to Top Down, Bottom Up (shown in <a data-type="xref" href="#bottom_up">Figure 11-16</a>) shows an inverse representation of <em>leaf elements</em> of the call stack. In comparison,&#13;
such a view renders a substantial number of methods, which can be useful in identifying methods that are consuming the most CPU time.</p>&#13;
&#13;
<p>The final tab provides a <a data-primary="Flame Chart" data-type="indexterm" id="idm46669737282416"/>Flame Chart view. A Flame Chart provides an aggregated visual of operations from the bottom up. It provides an inverted call chart to&#13;
better see which functions/methods are consuming more CPU time.</p>&#13;
&#13;
<figure><div class="figure" id="bottom_up">&#13;
<img alt="Bottom up" src="assets/pawk_1116.png"/>&#13;
<h6><span class="label">Figure 11-16. </span>Bottom Up view.</h6>&#13;
</div></figure>&#13;
&#13;
<p>To summarize, CPU profiling can render three different kinds of views, depending on the kind of deep dive you wish to pursue:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Top Down graphical representation shows each method call’s CPU time along with the time of its callees.</p>&#13;
</li>&#13;
<li>&#13;
<p>Bottom Up inverts the Top Down representation and is most useful to sort methods consuming the most or the least amount of time.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Flame Chart inverts and aggregates the call stack horizontally with other callees of the same level to show which&#13;
ones consume the most CPU time first.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Not only are there three different ways to render data, but there are different kinds of call stacks you can record. In&#13;
the upcoming sections, we cover different kinds of method tracing in CPU Profiler. As you’re starting to get the&#13;
picture of what kind of information CPU Profiler tries to capture, we’ll turn to <em>method tracing</em> with CPU Profiler&#13;
and record a segment of TrekMe creating a new map.<a data-startref="ix_ch11-asciidoc16" data-type="indexterm" id="idm46669737274096"/><a data-startref="ix_ch11-asciidoc15" data-type="indexterm" id="idm46669737273312"/><a data-startref="ix_ch11-asciidoc14" data-type="indexterm" id="idm46669737272640"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Method tracing" data-type="sect3"><div class="sect3" id="_method_tracing">&#13;
<h3>Method tracing</h3>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="method tracing" data-type="indexterm" id="ix_ch11-asciidoc17"/><a data-primary="CPU Profiler" data-secondary="method tracing" data-type="indexterm" id="ix_ch11-asciidoc18"/><a data-primary="method tracing" data-type="indexterm" id="ix_ch11-asciidoc19"/>CPU Profiler allows you to <em>record a trace</em> to analyze and render its status, duration, type, and more. Tracing relates to&#13;
recording device activity over a short period of time. Method tracing doesn’t occur until the recording button&#13;
is clicked twice: once to start the recording, and another time to end the recording. There are four configurations for&#13;
samples and traces, as shown in <a data-type="xref" href="#trace_configurations">Figure 11-17</a>.</p>&#13;
&#13;
<figure class="width-45"><div class="figure" id="trace_configurations">&#13;
<img alt="pawk 1117" src="assets/pawk_1117.png"/>&#13;
<h6><span class="label">Figure 11-17. </span>Configurations are available for Android developers for samples and traces.</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="Sample Java Methods" data-type="indexterm" id="idm46669737262576"/><em>Sample Java Methods</em> captures the application call stack, or a <a data-primary="Call Chart" data-type="indexterm" id="idm46669737261424"/>Call Chart (also seen in previous sections). The Call Chart renders under&#13;
the Thread activity timeline, which shows which threads are active at a particular time. These traces store individual&#13;
sessions to the right pane for comparison with others’ saved sessions.</p>&#13;
&#13;
<p>By choosing the Sample Java Methods configuration, you can examine TrekMe’s call stack by hovering the mouse pointer over&#13;
particular methods, as shown in <a data-type="xref" href="#sample_java_methods">Figure 11-18</a>.</p>&#13;
&#13;
<figure><div class="figure" id="sample_java_methods">&#13;
<img alt="Sample Java Methods" src="assets/pawk_1118.png"/>&#13;
<h6><span class="label">Figure 11-18. </span>Sample Java Methods.</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Don’t let your recording run too long. Once a recording reaches its size limit, the trace stops&#13;
collecting data even if the current session continues to record.</p>&#13;
</div>&#13;
&#13;
<p>Unlike Sample Java Methods, <a data-primary="Trace Java Methods" data-type="indexterm" id="idm46669737255184"/><em>Trace Java Methods</em> strings together a series of timestamps recorded for the start&#13;
and end of a method call. Should you wish, you can monitor <em>Sample C/C+ Functions</em> to gain insight into how the app&#13;
is interacting with the Android OS. Recording sample traces for native threads is available for Android API 26 and up.</p>&#13;
&#13;
<p>The terms “method” and “function” tend to be used in everyday conversation interchangeably when talking about method-tracing analysis. At this point, you might be wondering why Java methods and C/C++ functions differentiate enough to&#13;
matter in CPU profiling.</p>&#13;
&#13;
<p>In the CPU-recording configurations, Android Profiler uses “method” to refer to Java-based code, while “function”&#13;
references threads. The difference between the two is the order of method execution preserved via a call stack&#13;
while threads are created and scheduled by the Android OS itself.</p>&#13;
&#13;
<p>Finally, there is<a data-primary="Trace System Calls" data-type="indexterm" id="idm46669737251504"/> Trace System Calls in the configurations shown in <a data-type="xref" href="#trace_configurations">Figure 11-17</a>.  System Trace&#13;
is a powerful CPU-recording configuration made available for Android developers. It gives back graphical&#13;
information on frame-rendering data.</p>&#13;
&#13;
<p>Trace System Calls records analytics on <em>CPU Cores</em> to see how scheduling occurs across the board. This configuration&#13;
becomes more meaningful for detecting CPU bottlenecks across the CPU Cores. These kinds of bottlenecks can jump out&#13;
in places where the RenderThread chokes, especially for red-colored frames. Unlike other configurations, Trace System Calls&#13;
shows thread states and the CPU core it currently runs on, as shown in <a data-type="xref" href="#system_trace">Figure 11-19</a>.</p>&#13;
&#13;
<p>One of the key features in a system trace is having access to the<a data-primary="RenderThread" data-type="indexterm" id="idm46669737247088"/> <em>RenderThread</em>. RenderThread can show where&#13;
performance bottlenecks might be occurring when rendering the UI. In the case of <a data-type="xref" href="#system_trace">Figure 11-19</a>, we can see&#13;
that much of the idle time occurs around the actual drawing of the tiles themselves.</p>&#13;
&#13;
<p>The Android system tries to redraw the screen depending on the refresh rate on the screen (between 8 ms and 16 ms). Work&#13;
packets taking longer than the frame rate can cause <em>dropped frames</em>, indicated by red slots in Frames. Frames drop when&#13;
some task does not return before the screen redraws itself. In the case of this system trace recording,&#13;
it appears that we indeed have some dropped frames indicated by the numbers labeling boxes inside the Frame subsection under the Display section.</p>&#13;
&#13;
<p>TrekMe saves each frame into a JPEG file and loads the image into a bitmap for decoding. However, in <a data-type="xref" href="#system_trace">Figure 11-19</a>, we see that in the RenderThread, the length of DrawFrame doesn’t quite match up with the draw rate&#13;
intervals. A bit farther below that, some of that idle time is tied to various long-running <code>decodeBitmap</code> methods&#13;
in the pooled threads.</p>&#13;
&#13;
<figure><div class="figure" id="system_trace">&#13;
<img alt="System Trace" src="assets/pawk_1120.png"/>&#13;
<h6><span class="label">Figure 11-19. </span>System Trace reveals dropped frames where times are labeled within Frames.</h6>&#13;
</div></figure>&#13;
&#13;
<p>From here, there are some options that could potentially be considered for faster drawing; that is, caching network&#13;
responses for images, or even <em>prefetching</em>. For users in need of a few megabytes of data, prefetching is a nice-to-have in the case a device has access to at least a 3G network. The problem with that is that it may not be the best option to render&#13;
those bitmaps before we <em>know</em> what must be rendered. Another option is potentially encoding the data into&#13;
a more compressed format for easier decoding. Whatever the&#13;
decision, it’s up to the developer to evaluate the trade-offs and the effort of implementing certain optimizations.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The concept of prefetching refers to predicting what kind of data would come in a future request, and grabbing that&#13;
data preemptively while there’s an active radio connection. Each radio request has overhead in terms of the time it takes&#13;
to wake up the radio and the battery drainage that occurs to keep the radio awake, so Android developers can take&#13;
advantage of making additional calls while the radio is already awake.<a data-startref="ix_ch11-asciidoc19" data-type="indexterm" id="idm46669737235984"/><a data-startref="ix_ch11-asciidoc18" data-type="indexterm" id="idm46669737235280"/><a data-startref="ix_ch11-asciidoc17" data-type="indexterm" id="idm46669737234608"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Recording a sample method trace" data-type="sect3"><div class="sect3" id="idm46669737271376">&#13;
<h3>Recording a sample method trace</h3>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="recording a Sample Method Trace" data-type="indexterm" id="ix_ch11-asciidoc20"/><a data-primary="CPU Profiler" data-secondary="recording a Sample Method Trace" data-type="indexterm" id="ix_ch11-asciidoc21"/><a data-primary="Sample Method Trace" data-type="indexterm" id="ix_ch11-asciidoc22"/>Now that you are more familiar with what the recording configurations offer, we turn to <em>Sample Method Trace</em> on TrekMe.&#13;
CPU recordings are separated from the CPU Profiler timeline. To begin, click the Record button at the top of&#13;
the screen to analyze CPU activity while interacting with TrekMe.</p>&#13;
&#13;
<p>Ending the recording renders a tabbed right pane of execution times for sample or trace calls. You can also highlight&#13;
multiple threads at once for analysis. The average Android developer may not use all these tabs all the time;&#13;
still, it’s good to be cognizant of what tools are at your disposal.</p>&#13;
&#13;
<p>In TrekMe, there’s a predefined set of iterable tiles to download. A number of coroutines concurrently read the&#13;
iterable and perform a network request per tile. Each coroutine decodes a bitmap right after the network request&#13;
succeeded. These coroutines are sent to some dispatcher such as <code>Dispatchers.IO</code>, and the rendering happens when the&#13;
result is sent back to the UI thread. The UI thread is never blocked waiting for bitmap decoding, or waiting for a&#13;
network request.</p>&#13;
&#13;
<p>The shrunken CPU timeline in <a data-type="xref" href="#analysis_panel">Figure 11-20</a>, at first glance, appears to be nothing more than a reference to the previous screen view.&#13;
However, you can interact with this data to drill down further by highlighting a chunk of time via the range selector,&#13;
as shown in <a data-type="xref" href="#range_selector">Figure 11-21</a>.</p>&#13;
&#13;
<figure><div class="figure" id="analysis_panel">&#13;
<img alt="Analysis Panel" src="assets/pawk_1121.png"/>&#13;
<h6><span class="label">Figure 11-20. </span>CPU Profiler separates the recorded trace.</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="range_selector">&#13;
<img alt="Range Selector" src="assets/pawk_1122.png"/>&#13;
<h6><span class="label">Figure 11-21. </span>The range selector helps to manage sections of highlighted ranges.</h6>&#13;
</div></figure>&#13;
&#13;
<p>In <a data-type="xref" href="#cpu_profiler_callstack_analysis">Figure 11-22</a>, we look at one of the longer-running methods, <code>getTileStream</code>. Below the timeline, the left panel allows you to organize <em>threads</em> and <em>interactions</em> via drag-and-drop functionality.&#13;
Being able to group threads together also means you can highlight groups of stacktraces. You can expand a thread in a recorded&#13;
trace by double-clicking the thread twice to show a drop-down visual of a call stack.</p>&#13;
&#13;
<p>Selecting an item also opens an additional pane to the right. This is the <em>Analysis Panel</em>, which allows you to&#13;
examine stacktrace and execution time in more granular detail. Tracking CPU usage is important, but perhaps you’d&#13;
like to be able to analyze how an application interacts with Android hardware components. In the next section, we&#13;
look into Android Studio’s <em>Energy Profiler</em>.</p>&#13;
&#13;
<figure><div class="figure" id="cpu_profiler_callstack_analysis">&#13;
<img alt="Call Stack" src="assets/pawk_1123.png"/>&#13;
<h6><span class="label">Figure 11-22. </span>You can search for a specific method via the search function.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Excessive networking calls on Android devices are also <em>power-hungry</em>. The longer the device radio stays awake for&#13;
network communication, the more CPU consumption and battery drainage there is. By this logic, it would be fair to assume&#13;
that networking accounts for most energy consumption. We can confirm this by using Energy &#13;
<span class="keep-together">Profiler</span><a data-startref="ix_ch11-asciidoc22" data-type="indexterm" id="idm46669737211072"/><a data-startref="ix_ch11-asciidoc21" data-type="indexterm" id="idm46669737210368"/><a data-startref="ix_ch11-asciidoc20" data-type="indexterm" id="idm46669737209696"/>.<a data-startref="ix_ch11-asciidoc13" data-type="indexterm" id="idm46669737208896"/><a data-startref="ix_ch11-asciidoc12" data-type="indexterm" id="idm46669737208192"/><a data-startref="ix_ch11-asciidoc11" data-type="indexterm" id="idm46669737207520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Energy Profiler" data-type="sect2"><div class="sect2" id="_energy_profiler">&#13;
<h2>Energy Profiler</h2>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="Energy Profiler" data-type="indexterm" id="ix_ch11-asciidoc23"/><a data-primary="Android profiling tools" data-secondary="Energy Profiler" data-type="indexterm" id="ix_ch11-asciidoc24"/><a data-primary="Energy Profiler" data-type="indexterm" id="ix_ch11-asciidoc25"/>Energy Profiler is best used for determining heavy energy consumption. When an application makes a network&#13;
request, the application turns on the mobile radio hardware component. CPU consumption accelerates as the Android device&#13;
communicates with the network, draining battery at a faster rate.</p>&#13;
&#13;
<p>TrekMe prescales bitmaps to ensure consistent memory and energy usage when the user is zooming in and out. When the&#13;
user is creating and downloading a map, the details of the map are, by default, downloaded with the highest-resolution detail.&#13;
The event pane shows higher levels of consumption when downloading large chunks of data.</p>&#13;
&#13;
<p>A drag-and-click can select a range of the timeline to show details for events for the Android OS. In&#13;
<a data-type="xref" href="#energy_profiler_system_event_pane">Figure 11-23</a>, we can see a pop-up rendering of a breakdown of the energy graph. The first half of the pop-up&#13;
legend contains the categories CPU, Network, and Location, which relay to each category provided&#13;
in the stacked graph. It is a good sign to see that CPU and networking usage is light despite the relatively heavy job&#13;
of making a network call to request large pieces of data and draw them on the screen.</p>&#13;
&#13;
<figure><div class="figure" id="energy_profiler_system_event_pane">&#13;
<img alt="Energy Profiler system event pane" src="assets/pawk_1124.png"/>&#13;
<h6><span class="label">Figure 11-23. </span>System event pane.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The second half of the pop-up legend describes the kinds of system events captured from the device. Energy Profiler works&#13;
to capture certain kinds of system events and their energy consumption on a device:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a data-primary="Alarms" data-type="indexterm" id="idm46669737195344"/><em>Alarms</em> and<a data-primary="Jobs" data-type="indexterm" id="idm46669737193936"/> <em>Jobs</em> are system events designed to wake up a device at a specified time. As a best practice, Android now&#13;
recommends using <em>WorkManager</em> or <em>JobScheduler</em> whenever possible, especially for background tasks.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Location</em> requests use Android GPS Sensor, which can consume a large amount of battery. It’s a good practice to make&#13;
sure accuracy and frequency are gauged &#13;
<span class="keep-together">correctly.</span></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Although <a data-type="xref" href="#energy_profiler_system_event_pane">Figure 11-23</a> shows only one location request, there are other types of system events&#13;
that contain their own unique set of states. A request event may possess the state of <em>Active</em>, as pictured in <a data-type="xref" href="#energy_profiler_system_event_pane">Figure 11-23</a>,&#13;
<em>Requested</em>, or <em>Request Removed</em>. Likewise, if Energy Profiler captures a <em>Wake Lock</em> type of system event, the timeline would be able to show&#13;
state(s) for the duration of the wake lock event such as <em>Acquired</em>, <em>Held</em>, <em>Released</em>, and so on.</p>&#13;
&#13;
<p>Selecting a particular system event opens a right pane in Energy Profiler to see more details. From here, you can jump&#13;
directly to the source code for that particular location request. In TrekMe, <a data-primary="GoogleLocationProvider" data-type="indexterm" id="idm46669737183360"/><code>GoogleLocationProvider</code> is a class that&#13;
polls for user location every second. This isn’t necessarily an issue—the polling is intended to enable the device&#13;
to constantly update your location. This proves the power of this profiling tool: you can get precise&#13;
information without looking at the source code. Requests are made one at a time, removing existing requests in&#13;
order to make a new one when a new image block has been downloaded.</p>&#13;
&#13;
<p>In comparison to location polling, we can expect decreased energy consumption when a user is zooming in on a rendered&#13;
map. There are no requests made for downloading large chunks of data. We do expect some energy consumption for keeping&#13;
track of the user’s location, which also uses  <code>GoogleLocationProvider</code>.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#energy_breakdown">Figure 11-24</a>, we can see the excessive and rapid touch events indicated by the circular dots above the&#13;
stacked overlay graph. Because TrekMe has downloaded all the information it needed, no network calls are made at this&#13;
time. However, we do notice how CPU usage spikes back up to high levels. To avoid overwhelming the system, it is a good&#13;
practice to limit touch events to avoid spinning off duplicate zoom-drawing functions.</p>&#13;
&#13;
<figure><div class="figure" id="energy_breakdown">&#13;
<img alt="TrekMe energy profiler" src="assets/pawk_1125.png"/>&#13;
<h6><span class="label">Figure 11-24. </span>TrekMe opens and zooms in on an existing map.</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">So far, we’ve covered evaluating performance by looking at processing power. But examining battery/CPU usage does&#13;
not always diagnose performance problems. Sometimes, slow behavior can be attributed to clogged memory. In the next&#13;
section, we explore the relationship between CPU and memory and use Memory Profiler on TrekMe’s GPX recording feature.<a data-startref="ix_ch11-asciidoc25" data-type="indexterm" id="idm46669737175872"/><a data-startref="ix_ch11-asciidoc24" data-type="indexterm" id="idm46669737175168"/><a data-startref="ix_ch11-asciidoc23" data-type="indexterm" id="idm46669737174496"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memory Profiler" data-type="sect2"><div class="sect2" id="_memory_profiler">&#13;
<h2>Memory Profiler</h2>&#13;
&#13;
<p><a data-primary="Android Profiler" data-secondary="Memory Profiler" data-type="indexterm" id="ix_ch11-asciidoc26"/><a data-primary="Android profiling tools" data-secondary="Memory Profiler" data-type="indexterm" id="ix_ch11-asciidoc27"/><a data-primary="Memory Profiler" data-type="indexterm" id="ix_ch11-asciidoc28"/>In TrekMe, you can navigate to<a data-primary="GPX Record" data-type="indexterm" id="idm46669737167952"/> <em>GPX Record</em> in the pullout drawer. GPX stands for <em>GPS Exchange Format</em> and is&#13;
a set of data used with XML schema for GPS formatting in software applications. Hikers can click the play icon&#13;
under Control. The app then tracks and records the movements of the hikers and their devices, which can be saved&#13;
as a GPX file to be rendered as a line drawing later on to indicate the path traveled. <a data-type="xref" href="#trekme_gpx_recording">Figure 11-25</a> shows&#13;
TrekMe’s GPX recording feature.</p>&#13;
&#13;
<figure><div class="figure" id="trekme_gpx_recording">&#13;
<img alt="pawk 1126" src="assets/pawk_1126.png"/>&#13;
<h6><span class="label">Figure 11-25. </span>TrekMe’s GPX recording feature uses <code>GpxRecordingService</code> to track the GPS coordinates of a user on a hike.</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">We know that using location in the system <em>can</em> be heavy for CPU processing. But sometimes, slowdowns can be attributed&#13;
to memory problems. CPU processing uses <a data-primary="RAM" data-type="indexterm" id="idm46669737161536"/>RAM as its capacity for workspace, so when RAM fills up, the Android system&#13;
must execute a heap dump. When memory usage is severely restricted, the ability to execute many tasks at once becomes&#13;
limited. The more time it takes to execute fewer application operations, the slower Android gets. RAM is shared across&#13;
all applications: if too many applications are consuming too much memory, it can slow the performance of the device&#13;
or, worse, cause <code>OutOfMemoryException</code> crashes.</p>&#13;
&#13;
<p>Memory Profiler allows you to see how much memory is consumed out of the memory allocated for your application to run.&#13;
With Memory Profiler, you can manually trigger a <a data-primary="heap dumps" data-type="indexterm" id="idm46669737159216"/>heap dump in a running session to generate analysis to determine&#13;
which objects are held in the heap and how many there are.</p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#memory_profiler_heapdump">Figure 11-26</a>, Memory Profiler offers powerful features:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Triggering garbage collection</p>&#13;
</li>&#13;
<li>&#13;
<p>Capturing a Java heap dump</p>&#13;
</li>&#13;
<li>&#13;
<p>Allocation tracking</p>&#13;
</li>&#13;
<li>&#13;
<p>An interactive timeline of the fragments and activities available in the Android application</p>&#13;
</li>&#13;
<li>&#13;
<p>User-input events</p>&#13;
</li>&#13;
<li>&#13;
<p>Memory count to divide memory into categories</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="memory_profiler_heapdump">&#13;
<img alt="Memory Profiler" src="assets/pawk_1127.png"/>&#13;
<h6><span class="label">Figure 11-26. </span>Allocation Tracking offers a <em>Full</em> Italicized Text configuration, which captures all object allocations in memory, while a <em>Sampled</em> configuration records objects at regular &#13;
<span class="keep-together">intervals.</span></h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Like recording samples and traces in CPU Profiler, capturing Java heap dumps saves the results within the session panel&#13;
in Android Profiler for comparison for the life of your Android Studio instance.</p>&#13;
</div>&#13;
&#13;
<p>Initiating too much <a data-primary="garbage collection (GC)" data-type="indexterm" id="idm46669737145744"/>garbage collection (GC) can affect performance: for example, executing a ton of GC can slow&#13;
the device down, depending on how frequent and how large generational object allocation is in memory. At a minimum,&#13;
Android developers should try to run memory profiling of every application to ensure that nothing is being&#13;
held in the heap past its use, otherwise known as “memory leaks.” Detecting memory leaks can be life-saving,&#13;
especially for Android users depending on longer battery life. What you are about  to see is a variation of a common&#13;
memory management mistake developers often make while working with services: leaving a service accidentally running.</p>&#13;
&#13;
<p>TrekMe uses a foreground service to gain stats of the user’s hike, which is a natural choice for tracking the user’s location.&#13;
Services, like other Android components, run in the UI thread of the application. However, persisting services tend to&#13;
drain battery and system resources. Hence, it is important to limit the use of foreground services so as not to&#13;
impair overall device performance and to kill them off as soon as possible if the app must use one.</p>&#13;
&#13;
<p>We can run a couple of GPX recordings against Memory Profiler and trigger the heap dump to see which&#13;
objects held in heap consume the most memory, as shown in <a data-type="xref" href="#memory_allocations">Figure 11-27</a>.</p>&#13;
&#13;
<figure><div class="figure" id="memory_allocations">&#13;
<img alt="pawk 1128" src="assets/pawk_1128.png"/>&#13;
<h6><span class="label">Figure 11-27. </span>You can use the CTRL + F function to search for “GpxRecordingService” to narrow your results.</h6>&#13;
</div></figure>&#13;
&#13;
<p>A heap dump shows you a list of classes, which can be organized by heap <em>allocations</em>, <em>native size</em>, <em>shallow size</em>, or <em>retained size</em>.&#13;
Shallow size is a reference to the total Java memory used. Native size is a reference to the total memory used in&#13;
native memory. Retained size is made of both shallow size and retained size (in bytes).</p>&#13;
&#13;
<p>Within a recorded heap dump, you can organize your allocation record by <em>app heap</em>, <em>image heap</em>, or <em>zygote heap</em>.&#13;
The zygote heap refers to the memory that is allocated for a zygote process, which might include common framework code&#13;
and resources. The image heap stores memory allocation from the OS itself and contains references to classes used in&#13;
an image containing our application for a system boot. For our use case, we’re more concerned with the app heap, which&#13;
is the primary heap the app allocates memory to.</p>&#13;
&#13;
<p>In Memory Profiler, triggering a heap dump will render a list of objects still held in memory after GC. This list can&#13;
give you:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Every object instance of a selected object displayed in the <em>Instance View</em> pane, with the option to “Jump to Source” in the code</p>&#13;
</li>&#13;
<li>&#13;
<p>The ability to examine instance data by right-clicking an object in <em>References</em> and selecting <em>Go to Instance</em></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Remember, a memory leak occurs when caching holds references to objects that are no longer needed. In&#13;
<a data-type="xref" href="#memory_profiling_locationservice">Figure 11-28</a>, we search for “Location” with the same heap dump to locate our service and&#13;
be able to view total memory allocation. <code>LocationService</code> appears to have separate allocations when it should&#13;
only have one running at a time.</p>&#13;
&#13;
<figure><div class="figure" id="memory_profiling_locationservice">&#13;
<img alt="pawk 1129" src="assets/pawk_1129.png"/>&#13;
<h6><span class="label">Figure 11-28. </span>A suspicious number of <code>LocationService</code> instances appears to be held in memory.</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">It appears that every time we press Record, a new <code>LocationService</code> in TrekMe is instantiated and then held&#13;
in memory even after the service dies. You can start-and-stop a service, but if you are holding a reference to that&#13;
service in a background thread, even if it is dead, the instance continues to be held in the heap even after GC occurs.</p>&#13;
&#13;
<p>Let’s just run a couple more recordings in TrekMe to confirm the behavior we suspect. We can right-click one of these&#13;
instances to “Jump to Source” and see. In <em>RecordingViewModel.kt</em>, we see the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">startRecording</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">intent</code> <code class="p">=</code> <code class="n">Intent</code><code class="p">(</code><code class="n">app</code><code class="p">,</code> <code class="n">LocationServices</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">)</code>&#13;
    <code class="n">app</code><code class="p">.</code><code class="n">startService</code><code class="p">(</code><code class="n">intent</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We want to check whether these services are indeed stopping before starting a new one. A started service stays alive as&#13;
long as possible: until a <code>stopService</code> call is made outside the service or <code>stopSelf</code> is called within the service.&#13;
This makes the use of persistent services expensive, as Android considers running services always in use, meaning that&#13;
the memory a service uses up in RAM will never be made available.</p>&#13;
&#13;
<p>When a GPX recording stops, <code>LocationService</code> propagates a series of events, pinging the GPS location, which is then recorded and saved as a set of data. When a GPX&#13;
file has just been written, the service subscribes to the main thread to send a status. Because <code>LocationService</code> extends Android <code>Service</code>,&#13;
we can call <code>Service::stopSelf</code> to stop the service:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">@Subscribe</code><code class="p">(</code><code class="n">threadMode</code> <code class="p">=</code> <code class="n">ThreadMode</code><code class="p">.</code><code class="n">MAIN</code><code class="p">)</code>&#13;
<code class="k">fun</code> <code class="nf">onGpxFileWriteEvent</code><code class="p">(</code>&#13;
   <code class="n">event</code><code class="p">:</code> <code class="n">GpxFileWriteEvent</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">mStarted</code> <code class="p">=</code> <code class="k">false</code>&#13;
    <code class="n">sendStatus</code><code class="p">()</code>&#13;
    <code class="n">stopSelf</code><code class="p">()</code>    <code class="c1">// &lt;--- fix will stop the service and release the reference at GC</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can use Memory Profiler and check the heap dump to ensure we hold reference to only one service in memory. Actually,&#13;
since GPX recordings are done through <code>LocationService</code>, it makes sense to stop the service when the user stops recording.&#13;
This way, the service can be deallocated from memory on GC: otherwise, the heap continues to hold an instance of&#13;
<code>LocationService</code> past its life.</p>&#13;
&#13;
<p class="pagebreak-before">Memory Profiler can help you detect possible memory leaks through the process of sifting through the heap dump. You can also filter a heap dump by checking the&#13;
<em>Activities/Fragments Leaks</em> box in the heap dump configurations in Memory Profiler. Hunting for memory leaks can be…a manual process, and even then, hunting for memory leaks yourself is only one way of catching them. Luckily, we have&#13;
&#13;
<span class="keep-together">LeakCanary,</span> a popular memory leak detection library that can attach to your app in debug mode and idly watch for memory&#13;
leaks to occur<a data-startref="ix_ch11-asciidoc28" data-type="indexterm" id="idm46669737044928"/><a data-startref="ix_ch11-asciidoc27" data-type="indexterm" id="idm46669737044224"/><a data-startref="ix_ch11-asciidoc26" data-type="indexterm" id="idm46669737043552"/>.<a data-startref="ix_ch11-asciidoc3" data-type="indexterm" id="idm46669737042752"/><a data-startref="ix_ch11-asciidoc2" data-type="indexterm" id="idm46669737042048"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Detecting Memory Leaks with LeakCanary" data-type="sect1"><div class="sect1" id="Detecting_Memory_Leaks_with_LeakCanary_id">&#13;
<h1>Detecting Memory Leaks with LeakCanary</h1>&#13;
&#13;
<p><a data-primary="Android profiling tools" data-secondary="detecting memory leaks with LeakCanary" data-type="indexterm" id="ix_ch11-asciidoc29"/><a data-primary="LeakCanary" data-type="indexterm" id="ix_ch11-asciidoc30"/><a data-primary="memory leaks" data-secondary="LeakCanary detecting" data-type="indexterm" id="ix_ch11-asciidoc31"/>LeakCanary automatically detects at runtime explicit and implicit memory leaks that might be&#13;
hard to detect manually. This is a great benefit, since Memory Profiler requires manually&#13;
triggering a heap dump and checking for retained memory. When crash analytics are unable to detect crashes coming from&#13;
an <code>OutOfMemoryException</code>, LeakCanary serves as a viable alternative to keep an eye on issues detected at runtime, and&#13;
offers better coverage in discovering memory leaks.</p>&#13;
&#13;
<p>Memory leaks commonly come from bugs related to the lifecycle of objects being held past their use. LeakCanary is able&#13;
to detect various mistakes such as:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Creating a new <code>Fragment</code> instance without destroying the existing version first</p>&#13;
</li>&#13;
<li>&#13;
<p>Injecting an Android <code>Activity</code> or <code>Context</code> reference <em>implicitly</em> or <em>explicitly</em> into a non-Android component</p>&#13;
</li>&#13;
<li>&#13;
<p>Registering a listener, broadcast receiver, or RxJava subscription and not remembering to dispose of the listener/subscriber&#13;
at the end of the parent lifecycle</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For this example, we have installed LeakCanary in TrekMe. LeakCanary is used organically in development until a heap dump&#13;
with potential leaks has been retained. You can install LeakCanary by adding the following dependency to Gradle:</p>&#13;
&#13;
<pre data-code-language="groovy" data-type="programlisting"><code class="n">debugImplementation</code> <code class="s1">'com.squareup.leakcanary:leakcanary-android:2.*'</code></pre>&#13;
&#13;
<p>Once installed in your application, LeakCanary automatically detects leaks when an <code>Activity</code> or <code>Fragment</code> has been&#13;
destroyed, clears the <code>ViewModel</code>, and more.  It does this by detecting retained objects passed through some&#13;
<code>ObjectWatcher</code>. LeakCanary then dumps the heap, analyzes the heap, and categorizes those leaks for easy consumption.&#13;
After installing LeakCanary, you can use the application like normal. Should LeakCanary&#13;
detect retained instances in a heap dump that occurs, it sends a notification to the system tray.</p>&#13;
&#13;
<p class="pagebreak-before">In the case of TrekMe, it appears LeakCanary has detected a memory leak within a RecyclerView instance of&#13;
<code>MapImportFragment</code>, as shown in <a data-type="xref" href="#leak_canary_2">Figure 11-29</a>.</p>&#13;
&#13;
<figure><div class="figure" id="leak_canary_2">&#13;
<img alt="pawk 1130" src="assets/pawk_1130.png"/>&#13;
<h6><span class="label">Figure 11-29. </span>LeakCanary shows a RecyclerView leaking in its stacktrace.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The error message is telling us that a <code>RecyclerView</code> instance is “leaking.” LeakCanary indicates that this view instance&#13;
holds a reference on a <code>Context</code> instance which wraps the activity. Something prevents the <code>RecyclerView</code> instance from&#13;
being garbage-collected—either an implicit or explicit reference to the <code>RecyclerView</code> instance passed to the&#13;
component outliving the activity.</p>&#13;
&#13;
<p>We’re not sure what we’re dealing with quite yet, so we start by looking at the <em>MapImportFragment.kt</em> class holding&#13;
the RecyclerView mentioned in <a data-type="xref" href="#leak_canary_2">Figure 11-29</a>. Tracing back to the UI element <code>recyclerViewMapImport</code> referenced from&#13;
the layout file, we bring your attention to something curious:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">MapImportFragment</code><code class="p">:</code><code> </code><code class="n">Fragment</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">viewModel</code><code class="p">:</code><code> </code><code class="n">MapImportViewModel</code><code> </code><code class="k">by</code><code> </code><code class="n">viewModels</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="cm">/* removed for brevity */</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">override</code><code> </code><code class="k">fun</code><code> </code><code class="nf">onViewCreated</code><code class="p">(</code><code class="n">view</code><code class="p">:</code><code> </code><code class="n">View</code><code class="p">,</code><code> </code><code class="n">savedInstanceState</code><code class="p">:</code><code> </code><code class="n">Bundle</code><code class="p">?</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="cm">/* removed for brevity */</code><code>&#13;
</code><code>        </code><code class="n">recyclerViewMapImport</code><code class="p">.</code><code class="n">addOnItemTouchListener</code><code class="p">(</code><code>&#13;
</code><code>            </code><code class="n">RecyclerItemClickListener</code><code class="p">(</code><code>&#13;
</code><code>                </code><code class="k">this</code><code class="p">.</code><code class="n">context</code><code class="p">,</code><code>                            </code><a class="co" href="#callout_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-1" id="co_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>                </code><code class="n">recyclerViewMapImport</code><code class="p">,</code><code>&#13;
</code><code>                </code><code class="k">object</code><code class="p">:</code><code> </code><code class="n">RecyclerItemClickListener</code><code class="p">.</code><code class="n">onItemClickListener</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                    </code><code class="k">override</code><code> </code><code class="k">fun</code><code> </code><code class="nf">onItemClick</code><code class="p">(</code><code class="n">view</code><code class="p">:</code><code> </code><code class="n">View</code><code class="p">,</code><code> </code><code class="n">position</code><code class="p">:</code><code> </code><code class="n">Int</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                        </code><code class="n">binding</code><code class="p">.</code><code class="n">fab</code><code class="p">.</code><code class="n">activate</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>                        </code><code class="n">single</code><code class="p">.</code><code class="n">fab</code><code class="p">(</code><code class="n">position</code><code class="p">)</code><code>&#13;
</code><code>                    </code><code class="p">}</code><code>&#13;
</code><code>            </code><code class="p">}</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="cm">/* removed for brevity */</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">fun</code><code> </code><code class="nf">FloatingActionButton</code><code class="p">.</code><code class="n">activate</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="cm">/* removed for brevity */</code><code>&#13;
</code><code>        </code><code class="n">fab</code><code class="p">.</code><code class="n">setOnClickListener</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="n">itemSelected</code><code class="o">?.</code><code class="n">let</code><code> </code><code class="p">{</code><code> </code><code class="n">item</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>                </code><code class="k">val</code><code> </code><code class="py">inputStream</code><code> </code><code class="p">=</code><code> </code><code class="n">context</code><code class="p">.</code><code class="n">contentResolver</code><code class="p">.</code><code>&#13;
</code><code>                    </code><code class="n">openInputStream</code><code class="p">(</code><code class="n">item</code><code class="p">.</code><code class="n">url</code><code class="p">)</code><code>&#13;
</code><code>                </code><code class="n">inputStream</code><code class="o">?.</code><code class="n">let</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                    </code><code class="n">viewModel</code><code class="p">.</code><code class="n">unarchiveAsync</code><code class="p">(</code><code class="n">it</code><code class="p">,</code><code> </code><code class="n">item</code><code class="p">)</code><code>   </code><a class="co" href="#callout_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-2" id="co_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>                </code><code class="p">}</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-1" id="callout_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>In the <code>MapImportFragment</code>, we attach a custom click listener to every <code>ViewHolder</code> in the <code>RecyclerView</code>.</p></dd>&#13;
<dt><a class="co" href="#co_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-2" id="callout_performance_considerations_with___span_class__keep_together__android_profiling_tools__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>Context</code> then is used to get a <code>ContentResolver</code> and create an <code>InputStream</code> to feed as an argument for&#13;
<code>MapImportViewModel::unarchiveAsync</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>When a user clicks on a particular item in the RecyclerView, the Kotlin extension function <code>FloatingActionButton::activate</code>&#13;
is called. Remember, a common cause for a memory leak is when we accidentally inject an <code>Activity</code> or a <code>Context</code>&#13;
into a non-Android component.</p>&#13;
&#13;
<p>If you look closely at the <code>FloatingActionButton::activate</code> implementation, you can see that we create an implicit&#13;
reference to the enclosing class, which is the <code>MapImportFragment</code> instance.</p>&#13;
&#13;
<p>How is an implicit reference created? We add a click listener to a button. The listener holds a reference to the parent&#13;
<code>Context</code> (returned by the <code>getContext()</code> method of the fragment). To be able to access the <code>Context</code> from inside the listener, the Kotlin compiler creates an&#13;
implicit reference to the enclosing class.</p>&#13;
&#13;
<p>Following the code to the <code>MapImportViewModel</code> method, we see the <code>InputStream</code> passed down to be able to call another&#13;
private method in the <code>ViewModel</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MapImportViewModel</code> <code class="n">@ViewModelInject</code> <code class="n">constructor</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">settings</code><code class="p">:</code> <code class="n">Settings</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">ViewModel</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="cm">/* removed for brevity */</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">unarchiveAsync</code><code class="p">(</code><code class="n">inputStream</code><code class="p">:</code> <code class="n">InputStream</code><code class="p">,</code> <code class="n">item</code><code class="p">:</code> <code class="n">ItemData</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">viewModelScope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">rootFolder</code> <code class="p">=</code> <code class="n">settings</code><code class="p">.</code><code class="n">getAppDir</code><code class="p">()</code> <code class="o">?:</code> <code class="k">return</code><code class="n">@launch</code>&#13;
            <code class="k">val</code> <code class="py">outputFolder</code> <code class="p">=</code> <code class="n">File</code><code class="p">(</code><code class="n">rootFolder</code><code class="p">,</code> <code class="s">"imported"</code><code class="p">)</code>&#13;
            <code class="cm">/* removed for brevity */</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A<a data-primary="ViewModel" data-type="indexterm" id="idm46669736883728"/> <code>ViewModel</code> object has a lifecycle of its own and is intended to outlive the lifecycle of the view it is tied to until&#13;
the <code>Fragment</code> is detached. Rather than using an <code>InputStream</code> as an argument, it is better to use an application <code>context</code>,&#13;
which is available throughout the life of the application and which can be injected via constructor parameter injection in&#13;
<code>MapImportViewModel</code>.<sup><a data-type="noteref" href="ch11.html#idm46669736623312" id="idm46669736623312-marker">1</a></sup>&#13;
We can then create the <code>InputStream</code> right in <code>MapImportViewModel::unarchiveAsync</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MapImportViewModel</code> <code class="n">@ViewModelInject</code> <code class="n">constructor</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">settings</code><code class="p">:</code> <code class="n">Settings</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">app</code><code class="p">:</code> <code class="n">Application</code>&#13;
<code class="p">):</code> <code class="n">ViewModel</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="cm">/* removed for brevity */</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">unarchiveAsync</code><code class="p">(</code><code class="n">item</code><code class="p">:</code> <code class="n">ItemData</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">viewModelScope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">inputStream</code> <code class="p">=</code> <code class="n">app</code><code class="p">.</code><code class="n">contentResolve</code><code class="p">.</code>&#13;
                <code class="n">openInputStream</code><code class="p">(</code><code class="n">item</code><code class="p">.</code><code class="n">uri</code><code class="p">)</code> <code class="o">?:</code> <code class="k">return</code><code class="n">@launch</code>&#13;
            <code class="k">val</code> <code class="py">rootFolder</code> <code class="p">=</code> <code class="n">settings</code><code class="p">.</code><code class="n">getAppDir</code><code class="p">()</code> <code class="o">?:</code> <code class="k">return</code><code class="n">@launch</code>&#13;
            <code class="k">val</code> <code class="py">outputFolder</code> <code class="p">=</code> <code class="n">File</code><code class="p">(</code><code class="n">rootFolder</code><code class="p">,</code> <code class="s">"imported"</code><code class="p">)</code>&#13;
            <code class="cm">/* removed for brevity */</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Of course, turning on LeakCanary can be disrupting for development if an existing application has many memory leaks.&#13;
In this case, the temptation might be to turn off LeakCanary to prevent disruption to current work.&#13;
Should you choose to put LeakCanary on your application, it is best to do it only when you and your team have the capacity&#13;
to “face the music.”<a data-startref="ix_ch11-asciidoc31" data-type="indexterm" id="idm46669736620560"/><a data-startref="ix_ch11-asciidoc30" data-type="indexterm" id="idm46669736505856"/><a data-startref="ix_ch11-asciidoc29" data-type="indexterm" id="idm46669736505248"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669737010496">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>There is no doubt that Android benchmarking and profiling tools are powerful. To ensure that your application is getting the&#13;
most out of analytics, it’s best to choose one or two tools as appropriate. It can be easy to get lost in the world of optimizations,&#13;
but it’s important to remember that the largest wins come from making optimizations with the least effort and the&#13;
largest impact. Likewise, it’s important to take current priorities and team workload into consideration.</p>&#13;
&#13;
<p>Approach Android optimizations like a nutritionist, encouraging incremental, habitual changes instead of “crash dieting.” Android profiling is intended to show you what’s really&#13;
happening under the hood, but it’s important to remember that the average Android developer must prioritize which&#13;
issues must be addressed in a world where their time and manpower may be limited.</p>&#13;
&#13;
<p>The hope is that you feel more equipped to handle any potential bugs that may come your way, and that this chapter gives&#13;
you confidence to start exploring some of these tools on your own applications to see how things are working under the hood:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Android Profiler is a powerful way to analyze application performance, from networking and CPU to memory and&#13;
energy analytics. Android Studio caches recorded sessions along with heap dumps and method traces for the lifespan&#13;
of an Android Studio instance so that you can compare them with other saved sessions.</p>&#13;
</li>&#13;
<li>&#13;
<p>Network Profiler can help solve Android problems specific to API debugging. It can provide information&#13;
useful to both the client device and the server where the data comes from, and can help us ensure optimal data formatting&#13;
within a network call.</p>&#13;
</li>&#13;
<li>&#13;
<p>CPU Profiler can give insight as to where most of the time is being spent executing methods, and is particularly&#13;
useful for finding bottlenecks in performance. You can record different kinds of CPU traces to be able to drill&#13;
down into specific threads and call stacks.</p>&#13;
</li>&#13;
<li>&#13;
<p>Energy Profiler looks at whether CPU processes, networking calls, or GPS locations in an application could be&#13;
draining a device’s battery.</p>&#13;
</li>&#13;
<li>&#13;
<p>Memory Profiler looks at how much memory is allocated in the heap. This can help give insight about areas of code&#13;
that could use improvements in memory.</p>&#13;
</li>&#13;
<li>&#13;
<p>LeakCanary is a popular open source library created by Square. It can be helpful to use LeakCanary to&#13;
detect memory leaks that are harder to detect at runtime.<a data-startref="ix_ch11-asciidoc0" data-type="indexterm" id="idm46669736494560"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669736623312"><sup><a href="ch11.html#idm46669736623312-marker">1</a></sup> The <code>@ViewModelInject</code> annotation is special to Hilt, which is a dependency injection framework. However, constructor parameter injection can also be achieved with manual DI or with DI frameworks like Dagger and Koin.</p></div></div></section></body></html>