- en: Chapter 13\. Securing Your System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System security is the application of configurations, software, policies, rules,
    and best practices to a system (whether it’s new or years old) so that the system
    operates without significant downtime due to security breaches and compromises.
    As a system administrator, security is your most important and time-consuming
    task.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concentrates on the prevention of security problems. Discovery
    and mitigation are briefly covered. You will learn how to secure both newly deployed
    systems and systems that have been in operation for years. No single treatment
    is comprehensive because new threats and vulnerabilities arise on what seems like
    a daily basis. You will learn how to apply basic security settings to your Linux
    systems. Because many larger companies have their own standards, the security
    settings I recommend are a good place to start, but you should always comply with
    corporate security protocols and policies.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the Root Account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The root user account is the all-powerful account on every Linux system, and
    you must protect access to it. If someone compromises this account, they can lock
    you out, destroy the system, steal data, or maintain control of it and use it
    to pivot to and compromise other systems within your network. Never write down
    or share the root password with anyone outside the system administrators group.
    If you use a database or other secure password manager to generate and store passwords,
    ensure that you exercise extreme security measures around those applications.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the protection of regular user accounts (with password complexity, length,
    and expiration), you have the ultimate responsibility of protecting the root account
    as a system administrator. System user account passwords can be shared, written
    down, stolen via phishing, or given verbally to someone attempting to exploit
    a user via social engineering tactics. For these reasons, passwords, no matter
    how complex, are still vulnerable to many different types of attacks and should
    be replaced with passwordless key files, whose creation and use are covered later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The next section helps you understand the balance you must find and maintain
    between securing a system and locking it down so tightly that users will be tempted
    to circumvent security altogether by creating rogue systems or local virtual machines
    that likely have little to no security measures in place.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Balance Between Security and Usability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we’ve established, security is your greatest responsibility. However, you
    must also support usable systems. The most secure system is powered off and locked
    away, but it’s also not usable. Therefore, you have to strike a balance between
    a system that is secure for everyone and one that’s also usable.
  prefs: []
  type: TYPE_NORMAL
- en: Systems must have users, software, files, and network connections to be useful.
    All of these make your system less secure but more usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your job is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Maintain systems so they’re secure from over-the-network attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect the system from careless users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect users from one another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect the system’s configurations and data from everyone except those with
    appropriate access granted to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, you’ll learn how to perform these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing Your System’s Attack Surface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever seen a reenactment of a duel on television or in a movie? Notice
    that the participants turn sideways to each another with one arm outstretched
    and holding the dueling pistol while holding the other hand behind them. This
    “dueling” stance minimizes their exposed shootable surface, making them harder
    to hit. By decreasing the target size, you also decrease the chances of a fatal
    strike. You should protect your systems by decreasing their attackable surface
    in the same way, exposing only what you must to support normal user operation.
  prefs: []
  type: TYPE_NORMAL
- en: You must carefully select which services to install when installing a new system.
    For example, when I install a Red Hat–based server system, I use a minimal installation
    option that usually includes only the SSH service. I add services and packages
    as required to keep my systems’ footprints purposely small and focused on a single
    task. I never install a graphical user interface (GUI) or graphical display manager
    onto a server system because of the security vulnerabilities inherent in these
    user-friendly interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for and removing a GUI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To check if your system has a graphical display manager, issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the response is anything but `multi-user.target`, run the following command
    to correct it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check for the installation of a GUI or graphical display manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you receive any response, it might look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You might also see packages similar to `xorg-x11-server-common` and `xorg-x11-server-utils`.
    If you see any of these packages, issue the following command to remove them.
    Use the specific package name corresponding to your system’s installed package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating single-purpose systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At a minimum, each of your systems needs an SSH server. It’s a secure method
    of connecting and managing systems. Unused services make your system vulnerable
    and are entry points for system- and network-wide compromise. You should install
    your systems using a server or a minimal install option and add services as required
    after installation and setup.
  prefs: []
  type: TYPE_NORMAL
- en: If your distribution doesn’t have a server or minimal install option, then you
    must selectively uninstall any service or software package that isn’t explicitly
    required for the system’s prescribed purpose. Let’s examine how to create systems
    with a single purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization and cloud computing have allowed businesses to focus on a single
    service per system. Because of hardware costs, we used physical systems as servers
    rather than virtualization hosts and had to stack multiple services on a single
    system. Virtualization host systems can serve dozens of virtual machines or hundreds
    of container systems, each performing a single business task, such as a web server,
    database server, or application server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building a system that hosts a single service is much easier than paring down
    one that has existed for some time. However, as part of your system administrator
    duties, you should perform security “sweeps” of any system under your management.
    And a security sweep or audit includes examining the system for unused and outdated
    services that cause it to be vulnerable to attack. A security sweep consists of
    checking listening ports on the local machine using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These two commands provide a list of listening daemons (services). The interface
    `0.0.0.0` is all interfaces. Services accessible only on the local system listen
    on `127.0.0.1` (`localhost` or `loopback`). Malicious actors often set up an exfiltration
    service disguised as a web service, DNS service, or other legitimate service to
    fool system administrators and port scanners. You should check the legitimacy
    of all listening processes on your systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For example in the */etc/httpd/conf/httpd.conf* file (or your specific Apache
    configuration file), there are two possible configurations, but you may only use
    one or the other. You must comment the one you don’t wish to use. Here is the
    excerpt from *httpd.conf*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You may specify a particular network interface and port (`Listen 127.0.0.1:80`)
    or a port to listen on all interfaces (`Listen 80`). The former configuration
    ensures that only local system users may use the web service. While a local-only
    web server isn’t very practical, it illustrates how to limit access to a network
    service.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should perform an `autoremove` to remove unused software from your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This command removes any leftover software package dependencies from an incomplete
    uninstall or insufficient package removal cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that enabling any over-the-network listening daemon or service puts
    your system at potential risk. Protect all services with secure protocols, firewalls,
    access control lists, and IP restrictions as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The next section discusses security for user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Securing User Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as you create a user account on your system, your system’s security
    is weakened. However, as you know, user accounts are a requirement. It is a rare
    system with no user accounts other than the root account. Service accounts are
    common user accounts, even with no interactive shell. Having no shell means no
    one may interactively log in as that user and issue shell commands. Most systems
    have interactive shell user accounts so that regular users may log in and issue
    commands, compile software, connect to other systems, and use resources such as
    storage and data.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem with interactive user accounts is weak passwords. Weak passwords
    threaten your system’s security. There are at least two methods of mitigating
    this problem. One is to set up your system to require strong passwords by creating
    and enforcing a strong password policy. Another is to disable password use in
    favor of SSH key files so that users can connect to other systems without a password.
    You can also configure multifactor authentication (MFA) using various free or
    commercial tools. MFA implementation is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and enforcing a strong password policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Red Hat Enterprise Linux–based systems, the */etc/security/pwquality.conf*
    file is the configuration file that allows system administrators to set and enforce
    corporate password policies. The following is a complete listing of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to other systems via passwordless key files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Capturing passwords through packet sniffing or keylogger programs is a common
    method of compromising systems when unsuspecting users connect from one system
    to another using passwords. One of the best methods of password capture prevention
    is to discontinue the use of passwords altogether. Using key files, users may
    connect from one system to another without the need to interactively enter a password.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up key files between systems is trivial but a little time-consuming.
    Ultimately, it increases security because no passwords are traveling across networks,
    written on sticky notes, or so simple that anyone can guess them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the key file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remote login via key files provides you with a more secure connection between
    remote systems than using passwords.  Without going into great detail about how
    private/public key authentication works, which you can certainly research on your
    own, realize that using key files doesn’t pass an encrypted or unencrypted password
    to another system. There is no usable data (passwords) for an attacker to capture,
    so brute-force attacks against encrypted information aren’t possible. Creating
    a private/public key pair is easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses two Linux systems, `server1` and `server2`. You
    can see in the following code that you haven’t configured remote login via key
    files between these two systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following commands on both systems to set up your private/public key
    pair between these two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The default encryption algorithm is RSA, but both RSA and DSA algorithms are
    old, and you shouldn’t use them. The newer elliptical curve digital signature
    algorithm (ECDSA) is currently the best option. And while this algorithm accepts
    256- and 384-bit encryption, use 521 for maximum protection. You may optionally
    provide a passphrase to protect your key file pair further. Providing a passphrase
    ensures that even if your private key is stolen, it can’t be used without the
    passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The three available key sizes are 256, 384, and 521\. No, the `521` you see
    in the command isn’t an error. One would think the next available key size would
    be 512, but for ECDSA, it is 521.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the ID from one server to another using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As the message suggests, try to log into `server2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You have successfully created the key pair and may now log in from `server1`
    to `server2` without a password. Your next question should be, “Is this passwordless
    login only valid from `server1` to `server2` (unidirectional), or is it bidirectional
    (`server2` to `server1`)?”
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer the question, try to log in from `server2` to `server1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer is no. The key pair is unidirectional. To set up a reciprocal login
    (`server2` to `server1`), you must repeat the process for `server2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You may now connect bidirectionally between `server1` and `server2` using key
    pair authentication. If you want to learn more about SSH, encryption protocols,
    and security-related topics, please visit the [OpenSSH website](https://oreil.ly/ontmn).
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra security to SSHD
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You should secure your SSHD by accepting key file authentication if it’s not
    already set up. You can check by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncomment this line and restart the SSHD service. If you filter on the word
    “password,” you will find the following line in */etc/ssh/sshd_config*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This line allows users to connect and log in with a username and password. This
    line is a requirement for setting up key-based authentication. (Refer to the preceding
    subsection, where we saw that you must log in via username and password to copy
    your key to the remote system.)
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you change `PasswordAuthentication yes` to `Password​Authenti⁠cation no`,
    you will exclude users who do not already have their key-based authentication
    configured, because they will not be able to log in with a username and password.
    You’ll have to manually configure each user account unless you use some automation.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding warning is one of those decision points that you must make as
    a system administrator—finding the balance between usability and security. On
    the one hand, your attempt to increase security by removing passwords from remote
    connectivity is admirable. Still, on the other hand, you must leave password authentication
    intact to enable users to create their key pairs for secure connectivity. My best
    advice is to disable passwords and handle the task for your users because if you
    leave this significant security step to your users, your systems may go unsecured
    for months or years. Should you decide not to disable password authentication,
    please increase password complexity, shorten the expiration interval to no more
    than 90 days, and enforce nonrepeated passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Advanced Security Measures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The definition of *advanced* is certainly up for debate. For me, advanced means
    security measures that generally conform to the Security Technical Implementation
    Guide (STIG) as described in the [National Institute of Standards and Technology
    (NIST) 800-53](https://oreil.ly/E1G1b) and related documents. The so-called “STIGging”
    of a system protects it from over-the-network attacks and local system attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that even using STIG to secure a system is not a foolproof security
    method, but it’s a great standard for setting up new systems. It would be best
    to use it to secure your inherited systems.
  prefs: []
  type: TYPE_NORMAL
- en: STIGs are generally used for government contractor–owned systems involved in
    Department of Defense projects that must comply with strict data-handling regulations.
    Still, they apply to any system, hosting sensitive data or not. It would help
    if you implemented as many of these items as practical, especially those in the
    high severity list. [Figure 13-1](#the_findings_and_severity_levels_of_the) shows
    each guideline’s number and severity for reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/plsa_1301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. The findings and severity levels of the Red Hat Enterprise Linux
    8 STIG
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The next section discusses applying these controls to your systems.
  prefs: []
  type: TYPE_NORMAL
- en: Applying STIG Security Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applying a list of STIG controls is a time-consuming task. However, as you read
    through the controls, you’ll find that you can automate most configurations necessary
    to comply with the standard. And some STIGs provide you with downloadable scripts
    to make compliance easier. While the STIG shown in [Figure 13-1](#the_findings_and_severity_levels_of_the)
    is Red Hat Enterprise Linux–specific, these standards apply to all Linux distributions
    used in businesses and government offices. Information related to an Ubuntu STIG
    is available on the [Ubuntu DISA page](https://oreil.ly/Bob4c).
  prefs: []
  type: TYPE_NORMAL
- en: If you create “golden” images for your systems, which I highly recommend, you
    can develop a STIG image with the security controls already in place. New, revised
    STIGs are released when necessary and usually contain only a few new security
    fixes that you can place on your systems via script or some automation tool. Updating
    a golden image twice per year is probably enough to keep your systems updated
    so that new controls will be easy to distribute.
  prefs: []
  type: TYPE_NORMAL
- en: To implement STIG controls, begin with the Category I (High severity) controls
    and apply those first. If you have systems that you feel might be vulnerable,
    immediately implement all Category I security controls. Currently, for Red Hat
    Enterprise Linux 8, there are only 21 such controls, so the effort required is
    minimal. For Category II (Medium severity) controls, you should employ an audit
    tool because there are more than 300 Category II controls.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Using Security Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are dozens of commercial and free security tools that you can use to better
    protect your systems. The following three tools used with STIG can greatly enhance
    your systems’ security. As stated previously, you should install and run these
    tools at least once before deploying your systems onto a live network. An initial
    run provides you with a baseline assessment. Keep these initial reports to compare
    with those you run in the future.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend the following short list of security tools. All new systems
    should have these tools installed and an initial run completed before system production
    deployment. These security tools have served me well and are well-accepted in
    many enterprise environments.
  prefs: []
  type: TYPE_NORMAL
- en: Lynis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lynis is a lighter-weight vulnerability checker than the Security Content Automation
    Protocol (SCAP) and STIG tools. However, it is not a replacement for those tools
    if you must comply with the Department of Defense or other government security
    standards. Lynis is a security auditing tool that checks your servers’ system
    and software configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Lynis package via your package manager, and then run a system audit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once the audit is complete, I usually `grep` for `Suggestion`, as shown here,
    to obtain a list of recommended security fixes. The list might be quite lengthy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to this list, make corrections and fixes, and rerun the system
    audit. I recommend continuing to do this until there are no more recommended fixes
    or to get the list to a point where the recommendations (suggestions) do not apply
    to your system. The following is an excerpt from my suggestion list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An example of something I can ignore is the */etc/issue* and */etc/issue.net*
    legal notice. My systems are private virtual machines, and I’m the only one who
    uses them. You will likely see a long list of SSH hardening suggestions. It would
    be best if you implemented these. Some sysadmins create “golden” images from systems
    that have passed through a Lynis “cleansing” so they can deploy a clean image.
    Of course, Lynis should be run regularly to maintain this status. A scheduled
    `cron` job is a good solution for creating regular reports.
  prefs: []
  type: TYPE_NORMAL
- en: Portsentry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Portsentry runs in memory and attempts to detect network port scans and then
    ban the offending hosts’ IP address via *hosts.deny*, firewall rules, `ipchains`
    and `iptables` entries, or dropped routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following ports defined in */etc/portsentry/portsentry.conf* are “activated.”
    You may add custom ports or remove port numbers at will. In the Ubuntu implementation,
    this is the default list of ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The default action is to drop the route back to the scanning host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I also use the */etc/hosts.deny* entry by uncommenting the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the route to the host is blocked and the IP address is blocked
    in */etc/hosts.deny*. The entries from */etc/hosts.deny* and *route* look like
    the result from a scan (the scanning host is `192.168.1.234`).
  prefs: []
  type: TYPE_NORMAL
- en: 'From */etc/hosts.deny*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'From the *route* table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some entries from */var/log/syslog* that identify the offending system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Portsentry is a handy little utility that’s always been one of my security layers.
    You can see that it effectively eliminates connectivity from a particular host.
    If you have a DMZ host, you should use Portsentry on it because it will be scanned
    multiple times daily.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Intrusion and Detection Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Advanced Intrusion and Detection Environment (AIDE) is an intrusion-detection
    system for checking file integrity. Install AIDE from a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you do not use a Red Hat–based system, the installation proceeds differently.
    On Ubuntu (and I assume on all Debian-based systems), the installer steps you
    through a postfix configuration and creates multiple configuration files under
    */etc/aide*. The Ubuntu implementation is different from the Red Hat Enterprise
    Linux–based one. Differences are noted in the text. Before using AIDE, you must
    first initialize its database with the following command. This process takes a
    few minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can initialize the AIDE database on Ubuntu with a similar command (script),
    which executes `aide –init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On Red Hat Enterprise Linux–based systems, you must perform one last task before
    checking your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can perform a check on Ubuntu systems without copying the file. The Ubuntu
    install completes the task for you. However, if you run `sudo aide --check`, you
    receive the error `Couldn't open file /var/lib/aide/please-dont-call-aide-without-parameters/aide.db
    for reading`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ubuntu system shows a positive report for changes. It’s lengthy but illustrates
    the type of report you’ll see when AIDE detects changes. The report provides details
    of changes made to files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run an update that checks and updates the database, but the input
    and output databases must differ. The output from this command is also rather
    lengthy and is truncated because of that length. But the part I show here is the
    summary rather than the detailed view. This update was executed on an Ubuntu system
    but worked the same on Red Hat Enterprise Linux–based systems using the `sudo
    aide.wrapper --update` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you might receive false positives because some files change
    often, but it’s worth the slight annoyance to have a file integrity check that
    works. The next section is an overview of responding to security incidents, including
    internal and external system breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to Security Incidents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A security incident ranges from a user allowing  another user access to their
    account, to a clever user attempting to crack the root user’s password, to a full
    security breach by a malicious outside actor or advanced persistent threat. I’ve
    witnessed these, plus many other types of security incidents. One of the least-pleasant
    tasks that any sysadmin performs is responding to a security incident. Your worst
    day imaginable is when you discover a security breach or someone tells you, “We’ve
    been hacked.” These words are going to ruin an otherwise uneventful day.
  prefs: []
  type: TYPE_NORMAL
- en: A well-written security policy is the best defense against insider threats,
    such as someone trying to crack the root user’s passwords or sharing credentials
    between users. These incidents should be recorded and reported to management,
    and policy-driven action should be taken to prevent future occurrences of these
    types of security breaches. The story goes differently for external breaches because
    corporate policies do not bind malicious actors outside your organization.
  prefs: []
  type: TYPE_NORMAL
- en: The topics covered in this section deal with handling security incidents that
    occur from internal and external actors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Written Security Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing a security policy is a manageable task. Many examples are freely available
    online. A quick search turns up hundreds of possibilities. Select one or more
    generic policy examples and adapt them to your organization. All security incidents
    are serious and should be handled as such. Even the simple sharing of usernames
    and passwords between friendly coworkers is a violation and should be dealt with
    immediately and sternly. Violating security policy is often grounds for reprimand,
    termination, and criminal prosecution.
  prefs: []
  type: TYPE_NORMAL
- en: Each employee should be given a copy of the written security policy and should
    sign that they’ve read and understood the policy and the consequences of its violation.
    Annual security refresher courses should reinforce corporate security policy standards,
    expectations, and violation consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Confirming the Breach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must confirm that a breach has occurred and to what extent the breach has
    compromised intellectual property, financial records, employee information, and
    other valuable information and data. Depending on your specific regulatory requirements
    from the Securities and Exchange Commission, Department of Defense, and other
    authorities, some breaches must be reported to law enforcement upon discovery
    and confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t classified under one of the many regulatory authorities, you might
    find that you’re on your own for confirming and dealing with a breach. You should
    contact a third-party security firm that deals with breach discovery to assist
    in your efforts.
  prefs: []
  type: TYPE_NORMAL
- en: The first course of action is to remove compromised systems from the network.
    Unplug their network connections and disable WiFi adapters. Leave the systems
    powered on. Load your forensic tools offline onto the affected systems and perform
    a disk clone of the system before performing any mitigation. The duplicated disk
    may prove valuable to law enforcement in tracking the suspects.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the Malicious Actor(s)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identifying internal actors is often far easier than identifying those from
    an external source. Law enforcement, including the FBI, the Department of Homeland
    Security, the NSA, and other agencies, might help with the investigation if the
    threat is thought to be from a foreign source. Attackers cover their tracks by
    removing log files, exfiltrating data in small amounts, and pivoting from one
    system to another to remain inside your network undetected for months or years.
  prefs: []
  type: TYPE_NORMAL
- en: If you suspect a malicious group or foreign government-sponsored collective
    has breached your network or stolen intellectual property, your best option is
    to contact law enforcement and the FBI. If your company is a contractor protected
    by the Department of Defense or another agency, the FBI or NSA might contact you
    about a breach before you know it has occurred. In these cases, it’s best to provide
    those authorities with any information, data, and access they request. Identifying,
    stopping, and prosecuting cybercriminals is a high priority for government agencies.
  prefs: []
  type: TYPE_NORMAL
- en: Taking Corrective Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve confirmed a breach and evaluated the damage, it’s time to take corrective
    action, including scanning and cleaning files, enabling host-based firewalls,
    encrypting data, and reimaging systems. The actions you take will be dictated
    by the extent of the breach and actions taken by the malicious actors. Good backups,
    a disaster recovery plan, encrypted data, and multilayer security will help you
    recover from a breach.
  prefs: []
  type: TYPE_NORMAL
- en: You should report any breach to local law enforcement and take any recommended
    actions. If the breach is ongoing, inform law enforcement that the breach is ongoing
    so that they can take action or notify other agencies on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, when an attack’s breadth and depth aren’t clear, it’s recommended
    to reimage key systems offline and apply all security measures before bringing
    them back onto the corporate network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network and system security are ongoing efforts, not a “set it and forget it”
    scenario. Security requires constant vigilance, advanced training, regular software
    and hardware patching, automated system software, and multiple layers of security
    from MFA, firewalls, encryption, secure tools, secure development, and user training.
    It’s wise to engage an external security firm to assist in the secure design and
    protection of your network and assets.
  prefs: []
  type: TYPE_NORMAL
