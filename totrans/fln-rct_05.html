<html><head></head><body><section data-pdf-bookmark="Chapter 4. Inside Reconciliation" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch04">&#13;
<h1><span class="label">Chapter 4. </span>Inside Reconciliation</h1>&#13;
&#13;
&#13;
<p>To be truly fluent in React, we need to understand <em>what</em> its functions&#13;
do. So far, we’ve understood JSX and <code>React.createElement</code>. We’ve also&#13;
understood the virtual DOM in some appreciable level of detail. Let’s&#13;
explore the practical applications of it &#13;
<span class="keep-together">in React</span> in this chapter, and&#13;
understand<a data-primary="ReactDOM.createRoot(element).render()" data-type="indexterm" id="id600"/><a data-primary="root, React" data-type="indexterm" id="id601"/> what <code>ReactDOM.createRoot(element).​ren⁠der()</code> does.&#13;
Specifically, we’ll explore <em>how</em> React builds its virtual DOM and then&#13;
updates the real DOM through a process called &#13;
<span class="keep-together">reconciliation</span><a data-primary="reconciliation" data-type="indexterm" id="ix_reconciliation.04.10.61"/><a data-primary="virtual DOM (vDOM)" data-secondary="reconciliation process" data-type="indexterm" id="ix_virtualDOMvDOMreconciliationprocess.04.10.61"/><a data-primary="Document Object Model (DOM)" data-secondary="reconciliation process from vDOM" data-type="indexterm" id="ix_DocumentObjectModelDOMreconciliationprocessfromvDOM.04.10.61"/>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Reconciliation" data-type="sect1"><div class="sect1" id="id45">&#13;
<h1>Understanding Reconciliation</h1>&#13;
&#13;
<p>As a quick recap, React’s virtual DOM is a blueprint of our desired UI&#13;
state. React takes this blueprint and, through a process called&#13;
<em>reconciliation</em>, makes it a reality in a given host environment;&#13;
usually a web browser, but possibly other environments like shells,&#13;
native platforms like iOS and Android, and more.</p>&#13;
&#13;
<p>Consider the following code snippet:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">main</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Hello</code><code class="p">,</code> <code class="nx">world</code><code class="o">!&lt;</code><code class="err">/h1&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">Count</code><code class="o">:</code> <code class="p">{</code><code class="nx">count</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/span&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">Increment</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/main&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This code snippet contains a declarative description of what we want our&#13;
UI state to be: a tree of elements<a data-primary="tree of React elements" data-secondary="in reconciliation" data-secondary-sortas="reconciliation" data-type="indexterm" id="ix_treeofReactelementsinreconciliation.04.42.35"/>. Both our teammates <em>and</em> React can&#13;
read this and understand we’re trying to create a counter app with an&#13;
increment button that increments the counter. To understand&#13;
reconciliation, let’s understand what React does on the inside when&#13;
faced with a component like this.</p>&#13;
&#13;
<p>First, the JSX becomes a tree of React elements. This is what we saw in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>. When invoked, the <code>App</code> component returns a React&#13;
element whose children are further React elements. React elements are&#13;
immutable (to us) and represent the desired state of the UI. They are&#13;
not the actual UI state. React elements are created by&#13;
<code>React.createElement</code> or the JSX <code>&lt;</code> symbol, so this would be transpiled&#13;
into:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
    <code class="s2">"main"</code><code class="p">,</code>&#13;
    <code class="kc">null</code><code class="p">,</code>&#13;
    <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
      <code class="s2">"div"</code><code class="p">,</code>&#13;
      <code class="kc">null</code><code class="p">,</code>&#13;
      <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="s2">"Hello, world!"</code><code class="p">),</code>&#13;
      <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"span"</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="s2">"Count: "</code><code class="p">,</code> <code class="nx">count</code><code class="p">),</code>&#13;
      <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
        <code class="s2">"button"</code><code class="p">,</code>&#13;
        <code class="p">{</code> <code class="nx">onClick</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code> <code class="p">},</code>&#13;
        <code class="s2">"Increment"</code>&#13;
      <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This would give us a tree of created React elements that looks something&#13;
like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s2">"main"</code><code class="p">,</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">children</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="s2">"div"</code><code class="p">,</code>&#13;
      <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
        <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
          <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"h1"</code><code class="p">,</code>&#13;
            <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
              <code class="nx">children</code><code class="o">:</code> <code class="s2">"Hello, world!"</code><code class="p">,</code>&#13;
            <code class="p">},</code>&#13;
          <code class="p">},</code>&#13;
          <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"span"</code><code class="p">,</code>&#13;
            <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
              <code class="nx">children</code><code class="o">:</code> <code class="p">[</code><code class="s2">"Count: "</code><code class="p">,</code> <code class="nx">count</code><code class="p">],</code>&#13;
            <code class="p">},</code>&#13;
          <code class="p">},</code>&#13;
          <code class="p">{</code>&#13;
            <code class="nx">type</code><code class="o">:</code> <code class="s2">"button"</code><code class="p">,</code>&#13;
            <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
              <code class="nx">onClick</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">),</code>&#13;
              <code class="nx">children</code><code class="o">:</code> <code class="s2">"Increment"</code><code class="p">,</code>&#13;
            <code class="p">},</code>&#13;
          <code class="p">},</code>&#13;
        <code class="p">],</code>&#13;
      <code class="p">},</code>&#13;
    <code class="p">},</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This snippet represents the virtual DOM that comes from our&#13;
<code>Counter</code> component. Since this is the first render, this tree is now&#13;
committed to the browser using minimal calls to imperative DOM APIs. How&#13;
does React ensure minimal calls to imperative DOM APIs? It does so by&#13;
batching vDOM updates into one real DOM update, and touching the DOM as&#13;
little as possible for reasons discussed in earlier chapters. Let’s dive&#13;
into this in some more detail to fully understand batching<a data-startref="ix_treeofReactelementsinreconciliation.04.42.35" data-type="indexterm" id="id602"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Batching" data-type="sect1"><div class="sect1" id="id46">&#13;
<h1>Batching</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>, we discussed document fragments in browsers as part&#13;
of the DOM’s built-in APIs: lightweight containers that hold collections&#13;
of DOM nodes that act like a temporary staging area where you can make&#13;
multiple changes without affecting the main DOM until you finally append&#13;
the document fragment to the DOM, triggering a single reflow and&#13;
repaint.</p>&#13;
&#13;
<p>In a similar vein, React batches<a data-primary="batched updates" data-secondary="reconciliation" data-type="indexterm" id="ix_batchedupdatesreconciliation.04.133.33"/><a data-primary="reconciliation" data-secondary="batched updates" data-type="indexterm" id="ix_reconciliationbatchedupdates.04.133.33"/><a data-primary="updates" data-secondary="batching" data-type="indexterm" id="ix_updatesbatching.04.133.33"/> updates to the real DOM during&#13;
reconciliation, combining multiple vDOM<a data-primary="batched updates" data-secondary="virtual DOM" data-type="indexterm" id="id603"/> updates into a single DOM&#13;
update. This reduces the number of times the real DOM has to be updated&#13;
and therefore lends itself to better performance for web applications.</p>&#13;
&#13;
<p>To understand this, let’s consider a component that updates its state&#13;
multiple times in quick succession:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">Example</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">handleClick</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setCount</code><code class="p">((</code><code class="nx">prevCount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">prevCount</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setCount</code><code class="p">((</code><code class="nx">prevCount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">prevCount</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setCount</code><code class="p">((</code><code class="nx">prevCount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">prevCount</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">handleClick</code><code class="p">}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the <code>handleClick</code> function calls <code>setCount</code> three times&#13;
in quick succession. Without batching, React would update the real DOM&#13;
three separate times, even though the value of <code>count</code> only changed once.&#13;
This would be wasteful and slow.</p>&#13;
&#13;
<p>However, because React batches updates, it makes <em>one</em> update to the DOM&#13;
with <code>count + 3</code> instead of three updates to the DOM with <code>count + 1</code> each&#13;
time.</p>&#13;
&#13;
<p>To calculate the most efficient batched update to the DOM, React will&#13;
create a new vDOM tree<a data-primary="tree of React elements" data-secondary="forking new vDOM tree in batched update" data-type="indexterm" id="id604"/> as a fork of the current vDOM tree with the&#13;
updated values, where <code>count</code> is <code>3</code>. This tree will need to be&#13;
<em>reconciled</em> with what is currently in the browser, effectively turning&#13;
<code>0</code> into <code>3</code>. React will then calculate that just one update is required&#13;
to the DOM using the new vDOM value <code>3</code> instead of manually updating the&#13;
DOM three times. This is how batching fits into the picture, and it is a part&#13;
of the broader topic we’re about to dive into: reconciliation, or the&#13;
process of reconciling the next expected DOM state with the current DOM.</p>&#13;
&#13;
<p>Before we understand what modern-day React does under the hood, let’s&#13;
explore how React used to perform reconciliation before version 16, with&#13;
the legacy “stack” reconciler. This will help us understand the need&#13;
for today’s popular Fiber reconciler<a data-primary="Fiber reconciler" data-type="indexterm" id="id605"/><a data-primary="concurrent rendering and updating" data-secondary="Fiber reconciler" data-type="indexterm" id="id606"/><a data-primary="reconciliation" data-secondary="Fiber reconciler" data-type="indexterm" id="id607"/>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>At this point, it’s worth mentioning that all of the&#13;
topics we’re about to discuss are implementation details in React that&#13;
can and likely will change over time. Here, we are isolating the&#13;
mechanism of how React works from actual practical usage of React. The&#13;
goal is that by understanding React’s internal mechanisms, we’ll have a&#13;
better understanding of how to use React effectively in applications<a data-startref="ix_batchedupdatesreconciliation.04.133.33" data-type="indexterm" id="id608"/><a data-startref="ix_reconciliationbatchedupdates.04.133.33" data-type="indexterm" id="id609"/><a data-startref="ix_updatesbatching.04.133.33" data-type="indexterm" id="id610"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prior Art" data-type="sect1"><div class="sect1" id="id229">&#13;
<h1>Prior Art</h1>&#13;
&#13;
<p>Previously, React used a stack data structure for rendering. To make&#13;
sure we’re on the same page, let’s briefly discuss the stack data&#13;
structure.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stack Reconciler (Legacy)" data-type="sect2"><div class="sect2" id="id47">&#13;
<h2>Stack Reconciler (Legacy)</h2>&#13;
&#13;
<p>In computer science, a stack<a data-primary="reconciliation" data-secondary="stack reconciler (legacy)" data-type="indexterm" id="ix_reconciliationstackreconcilerlegacy.04.203.29"/><a data-primary="stack reconciler in React (legacy)" data-type="indexterm" id="ix_stackreconcilerinReactlegacy.04.203.29"/> is a linear data structure that follows the&#13;
last in, first out (LIFO) principle<a data-primary="last in, first out (LIFO) principle, stack" data-type="indexterm" id="id611"/><a data-primary="LIFO (last in, first out) principle, stack" data-type="indexterm" id="id612"/>. This means that the last element&#13;
added to the stack will be the first one to be removed. A stack has two&#13;
fundamental operations, push and pop, that allow elements to be added and&#13;
removed from the top of the stack, respectively.</p>&#13;
&#13;
<p>A stack can be visualized as a collection of elements that are arranged&#13;
vertically, with the topmost element being the most recently added one.&#13;
Here’s an ASCII illustration of a stack with three elements:</p>&#13;
&#13;
<pre data-code-language="less" data-type="programlisting"><code class="nt">-----</code><code class="w"/>&#13;
<code class="o">|</code><code class="w"> </code><code class="nt">3</code><code class="w"> </code><code class="o">|</code><code class="w"/>&#13;
<code class="o">|</code><code class="nt">___</code><code class="o">|</code><code class="w"/>&#13;
<code class="o">|</code><code class="w"> </code><code class="nt">2</code><code class="w"> </code><code class="o">|</code><code class="w"/>&#13;
<code class="o">|</code><code class="nt">___</code><code class="o">|</code><code class="w"/>&#13;
<code class="o">|</code><code class="w"> </code><code class="nt">1</code><code class="w"> </code><code class="o">|</code><code class="w"/>&#13;
<code class="o">|</code><code class="nt">___</code><code class="o">|</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the most recently added element is <code>3</code>, which is at the&#13;
top of the stack. The element <code>1</code>, which was added first, is at the bottom&#13;
of the stack.</p>&#13;
&#13;
<p>In this stack, the push operation adds an element to the top of the&#13;
stack. In code, this can be executed in JavaScript using an array and&#13;
the <code>push</code> method, like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="p">[];</code>&#13;
&#13;
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code> <code class="c1">// stack is now [1]</code>&#13;
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code> <code class="c1">// stack is now [1, 2]</code>&#13;
<code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code> <code class="c1">// stack is now [1, 2, 3]</code></pre>&#13;
&#13;
<p>The pop operation removes the top element from the stack. In code, this&#13;
can be executed in JavaScript using an array and the <code>pop</code> method, like&#13;
this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">stack</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">top</code> <code class="o">=</code> <code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">();</code> <code class="c1">// top is now 3, and stack is now [1, 2]</code></pre>&#13;
&#13;
<p>In this example, the <code>pop</code> method removes the top element (<code>3</code>) from the&#13;
stack and returns it. The stack array now contains the remaining&#13;
elements (<code>1</code> and <code>2</code>).</p>&#13;
&#13;
<p>React’s original reconciler was a stack-based algorithm that was used to&#13;
compare the old and new virtual trees and update the DOM accordingly.&#13;
While the stack reconciler worked well in simple cases, it presented a&#13;
number of challenges as applications grew in size and complexity.</p>&#13;
&#13;
<p>Let’s take a quick look at why this was the case. To do so, we’ll&#13;
consider an example where we’ve got a list of updates to make:</p>&#13;
<ol>&#13;
<li>&#13;
<p>A nonessential computationally expensive component consumes CPU and&#13;
&#13;
<span class="keep-together">renders.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>A user types into an <code>input</code> element.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Button</code> becomes enabled if the input is valid.</p>&#13;
</li>&#13;
<li>&#13;
<p>A containing <code>Form</code> component holds the state, so it rerenders.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p class="pagebreak-before">In code, we’d express this like so:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useReducer</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">initialState</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">text</code><code class="o">:</code><code class="w"> </code><code class="s2">""</code><code class="p">,</code><code class="w"> </code><code class="nx">isValid</code><code class="o">:</code><code class="w"> </code><code class="kc">false</code><code class="w"> </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">Form</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">dispatch</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useReducer</code><code class="p">(</code><code class="nx">reducer</code><code class="p">,</code><code class="w"> </code><code class="nx">initialState</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">handleChange</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">dispatch</code><code class="p">({</code><code class="w"> </code><code class="nx">type</code><code class="o">:</code><code class="w"> </code><code class="s2">"handleInput"</code><code class="p">,</code><code class="w"> </code><code class="nx">payload</code><code class="o">:</code><code class="w"> </code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="w"> </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">input</code> <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">text</code><code class="p">}</code> <code class="na">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">handleChange</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">Button</code> <code class="na">disabled</code><code class="o">=</code><code class="p">{</code><code class="o">!</code><code class="nx">state</code><code class="p">.</code><code class="nx">isValid</code><code class="p">}&gt;</code><code class="nx">Submit</code><code class="p">&lt;/</code><code class="nt">Button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">reducer</code><code class="p">(</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">action</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">switch</code><code class="w"> </code><code class="p">(</code><code class="nx">action</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="s2">"handleInput"</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">text</code><code class="o">:</code><code class="w"> </code><code class="nx">action</code><code class="p">.</code><code class="nx">payload</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">isValid</code><code class="o">:</code><code class="w"> </code><code class="nx">action</code><code class="p">.</code><code class="nx">payload</code><code class="p">.</code><code class="nx">length</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="mf">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">default</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">throw</code><code class="w"> </code><code class="ow">new</code><code class="w"> </code><code class="ne">Error</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this case, the <a data-primary="performance" data-secondary="stack reconciler issue" data-type="indexterm" id="id613"/>stack reconciler would render<a data-primary="rendering" data-secondary="stack reconciler’s disadvantage in" data-type="indexterm" id="id614"/> the updates sequentially&#13;
without being able to pause or defer work. If the computationally&#13;
expensive component blocks rendering, user input will appear on screen&#13;
with an observable lag. This leads to poor user experience, since the&#13;
text field would be unresponsive. Instead, it would be far more pleasant&#13;
to be able to recognize the user input as a higher-priority update than&#13;
rendering the nonessential expensive component, and update the screen to&#13;
reflect the input, deferring rendering the computationally expensive&#13;
component.</p>&#13;
&#13;
<p>There is a need to be able to bail out of current rendering work if&#13;
interrupted by higher-priority rendering work, like user input. To do&#13;
this, React needs to have a sense of priority for certain types of&#13;
rendering operations over others.</p>&#13;
&#13;
<p>The stack reconciler did not prioritize updates<a data-primary="prioritizing updates" data-type="indexterm" id="id615"/><a data-primary="prioritizing updates" data-secondary="synchronous rendering problem" data-type="indexterm" id="id616"/><a data-primary="synchronous rendering" data-secondary="problem with" data-type="indexterm" id="id617"/>, which meant that less&#13;
important updates could block more important updates. For example, a&#13;
low-priority update to a tooltip might block a high-priority update to a&#13;
text input. Updates to the virtual tree were executed in the order they&#13;
were received.</p>&#13;
&#13;
<p>In a React application, updates to the virtual tree can have different&#13;
levels of importance. For example, an update to a form input might be&#13;
more important than an update to an indicator showing the number of&#13;
likes on a post, because the user is directly interacting with the input&#13;
and expects it to be responsive.</p>&#13;
&#13;
<p>In the stack reconciler, updates were executed in the order they were&#13;
received, which meant that less important updates could block more&#13;
important updates. For example, if a like counter update was received&#13;
before a form input update, the like counter update would be executed&#13;
first and could block the form input update.</p>&#13;
&#13;
<p>If the like counter update takes a long time to execute (e.g., because&#13;
it’s performing an expensive computation), this could result in a&#13;
noticeable delay or jank in the user interface, especially if the user&#13;
is interacting with the application during the update.</p>&#13;
&#13;
<p>Another challenge with the stack reconciler was that it did not allow&#13;
updates to be interrupted or cancelled. What this means is that even if&#13;
the stack reconciler had a sense of update priority, there were no&#13;
guarantees that it could work well with various priorities by bailing&#13;
out of unimportant work when a high-priority update was &#13;
<span class="keep-together">scheduled.</span></p>&#13;
&#13;
<p>In any web application, not all updates are created equal: a random&#13;
unexpected notification appearing is not as important as responding to&#13;
my click on a button because the latter is a deliberate action that&#13;
warrants an immediate reaction, whereas the former isn’t even expected&#13;
and may not even be welcome.</p>&#13;
&#13;
<p>In the stack reconciler, updates could not be interrupted or cancelled,&#13;
which meant that unnecessary updates, like showing a toast, were&#13;
sometimes made at the expense of user interactions. This could result in&#13;
unnecessary work being performed on the virtual tree and the DOM, which&#13;
negatively impacted the performance of the &#13;
<span class="keep-together">application.</span></p>&#13;
&#13;
<p>The stack reconciler presented a number of challenges as applications&#13;
grew in size and complexity. The main challenges were centered around&#13;
jank and user interfaces being slow to respond. To address these&#13;
challenges, the React team developed a new reconciler called the Fiber&#13;
reconciler, which is based on a different data structure called a Fiber&#13;
tree. Let’s explore this data structure in the next section<a data-startref="ix_reconciliationstackreconcilerlegacy.04.203.29" data-type="indexterm" id="id618"/><a data-startref="ix_stackreconcilerinReactlegacy.04.203.29" data-type="indexterm" id="id619"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Fiber Reconciler" data-type="sect1"><div class="sect1" id="id48">&#13;
<h1>The Fiber Reconciler</h1>&#13;
&#13;
<p>The Fiber reconciler<a data-primary="Fiber reconciler" data-type="indexterm" id="ix_Fiberreconciler.04.374.21"/><a data-primary="reconciliation" data-secondary="Fiber reconciler" data-type="indexterm" id="ix_reconciliationFiberreconciler.04.374.21"/><a data-primary="concurrent rendering and updating" data-secondary="Fiber reconciler" data-type="indexterm" id="ix_concurrentrenderingandupdatingFiberreconciler.04.374.21"/> involves the use of a different data structure&#13;
called a “Fiber” that represents a single unit of work for the&#13;
reconciler. Fibers are created from React elements that we covered in&#13;
<a data-type="xref" href="ch03.html#ch03">Chapter 3</a>, with the key difference being that they are&#13;
stateful and long-lived, while React elements<a data-primary="elements" data-secondary="React elements versus Fibers" data-type="indexterm" id="id620"/> are ephemeral and&#13;
stateless.</p>&#13;
&#13;
<p>Mark Erikson<a data-primary="Erikson, Mark" data-type="indexterm" id="id621"/>, the maintainer of Redux and a prominent React expert, describes Fibers as “React’s internal data structure that represents&#13;
the actual component tree at a point in time.” Indeed, this is a good&#13;
way to think about Fibers, and it’s on-brand for Mark who, at the time&#13;
of writing, works on time-travel debugging React apps full time with&#13;
Replay<a data-primary="Replay debugging tool" data-type="indexterm" id="id622"/><a data-primary="debugging" data-secondary="Replay tool" data-type="indexterm" id="id623"/>: a tool that allows you to rewind and replay your app’s state for&#13;
debugging. If you haven’t already, check out <a class="orm:hideurl" href="https://www.replay.io">Replay.io</a> for more&#13;
information.</p>&#13;
&#13;
<p>Similar to how the vDOM is a tree of elements, React uses a Fiber tree&#13;
in reconciliation which, as the name suggests, is a tree<a data-primary="tree structure, Fiber" data-type="indexterm" id="id624"/> of Fibers that&#13;
is directly modeled after the vDOM.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fiber as a Data Structure" data-type="sect2"><div class="sect2" id="id49">&#13;
<h2>Fiber as a Data Structure</h2>&#13;
&#13;
<p>The Fiber data structure<a data-primary="data structure, Fiber as" data-type="indexterm" id="ix_datastructureFiberas.04.395.25"/> in React is a key component of the Fiber&#13;
reconciler. The Fiber reconciler allows updates to be prioritized<a data-primary="prioritizing updates" data-secondary="Fiber reconciler’s role in" data-type="indexterm" id="id625"/> and&#13;
executed concurrently, which improves the performance and responsiveness&#13;
of React applications. Let’s explore the Fiber data structure in more&#13;
detail.</p>&#13;
&#13;
<p>At its core, the Fiber data structure is a representation of a component&#13;
instance and its state in a React application. As discussed, the Fiber&#13;
data structure is designed to be a mutable instance and can be updated&#13;
and rearranged as needed during the reconciliation process.</p>&#13;
&#13;
<p>Each instance of a Fiber node contains information about the component&#13;
it represents, including its props, state, and child components. The&#13;
Fiber node also contains information about its position in the component&#13;
tree, as well as metadata that is used by the Fiber reconciler to&#13;
prioritize and execute updates.</p>&#13;
&#13;
<p>Here’s an example of a simple Fiber node:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nx">tag</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="c1">// 3 = ClassComponent</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="nx">App</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">ref</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Tejas"</code><code class="p">,</code>&#13;
    <code class="nx">age</code><code class="o">:</code> <code class="mi">30</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">stateNode</code><code class="o">:</code> <code class="nx">AppInstance</code><code class="p">,</code>&#13;
  <code class="k">return</code><code class="o">:</code> <code class="nx">FiberParent</code><code class="p">,</code>&#13;
  <code class="nx">child</code><code class="o">:</code> <code class="nx">FiberChild</code><code class="p">,</code>&#13;
  <code class="nx">sibling</code><code class="o">:</code> <code class="nx">FiberSibling</code><code class="p">,</code>&#13;
  <code class="nx">index</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, we have a Fiber node that represents a <code>ClassComponent</code>&#13;
called <code>App</code>. The Fiber node contains information about the component’s:</p>&#13;
<dl>&#13;
<dt><code>tag</code></dt>&#13;
<dd>&#13;
<p>In this case it’s <code>3</code>, which React uses to identify class&#13;
components. Each type of component (class components, function&#13;
components, Suspense and error boundaries, fragments, etc.) has its&#13;
own numerical ID as Fibers.</p>&#13;
</dd>&#13;
<dt><code>type</code></dt>&#13;
<dd>&#13;
<p><code>App</code> refers to the function or class component that this Fiber&#13;
represents.</p>&#13;
</dd>&#13;
<dt><code>props</code></dt>&#13;
<dd>&#13;
<p>(<code>{name: "Tejas", age: 30}</code>) represent the input props to the&#13;
component, or input arguments to the function.</p>&#13;
</dd>&#13;
<dt><code>stateNode</code></dt>&#13;
<dd>&#13;
<p>The instance of the <code>App</code> component that this&#13;
Fiber represents.</p>&#13;
&#13;
<p>Its position in the component tree: <code>return</code>, <code>child</code>, <code>sibling</code>,&#13;
and <code>index</code> each give the Fiber reconciler a way to “walk the tree,”&#13;
identifying parents, children, siblings, and the Fiber’s index.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Fiber reconciliation involves comparing the current Fiber tree with the&#13;
next Fiber tree and figuring out which nodes need to be updated, added,&#13;
or removed.</p>&#13;
&#13;
<p>During the reconciliation process, the Fiber reconciler creates a Fiber&#13;
node for each React element in the virtual DOM. There is a&#13;
function called <code>createFiberFrom​Ty⁠peAndProps</code> that does this. Of course,&#13;
another way of saying “type and props” is by calling them React&#13;
elements. As we recall, a React element is this: type and props:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s2">"div"</code><code class="p">,</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">className</code><code class="o">:</code> <code class="s2">"container"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This function returns a Fiber derived from elements. Once the Fiber&#13;
nodes have been created, the Fiber reconciler<a data-primary="work loop, in Fiber reconciliation" data-type="indexterm" id="id626"/> uses a <em>work loop</em> to&#13;
update the user interface. The work loop starts at the root Fiber node&#13;
and works its way down the component tree, marking each Fiber node as&#13;
“dirty” if it needs to be updated. Once it reaches the end, it walks&#13;
back up, creating a new DOM tree in memory, detached from the browser,&#13;
that will eventually be committed (flushed) to the screen. This is&#13;
represented by two functions: <code>beginWork</code> walks downward, marking&#13;
components as “need to update,” and &#13;
<span class="keep-together"><code>completeWork</code></span> walks back&#13;
up, constructing a tree of real DOM elements detached from the browser.&#13;
This off-screen rendering process can be interrupted and thrown away at&#13;
any time, since the user doesn’t see it.</p>&#13;
&#13;
<p>The Fiber architecture takes inspiration from a concept called “double&#13;
buffering” in the game world, where the next screen is prepared&#13;
offscreen and then “flushed” to the current screen. To better grasp&#13;
the Fiber architecture, let’s understand this concept in a little more&#13;
detail before we move further<a data-startref="ix_datastructureFiberas.04.395.25" data-type="indexterm" id="id627"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Double Buffering" data-type="sect2"><div class="sect2" id="id50">&#13;
<h2>Double Buffering</h2>&#13;
&#13;
<p>Double buffering<a data-primary="double buffering, Fiber reconciler" data-type="indexterm" id="id628"/> is a technique used in computer graphics and video&#13;
processing to reduce flicker and improve perceived performance. The&#13;
technique involves creating two buffers (or memory spaces) for storing&#13;
images or frames, and switching between them at regular intervals to&#13;
display the final image or video.</p>&#13;
&#13;
<p>Here’s how double buffering works in practice:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The first buffer is filled with the initial image or frame.</p>&#13;
</li>&#13;
<li>&#13;
<p>While the first buffer is being displayed, the second buffer is&#13;
updated with new data or images.</p>&#13;
</li>&#13;
<li>&#13;
<p>When the second buffer is ready, it is switched with the first buffer&#13;
and displayed on the screen.</p>&#13;
</li>&#13;
<li>&#13;
<p>The process continues, with the first and second buffers being&#13;
switched at regular intervals to display the final image or video.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>By using double buffering, flicker and other visual artifacts can be&#13;
reduced, since the final image or video is displayed without&#13;
interruptions or delays.</p>&#13;
&#13;
<p>Fiber reconciliation<a data-primary="tree structure, Fiber" data-type="indexterm" id="id629"/> is similar to double buffering such that when&#13;
updates happen, the current Fiber tree is forked and updated to reflect&#13;
the new state of a given user interface. This is <a data-primary="rendering" data-secondary="Fiber reconciliation" data-type="indexterm" id="id630"/>called <em>rendering</em>.&#13;
Then, when the alternate tree is ready and accurately reflects the state&#13;
a user expects to see, it is swapped with the current tree similarly to&#13;
how video buffers are swapped in double buffering. <a data-primary="commit phase" data-secondary="reconciliation" data-type="indexterm" id="id631"/><a data-primary="commit, in reconciliation" data-type="indexterm" id="id632"/>This is called the&#13;
<em>commit phase</em> of reconciliation or a <em>commit</em>.</p>&#13;
&#13;
<p>By using a work-in-progress tree, the Fiber reconciler presents a number&#13;
of benefits:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It can avoid making unnecessary updates to the real DOM, which can&#13;
improve performance and reduce flicker.</p>&#13;
</li>&#13;
<li>&#13;
<p>It can compute the new state of a UI off-screen, and throw it away if&#13;
a newer higher-priority update needs to happen.</p>&#13;
</li>&#13;
<li>&#13;
<p>Since reconciliation happens off-screen, it can even pause and resume&#13;
without messing up what the user currently sees.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With the Fiber reconciler, two trees are derived from a user-defined&#13;
tree of JSX &#13;
<span class="keep-together">elements:</span> one tree containing “current” Fibers, and&#13;
another tree containing work-in-progress Fibers. Let’s explore these&#13;
trees a little more.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fiber Reconciliation" data-type="sect2"><div class="sect2" id="id230">&#13;
<h2>Fiber Reconciliation</h2>&#13;
&#13;
<p>Fiber reconciliation happens in two phases: the render phase and the commit phase. This two-phase approach, shown in <a data-type="xref" href="#figure4-1">Figure 4-1</a>, allows React to do rendering work that can be disposed of at any time before committing it to the DOM and showing a new state to users: it makes rendering interruptible. To be a little bit&#13;
more detailed, what makes rendering feel interruptible are the heuristics&#13;
employed by the React scheduler of yielding the execution back to the&#13;
main thread every 5 ms, which is smaller than a single frame even on&#13;
120 fps devices.</p>&#13;
&#13;
<figure><div class="figure" id="figure4-1">&#13;
<img alt="Reconciliation Flow in the Fiber Reconciler" src="assets/frea_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Reconciliation flow in the Fiber reconciler</h6>&#13;
</div></figure>&#13;
&#13;
<p>We’ll dive more into the details around the scheduler in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a> as we&#13;
explore React’s concurrent features. For now, though, let’s walk through&#13;
these phases of &#13;
<span class="keep-together">reconciliation.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The render phase" data-type="sect3"><div class="sect3" id="id51">&#13;
<h3>The render phase</h3>&#13;
&#13;
<p>The <em>render phase</em> starts<a data-primary="render phase, Fiber reconciliation" data-type="indexterm" id="ix_renderphaseFiberreconciliation.04.560.26"/><a data-primary="rendering" data-secondary="Fiber reconciliation" data-type="indexterm" id="ix_renderingFiberreconciliation.04.560.26"/> when a state-change event occurs in the&#13;
<code>current</code> tree. React does the work of making the changes <em>off-screen</em>&#13;
in the <code>alternate</code> tree by recursively stepping through each Fiber and&#13;
setting flags that signal updates are pending (see <a data-type="xref" href="#figure4-2">Figure 4-2</a>). As we alluded to earlier,&#13;
this happens in a function called <code>beginWork</code> internally in React.</p>&#13;
&#13;
<figure><div class="figure" id="figure4-2">&#13;
<img alt="Call order of the Render Phase" src="assets/frea_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Call order of the render phase</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="beginWork" data-type="sect4"><div class="sect4" id="id52">&#13;
<h4>beginWork</h4>&#13;
&#13;
<p><code>beginWork</code> is <a data-primary="beginWork function" data-type="indexterm" id="ix_beginWorkfunction.04.572.16"/>responsible for setting flags on Fiber nodes in the work-in-progress tree about whether or not they should update. It sets a&#13;
bunch of flags and then recursively goes to the next Fiber node, doing&#13;
the same thing until it reaches the bottom of the tree. When it&#13;
finishes, we start calling <code>completeWork</code> on the Fiber nodes and walk&#13;
back up.</p>&#13;
&#13;
<p>The signature of <code>beginWork</code> is as follows:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">beginWork</code><code class="p">(</code>&#13;
  <code class="nx">current</code><code class="o">:</code> <code class="nx">Fiber</code> <code class="o">|</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">workInProgress</code><code class="o">:</code> <code class="nx">Fiber</code><code class="p">,</code>&#13;
  <code class="nx">renderLanes</code><code class="o">:</code> <code class="nx">Lanes</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">Fiber</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code></pre>&#13;
&#13;
<p>More on <code>completeWork</code> later. For now, let’s dive into <code>beginWork</code>. Its&#13;
signature includes the following arguments:</p>&#13;
<dl>&#13;
<dt><code>current</code></dt>&#13;
<dd>&#13;
<p>A reference<a data-primary="current argument" data-type="indexterm" id="id633"/> to the Fiber node in the current tree that&#13;
corresponds to the work-in-progress node being updated. This is used to&#13;
determine what has changed between the previous version and the new&#13;
version of the tree, and what needs to be updated. This is <em>never</em>&#13;
mutated and is only used for comparison.</p>&#13;
</dd>&#13;
<dt><code>workInProgress</code></dt>&#13;
<dd>&#13;
<p>The Fiber node being updated in the work-in-progress<a data-primary="workInProgress" data-type="indexterm" id="id634"/>&#13;
tree. This is the node that will be marked as “dirty” if updated and&#13;
returned by the function.</p>&#13;
</dd>&#13;
<dt><code>renderLanes</code></dt>&#13;
<dd>&#13;
<p>Render lanes<a data-primary="renderLanes" data-type="indexterm" id="id635"/> is a new concept in React’s Fiber&#13;
reconciler that replaces the <a data-primary="renderExpirationTime (deprecated)" data-type="indexterm" id="id636"/>older <code>renderExpirationTime</code>. It’s a bit&#13;
more complex than the old <code>renderExpirationTime</code> concept, but it allows&#13;
React to better prioritize updates and make the update process more&#13;
efficient. Since <code>renderExpirationTime</code> is deprecated, we’ll focus on&#13;
<code>renderLanes</code> in this chapter.</p>&#13;
&#13;
<p>It is essentially a bitmask that represents “lanes” in which an update&#13;
is being processed. Lanes are a way of categorizing updates based on&#13;
their priority and other factors. When a change is made to a React&#13;
component, it is assigned a lane based on its priority and other&#13;
characteristics. The higher the priority of the change, the higher the&#13;
lane it is assigned to.</p>&#13;
&#13;
<p>The <code>renderLanes</code> value is passed to the <code>beginWork</code> function in order&#13;
to ensure that updates are processed in the correct order. Updates that&#13;
are assigned to higher-priority<a data-primary="prioritizing updates" data-secondary="render lanes’ role in" data-type="indexterm" id="id637"/> lanes are processed before updates that&#13;
are assigned to lower-priority lanes. This ensures that high-priority&#13;
updates, such as updates that affect user interaction or accessibility,&#13;
are processed as quickly as possible.</p>&#13;
&#13;
<p>In addition to prioritizing updates, <code>renderLanes</code> also helps React&#13;
better manage concurrency<a data-primary="concurrent rendering and updating" data-secondary="managing in React" data-type="indexterm" id="id638"/>. React uses a technique <a data-primary="time slicing" data-type="indexterm" id="id639"/>called “time&#13;
slicing” to break up long-running updates into smaller, more manageable&#13;
chunks. <code>renderLanes</code> plays a key role in this process, as it allows&#13;
React to determine which updates should be processed first, and which&#13;
updates can be deferred until later.</p>&#13;
&#13;
<p>After the render phase is complete, the&#13;
<code>getLanesToRetrySynchronouslyOnError</code> function<a data-primary="getLanesToRetrySynchronouslyOnError function" data-type="indexterm" id="id640"/> is called to determine if&#13;
any deferred updates were created during the render phase. If there are&#13;
deferred updates, the <code>updateComponent</code> function starts a new work loop&#13;
to handle them, using <code>beginWork</code> and <code>getNextLanes</code> to process the&#13;
updates and prioritize them based on their lanes.</p>&#13;
&#13;
<p>We dive much deeper into render lanes in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>, the upcoming chapter&#13;
on concurrency. For now, let’s continue following the Fiber&#13;
reconciliation flow<a data-startref="ix_beginWorkfunction.04.572.16" data-type="indexterm" id="id641"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="completeWork" data-type="sect4"><div class="sect4" id="id53">&#13;
<h4>completeWork</h4>&#13;
&#13;
<p>The <code>completeWork</code> function applies updates to the work-in-progress&#13;
Fiber node and constructs a new real DOM tree that represents the&#13;
updated state of the application. It constructs this tree detached from&#13;
the DOM out of the plane of browser visibility.</p>&#13;
&#13;
<p>If the host environment is a browser, this means doing things like&#13;
<code>document.​crea⁠teElement</code> or <code>newElement.appendChild</code>. Keep in mind, this&#13;
tree of elements<a data-primary="tree of React elements" data-secondary="in reconciliation" data-secondary-sortas="reconciliation" data-type="indexterm" id="id642"/> is not yet attached to the in-browser document: React&#13;
is just creating the next version of the UI off-screen. Doing this work&#13;
off-screen makes it interruptible<a data-primary="interruptibility during updates, Fiber reconciler" data-type="indexterm" id="id643"/>: whatever next state React is&#13;
computing is not yet painted to the screen, so it can be thrown away in&#13;
case some higher-priority update gets scheduled. This is the whole point&#13;
of the Fiber &#13;
<span class="keep-together">reconciler.</span></p>&#13;
&#13;
<p>The signature of <code>completeWork</code> is as follows:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">completeWork</code><code class="p">(</code>&#13;
  <code class="nx">current</code><code class="o">:</code> <code class="nx">Fiber</code> <code class="o">|</code> <code class="kc">null</code><code class="p">,</code>&#13;
  <code class="nx">workInProgress</code><code class="o">:</code> <code class="nx">Fiber</code><code class="p">,</code>&#13;
  <code class="nx">renderLanes</code><code class="o">:</code> <code class="nx">Lanes</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">Fiber</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code></pre>&#13;
&#13;
<p>Here, the signature is the same signature as <code>beginWork</code>.</p>&#13;
&#13;
<p>The <code>completeWork</code> function is closely related to the <code>beginWork</code>&#13;
function. While <code>beginWork</code> is responsible for setting flags about&#13;
“should update” state on a Fiber node, &#13;
<span class="keep-together"><code>completeWork</code></span> is responsible&#13;
for constructing a new tree to be committed to the host environment.&#13;
When <code>completeWork</code> reaches the top and has constructed the new DOM&#13;
tree, we say that “the render phase is completed.” Now, React moves on to the&#13;
commit phase<a data-startref="ix_renderphaseFiberreconciliation.04.560.26" data-type="indexterm" id="id644"/><a data-startref="ix_renderingFiberreconciliation.04.560.26" data-type="indexterm" id="id645"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The commit phase" data-type="sect3"><div class="sect3" id="id177">&#13;
<h3>The commit phase</h3>&#13;
&#13;
<p>The <em>commit phase</em> (see <a data-type="xref" href="#figure4-3">Figure 4-3</a>) is <a data-primary="commit phase" data-secondary="reconciliation" data-type="indexterm" id="ix_commitphasereconciliation.04.683.43"/>responsible for updating the actual DOM with the&#13;
changes that were made to the virtual DOM during the render phase.&#13;
During the commit phase, the new virtual DOM tree is committed to the&#13;
host environment, and the work-in-progress tree is replaced with the&#13;
current tree. It’s in this phase that all effects are also run. The&#13;
commit phase is divided into two parts: the mutation phase and the&#13;
layout phase.</p>&#13;
&#13;
<figure><div class="figure" id="figure4-3">&#13;
<img alt="The Commit Phase with FiberRootNode" src="assets/frea_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>The commit phase with <code>FiberRootNode</code></h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The mutation phase" data-type="sect4"><div class="sect4" id="id54">&#13;
<h4>The mutation phase</h4>&#13;
&#13;
<p>The mutation phase<a data-primary="mutating data" data-type="indexterm" id="id646"/> is the first part of the commit phase, and it is&#13;
responsible for updating the actual DOM with the changes that were made&#13;
to the virtual DOM. During this phase, React identifies updates that&#13;
need to be made and calls a special function<a data-primary="commitMutationEffects function" data-type="indexterm" id="id647"/> called&#13;
<code>commitMutationEffects</code>. This function applies the updates that were&#13;
made to Fiber nodes in the alternate tree during the render phase to the&#13;
actual DOM.</p>&#13;
&#13;
<p>Here’s an full-pseudocode example of how <code>commitMutationEffects</code> might&#13;
be &#13;
<span class="keep-together">implemented:</span></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">commitMutationEffects</code><code class="p">(</code><code class="nx">Fiber</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">Fiber</code><code class="p">.</code><code class="nx">tag</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="nx">HostComponent</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="c1">// Update DOM node with new props and/or children</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">case</code> <code class="nx">HostText</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="c1">// Update text content of DOM node</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">case</code> <code class="nx">ClassComponent</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="c1">// Call lifecycle methods like componentDidMount and componentDidUpdate</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="c1">// ... other cases for different types of nodes</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>During the mutation phase, React also calls other special functions,&#13;
such as <code>commit​Un⁠mount</code> and <code>commitDeletion</code>, to remove nodes from the&#13;
DOM that are no longer needed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The layout phase" data-type="sect4"><div class="sect4" id="id55">&#13;
<h4>The layout phase</h4>&#13;
&#13;
<p>The layout phase<a data-primary="layout phase of reconciliation" data-type="indexterm" id="id648"/> is the second part of the commit phase, and it is&#13;
responsible for calculating the new layout of the updated nodes in the&#13;
DOM. During this phase, React calls a special function<a data-primary="commitLayoutEffects function" data-type="indexterm" id="id649"/> called&#13;
<code>commitLayoutEffects</code>. This function calculates the new layout of the&#13;
updated nodes in the DOM.</p>&#13;
&#13;
<p>Like <code>commitMutationEffects</code>, <code>commitLayoutEffects</code> is also a massive&#13;
switch statement that calls different functions, depending on the type of&#13;
node being updated.</p>&#13;
&#13;
<p>Once the layout phase is complete, React has successfully updated the&#13;
actual DOM to reflect the changes that were made to the virtual DOM&#13;
during the render phase.</p>&#13;
&#13;
<p>By dividing the commit phase into two parts (mutation and layout), React&#13;
is able to apply updates to the DOM in an efficient manner. By working&#13;
in concert with other key functions in the reconciler, the commit phase&#13;
helps to ensure that React applications are fast, responsive, and&#13;
reliable, even as they become more complex and handle larger amounts of&#13;
data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Effects" data-type="sect4"><div class="sect4" id="id56">&#13;
<h4>Effects</h4>&#13;
&#13;
<p>During the commit phase of React’s reconciliation process, side effects<a data-primary="side effects, in reconciliation" data-type="indexterm" id="id650"/>&#13;
are performed in a specific order, depending on the type of effect.&#13;
There are several types of effects that can occur during the commit&#13;
phase, including:</p>&#13;
<dl>&#13;
<dt>Placement effects</dt>&#13;
<dd>&#13;
<p>These effects<a data-primary="placement effects, in reconciliation" data-type="indexterm" id="id651"/> occur when a new component is added&#13;
to the DOM. For example, if a new button is added to a form, a placement&#13;
effect will occur to add the button to the DOM.</p>&#13;
</dd>&#13;
<dt>Update effects</dt>&#13;
<dd>&#13;
<p>These effects<a data-primary="update effects, in reconciliation" data-type="indexterm" id="id652"/> occur when a component is updated with&#13;
new props or state. For example, if the text of a button changes, an&#13;
update effect will occur to update the text in the DOM.</p>&#13;
</dd>&#13;
<dt>Deletion effects</dt>&#13;
<dd>&#13;
<p>These effects<a data-primary="deletion effects, in reconciliation" data-type="indexterm" id="id653"/> occur when a component is removed&#13;
from the DOM. For example, if a button is removed from a form, a&#13;
deletion effect will occur to remove the button from the DOM.</p>&#13;
</dd>&#13;
<dt>Layout effects</dt>&#13;
<dd>&#13;
<p>These effects<a data-primary="layout effects, in reconciliation" data-type="indexterm" id="id654"/> occur before the browser has a chance&#13;
to paint, and are used to update the layout of the page. Layout effects&#13;
are managed using the <code>useLayoutEffect</code> hook in function components and&#13;
the <code>componentDidUpdate</code> lifecycle method in class components.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In contrast to these commit-phase effects, passive effects<a data-primary="passive effects, in reconciliation" data-type="indexterm" id="id655"/> are&#13;
user-defined effects that are scheduled to run after the browser has had&#13;
a chance to paint. Passive effects are managed<a data-primary="useEffect hook" data-type="indexterm" id="id656"/> using the <code>useEffect</code>&#13;
hook.</p>&#13;
&#13;
<p>Passive effects are useful for performing actions that are not critical&#13;
to the initial rendering of the page, such as fetching data from an API&#13;
or performing analytics tracking. Because passive effects are not&#13;
performed during the render phase, they do not affect the time required&#13;
to compute a minimal set of updates required to bring a user interface&#13;
into the developer’s desired state<a data-startref="ix_commitphasereconciliation.04.683.43" data-type="indexterm" id="id657"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Putting everything on the screen" data-type="sect3"><div class="sect3" id="id57">&#13;
<h3>Putting everything on the screen</h3>&#13;
&#13;
<p>React maintains<a data-primary="FiberRootNode" data-type="indexterm" id="id658"/><a data-primary="root, React" data-secondary="FiberRootNode" data-type="indexterm" id="id659"/> a <code>FiberRootNode</code> atop both trees that points to one of&#13;
the two trees: the <code>current</code> or the <code>workInProgress</code> tree. The&#13;
<code>FiberRootNode</code> is a key data structure that is responsible for managing&#13;
the commit phase of the reconciliation process.</p>&#13;
&#13;
<p>When updates are made to the virtual DOM, React updates the&#13;
<code>workInProgress</code> tree<a data-primary="workInProgress" data-type="indexterm" id="id660"/><a data-primary="current argument" data-type="indexterm" id="id661"/>, while leaving the current tree unchanged. This&#13;
allows React to continue rendering and updating the virtual DOM, while&#13;
also preserving the current state of the &#13;
<span class="keep-together">application.</span></p>&#13;
&#13;
<p>When the rendering process is complete, React calls a function<a data-primary="commitRoot function" data-type="indexterm" id="id662"/> called&#13;
<code>commitRoot</code>, which is responsible for committing the changes made to&#13;
the <code>workInProgress</code> tree to the actual DOM. <code>commitRoot</code> switches the&#13;
pointer of the <code>FiberRootNode</code> from the current tree to the&#13;
<code>workInProgress</code> tree, making the <code>workInProgress</code> tree the new current&#13;
tree.</p>&#13;
&#13;
<p>From this point on, any future updates are based on the new current&#13;
tree. This process ensures that the application remains in a consistent&#13;
state, and that updates are applied correctly and efficiently<a data-startref="ix_reconciliation.04.10.61" data-type="indexterm" id="id663"/><a data-startref="ix_virtualDOMvDOMreconciliationprocess.04.10.61" data-type="indexterm" id="id664"/><a data-startref="ix_DocumentObjectModelDOMreconciliationprocessfromvDOM.04.10.61" data-type="indexterm" id="id665"/><a data-startref="ix_Fiberreconciler.04.374.21" data-type="indexterm" id="id666"/><a data-startref="ix_reconciliationFiberreconciler.04.374.21" data-type="indexterm" id="id667"/><a data-startref="ix_concurrentrenderingandupdatingFiberreconciler.04.374.21" data-type="indexterm" id="id668"/>.</p>&#13;
&#13;
<p>All of this appears to happen instantly in the browser. This is the&#13;
work of &#13;
<span class="keep-together">reconciliation.</span></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chapter Review" data-type="sect1"><div class="sect1" id="id231">&#13;
<h1>Chapter Review</h1>&#13;
&#13;
<p>In this chapter, we explored the concept of React reconciliation and&#13;
learned about the Fiber reconciler. We also learned about Fibers, which&#13;
enable efficient and interruptible rendering in concert with a powerful&#13;
scheduler. We also learned about the render phase and the commit phase,&#13;
which are the two main phases of the reconciliation process. Finally, we&#13;
learned about the <code>FiberRootNode</code>: a key data structure responsible for&#13;
managing the commit phase of the reconciliation process.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect1"><div class="sect1" id="id232">&#13;
<h1>Review Questions</h1>&#13;
&#13;
<p>Let’s ask ourselves a few questions to test our understanding of the&#13;
concepts in this chapter:</p>&#13;
<ol>&#13;
<li>&#13;
<p>What is React reconciliation?</p>&#13;
</li>&#13;
<li>&#13;
<p>What’s the role of the Fiber data structure?</p>&#13;
</li>&#13;
<li>&#13;
<p>Why do we need two trees?</p>&#13;
</li>&#13;
<li>&#13;
<p>What happens when an application updates?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>If we can answer these questions, we should be well on our way to&#13;
understanding the Fiber reconciler and the reconciliation process in&#13;
React.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up Next" data-type="sect1"><div class="sect1" id="id233">&#13;
<h1>Up Next</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, we’ll look at common questions in React and explore&#13;
some advanced patterns. We’ll answer questions around how often to use <code>useMemo</code> and when to use <code>React.lazy</code>. We’ll also explore how to use&#13;
<code>useReducer</code> and <code>useContext</code> to manage state in React applications.</p>&#13;
&#13;
<p>See you there!</p>&#13;
</div></section>&#13;
</div></section></body></html>