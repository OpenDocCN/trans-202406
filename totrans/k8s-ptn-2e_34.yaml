- en: Chapter 27\. Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A controller actively monitors and maintains a set of Kubernetes resources in
    a desired state. The heart of Kubernetes itself consists of a fleet of controllers
    that regularly watch and reconcile the current state of applications with the
    declared target state. In this chapter, we see how to leverage this *Controller*
    pattern to extend the platform for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve already seen that Kubernetes is a sophisticated and comprehensive platform
    that provides many features out of the box. However, it is a general-purpose orchestration
    platform that does not cover all application use cases. Luckily, it provides natural
    extension points where specific use cases can be implemented elegantly on top
    of proven Kubernetes building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The main questions that arise here are how to extend Kubernetes without changing
    and breaking it and how to use its capabilities for custom use cases.
  prefs: []
  type: TYPE_NORMAL
- en: By design, Kubernetes is based on a declarative resource-centric API. What exactly
    do we mean by *declarative*? As opposed to an *imperative* approach, a declarative
    approach does not tell Kubernetes how it should act but instead describes how
    the target state should look. For example, when we scale up a Deployment, we do
    not actively create new Pods by telling Kubernetes to “create a new Pod.” Instead,
    we change the Deployment resource’s `replicas` property via the Kubernetes API
    to the desired number.
  prefs: []
  type: TYPE_NORMAL
- en: So, how are the new Pods created? This is done internally by the controllers.
    For every change in the resource status (like changing the `replicas` property
    value of a Deployment), Kubernetes creates an event and broadcasts it to all interested
    listeners. These listeners can then react by modifying, deleting, or creating
    new resources, which in turn creates other events, like Pod-created events. These
    events are then potentially picked up again by other controllers, which perform
    their specific actions.
  prefs: []
  type: TYPE_NORMAL
- en: The whole process is also known as *state reconciliation*, where a target state
    (the number of desired replicas) differs from the current state (the actual running
    instances), and it is the task of a controller to reconcile and reach the desired
    target state again. When looked at from this angle, Kubernetes essentially represents
    a distributed state manager. You give it the desired state for a component instance,
    and it attempts to maintain that state should anything change.
  prefs: []
  type: TYPE_NORMAL
- en: How can we now hook into this reconciliation process without modifying Kubernetes
    code and create a controller customized for our specific needs?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes comes with a collection of built-in controllers that manage standard
    Kubernetes resources like ReplicaSets, DaemonSets, StatefulSets, Deployments,
    or Services. These controllers run as part of the controller manager, which is
    deployed (as a standalone process or a Pod) on the control plane node. These controllers
    are not aware of one another. They run in an endless reconciliation loop, to monitor
    their resources for the actual and desired state and to act accordingly to get
    the actual state closer to the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in addition to these out-of-the-box controllers, the Kubernetes event-driven
    architecture allows us to natively plug in other custom controllers. Custom controllers
    can add extra functionality to the behavior by reacting to state-changing events,
    the same way that internal controllers do. A common characteristic of controllers
    is that they are reactive and react to events in the system to perform their specific
    actions. At a high level, this reconciliation process consists of the following
    main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Observe
  prefs: []
  type: TYPE_NORMAL
- en: Discover the actual state by watching for events issued by Kubernetes when an
    observed resource changes.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze
  prefs: []
  type: TYPE_NORMAL
- en: Determine the differences from the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Act
  prefs: []
  type: TYPE_NORMAL
- en: Perform operations to drive the actual state to the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the ReplicaSet controller watches for ReplicaSet resource changes,
    analyzes how many Pods need to be running, and acts by submitting Pod definitions
    to the API Server. The Kubernetes backend is then responsible for starting up
    the requested Pod on a node.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 27-1](#img-controller-controller) shows how a controller registers
    itself as an event listener for detecting changes on the managed resources. It
    observes the current state and changes it by calling out to the API Server to
    get closer to the target state (if necessary).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observe-Analyse-Act cycle](assets/kup2_2701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 27-1\. Observe-Analyze-Act cycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Controllers are part of the Kubernetes control plane, and it became clear early
    on that they would also allow you to extend the platform with custom behavior.
    Moreover, they have become the standard mechanism for extending the platform and
    enable complex application lifecycle management. And as a result, a new generation
    of more sophisticated controllers was born, called *Operators*. From an evolutionary
    and complexity point of view, we can classify the active reconciliation components
    into two groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Controllers*'
  prefs: []
  type: TYPE_NORMAL
- en: A simple reconciliation process that monitors and acts on standard Kubernetes
    resources. More often, these controllers enhance platform behavior and add new
    platform features.
  prefs: []
  type: TYPE_NORMAL
- en: '*Operators*'
  prefs: []
  type: TYPE_NORMAL
- en: A sophisticated reconciliation process that interacts with CustomResourceDefinitions
    (CRDs), which are at the heart of the *Operator* pattern. Typically, these operators
    encapsulate complex application domain logic and manage the full application lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, these classifications help introduce new concepts gradually.
    Here, we focus on the simpler controllers, and in [Chapter 28](ch28.html#Operator),
    we introduce CRDs and build up to the *Operator* pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having multiple controllers acting on the same resources simultaneously,
    controllers use the *Singleton Service* pattern explained in [Chapter 10](ch10.html#SingletonService).
    Most controllers are deployed just as Deployments but with one replica, as Kubernetes
    uses optimistic locking at the resource level to prevent concurrency issues when
    changing resource objects. In the end, a controller is nothing more than an application
    that runs permanently in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Because Kubernetes itself is written in Go, and a complete client library for
    accessing Kubernetes is also written in Go, many controllers are written in Go
    too. However, you can write controllers in any programming language by sending
    requests to the Kubernetes API Server. We see a controller written in a pure shell
    script later in [Example 27-1](#ex-controller-config-map).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward kind of controllers extend the way Kubernetes manages
    its resources. They operate on the same standard resources and perform similar
    tasks as the Kubernetes internal controllers operating on the standard Kubernetes
    resources, but they are invisible to the user of the cluster. Controllers evaluate
    resource definitions and conditionally perform some actions. Although they can
    monitor and act upon any field in the resource definition, metadata and ConfigMaps
    are most suitable for this purpose. The following are a few considerations to
    keep in mind when choosing where to store controller data:'
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs: []
  type: TYPE_NORMAL
- en: Labels as part of a resource’s metadata can be watched by any controller. They
    are indexed in the backend database and can be efficiently searched for in queries.
    We should use labels when a selector-like functionality is required (e.g., to
    match Pods of a Service or a Deployment). A limitation of labels is that only
    alphanumeric names and values with restrictions can be used. See the Kubernetes
    documentation for which syntax and character sets are allowed for labels.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs: []
  type: TYPE_NORMAL
- en: Annotations are an excellent alternative to labels. They have to be used instead
    of labels if the values do not conform to the syntax restrictions of label values.
    Annotations are not indexed, so we use annotations for nonidentifying information
    not used as keys in controller queries. Preferring annotations over labels for
    arbitrary metadata also has the advantage that it does not negatively impact the
    internal Kubernetes performance.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes controllers need additional information that does not fit well into
    labels or annotations. In this case, ConfigMaps can be used to hold the target
    state definition. These ConfigMaps are then watched and read by the controllers.
    However, CRDs are much better suited for designing the custom target state specification
    and are recommended over plain ConfigMaps. For registering CRDs, however, you
    need elevated cluster-level permissions. If you don’t have these, ConfigMaps are
    still the best alternative to CRDs. We will explain CRDs in detail in [Chapter 28,
    “Operator”](ch28.html#Operator).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few reasonably simple example controllers you can study as a sample
    implementation of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: jenkins-x/exposecontroller
  prefs: []
  type: TYPE_NORMAL
- en: '[This controller](https://oreil.ly/URMaE) watches Service definitions, and
    if it detects an annotation named `expose` in the metadata, the controller automatically
    exposes an Ingress object for external access of the Service. It also removes
    the Ingress object when someone removes the Service. This project is now archived
    but still serves as a good example of implementing a simple controller.'
  prefs: []
  type: TYPE_NORMAL
- en: stakater/Reloader
  prefs: []
  type: TYPE_NORMAL
- en: This is [a controller](https://oreil.ly/YUGPG) that watches ConfigMap and Secret
    objects for changes and performs rolling upgrades of their associated workloads,
    which can be Deployment, DaemonSet, StatefulSet and other workload resources.
    We can use this controller with applications that are not capable of watching
    the ConfigMap and updating themselves with new configurations dynamically. That
    is particularly true when a Pod consumes this ConfigMap as environment variables
    or when your application cannot quickly and reliably update itself on the fly
    without a restart. As a proof of concept, we implement a similar controller with
    a plain shell script in [Example 27-2](#ex-controller-script).
  prefs: []
  type: TYPE_NORMAL
- en: Flatcar Linux Update Operator
  prefs: []
  type: TYPE_NORMAL
- en: This is a [controller](https://oreil.ly/f8_FY) that reboots a Kubernetes node
    running on Flatcar Container Linux when it detects a particular annotation on
    the Node resource object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at a concrete example: a controller that consists of
    a single shell script and that watches the Kubernetes API for changes on ConfigMap
    resources. If we annotate such a ConfigMap with `k8spatterns.io/podDeleteSelector`,
    all Pods selected with the given label selector are deleted when the ConfigMap
    changes. Assuming we back these Pods with a high-order resource like Deployment
    or ReplicaSet, these Pods are restarted and pick up the changed configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following ConfigMap would be monitored by our controller for
    changes and would restart all Pods that have a label `app` with value `webapp`.
    The ConfigMap in [Example 27-1](#ex-controller-config-map) is used in our web
    application to provide a welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-1\. ConfigMap use by web application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_controller_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation used as selector for the controller in [Example 27-2](#ex-controller-script)
    to find the application Pods to restart.
  prefs: []
  type: TYPE_NORMAL
- en: Our controller shell script now evaluates this ConfigMap. You can find the source
    in its full glory in our Git repository. In short, the controller starts a *hanging
    GET* HTTP request for opening an endless HTTP response stream to observe the lifecycle
    events pushed by the API Server to us. These events are in the form of plain JSON
    objects, which are then analyzed to detect whether a changed ConfigMap carries
    our annotation. As events arrive, the controller acts by deleting all Pods matching
    the selector provided as the value of the annotation. Let’s have a closer look
    at how the controller works.
  prefs: []
  type: TYPE_NORMAL
- en: The main part of this controller is the reconciliation loop, which listens on
    ConfigMap lifecycle events, as shown in [Example 27-2](#ex-controller-script).
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-2\. Controller script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_controller_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace to watch (or *default* if not given).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_controller_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Access to the Kubernetes API via a proxy running in the same Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_controller_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Loop with watches for events on ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: The environment variable `WATCH_NAMESPACE` specifies the namespace in which
    the controller should watch for ConfigMap updates. We can set this variable in
    the Deployment descriptor of the controller itself. In our example, we’re using
    the Downward API described in [Chapter 14, “Self Awareness”](ch14.html#SelfAwareness),
    to monitor the namespace in which we have deployed the controller as configured
    in [Example 27-3](#ex-controller-downward-api) as part of the controller Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-3\. `WATCH_NAMESPACE` extracted from the current namespace
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this namespace, the controller script constructs the URL to the Kubernetes
    API endpoint to watch the ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note the `watch=true` query parameter in [Example 27-2](#ex-controller-script).
    This parameter indicates to the API Server not to close the HTTP connection but
    to send events along the response channel as soon as they happen (*hanging GET*
    or *Comet* are other names for this kind of technique). The loop reads every individual
    event as it arrives as a single item to process.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our controller contacts the Kubernetes API Server via localhost.
    We won’t deploy this script directly on the Kubernetes API control plane node,
    but then how can we use localhost in the script? As you may have probably guessed,
    another pattern kicks in here. We deploy this script in a Pod together with an
    ambassador container that exposes port 8001 on localhost and proxies it to the
    real Kubernetes Service. See [Chapter 18](ch18.html#Ambassador) for more details
    on the *Ambassador* pattern. We see the actual Pod definition with this ambassador
    in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Watching events this way is not very robust, of course. The connection can stop
    anytime, so there should be a way to restart the loop. Also, one could miss events,
    so production-grade controllers should not only watch on events but from time
    to time should also query the API Server for the entire current state and use
    that as the new base. For the sake of demonstrating the pattern, this is good
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, the logic shown in [Example 27-4](#ex-controller-loop) is performed.
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-4\. Controller reconciliation loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_controller_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Extract the type and name of the ConfigMap from the event.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_controller_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Extract all annotations on the ConfigMap with the key `k8spatterns.io/podDeleteSelector`.
    See the following sidebar for an explanation of this `jq` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_controller_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If the event indicates an update of the ConfigMap and our annotation is attached,
    then find all Pods matching this label selector.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_controller_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Delete all Pods that match the selector.
  prefs: []
  type: TYPE_NORMAL
- en: First, the script extracts the event type that specifies what action happened
    to the ConfigMap. Then, we derive the annotations with `jq`. [`jq`](https://oreil.ly/e57Xi)
    is an excellent tool for parsing JSON documents from the command line, and the
    script assumes it is available in the container the script is running in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the ConfigMap has annotations, we check for the annotation `k8spatterns.io/podDeleteSelector`
    by using a more complex `jq` query. The purpose of this query is to convert the
    annotation value to a Pod selector that can be used in an API query option in
    the next step: an annotation `k8spatterns.io/podDeleteSelector: "app=webapp"`
    is transformed to `app%3Dwebapp` that is used as a Pod selector. This conversion
    is performed with `jq` and is explained next if you are interested in how this
    extraction works.'
  prefs: []
  type: TYPE_NORMAL
- en: If the script can extract a `selector`, we can now use it directly to select
    the Pods to delete. First, we look up all Pods that match the selector, and then
    we delete them one by one with direct API calls.
  prefs: []
  type: TYPE_NORMAL
- en: This shell script-based controller is, of course, not production-grade (e.g.,
    the event loop can stop any time), but it nicely reveals the base concepts without
    too much boilerplate code for us.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining work is about creating resource objects and container images.
    The controller script itself is stored in a ConfigMap `config-watcher-controller`,
    and can be easily edited later if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a Deployment to create a Pod for our controller with two containers:'
  prefs: []
  type: TYPE_NORMAL
- en: One Kubernetes API ambassador container that exposes the Kubernetes API on localhost
    on port 8001\. The image `k8spatterns/kubeapi-proxy` is an Alpine Linux with a
    local `kubectl` installed and `kubectl proxy` started with the proper CA and token
    mounted. The original version, kubectl-proxy, was written by Marko Lukša, who
    introduced this proxy in *Kubernetes in Action*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main container that executes the script contained in the just-created ConfigMap.
    Here, we use an Alpine base image with `curl` and `jq` installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the Dockerfiles for the `k8spatterns/kubeapi-proxy` and `k8spatterns/curl-jq`
    images in the example [Git repository](https://oreil.ly/a0zZR).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the images for our Pod, the final step is to deploy the controller
    by using a Deployment. We can see the main parts of the Deployment in [Example 27-5](#ex-controller-deployment)
    (the full version is available in our example repository).
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-5\. Controller Deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_controller_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccount with proper permissions for watching events and restarting Pods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_controller_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Ambassador container for proxying localhost to the Kubeserver API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_controller_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Main container holding all tools and mounting the controller script.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_controller_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Startup command calling the controller script.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_controller_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Volume mapped to the ConfigMap holding our script.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_controller_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Mount of the ConfigMap-backed volume into the main Pod.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we mount the `config-watcher-controller-script` from the ConfigMap
    we created previously and directly use it as the startup command for the primary
    container. For simplicity, we omitted any liveness and readiness checks as well
    as resource limit declarations. Also, we need a ServiceAccount `config-watcher-controller`
    that is allowed to monitor ConfigMaps. Refer to the example repository for the
    full security setup.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the controller in action. For this, we are using a straightforward
    web server, which serves the value of an environment variable as the only content.
    The base image uses plain `nc` (netcat) for serving the content. You can find
    the Dockerfile for this image in the example repository. We deploy the HTTP server
    with a ConfigMap and Deployment, as is sketched in [Example 27-6](#ex-controller-webapp).
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-6\. Sample web app with Deployment and ConfigMap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_controller_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMap for holding the data to serve.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_controller_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Annotation that triggers a restart of the web app’s Pod.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_controller_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Message used in web app in HTTP responses.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_controller_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment for the web app.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_controller_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Simplistic image for HTTP serving with netcat.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_controller_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variable used as an HTTP response body and fetched from the watched
    ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our example of our ConfigMap controller implemented in a plain
    shell script. Although this is probably the most complex example in this book,
    it also shows that it does not take much to write a basic controller.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, for real-world scenarios, you would write this sort of controller
    in a real programming language that provides better error-handling capabilities
    and other advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sum up, a controller is an active reconciliation process that monitors objects
    of interest for the world’s desired state and the world’s actual state. Then,
    it sends instructions to try to change the world’s current state to be more like
    the desired state. Kubernetes uses this mechanism with its internal controllers,
    and you can also reuse the same mechanism with custom controllers. We demonstrated
    what is involved in writing a custom controller and how it functions and extends
    the Kubernetes platform.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers are possible because of the highly modular and event-driven nature
    of the Kubernetes architecture. This architecture naturally leads to a decoupled
    and asynchronous approach for controllers as extension points. The significant
    benefit here is that we have a precise technical boundary between Kubernetes itself
    and any extensions. However, one issue with the asynchronous nature of controllers
    is that they are often hard to debug because the flow of events is not always
    straightforward. As a consequence, you can’t easily set breakpoints in your controller
    to stop everything to examine a specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 28](ch28.html#Operator), you’ll learn about the related *Operator*
    pattern, which builds on this *Controller* pattern and provides an even more flexible
    way to configure operations.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Controller Example](https://oreil.ly/qQcZM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing Controllers](https://oreil.ly/3yuBU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing a Kubernetes Controller](https://oreil.ly/mY5Dc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[A Deep Dive into Kubernetes Controllers](https://oreil.ly/Qa2X4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Expose Controller](https://oreil.ly/Mq3GN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reloader: ConfigMap Controller](https://oreil.ly/bcTYK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing a Custom Controller: Extending the Functionality of Your Cluster](https://oreil.ly/yZdL3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Writing Kubernetes Custom Controllers](https://oreil.ly/0zM5X)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Contour Ingress Controller](https://oreil.ly/19xfy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Syntax and Character Set](https://oreil.ly/FTxze)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubectl-Proxy](https://oreil.ly/_g75A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
