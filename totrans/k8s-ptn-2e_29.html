<html><head></head><body><section data-pdf-bookmark="Chapter 23. Process Containment" data-type="chapter" epub:type="chapter"><div class="chapter" id="ProcessContainment">&#13;
<h1><span class="label">Chapter 23. </span>Process Containment</h1>&#13;
&#13;
&#13;
<p>This<a data-primary="Process Containment" data-type="indexterm" id="procon23"/> chapter describes techniques that help apply the<a data-primary="principle of least privilege" data-type="indexterm" id="idm45902088315584"/><a data-primary="least privilege" data-type="indexterm" id="idm45902088314848"/> principle of least privilege to constrain a process to the minimum privileges it needs to run. The <em>Process Containment</em> pattern helps make applications more secure by limiting the attack surface and creating a line of defense. It also prevents any rogue process from running out of its designated boundary.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902088313424">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>One<a data-primary="problems" data-secondary="applications, limiting attack surface of" data-type="indexterm" id="idm45902088312096"/> of the primary attack vectors for Kubernetes workloads is through the application code. Many techniques can help improve code security. For example, static code analysis tools can check the source code for security flaws. Dynamic scanning tools can simulate malicious attackers with the goal of breaking into the system through well-known service attacks such as SQL injection (SQLi), cross-site request forgery (CSRF), and cross-site scripting (XSS). Then there are tools for regularly scanning the application’s dependencies for security vulnerabilities. As part of the image build process, the containers are scanned for known vulnerabilities. This is usually done by checking the base image and all its packages against a database that tracks vulnerable packages. These are only a few of the steps involved in creating secure applications and protecting against malicious actors, compromised users, unsafe container images, or dependencies with vulnerabilities.</p>&#13;
&#13;
<p>Regardless of how many checks are in place, new code and new dependencies can introduce new vulnerabilities, and there is no way to guarantee the complete absence of risks. Without runtime process-level security controls in place, a malicious actor can breach the application code and attempt to take control of the host or the entire Kubernetes cluster. The mechanisms we will explore in this chapter demonstrate how to limit a container only to the permissions it needs to run and apply the least-privilege principle. This way, Kubernetes configurations act as another line of defense, containing any rogue process and preventing it from running outside its designated boundary.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902088310288">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>Typically, a<a data-primary="Kubernetes" data-secondary="security configurations" data-type="indexterm" id="Ksec23"/> container runtime such as Docker assigns the default<a data-primary="runtime permissions" data-type="indexterm" id="idm45902088307376"/> runtime permissions a container will have. When the container is managed by Kubernetes, the security configurations that will be applied to a container are controlled by Kubernetes and exposed to the user through the security context configurations of the Pod and the container specs. The Pod-level configurations apply to the Pod’s volumes and all containers in the Pod, whereas container-level configurations apply to a single container. When the same configurations are set at both Pod and container levels, the values in the container spec take precedence.</p>&#13;
&#13;
<p>As a developer creating cloud native applications, you typically should not need to deal with many fine-grained security configurations but instead have them validated and enforced as global policy. Fine-grained tuning is usually required when creating specialized infrastructure containers such as build systems and other plugins that need broader access to the underlying nodes. Therefore, we will review only the common security configurations that would be useful for running typical cloud native applications on Kubernetes.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Containers with a Non-Root User" data-type="sect2"><div class="sect2" id="idm45902088306064">&#13;
<h2>Running Containers with a Non-Root User</h2>&#13;
&#13;
<p>Container images have a user, and can optionally have a group, to run the container process.<a data-primary="non-root users" data-type="indexterm" id="idm45902088304480"/> These users and groups are used to control access to files, directories, and volume mounts. With some other containers, no user is created and the container image runs as root by default. In others, a user is created in the container image, but it is not set as the default user to run. These situations can be rectified by overriding the user at runtime using <code>securityContext</code>, as shown in <a data-type="xref" href="#process-containment-user-permissions">Example 23-1</a>.</p>&#13;
<div data-type="example" id="process-containment-user-permissions">&#13;
<h5><span class="label">Example 23-1. </span>Setting a user and group for the containers of a Pod</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">web-app</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">securityContext</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1000</code><code class="w">   </code><a class="co" href="#callout_process_containment_CO1-1" id="co_process_containment_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">runAsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2000</code><code class="w">  </code><a class="co" href="#callout_process_containment_CO1-2" id="co_process_containment_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_process_containment_CO1-1" id="callout_process_containment_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Indicates the UID to run the container process.</p></dd>&#13;
<dt><a class="co" href="#co_process_containment_CO1-2" id="callout_process_containment_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Specifies the GID to run the container process.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The configuration forces any container in the Pod to run with user ID 1000 and group ID 2000. This is useful when you want to swap the user that is specified in the container image. But there is also a danger in setting these values and making runtime decisions about which user to run the image. Often the user is set in conjunction with the directory structure containing files that have the same ownership IDs specified in the container image. To avoid having runtime failures due to lack of permissions, you should check the container image file and run the container with the user ID and group ID defined. This is one way to prevent a container from running as root, and matching it to the expected user in the image.</p>&#13;
&#13;
<p>Instead of specifying a user ID to ensure that a container is not running as root, a less intrusive way is to set the <code>.spec.securityContext.runAsNonRoot</code> flag to <code>true</code>. When set, the<a data-primary="Kubelet" data-secondary="Process Containment" data-type="indexterm" id="idm45902088240656"/> Kubelet will validate at runtime and prevent any container from starting with a root user—that is, a user with UID 0. This latter mechanism doesn’t change the user, but only ensures that a container is running as a non-root user. If you need to run as root to access files or volumes in the container, you can limit the exposure to root by running an init container that can run as root for a short time, and you can change the file access modes, before applications containers start up as non-root.</p>&#13;
&#13;
<p>A container may not run as root, but it is possible to obtain root-like capabilities through privilege escalation. This is most similar to using the <code>sudo</code> command on Linux and executing commands with the root privileges. The way to prevent this in containers is by setting <code>.spec.containers[].securityContext.allowPrivilege​Es⁠calation</code> to <code>false</code>. This configuration typically has no side effects because if an application is designed to run as non-root, it should not require privilege escalation during its lifetime.</p>&#13;
&#13;
<p>The root user has special permissions and privileges in a Linux system, and preventing the root user from owning container processes, escalating privileges to become root, or limiting the root user lifetime with init containers will help prevent container breakout attacks and ensure adherence to the general security practices.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Restricting Container Capabilities" data-type="sect2"><div class="sect2" id="idm45902088199488">&#13;
<h2>Restricting Container Capabilities</h2>&#13;
&#13;
<p>In essence, a container<a data-primary="containers" data-secondary="restricting capabilities of" data-type="indexterm" id="idm45902088198080"/> is a process that runs on a node, and it can have the same privileges a process can have. If the process requires a kernel-level call, it needs to have the privileges to do so in order to succeed. You can do this either by running the container as root, which grants all privileges to the container, or by assigning specific capabilities required for the application to function.</p>&#13;
&#13;
<p>Containers with the <code>.spec.containers[].securityContext.privileged</code> flag set are essentially equivalent to root on the host and bypass the kernel permission checks. From a security point of view, this option bundles your container with the host system rather than isolating it. Therefore, this flag is typically set for containers with administrative capabilities—for example, to manipulate the network stack or access hardware devices. It is a better approach to avoid using privileged containers altogether and give specific kernel capabilities to containers that need them. In Linux, the privileges traditionally associated with the root user are divided into distinct capabilities, which can be independently enabled and disabled. Finding out what capabilities your container has is not straightforward. You can employ a whitelisting approach and start your container without any capabilities and gradually add capabilities when needed for every use case within the container. You might need the help of your security team, or you can use tools such as SELinux in permissive mode and check the audit logs of your application to discover what capabilities it needs, if any.</p>&#13;
&#13;
<p>To make containers more secure, you should provide them with the least amount of privileges needed to run. The container runtime assigns a set of default privileges (capabilities) to the container. Contrary to what you might expect, if the <code>.spec.containers[].securityContext.capabilities</code> section is left empty, the default set of capabilities defined by the container runtime are far more generous than most processes need, opening them up to exploits. A good security practice for locking down the container attack surface is to drop all privileges and add only the ones you need, as shown in <a data-type="xref" href="#process-containment-permissions">Example 23-2</a>.</p>&#13;
<div data-type="example" id="process-containment-permissions">&#13;
<h5><span class="label">Example 23-2. </span>Setting Pod permissions</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">web-app</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">docker.io/centos/httpd</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">securityContext</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">capabilities</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">drop</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">'</code><code class="s">ALL</code><code class="s">'</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">            </code><a class="co" href="#callout_process_containment_CO2-1" id="co_process_containment_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">add</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">'</code><code class="s">NET_BIND_SERVICE</code><code class="s">'</code><code class="p-Indicator">]</code><code class="w">  </code><a class="co" href="#callout_process_containment_CO2-2" id="co_process_containment_CO2-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_process_containment_CO2-1" id="callout_process_containment_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Removes all default capabilities assigned to the container by the container &#13;
<span class="keep-together">runtime.</span></p></dd>&#13;
<dt><a class="co" href="#co_process_containment_CO2-2" id="callout_process_containment_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Adds back only the <code>NET_BIND_SERVICE</code> capability.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>In this example, we drop all the capabilities and add back only the <code>NET_BIND_SERVICE</code> capability, which allows binding to privileged ports with numbers lower than 1024. An alternative approach for addressing this scenario is to replace the container with one that binds to an unprivileged port number.</p>&#13;
&#13;
<p>A Pod is more likely to be compromised if its Security Context is not configured or is too permissive. Limiting the capabilities of containers to the very minimum acts as an additional line of defense against known attacks. A malicious actor who breaches an application would have a harder time taking control of the host when the container process is not privileged or when the capabilities are severely limited.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Avoiding a Mutable Container Filesystem" data-type="sect2"><div class="sect2" id="idm45902088119680">&#13;
<h2>Avoiding a Mutable Container Filesystem</h2>&#13;
&#13;
<p>In general, containerized applications<a data-primary="containers" data-secondary="avoiding mutable filesystems" data-type="indexterm" id="idm45902088118144"/> should not be able to write to the container filesystem because containers are ephemeral and any state will be lost upon restart. As discussed in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch11.html#StatelessService">Chapter 11, “Stateless Service”</a>, state should be written to external persistence methods such as database or filesystems. Logs should be written to stdout or forward to a remote log collector. Such an application can limit the attack surface of the container further by having a read-only container filesystem. A read-only filesystem will prevent any rogue user from tampering with the application configuration or installing additional executables on the disk that can be used for further exploits. The way to do that is to set <code>.spec.containers[].securityContext.readOnlyRootFile</code> to <code>true</code>, which will mount the container’s root filesystem as read-only. This prevents any writes to the container’s root filesystem at runtime and enforces the principle of immutable infrastructure.</p>&#13;
&#13;
<p>The complete list of values in the <code>securityContext</code> field has many more items and can vary between Pod and container configurations. It is beyond the scope of this book to cover all security configurations. The two other must-check security context options are <code>seccompProfile</code> and <code>seLinuxOptions</code>. The first one is a Linux kernel feature that can be used to limit the process running in a container to call only a subset of the available system calls. These system calls are configured as profiles and applied to a container or Pod.</p>&#13;
&#13;
<p>The latter option, <code>seLinuxOptions</code>, can assign custom SELinux labels to all containers within the Pod as well as the volume. SELinux uses policies to define which processes can access other labeled objects in the system. In Kubernetes, it is typically used to label the container image in such a way as to restrict the process to access only files within the image. When SELinux is supported on the host environment, it can be strictly enforced to deny access, or it can be configured in permissive mode to log access violations.</p>&#13;
&#13;
<p class="pagebreak-before">Configuring these fields for every Pod or container causes them to be prone to human errors. Unfortunately, setting them is usually the responsibility of the workload authors who are not typically the security subject-matter experts in the organization. That is why there are also cluster-level, policy-driven means defined by cluster administrators for ensuring all Pods in a namespace meet the minimum security standards. Let’s briefly review that next.<a data-primary="" data-startref="Ksec23" data-type="indexterm" id="idm45902088069648"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enforcing Security Policies" data-type="sect2"><div class="sect2" id="idm45902088068544">&#13;
<h2>Enforcing Security Policies</h2>&#13;
&#13;
<p>So<a data-primary="security policies, enforcing" data-type="indexterm" id="idm45902088066864"/><a data-primary="containers" data-secondary="enforcing security policies" data-type="indexterm" id="idm45902088066096"/> far, we’ve explored setting security parameters of the container runtime using the <code>securityContext</code> definition as part of the Pod and container specifications. These specifications are created individually per Pod and usually indirectly through higher abstractions such as Deployments, Jobs, and<a data-primary="CronJobs" data-secondary="enforcing security policies" data-type="indexterm" id="idm45902088064640"/> CronJobs. But how can a cluster administrator or a security expert ensure that a collection of Pods follows certain security standards? The answer is in the Kubernetes<a data-primary="Pod Security Standards (PSS)" data-type="indexterm" id="idm45902088063520"/><a data-primary="PSS (Pod Security Standards)" data-type="indexterm" id="idm45902088062832"/> Pod Security Standards (PSS) and<a data-primary="Pod Security Admission (PSA) controller" data-type="indexterm" id="idm45902088062016"/><a data-primary="PSA (Pod Security Admission) controller" data-type="indexterm" id="idm45902088061280"/> Pod Security Admission (PSA) controller. PSS defines a common understanding and consistent language around security policies, and PSA helps enforce them. This way, the policies are independent of the underlying enforcement mechanism and can be applied through PSS or other third-party tools. These policies are grouped in three security profiles that are cumulative, from highly permissive to highly restrictive, as follows:</p>&#13;
<dl>&#13;
<dt>Privileged</dt>&#13;
<dd>&#13;
<p>This is an unrestricted profile with the widest possible level of permissions. It is purposely left open and offers allow-by-default mechanisms for trusted users and infrastructure workloads.</p>&#13;
</dd>&#13;
<dt>Baseline</dt>&#13;
<dd>&#13;
<p>This profile is for common noncritical application workloads. It has a minimally restrictive policy and provides a balance between ease of adoption and prevention from known privilege escalations. For example, it won’t allow privileged containers, certain security capabilities, and even other configurations outside of the <code>securityContext</code> field.</p>&#13;
</dd>&#13;
<dt>Restricted</dt>&#13;
<dd>&#13;
<p>This is the most restrictive profile that follows the latest security-hardening best practices at the expense of adoption. It is meant for security-critical applications, as well as lower-trust users. On top of the Baseline profile, it puts restrictions on the fields we reviewed earlier, such as  <code>allowPrivilegeEscalation</code>, <code>runAsNonRoot</code>, <code>runAsUser</code>, and other container configurations.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>PodSecurityPolicy was the legacy security-policy-enforcement mechanism that was replaced with PSA in Kubernetes v1.25. Going forward, you can use a third-party admission plugin or the built-in PSA controller to enforce the security standards for each namespace. The security standards are applied to a Kubernetes namespace using labels that define the standard level as described earlier and one or more actions to take when a potential violation is detected. Following are the actions you can take:</p>&#13;
<dl>&#13;
<dt>Warn</dt>&#13;
<dd>&#13;
<p>The policy violations are allowed with a user-facing warning.</p>&#13;
</dd>&#13;
<dt>Audit</dt>&#13;
<dd>&#13;
<p>The policy violations are allowed with an auditing log entry recorded.</p>&#13;
</dd>&#13;
<dt>Enforce</dt>&#13;
<dd>&#13;
<p>Any policy violations will cause the Pod to be rejected.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>With these options defined, <a data-type="xref" href="#process-containment-standard-enformcent">Example 23-3</a> creates a namespace that rejects any Pods that don’t satisfy the <em>baseline</em> standard, and also generates a warning for Pods that don’t meet the <em>restricted</em> standards requirements.</p>&#13;
<div data-type="example" id="process-containment-standard-enformcent">&#13;
<h5><span class="label">Example 23-3. </span>Set security standards for a namespace</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">baseline-namespace</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">pod-security.kubernetes.io/enforce</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">baseline</code><code class="w">             </code><a class="co" href="#callout_process_containment_CO3-1" id="co_process_containment_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">pod-security.kubernetes.io/enforce-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.25</code><code class="w">        </code><a class="co" href="#callout_process_containment_CO3-2" id="co_process_containment_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">pod-security.kubernetes.io/warn</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">restricted</code><code class="w">              </code><a class="co" href="#callout_process_containment_CO3-3" id="co_process_containment_CO3-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">pod-security.kubernetes.io/warn-version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1.25</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_process_containment_CO3-1" id="callout_process_containment_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Label hinting to the PSA controller to reject Pods that violate the <em>baseline</em> standard.</p></dd>&#13;
<dt><a class="co" href="#co_process_containment_CO3-2" id="callout_process_containment_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Version of the security-standard requirements to use (optional).</p></dd>&#13;
<dt><a class="co" href="#co_process_containment_CO3-3" id="callout_process_containment_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Label hinting to the PSA controller to warn about Pods that violate the <em>restricted</em> &#13;
<span class="keep-together">standard.</span></p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This example creates a new namespace and configures the security standards to apply to all Pods that will be created in this namespace. It is also possible to update the configuration of a namespace or apply the policy to one or all existing namespaces. For details on how to do this in the least distributive way, check out <a data-type="xref" href="#ch23moreinfo">“More Information”</a>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902087953184">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>One of the common security challenges with Kubernetes is running<a data-primary="legacy applications" data-type="indexterm" id="idm45902087951744"/> legacy applications that are not implemented or containerized with Kubernetes security controls in mind. Running a privileged container can be a challenge on Kubernetes distributions or environments with strict security policies. Understanding how Kubernetes does process containment at runtime and configures security boundaries, as shown in <a data-type="xref" href="#img-process-containment">Figure 23-1</a>, will help you create applications that run on Kubernetes more securely. It is important to realize that a container is not only a packaging format and not only a resource isolation mechanism, but when configured properly, it is also a security fence.</p>&#13;
&#13;
<figure><div class="figure" id="img-process-containment">&#13;
<img alt="A containerized process is contained and only certain operations allowed to reach the node" src="assets/kup2_2301.png"/>&#13;
<h6><span class="label">Figure 23-1. </span>Process Containment pattern</h6>&#13;
</div></figure>&#13;
&#13;
<p>The tendency of shifting left the security considerations and testing practices, including deploying into Kubernetes with the production security standards, is getting more popular. Such practices help identify and tackle security issues earlier in the development cycle and prevent last-minute surprises.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><em>Shifting left</em> is<a data-primary="Shift Left model" data-type="indexterm" id="idm45902087946416"/> all about doing things earlier rather than later. It’s about going leftward on the time ray that describes a development and deployment process. In our context, shift left implies that the developer already thinks about operational security when developing the application. See more details about the Shift Left model on <a href="https://oreil.ly/cdw3f">Devopedia</a>.</p>&#13;
</div>&#13;
&#13;
<p>In this chapter, we hope that we have given you enough food for thought when creating secure cloud native applications. The guidelines in this chapter will help you design and implement applications that don’t write to the local filesystem or require root privileges (for example, when containerizing applications, to ensure the container has a designated non-root user) and configure the security context. We hope that you understand exactly what your application needs and give it only the minimum permissions. We also aimed to help you build boundaries between the workloads and the host, to reduce container privileges and configuring the runtime environment to limit resource utilization in the event of a breach. In this endeavor, the <em>Process Containment</em> pattern ensures “what happens in a container stays in a container,” including any security breaches.<a data-primary="" data-startref="procon23" data-type="indexterm" id="idm45902087943776"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="ch23moreinfo">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Seeg_">Process Containment Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/e7lKN">Configure a Security Context for a Pod or Container</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/S8ac9">Pod Security Admission</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2xzlg">Pod Security Standards</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/FnVMh">Enforce Pod Security Standards with Namespace Labels</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/QnhLj">Admission Controllers Reference: PodSecurity</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/GkHt7">Linux Capabilities</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/IkMnH">Introduction to Security Contexts and SCCs</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/f04Xj">10 Kubernetes Security Context Settings You Should Understand</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/pbAqs">Security Risk Analysis Tool for Kubernetes Resources</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>