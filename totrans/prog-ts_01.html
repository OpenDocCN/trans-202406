<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introduction" data-type="chapter" epub:type="chapter"><div class="chapter" id="intro">&#13;
<h1><span class="label">Chapter 1. </span>Introduction</h1>&#13;
&#13;
&#13;
<p>So, you decided to buy a book about TypeScript. Why?</p>&#13;
&#13;
<p>Maybe it’s because you’re sick of those weird <code>cannot read property blah of</code> <span class="keep-together"><code>undefined</code></span> JavaScript errors. Or maybe you heard TypeScript can help your code scale better, and wanted to see what all the fuss is about. Or you’re a C# person, and have been thinking of trying out this whole JavaScript thing. Or you’re a functional programmer, and decided it was time to take your chops to the next level. Or your boss was so fed up with your code causing production issues that they gave you this book as a Christmas present (stop me if I’m getting warm).</p>&#13;
&#13;
<p>Whatever your reasons are, what you’ve heard is true. TypeScript is the language that will power the next generation of web apps, mobile apps, NodeJS projects, and Internet of Things (IoT) devices. <a data-primary="TypeScript" data-secondary="benefits of" data-type="indexterm" id="idm46304996584680"/>It will make your programs safer by checking for common mistakes, serve as documentation for yourself and future engineers, make refactoring painless, and make, like, half of your unit tests unnecessary (“What unit tests?”). TypeScript will double your productivity as a programmer, and it will land you a date with that cute barista across the street.</p>&#13;
&#13;
<p>But before you go rushing across the street, let’s unpack all of that a little bit, starting with this: what exactly do I mean when I say “safer”? <a data-primary="type safety" data-type="indexterm" id="idm46304996582648"/>What I am talking about, of course, is <em>type safety</em>.</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304996581256">&#13;
<h5>Type safety</h5>&#13;
<p>Using types to prevent programs from doing invalid things.<sup><a data-type="noteref" href="ch01.html#idm46304996579624" id="idm46304996579624-marker">1</a></sup></p>&#13;
</div></aside>&#13;
&#13;
<p>Here are a few examples of<a data-primary="invalid actions" data-type="indexterm" id="idm46304996578280"/> things that are invalid:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Multiplying a number and a list</p>&#13;
</li>&#13;
<li>&#13;
<p>Calling a function with a list of strings when it actually needs a list of objects</p>&#13;
</li>&#13;
<li>&#13;
<p>Calling a method on an object when that method doesn’t actually exist on that object</p>&#13;
</li>&#13;
<li>&#13;
<p>Importing a module that was recently moved</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are some programming languages that try to make the most of mistakes like these. <a data-primary="errors" data-secondary="in JavaScript" data-type="indexterm" id="idm46304996572904"/>They try to figure out what you really meant when you did something invalid, because hey, you do what you can, right? Take JavaScript, for example:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="mi">3</code> <code class="o">+</code> <code class="p">[]</code>            <code class="c1">// Evaluates to the string "3"</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{}</code>&#13;
<code class="nx">obj</code><code class="p">.</code><code class="nx">foo</code>           <code class="c1">// Evaluates to undefined</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">b</code><code class="o">/</code><code class="mi">2</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">a</code><code class="p">(</code><code class="s2">"z"</code><code class="p">)</code>            <code class="c1">// Evaluates to NaN</code></pre>&#13;
&#13;
<p>Notice that instead of throwing exceptions when you try to do things that are obviously invalid, JavaScript tries to make the best of it and avoids exceptions whenever it can.<a data-primary="exceptions" data-secondary="JavaScript and" data-type="indexterm" id="idm46304989556584"/> Is JavaScript being helpful? Certainly. Does it make it easier for you to catch bugs quickly? Probably not.</p>&#13;
&#13;
<p>Now imagine if JavaScript threw more exceptions instead of quietly making the best of what we gave it. We might get feedback like this instead:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="mi">3</code> <code class="o">+</code> <code class="p">[]</code>            <code class="c1">// Error: Did you really mean to add a number and an array?</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{}</code>&#13;
<code class="nx">obj</code><code class="p">.</code><code class="nx">foo</code>           <code class="c1">// Error: You forgot to define the property "foo" on obj.</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">b</code><code class="o">/</code><code class="mi">2</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">a</code><code class="p">(</code><code class="s2">"z"</code><code class="p">)</code>            <code class="c1">// Error: The function "a" expects a number,</code>&#13;
                  <code class="c1">// but you gave it a string.</code></pre>&#13;
&#13;
<p>Don’t get me wrong: trying to fix our mistakes for us is a neat feature for a programming language to have (if only it worked for more than just programs!). But for JavaScript, this feature creates a disconnect between when you make a mistake in your code, and when you <em>find out</em> that you made a mistake in your code. Often, that means that the first time you hear about your mistake will be from someone else.</p>&#13;
&#13;
<p>So here’s a question: when exactly does JavaScript tell you that you made a mistake?</p>&#13;
&#13;
<p>Right: when you actually <em>run</em> your program. Your program might get run when you test it in a browser, or when a user visits your website, or when you run a unit test.<a data-primary="tests, relying on to find errors" data-type="indexterm" id="idm46304995696408"/> If you’re disciplined and write plenty of unit tests and end-to-end tests, smoke test your code before pushing it, and test it internally for a while before shipping it to users, you will hopefully find out about your error before your users do. But what if you don’t?</p>&#13;
&#13;
<p>That’s where TypeScript comes in.<a data-primary="TypeScript" data-secondary="errors, handling of" data-type="indexterm" id="idm46304995695080"/> Even cooler than the fact that TypeScript gives you helpful error messages is <em>when</em> it gives them to you: TypeScript gives you error messages <em>in your text editor, as you type</em>. <a data-primary="errors" data-secondary="error messages in TypeScript" data-type="indexterm" id="idm46304995693128"/>That means you don’t have to rely on unit tests or smoke tests or coworkers to catch these sorts of issues: TypeScript will catch them for you and warn you about them as you write your program. Let’s see what TypeScript says about our previous example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="mi">3</code> <code class="o">+</code> <code class="p">[]</code>            <code class="c1">// Error TS2365: Operator '+' cannot be applied to types '3'</code>&#13;
                  <code class="c1">// and 'never[]'.</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{}</code>&#13;
<code class="nx">obj</code><code class="p">.</code><code class="nx">foo</code>           <code class="c1">// Error TS2339: Property 'foo' does not exist on type '{}'.</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">a</code><code class="p">(</code><code class="nx">b</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">b</code> <code class="o">/</code> <code class="mi">2</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">a</code><code class="p">(</code><code class="s2">"z"</code><code class="p">)</code>            <code class="c1">// Error TS2345: Argument of type '"z"' is not assignable to</code>&#13;
                  <code class="c1">// parameter of type 'number'.</code></pre>&#13;
&#13;
<p>In addition to <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2339" data-type="indexterm" id="idm46304993588632"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304995144712"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2365" data-type="indexterm" id="idm46304995612120"/>eliminating entire classes of type-related bugs, this will actually change the way you write code. You will find yourself sketching out a program at the type level before you fill it in at the value level;<sup><a data-type="noteref" href="ch01.html#idm46304995487608" id="idm46304995487608-marker">2</a></sup> you will think about edge cases as you design your program, not as an afterthought; and you will design programs that are simpler, faster, easier to understand, and easier to maintain.</p>&#13;
&#13;
<p>Are you ready to begin the journey? Let’s go!</p>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304996579624"><sup><a href="ch01.html#idm46304996579624-marker">1</a></sup> Depending on which statically typed language you use, “invalid” can mean a range of things, from programs that will crash when you run them to things that won’t crash but are clearly nonsensical.</p><p data-type="footnote" id="idm46304995487608"><sup><a href="ch01.html#idm46304995487608-marker">2</a></sup> If you’re not sure what “type level” means here, don’t worry. We’ll go over it in depth in later chapters.</p></div></div></section></body></html>