<html><head></head><body><section data-pdf-bookmark="Chapter 10. Namespaces.Modules" data-type="chapter" epub:type="chapter"><div class="chapter" id="modules">&#13;
<h1><span class="label">Chapter 10. </span>Namespaces.Modules</h1>&#13;
&#13;
&#13;
<p>When you write a program, you can express encapsulation at several levels. At the lowest level, <a data-primary="modules" data-type="indexterm" id="ix_mods"/>functions encapsulate behaviors, and data structures like objects and lists encapsulate data. You might then group functions and data into classes, or keep them separate as namespaced utilities with a separate database or store for your data. A single class or a set of utilities per file is typical. Going up, you might group a few classes or utilities into a package, which you publish to NPM.</p>&#13;
&#13;
<p>When we talk about modules, it’s important to make a distinction between how the compiler (TSC) resolves modules, how your build system (Webpack, Gulp, etc.) resolves modules, and how modules are actually loaded into your application at runtime (<code>&lt;script /&gt;</code> tags, SystemJS, etc.). In the JavaScript world there is usually a separate program that does each of these jobs, which can make modules hard to reason about. The CommonJS and ES2015 module standards make it easier to interoperate the three programs, and powerful bundlers like Webpack help abstract away the three kinds of resolution happening under the hood.</p>&#13;
&#13;
<p>In this chapter we’ll focus on the first of these three kinds of programs: how TypeScript resolves and compiles modules. We’ll leave a discussion of how the build system and runtime loaders work with modules to <a data-type="xref" href="ch12.html#typescript-in-production">Chapter 12</a> and talk here about:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The different ways to namespace and modularize your code</p>&#13;
</li>&#13;
<li>&#13;
<p>The different ways to import and export code</p>&#13;
</li>&#13;
<li>&#13;
<p>Scaling these approaches as your codebase grows</p>&#13;
</li>&#13;
<li>&#13;
<p>Module mode versus script mode</p>&#13;
</li>&#13;
<li>&#13;
<p>What declaration merging is, and what you can do with it</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>But first, a bit of background.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Brief History of JavaScript Modules" data-type="sect1"><div class="sect1" id="idm46304953543384">&#13;
<h1>A Brief History of JavaScript Modules</h1>&#13;
&#13;
<p>Because TypeScript compiles to and interoperates with JavaScript, it has to support the various module standards that JavaScript programmers use.<a data-primary="JavaScript" data-secondary="modules, brief history of" data-type="indexterm" id="ix_JSmod"/><a data-primary="modules" data-secondary="brief history of JavaScript modules" data-type="indexterm" id="ix_modsJShist"/></p>&#13;
&#13;
<p>In the beginning (in 1995), JavaScript didn’t support any sort of module system. Without modules, everything was declared in a global namespace, which made it really hard to build and scale applications. You could quickly run out of variable names, and run into collisions between variable names; and without exposing explicit APIs for each module, it’s hard to know which parts of a module you’re supposed to use, and which parts are private implementation details.</p>&#13;
&#13;
<p>To help solve these problems, people simulated modules with either objects or <em>Immediately Invoked Function Expressions</em> (IIFEs), which they assigned to the global <code>window</code>, making them available to other modules in their application (and in other applications hosted on the same web page).<a data-primary="immediately invoked function expressions (IIFEs)" data-type="indexterm" id="idm46304953521656"/> It looked something like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nb">window</code><code class="p">.</code><code class="nx">emailListModule</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">renderList</code><code class="p">()</code> <code class="p">{}</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nb">window</code><code class="p">.</code><code class="nx">emailComposerModule</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">renderComposer</code><code class="p">()</code> <code class="p">{}</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nb">window</code><code class="p">.</code><code class="nx">appModule</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">renderApp</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nb">window</code><code class="p">.</code><code class="nx">emailListModule</code><code class="p">.</code><code class="nx">renderList</code><code class="p">()</code>&#13;
    <code class="nb">window</code><code class="p">.</code><code class="nx">emailComposerModule</code><code class="p">.</code><code class="nx">renderComposer</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because loading and running JavaScript blocks the browser’s UI, as a web application grows and includes more and more lines of code, the user’s browser gets slower and slower.<a data-primary="browsers" data-secondary="loading and running JavaScript" data-type="indexterm" id="idm46304953435080"/> For this reason, clever programmers started dynamically loading JavaScript after the page loaded, rather than loading it all in one shot. Nearly 10 years after JavaScript was first released, Dojo (Alex Russell, 2004), YUI (Thomas Sha, 2005), and LABjs (Kyle Simpson, 2009) shipped module loaders—ways to lazily (and often asynchronously) load JavaScript code after the initial page load has happened.<a data-primary="lazy and asynchronous loading modules" data-type="indexterm" id="idm46304953477560"/><a data-primary="asynchronously loading modules" data-type="indexterm" id="idm46304953476952"/> Lazy and asynchronous module loading meant three things:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Modules needed to be well encapsulated. Otherwise, a page might be broken while dependencies are streaming in.</p>&#13;
</li>&#13;
<li>&#13;
<p>Dependencies between modules needed to be explicit. Otherwise, we don’t know which modules need to be loaded and in what order.</p>&#13;
</li>&#13;
<li>&#13;
<p>Every module needed a unique identifier within the app. Otherwise, there’s no reliable way to specify what modules need to be loaded.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Loading a module<a data-primary="LABjs, loading module with" data-type="indexterm" id="idm46304953472376"/> with LABjs looked like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">$LAB</code>&#13;
  <code class="p">.</code><code class="nx">script</code><code class="p">(</code><code class="s1">'/emailBaseModule.js'</code><code class="p">).</code><code class="nx">wait</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">script</code><code class="p">(</code><code class="s1">'/emailListModule.js'</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">script</code><code class="p">(</code><code class="s1">'/emailComposerModule.js'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Around the same time, NodeJS (Ryan Dahl, 2009) was being developed, and its creators took a lesson from JavaScript’s growing pains and from other languages and decided to build a module system right into the platform.<a data-primary="NodeJS" data-secondary="modules" data-type="indexterm" id="idm46304953400648"/> Like any good module system, it needed to satisfy the same three criteria as LABjs and YUI’s loaders.<a data-primary="CommonJS module standard" data-type="indexterm" id="idm46304953399656"/> NodeJS did that with the CommonJS module standard, which looked like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// emailBaseModule.js</code>&#13;
<code class="kd">var</code> <code class="nx">emailList</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'emailListModule'</code><code class="p">)</code>&#13;
<code class="kd">var</code> <code class="nx">emailComposer</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'emailComposerModule'</code><code class="p">)</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code><code class="p">.</code><code class="nx">renderBase</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the meantime, <a data-primary="AMD module standard" data-type="indexterm" id="idm46304953397672"/>on the web the AMD module standard (James Burke, 2008)—pushed by Dojo and RequireJS—was taking off. It supported an equivalent set of functionality, and came with its own build system for bundling up JavaScript code:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">define</code><code class="p">(</code><code class="s1">'emailBaseModule'</code><code class="p">,</code>&#13;
  <code class="p">[</code><code class="s1">'require'</code><code class="p">,</code> <code class="s1">'exports'</code><code class="p">,</code> <code class="s1">'emailListModule'</code><code class="p">,</code> <code class="s1">'emailComposerModule'</code><code class="p">],</code>&#13;
  <code class="kd">function</code><code class="p">(</code><code class="nx">require</code><code class="p">,</code> <code class="nx">exports</code><code class="p">,</code> <code class="nx">emailListModule</code><code class="p">,</code> <code class="nx">emailComposerModule</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">exports</code><code class="p">.</code><code class="nx">renderBase</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
      <code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>A few years <a data-primary="Browserify" data-type="indexterm" id="idm46304953360104"/>after that, Browserify came out (James Halliday, 2011), giving frontend engineers the ability to use CommonJS on the frontend, too.<a data-primary="imports" data-secondary="CommonJS" data-type="indexterm" id="idm46304953298072"/><a data-primary="exports" data-secondary="CommonJS" data-type="indexterm" id="idm46304953297192"/> CommonJS became the de facto standard for module bundling and import/export syntax.</p>&#13;
&#13;
<p>There were a few problems with the CommonJS way of doing things.<a data-primary="CommonJS module standard" data-secondary="problems with" data-type="indexterm" id="idm46304953295512"/><a data-primary="require calls" data-type="indexterm" id="idm46304953294568"/> Among them, <code>require</code> calls are necessarily synchronous, and the CommonJS module resolution algorithm is not ideal for use on the web. On top of that, code that uses it isn’t statically analyzable in some cases (as a TypeScript programmer, this should perk your ears up),<a data-primary="module.exports" data-type="indexterm" id="idm46304953293080"/> because <code>module.exports</code> can appear anywhere (even in dead code branches that are never actually reached) and <code>require</code> calls can appear anywhere and contain arbitrary strings and expressions, making it impossible to statically link a JavaScript program, and verify that all referenced files really exist and export what they say they export.<a data-primary="exports" data-secondary="module.exports" data-type="indexterm" id="idm46304953291176"/></p>&#13;
&#13;
<p>Against this backdrop, ES2015—the sixth <a data-primary="ES2015" data-type="indexterm" id="idm46304953289880"/>edition of the ECMAScript language—introduced a new standard for imports and exports that had a clean syntax and was statically analyzable.<a data-primary="exports" data-secondary="ES2015 standard for" data-type="indexterm" id="ix_exES"/><a data-primary="imports" data-secondary="ES2015 standard for" data-type="indexterm" id="ix_impES"/> It looks like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// emailBaseModule.js</code>&#13;
<code class="kr">import</code> <code class="nx">emailList</code> <code class="nx">from</code> <code class="s1">'emailListModule'</code>&#13;
<code class="kr">import</code> <code class="nx">emailComposer</code> <code class="nx">from</code> <code class="s1">'emailComposerModule'</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">renderBase</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is the standard we use in JavaScript and TypeScript code today. However, at the time of writing the standard isn’t yet natively supported in every JavaScript runtime, so we have to compile it down to a format that is supported (CommonJS for NodeJS environments, globals or a module-loadable format for browser environments).<a data-primary="browsers" data-secondary="module-loadable format for" data-type="indexterm" id="idm46304953266712"/></p>&#13;
&#13;
<p>TypeScript gives us a few ways to consume and export code in a module: with global declarations,<a data-primary="TypeScript" data-secondary="modules, consuming and exporting" data-type="indexterm" id="idm46304953265144"/> with standard ES2015 <code>import</code>s and <code>export</code>s, and with backward-compatible <code>import</code>s from CommonJS modules. On top of that, TSC’s build system lets us compile modules for a variety of environments: globals, ES2015, CommonJS, AMD, SystemJS, or UMD (a mix of CommonJS, AMD, and globals—whichever happens to be available in the consumer’s environment).<a data-primary="globals (browser)" data-type="indexterm" id="idm46304953262568"/><a data-primary="JavaScript" data-secondary="modules, brief history of" data-startref="ix_JSmod" data-type="indexterm" id="idm46304953261864"/><a data-primary="modules" data-secondary="brief history of JavaScript modules" data-startref="ix_modsJShist" data-type="indexterm" id="idm46304953260680"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="import, export" data-type="sect1"><div class="sect1" id="idm46304953542760">&#13;
<h1>import, export</h1>&#13;
&#13;
<p>Unless you’re being chased by wolves, you should use ES2015 <code>import</code>s and <code>export</code>s in your TypeScript code, rather than using CommonJS, global, or namespaced modules. <a data-primary="modules" data-secondary="import, export" data-type="indexterm" id="ix_modsimex"/>They look like this—the same as plain old JavaScript:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// a.ts</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">foo() {</code><code class="p">}</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">bar() {</code><code class="p">}</code>&#13;
&#13;
<code class="c1">// b.ts</code>&#13;
<code class="kr">import</code> <code class="p">{</code><code class="nx">foo</code><code class="p">,</code> <code class="nx">bar</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./a'</code>&#13;
<code class="nx">foo</code><code class="p">()</code>&#13;
<code class="kr">export</code> <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">()</code></pre>&#13;
&#13;
<p>The ES2015 module standard supports default exports:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// c.ts</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">meow</code><code class="p">(</code><code class="nx">loudness</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">// d.ts</code>&#13;
<code class="kr">import</code> <code class="nx">meow</code> <code class="nx">from</code> <code class="s1">'./c'</code> <code class="c1">// Note the lack of {curlies}</code>&#13;
<code class="nx">meow</code><code class="p">(</code><code class="mi">11</code><code class="p">)</code></pre>&#13;
&#13;
<p class="pagebreak-before">It also supports importing everything from a module using a wildcard import (<code>*</code>):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// e.ts</code>&#13;
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">a</code> <code class="nx">from</code> <code class="s1">'./a'</code>&#13;
<code class="nx">a</code><code class="p">.</code><code class="nx">foo</code><code class="p">()</code>&#13;
<code class="nx">a</code><code class="p">.</code><code class="nx">bar</code><code class="p">()</code></pre>&#13;
&#13;
<p>And reexporting some (or all) exports from a module:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// f.ts</code>&#13;
<code class="kr">export</code> <code class="o">*</code> <code class="nx">from</code> <code class="s1">'./a'</code>&#13;
<code class="kr">export</code> <code class="p">{</code><code class="nx">result</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./b'</code>&#13;
<code class="kr">export</code> <code class="nx">meow</code> <code class="nx">from</code> <code class="s1">'./c'</code></pre>&#13;
&#13;
<p>Because we’re writing TypeScript, not JavaScript, we can of course export types and interfaces as well as values. And because types and values live in separate namespaces, it’s perfectly fine to export two things—one at the value level and one at the type level—that share the same name. Like for any other code, TypeScript will infer whether you meant the type or the value when you actually use it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// g.ts</code>&#13;
<code class="kr">export</code> <code class="kd">let</code> <code class="nx">X</code> <code class="o">=</code> <code class="mi">3</code>&#13;
<code class="kr">export</code> <code class="nx">type</code> <code class="nx">X</code> <code class="o">=</code> <code class="p">{</code><code class="nx">y</code>: <code class="kt">string</code><code class="p">}</code>&#13;
&#13;
<code class="c1">// h.ts</code>&#13;
<code class="kr">import</code> <code class="p">{</code><code class="nx">X</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./g'</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">X</code> <code class="o">+</code> <code class="mi">1</code>         <code class="c1">// X refers to the value X</code>&#13;
<code class="kd">let</code> <code class="nx">b</code>: <code class="kt">X</code> <code class="o">=</code> <code class="p">{</code><code class="nx">y</code><code class="o">:</code> <code class="s1">'z'</code><code class="p">}</code>   <code class="c1">// X refers to the type X</code></pre>&#13;
&#13;
<p>Module paths are filenames on the filesystem.<a data-primary="filesystem, module paths as filenames on" data-type="indexterm" id="idm46304952994616"/><a data-primary="paths (module)" data-type="indexterm" id="idm46304952976184"/> This couples modules with the way they’re laid out in the filesystem, but is an important feature for module loaders that need to be aware of that layout so they can resolve modules names to files.<a data-primary="imports" data-secondary="ES2015 standard for" data-startref="ix_impES" data-type="indexterm" id="idm46304952975224"/><a data-primary="exports" data-secondary="ES2015 standard for" data-startref="ix_exES" data-type="indexterm" id="idm46304952974040"/><a data-primary="modules" data-secondary="import, export" data-startref="ix_modsimex" data-type="indexterm" id="idm46304952972824"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dynamic Imports" data-type="sect2"><div class="sect2" id="dynamic_imports">&#13;
<h2>Dynamic Imports</h2>&#13;
&#13;
<p>As your application gets bigger, its time to initial render will get worse and worse. <a data-primary="modules" data-secondary="import, export" data-tertiary="dynamic imports" data-type="indexterm" id="idm46304952969512"/><a data-primary="imports" data-secondary="dynamic" data-type="indexterm" id="idm46304952968264"/>This is especially a problem for frontend applications where the network can be a bottleneck, but it also applies to backend applications that take more time to start up as you import more code at the top level—code that needs to be loaded from the filesystem, parsed, compiled, and evaluated, all while blocking other code from running.</p>&#13;
&#13;
<p>On the frontend, one way to deal with this problem (besides writing less code!) is with <em>code splitting</em>: chunking <a data-primary="code splitting" data-type="indexterm" id="idm46304952965928"/>your code up into a bunch of generated JavaScript files, instead of shipping everything in a single large file. With splitting you get the benefit of loading multiple chunks in parallel, which eases the toll of large network requests (see <a data-type="xref" href="#network-waterfall-fig">Figure 10-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="network-waterfall-fig">&#13;
<img alt="prts 1001" src="assets/prts_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>Network waterfall for JavaScript loaded from facebook.com</h6>&#13;
</div></figure>&#13;
&#13;
<p>A further optimization is to lazy-load chunks of code when they’re actually needed.<a data-primary="lazy and asynchronous loading modules" data-secondary="lazy loading chunks of code" data-type="indexterm" id="idm46304952961624"/> Really large frontend applications—like those at Facebook and Google—use this type of optimization as a matter of course. Without it, clients might be loading gigabytes of JavaScript code on the initial page load, which could take minutes or hours (not to mention that people would probably stop using those services once they received their mobile bills).</p>&#13;
&#13;
<p>Lazy loading is also useful for other reasons. For example, the popular <a href="https://momentjs.com">Moment.js</a> date manipulation library comes with packages to support every date format used around the world,<a data-primary="Moment.js date manipulation library" data-type="indexterm" id="idm46304952959016"/> split up by locale. Each packages weighs in at around 3 KB. Loading all of these locales for each user might be an unacceptable performance and bandwidth hit; instead, you might want to detect the user’s locale, then load just the relevant date package.</p>&#13;
&#13;
<p>LABjs and its siblings introduced the concept of lazy-loading code when you actually need it,<a data-primary="LABjs, loading module with" data-secondary="lazy-loading code" data-type="indexterm" id="idm46304952957400"/> and the concept was formalized in <em>dynamic imports</em>.<a data-primary="dynamic imports" data-type="indexterm" id="idm46304952955896"/> It looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">locale</code> <code class="o">=</code> <code class="nx">await</code> <code class="kr">import</code><code class="p">(</code><code class="s1">'locale_us-en'</code><code class="p">)</code></pre>&#13;
&#13;
<p>You can use <code>import</code> either as a statement to statically pull in code (as we’ve used it up to this point), or as a function that returns a <code>Promise</code> for your module (as we did in this example).<a data-primary="import statements" data-type="indexterm" id="idm46304952951800"/><a data-primary="promises" data-secondary="returned by import function" data-type="indexterm" id="idm46304952951160"/><a data-primary="import function" data-type="indexterm" id="idm46304952948664"/></p>&#13;
&#13;
<p>While you can pass an arbitrary expression that evaluates to a string to <code>import</code>, you lose type safety when you do. To safely use dynamic imports, be sure to either:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Pass a string literal directly to <code>import</code>, without assigning the string to a variable first.</p>&#13;
</li>&#13;
<li>&#13;
<p>Pass an expression to <code>import</code> and manually annotate the module’s signature.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>If using the second option, a common pattern is to statically import the module, but use it only in a type position, so that TypeScript compiles away the static import (to learn more, see <a data-type="xref" href="ch12.html#import-elision">“The types Directive”</a>). For example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">locale</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./locales/locale-us'</code>&#13;
&#13;
<code class="nx">async</code> <code class="kd">function</code> <code class="nx">main() {</code>&#13;
  <code class="kd">let</code> <code class="nx">userLocale</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getUserLocale</code><code class="p">()</code>&#13;
  <code class="kd">let</code> <code class="nx">path</code> <code class="o">=</code> <code class="p">.</code><code class="o">/</code><code class="nx">locales</code><code class="o">/</code><code class="nx">locale</code><code class="o">-</code><code class="nx">$</code><code class="p">{</code><code class="nx">userLocale</code><code class="p">}</code>&#13;
  <code class="kd">let</code> <code class="nx">localeUS</code>: <code class="kt">typeof</code> <code class="nx">locale</code> <code class="o">=</code> <code class="nx">await</code> <code class="kr">import</code><code class="p">(</code><code class="nx">path</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We imported <code>locale</code> from <em>./locales/locale-us</em>, but we only used it for its type, which we retrieved with <code>typeof locale</code>. We needed to do that because TypeScript couldn’t statically look up the type of <code>import(path)</code>, because <code>path</code> is a computed variable and not a static string.<a data-primary="paths (module)" data-type="indexterm" id="idm46304952852296"/> Because we never used <code>locale</code> as a value, and instead just scavenged it for its type, TypeScript compiled away the static import (in this example, TypeScript doesn’t generate any top-level exports at all), leaving us with both excellent type safety and a dynamically computed import.</p>&#13;
<div data-type="tip"><h1>TSC Setting: module</h1>&#13;
<p>TypeScript supports dynamic imports in <code>esnext</code> module mode only.<a data-primary="esnext module mode" data-type="indexterm" id="idm46304952849080"/> To use dynamic <a data-primary="tsconfig.json" data-secondary="module:esnext" data-type="indexterm" id="idm46304952848216"/>imports, set <code>{"module": "esnext"}</code> in your <em>tsconfig.json</em>’s <code>compilerOptions</code>. Jump ahead to <a data-type="xref" href="ch12.html#Running-TypeScript-on-the-Server">“Running TypeScript on the Server”</a> and <a data-type="xref" href="ch12.html#Running-TypeScript-in-the-Browser">“Running TypeScript in the Browser”</a> to learn more.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using CommonJS and AMD Code" data-type="sect2"><div class="sect2" id="idm46304952970888">&#13;
<h2>Using CommonJS and AMD Code</h2>&#13;
&#13;
<p>When consuming a JavaScript module that uses the CommonJS or AMD standard, you can simply import names from it, <a data-primary="imports" data-secondary="using CommonJS and AMD code" data-type="indexterm" id="idm46304952842536"/><a data-primary="exports" data-secondary="using CommonJS and AMD code" data-type="indexterm" id="idm46304952841592"/><a data-primary="modules" data-secondary="import, export" data-tertiary="using CommonJS and AMD code" data-type="indexterm" id="idm46304952840632"/><a data-primary="CommonJS module standard" data-secondary="consuming JavaScript module that uses" data-type="indexterm" id="idm46304952839400"/><a data-primary="AMD module standard" data-secondary="consuming JavaScript module that uses" data-type="indexterm" id="idm46304952838424"/>just like for ES2015 modules:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">something</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./a/legacy/commonjs/module'</code></pre>&#13;
&#13;
<p>By default, CommonJS default exports don’t interoperate with ES2015 default imports; to use a default export, you have to use a wildcard import:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">fs</code> <code class="nx">from</code> <code class="s1">'fs'</code>&#13;
<code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s1">'some/file.txt'</code><code class="p">)</code></pre>&#13;
&#13;
<p>To interoperate more <a data-primary="esModuleInterop TSC flag" data-type="indexterm" id="idm46304952816328"/><a data-primary="TSC compiler" data-secondary="esModuleInterop flag" data-type="indexterm" id="idm46304952815720"/>smoothly, set <code>{"esModuleInterop": true}</code> in your <em>tsconfig.json</em>’s <code>compilerOptions</code>. Now, you can leave out the wildcard:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="kr">import</code><code> </code><code class="nx">fs</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'fs'</code></strong><code>&#13;
</code><code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s1">'some/file.txt'</code><code class="p">)</code><code>&#13;
</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As I mentioned at the top of the chapter, even though this code compiles, that doesn’t mean it’ll work at runtime. Whichever module standard you use—<code>import</code>/<code>export</code>, CommonJS, AMD, UMD, <a data-primary="globals (browser)" data-type="indexterm" id="idm46304952723560"/>or browser globals—your module bundler and module loader have to be aware of that format so they can package up and split your code correctly at compile time, and load your code correctly at runtime. Head over to <a data-type="xref" href="ch12.html#typescript-in-production">Chapter 12</a> to learn more.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Module Mode Versus Script Mode" data-type="sect2"><div class="sect2" id="module-mode">&#13;
<h2>Module Mode Versus Script Mode</h2>&#13;
&#13;
<p>TypeScript parses each of your TypeScript files in one of two modes: <em>module mode</em> or <em>script mode</em>. <a data-primary="modules" data-secondary="import, export" data-tertiary="module mode or script mode" data-type="indexterm" id="idm46304952718552"/><a data-primary="module mode versus script mode" data-type="indexterm" id="idm46304952717304"/><a data-primary="script mode versus module mode" data-type="indexterm" id="idm46304952703640"/>It decides which mode to use based on a single heuristic: does your file have any <code>import</code>s or <code>export</code>s? If so, it uses module mode; otherwise, it uses script mode.<a data-primary="imports" data-secondary="module mode versus script mode" data-type="indexterm" id="idm46304952702136"/><a data-primary="exports" data-secondary="module mode versus script mode" data-type="indexterm" id="idm46304952701288"/></p>&#13;
&#13;
<p>Module mode is what we’ve used up to this point, and what you’ll use most of the time. In module mode, you use <code>import</code> and <code>import()</code> to require code from other files, and <code>export</code> to make code available to other files. If you use any third-party UMD modules (as a reminder, UMD modules try to use CommonJS, RequireJS, or browser globals, whichever the environment supports), you have to <code>import</code> them first, and can’t use their global exports directly.</p>&#13;
&#13;
<p>In script mode, any top-level variables you declare will be available to other files in your project without an explicit import, and you can safely consume global exports from third-party UMD modules without explicitly importing them first. A couple of use cases for script mode are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To quickly prototype browser code that you plan to compile to no module system at all (<code>{"module": "none"}</code> in your <em>tsconfig.json</em>) and include as raw <code>&lt;script /&gt;</code> tags in your HTML file.</p>&#13;
</li>&#13;
<li>&#13;
<p>To create type declarations (see <a data-type="xref" href="ch11.html#type-declarations">“Type Declarations”</a>)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You’ll almost always want to stick to module mode, which TypeScript will choose for you automatically as you write real-world code that <code>import</code>s other code and <code>export</code>s things for other files to use.<a data-primary="modules" data-startref="ix_mods" data-type="indexterm" id="idm46304952691448"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Namespaces" data-type="sect1"><div class="sect1" id="namespaces">&#13;
<h1>Namespaces</h1>&#13;
&#13;
<p>TypeScript gives us another way to encapsulate code: the <code>namespace</code> keyword. Namespaces will feel familiar to a lot of Java, C#, C++, PHP, and Python programmers.<a data-primary="namespace keyword" data-type="indexterm" id="idm46304952688104"/><a data-primary="namespaces" data-type="indexterm" id="ix_nmsp"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you’re coming from a language with namespaces, note that although namespaces are supported by TypeScript, they’re not the preferred way to encapsulate code; if you’re not sure whether to use namespaces or modules, choose modules.</p>&#13;
</div>&#13;
&#13;
<p>Namespaces abstract away the nitty-gritty details of how files are laid out in the filesystem; you don’t have to know that your <code>.mine</code> function lives in the <code>schemes/scams/bitcoin/apps</code> folder, and instead you can access it with a short, convenient namespace like <code>Schemes.Scams.Bitcoin.Apps.mine</code>.<sup><a data-type="noteref" href="ch10.html#idm46304952683240" id="idm46304952683240-marker">1</a></sup></p>&#13;
&#13;
<p>Say we have two files—a module to make HTTP GET requests, and a consumer that uses that module to make requests:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Get.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// App.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">App</code> <code class="p">{</code>&#13;
  <code class="nx">Network</code><code class="p">.</code><code class="nx">get</code><code class="o">&lt;</code><code class="nx">GitRepo</code><code class="o">&gt;</code><code class="p">(</code><code class="s1">'https://api.github.com/repos/Microsoft/typescript'</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A namespace must have a name (like <code>Network</code>), and it can export functions, variables, types, interfaces, or other namespaces.<a data-primary="namespaces" data-secondary="exports" data-type="indexterm" id="idm46304952643528"/><a data-primary="exports" data-secondary="namespace" data-type="indexterm" id="idm46304952642680"/> Any code in a <code>namespace</code> block that’s not explicitly exported is private to the block. Because namespaces can export namespaces, you can easily model nested namespaces. Let’s say our <code>Network</code> module is getting big, and we want to split it up into a few submodules. We can use namespaces to do that:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">HTTP</code> <code class="p">{</code>&#13;
    <code class="kr">export</code> <code class="kd">function</code> <code class="nx">get</code>	<code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code>	<code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">TCP</code> <code class="p">{</code>&#13;
    <code class="nx">listenOn</code><code class="p">(</code><code class="nx">port</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">Connection</code> <code class="p">{</code>&#13;
      <code class="c1">//...</code>&#13;
    <code class="p">}</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
  <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">UDP</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
  <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">IP</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>Now, all<a data-primary="namespaces" data-secondary="subnamespaces" data-type="indexterm" id="idm46304952619048"/> of our network-related utilities are in subnamespaces under <code>Network</code>. For example, we can now call <code>Network.HTTP.get</code> and <code>Network.TCP.listenOn</code> from any file. Like interfaces, namespaces can be augmented, making it convenient to split them across files. TypeScript will recursively merge identically named namespaces for us:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// HTTP.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">HTTP</code> <code class="p">{</code>&#13;
    <code class="kr">export</code> <code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// UDP.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">UDP</code> <code class="p">{</code>&#13;
    <code class="kr">export</code> <code class="kd">function</code> <code class="nx">send</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">packets</code>: <code class="kt">Buffer</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="k">void</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// MyApp.ts</code>&#13;
<code class="nx">Network</code><code class="p">.</code><code class="nx">HTTP</code><code class="p">.</code><code class="nx">get</code><code class="o">&lt;</code><code class="nx">Dog</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">(</code><code class="s1">'http://url.com/dogs'</code><code class="p">)</code>&#13;
<code class="nx">Network</code><code class="p">.</code><code class="nx">UDP</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'http://url.com/cats'</code><code class="p">,</code> <code class="k">new</code> <code class="nx">Buffer</code><code class="p">(</code><code class="mi">123</code><code class="p">))</code></pre>&#13;
&#13;
<p>If you end up with long namespace hierarchies, you can use <em>aliases</em> to shorten them for convenience. <a data-primary="type aliases" data-secondary="for namespaces" data-type="indexterm" id="idm46304952555144"/><a data-primary="namespaces" data-secondary="long, using aliases to shorten" data-type="indexterm" id="idm46304952407896"/>Note that despite the similar syntax, destructuring (like you do when importing ES2015 modules) is not supported for aliases:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// A.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">A</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">B</code> <code class="p">{</code>&#13;
    <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">C</code> <code class="p">{</code>&#13;
      <code class="kr">export</code> <code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="mi">3</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// MyApp.ts</code>&#13;
<code class="kr">import</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">A</code><code class="p">.</code><code class="nx">B</code><code class="p">.</code><code class="nx">C</code><code class="p">.</code><code class="nx">d</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">e</code> <code class="o">=</code> <code class="nx">d</code> <code class="o">*</code> <code class="mi">3</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collisions" data-type="sect2"><div class="sect2" id="idm46304952405944">&#13;
<h2>Collisions</h2>&#13;
&#13;
<p>Collisions between identically named exports<a data-primary="namespaces" data-secondary="collisions" data-type="indexterm" id="idm46304952291720"/> are not allowed:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// HTTP.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">request</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// HTTP2.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="c1">// Error TS2393: Duplicate function implementation.</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">request</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The exception to the no-collisions rule is overloaded ambient function declarations, which<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2393" data-type="indexterm" id="idm46304952354200"/><a data-primary="overloaded ambient function declarations" data-type="indexterm" id="idm46304952264888"/><a data-primary="functions" data-secondary="overloaded ambient function declarations" data-type="indexterm" id="idm46304952264120"/> you can use to refine function types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// HTTP.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">request</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// HTTP2.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">request</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">priority</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// HTTPS.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Network</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">request</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">url</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">algo</code><code class="o">:</code> <code class="s1">'SHA1'</code> <code class="o">|</code> <code class="s1">'SHA256'</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Compiled Output" data-type="sect2"><div class="sect2" id="idm46304952241912">&#13;
<h2>Compiled Output</h2>&#13;
&#13;
<p>Unlike imports and exports, namespaces don’t respect your <em>tsconfig.json</em>’s <code>module</code> setting, and always compile to global variables.<a data-primary="namespaces" data-secondary="compiled output" data-type="indexterm" id="idm46304952176920"/><a data-primary="module setting (tsconfig.json)" data-type="indexterm" id="idm46304952175944"/><a data-primary="global namespace" data-type="indexterm" id="idm46304952175304"/><a data-primary="TSC compiler" data-secondary="namespace output" data-type="indexterm" id="idm46304952174632"/> Let’s peek behind the veil to see what the generated output looks like. Say we have the following module:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Flowers.ts</code>&#13;
<code class="nx">namespace</code> <code class="nx">Flowers</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">give</code><code class="p">(</code><code class="nx">count</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">count</code> <code class="o">+</code> <code class="s1">' flowers'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Running it through <code>TSC</code>, the generated JavaScript output looks like this:</p>&#13;
<pre data-code-language="js" data-type="programlisting">&#13;
<code class="kd">let</code><code> </code><code class="nx">Flowers</code><code>&#13;
</code><code class="p">(</code><code class="kd">function</code><code> </code><code class="p">(</code><code class="nx">Flowers</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_namespaces_modules_CO1-1" id="co_namespaces_modules_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="kd">function</code><code> </code><code class="nx">give</code><code class="p">(</code><code class="nx">count</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="nx">count</code><code> </code><code class="o">+</code><code> </code><code class="s1">' flowers'</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">Flowers</code><code class="p">.</code><code class="nx">give</code><code> </code><code class="o">=</code><code> </code><code class="nx">give</code><code> </code><a class="co" href="#callout_namespaces_modules_CO1-2" id="co_namespaces_modules_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">(</code><code class="nx">Flowers</code><code> </code><code class="o">||</code><code> </code><code class="p">(</code><code class="nx">Flowers</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="p">}</code><code class="p">)</code><code class="p">)</code><code> </code><a class="co" href="#callout_namespaces_modules_CO1-3" id="co_namespaces_modules_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code></pre>&#13;
&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_namespaces_modules_CO1-1" id="callout_namespaces_modules_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>Flowers</code> is declared within an IIFE—a function that calls itself immediately—to create a closure and prevent variables that weren’t explicitly exported from leaking out of the <code>Flowers</code> module.</p></dd>&#13;
<dt><a class="co" href="#co_namespaces_modules_CO1-2" id="callout_namespaces_modules_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>TypeScript assigns the <code>give</code> function that we exported to the <code>Flowers</code> namespace.</p></dd>&#13;
<dt><a class="co" href="#co_namespaces_modules_CO1-3" id="callout_namespaces_modules_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>If the <code>Flowers</code> namespace is already globally defined, then TypeScript augments it (<code>Flowers</code>); otherwise, TypeScript creates and augments that newly created namespace (<code>Flowers = {}</code>).</p></dd>&#13;
</dl>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304951990872">&#13;
<h5>Prefer Modules over Namespaces When Possible</h5>&#13;
<p>Prefer regular modules (the <code>import</code> and <code>export</code> kind) over namespaces as a way to more closely stick to JavaScript standards and make your dependencies more explicit.<a data-primary="namespaces" data-secondary="preferring modules over" data-type="indexterm" id="idm46304951988952"/><a data-primary="modules" data-secondary="preferring over namespaces" data-type="indexterm" id="idm46304951988104"/></p>&#13;
&#13;
<p>Explicit dependencies have lots of benefits for readability, enforcing module isolation (because namespaces are automatically merged, but modules are not), and static analysis, which matters for big frontend projects where stripping out dead code and splitting your compiled code into multiple files is crucial for <span class="keep-together">performance</span>.</p>&#13;
&#13;
<p>When running TypeScript programs in a NodeJS environment,<a data-primary="NodeJS" data-secondary="preferring modules over namespaces" data-type="indexterm" id="idm46304951985528"/> modules are also the clear choice because of NodeJS’s built-in support for CommonJS.<a data-primary="browsers" data-secondary="preferring modules over namespaces" data-type="indexterm" id="idm46304951984552"/> In browser environments, some programmers prefer namespaces for simplicity, but for medium- to large-sized projects, try to stick to modules over namespaces.<a data-primary="namespaces" data-startref="ix_nmsp" data-type="indexterm" id="idm46304951983400"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Declaration Merging" data-type="sect1"><div class="sect1" id="namespace-merging">&#13;
<h1>Declaration Merging</h1>&#13;
&#13;
<p>So far we’ve touched on three types of merging<a data-primary="declaration merging" data-type="indexterm" id="ix_decmrg"/><a data-primary="values" data-secondary="merging values and types" data-type="indexterm" id="idm46304951979960"/><a data-primary="types" data-secondary="merging types and values" data-type="indexterm" id="idm46304951979112"/><a data-primary="namespaces" data-secondary="merging" data-type="indexterm" id="idm46304951978264"/> that TypeScript does for us:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Merging values and types, so that the same name can refer to either a value or a type depending how we use it (see <a data-type="xref" href="ch06.html#companion-objects">“Companion Object Pattern”</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Merging multiple namespaces into one<a data-primary="interfaces" data-secondary="merging" data-type="indexterm" id="idm46304951974760"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Merging multiple interfaces into one (see <a data-type="xref" href="ch05.html#interface-merging">“Declaration Merging”</a>)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As you might have intuited, these are three special cases of a much more general TypeScript behavior. TypeScript has a rich set of behavior for merging different kinds of names, unlocking all sorts of patterns that can otherwise be difficult to express (see <a data-type="xref" href="#declaration-merging-table">Table 10-1</a>).</p>&#13;
<table id="declaration-merging-table">&#13;
<caption><span class="label">Table 10-1. </span>Can the declaration be merged?</caption>&#13;
<tbody>&#13;
<tr>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
<th/>&#13;
<td>To</td>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td/>&#13;
<td/>&#13;
<td><p>Value</p></td>&#13;
<td><p>Class</p></td>&#13;
<td><p>Enum</p></td>&#13;
<td><p>Function</p></td>&#13;
<td><p>Types alias</p></td>&#13;
<td><p>Interface</p></td>&#13;
<td><p>Namespace</p></td>&#13;
<td><p>Module</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td/>&#13;
<td><p>Value</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p> — </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td/>&#13;
<td><p>Class</p></td>&#13;
<td><p> — </p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p> — </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td/>&#13;
<td><p>Enum</p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p> — </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>From</p></td>&#13;
<td><p>Function</p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p> — </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td/>&#13;
<td><p>Type alias</p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>No</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p> — </p></td>&#13;
</tr>&#13;
<tr>&#13;
&#13;
<td/>&#13;
<td><p>Interface</p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p> — </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td/>&#13;
<td><p>Namespace</p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p>Yes</p></td>&#13;
<td><p> — </p></td>&#13;
</tr>&#13;
<tr>&#13;
<td/>&#13;
<td><p>Module</p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p> — </p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>This means that if, for example, you declare a value and a type alias in the same scope, TypeScript will allow it, and infer which one you meant—the type or the value—from whether you use the name in a value or a type position.<a data-primary="companion object pattern" data-type="indexterm" id="idm46304951910088"/> This is what lets us implement the pattern described in <a data-type="xref" href="ch06.html#companion-objects">“Companion Object Pattern”</a>. It also means that you can use an interface and a namespace to implement companion objects—you’re not limited to just a value and a type alias. Or you can take advantage of module merging to augment a third-party module declaration (more on this in <a data-type="xref" href="app04.html#extending-a-module">“Extending a Module”</a>). Or you can add static methods to an enum by merging that enum with a namespace (try it!).</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304951907160">&#13;
<h5>The moduleResolution Flag</h5>&#13;
<p>Eagle-eyed readers may notice the <code>moduleResolution</code> flag available in their <em>tsconfig.json</em>. <a data-primary="moduleResolution TSC flag" data-type="indexterm" id="idm46304951905064"/><a data-primary="TSC compiler" data-secondary="moduleResolution flag" data-type="indexterm" id="idm46304951904360"/>This flag controls the algorithm TypeScript uses to resolve module names in your application. The flag supports two modes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>node</code>: Always use this mode.<a data-primary="node mode (moduleResolution flag)" data-type="indexterm" id="idm46304951901320"/> It resolves modules using the same algorithm that NodeJS uses.<a data-primary="paths (module)" data-type="indexterm" id="idm46304951900520"/> Modules prefixed with a <code>.</code>, <code>/</code>, or <code>~</code> (like <code>./my/file</code>) are resolved from the local filesystem, either relative to the current file, or using an absolute path (relative to your <em>/</em> directory, or whatever your <em>tsconfig.json</em>’s <code>baseUrl</code> is set to), depending on the prefix you use. TypeScript loads module paths that don’t have a prefix from your <em>node modules</em> folder, the same as NodeJS. TypeScript builds on NodeJS’s resolution strategy in two ways:</p>&#13;
<ol>&#13;
<li>&#13;
<p>In addition to the <code>main</code> field in a package’s <em>package.json</em> that NodeJS looks at to find the default importable file in a directory, TypeScript also looks at the TypeScript-specific <code>types</code> property (more on that in <a data-type="xref" href="ch11.html#type-lookup">“Type Lookup for JavaScript”</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>When importing a file with an unspecified extension, TypeScript first looks for a file with that name and a <em>.ts</em> extension, followed by <em>.tsx</em>, <em>.d.ts</em>, and finally <em>.js</em>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</li>&#13;
<li>&#13;
<p><code>classic</code>: You should never use this mode.<a data-primary="classic mode (moduleResolution flag)" data-type="indexterm" id="idm46304951888360"/> In this mode, relative paths are resolved like in <code>node</code> mode, but for unprefixed names, TypeScript will look for a file with the given name in the current folder, then walk up the directory tree a folder at a time until it finds a matching file. This is really surprising behavior for anyone coming from the NodeJS or JavaScript world, and does not interoperate well with other build tools.<a data-primary="declaration merging" data-startref="ix_decmrg" data-type="indexterm" id="idm46304951886760"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304951885272">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we covered TypeScript’s module system, starting with a brief history of JavaScript module systems, ES2015 modules and safely lazy-loading code with dynamic imports, interoperating with CommonJS and AMD modules, and module mode versus script mode. We then covered namespaces, namespace merging, and how TypeScript’s declaration merging works.</p>&#13;
&#13;
<p>As you develop applications in TypeScript, try hard to stick to ES2015 modules. TypeScript doesn’t care which module system you use, but it will make it easier to integrate with build tooling (see <a data-type="xref" href="ch12.html#typescript-in-production">Chapter 12</a> to learn more).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercise" data-type="sect1"><div class="sect1" id="idm46304951881944">&#13;
<h1>Exercise</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Play around with declaration merging, to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Reimplement companion objects (from <a data-type="xref" href="ch06.html#companion-objects">“Companion Object Pattern”</a>) using namespaces and interfaces, instead of values and types.</p>&#13;
</li>&#13;
<li>&#13;
<p>Add static methods to an enum.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304952683240"><sup><a href="ch10.html#idm46304952683240-marker">1</a></sup> I really hope this joke ages well, and I don’t end up regretting not investing in Bitcoin.</p></div></div></section></body></html>