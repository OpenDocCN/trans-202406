<html><head></head><body><section data-pdf-bookmark="Chapter 9. Suspense" data-type="chapter" epub:type="chapter"><div class="chapter" id="suspense">&#13;
<h1><span class="label">Chapter 9. </span>Suspense</h1>&#13;
&#13;
&#13;
<p>This<a data-primary="Suspense component" data-secondary="benefits and drawbacks of" data-type="indexterm" id="idm45901623974056"/> is the least important chapter in this book. At least, that’s what we’ve been told by the React team. They didn’t specifically say, “this is the least important chapter, don’t write it.” They’ve only issued a series of tweets warning educators and evangelists that much of their work in this area will very soon be outdated. All of this will change.</p>&#13;
&#13;
<p>It could be said that the work the React team has done with Fiber, Suspense, and concurrent mode represents the future of web development. This work may change the way browsers interpret JavaScript. That sounds pretty important. We’re saying that this is the least important chapter in this book because the community hype for Suspense is high; we need to say it to balance out your expectations. The APIs and patterns that make up Suspense are not the single overarching theory that defines how all things large and small should operate.</p>&#13;
&#13;
<p>Suspense is a just a feature. You may not ever need to use it. It’s being designed to solve specific problems that Facebook experiences working at scale. We don’t all have the same problems as Facebook, so we may want to think twice before reaching for those tools as the solution to all our problems. They may unnecessarily introduce complexity where complexity is not needed. Plus, this is all going to change. Concurrent mode is an experimental feature, and the React team has issued stern warnings about trying to use it in production. In fact, most of these concepts involve using hooks. If you don’t see yourself developing custom hooks on a daily basis, you’ll probably never need to know about these features. Much of the mechanics involving Suspense can be abstracted away in hooks.</p>&#13;
&#13;
<p>In light of these three paragraphs of downplay, the concepts covered in this chapter are exciting. If used correctly, they could someday help us create better user experiences. If you own or maintain a React library of hooks and/or components, you may find these concepts valuable. They’ll help you fine-tune your custom hooks to allow for better feedback and prioritization.</p>&#13;
&#13;
<p>In this chapter, we’ll build another small app to demonstrate some of these features. We’ll essentially rebuild the app from <a data-type="xref" href="ch08.html#incorporating-data">Chapter 8</a>, but this time with a little more structure. For example, we’ll be using a <code>SiteLayout</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">SiteLayout</code><code class="p">({</code>&#13;
  <code class="nx">children</code><code class="p">,</code>&#13;
  <code class="nx">menu</code> <code class="o">=</code> <code class="nx">c</code> <code class="o">=&gt;</code> <code class="kc">null</code>&#13;
<code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"site-container"</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">menu</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">children</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>SiteLayout</code> will rendered within the <code>App</code> component to help us compose our UI:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">SiteLayout</code> <code class="nx">menu</code><code class="o">=</code><code class="p">{</code><code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">Menu</code><code class="o">&lt;</code><code class="err">/p&gt;}&gt;</code>&#13;
      <code class="o">&lt;&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">Callout</code><code class="o">&gt;</code><code class="nx">Callout</code><code class="o">&lt;</code><code class="err">/Callout&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Contents</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">This</code> <code class="nx">is</code> <code class="nx">the</code> <code class="nx">main</code> <code class="nx">part</code> <code class="k">of</code> <code class="nx">the</code> <code class="nx">example</code> <code class="nx">layout</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/SiteLayout&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This component will be used to give our layout some style, as shown in <a data-type="xref" href="#fig0901">Figure 9-1</a>.</p>&#13;
&#13;
<p>Specifically, it will allow us to clearly see where and when specific components are rendered.</p>&#13;
&#13;
<figure><div class="figure" id="fig0901">&#13;
<img alt="Sample layout" src="assets/lrc2_0901.png"/>&#13;
<h6><span class="label">Figure 9-1. </span>Sample layout</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Error Boundaries" data-type="sect1"><div class="sect1" id="error-boundaries">&#13;
<h1>Error Boundaries</h1>&#13;
&#13;
<p>Thus<a data-primary="Suspense component" data-secondary="error boundaries" data-type="indexterm" id="Serrorb09"/><a data-primary="error boundaries" data-type="indexterm" id="errorb09"/> far, we haven’t done the best job with handling errors. An error thrown anywhere in our component tree will take down the entire application. Larger component trees only further complicate our project and complicate debugging it. Sometimes, it can be hard to pinpoint where an error has occurred, especially when they occur within components that we didn’t write.</p>&#13;
&#13;
<p>Error boundaries are components that can be used to prevent errors from crashing the entire app. They also allow us to render sensible error messages in production. Because errors can be handled by a single component, they could potentially track errors within the application and report them to an issue management system.</p>&#13;
&#13;
<p>Currently, the only way to make an error boundary component is to use a class component. Like most topics in this chapter, this too will eventually change. In the future, creating error boundaries could be possible with a hook or some other solution that doesn’t require creating a class. For now, here’s an example of an <code>ErrorBoundary</code> <span class="keep-together">component</span>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">Component</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="nx">ErrorBoundary</code> <code class="kr">extends</code> <code class="nx">Component</code> <code class="p">{</code>&#13;
  <code class="nx">state</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">error</code><code class="o">:</code> <code class="kc">null</code> <code class="p">};</code>&#13;
&#13;
  <code class="kr">static</code> <code class="nx">getDerivedStateFromError</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">error</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">error</code> <code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">;</code>&#13;
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">children</code><code class="p">,</code> <code class="nx">fallback</code> <code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code>&#13;
&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="k">return</code> <code class="o">&lt;</code><code class="nx">fallback</code> <code class="nx">error</code><code class="o">=</code><code class="p">{</code><code class="nx">error</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="nx">children</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is a class component. It stores state differently, and it doesn’t use hooks. Instead, it has access to specific methods that are invoked during different times throughout the component life cycle. <code>getDerivedStateFromError</code> is one of those methods. It is invoked when an error occurs anywhere within the <code>children</code> during the render process. When an error occurs, the value for <code>state.error</code> is set. Where there’s an error, the <code>fallback</code> component is rendered, and that error is passed to the component as a property.</p>&#13;
&#13;
<p>Now we can use this component in our tree to capture errors and render a <code>fallback</code> component if they occur. For example, we could wrap our entire application with an error boundary:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">ErrorScreen</code><code class="p">({</code> <code class="nx">error</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="c1">//</code>&#13;
  <code class="c1">// Here you can handle or track the error before rendering the message</code>&#13;
  <code class="c1">//</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"error"</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h3</code><code class="o">&gt;</code><code class="nx">We</code> <code class="nx">are</code> <code class="nx">sorry</code><code class="p">...</code> <code class="nx">something</code> <code class="nx">went</code> <code class="nx">wrong</code><code class="o">&lt;</code><code class="err">/h3&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">We</code> <code class="nx">cannot</code> <code class="nx">process</code> <code class="nx">your</code> <code class="nx">request</code> <code class="nx">at</code> <code class="k">this</code> <code class="nx">moment</code><code class="p">.</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">ERROR</code><code class="o">:</code> <code class="p">{</code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nx">ErrorBoundary</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="nx">ErrorScreen</code><code class="p">}</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="o">/&gt;</code>&#13;
<code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;;</code></pre>&#13;
&#13;
<p>The <code>ErrorScreen</code> provides a gentle message for our users that an error has occurred. It renders some details about the error. It also gives us a place to potentially track errors that occur anywhere within our app. If an error does occur within the app, this component will be rendered instead of a black screen. We can make this component look nice with a little CSS:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="css" data-type="programlisting"><code class="nc">.error</code> <code class="p">{</code>&#13;
  <code class="k">background-color</code><code class="o">:</code> <code class="m">#efacac</code><code class="p">;</code>&#13;
  <code class="k">border</code><code class="o">:</code> <code class="nb">double</code> <code class="m">4px</code> <code class="nb">darkred</code><code class="p">;</code>&#13;
  <code class="k">color</code><code class="o">:</code> <code class="nb">darkred</code><code class="p">;</code>&#13;
  <code class="k">padding</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To test this out we’re going to create a component we can use to intentionally cause errors. <code>BreakThings</code> always throws an error:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">BreakThings</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"We intentionally broke something"</code><code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Error boundaries can be composed. Sure, we wrapped the <code>App</code> component in an <code>ErrorBoundary</code>, but we can also wrap individual components within the <code>App</code> with Error:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting">  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">SiteLayout</code>&#13;
      <code class="nx">menu</code><code class="o">=</code><code class="p">{</code>&#13;
        <code class="o">&lt;</code><code class="nx">ErrorBoundary</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="nx">ErrorScreen</code><code class="p">}</code><code class="o">&gt;</code>&#13;
          <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">Site</code> <code class="nx">Layout</code> <code class="nx">Menu</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
          <code class="o">&lt;</code><code class="nx">BreakThings</code> <code class="o">/&gt;</code>&#13;
        <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
      <code class="p">}</code>&#13;
    <code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ErrorBoundary</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="nx">ErrorScreen</code><code class="p">}</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">Callout</code><code class="o">&gt;</code><code class="nx">Callout</code><code class="o">&lt;</code><code class="nx">BreakThings</code> <code class="o">/&gt;&lt;</code><code class="err">/Callout&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ErrorBoundary</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="nx">ErrorScreen</code><code class="p">}</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Contents</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="k">this</code> <code class="nx">is</code> <code class="nx">the</code> <code class="nx">main</code> <code class="nx">part</code> <code class="k">of</code> <code class="nx">the</code> <code class="nx">example</code> <code class="nx">layout</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/SiteLayout&gt;</code></pre>&#13;
&#13;
<p>Each <code>ErrorBoundary</code> will render a <code>fallback</code> if an error occurs anywhere within their children. In this case, we used the <code>BreakThings</code> component in the menu and within the <code>Callout</code>. This would result in rendering the <code>ErrorScreen</code> twice, as we can see in <a data-type="xref" href="#fig0902">Figure 9-2</a>.</p>&#13;
&#13;
<p>We can see that the <code>ErrorBoundaries</code> are rendered in place. Notice that the two errors that have occurred have been contained to their regions. The boundaries are like walls that prevent these errors from attacking the rest of the application. Despite intentionally throwing two errors, the contents are still rendered without issue.</p>&#13;
&#13;
<figure><div class="figure" id="fig0902">&#13;
<img alt="Error Boundaries" src="assets/lrc2_0902.png"/>&#13;
<h6><span class="label">Figure 9-2. </span>ErrorBoundaries</h6>&#13;
</div></figure>&#13;
&#13;
<p>In <a data-type="xref" href="#fig0903">Figure 9-3</a>, we can observe what happens when we move the <code>BreakThings</code> component to only the contents.</p>&#13;
&#13;
<figure><div class="figure" id="fig0903">&#13;
<img alt="error" src="assets/lrc2_0903.png"/>&#13;
<h6><span class="label">Figure 9-3. </span>Error</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now we see the menu and the callout being rendered without issue, but the contents has rendered an error to notify the user that an error has occurred.</p>&#13;
&#13;
<p>Inside of the <code>render</code> method in the <code>ErrorBoundary</code> class component, we can make the <code>fallback</code> property optional. When it’s not included, we’ll simply use our <code>ErrorScreen</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">error</code> <code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">;</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">children</code> <code class="p">}</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code>&#13;
&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">error</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">fallback</code><code class="p">)</code> <code class="k">return</code> <code class="o">&lt;</code><code class="nx">ErrorScreen</code> <code class="nx">error</code><code class="o">=</code><code class="p">{</code><code class="nx">error</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="k">return</code> <code class="o">&lt;</code><code class="nx">fallback</code> <code class="nx">error</code><code class="o">=</code><code class="p">{</code><code class="nx">error</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
&#13;
  <code class="k">return</code> <code class="nx">children</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is a good solution for handling errors consistently across an application. Now, we just have to wrap specific parts of our component tree with an <code>ErrorBoundary</code> and let the component handle the rest:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;&amp;</code><code class="nx">lt</code><code class="p">;</code><code class="nx">Contents</code> <code class="o">/&amp;</code><code class="nx">gt</code><code class="p">;</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="k">this</code> <code class="nx">is</code> <code class="nx">the</code> <code class="nx">main</code> <code class="nx">part</code> <code class="k">of</code> <code class="nx">the</code> <code class="nx">example</code> <code class="nx">layout</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">BreakThings</code> <code class="o">/&gt;</code>&#13;
<code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code></pre>&#13;
&#13;
<p>Error boundaries are not only a good idea—they’re essential for retaining users in production, and they’ll prevent some small bug in a relatively unimportant component from bringing down the entire application.<a data-primary="" data-startref="errorb09" data-type="indexterm" id="idm45901623132472"/><a data-primary="" data-startref="Serrorb09" data-type="indexterm" id="idm45901623120040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Splitting" data-type="sect1"><div class="sect1" id="code-splitting">&#13;
<h1>Code Splitting</h1>&#13;
&#13;
<p>If<a data-primary="Suspense component" data-secondary="code splitting" data-tertiary="benefits of" data-type="indexterm" id="idm45901623117528"/><a data-primary="code splitting" data-secondary="benefits of" data-type="indexterm" id="idm45901623116248"/> the applications you’re working on are small now, chances are they won’t stay that way. A lot of the applications you work on will eventually contain massive codebases with hundreds, maybe even thousands, of components. Most of your users could be accessing your applications via their phones on potentially slow networks. They can’t wait for the entire codebase of your application to successfully download before React completes its first render.</p>&#13;
&#13;
<p><em>Code splitting</em> provides us with a way to split our codebase into manageable chunks and then load those chunks as they’re needed. To<a data-primary="Suspense component" data-secondary="code splitting" data-tertiary="example of" data-type="indexterm" id="idm45901623077752"/><a data-primary="code splitting" data-secondary="example of" data-type="indexterm" id="idm45901623076504"/> exemplify the power of code splitting, we’ll add a user agreement screen to our application:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Agreement</code><code class="p">({</code> <code class="nx">onAgree</code> <code class="o">=</code> <code class="nx">f</code> <code class="o">=&gt;</code> <code class="nx">f</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">Terms</code><code class="p">...</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">These</code> <code class="nx">are</code> <code class="nx">the</code> <code class="nx">terms</code> <code class="nx">and</code> <code class="nx">stuff</code><code class="p">.</code> <code class="nx">Do</code> <code class="nx">you</code> <code class="nx">agree</code><code class="o">?&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">onAgree</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">I</code> <code class="nx">agree</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Next, we’ll move the rest of our codebase from a component called <code>App</code> to a component called <code>Main</code>, and we’ll place that component in its own file:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ErrorBoundary</code> <code class="nx">from</code> <code class="s2">"./ErrorBoundary"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">SiteLayout</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">children</code><code class="p">,</code> <code class="nx">menu</code> <code class="o">=</code> <code class="nx">c</code> <code class="o">=&gt;</code> <code class="kc">null</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"site-container"</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">menu</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">children</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Menu</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">p</code> <code class="nx">style</code><code class="o">=</code><code class="p">{{</code> <code class="nx">color</code><code class="o">:</code> <code class="s2">"white"</code> <code class="p">}}</code><code class="o">&gt;</code><code class="nx">TODO</code><code class="o">:</code> <code class="nx">Build</code> <code class="nx">Menu</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
  <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Callout</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">children</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"callout"</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">children</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Main</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">SiteLayout</code> <code class="nx">menu</code><code class="o">=</code><code class="p">{</code><code class="o">&lt;</code><code class="nx">Menu</code> <code class="o">/&gt;</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">Callout</code><code class="o">&gt;</code><code class="nx">Welcome</code> <code class="nx">to</code> <code class="nx">the</code> <code class="nx">site</code><code class="o">&lt;</code><code class="err">/Callout&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">TODO</code><code class="o">:</code> <code class="nx">Home</code> <code class="nx">Page</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">Complete</code> <code class="nx">the</code> <code class="nx">main</code> <code class="nx">contents</code> <code class="k">for</code> <code class="k">this</code> <code class="nx">home</code> <code class="nx">page</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/SiteLayout&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So <code>Main</code> is where the current site layout is rendered. Now we’ll modify the <code>App</code> component to render the <code>Agreement</code> until the user agrees to it. When they agree, we’ll unmount the <code>Agreement</code> component and render the <code>Main</code> website component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">Agreement</code> <code class="nx">from</code> <code class="s2">"./Agreement"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">Main</code> <code class="nx">from</code> <code class="s2">"./Main"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="s2">"./SiteLayout.css"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">agree</code><code class="p">,</code> <code class="nx">setAgree</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">agree</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="o">&lt;</code><code class="nx">Agreement</code> <code class="nx">onAgree</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setAgree</code><code class="p">(</code><code class="kc">true</code><code class="p">)}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">Main</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Initially, the only component that’s rendered is the <code>Agreement</code> component. Once the user agrees, the value for <code>agree</code> changes to <code>true</code>, and the <code>Main</code> component is rendered. The issue is that all code for the <code>Main</code> component and all of its children is packaged into a single JavaScript file: the bundle. That means that users have to wait for this codebase to download completely before the <code>Agreement</code> component is initially rendered.</p>&#13;
&#13;
<p>We can put off loading the main component until it has rendered by declaring it using <code>React.lazy</code> instead of initially importing it:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Main</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">lazy</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="kr">import</code><code class="p">(</code><code class="s2">"./Main"</code><code class="p">));</code></pre>&#13;
&#13;
<p>We’re telling React to wait to load the codebase for the <code>Main</code> component until it’s initially rendered. When it is rendered, it will be imported at that time using the <code>import</code> function.</p>&#13;
&#13;
<p>Importing code during runtime is just like loading anything else from the internet. First, the request for the JavaScript code is pending. Then it’s either successful, and a JavaScript file is returned, or it fails, causing an error to occur. Just like we need to notify a user that we’re in the process of loading data, we’ll need to let the user know that we’re in the process of loading code.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introducing: The Suspense Component" data-type="sect2"><div class="sect2" id="introducing-the-suspense-component">&#13;
<h2>Introducing: The Suspense Component</h2>&#13;
&#13;
<p>Once<a data-primary="Suspense component" data-secondary="code splitting" data-tertiary="how it works" data-type="indexterm" id="idm45901622625880"/><a data-primary="code splitting" data-secondary="Suspense component" data-type="indexterm" id="idm45901622624600"/> again, we find ourselves in a situation where we’re managing an asynchronous request. This time, we have the <code>Suspense</code> component to help us out. The <code>Suspense</code> component works much like the <code>ErrorBoundary</code> component. We wrap it around specific components in our tree. Instead of falling back to an error message when an error occurs, the <code>Suspense</code> component renders a loading message when lazy loading occurs.</p>&#13;
&#13;
<p>We can modify the app to lazy load the <code>Main</code> component with the following code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code><code class="p">,</code> <code class="nx">Suspense</code><code class="p">,</code> <code class="nx">lazy</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">Agreement</code> <code class="nx">from</code> <code class="s2">"./Agreement"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ClimbingBoxLoader</code> <code class="nx">from</code> <code class="s2">"react-spinners/ClimbingBoxLoader"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Main</code> <code class="o">=</code> <code class="nx">lazy</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="kr">import</code><code class="p">(</code><code class="s2">"./Main"</code><code class="p">));</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">agree</code><code class="p">,</code> <code class="nx">setAgree</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">agree</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="o">&lt;</code><code class="nx">Agreement</code> <code class="nx">onAgree</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setAgree</code><code class="p">(</code><code class="kc">true</code><code class="p">)}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">Suspense</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="o">&lt;</code><code class="nx">ClimbingBoxLoader</code> <code class="o">/&gt;</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">Main</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/Suspense&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now the app initially only loads the codebase for <code>React</code>, the <code>Agreement</code> component, and the <code>ClimbingBoxLoader</code>. React will hold off on loading the <code>Main</code> component until the user agrees to the agreement.</p>&#13;
&#13;
<p>The <code>Main</code> component has been wrapped in a <code>Suspense</code> component. As soon as the user agrees to the agreement, we start loading the codebase for the <code>Main</code> component. Because the request for this codebase is pending, the <code>Suspense</code> component will render the <code>ClimbingBoxLoader</code> in its place until the codebase has successfully loaded. Once that happens, the <code>Suspense</code> component will unmount the <code>ClimbingBoxLoader</code> and render the <code>Main</code> component.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>React Spinners<a data-primary="React Spinners library" data-type="indexterm" id="idm45901622454440"/> is a library of animated loading spinners that indicate that something is loading or that the app is working. For the remainder of this chapter, we’ll be sampling different loader components from this library. Make sure you install this library: <code>npm i react-spinners</code>.</p>&#13;
</div>&#13;
&#13;
<p>What happens when the internet connection goes down before trying to load the <code>Main</code> component? Well, we’ll have an error on our hands. We can handle that by wrapping our <code>Suspense</code> component within an <code>ErrorBoundary</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">ErrorBoundary</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="nx">ErrorScreen</code><code class="p">}</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">Suspense</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="o">&lt;</code><code class="nx">ClimbingBoxLoader</code> <code class="o">/&gt;</code><code class="p">}</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nx">Main</code> <code class="o">/&gt;</code>&#13;
  <code class="o">&lt;</code><code class="err">/Suspense&gt;</code>&#13;
<code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code></pre>&#13;
&#13;
<p>The composition of these three components gives us a way to handle most asynchronous requests. We have a solution for pending: the <code>Suspense</code> component will render a loader animation while the request for the source code is pending. We have a solution for the failed state: if an error occurs while loading the <code>Main</code> component, it will be caught and handled by the <code>ErrorBoundary</code>. We even have a solution for success: if the request is successful, we’ll render the <code>Main</code> component.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Suspense with Data" data-type="sect2"><div class="sect2" id="suspense-with-data">&#13;
<h2>Using Suspense with Data</h2>&#13;
&#13;
<p>In<a data-primary="Suspense component" data-secondary="code splitting" data-tertiary="using Suspense with data" data-type="indexterm" id="idm45901622427512"/><a data-primary="code splitting" data-secondary="using Suspense with data" data-type="indexterm" id="idm45901622426376"/> the last chapter, we built a <code>useFetch</code> hook and a <code>Fetch</code> component to help us handle the three states involved with making a GitHub request: pending, success, and fail. That was our solution. We think it was pretty cool. However, in the last section, we handled these three states by elegantly composing the <code>ErrorBoundary</code> and <code>Suspense</code> components. That was for lazy loading JavaScript source code, but we can use the same pattern to help us load data.</p>&#13;
&#13;
<p>Let’s say we have a <code>Status</code> component that’s capable of rendering some sort of status message:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">loadStatus</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"success - ready"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Status</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">status</code> <code class="o">=</code> <code class="nx">loadStatus</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">status</code><code class="o">:</code> <code class="p">{</code><code class="nx">status</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This component invokes the <code>loadStatus</code> function to retrieve the current status message. We can render the <code>Status</code> component in our <code>App</code> component:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">Status</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we were to run this code as-is, we would see our successful status message, as shown in <a data-type="xref" href="#fig0904">Figure 9-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig0904">&#13;
<img alt="Success: everything works" src="assets/lrc2_0904.png"/>&#13;
<h6><span class="label">Figure 9-4. </span>Success: everything works</h6>&#13;
</div></figure>&#13;
&#13;
<p>When we rendered the <code>Status</code> component within the <code>App</code> component, we were good React developers because we wrapped the <code>Status</code> component inside of an error boundary. Now if something goes wrong while loading the status, the <code>ErrorBoundary</code> will fall back to the default error screen. To demonstrate this, let’s cause an error inside of the <code>loadStatus</code> function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">loadStatus</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"something went wrong"</code><code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now when we run our application, we see the expected output. The <code>ErrorBoundary</code> caught our error and rendered a message to the user instead (<a data-type="xref" href="#fig0905">Figure 9-5</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig0905">&#13;
<img alt="Fail: error boundary triggered" src="assets/lrc2_0905.png"/>&#13;
<h6><span class="label">Figure 9-5. </span>Fail: error boundary triggered</h6>&#13;
</div></figure>&#13;
&#13;
<p>So far, everything is working as suspected. We’ve composed the <code>Status</code> component inside of an <code>ErrorBoundary</code>, and the combination of these two components is handling two of the three promise states: success or rejected. “Rejected” is the official promise term for a failed or error state.</p>&#13;
&#13;
<p>We have two of the three states covered. What about the third state? Pending? That state can be triggered by throwing a promise:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">loadStatus</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">throw</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolves</code> <code class="o">=&gt;</code> <code class="kc">null</code><code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>If we throw a promise from the <code>loadStatus</code> function, we’ll see a special type of error in the browser (<a data-type="xref" href="#fig0906">Figure 9-6</a>).</p>&#13;
&#13;
<p>This error is telling us that a pending state was triggered, but there is no <code>Suspense</code> component configured somewhere higher in the tree. Whenever we throw a promise from a React app, we need a <code>Suspense</code> component to handle rendering a fallback:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">Suspense</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="o">&lt;</code><code class="nx">GridLoader</code> <code class="o">/&gt;</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">Status</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/Suspense&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="fig0906">&#13;
<img alt="Throw promise" src="assets/lrc2_0906.png"/>&#13;
<h6><span class="label">Figure 9-6. </span>Throw promise</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now we have the right component composition to handle all three states. The <code>loadStatus</code> function is still throwing a promise, but there’s now a <code>Suspense</code> component configured somewhere higher in the tree to handle it. When we throw the promise, we’re telling React that we’re waiting on a pending promise. React responds by rendering the fallback <code>GridLoader</code> component (<a data-type="xref" href="#fig0907">Figure 9-7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig0907">&#13;
<img alt="Grid Loader" src="assets/lrc2_0907.png"/>&#13;
<h6><span class="label">Figure 9-7. </span>GridLoader</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">When <code>loadStatus</code> successfully returns a result, we’ll render the <code>Status</code> component as planned. If something goes wrong (if <code>loadStatus</code> throws an error), we have it covered with an <code>ErrorBoundary</code>. When <code>loadStatus</code> throws a promise, we trigger the pending state, which is handled by the <code>Suspense</code> component.</p>&#13;
&#13;
<p>This is a pretty cool pattern, but wait…what do you mean, “throw a promise”?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Throwing Promises" data-type="sect2"><div class="sect2" id="throwing-promises">&#13;
<h2>Throwing Promises</h2>&#13;
&#13;
<p>In<a data-primary="promises" data-secondary="code splitting and" data-type="indexterm" id="idm45901622126728"/><a data-primary="Suspense component" data-secondary="code splitting" data-tertiary="throwing promises" data-type="indexterm" id="idm45901622125720"/><a data-primary="code splitting" data-secondary="throwing promises" data-type="indexterm" id="idm45901622124504"/> JavaScript, the <code>throw</code> keyword is technically for errors. You’ve probably used it many times in your own code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"inspecting errors"</code><code class="p">);</code></pre>&#13;
&#13;
<p>This line of code causes an error. When this error goes unhandled, it crashes the whole app, as demonstrated in <a data-type="xref" href="#fig0908">Figure 9-8</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig0908">&#13;
<img alt="Throwing an error" src="assets/lrc2_0908.png"/>&#13;
<h6><span class="label">Figure 9-8. </span>Throwing an error</h6>&#13;
</div></figure>&#13;
&#13;
<p>The<a data-primary="Create React App" data-type="indexterm" id="idm45901622121768"/> error screen you see rendered in the browser is a development-mode feature of Create React App. Whenever you’re in development mode, unhandled errors are caught and displayed directly on the screen. If you close this screen by clicking on the “X” in the upper right-hand corner, you’ll see what your production users see when there’s an error: nothing, a blank, white screen.</p>&#13;
&#13;
<p>Unhandled errors are always visible in the console. All the red text we see in the console is information about the error we’ve thrown.</p>&#13;
&#13;
<p class="pagebreak-before">JavaScript is a pretty free-loving language. It lets us get away with a lot of stuff that we can’t get away with when using traditional typed languages. For example, in JavaScript, we can throw any type:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="k">throw</code> <code class="s2">"inspecting errors"</code><code class="p">;</code></pre>&#13;
&#13;
<p>Here, we’ve thrown a string. The browser will tell us that something has gone uncaught, but it’s not an error (<a data-type="xref" href="#fig0909">Figure 9-9</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig0909">&#13;
<img alt="Grid Loader" src="assets/lrc2_0909.png"/>&#13;
<h6><span class="label">Figure 9-9. </span>GridLoader</h6>&#13;
</div></figure>&#13;
&#13;
<p>This time, when we threw a string, the Create React App error screen wasn’t rendered inside the browser. React knows the difference between an error and a string.</p>&#13;
&#13;
<p>JavaScript lets us throw any type, which means we can throw a promise:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="k">throw</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolves</code> <code class="o">=&gt;</code> <code class="kc">null</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now the browser is telling us that something has gone uncaught. It’s not an error, it’s a promise, as shown in <a data-type="xref" href="#fig0910">Figure 9-10</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig0910">&#13;
<img alt="Throwing a promise" src="assets/lrc2_0910.png"/>&#13;
<h6><span class="label">Figure 9-10. </span>Throwing a promise</h6>&#13;
</div></figure>&#13;
&#13;
<p>To throw a promise within the React component tree, we’ll do so first in a <span class="keep-together"><code>loadStatus</code></span> function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">loadStatus</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"load status"</code><code class="p">);</code>&#13;
  <code class="k">throw</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolves</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolves</code><code class="p">,</code> <code class="mi">3000</code><code class="p">));</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>If we use this <code>loadStatus</code> function inside a React component, a promise is thrown, then somewhere farther up the tree is caught by the <code>Suspense</code> component. That’s right: JavaScript allows us to throw any type, which also means that we can catch any type.</p>&#13;
&#13;
<p>Consider the following example:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">safe</code><code class="p">(</code><code class="nx">loadStatus</code><code class="p">);</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">safe</code><code class="p">(</code><code class="nx">fn</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="nx">fn</code><code class="p">();</code>&#13;
  <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">error</code> <code class="k">instanceof</code> <code class="nb">Promise</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">error</code><code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">safe</code><code class="p">(</code><code class="nx">fn</code><code class="p">));</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
      <code class="k">throw</code> <code class="nx">error</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’re sending the <code>loadStatus</code> function a <code>safe</code> function, which makes <code>safe</code> a higher-order function. <code>loadStatus</code> becomes <code>fn</code> within the scope of the <code>safe</code> function. The <code>safe</code> function tries to invoke the <code>fn</code> that’s passed as the argument. In this case, <code>safe</code> tries to invoke <code>loadStatus</code>. When it does, <code>loadStatus</code> throws a promise, an intentional delay of three seconds. That promise is immediately caught and becomes <code>error</code> within the scope of the catch block. We can check to see if the <code>error</code> is a promise, and in this case, it is. Now we can wait for that promise to resolve and then attempt to call <code>safe</code> again with the same <code>loadStatus</code> function.</p>&#13;
&#13;
<p>What do we expect to happen when we invoke the <code>safe</code> function recursively with a function that creates a promise that causes a three-second delay? We get a delayed loop, as shown in <a data-type="xref" href="#fig0911">Figure 9-11</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig0911">&#13;
<img alt="An unfortunate loop" src="assets/lrc2_0911.png"/>&#13;
<h6><span class="label">Figure 9-11. </span>An unfortunate loop</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>safe</code> function is invoked, the promise is caught, we wait three seconds for the promise to resolve, then we call <code>safe</code> again with the same function, and the cycle starts all over again. Every three seconds, the string “load status” is printed to the console. How many times you watch that happen depends upon how patient you are.</p>&#13;
&#13;
<p>We didn’t make this endless recursive loop to test your patience; we made it to demonstrate a point. Watch what happens when we use this new <code>loadStatus</code> function in conjunction with our <code>Status</code> component from earlier:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">loadStatus</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"load status"</code><code class="p">);</code>&#13;
  <code class="k">throw</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolves</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolves</code><code class="p">,</code> <code class="mi">3000</code><code class="p">));</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Status</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">status</code> <code class="o">=</code> <code class="nx">loadStatus</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">status</code><code class="o">:</code> <code class="p">{</code><code class="nx">status</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">Suspense</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="o">&lt;</code><code class="nx">GridLoader</code> <code class="o">/&gt;</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">Status</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/Suspense&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because <code>loadStatus</code> is throwing a promise, the <code>GridLoader</code> animation renders on the screen. When you take a look at the console, the results are once again testing your patience (<a data-type="xref" href="#fig0912">Figure 9-12</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig0912">&#13;
<img alt="Suspense Recursion" src="assets/lrc2_0912.png"/>&#13;
<h6><span class="label">Figure 9-12. </span>Suspense recursion</h6>&#13;
</div></figure>&#13;
&#13;
<p>We see the same pattern as we did with the <code>safe</code> function. The <code>Suspense</code> component knows that a promise was thrown. It will render the <code>fallback</code> component. Then the <code>Suspense</code> component waits for the thrown promise to be resolved, just like the <code>safe</code> function did. Once resolved, the <code>Suspense</code> component rerenders the <code>Status</code> component. When <code>Status</code> renders again, it calls <code>loadStatus</code> and the whole process repeats itself. We see “load status” printed to the console, every three seconds, endlessly, <span class="keep-together">forever</span>.</p>&#13;
&#13;
<p>An endless loop is typically not the desired output. It isn’t for React, either. It’s important to know that, when we throw a promise, it’s caught by the <code>Suspense</code> component, and we enter into a <code>pending</code> state until the promise has been resolved.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building Suspenseful Data Sources" data-type="sect2"><div class="sect2" id="building-suspenseful-data-sources">&#13;
<h2>Building Suspenseful Data Sources</h2>&#13;
&#13;
<p>A<a data-primary="Suspense component" data-secondary="code splitting" data-tertiary="building Suspenseful data sources" data-type="indexterm" id="idm45901621749544"/><a data-primary="code splitting" data-secondary="building Suspenseful data sources" data-type="indexterm" id="idm45901621748200"/> Suspenseful data source needs to provide a function that handles all the states associated with loading data: pending, success, and error. The <code>loadStatus</code> function can only return or throw one type at a time. We need the <code>loadStatus</code> function to throw a promise when the data is loading, return a <code>response</code> when the data is successful, or throw an error if something goes wrong:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">loadStatus</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="k">throw</code> <code class="nx">error</code><code class="p">;</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">)</code> <code class="k">return</code> <code class="nx">response</code><code class="p">;</code>&#13;
  <code class="k">throw</code> <code class="nx">promise</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ll need a place to declare <code>error</code>, <code>response</code>, and <code>promise</code>. We also need to make sure that these variables are scoped appropriately and do not collide with other requests. The solution is to define <code>loadStatus</code> using a closure:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">loadStatus</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">error</code><code class="p">,</code> <code class="nx">promise</code><code class="p">,</code> <code class="nx">response</code><code class="p">;</code>&#13;
&#13;
  <code class="k">return</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="k">throw</code> <code class="nx">error</code><code class="p">;</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">)</code> <code class="k">return</code> <code class="nx">response</code><code class="p">;</code>&#13;
    <code class="k">throw</code> <code class="nx">promise</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">})();</code></pre>&#13;
&#13;
<p>This is a closure. The scope of the <code>error</code>, <code>promise</code>, and <code>response</code> are closed off from any code outside of the function where they’re defined. When we declare <code>loadStatus</code>, an anonymous function is declared and immediately invoked: <code>fn()</code> is the same as <code>(fn)()</code>. The value of <code>loadStatus</code> becomes the inner function that’s returned. The <code>loadStatus</code> function now has access to <code>error</code>, <code>promise</code>, and <code>response</code>, but the rest of our JavaScript world does not.</p>&#13;
&#13;
<p>Now all we need to do is handle the values for <code>error</code>, <code>response</code>, and <code>promise</code>. The <code>promise</code> will be pending for three seconds before it’s successfully resolved. When the <code>promise</code> resolves, the value for <code>response</code> will be set to “success.” We’ll catch any errors or promise rejections and use them to set the <code>error</code> value:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">loadStatus</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">error</code><code class="p">,</code> <code class="nx">response</code><code class="p">;</code>&#13;
  <code class="kr">const</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolves</code> <code class="o">=&gt;</code>&#13;
    <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolves</code><code class="p">,</code> <code class="mi">3000</code><code class="p">)</code>&#13;
  <code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">response</code> <code class="o">=</code> <code class="s2">"success"</code><code class="p">))</code>&#13;
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">error</code> <code class="o">=</code> <code class="nx">e</code><code class="p">));</code>&#13;
  <code class="k">return</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="k">throw</code> <code class="nx">error</code><code class="p">;</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">)</code> <code class="k">return</code> <code class="nx">response</code><code class="p">;</code>&#13;
    <code class="k">throw</code> <code class="nx">pending</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">})();</code></pre>&#13;
&#13;
<p>We created a promise that’s pending for three seconds. If the <code>loadStatus</code> function is invoked at any point during that time, the promise itself will be thrown. After the three seconds, the promise is successfully resolved and <code>response</code> is assigned a value. If you invoke <code>loadStatus</code> now, it will return the response: “success.” If something went wrong, then the <code>loadStatus</code> function would return the <code>error</code>.</p>&#13;
&#13;
<p>The <code>loadStatus</code> function is our Suspenseful data source. It is capable of communicating its state with the Suspense architecture. The inner workings of <code>loadStatus</code> are hardcoded. It always resolves the same three-second delay promise. However, the mechanics of handling <code>error</code>, <code>response</code>, and <code>promise</code> are repeatable. We can wrap any promise with this technique to produce suspenseful data sources.</p>&#13;
&#13;
<p>All we need to create a Suspenseful data source is a promise, so we can create a function that takes a promise as an argument and returns a Suspenseful data source. In this example, we call that function <code>createResource</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">resource</code> <code class="o">=</code> <code class="nx">createResource</code><code class="p">(</code><code class="nx">promise</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">resource</code><code class="p">.</code><code class="nx">read</code><code class="p">();</code></pre>&#13;
&#13;
<p>This code assumes that <code>createResource(promise)</code> will successfully create a <code>resource</code> object. This object has a <code>read</code> function, and we can invoke <code>read</code> as many times as we like. When the promise is resolved, <code>read</code> will return the resulting data. When the promise is pending, <code>read</code> will throw the <code>promise</code>. And if anything goes wrong, <code>read</code> will throw an error. This data source is ready to work with Suspense.</p>&#13;
&#13;
<p>The <code>createResource</code> function looks a lot like our anonymous function from before:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createResource</code><code class="p">(</code><code class="nx">pending</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">error</code><code class="p">,</code> <code class="nx">response</code><code class="p">;</code>&#13;
  <code class="nx">pending</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">response</code> <code class="o">=</code> <code class="nx">r</code><code class="p">)).</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">error</code> <code class="o">=</code> <code class="nx">e</code><code class="p">));</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">read</code><code class="p">()</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="k">throw</code> <code class="nx">error</code><code class="p">;</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">)</code> <code class="k">return</code> <code class="nx">response</code><code class="p">;</code>&#13;
      <code class="k">throw</code> <code class="nx">pending</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This function still closes off the values for <code>error</code> and <code>response</code>, but it allows consumers to pass in a promise as an argument called <code>pending</code>. When the pending promise is resolved, we capture the results with a <code>.then</code> function. If the promise is rejected, we’ll catch the error and use it to assign a value to the <code>error</code> variable.</p>&#13;
&#13;
<p>The <code>createResource</code> function returns a resource object. This object contains a function called <code>read</code>. If the promise is still pending, then <code>error</code> and <code>response</code> will be undefined. So <code>read</code> throws the promise. Invoking <code>read</code> when there’s a value for <code>error</code> will cause that <code>error</code> to be thrown. Finally, invoking <code>read</code> when there’s a response will yield whatever data was resolved by the promise. It doesn’t matter how many times we call <code>read</code>—it will always accurately report on the state of our promise.</p>&#13;
&#13;
<p>In order to test it out in a component, we’ll need a promise, ideally one that sounds like the name of an ’80s ski movie:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">threeSecondsToGnar</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolves</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">resolves</code><code class="p">({</code> <code class="nx">gnar</code><code class="o">:</code> <code class="s2">"gnarly!"</code> <code class="p">}),</code> <code class="mi">3000</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>The <code>threeSecondsToGnar</code> promise waits three seconds before resolving to an object that has a field and value for <code>gnar</code>. Let’s use this promise to create a Suspenseful data resource and use that data resource in a small React application:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">resource</code> <code class="o">=</code> <code class="nx">createResource</code><code class="p">(</code><code class="nx">threeSecondsToGnar</code><code class="p">);</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Gnar</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">resource</code><code class="p">.</code><code class="nx">read</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Gnar</code><code class="o">:</code> <code class="p">{</code><code class="nx">result</code><code class="p">.</code><code class="nx">gnar</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">Suspense</code> <code class="nx">fallback</code><code class="o">=</code><code class="p">{</code><code class="o">&lt;</code><code class="nx">GridLoader</code> <code class="o">/&gt;</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ErrorBoundary</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">Gnar</code> <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/ErrorBoundary&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/Suspense&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>React components can render a lot. The <code>Gnar</code> component will be rendered several times before it actually returns a response. Each time <code>Gnar</code> is rendered, <code>resource.read()</code> is invoked. The first time <code>Gnar</code> is rendered, a promise is thrown. That promise is handled by the <code>Suspense</code> component and a <code>fallback</code> component will be rendered.</p>&#13;
&#13;
<p>When the promise has resolved, the <code>Suspense</code> component will attempt to render <code>Gnar</code> again. <code>Gnar</code> will invoke <code>resource.read()</code> again, but this time, assuming everything went OK, <code>resource.read()</code> will successfully return <code>Gnar</code>, which is used to render the state of <code>Gnar</code> in an <code>h1</code> element. If something went wrong, <code>resource.read()</code> would have thrown an error, which would be handed by the <code>ErrorBoundary</code>.</p>&#13;
&#13;
<p>As you can imagine, the <code>createResource</code> function can become quite robust. Our resource can attempt to handle errors. Maybe when there’s a network error, the resource can wait a few seconds and automatically attempt to load the data again. Our resource could communicate with other resources. Maybe we can log the performance statistics behind all of our resources. The sky’s the limit. As long as we have a function that we can use to read the current state of that resource, we can do whatever we like with the resource itself.</p>&#13;
&#13;
<p>At<a data-primary="Suspense component" data-secondary="future of" data-type="indexterm" id="idm45901621197112"/> present, this is how Suspense works. This is how we can use the <code>Suspense</code> component with any type of asynchronous resource. This could all change, and we expect it to change. However, whatever the finalized API for Suspense ends up being, it will be sure to handle three states: pending, success, and fail.</p>&#13;
&#13;
<p>The look at these Suspense APIs has been kind of high-level, and this was intentional because this stuff is experimental. It’s going to change. What’s important to take away from this chapter is that React is always tinkering with ways to make React apps faster.</p>&#13;
&#13;
<p>Behind the scenes of a lot of this work is the way that React itself works—specifically, its reconciliation algorithm called Fiber.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fiber" data-type="sect2"><div class="sect2" id="fiber-sect">&#13;
<h2>Fiber</h2>&#13;
&#13;
<p>Throughout this book, we’ve talked about React components as being functions that return data as a UI. Every time this data changes (props, state, remote data, etc), we rely on React to rerender the component. If we click a star to rate a color, we assume that our UI will change, and we assume that it’ll happen fast. We assume this because we trust React to make it happen. How exactly does this work though? To understand how React efficiently updates the DOM, let’s take a closer look at how React works.<a data-primary="Fiber algorithm" data-type="indexterm" id="fiberc09"/><a data-primary="reconciliation algorithm, Fiber" data-type="indexterm" id="recalg09"/></p>&#13;
&#13;
<p>Consider that you’re writing an article for your company blog. You want feedback, so you send the article to your coworker before you publish. They recommend a few quick changes, and now you need to incorporate those changes. You create a brand-new document, type out the entire article from scratch, and then add in the edits.</p>&#13;
&#13;
<p>You’re probably groaning at this unnecessary extra effort, but this is how a lot of libraries previously worked. To make an update, we’d get rid of everything, then start from scratch and rebuild the DOM during the update.</p>&#13;
&#13;
<p>Now, you’re writing another blog post and you send it to your coworker again. This time, you’ve modernized your article-writing process to use GitHub. Your coworker checks out a GitHub branch, makes the changes, and merges in the branch when they’re finished. Faster and more efficient.</p>&#13;
&#13;
<p>This process is similar to how React works. When a change occurs, React makes a copy of the component tree as a JavaScript object. It looks for the parts of the tree that need to change and changes only those parts. Once complete, the copy of the tree (known as the work-in-progress tree) replaces the existing tree. It’s important to reiterate that it uses the parts of the tree that are already there. For example, if we had to update an item in the list from <code>red</code> to <code>green</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">ul</code><code class="o">&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">li</code><code class="o">&gt;</code><code class="nx">blue</code><code class="o">&lt;</code><code class="err">/li&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">li</code><code class="o">&gt;</code><code class="nx">purple</code><code class="o">&lt;</code><code class="err">/li&gt;</code>&#13;
  <code class="o">&lt;</code><code class="nx">li</code><code class="o">&gt;</code><code class="nx">red</code><code class="o">&lt;</code><code class="err">/li&gt;</code>&#13;
<code class="o">&lt;</code><code class="err">/ul&gt;</code></pre>&#13;
&#13;
<p>React would not get rid of the third <code>li</code>. Instead it would replace its children (<code>red</code> text) with <code>green</code> text. This is an efficient approach to updating and is the way that React has updated the DOM since its inception. There is a potential problem here, though. Updating the DOM is an expensive task because it’s synchronous. We have to wait for all of the updates to be reconciled and then rendered before we can do other tasks on the main thread. In other words, we’d have to wait for React to recursively move through all of the updates, which could make the user experience seem unresponsive.</p>&#13;
&#13;
<p>The React team’s solution to this was a full rewrite of React’s reconciliation algorithm, called Fiber. Fiber, released in version 16.0, rewrote the way that DOM updates worked by taking a more asynchronous approach. The first change with 16.0 was the separation of the renderer and the reconciler. A renderer is the part of the library that handles rendering, and the reconciler is the part of the library that manages updates when they occur.</p>&#13;
&#13;
<p>Separating the renderer from the reconciler was a big deal. The reconciliation algorithm was kept in React Core (the package you install to use React), and each rendering target was made responsible for rendering. In other words, ReactDOM, React Native, React 360, and more would be responsible for the logic of rendering and could be plugged into React’s core reconciliation algorithm.</p>&#13;
&#13;
<p>Another huge shift with React Fiber was its changes to the reconciliation algorithm. Remember our expensive DOM updates that blocked the main thread? This lengthy block of updates is called <em>work</em>—with Fiber, React split the work into smaller units of work called <em>fibers</em>. A fiber is a JavaScript object that keeps track of what it’s reconciling and where it is in the updating cycle.</p>&#13;
&#13;
<p>Once a fiber (unit of work) is complete, React checks in with the main thread to make sure there’s not anything important to do. If there is important work to do, React will give control to the main thread. When it’s done with that important work, React will continue its update. If there’s nothing critical to jump to on the main thread, React moves on to the next unit of work and renders those changes to the DOM.</p>&#13;
&#13;
<p>To use the GitHub example from earlier, each fiber represents a commit on a branch, and when we check the branch back into the main branch, that represents the updated DOM tree. By breaking up the work of an update into chunks, Fiber allows priority tasks to jump the line for immediate handling by the main thread. The result is a user experience that feels more responsive.</p>&#13;
&#13;
<p>If this was all Fiber did, it would be a success, but there’s even more to it than that! In addition to the performance benefits of breaking work into smaller units, the rewrite also sets up exciting possibilities for the future. Fiber provides the infrastructure for prioritizing updates. In the longer term, the developer may even be able to tweak the defaults and decide which types of tasks should be given the highest priority. The process of prioritizing units of work is called <em>scheduling</em>; this concept underlies the experimental concurrent mode, which will eventually allow these units of work to be performed in parallel.<a data-primary="concurrent mode" data-type="indexterm" id="idm45901621158376"/></p>&#13;
&#13;
<p>An understanding of Fiber is not vital to working with React in production, but the rewrite of its reconciliation algorithm provides interesting insight into how React works and how its contributors are thinking about the future.<a data-primary="" data-startref="recalg09" data-type="indexterm" id="idm45901621157048"/><a data-primary="" data-startref="fiberc09" data-type="indexterm" id="idm45901621156072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>