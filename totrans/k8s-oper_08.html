<html><head></head><body><section data-pdf-bookmark="Chapter 8. Operator Lifecycle Manager" data-type="chapter" epub:type="chapter"><div class="chapter" id="operator_lifecyle_manager">&#13;
<h1><span class="label">Chapter 8. </span>Operator Lifecycle Manager</h1>&#13;
&#13;
&#13;
<p>Once you have written an Operator, it’s time to turn your attention to its installation and management.<a data-primary="Operator Lifecycle Manager (OLM)" data-type="indexterm" id="ix_OLM"/> As there are multiple steps involved in deploying an Operator, including creating the deployment, adding the custom resource definitions, and configuring the necessary permissions, a management layer becomes necessary to facilitate the process.<a data-primary="lifecycle manager" data-see="Operator Lifecycle Manager" data-type="indexterm" id="idm45261330711176"/></p>&#13;
&#13;
<p>Operator Lifecycle Manager (OLM) fulfills this role by introducing a packaging mechanism for delivering Operators and the necessary metadata for visualizing them in compatible UIs, including installation instructions and API hints in the form of CRD descriptors.</p>&#13;
&#13;
<p>OLM’s benefits extend beyond installation into Day 2 operations, including managing upgrades to existing Operators, providing a means to convey Operator stability through version channels, and the ability to aggregate multiple Operator hosting sources into a single interface.</p>&#13;
&#13;
<p>We begin this chapter by introducing OLM and its interfaces, including both the CRDs that end users will interact with inside of the cluster and the packaging format it uses for Operators. After that, we will show you OLM in action, using it to connect to OperatorHub.io to install an Operator. We conclude the chapter with a developer-focused exploration of the process of writing the necessary metadata files to make an Operator available to OLM and test it against a local <span class="keep-together">cluster.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="OLM Custom Resources" data-type="sect1"><div class="sect1" id="idm45261330707496">&#13;
<h1>OLM Custom Resources</h1>&#13;
&#13;
<p>As you know, the CRDs owned by an Operator make up that Operator’s API.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="custom resources" data-type="indexterm" id="ix_OLMCR"/><a data-primary="custom resources (CRs)" data-secondary="installed by OLM" data-type="indexterm" id="ix_CROLM"/> So, it makes sense to look at each of the CRDs that are installed by OLM and explore their uses.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ClusterServiceVersion" data-type="sect2"><div class="sect2" id="idm45261330703576">&#13;
<h2>ClusterServiceVersion</h2>&#13;
&#13;
<p>The <em>ClusterServiceVersion</em> (CSV) is the primary metadata resource that describes an Operator.<a data-primary="ClusterServiceVersion (CSV)" data-type="indexterm" id="idm45261330701816"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="custom resources" data-tertiary="ClusterServiceVersion" data-type="indexterm" id="idm45261330701208"/> Each CSV represents a version of an Operator and contains the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>General metadata about the Operator, including its name, version, description, and icon</p>&#13;
</li>&#13;
<li>&#13;
<p>Operator installation information, describing the deployments that are created and the permissions that are required</p>&#13;
</li>&#13;
<li>&#13;
<p>The CRDs that are owned by the Operator as well as references to any CRDs the Operator is dependent on</p>&#13;
</li>&#13;
<li>&#13;
<p>Annotations on the CRD fields to provide hints to users on how to properly specify values for the fields</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>When learning about CSVs, it can be useful to relate the concepts to that of a traditional Linux system. You can think of a CSV as analogous to a Linux package, such as a Red Hat Package Manager (RPM) file. Like an RPM file, the CSV contains information on how to install the Operator and any dependencies it requires. Following this analogy, you can think of OLM as a management tool similar to yum or DNF.<a data-primary="CSV" data-see="ClusterServiceVersion" data-type="indexterm" id="idm45261330695368"/></p>&#13;
&#13;
<p>Another important aspect to understand is the relationship between a CSV and the Operator deployment resource it manages. Much like how a deployment describes the “pod template” for the pods it creates, a CSV contains a “deployment template” for the deployment of the Operator pod. This is a formal ownership in the Kubernetes sense of the word; if the Operator deployment is deleted, the CSV will recreate it to bring the cluster back to the desired state, similar to how a deployment will cause deleted pods to be recreated.</p>&#13;
&#13;
<p>A ClusterServiceVersion resource is typically populated from a Cluster Service Version YAML file. We provide more details on how to write this file in <a data-type="xref" href="#writing_a_cluster_service_version_file">“Writing a Cluster Service Version File”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CatalogSource" data-type="sect2"><div class="sect2" id="idm45261330692184">&#13;
<h2>CatalogSource</h2>&#13;
&#13;
<p>A <em>CatalogSource</em> contains information for accessing a repository of Operators.<a data-primary="CatalogSource" data-type="indexterm" id="idm45261330690440"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="custom resources" data-tertiary="CatalogSource" data-type="indexterm" id="idm45261330689832"/> OLM provides a utility API named <code>packagemanifests</code> for querying catalog sources, which provides a list of Operators and the catalogs in which they are found. It uses resources of this kind to populate the list of available Operators.<a data-primary="manifests" data-secondary="packagemanifests API" data-type="indexterm" id="idm45261330688040"/><a data-primary="packagemanifests API" data-type="indexterm" id="idm45261330687192"/> The following is an example of using the <code>packagemanifests</code> API against the default catalog source:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>-n</code><code> </code><code>olm</code><code> </code><code>get</code><code> </code><code>packagemanifests</code></strong><code>&#13;
</code><code>NAME</code><code>                               </code><code>CATALOG</code><code>               </code><code>AGE</code><code>&#13;
</code><code>akka-cluster-operator</code><code>              </code><code>Community</code><code> </code><code>Operators</code><code>   </code><code>19s</code><code>&#13;
</code><code>appsody-operator</code><code>                   </code><code>Community</code><code> </code><code>Operators</code><code>   </code><code>19s</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subscription" data-type="sect2"><div class="sect2" id="idm45261330672248">&#13;
<h2>Subscription</h2>&#13;
&#13;
<p>End users create a <em>subscription</em> to install, and subsequently update, the Operators that OLM provides.<a data-primary="subscriptions" data-type="indexterm" id="idm45261330674792"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="custom resources" data-tertiary="subscription" data-type="indexterm" id="idm45261330674088"/><a data-primary="channels" data-type="indexterm" id="idm45261330657528"/> A subscription is made to a <em>channel</em>, which is a stream of Operator versions, such as “stable” or “nightly.”</p>&#13;
&#13;
<p>To continue with the earlier analogy to Linux packages, a subscription is equivalent to a command that installs a package, such as <code>yum install</code>. An installation command through yum will typically refer to the package by name rather than to a specific version, leaving the determination of the latest package to yum itself. In the same way, a subscription to an Operator by name and its channel lets OLM resolve the version based on what is available in that particular channel.</p>&#13;
&#13;
<p>Users configure a subscription with an <em>approval mode</em>.<a data-primary="approval mode (subscriptions)" data-type="indexterm" id="idm45261330653960"/> This value, set to either <code>manual</code> or <code>automatic</code>, tells OLM if manual user review is required before an Operator is installed. If set to <code>manual approval</code>, OLM-compatible user interfaces present the user with the details of the resources OLM will create during the Operator installation. The user has the option of approving or rejecting the Operator, and OLM takes the appropriate next steps.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="InstallPlan" data-type="sect2"><div class="sect2" id="idm45261330651384">&#13;
<h2>InstallPlan</h2>&#13;
&#13;
<p>A subscription creates an <em>InstallPlan</em>, which describes the full list of resources that OLM will create to satisfy the CSV’s resource requirements.<a data-primary="InstallPlan" data-type="indexterm" id="idm45261330633080"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="custom resources" data-tertiary="InstallPlan" data-type="indexterm" id="idm45261330632584"/> For subscriptions set to require manual approval, the end user sets an approval on this resource to inform OLM that the installation should proceed. Otherwise, users do not need to explicitly interact with these resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="OperatorGroup" data-type="sect2"><div class="sect2" id="idm45261330630872">&#13;
<h2>OperatorGroup</h2>&#13;
&#13;
<p>End users control Operator multitenancy through an <em>OperatorGroup</em>.<a data-primary="OperatorGroup" data-type="indexterm" id="idm45261330628920"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="custom resources" data-tertiary="OperatorGroup" data-type="indexterm" id="idm45261330628312"/><a data-primary="namespaces" data-secondary="that may be accessed by an Operator" data-type="indexterm" id="idm45261330627224"/> These designate namespaces that may be accessed by an individual Operator. In other words, an Operator belonging to an OperatorGroup will not react to custom resource changes in a namespace not indicated by the group.</p>&#13;
&#13;
<p>Although you can use OperatorGroups for fine-grained control for a set of namespaces, they are most commonly <a data-primary="namespaces" data-secondary="scoping Operators for, with OperatorGroup" data-type="indexterm" id="idm45261330625496"/>used in two ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To scope an Operator to a single namespace</p>&#13;
</li>&#13;
<li>&#13;
<p>To allow an Operator to run globally across all namespaces</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For example, the following definition creates a group that scopes Operators within it to the single namespace <code>ns-alpha</code>:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">operators.coreos.com/v1alpha2</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">OperatorGroup</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">group-alpha</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">ns-alpha</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">targetNamespaces</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">ns-alpha</code></pre>&#13;
&#13;
<p>Omitting the designator entirely results in a group that will cover all namespaces in the cluster:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">operators.coreos.com/v1alpha2</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">OperatorGroup</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">group-alpha</code><code>&#13;
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ns-alpha</code><code> </code><a class="co" href="#callout_operator_lifecycle_manager_CO1-1" id="co_operator_lifecycle_manager_CO1-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO1-1" id="callout_operator_lifecycle_manager_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Note that, as a Kubernetes resource, the OperatorGroup must still reside in a specific namespace.<a data-primary="targetNamespaces designation" data-type="indexterm" id="idm45261330548568"/> However, the lack of the <code>targetNamespaces</code> designation means the OperatorGroup will cover all namespaces.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The two examples shown here cover the majority of use cases; creating fine-grained OperatorGroups scoped to more than one specific namespace is outside the scope of this book. You can find more information in <a href="https://oreil.ly/ZBAou">OLM’s GitHub repository</a>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing OLM" data-type="sect1"><div class="sect1" id="idm45261330630280">&#13;
<h1>Installing OLM</h1>&#13;
&#13;
<p>In the rest of this chapter, we explore using and developing for OLM.<a data-primary="custom resources (CRs)" data-secondary="installed by OLM" data-startref="ix_CROLM" data-type="indexterm" id="idm45261330543544"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="custom resources" data-startref="ix_OLMCR" data-type="indexterm" id="idm45261330542296"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="installing" data-type="indexterm" id="ix_OLMins"/> As OLM is not installed by default in most Kubernetes distributions, the first step is to install the necessary resources to run it.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>OLM is an evolving project. As such, be sure to consult its GitHub repository to find the latest installation instructions for <a href="https://oreil.ly/It369">the current release</a>. You can find the most recent releases on the OLM project’s GitHub repository.</p>&#13;
</div>&#13;
&#13;
<p>As of the current release (0.11.0), the installation performs two primary tasks.</p>&#13;
&#13;
<p>To begin, you’ll need to install the CRDs required by OLM. These function as the API into OLM and provide the ability to configure external sources that provide Operators and the cluster-side resources used to make those Operators available to users. You create these through the <code>kubectl apply</code> command, as follows:</p>&#13;
<pre class="pagebreak-before less_space" data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code class="se">\&#13;
</code><code>https://github.com/operator-framework/operator-lifecycle-manager/releases/</code><code class="se">\&#13;
</code><code>download/0.11.0/crds.yaml</code></strong><code>&#13;
</code><code>clusterserviceversions.operators.coreos.com</code><code> </code><code>created</code><code>&#13;
</code><code>installplans.operators.coreos.com</code><code> </code><code>created</code><code>&#13;
</code><code>subscriptions.operators.coreos.com</code><code> </code><code>created</code><code>&#13;
</code><code>catalogsources.operators.coreos.com</code><code> </code><code>created</code><code>&#13;
</code><code>operatorgroups.operators.coreos.com</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The examples here use the 0.11.0 release, which was the latest version at the time of writing; you can update these commands to use the most up-to-date version available at the time you’re reading the book.</p>&#13;
</div>&#13;
&#13;
<p>The second step is to create all of the Kubernetes resources that make up OLM itself. These include the Operators that will drive OLM as well as the necessary RBAC resources (ServiceAccounts, ClusterRoles, etc.) for it to function.</p>&#13;
&#13;
<p>As with the CRD creation, you perform this step through the <code>kubectl apply</code> <span class="keep-together">command:</span></p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code class="se">\&#13;
</code><code>https://github.com/operator-framework/operator-lifecycle-manager/</code><code class="se">\&#13;
</code><code>releases/download/0.11.0/olm.yaml</code></strong><code>&#13;
</code><code>namespace/olm</code><code> </code><code>created</code><code>&#13;
</code><code>namespace/operators</code><code> </code><code>created</code><code>&#13;
</code><code>system:controller:operator-lifecycle-manager</code><code> </code><code>created</code><code>&#13;
</code><code>serviceaccount/olm-operator-serviceaccount</code><code> </code><code>created</code><code>&#13;
</code><code>clusterrolebinding.rbac.authorization.k8s.io/olm-operator-binding-olm</code><code> </code><code>created</code><code>&#13;
</code><code>deployment.apps/olm-operator</code><code> </code><code>created</code><code>&#13;
</code><code>deployment.apps/catalog-operator</code><code> </code><code>created</code><code>&#13;
</code><code>clusterrole.rbac.authorization.k8s.io/aggregate-olm-edit</code><code> </code><code>created</code><code>&#13;
</code><code>clusterrole.rbac.authorization.k8s.io/aggregate-olm-view</code><code> </code><code>created</code><code>&#13;
</code><code>operatorgroup.operators.coreos.com/global-operators</code><code> </code><code>created</code><code>&#13;
</code><code>operatorgroup.operators.coreos.com/olm-operators</code><code> </code><code>created</code><code>&#13;
</code><code>clusterserviceversion.operators.coreos.com/packageserver</code><code> </code><code>created</code><code>&#13;
</code><code>catalogsource.operators.coreos.com/operatorhubio-catalog</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
&#13;
<p>You can verify the installation by looking at the resources that were created:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get ns olm</strong>&#13;
NAME              STATUS   AGE&#13;
olm               Active   43s&#13;
&#13;
$ <strong>kubectl get pods -n olm</strong>&#13;
NAME                                READY   STATUS    RESTARTS   AGE&#13;
catalog-operator-7c94984c6c-wpxsv   1/1     Running   <code>0</code>          68s&#13;
olm-operator-79fdbcc897-r76ss       1/1     Running   <code>0</code>           68s&#13;
olm-operators-qlkh2                 1/1     Running   <code>0</code>           57s&#13;
operatorhubio-catalog-9jdd8         1/1     Running   <code>0</code>           57s&#13;
packageserver-654686f57d-74skk      1/1     Running   <code>0</code>           39s&#13;
packageserver-654686f57d-b8ckz      1/1     Running   <code>0</code>           39s&#13;
&#13;
$ <strong>kubectl get crd</strong>&#13;
NAME                                          CREATED AT&#13;
catalogsources.operators.coreos.com           2019-08-07T20:30:42Z&#13;
clusterserviceversions.operators.coreos.com   2019-08-07T20:30:42Z&#13;
installplans.operators.coreos.com             2019-08-07T20:30:42Z&#13;
operatorgroups.operators.coreos.com           2019-08-07T20:30:42Z&#13;
subscriptions.operators.coreos.com            2019-08-07T20:30:42Z&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using OLM" data-type="sect1"><div class="sect1" id="idm45261330544776">&#13;
<h1>Using OLM</h1>&#13;
&#13;
<p>Now that we’ve introduced the basic concepts around OLM, let’s see how to use it to install an Operator.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="installing" data-startref="ix_OLMins" data-type="indexterm" id="idm45261330375336"/> We’ll use OperatorHub.io as the source repository for Operators.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="using" data-type="indexterm" id="ix_OLMuse"/><a data-primary="OperatorHub.io" data-type="indexterm" id="idm45261330376712"/><a data-primary="repository for Operator source" data-type="indexterm" id="idm45261330376040"/> We cover OperatorHub.io in more detail in <a data-type="xref" href="ch10.html#getting_involved">Chapter 10</a>, but for now the important thing to know is that it’s a community-curated list of publicly available Operators for use with OLM. In keeping with the Linux package analogy from earlier in the chapter, you can think of it as similar to an RPM repository.</p>&#13;
&#13;
<p>Installing OLM creates a default catalog source in the <code>olm</code> namespace. You can verify <a data-primary="CatalogSource" data-secondary="describing" data-type="indexterm" id="idm45261330379144"/>that this source, named <code>operatorhubio-catalog</code>, exists by using the CLI:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>catalogsource</code><code> </code><code>-n</code><code> </code><code>olm</code></strong><code>&#13;
</code><code>NAME</code><code>                    </code><code>NAME</code><code>                  </code><code>TYPE</code><code>   </code><code>PUBLISHER</code><code>        </code><code>AGE</code><code>&#13;
</code><code>operatorhubio-catalog</code><code>   </code><code>Community</code><code> </code><code>Operators</code><code>   </code><code>grpc</code><code>   </code><code>OperatorHub.io</code><code>   </code><code>4h20m</code><code>&#13;
</code></pre>&#13;
&#13;
<p>You can find<a data-primary="kubectl command" data-secondary="describe" data-type="indexterm" id="idm45261330394200"/> further details about the source by using the <code>describe</code> command:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>catalogsource/operatorhubio-catalog</code><code> </code><code>-n</code><code> </code><code>olm</code></strong><code>&#13;
</code><code>Name:</code><code>         </code><code>operatorhubio-catalog</code><code>&#13;
</code><code>Namespace:</code><code>    </code><code>olm</code><code>&#13;
</code><code>Labels:</code><code>       </code><code>&lt;</code><code>none&gt;</code><code>&#13;
</code><code>Annotations:</code><code>  </code><code>kubectl.kubernetes.io/last-applied-configuration...</code><code>&#13;
</code><code>API</code><code> </code><code>Version:</code><code>  </code><code>operators.coreos.com/v1alpha1</code><code>&#13;
</code><code>Kind:</code><code>         </code><code>CatalogSource</code><code>&#13;
</code><code>Metadata:</code><code>&#13;
  </code><code>Creation</code><code> </code><code>Timestamp:</code><code>  </code><code>2019-09-23T13:53:39Z</code><code>&#13;
  </code><code>Generation:</code><code>          </code><code>1</code><code>&#13;
  </code><code>Resource</code><code> </code><code>Version:</code><code>    </code><code>801</code><code>&#13;
  </code><code>Self</code><code> </code><code>Link:</code><code>           </code><code>/apis/operators.coreos.com/v1alpha1/...</code><code>&#13;
  </code><code>UID:</code><code>                 </code><code>45842de1-3b6d-4b1b-bd36-f616dec94c6a</code><code>&#13;
</code><code>Spec:</code><code>&#13;
  </code><code>Display</code><code> </code><code>Name:</code><code>  </code><code>Community</code><code> </code><code>Operators</code><code>  </code><a class="co" href="#c01-01" id="comarker1-01"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code>Image:</code><code>         </code><code>quay.io/operator-framework/upstream-community-operators:latest</code><code>&#13;
  </code><code>Publisher:</code><code>     </code><code>OperatorHub.io</code><code>&#13;
  </code><code>Source</code><code> </code><code>Type:</code><code>   </code><code>grpc</code><code>&#13;
</code><code>Status:</code><code>&#13;
  </code><code>Last</code><code> </code><code>Sync:</code><code>  </code><code>2019-09-23T13:53:54Z</code><code>&#13;
  </code><code>Registry</code><code> </code><code>Service:</code><code>&#13;
    </code><code>Created</code><code> </code><code>At:</code><code>         </code><code>2019-09-23T13:53:44Z</code><code>&#13;
    </code><code>Port:</code><code>               </code><code>50051</code><code>&#13;
    </code><code>Protocol:</code><code>           </code><code>grpc</code><code>&#13;
    </code><code>Service</code><code> </code><code>Name:</code><code>       </code><code>operatorhubio-catalog</code><code>&#13;
    </code><code>Service</code><code> </code><code>Namespace:</code><code>  </code><code>olm</code><code>&#13;
</code><code>Events:</code><code>                 </code><code>&lt;</code><code>none&gt;</code><code>&#13;
</code></pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1-01" id="c01-01"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p>Note that the display name is simply “Community Operators,” rather than indicating anything about OperatorHub.io. This value appears in the output of the next command, when we look at the list of possible Operators.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This catalog source is configured to read all of the Operators hosted on <span class="keep-together">OperatorHub.io</span>. You can use the <code>packagemanifest</code> utility API to get a list of the Operators <a data-primary="packagemanifests API" data-type="indexterm" id="idm45261330258440"/>that are found:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>packagemanifest</code><code> </code><code>-n</code><code> </code><code>olm</code></strong><code>&#13;
</code><code>NAME</code><code>                               </code><code>CATALOG</code><code>               </code><code>AGE</code><code>&#13;
</code><code>akka-cluster-operator</code><code>              </code><code>Community</code><code> </code><code>Operators</code><code>   </code><code>4h47m</code><code>&#13;
</code><code>appsody-operator</code><code>                   </code><code>Community</code><code> </code><code>Operators</code><code>   </code><code>4h47m</code><code>&#13;
</code><code>aqua</code><code>                               </code><code>Community</code><code> </code><code>Operators</code><code>   </code><code>4h47m</code><code>&#13;
</code><code>atlasmap-operator</code><code>                  </code><code>Community</code><code> </code><code>Operators</code><code>   </code><code>4h47m</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>  </code><a class="co" href="#c01-02" id="comarker1-02"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code></pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1-02" id="c01-02"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p>At the time of writing, there are close to 80 Operators on OperatorHub.io. We truncated the output of this command for brevity.</p></dd>&#13;
</dl>&#13;
&#13;
<p>For this example, you’ll install the etcd Operator. The first step is to define an OperatorGroup to dictate which namespaces the Operator will manage. The etcd Operator you’re going to be using is scoped to a single namespace (you’ll see later how we determined that), so you’ll create a group for just the default namespace:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">operators.coreos.com/v1alpha2</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">OperatorGroup</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default-og</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">targetNamespaces</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">default</code></pre>&#13;
&#13;
<p>Create the group using the <code>kubectl</code> <code>apply</code> command (this example assumes the YAML in the previous snippet is saved to a file named <em>all-og.yaml</em>):</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code>all-og.yaml</code></strong><code>&#13;
</code><code>operatorgroup.operators.coreos.com/default-og</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
&#13;
<p>The creation<a data-primary="subscriptions" data-secondary="creation of, triggering Operator installation" data-type="indexterm" id="idm45261330131960"/> of a subscription triggers the installation of an Operator. Before you can do that, you need to determine which channel you want to subscribe to. OLM provides channel information in addition to a wealth of other details about the Operator.</p>&#13;
&#13;
<p>You can view this information by using the <code>packagemanifest</code> API:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>packagemanifest/etcd</code><code> </code><code>-n</code><code> </code><code>olm</code></strong><code>&#13;
</code><code>Name:</code><code>         </code><code>etcd</code><code>&#13;
</code><code>Namespace:</code><code>    </code><code>olm</code><code>&#13;
</code><code>Labels:</code><code>       </code><code class="nv">catalog</code><code class="o">=</code><code>operatorhubio-catalog</code><code>&#13;
              </code><code>catalog-namespace</code><code class="o">=</code><code>olm</code><code>&#13;
              </code><code class="nv">provider</code><code class="o">=</code><code>CNCF</code><code>&#13;
              </code><code>provider-url</code><code class="o">=</code><code>&#13;
</code><code>Annotations:</code><code>  </code><code>&lt;</code><code>none&gt;</code><code>&#13;
</code><code>API</code><code> </code><code>Version:</code><code>  </code><code>packages.operators.coreos.com/v1</code><code>&#13;
</code><code>Kind:</code><code>         </code><code>PackageManifest</code><code>&#13;
</code><code>Metadata:</code><code>&#13;
  </code><code>Creation</code><code> </code><code>Timestamp:</code><code>  </code><code>2019-09-23T13:53:39Z</code><code>&#13;
  </code><code>Self</code><code> </code><code>Link:</code><code>           </code><code>/apis/packages.operators.coreos.com/v1/namespaces/...</code><code>&#13;
</code><code>Spec:</code><code>&#13;
</code><code>Status:</code><code>&#13;
  </code><code>Catalog</code><code> </code><code>Source:</code><code>               </code><code>operatorhubio-catalog</code><code>&#13;
  </code><code>Catalog</code><code> </code><code>Source</code><code> </code><code>Display</code><code> </code><code>Name:</code><code>  </code><code>Community</code><code> </code><code>Operators</code><code>&#13;
  </code><code>Catalog</code><code> </code><code>Source</code><code> </code><code>Namespace:</code><code>     </code><code>olm</code><code>&#13;
  </code><code>Catalog</code><code> </code><code>Source</code><code> </code><code>Publisher:</code><code>     </code><code>OperatorHub.io</code><code>&#13;
  </code><code>Channels:</code><code>&#13;
    </code><code>Current</code><code> </code><code>CSV:</code><code>  </code><code>etcdoperator.v0.9.4-clusterwide</code><code>&#13;
    </code><code>Current</code><code> </code><code>CSV</code><code> </code><code>Desc:</code><code>&#13;
      </code><code>Annotations:</code><code>&#13;
        </code><code>Alm</code><code> </code><code>-</code><code> </code><code>Examples:</code><code>  </code><code class="o">[</code><code>...</code><code class="o">]</code><code>   </code><a class="co" href="#c01-03" id="comarker1-03"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>  </code><a class="co" href="#c02" id="comarker2"><img alt="2" src="assets/2.png"/></a><code>&#13;
    </code><code>Install</code><code> </code><code>Modes:</code><code>  </code><a class="co" href="#c03" id="comarker3"><img alt="3" src="assets/3.png"/></a><code>&#13;
        </code><code>Type:</code><code>       </code><code>OwnNamespace</code><code>&#13;
        </code><code>Supported:</code><code>  </code><code class="nb">true </code><a class="co" href="#c04" id="comarker4"><img alt="4" src="assets/4.png"/></a><code class="nb">&#13;
        </code><code>Type:</code><code>       </code><code>SingleNamespace</code><code>&#13;
        </code><code>Supported:</code><code>  </code><code class="nb">true&#13;
        </code><code>Type:</code><code>       </code><code>MultiNamespace</code><code>&#13;
        </code><code>Supported:</code><code>  </code><code class="nb">false&#13;
        </code><code>Type:</code><code>       </code><code>AllNamespaces</code><code>&#13;
        </code><code>Supported:</code><code>  </code><code class="nb">false </code><a class="co" href="#c05" id="comarker5"><img alt="5" src="assets/5.png"/></a><code class="nb">&#13;
    </code><code>Provider:</code><code>&#13;
        </code><code>Name:</code><code>       </code><code>CNCF</code><code>&#13;
    </code><code>Version:</code><code>      </code><code>0.9.4</code><code>&#13;
</code><code>Name:</code><code>           </code><code>singlenamespace-alpha</code><code>  </code><a class="co" href="#c06" id="comarker6"><img alt="6" src="assets/6.png"/></a><code>&#13;
  </code><code>Default</code><code> </code><code>Channel:</code><code>  </code><code>singlenamespace-alpha</code><code>&#13;
  </code><code>Package</code><code> </code><code>Name:</code><code>     </code><code>etcd</code><code>&#13;
  </code><code>Provider:</code><code>&#13;
    </code><code>Name:</code><code>  </code><code>CNCF</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code></pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1-03" id="c01-03"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p>The examples section of a package manifest contains a series of manifests that you can use to deploy custom resources defined by this Operator. For brevity, we have omitted them from this output.</p></dd>&#13;
 <dt><a class="co" href="#comarker2" id="c02"><img alt="2" src="assets/2.png"/></a></dt>&#13;
  <dd><p>We cut out much of the file for readability. We’ll cover many of these fields when we talk about creating the CSV file in <a data-type="xref" href="#writing_a_cluster_service_version_file">“Writing a Cluster Service Version File”</a>.</p></dd>&#13;
 <dt><a class="co" href="#comarker3" id="c03"><img alt="3" src="assets/3.png"/></a></dt>&#13;
  <dd><p>The install modes section describes the circumstances in which an end user may deploy this Operator. We will also cover these later in this chapter.</p></dd>&#13;
 <dt><a class="co" href="#comarker4" id="c04"><img alt="4" src="assets/4.png"/></a></dt>&#13;
  <dd><p>This particular channel offers an Operator that is configured to be run to watch the same namespace it is deployed in.</p></dd>&#13;
 <dt><a class="co" href="#comarker5" id="c05"><img alt="5" src="assets/5.png"/></a></dt>&#13;
  <dd><p>Along the same lines, end users cannot install this Operator to monitor all namespaces in the cluster. If you look around in the package manifest data you’ll find another channel named <code>clusterwide-alpha</code> that is suited to this purpose.</p></dd>&#13;
 <dt><a class="co" href="#comarker6" id="c06"><img alt="6" src="assets/6.png"/></a></dt>&#13;
  <dd><p>The <code>Name</code> field in this section indicates the name of the channel which is referenced by a subscription.</p></dd>&#13;
  </dl>&#13;
&#13;
<p>Since this Operator comes from OperatorHub.io, it can be beneficial to view its page on the site directly. <a data-primary="OperatorHub.io" data-secondary="viewing Operator page directly" data-type="indexterm" id="idm45261329896984"/>All of the data contained in the package manifest is displayed on the individual Operator’s page, but formatted in a more easily readable manner. You can check this out on the  <a href="https://oreil.ly/1bjkr">etcd Operator page</a>.</p>&#13;
&#13;
<p>Once you have decided on a channel, the last step is to create the subscription resource itself. Here is an example manifest:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">operators.coreos.com/v1alpha1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Subscription</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">etcd-subscription</code><code>&#13;
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">default</code><code> </code><a class="co" href="#callout_operator_lifecycle_manager_CO2-1" id="co_operator_lifecycle_manager_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">etcd</code><code> </code><a class="co" href="#callout_operator_lifecycle_manager_CO2-2" id="co_operator_lifecycle_manager_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>  </code><code class="nt">source</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">operatorhubio-catalog</code><code> </code><a class="co" href="#callout_operator_lifecycle_manager_CO2-3" id="co_operator_lifecycle_manager_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>  </code><code class="nt">sourceNamespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">olm</code><code>&#13;
</code><code>  </code><code class="nt">channel</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">singlenamespace-alpha</code><code> </code><a class="co" href="#callout_operator_lifecycle_manager_CO2-4" id="co_operator_lifecycle_manager_CO2-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO2-1" id="callout_operator_lifecycle_manager_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This manifest installs the subscription, and thus the Operator deployment itself, in the default namespace.</p></dd>&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO2-2" id="callout_operator_lifecycle_manager_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The name of the Operator to be installed, as found by the <code>packagemanifest</code> API call.</p></dd>&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO2-3" id="callout_operator_lifecycle_manager_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>source</code> and <code>sourceNamespace</code> describe where to find the catalog source that provides the Operator.</p></dd>&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO2-4" id="callout_operator_lifecycle_manager_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>OLM will install Operators from the <code>singlenamespace-alpha</code> channel.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As with other resources, you create the subscription using <code>kubectl</code> <code>apply</code> (this command assumes the subscription YAML above is saved in a file named <em>sub.yaml</em>):</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code>sub.yaml</code></strong><code>&#13;
</code><code>subscription.operators.coreos.com/etcd-subscription</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exploring the Operator" data-type="sect2"><div class="sect2" id="idm45261329947448">&#13;
<h2>Exploring the Operator</h2>&#13;
&#13;
<p>When you create the subscription, a number of things happen. At the highest level of <a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="using" data-tertiary="exploring the CSV Operator" data-type="indexterm" id="idm45261329946008"/><a data-primary="ClusterServiceVersion (CSV)" data-secondary="creation by OLM in default namespace" data-type="indexterm" id="idm45261329944600"/>the resource hierarchy, OLM creates a ClusterServiceVersion resource in the default namespace:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>csv</code><code> </code><code>-n</code><code> </code><code>default</code></strong><code>&#13;
</code><code>NAME</code><code>                  </code><code>DISPLAY</code><code>   </code><code>VERSION</code><code>   </code><code>REPLACES</code><code>              </code><code>PHASE</code><code>&#13;
</code><code>etcdoperator.v0.9.4</code><code>   </code><code>etcd</code><code>      </code><code>0.9.4</code><code>     </code><code>etcdoperator.v0.9.2</code><code>   </code><code>Succeeded</code><code>&#13;
</code></pre>&#13;
&#13;
<p>The CSV is effectively what the subscription installs—it’s the package, in the RPM analogy. OLM performs the Operator installation steps defined in the CSV to create the Operator pods themselves. Additionally, OLM will store information about events in this process, which you can view using the <code>describe</code> command:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>csv/etcdoperator.v0.9.4</code><code> </code><code>-n</code><code> </code><code>default</code></strong><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code><code>Events:</code><code>&#13;
</code><code>operator-lifecycle-manager</code><code>  </code><code>requirements</code><code> </code><code>not</code><code> </code><code>yet</code><code> </code><code>checked</code><code>&#13;
</code><code>one</code><code> </code><code>or</code><code> </code><code>more</code><code> </code><code>requirements</code><code> </code><code>couldn</code><code class="err">'</code><code>t</code><code> </code><code>be</code><code> </code><code>found</code><code>&#13;
</code><code>all</code><code> </code><code>requirements</code><code> </code><code>found,</code><code> </code><code>attempting</code><code> </code><code>install</code><code>&#13;
</code><code>waiting</code><code> </code><code class="k">for</code><code> </code><code>install</code><code> </code><code>components</code><code> </code><code>to</code><code> </code><code>report</code><code> </code><code>healthy</code><code>&#13;
</code><code>installing:</code><code> </code><code>ComponentMissing:</code><code> </code><code>missing</code><code> </code><code>deployment</code><code> </code><code>with</code><code> </code><code class="nv">name</code><code class="o">=</code><code>etcd-operator</code><code>&#13;
</code><code>installing:</code><code> </code><code>ComponentMissing:</code><code> </code><code>missing</code><code> </code><code>deployment</code><code> </code><code>with</code><code> </code><code class="nv">name</code><code class="o">=</code><code>etcd-operator</code><code>&#13;
</code><code>installing:</code><code> </code><code>Waiting:</code><code> </code><code>waiting</code><code> </code><code class="k">for</code><code> </code><code>deployment</code><code> </code><code>etcd-operator</code><code> </code><code>to</code><code> </code><code>become</code><code> </code><code>ready:</code><code>&#13;
  </code><code>Waiting</code><code> </code><code class="k">for</code><code> </code><code>rollout</code><code> </code><code>to</code><code> </code><code>finish:</code><code> </code><code class="m">0</code><code> </code><code>of</code><code> </code><code class="m">1</code><code> </code><code>updated</code><code> </code><code>replicas</code><code> </code><code>are</code><code> </code><code>available...</code><code>&#13;
</code><code>install</code><code> </code><code>strategy</code><code> </code><code>completed</code><code> </code><code>with</code><code> </code><code>no</code><code> </code><code>errors</code><code>&#13;
</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The output here has been edited to fit the page. Your output will vary slightly and contain more data per event.</p>&#13;
</div>&#13;
&#13;
<p>OLM is responsible for following the deployment template contained within the CSV to create the Operator pod itself. Continuing down the resource ownership hierarchy, you can see that OLM creates a deployment resource as well:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get deployment -n default</strong>&#13;
NAME            READY   UP-TO-DATE   AVAILABLE   AGE&#13;
etcd-operator   1/1     <code>1</code>             <code>1</code>           3m42s&#13;
</pre>&#13;
&#13;
<p>Viewing the details of the deployment explicitly shows the owner relationship between the CSV and this deployment:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>deployment/etcd-operator</code><code> </code><code>-n</code><code> </code><code>default</code><code> </code><code>-o</code><code> </code><code>yaml</code></strong><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code><code>ownerReferences:</code><code>&#13;
</code><code>-</code><code> </code><code>apiVersion:</code><code> </code><code>operators.coreos.com/v1alpha1</code><code>&#13;
  </code><code>blockOwnerDeletion:</code><code> </code><code class="nb">false&#13;
  </code><code>controller:</code><code> </code><code class="nb">false&#13;
  </code><code>kind:</code><code> </code><code>ClusterServiceVersion</code><code>&#13;
  </code><code>name:</code><code> </code><code>etcdoperator.v0.9.4</code><code>&#13;
  </code><code>uid:</code><code> </code><code>564c15d9-ab49-439f-8ea4-8c140f55e641</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Unsurprisingly, the deployment creates a number of pods based on its resource definition. In the case of the etcd Operator, the CSV defines the deployment as requiring three pods:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods -n default</strong>&#13;
NAME                            READY   STATUS    RESTARTS   AGE&#13;
etcd-operator-c4bc4fb66-zg22g   3/3     Running   <code>0</code>          6m4s&#13;
</pre>&#13;
&#13;
<p>To summarize, creating the subscription caused the following to take place:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>OLM creates a CSV resource in the same namespace as the subscription. This CSV contains, among other things, the manifest for the deployment of the Operator itself.</p>&#13;
</li>&#13;
<li>&#13;
<p>OLM uses the deployment manifest to create a deployment resource for the Operator. The owner of that resource is the CSV itself.</p>&#13;
</li>&#13;
<li>&#13;
<p>The deployment causes the creation of replica sets and pods for the Operator itself.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deleting the Operator" data-type="sect2"><div class="sect2" id="idm45261329946856">&#13;
<h2>Deleting the Operator</h2>&#13;
&#13;
<p>Deleting an OLM-deployed Operator isn’t as straightforward as it is when working with simple deployment resources.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="using" data-tertiary="deleting an OLM-deployed Operator" data-type="indexterm" id="idm45261329576216"/></p>&#13;
&#13;
<p>A deployment resource acts as installation instructions for pods. If a pod is removed, either by user intervention or because of an error on the pod itself, Kubernetes detects the difference between the desired state of the deployment and the actual number of pods.</p>&#13;
&#13;
<p>In much the same way, the CSV resource acts as the installation instructions for the Operator. Often, a CSV indicates that a deployment must exist to fulfill this plan. If that deployment ceases to exist, OLM takes the necessary steps to make the actual state of the system match the CSV’s desired state.</p>&#13;
&#13;
<p>As such, it’s not sufficient to simply delete the Operator’s deployment resource. Instead, an Operator deployed by OLM is deleted by deleting the CSV resource:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl delete csv/etcdoperator.v0.9.4</strong>&#13;
<code>clusterserviceversion.operators.coreos.com "etcdoperator.v0.9.4" deleted</code>&#13;
</pre>&#13;
&#13;
<p>OLM takes care of deleting the resources that the CSV created when it was originally deployed, including the Operator’s deployment resource.</p>&#13;
&#13;
<p>Additionally, you’ll need to delete the subscription to prevent OLM from installing new CSV versions in the future:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl delete subscription/etcd-subscription</strong>&#13;
<code>subscription.operators.coreos.com "etcd-subscription" deleted</code>&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="OLM Bundle Metadata Files" data-type="sect1"><div class="sect1" id="idm45261329579464">&#13;
<h1>OLM Bundle Metadata Files</h1>&#13;
&#13;
<p>An “OLM bundle” provides details on an Operator that can be installed. <a data-primary="bundle metadata files (OLM)" data-type="indexterm" id="ix_bmf"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="using" data-startref="ix_OLMuse" data-type="indexterm" id="idm45261329610872"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="bundle metadata files" data-type="indexterm" id="ix_OLMbmf"/>The bundle contains all the necessary information (for all the available versions of the Operator) to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Provide a flexible delivery structure for the Operator by offering one or more <em>channels</em> that a user can subscribe to.<a data-primary="channels, subscriptions to" data-type="indexterm" id="idm45261329606824"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Deploy the CRDs required for the Operator to function.</p>&#13;
</li>&#13;
<li>&#13;
<p>Instruct OLM on how to create the Operator deployment.</p>&#13;
</li>&#13;
<li>&#13;
<p>Include additional information on each CRD spec field, including hints on how to render those fields in a UI.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are three types of files included in an OLM bundle: custom resource definitions, Cluster Service Version files, and package manifest files.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom Resource Definitions" data-type="sect2"><div class="sect2" id="idm45261329677960">&#13;
<h2>Custom Resource Definitions</h2>&#13;
&#13;
<p>Since the Operator requires its CRDs to function, the OLM bundle includes them.<a data-primary="custom resource definitions (CRDs)" data-secondary="OLM bundle metadata files" data-type="indexterm" id="idm45261329676664"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="bundle metadata files" data-tertiary="custom resource definitions (CRDs)" data-type="indexterm" id="idm45261329675656"/><a data-primary="bundle metadata files (OLM)" data-secondary="custom resource definitions (CRDs)" data-type="indexterm" id="idm45261329674408"/> OLM installs the CRDs along with the Operator itself. You, as the OLM bundle developer, do not need to make any changes or additions to the CRD files beyond what already exists to support the Operator.</p>&#13;
&#13;
<p>Keep in mind that only CRDs that are owned by the Operator should be included. Any dependent CRDs that are provided by other Operators will be installed automatically by OLM’s dependency resolution (the notion of required CRDs is addressed in <a data-type="xref" href="#owned_crds">“Owned CRDs”</a>).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Each CRD must be defined in its own file.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cluster Service Version File" data-type="sect2"><div class="sect2" id="idm45261329670216">&#13;
<h2>Cluster Service Version File</h2>&#13;
&#13;
<p>The CSV file contains the bulk of the metadata <a data-primary="ClusterServiceVersion (CSV)" data-secondary="in OLM bundle metadata files" data-type="indexterm" id="idm45261329668920"/><a data-primary="bundle metadata files (OLM)" data-secondary="cluster service version files" data-type="indexterm" id="idm45261329667864"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="bundle metadata files" data-tertiary="CSV files" data-type="indexterm" id="idm45261329666888"/>about the Operator, including:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to deploy the Operator</p>&#13;
</li>&#13;
<li>&#13;
<p>The list of CRDs that the Operator uses (those that it owns as well as dependencies from other Operators)</p>&#13;
</li>&#13;
<li>&#13;
<p>Metadata about the Operator, including a description, logo, its maturity level, and related links</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Given the large role this file plays, we cover details on how to write one in the following section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Package Manifest File" data-type="sect2"><div class="sect2" id="idm45261329661448">&#13;
<h2>Package Manifest File</h2>&#13;
&#13;
<p>The package manifest file describes a list of channels that point to particular Operator versions.<a data-primary="bundle metadata files (OLM)" data-secondary="package manifest files" data-type="indexterm" id="idm45261329660008"/><a data-primary="package manifest file" data-type="indexterm" id="idm45261329658968"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="bundle metadata files" data-tertiary="package manifest file" data-type="indexterm" id="idm45261329658296"/> It is up to the Operator owners to determine the breakdown of channels and their respective delivery cadence. We strongly recommend that channels set expectations around stability, features, and rate of changes.</p>&#13;
&#13;
<p>Users subscribe to channels. OLM will use the package manifest to determine if a new version of the Operator is available in a subscribed-to channel and allow the user to take steps to update as appropriate. We’ll get into more detail about this file in <a data-type="xref" href="#writ_pack_manifest_file">“Writing a Package Manifest File”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing a Cluster Service Version File" data-type="sect1"><div class="sect1" id="writing_a_cluster_service_version_file">&#13;
<h1>Writing a Cluster Service Version File</h1>&#13;
&#13;
<p>Each version of an Operator will have its own Cluster Service Version file.<a data-primary="bundle metadata files (OLM)" data-startref="ix_bmf" data-type="indexterm" id="idm45261329653016"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="bundle metadata files" data-startref="ix_OLMbmf" data-type="indexterm" id="idm45261329651976"/> The CSV file is a standard Kubernetes manifest of kind ClusterServiceVersion, which is one of the custom resources that OLM provides.<a data-primary="ClusterServiceVersion (CSV)" data-secondary="writing a CSV file" data-type="indexterm" id="ix_CSVfile"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="writing a CSV file" data-type="indexterm" id="ix_OLMCSV"/></p>&#13;
&#13;
<p>The resources in this file provide OLM with information about a specific Operator version, including installation instructions and extra details on how the user interacts with the Operator’s CRDs.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generating a File Skeleton" data-type="sect2"><div class="sect2" id="idm45261329647064">&#13;
<h2>Generating a File Skeleton</h2>&#13;
&#13;
<p>Given the amount of data included in a CSV file, the easiest starting point is to use the Operator SDK to generate a skeleton.<a data-primary="ClusterServiceVersion (CSV)" data-secondary="writing a CSV file" data-tertiary="generating file skeleton" data-type="indexterm" id="idm45261329645224"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="writing a CSV file" data-tertiary="generating file skeleton" data-type="indexterm" id="idm45261329643896"/> The SDK will build this skeleton with the basic structure of a Cluster Service Version file, and will populate it with as much data as it can determine about the Operator itself. It provides a good basis from which you can flesh out the remaining details.</p>&#13;
&#13;
<p>As each CSV corresponds to a particular Operator version, that version information is reflected in the filename scheme.<a data-primary="versions" data-secondary="Operator version in CSV files" data-type="indexterm" id="idm45261329641736"/> The filename pattern is to use the Operator name and append the semantic version number. For example, a CSV file for the Visitors Site Operator will be named something like <em>visitors-operator.v1.0.0.yaml</em>.</p>&#13;
&#13;
<p>In order for the Operator SDK to populate the skeleton CSV file with information about a specific Operator, you must run the generation command from the root of the Operator project source code. The general form of this command is as follows:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>operator-sdk olm-catalog gen-csv --csv-version <em>x.y.z</em></strong>&#13;
</pre>&#13;
&#13;
<p>Again, is it up to the Operator’s development team to determine their own version numbering policy. For consistency and general user-friendliness, we recommend that Operator releases follow <a href="https://semver.org">Semantic Versioning</a> principles.</p>&#13;
&#13;
<p>Running the CSV generation command on the Visitors Site Operator produces the following output:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>operator-sdk</code><code> </code><code>olm-catalog</code><code> </code><code>gen-csv</code><code> </code><code>--csv-version</code><code> </code><code>1.0.0</code></strong><code>&#13;
</code><code>INFO</code><code class="o">[</code><code>0000</code><code class="o">]</code><code> </code><code>Generating</code><code> </code><code>CSV</code><code> </code><code>manifest</code><code> </code><code>version</code><code> </code><code>1.0.0</code><code>&#13;
</code><code>INFO</code><code class="o">[</code><code>0000</code><code class="o">]</code><code> </code><code>Fill</code><code> </code><code>in</code><code> </code><code>the</code><code> </code><code>following</code><code> </code><code>required</code><code> </code><code>fields</code><code> </code><code>in</code><code> </code><code>file</code><code>&#13;
</code><code>visitors-operator/1.0.0/visitors-operator.v1.0.0.clusterserviceversion.yaml:</code><code>&#13;
    </code><code>spec.keywords</code><code>&#13;
    </code><code>spec.maintainers</code><code>&#13;
    </code><code>spec.provider</code><code>&#13;
</code><code>INFO</code><code class="o">[</code><code>0000</code><code class="o">]</code><code> </code><code>Created</code><code>&#13;
</code><code>visitors-operator/1.0.0/visitors-operator.v1.0.0.clusterserviceversion.yaml</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Even with only the base CSV structure, the generated file is already fairly detailed. At a high level, it includes the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>References to all CRDs the Operator owns (in other words, those defined in the Operator project)</p>&#13;
</li>&#13;
<li>&#13;
<p>A partial definition for the Operator’s Deployment resource</p>&#13;
</li>&#13;
<li>&#13;
<p>A set of RBAC rules that the Operator requires</p>&#13;
</li>&#13;
<li>&#13;
<p>Indicators describing the scope of namespaces the Operator will watch</p>&#13;
</li>&#13;
<li>&#13;
<p>An example custom resource (found in <code>metadata.annotations.alm-examples</code>) that you can modify for your needs</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We dive deeper into each of these components and the sorts of changes you should make to them in the following sections.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The SDK will not know the name of the image to use for the Operator itself. The skeleton file includes the field <code>image: REPLACE_IMAGE</code> in the deployment descriptor. You must update this value to point to a hosted image of the Operator (for example, on Docker Hub or Quay.io) that OLM will deploy.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Metadata" data-type="sect2"><div class="sect2" id="idm45261329703160">&#13;
<h2>Metadata</h2>&#13;
&#13;
<p>As previously mentioned, the <code>metadata.annotations.alm-examples</code> field contains an example for each CRD that the Operator owns. The SDK will initially populate this field using the custom resource manifest found in the Operator project’s <em>deploy/crds</em> directory. Be sure to review and flesh out this example with actual data that end users can further customize to their needs.</p>&#13;
&#13;
<p>Apart from <code>alm-examples</code>, you can find the remainder of the Operator’s metadata under the <code>spec</code> section of the manifest. The output of the SDK’s generation command highlights three specific fields as required:</p>&#13;
<dl>&#13;
<dt>keywords</dt>&#13;
<dd>&#13;
<p>A list of categories describing the Operator; compatible UIs use this for discovery</p>&#13;
</dd>&#13;
<dt>maintainers</dt>&#13;
<dd>&#13;
<p>A list of name and email pairings for the maintainers of the Operator codebase</p>&#13;
</dd>&#13;
<dt>provider</dt>&#13;
<dd>&#13;
<p>The name of the publishing entity for the Operator</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This snippet from the etcd Operator demonstrates the three required fields:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">keywords</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">'etcd'</code><code class="p-Indicator">,</code> <code class="s">'key</code><code class="nv"> </code><code class="s">value'</code><code class="p-Indicator">,</code> <code class="s">'database'</code><code class="p-Indicator">,</code> <code class="s">'coreos'</code><code class="p-Indicator">,</code> <code class="s">'open</code><code class="nv"> </code><code class="s">source'</code><code class="p-Indicator">]</code>&#13;
<code class="nt">maintainers</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd Community</code>&#13;
  <code class="nt">email</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-dev@googlegroups.com</code>&#13;
<code class="nt">provider</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">CNCF</code></pre>&#13;
&#13;
<p>We also encourage you to provide the following metadata fields, which produce a more robust listing in catalogs such as OperatorHub.io:</p>&#13;
<dl>&#13;
<dt>displayName</dt>&#13;
<dd>&#13;
<p>A user-friendly name for the Operator</p>&#13;
</dd>&#13;
<dt>description</dt>&#13;
<dd>&#13;
<p>A string describing the Operator’s functionality; you can use YAML constructs for multiline strings to provide further display information</p>&#13;
</dd>&#13;
<dt>version</dt>&#13;
<dd>&#13;
<p>The semantic version of the Operator, which should be incremented each time a new Operator image is published</p>&#13;
</dd>&#13;
<dt>replaces</dt>&#13;
<dd>&#13;
<p>The version, if any, of the Operator that this CSV updates</p>&#13;
</dd>&#13;
<dt>icon</dt>&#13;
<dd>&#13;
<p>A base64–encoded image used by compatible UIs</p>&#13;
</dd>&#13;
<dt>maturity</dt>&#13;
<dd>&#13;
<p>The maturity level of the Operator included in this release, such as <code>alpha</code>, <code>beta</code>, or <code>stable</code></p>&#13;
</dd>&#13;
<dt>links</dt>&#13;
<dd>&#13;
<p>A list of relevant links for the Operator, such as documentation, quick start guides, or blog entries</p>&#13;
</dd>&#13;
<dt>minKubeVersion</dt>&#13;
<dd>&#13;
<p>The minimum version of Kubernetes that the Operator must be deployed on, using the format “Major.Minor.Patch” (e.g., 1.13.0)</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Owned CRDs" data-type="sect2"><div class="sect2" id="owned_crds">&#13;
<h2>Owned CRDs</h2>&#13;
&#13;
<p>In order to install an Operator, OLM must know about all of the CRDs it uses.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="writing a CSV file" data-tertiary="owned CRDs" data-type="indexterm" id="idm45261329411208"/><a data-primary="ClusterServiceVersion (CSV)" data-secondary="writing a CSV file" data-tertiary="owned CRDs" data-type="indexterm" id="idm45261329409992"/> These come in two forms: those owned by the Operator and those that are used as dependencies (in CSV terms, these are referred to as “required” CRDs; we will cover these in the next section).</p>&#13;
&#13;
<p>The SDK skeleton generation adds the <code>spec.customresourcedefinitions</code> section to the CSV file. It also populates the <code>owned</code> section with entries for each CRD defined by the Operator, including identifying information such as <code>kind</code>, <code>name</code>, and <code>version</code>. However, there are more fields that you must manually add before the OLM bundle is valid.</p>&#13;
&#13;
<p>The following are required fields that you must set for each owned CRD:</p>&#13;
<dl>&#13;
<dt>displayName</dt>&#13;
<dd>&#13;
<p>The user-friendly name of the custom resource</p>&#13;
</dd>&#13;
<dt>description</dt>&#13;
<dd>&#13;
<p>Information about what the custom resource represents</p>&#13;
</dd>&#13;
<dt>resources</dt>&#13;
<dd>&#13;
<p>A list of Kubernetes resource types that will be created by the custom resource</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The <code>resources</code> list does not need to be exhaustive. Rather, it should only list visible resources that are relevant to the user. For example, you should list things an end user interacts with, such as service and deployment resources, but omit an internal ConfigMap that the user does not directly manipulate.</p>&#13;
&#13;
<p>You only need to include one instance of each resource type, regardless of how many resources of that type are created by the Operator. For example, if the custom resource creates multiple deployments, you only need to list the deployment resource type once.</p>&#13;
&#13;
<p>An example list for a custom resource that creates one or more deployments and services is as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">resources</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Service</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code></pre>&#13;
&#13;
<p>There are two more fields you need to add to each owned resource:  <span class="keep-together"><code>specDescriptors</code></span> and <code>statusDescriptors</code>. These fields provide additional metadata about the <code>spec</code> and <code>status</code> fields that will be present in the custom resource. Compatible UIs can use this additional information to render an interface for users.</p>&#13;
&#13;
<p>For each field in the custom resource’s spec, add an entry to the <code>specDescriptors</code> field.<a data-primary="spec descriptors, for CRDs owned by Operator in OLM" data-type="indexterm" id="idm45261329374184"/> Each entry should contain the following:</p>&#13;
<dl>&#13;
<dt>displayName</dt>&#13;
<dd>&#13;
<p>The user-friendly name of the field</p>&#13;
</dd>&#13;
<dt>description</dt>&#13;
<dd>&#13;
<p>Information about what the field represents</p>&#13;
</dd>&#13;
<dt>path</dt>&#13;
<dd>&#13;
<p>The dot-delimited path of the field in the object</p>&#13;
</dd>&#13;
<dt>x-descriptors</dt>&#13;
<dd>&#13;
<p>UI component information about the field’s capabilities</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#commonly_used_spec_descriptors">Table 8-1</a> lists the descriptors that are commonly supported by compatible UIs.</p>&#13;
<table id="commonly_used_spec_descriptors">&#13;
<caption><span class="label">Table 8-1. </span>Commonly used spec descriptors</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type</th>&#13;
<th>Descriptor string</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Boolean switch</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:booleanSwitch</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Checkbox</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:checkbox</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Endpoint list</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:endpointList</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Image pull policy</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:imagePullPolicy</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Label</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:label</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Namespace selector</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:namespaceSelector</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Node affinity</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:nodeAffinity</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Number</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:number</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Password</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:password</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Pod affinity</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:podAffinity</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Pod anti-affinity</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:podAntiAffinity</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Resource requirements</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:resourceRequirements</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Selector</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:selector:</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Text</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:text</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Update strategy</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:updateStrategy</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The structure of the <code>statusDescriptors</code> field is similar, including the same fields you need to specify. <a data-primary="status descriptors, for CRDs owned by Operator in OLM" data-type="indexterm" id="idm45261329306008"/>The only difference is the set of valid descriptors; these are listed in <a data-type="xref" href="#commonly_used_status_descriptors">Table 8-2</a>.</p>&#13;
<table id="commonly_used_status_descriptors">&#13;
<caption><span class="label">Table 8-2. </span>Commonly used status descriptors</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Type</th>&#13;
<th>Descriptor string</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Conditions</p></td>&#13;
<td><p><code>urn:alm:descriptor:io.kubernetes.conditions</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>k8s phase reason</p></td>&#13;
<td><p><code>urn:alm:descriptor:io.kubernetes.phase:reason</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>k8s phase</p></td>&#13;
<td><p><code>urn:alm:descriptor:io.kubernetes.phase</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Pod count</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:podCount</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Pod statuses</p></td>&#13;
<td><p><code>urn:alm:descriptor:com.tectonic.ui:podStatuses</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Prometheus endpoint</p></td>&#13;
<td><p><code>urn:alm:descriptor:prometheusEndpoint</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Text</p></td>&#13;
<td><p><code>urn:alm:descriptor:text</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>W3 link</p></td>&#13;
<td><p><code>urn:alm:descriptor:org.w3:link</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>As an example, the following snippet contains a subset of the descriptors for the etcd Operator:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">specDescriptors</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">The desired number of member Pods for the etcd cluster.</code>&#13;
    <code class="l-Scalar-Plain">displayName</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">Size</code>&#13;
    <code class="l-Scalar-Plain">path</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">size</code>&#13;
    <code class="l-Scalar-Plain">x-descriptors</code><code class="p-Indicator">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="s">'urn:alm:descriptor:com.tectonic.ui:podCount'</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">Limits describes the minimum/maximum amount of compute</code>&#13;
               <code class="l-Scalar-Plain">resources required/allowed</code>&#13;
    <code class="l-Scalar-Plain">displayName</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">Resource Requirements</code>&#13;
    <code class="l-Scalar-Plain">path</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">pod.resources</code>&#13;
    <code class="l-Scalar-Plain">x-descriptors</code><code class="p-Indicator">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="s">'urn:alm:descriptor:com.tectonic.ui:resourceRequirements'</code>&#13;
&#13;
<code class="nt">statusDescriptors</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">The status of each of the member Pods for the etcd cluster.</code>&#13;
    <code class="l-Scalar-Plain">displayName</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">Member Status</code>&#13;
    <code class="l-Scalar-Plain">path</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">members</code>&#13;
    <code class="l-Scalar-Plain">x-descriptors</code><code class="p-Indicator">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="s">'urn:alm:descriptor:com.tectonic.ui:podStatuses'</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">The current size of the etcd cluster.</code>&#13;
    <code class="l-Scalar-Plain">displayName</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">Cluster Size</code>&#13;
    <code class="l-Scalar-Plain">path</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">size</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">The current status of the etcd cluster.</code>&#13;
    <code class="l-Scalar-Plain">displayName</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">Status</code>&#13;
    <code class="l-Scalar-Plain">path</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">phase</code>&#13;
    <code class="l-Scalar-Plain">x-descriptors</code><code class="p-Indicator">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="s">'urn:alm:descriptor:io.kubernetes.phase'</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">Explanation for the current status of the cluster.</code>&#13;
    <code class="l-Scalar-Plain">displayName</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">Status Details</code>&#13;
    <code class="l-Scalar-Plain">path</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">reason</code>&#13;
    <code class="l-Scalar-Plain">x-descriptors</code><code class="p-Indicator">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="s">'urn:alm:descriptor:io.kubernetes.phase:reason'</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Required CRDs" data-type="sect2"><div class="sect2" id="idm45261329412472">&#13;
<h2>Required CRDs</h2>&#13;
&#13;
<p>Custom resources that are used by an Operator but not owned by it are designated as <em>required</em>.<a data-primary="required CRDs in CSV file" data-type="indexterm" id="idm45261329192056"/><a data-primary="custom resource definitions (CRDs)" data-secondary="required" data-type="indexterm" id="idm45261329191464"/> When installing an Operator, OLM will find the appropriate Operator that provides a required CRD and install it. This allows Operators to maintain a limited scope while utilizing composition and dependency resolution when necessary.</p>&#13;
&#13;
<p>The required section of a CSV is optional. Only Operators that require the use of other, non-Kubernetes resources need to include this.</p>&#13;
&#13;
<p>Each required CRD is specified using its:</p>&#13;
<dl>&#13;
<dt>name</dt>&#13;
<dd>&#13;
<p>The full name used to identify the required CRD</p>&#13;
</dd>&#13;
<dt>version</dt>&#13;
<dd>&#13;
<p>The version of the CRD desired</p>&#13;
</dd>&#13;
<dt>kind</dt>&#13;
<dd>&#13;
<p>The Kubernetes resource kind; displayed to users in compatible UIs</p>&#13;
</dd>&#13;
<dt>displayName</dt>&#13;
<dd>&#13;
<p>The user-friendly name of the field; displayed to users in compatible UIs</p>&#13;
</dd>&#13;
<dt>description</dt>&#13;
<dd>&#13;
<p>Information on how the required CRD is used; displayed to users in compatible UIs</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>For example, the following indicates an EtcdCluster is a required CRD for a different Operator:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">required</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcdclusters.etcd.database.coreos.com</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1beta2</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">EtcdCluster</code>&#13;
  <code class="nt">displayName</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd Cluster</code>&#13;
  <code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">Represents a cluster of etcd nodes.</code></pre>&#13;
&#13;
<p>One entry is needed under the <code>required</code> field for each required CRD.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Install Modes" data-type="sect2"><div class="sect2" id="idm45261329107608">&#13;
<h2>Install Modes</h2>&#13;
&#13;
<p>The install modes section of a CSV tells OLM<a data-primary="install modes for Operators in CSV file" data-type="indexterm" id="idm45261329106168"/><a data-primary="ClusterServiceVersion (CSV)" data-secondary="writing a CSV file" data-tertiary="install modes for Operators" data-type="indexterm" id="idm45261329105448"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="writing a CSV file" data-tertiary="install modes for Operators" data-type="indexterm" id="idm45261329104200"/> how the Operator can be deployed. There are four options, all of which must be present in the <code>installModes</code> field with their own flag indicating whether or not they are supported. The Operator SDK includes a default set of values for each of these options when generating a CSV.</p>&#13;
&#13;
<p>The following installation modes are supported:</p>&#13;
<dl>&#13;
<dt>OwnNamespace</dt>&#13;
<dd>&#13;
<p>The Operator can be deployed to an OperatorGroup that selects its own <span class="keep-together">namespace.</span></p>&#13;
</dd>&#13;
<dt>SingleNamespace</dt>&#13;
<dd>&#13;
<p>The Operator can be deployed to an OperatorGroup that selects one namespace.</p>&#13;
</dd>&#13;
<dt>MultiNamespace</dt>&#13;
<dd>&#13;
<p>The Operator can be deployed to an OperatorGroup that selects more than one namespace.</p>&#13;
</dd>&#13;
<dt>AllNamespaces</dt>&#13;
<dd>&#13;
<p>The Operator can be deployed to an OperatorGroup that selects all namespaces (defined as <code>targetNamespace: ""</code>).</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The following snippet shows the proper way to structure this field, along with the default values set by the SDK during generation:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">installModes</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">OwnNamespace</code>&#13;
  <code class="nt">supported</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">SingleNamespace</code>&#13;
  <code class="nt">supported</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">MultiNamespace</code>&#13;
  <code class="nt">supported</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">AllNamespaces</code>&#13;
  <code class="nt">supported</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Versioning and Updating" data-type="sect2"><div class="sect2" id="versioning_updating">&#13;
<h2>Versioning and Updating</h2>&#13;
&#13;
<p>True to its name, each Cluster Service Version file represents a single version of an Operator. <a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="writing a CSV file" data-tertiary="versions and upgrades for Operators" data-type="indexterm" id="idm45261329136232"/><a data-primary="versions" data-secondary="versioning and updating Operators in CSV file" data-type="indexterm" id="idm45261329135048"/><a data-primary="ClusterServiceVersion (CSV)" data-secondary="writing a CSV file" data-tertiary="versions and updates for Operators" data-type="indexterm" id="idm45261329134072"/>Subsequent versions of the Operator will each have their own CSV file. In many cases, this can be a copy of the previous version with the appropriate changes.</p>&#13;
&#13;
<p>The following describes the general changes you need to make between versions of an Operator (this is not an exhaustive list; take care to review the entire contents of the file to ensure no further changes are required):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Change the new CSV filename to reflect the new version of the Operator.</p>&#13;
</li>&#13;
<li>&#13;
<p>Update the <code>metadata.name</code> field of the CSV file with the new version.</p>&#13;
</li>&#13;
<li>&#13;
<p>Update the <code>spec.version</code> field with the new version.</p>&#13;
</li>&#13;
<li>&#13;
<p>Update the <code>spec.replaces</code> field to indicate the previous version of the CSV that is being upgraded by the new version.</p>&#13;
</li>&#13;
<li>&#13;
<p>In most cases, the new CSV will refer to a newer image of the Operator itself. Be sure to update the <code>spec.containers.image</code> field as appropriate to refer to the correct image.</p>&#13;
</li>&#13;
<li>&#13;
<p>In the event of a CRD change, you may need to update the <code>specDescriptor</code> and <code>statusDescriptor</code> fields of the CRD reference in the CSV file.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>While these changes will result in a new version of the Operator, users cannot access that version until it is present in a channel. Update the <em>*.package.yaml</em> file to reference the new CSV file for the appropriate channels (see the next section for more information on this file).</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Do not modify existing CSV files once they are released and in use by OLM. Make changes in a new version of the file instead, and propagate it to users through the use of channels.<a data-primary="ClusterServiceVersion (CSV)" data-secondary="writing a CSV file" data-startref="ix_CSVfile" data-type="indexterm" id="idm45261329045016"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="writing a CSV file" data-startref="ix_OLMCSV" data-type="indexterm" id="idm45261329043800"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing a Package Manifest File" data-type="sect1"><div class="sect1" id="writ_pack_manifest_file">&#13;
<h1>Writing a Package Manifest File</h1>&#13;
&#13;
<p>Compared to writing a Cluster Service Version file, writing a package manifest is significantly easier.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="writing a package manifest file" data-type="indexterm" id="idm45261329040600"/><a data-primary="package manifest file" data-secondary="writing" data-type="indexterm" id="idm45261329039592"/> A package file requires three fields:</p>&#13;
<dl>&#13;
<dt>packageName</dt>&#13;
<dd>&#13;
<p>The name of the Operator itself; this should match the value used in the CSV file</p>&#13;
</dd>&#13;
<dt>channels</dt>&#13;
<dd>&#13;
<p>A list of all channels for delivering versions of the Operator</p>&#13;
</dd>&#13;
<dt>defaultChannel</dt>&#13;
<dd>&#13;
<p>The name of the channel users should subscribe to by default</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Each entry in the <code>channels</code> field is made up of two items:</p>&#13;
<dl>&#13;
<dt>name</dt>&#13;
<dd>&#13;
<p>The name of the channel; this is what users will subscribe to</p>&#13;
</dd>&#13;
<dt>currentCSV</dt>&#13;
<dd>&#13;
<p>The full name (including the Operator name but not the <em>.yaml</em> suffix) of the CSV file that is currently installed through the channel</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>It is left to the Operator’s team to determine their policy for what channels will be supported.</p>&#13;
&#13;
<p>The following example distributes the Visitors Site Operator through two channels:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">packageName</code><code class="p">:</code> <code class="l-Scalar-Plain">visitors-operator</code>&#13;
<code class="nt">channels</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">stable</code>&#13;
  <code class="nt">currentCSV</code><code class="p">:</code> <code class="l-Scalar-Plain">visitors-operator.v1.0.0</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">testing</code>&#13;
  <code class="nt">currentCSV</code><code class="p">:</code> <code class="l-Scalar-Plain">visitors-operator.v1.1.0</code>&#13;
<code class="nt">defaultChannel</code><code class="p">:</code> <code class="l-Scalar-Plain">stable</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Locally" data-type="sect1"><div class="sect1" id="idm45261329026968">&#13;
<h1>Running Locally</h1>&#13;
&#13;
<p>Once you have written the necessary bundle files, the next step is to build the bundle and test it against a local cluster, such as one started by Minikube.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="running locally" data-type="indexterm" id="idm45261328972072"/> In the following sections, we’ll describe the process of installing OLM into a cluster, building the OLM bundle, and subscribing to a channel to deploy the Operator.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prerequisites" data-type="sect2"><div class="sect2" id="idm45261328970680">&#13;
<h2>Prerequisites</h2>&#13;
&#13;
<p>This section covers the changes you need to make to the cluster to run OLM, as well as configuring it to look at your repository of bundles.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="building bundle file and running locally" data-tertiary="prerequisites" data-type="indexterm" id="ix_OLMbldbndpre"/> You only need to complete these steps once for a cluster; we cover iterative development and testing of an Operator in <a data-type="xref" href="#building_the_olm_bundle">“Building the OLM Bundle”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Install the Marketplace Operator" data-type="sect3"><div class="sect3" id="idm45261328966248">&#13;
<h3>Install the Marketplace Operator</h3>&#13;
&#13;
<p>The Marketplace Operator imports Operators from an external data store. In this chapter, you’ll be using Quay.io to host your OLM bundles.<a data-primary="Marketplace Operator" data-type="indexterm" id="idm45261328964392"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Despite its name, the Marketplace Operator is not tied to a particular source of Operators. It simply acts as a conduit to pull Operators from any compatible external store. One such site is OperatorHub.io, which we discuss in <a data-type="xref" href="ch10.html#getting_involved">Chapter 10</a>.</p>&#13;
</div>&#13;
&#13;
<p>In keeping with the notion that CRDs represent an Operator’s API, installing the Marketplace Operator introduces two CRDs:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The OperatorSource resource describes an external hosting registry for OLM bundles. In this example, we use Quay.io, a free image hosting site.</p>&#13;
</li>&#13;
<li>&#13;
<p>The CatalogSourceConfig resource bridges between an OperatorSource and OLM itself. An OperatorSource automatically creates CatalogSourceConfig resources, and you do not need to explicitly interact with this type.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Similar to OLM, the Marketplace Operator is an evolving project. As such, be sure to consult <a href="https://oreil.ly/VNOrU">its GitHub repository</a> to find the latest installation instructions for the current release.</p>&#13;
</div>&#13;
&#13;
<p>As there are currently no formal releases of the Marketplace Operator, it is installed by cloning the upstream repository and using the manifests within:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>git</code><code> </code><code>clone</code><code> </code><code>https://github.com/operator-framework/operator-marketplace.git</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code class="nb">cd </code><code>operator-marketplace</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code>deploy/upstream/</code></strong><code>&#13;
</code><code>namespace/marketplace</code><code> </code><code>created</code><code>&#13;
</code><code>customresourcedefinition.apiextensions.k8s.io/catalogsourceconfigs.....</code><code>&#13;
</code><code>customresourcedefinition.apiextensions.k8s.io/operatorsources.operators....</code><code>&#13;
</code><code>serviceaccount/marketplace-operator</code><code> </code><code>created</code><code>&#13;
</code><code>clusterrole.rbac.authorization.k8s.io/marketplace-operator</code><code> </code><code>created</code><code>&#13;
</code><code>role.rbac.authorization.k8s.io/marketplace-operator</code><code> </code><code>created</code><code>&#13;
</code><code>clusterrolebinding.rbac.authorization.k8s.io/marketplace-operator</code><code> </code><code>created</code><code>&#13;
</code><code>rolebinding.rbac.authorization.k8s.io/marketplace-operator</code><code> </code><code>created</code><code>&#13;
</code><code>operatorsource.operators.coreos.com/upstream-community-operators</code><code> </code><code>created</code><code>&#13;
</code><code>deployment.apps/marketplace-operator</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
&#13;
<p>You can verify the installation by ensuring the <code>marketplace</code> namespace was created:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>ns</code><code> </code><code>marketplace</code></strong><code>&#13;
</code><code>NAME</code><code>          </code><code>STATUS</code><code>   </code><code>AGE</code><code>&#13;
</code><code>marketplace</code><code>   </code><code>Active</code><code>   </code><code>4m19s</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Install Operator Courier" data-type="sect3"><div class="sect3" id="idm45261328965752">&#13;
<h3>Install Operator Courier</h3>&#13;
&#13;
<p>Operator Courier is a client-side tool used for building and pushing the OLM bundle to a repository. <a data-primary="Operator Courier" data-secondary="installing" data-type="indexterm" id="idm45261328869976"/>It is also used for verifying the contents of the bundle files.</p>&#13;
&#13;
<p>You can install Operator Courier through the Python package installer <code>pip</code>:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>pip3</code><code> </code><code>install</code><code> </code><code>operator-courier</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>Once installed, you can run Operator Courier from the command line:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>operator-courier</code></strong><code>&#13;
</code><code>usage:</code><code> </code><code>operator-courier</code><code> </code><code>&lt;</code><code class="nb">command</code><code>&gt;</code><code> </code><code class="o">[</code><code>&lt;</code><code>args&gt;</code><code class="o">]</code><code>&#13;
&#13;
</code><code>These</code><code> </code><code>are</code><code> </code><code>the</code><code> </code><code>commands</code><code> </code><code>you</code><code> </code><code>can</code><code> </code><code>use:</code><code>&#13;
    </code><code>verify</code><code>      </code><code>Create</code><code> </code><code>a</code><code> </code><code>bundle</code><code> </code><code>and</code><code> </code><code class="nb">test </code><code>it</code><code> </code><code class="k">for</code><code> </code><code>correctness.</code><code>&#13;
    </code><code>push</code><code>        </code><code>Create</code><code> </code><code>a</code><code> </code><code>bundle,</code><code> </code><code class="nb">test </code><code>it,</code><code> </code><code>and</code><code> </code><code>push</code><code> </code><code>it</code><code> </code><code>to</code><code> </code><code>an</code><code> </code><code>app</code><code> </code><code>registry.</code><code>&#13;
    </code><code>nest</code><code>        </code><code>Take</code><code> </code><code>a</code><code> </code><code>flat</code><code> </code><code>to-be-bundled</code><code> </code><code>directory</code><code> </code><code>and</code><code> </code><code>version</code><code> </code><code>nest</code><code> </code><code>it.</code><code>&#13;
    </code><code>flatten</code><code>     </code><code>Create</code><code> </code><code>a</code><code> </code><code>flat</code><code> </code><code>directory</code><code> </code><code>from</code><code> </code><code>versioned</code><code> </code><code>operator</code><code> </code><code>bundle</code><code> </code><code>yaml</code><code>&#13;
                </code><code>files.</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Retrieve a Quay token" data-type="sect3"><div class="sect3" id="idm45261328603112">&#13;
<h3>Retrieve a Quay token</h3>&#13;
&#13;
<p>Quay.io is a free hosting site for container images.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="building bundle file and running locally" data-tertiary="retrieving a Quay token" data-type="indexterm" id="idm45261328720264"/><a data-primary="Quay.io" data-secondary="retrieving a token from" data-type="indexterm" id="idm45261328719160"/> We will use Quay.io to host the OLM bundles to serve them to the Operator Marketplace.</p>&#13;
&#13;
<p>New users can sign up for a free Quay.io account <a href="https://quay.io/">via the website</a>.</p>&#13;
&#13;
<p>In order for Operator Courier to push OLM bundles into your Quay.io account, you need an authentication token. While the token is accessible through the web UI, you can also use the following script to retrieve it from the command line, substituting your username and password as indicated:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">USERNAME</code><code class="o">=</code>&lt;quay.io username&gt;&#13;
<code class="nv">PASSWORD</code><code class="o">=</code>&lt;quay.io password&gt;&#13;
<code class="nv">URL</code><code class="o">=</code>https://quay.io/cnr/api/v1/users/login&#13;
&#13;
<code class="nv">TOKEN_JSON</code><code class="o">=</code><code class="k">$(</code>curl -s -H <code class="s2">"Content-Type: application/json"</code> -XPOST <code class="nv">$URL</code> -d <code class="se">\</code>&#13;
<code class="s1">'{"user":{"username":"'</code><code class="s2">"</code><code class="si">${</code><code class="nv">USERNAME</code><code class="si">}</code><code class="s2">"</code><code class="s1">'","password": "'</code><code class="s2">"</code><code class="si">${</code><code class="nv">PASSWORD</code><code class="si">}</code><code class="s2">"</code><code class="s1">'"}}'</code><code class="k">)</code>&#13;
&#13;
<code class="nb">echo</code> <code class="sb">`</code><code class="nb">echo</code> <code class="nv">$TOKEN_JSON</code> <code class="p">|</code> awk <code class="s1">'{split($0,a,"\""); print a[4]}'</code><code class="sb">`</code></pre>&#13;
&#13;
<p>An interactive version of this script is provided in <a href="https://github.com/kubernetes-operators-book/chapters/blob/master/ch08/get-quay-token">this book’s GitHub repository</a>.</p>&#13;
&#13;
<p>You will use this token later when pushing the bundle to Quay.io, so save it somewhere accessible. The output of the script provides a command to save it as an environment variable.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create the OperatorSource" data-type="sect3"><div class="sect3" id="idm45261328691976">&#13;
<h3>Create the OperatorSource</h3>&#13;
&#13;
<p>An OperatorSource resource defines the external data store used to host Operator bundles.<a data-primary="OperatorSource" data-secondary="creating" data-type="indexterm" id="idm45261328690200"/> In this case, you will be defining an OperatorSource to point to your Quay.io account, which will provide access to its hosted OLM bundles.</p>&#13;
&#13;
<p>A sample OperatorSource manifest follows; you should replace both instances of <code>&lt;QUAY_USERNAME&gt;</code> with your Quay.io username:</p>&#13;
&#13;
<pre data-type="programlisting">apiVersion: operators.coreos.com/v1&#13;
kind: OperatorSource&#13;
metadata:&#13;
  name: &lt;QUAY_USERNAME&gt;-operators  <a class="co" href="#callout_operator_lifecycle_manager_CO3-1" id="co_operator_lifecycle_manager_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
  namespace: marketplace&#13;
spec:&#13;
  type: appregistry&#13;
  endpoint: https://quay.io/cnr&#13;
  registryNamespace: &lt;QUAY_USERNAME&gt;</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO3-1" id="callout_operator_lifecycle_manager_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Using your username here isn’t a hard requirement; it’s just a simple way to ensure uniqueness for the OperatorSource name.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Once you’ve written the OperatorSource manifest, create the resource using the following command (assuming the manifest file is named <em>operator-source.yaml</em>):</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code>operator-source.yaml</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>To verify the OperatorSource was deployed <a data-primary="OperatorSource" data-secondary="verifying deployment of" data-type="indexterm" id="idm45261328685528"/>correctly, you can look in the <code>marketplace</code> namespace for a list of all known OperatorSources:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>opsrc</code><code> </code><code>-n</code><code> </code><code>marketplace</code></strong><code>&#13;
</code><code>NAME</code><code>            </code><code>TYPE</code><code>         </code><code>ENDPOINT</code><code>             </code><code>REGISTRY</code><code>  </code><code>STATUS</code><code>&#13;
</code><code>jdob-operators</code><code>  </code><code>appregistry</code><code>  </code><code>https://quay.io/cnr</code><code>  </code><code>jdob</code><code>      </code><code>Failed</code><code> </code><a class="co" href="#c01-04" id="comarker1-04"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code></pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1-04" id="c01-04"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p>If there are no bundles at the endpoint when you create the source, the status will be <code>Failed</code>. You can ignore this for now; you’ll refresh this list later, once you’ve uploaded a bundle.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The output shown here has been truncated for readability; your results may vary slightly.</p>&#13;
</div>&#13;
&#13;
<p>When the OperatorSource is initially created, it may fail if there are no OLM bundles found in the user’s Quay.io application list. In a later step, you will create and deploy the bundles, after which the OperatorSource will start correctly. We included this step as a prerequisite since you only need to do it once; when updating an OLM bundle or creating new ones in the same Quay.io namespace, you will reuse the OperatorSource resource.</p>&#13;
&#13;
<p>Additionally, the OperatorSource creation results in the creation of a CatalogSource.<a data-primary="CatalogSource" data-secondary="OperatorSource creation and" data-type="indexterm" id="idm45261328579560"/> No further action is required for this resource, but you can confirm its existence by checking in the <code>marketplace</code> namespace:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>catalogsource</code><code> </code><code>-n</code><code> </code><code>marketplace</code></strong><code>&#13;
</code><code>NAME</code><code>            </code><code>NAME</code><code>     </code><code>TYPE</code><code>   </code><code>PUBLISHER</code><code>   </code><code>AGE</code><code>&#13;
</code><code>jdob-operators</code><code>           </code><code>grpc</code><code>               </code><code>6m5s</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building the OLM Bundle" data-type="sect2"><div class="sect2" id="building_the_olm_bundle">&#13;
<h2>Building the OLM Bundle</h2>&#13;
&#13;
<p>Once you’ve installed the initial prerequisites, the bulk of your time is spent on a build and test cycle.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="building bundle file and running locally" data-startref="ix_OLMbldbndpre" data-tertiary="prerequisites" data-type="indexterm" id="idm45261328538344"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="building bundle file and running locally" data-tertiary="building the bundle" data-type="indexterm" id="ix_OLMbldbndbld"/> This section covers the steps necessary to build and host an OLM bundle on Quay.io.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Perform linting" data-type="sect3"><div class="sect3" id="idm45261328535208">&#13;
<h3>Perform linting</h3>&#13;
&#13;
<p>OLM bundles are verified<a data-primary="linting OLM bundles" data-type="indexterm" id="idm45261328533912"/><a data-primary="Operator Courier" data-secondary="verify command" data-type="indexterm" id="idm45261328533208"/> using Operator Courier’s <code>verify</code> command:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>operator-courier</code><code> </code><code>verify</code><code> </code><code class="nv">$OLM_FILES_DIRECTORY</code></strong><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Push the bundle to Quay.io" data-type="sect3"><div class="sect3" id="idm45261328513576">&#13;
<h3>Push the bundle to Quay.io</h3>&#13;
&#13;
<p>When the metadata files pass verification and are ready to be tested, Operator Courier uploads the OLM bundle into your Quay.io account.<a data-primary="Quay.io" data-secondary="pushing OLM bundle to" data-type="indexterm" id="idm45261328512008"/> There are a number of required parameters (and some optional arguments) when using the <code>push</code> command:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>operator-courier</code><code> </code><code>push</code></strong><code>&#13;
</code><code>usage:</code><code> </code><code>operator-courier</code><code> </code><code class="o">[</code><code>-h</code><code class="o">]</code><code> </code><code class="o">[</code><code>--validation-output</code><code> </code><code>VALIDATION_OUTPUT</code><code class="o">]</code><code>&#13;
</code><code>source_dir</code><code> </code><code>namespace</code><code> </code><code>repository</code><code> </code><code>release</code><code> </code><code>token</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Here’s an example push for the Visitors Site Operator:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">OPERATOR_DIR</code><code class="o">=</code><code>visitors-olm/</code><code>&#13;
</code><code class="nv">QUAY_NAMESPACE</code><code class="o">=</code><code>jdob</code><code>&#13;
</code><code class="nv">PACKAGE_NAME</code><code class="o">=</code><code>visitors-operator</code><code>&#13;
</code><code class="nv">PACKAGE_VERSION</code><code class="o">=</code><code>1.0.0</code><code>&#13;
</code><code class="nv">QUAY_TOKEN</code><code class="o">=</code><code>*****</code><code> </code><a class="co" href="#c01-05" id="comarker1-05"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="nv">$ </code><strong><code>operator-courier</code><code> </code><code>push</code><code> </code><code class="s2">"</code><code class="nv">$OPERATOR_DIR</code><code class="s2">"</code><code> </code><code class="s2">"</code><code class="nv">$QUAY_NAMESPACE</code><code class="s2">"</code><code> </code><code class="se">\&#13;
</code><code class="s2">"</code><code class="nv">$PACKAGE_NAME</code><code class="s2">"</code><code> </code><code class="s2">"</code><code class="nv">$PACKAGE_VERSION</code><code class="s2">"</code><code> </code><code class="s2">"</code><code class="nv">$QUAY_TOKEN</code><code class="s2">"</code></strong><code>&#13;
</code></pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1-05" id="c01-05"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p><code>QUAY_TOKEN</code> is the full token, including the “basic” prefix. You can use the script we introduced earlier in this section to set this variable.</p></dd>&#13;
  </dl>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>By default, bundles pushed to Quay.io in this fashion are marked as private. Navigate to the image at <a href="https://quay.io/application/"><em class="hyperlink">https://quay.io/application/</em></a> and mark it as public so that it is accessible to the cluster.</p>&#13;
</div>&#13;
&#13;
<p>The Operator bundle is now ready for testing.<a data-primary="PACKAGE_VERSION variable" data-type="indexterm" id="idm45261328412200"/> For subsequent versions, update the <code>PACKAGE_VERSION</code> variable according to the new version of the CSV file (see <a data-type="xref" href="#versioning_updating">“Versioning and Updating”</a> for more information) and push a new bundle.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Restart the OperatorSource" data-type="sect3"><div class="sect3" id="idm45261328410088">&#13;
<h3>Restart the OperatorSource</h3>&#13;
&#13;
<p>The OperatorSource reads the list of Operators in the configured Quay.io account on startup.<a data-primary="OperatorSource" data-secondary="restarting" data-type="indexterm" id="idm45261328408472"/> After uploading a new Operator or a new version of a CSV file, you’ll need to restart the OperatorSource pod to pick up the changes.</p>&#13;
&#13;
<p>The pod’s name begins with the same name as the OperatorSource. Using the example OperatorSource from the previous section, with “jdob” as the Quay.io username, the following demonstrates how to restart the OperatorSource:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods -n marketplace</strong>&#13;
NAME                                      READY   STATUS    RESTARTS   AGE&#13;
jdob-operators-5969c68d68-vfff6           1/1     Running   <code>0</code>          34s&#13;
marketplace-operator-bb555bb7f-sxj7d      1/1     Running   <code>0</code>           102m&#13;
upstream-community-operators-588bf67cfc   1/1     Running   <code>0</code>           101m&#13;
&#13;
$ <strong>kubectl delete pod jdob-operators-5969c68d68-vfff6 -n marketplace</strong>&#13;
<code>pod "jdob-operators-5969c68d68-vfff6" deleted</code>&#13;
&#13;
$ <strong>kubectl get pods -n marketplace</strong>&#13;
NAME                                      READY   STATUS    RESTARTS   AGE&#13;
jdob-operators-5969c68d68-6w8tm           1/1     Running   <code>0</code>           12s  <a class="co" href="#c01-06" id="comarker1-06"><img alt="1" src="assets/1.png"/></a>&#13;
marketplace-operator-bb555bb7f-sxj7d      1/1     Running   <code>0</code>           102m&#13;
upstream-community-operators-588bf67cfc   1/1     Running   <code>0</code>           102m&#13;
</pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1-06" id="c01-06"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p>The newly started pod name suffix differs from the original pod, confirming that a new pod has been created.</p></dd>&#13;
</dl>&#13;
&#13;
<p>At any point, you can query the OperatorSource to see a list of its known Operators:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code class="nv">OP_SRC_NAME</code><code class="o">=</code><code>jdob-operators</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>opsrc</code><code> </code><code class="nv">$OP_SRC_NAME</code><code> </code><code class="se">\&#13;
</code><code>-o</code><code class="o">=</code><code>custom-columns</code><code class="o">=</code><code>NAME:.metadata.name,PACKAGES:.status.packages</code><code> </code><code class="se">\&#13;
</code><code>-n</code><code> </code><code>marketplace</code></strong><code>&#13;
</code><code>NAME</code><code>             </code><code>PACKAGES</code><code>&#13;
</code><code>jdob-operators</code><code>   </code><code>visitors-operator</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing the Operator Through OLM" data-type="sect2"><div class="sect2" id="idm45261328338552">&#13;
<h2>Installing the Operator Through OLM</h2>&#13;
&#13;
<p>After you’ve configured the Marketplace Operator to retrieve your bundle, test it by creating a subscription to one of its supported channels.<a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="building bundle file and running locally" data-startref="ix_OLMbldbndbld" data-tertiary="building the bundle" data-type="indexterm" id="idm45261328337368"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="building bundle file and running locally" data-tertiary="installing Operator through OLM" data-type="indexterm" id="idm45261328335912"/> OLM reacts to the subscription and installs the corresponding Operator.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create the OperatorGroup" data-type="sect3"><div class="sect3" id="idm45261328334536">&#13;
<h3>Create the OperatorGroup</h3>&#13;
&#13;
<p>You’ll need an OperatorGroup to denote which namespaces the Operator should watch.<a data-primary="OperatorGroup" data-secondary="creating for Operator installed via OLM" data-type="indexterm" id="idm45261328333032"/> It must exist in the namespace where you want to deploy the Operator. For simplicity while testing, the example OperatorGroup defined here deploys the Operator into the existing <code>marketplace</code> namespace:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">operators.coreos.com/v1alpha2</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">OperatorGroup</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">book-operatorgroup</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">marketplace</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">targetNamespaces</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">marketplace</code></pre>&#13;
&#13;
<p>Like with other Kubernetes resources, use the <code>kubectl</code> <code>apply</code> command to create the OperatorGroup:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code>operator-group.yaml</code></strong><code>&#13;
</code><code>operatorgroup.operators.coreos.com/book-operatorgroup</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create the subscription" data-type="sect3"><div class="sect3" id="idm45261328278872">&#13;
<h3>Create the subscription</h3>&#13;
&#13;
<p>A subscription links the previous steps together by selecting an Operator and one of its channels.<a data-primary="subscriptions" data-secondary="creating for Operator installed via OLM" data-type="indexterm" id="idm45261328277288"/> OLM uses this information to start the corresponding Operator pod.</p>&#13;
&#13;
<p>The following example creates a new subscription to the stable channel for the Visitors Site Operator:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code>apiVersion:</code><code> </code><code>operators.coreos.com/v1alpha1</code><code>&#13;
</code><code>kind:</code><code> </code><code>Subscription</code><code>&#13;
</code><code>metadata:</code><code>&#13;
  </code><code>name:</code><code> </code><code>book-sub</code><code>&#13;
  </code><code>namespace:</code><code> </code><code>marketplace</code><code>  </code><a class="co" href="#callout_operator_lifecycle_manager_CO4-1" id="co_operator_lifecycle_manager_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>spec:</code><code>&#13;
  </code><code>channel:</code><code> </code><code>stable</code><code>  </code><a class="co" href="#callout_operator_lifecycle_manager_CO4-2" id="co_operator_lifecycle_manager_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code>name:</code><code> </code><code>visitors-operator</code><code>&#13;
  </code><code class="nb">source</code><code>:</code><code> </code><code>jdob-operators</code><code>  </code><a class="co" href="#callout_operator_lifecycle_manager_CO4-3" id="co_operator_lifecycle_manager_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code>sourceNamespace:</code><code> </code><code>marketplace</code><code>  </code><a class="co" href="#callout_operator_lifecycle_manager_CO4-4" id="co_operator_lifecycle_manager_CO4-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO4-1" id="callout_operator_lifecycle_manager_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Indicates the namespace the subscription will be created in.</p></dd>&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO4-2" id="callout_operator_lifecycle_manager_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Selects one of the channels defined in the package manifest.</p></dd>&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO4-3" id="callout_operator_lifecycle_manager_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Identifies which OperatorSource to look at for the corresponding Operator and channel.</p></dd>&#13;
<dt><a class="co" href="#co_operator_lifecycle_manager_CO4-4" id="callout_operator_lifecycle_manager_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Specifies the OperatorSource’s namespace.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Create the subscription using the <code>apply</code> command:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code>subscription.yaml</code></strong><code>&#13;
</code><code>subscription.operators.coreos.com/book-sub</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
&#13;
<p>OLM will be notified of the new subscription and will start the Operator pod in the <code>marketplace</code> namespace:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods -n marketplace</strong>&#13;
NAME                                           READY   STATUS    RESTARTS   AGE&#13;
jdob-operators-5969c68d68-6w8tm                1/1     Running   <code>0</code>           143m&#13;
visitors-operator-86cb966f59-l5bkg             1/1     Running   <code>0</code>           12s&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We have truncated the output here for readability; your results may vary slightly.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing the Running Operator" data-type="sect2"><div class="sect2" id="idm45261328163528">&#13;
<h2>Testing the Running Operator</h2>&#13;
&#13;
<p>Once OLM has started the Operator, you can test it by creating a custom resource of the same type that the Operator owns.<a data-primary="testing" data-secondary="for running Operator installed via OLM" data-type="indexterm" id="idm45261328162088"/><a data-primary="Operator Lifecycle Manager (OLM)" data-secondary="testing the running Operator" data-type="indexterm" id="idm45261328161144"/> Refer to Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#adapter_operators">6</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.html#operators_in_go_with_the_operator_sdk">7</a> for more information about testing a running Operator.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Visitors Site Operator Example" data-type="sect1"><div class="sect1" id="idm45261328139592">&#13;
<h1>Visitors Site Operator Example</h1>&#13;
&#13;
<p>You can find the OLM bundle files <a data-primary="Visitors Site sample application" data-secondary="testing the Operator" data-type="indexterm" id="idm45261328138136"/>for the Visitors Site Operator in <a href="https://github.com/kubernetes-operators-book/chapters/tree/master/ch08">the book’s GitHub repository</a>.</p>&#13;
&#13;
<p>There are two directories of note:</p>&#13;
<dl>&#13;
<dt><em>bundle</em></dt>&#13;
<dd>&#13;
<p>This directory contains the actual OLM bundle files, including the CSV, CRD, and package files. You can use the process outlined in this chapter to build and deploy the Visitors Site Operator using these files.</p>&#13;
</dd>&#13;
<dt><em>testing</em></dt>&#13;
<dd>&#13;
<p>This directory contains the additional resources required to deploy an Operator from OLM. These include the OperatorSource, OperatorGroup, subscription, and a sample custom resource to test the Operator.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Readers are welcome to submit feedback, issues, and questions on these files through the Issues tab in GitHub.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45261328131384">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>As with any piece of software, managing installation and upgrades is critical for Operators. Operator Lifecycle Manager<a data-primary="Operator Lifecycle Manager (OLM)" data-startref="ix_OLM" data-type="indexterm" id="idm45261328129928"/> fills this role, giving you a mechanism for discovering Operators, handling updates, and ensuring stability.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Resources" data-type="sect1"><div class="sect1" id="idm45261328128424">&#13;
<h1>Resources</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/cu1IP">OLM installation</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/1IN19">OLM repository</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/VVvFM">Marketplace Operator repository</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/d6XdP">Operator Courier repository</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>