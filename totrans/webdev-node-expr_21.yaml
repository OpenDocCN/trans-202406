- en: Chapter 21\. Going Live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The big day is here: you’ve spent weeks or months toiling over your labor of
    love, and now your website or service is ready to launch. It’s not as easy as
    just “flipping a switch” and then your website is live…or is it?'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter (which you should really read *weeks* before launch, not the
    day of!), you’ll learn about some of the domain registration and hosting services
    available to you, techniques for moving from a staging environment to production,
    deployment techniques, and things to consider when picking production services.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Registration and Hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People are often confused about the difference between *domain registration*
    and *hosting*. If you’re reading this book, you probably aren’t, but I bet you
    know people who are, like your clients or your manager.
  prefs: []
  type: TYPE_NORMAL
- en: Every website and service on the internet can be identified by an *Internet
    Protocol (IP) address* (or more than one). These numbers are not particularly
    friendly to humans (and that situation will only get worse as IPv6 adoption improves),
    but your computer ultimately needs these numbers to show you a web page. That’s
    where *domain names* come in. They map a human-friendly name (like *google.com*)
    with an IP address (74.125.239.13 or 2601:1c2:1902:5b38:c256:27ff:fe70:47d1).
  prefs: []
  type: TYPE_NORMAL
- en: A real-world analogy would be the difference between a business name and a physical
    address. A domain name is like your business name (Apple), and an IP address is
    like your physical address (One Apple Park Way, Cupertino, CA 95014). If you need
    to actually get in your car and visit Apple’s headquarters, you’ll need to know
    the physical address. Fortunately, if you know the business name, you can probably
    get the physical address. The other reason this abstraction is helpful is that
    an organization can move (getting a new physical address), and people can still
    find it even though it’s moved (as a matter of fact, Apple *did* move its physical
    headquarters between the first and second editions of this book).
  prefs: []
  type: TYPE_NORMAL
- en: '*Hosting*, on the other hand, describes the computers that run your website.
    To continue the physical analogy, hosting could be compared to the buildings you
    see once you reach the physical address. What is often confusing to people is
    that domain registration has very little to do with hosting, and you do not always
    purchase your domain from the same entity that you pay for hosting (in the same
    way that you usually buy land from one person and pay another person to build
    and maintain buildings for you).'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it’s certainly possible to host your website without a domain name, it’s
    quite unfriendly: IP addresses aren’t very marketable! Usually, when you purchase
    hosting, you’re automatically assigned a subdomain (which we’ll cover in a moment),
    which can be thought of as something between a marketing-friendly domain name
    and an IP address (for example, *ec2-54-201-235-192.us-west-2.compute.amazonaws.com*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a domain, and you go live, you could reach your website with
    multiple URLs. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*http://meadowlarktravel.com/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*http://www.meadowlarktravel.com/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*http://ec2-54-201-235-192.us-west-2.compute.amazonaws.com/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*http://54.201.235.192/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to domain mapping, all of these addresses point to the same website.
    Once the requests reach your website, it is possible to take action based on the
    URL that was used. For example, if someone gets to your website from the IP address,
    you could automatically redirect to the domain name, though that is not very common
    as there is little point to it (it is more common to redirect from *http://meadowlarktravel.com/*
    to *http://www.meadowlarktravel.com/*).
  prefs: []
  type: TYPE_NORMAL
- en: Most domain registrars offer hosting services (or partner with companies that
    do). Aside from AWS, I’ve never found registrar hosting options to be particularly
    attractive, and it’s okay to separate domain registration and hosting.
  prefs: []
  type: TYPE_NORMAL
- en: Domain Name System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Domain Name System* (DNS) is what’s responsible for mapping domain names
    to IP addresses. The system is fairly intricate, but there are some things about
    DNS that you should know as a website owner.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should always keep in mind that *domain names are valuable*. If a hacker
    were to completely compromise your hosting service and take control of your hosting,
    but you retained control of your domain, you could get new hosting and redirect
    the domain. If, on the other hand, your *domain* were compromised, you could be
    in real trouble. Your reputation is tied to your domain, and good domain names
    are carefully guarded. People who have lost control of domains have found that
    it can be devastating, and there are those in the world who will actively try
    to compromise your domain (especially if it’s a particularly short or memorable
    one) so they can sell it off, ruin your reputation, or blackmail you. The upshot
    is that *you should take domain security very seriously*, perhaps even more seriously
    than your data (depending on how valuable your data is). I’ve seen people spend
    inordinate amounts of time and money on hosting security while getting the cheapest,
    sketchiest domain registration they can find. Don’t make that mistake. (Fortunately,
    quality domain registration is not particularly expensive.)
  prefs: []
  type: TYPE_NORMAL
- en: Given the importance of protecting ownership of your domain, you should employ
    good security practices with respect to your domain registration. At the very
    least, you should use strong, unique passwords, and employ proper password hygiene
    (no keeping it on a sticky note attached to your monitor). Preferably, you should
    use a registrar that offers two-factor authentication. Don’t be afraid to ask
    your registrar pointed questions about what is required to authorize changes to
    your account. The registrars I recommend are AWS Route 53, Name.com and Namecheap.com.
    All three offer two-factor authentication, and I have found their support to be
    good and their online control panels to be easy and robust.
  prefs: []
  type: TYPE_NORMAL
- en: When you register a domain, you must provide a third-party email address that’s
    associated with that domain (i.e., if you’re registering *meadowlarktravel.com*,
    you shouldn’t use *admin@meadowlarktravel.com* as your registrant email). Since
    any security system is as strong as its weakest link, you should use an email
    address with good security. It’s quite common to use a Gmail or Outlook account,
    and if you do, you should employ the same security standards as you do with your
    domain registrar account (good password hygiene and two-factor authentication).
  prefs: []
  type: TYPE_NORMAL
- en: Top-Level Domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What your domain ends with (such as *.com* or *.net*) is called a *top-level-domain*
    (TLD). Generally speaking, there are two types of TLD: country code TLDs and general
    TLDs. Country code TLDs (such as *.us*, *.es*, and *.uk*) are designed to provide
    a geographic categorization. However, there are few restrictions on who can acquire
    these TLDs (the internet is truly a global network, after all), so they are often
    used for “clever” domains, such as *placehold.it* and *goo.gl*.'
  prefs: []
  type: TYPE_NORMAL
- en: General TLDs (gTLDs) include the familiar *.com*, *.net*, *.gov*, *.fed*, *.mil*,
    and *.edu*. While anyone can acquire an available *.com* or *.net* domain, there
    are restrictions in place for the others mentioned. For more information, see
    [Table 21-1](#restrictedgtlds).
  prefs: []
  type: TYPE_NORMAL
- en: Table 21-1\. Restricted gTLDs
  prefs: []
  type: TYPE_NORMAL
- en: '| TLD | More information |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *.gov*, *.fed* | [*https://www.dotgov.gov*](https://www.dotgov.gov) |'
  prefs: []
  type: TYPE_TB
- en: '| *.edu* | [*https://net.educause.edu/*](https://net.educause.edu/) |'
  prefs: []
  type: TYPE_TB
- en: '| *.mil* | Military personnel and contractors should contact their IT department,
    or the [Department of Defense Unified Registration System](http://bit.ly/354JvZF)
    |'
  prefs: []
  type: TYPE_TB
- en: The Internet Corporation for Assigned Names and Numbers (ICANN) is ultimately
    responsible for management of TLDs, though it delegates much of the actual administration
    to other organizations. Recently, the ICANN has authorized many new gTLDs, such
    as *.agency*, *.florist*, *.recipes*, and even *.ninja*. For the foreseeable future,
    *.com* will probably remain the “premium” TLD, and the hardest one to get real
    estate in. People who were lucky (or shrewd) enough to purchase *.com* domains
    in the internet’s formative years received massive payouts for prime domains (for
    example, Facebook purchased *fb.com* in 2010 for a whopping $8.5 million dollars).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the scarcity of *.com* domains, people are turning to alternative TLDs,
    or using *.com.us* to try to get a domain that accurately reflects their organization.
    When picking a domain, you should consider how it’s going to be used. If you plan
    on marketing primarily electronically (where people are more likely to click a
    link than type in a domain), then you should probably focus more on getting a
    catchy or meaningful domain than a short one. If you’re focusing on print advertising,
    or you have reason to believe people will be entering your URL manually into their
    devices, you might consider alternative TLDs so you can get a shorter domain name.
    It’s also common practice to have two domains: a short, easy-to-type one, and
    a longer one more suitable for marketing.'
  prefs: []
  type: TYPE_NORMAL
- en: Subdomains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whereas a TLD goes after your domain, a subdomain goes before it. By far, the
    most common subdomain is *www*. I’ve never particularly cared for this subdomain.
    After all, you’re at a computer, *using* the World Wide Web; I’m pretty sure you’re
    not going to be confused if there isn’t a *www* to remind you of what you’re doing.
    For this reason, I recommend using no subdomain for your primary domain: *http://meadowlarktravel.com/*
    instead of *http://www.meadowlarktravel.com/*. It’s shorter and less busy, and
    thanks to redirects, there’s no danger of losing visits from people who automatically
    start everything with *www*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subdomains are used for other purposes too. I commonly see things like *blogs.meadowlarktravel.com*,
    *api.meadowlarktravel.com*, and *m.meadowlarktravel.com* (for a mobile site).
    Often this is done for technical reasons: it can be easier to use a subdomain
    if, for example, your blog uses a completely different server than the rest of
    your site. A good proxy, though, can redirect traffic appropriately based on either
    subdomain or path, so the choice of whether to use a subdomain or a path should
    be more content-focused than technology-focused (remember what Tim Berners-Lee
    said about URLs expressing your information architecture, not your technical architecture).'
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that subdomains be used to compartmentalize significantly different
    parts of your website or service. For example, I think it’s a good use of subdomains
    to make your API available at *api.meadowlarktravel.com*. Microsites (sites that
    have a different appearance than the rest of your site, usually highlighting a
    single product or subject) are also good candidates for subdomains. Another sensible
    use for subdomains is to separate admin interfaces from public interfaces (*admin.meadowlarktravel.com*,
    for employees only).
  prefs: []
  type: TYPE_NORMAL
- en: Your domain registrar, unless you specify otherwise, will redirect all traffic
    to your server regardless of subdomain. It is up to your server (or proxy), then,
    to take appropriate action based on the subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: Nameservers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The “glue” that makes domains work are nameservers, and this is what you’ll
    be asked to provide when you establish hosting for your website. Usually, this
    is pretty straightforward, as your hosting service will do most of the work for
    you. For example, let’s say we choose to host *meadowlarktravel.com* at [DigitalOcean](https://www.digitalocean.com).
    When you set up your hosting account with DigitalOcean, you’ll be given the names
    of the DigitalOcean nameservers (there are multiple ones for redundancy). DigitalOcean,
    like most hosting providers, calls their nameservers *ns1.digitalocean.com*, *ns1.digitalocean.com*,
    and so on. Go to your domain registrar and set the nameservers for the domain
    you want to host, and you’re all set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the mapping works in this case is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Website visitor navigates to *http://meadowlarktravel.com/*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser sends the request to the computer’s network system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The computer’s network system, which has been given an internet IP address and
    a DNS server by the internet provider, asks the DNS resolver to resolve *meadowlarktravel.com*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DNS resolver is aware that *meadowlarktravel.com* is handled by *ns1.digitalocean.com*,
    so it asks *ns1.digitalocean.com* to give it an IP address for *meadowlarktravel.com*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server at *ns1.digitalocean.com* receives the request and recognizes that
    *meadowlarktravel.com* is indeed an active account, and returns the associated
    IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While this is the most common case, it’s not the only way to configure your
    domain mapping. Since the server (or proxy) that actually serves your website
    has an IP address, we can cut out the middleman by registering that IP address
    with the DNS resolvers (this effectively cuts out the middleman of the nameserver
    *ns1.digitalocean.com* in the previous example). For this approach to work, your
    hosting service must assign you a *static* IP address. Commonly, hosting providers
    will give your server(s) a *dynamic* IP address, which means it may change without
    notice, which would render this scheme ineffective. It can sometimes cost extra
    to get a static IP address instead of a dynamic one: check with your hosting provider.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to map your domain to your website directly (skipping your host’s
    nameservers), you will either be adding an A record or a CNAME record. An *A record*
    maps a domain name directly to an IP address, whereas a *CNAME* maps one domain
    name to another. CNAME records are usually a little less flexible, so A records
    are generally preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re using AWS for your nameservers, in addition to A and CNAME records,
    it also has a record called an *alias* that offers a lot of advantages if you’re
    pointing it to a service hosted on AWS. For more information, see the [AWS documentation](https://amzn.to/2pUuDhv).
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever technique you use, domain mapping is usually aggressively cached,
    meaning that when you change your domain records, it can take up to 48 hours for
    your domain to be attached to the new server. Keep in mind that this is also subject
    to geography: if you see your domain working in Los Angeles, your client in New
    York may see the domain attached to the previous server. In my experience, 24
    hours is usually sufficient for domains to resolve correctly in the continental
    US, with international resolution taking up to 48 hours.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need something to go live precisely at a certain time, you should not
    rely on DNS changes. Rather, modify your server to redirect to the “coming soon”
    site or page, and make the DNS changes in advance of the actual switchover. At
    the appointed moment, then, you can have your server switch over to the live site,
    and your visitors will see the change immediately, regardless of where they are
    in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing a hosting service can seem overwhelming at first. Node has taken off
    in a big way, and everyone’s clamoring to offer Node hosting to meet the demand.
    How you select a hosting provider depends very much on your needs. If you have
    reason to believe your site will be the next Amazon or Twitter, you’ll have a
    very different set of concerns than you would if you were building a website for
    your local stamp collector’s club.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional hosting or cloud hosting?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term “cloud” is one of the most nebulous tech terms to crop up in recent
    years. Really, it’s just a fancy way to say “the internet,” or “part of the internet.”
    The term is not entirely useless, though. While not part of the technical definition
    of the term, hosting in the cloud usually implies a certain commoditizing of computing
    resources. That is to say, we no longer think about a “server” as a distinct,
    physical entity: it’s simply a homogeneous resource somewhere in the cloud, and
    one is as good as another. I’m oversimplifying, of course: computing resources
    are distinguished (and priced) according to their memory, number of CPUs, etc.
    The difference is between knowing (and caring) what actual server your app is
    hosted on, and knowing it’s hosted on *some* server in the cloud, and it could
    just as easily be moved over to a different one without you knowing (or caring).'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud hosting is also highly *virtualized*. That is, the server(s) your app
    is running on are not usually physical machines, but virtual machines running
    on physical servers. This idea was not introduced by cloud hosting, but it has
    become synonymous with it.
  prefs: []
  type: TYPE_NORMAL
- en: While cloud hosting had humble origins, it means a lot more than “homogenous
    servers” now. The major cloud providers offer many infrastructure services that
    (in theory) reduce your maintenance burden and offer a high degree of scalability.
    These services include database storage, file storage, networking queues, authentication,
    video processing, telecommunications services, artificial intelligence engines,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud hosting can be a little disconcerting at first, not knowing anything
    about the actual physical machine your server is running on, trusting that your
    servers aren’t going to be affected by the other servers running on the same computer.
    Really, though, nothing has changed: when your hosting bill comes, you’re still
    paying for essentially the same thing: someone taking care of the physical hardware
    and networking that enables your web applications. All that’s changed is that
    you’re more removed from the hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: I believe that “traditional” hosting (for lack of a better term) will eventually
    disappear altogether. That’s not to say hosting companies will go out of business
    (though some inevitably will); they will just start to offer cloud hosting themselves.
  prefs: []
  type: TYPE_NORMAL
- en: XaaS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When considering cloud hosting, you will come across the acronyms SaaS, PaaS,
    IaaS, and FaaS:'
  prefs: []
  type: TYPE_NORMAL
- en: Software as a Service (SaaS)
  prefs: []
  type: TYPE_NORMAL
- en: 'SaaS generally describes software (websites, apps) that are provided to you:
    you just use them. An example would be Google Documents or Dropbox.'
  prefs: []
  type: TYPE_NORMAL
- en: Platform as a Service (PaaS)
  prefs: []
  type: TYPE_NORMAL
- en: PaaS provides all of the infrastructure for you (operating systems, networking—all
    of that is handled). All you have to do is write your applications. While there
    is often a blurry line between PaaS and IaaS (and you will often find yourself
    straddling that line as a developer), this is generally the service model we’re
    discussing in this book. If you’re running a website or web service, PaaS is probably
    what you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as a Service (IaaS)
  prefs: []
  type: TYPE_NORMAL
- en: 'IaaS gives you the most flexibility, but at cost. All you get are virtual machines
    and a basic network connecting them. You are then responsible for installing and
    maintaining operating systems, databases, and network policies. Unless you need
    this level of control over your environment, you will generally want to stick
    with PaaS. (Note that PaaS does allow you to have control over the *choice* of
    operating systems and network configuration: you just don’t have to do it yourself.)'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as a Service (FaaS)
  prefs: []
  type: TYPE_NORMAL
- en: FaaS describes offerings such as AWS Lambda, Google Functions, and Azure Functions,
    which provide a way to run individual functions in the cloud without having to
    configure the runtime environment yourself. It’s at the core of what is commonly
    being called “serverless” architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The behemoths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The companies that essentially run the internet (or, at least, are heavily invested
    in the running of the internet) have realized that with the commoditization of
    computing resources, they have another viable product to sell. Amazon, Microsoft,
    and Google all offer cloud computing services, and their services are quite good.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these services are priced similarly: if your hosting needs are modest,
    there will be minimal price difference among the three. If you have very high
    bandwidth or storage needs, you will have to evaluate the services more carefully,
    as the cost difference could be greater, depending on your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: While Microsoft does not normally leap to mind when we consider open source
    platforms, I would not overlook Azure. Not only is the platform established and
    robust, but Microsoft has bent over backward to make it friendly to not just Node,
    but the open source community. Microsoft offers a one-month Azure trial, which
    is a great way to determine if the service meets your needs; if you’re considering
    one of the big three, I definitely recommend the free trial to evaluate Azure.
    Microsoft offers Node APIs for all of its major services, including its cloud
    storage service. In addition to excellent Node hosting, Azure offers an excellent
    cloud storage system (with a JavaScript API), as well as good support for MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon offers the most comprehensive set of resources, including SMS (text message),
    cloud storage, email services, payment services (ecommerce), DNS, and more. In
    addition, Amazon offers a free usage tier, making it very easy to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: Google’s cloud platform has come a long way and now offers robust Node hosting
    and, as you might expect, excellent integration with its own services (mapping,
    authentication, and search being particularly attractive).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the “big three,” it is worth considering [Heroku](https://www.heroku.com),
    which has been catering to people wanting to host fast and nimble Node applications
    for some time now. I’ve also had great luck with [DigitalOcean](https://www.digitalocean.com),
    which focuses more on providing containers and a limited number of services in
    a very user-friendly manner.
  prefs: []
  type: TYPE_NORMAL
- en: Boutique hosting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Smaller hosting services, which I’m going to call “boutique” hosting services
    (for lack of a better word), may not have the infrastructure or resources of Microsoft,
    Amazon, or Google, but that doesn’t mean they don’t offer something valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Because boutique hosting services can’t compete in terms of infrastructure,
    they usually focus on customer service and support. If you need a lot of support,
    you might want to consider a boutique hosting service. If you have a hosting provider
    you’ve been happy with, don’t hesitate to ask if it offers (or plans on offering)
    Node hosting.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It still surprises me that, in 2019, people are still using FTP to deploy their
    applications. If you are, *please stop*. FTP is in no way secure. Not only are
    all your files transmitted unencrypted, but your *username and password* are also.
    If your hosting provider doesn’t give you an option, find a new hosting provider.
    If you really have no choice, make sure you use a unique password that you’re
    not using for anything else.
  prefs: []
  type: TYPE_NORMAL
- en: At minimum, you should be using SFTP or FTPS (not to be confused), but you should
    really be considering a *continuous delivery* (CD) service.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind CD is that you’re never very far away from a version that can
    be released (weeks or even days). CD is usually used in the same breath as *continuous
    integration* (CI), which refers to automated processes for integrating the work
    of developers and testing them.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the more you can automate your processes, the easier your development
    will be. Imagine merging in changes, and automatically getting notified that unit
    tests pass, then integration tests pass, and then seeing your changes online…in
    a matter of minutes! It’s a great goal, but you have to invest some work up front
    to get it set up, and there will be some maintenance over time.
  prefs: []
  type: TYPE_NORMAL
- en: Although the steps themselves are similar (run unit tests, run integration tests,
    deploy to staging servers, deploy to production servers), the process of setting
    up CI/CD pipelines (a word you’ll hear a lot when discussing CI/CD) varies substantially.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should look at some of the options available for CI/CD and choose one that
    meets your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[AWS CodePipeline](https://amzn.to/2CzTQAo)'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re hosting on AWS, CodePipeline should be first on your list, as it will
    be the easiest path to CI/CD for you. It’s very robust, but I’ve found it to be
    a little less user-friendly than some of the other options.
  prefs: []
  type: TYPE_NORMAL
- en: '[Microsoft Azure Web Apps](http://bit.ly/2CEsSI0)'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re hosting on Azure, Web Apps is your best bet (are you noticing a trend
    here?). I haven’t had much experience with this service, but it seems to be well
    loved in the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[Travis CI](https://travis-ci.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Travis CI has been around for a long time now, and has a large, loyal user base
    and good documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Semaphore](https://semaphoreci.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Semaphore is easy to set up and configure, but it doesn’t offer many features,
    and its basic (low-cost) plans are slow.
  prefs: []
  type: TYPE_NORMAL
- en: '[Google Cloud Build](http://bit.ly/2NGuIys)'
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t tried Google Cloud Build yet, but it looks robust and, like CodePipeline
    and Azure Web Apps, it’s likely that is the best choice if you’re hosting on Google
    Cloud.]
  prefs: []
  type: TYPE_NORMAL
- en: '[CircleCI](https://circleci.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: CircleCI is another CI that’s been around for some time, and is well loved.
  prefs: []
  type: TYPE_NORMAL
- en: '[Jenkins](https://jenkins.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is another incumbent with a large community. My experience is that it
    hasn’t kept up with modern deployment practices as well as some of the other options
    here, but it did just release a new version that looks promising.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the day, CI/CD services are automating the activities that *you*
    create. You still have to write the code, determine your versioning scheme, write
    high-quality unit and integration tests and a way to run them, and understand
    your deployment infrastructure. The examples in this book could be automated simply
    enough: most everything could be deployed to a single server running a Node instance.
    However, as you start to grow your infrastructure, so too will your CI/CD pipeline
    grow in complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: Git’s role in deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git’s greatest strength (and greatest weakness) is its flexibility. It can be
    adapted to almost any workflow imaginable. For the sake of deployment, I recommend
    creating one or more branches *specifically for deployment*. For example, you
    might have a `production` branch and a `staging` branch. How you use those branches
    is very much up to your individual workflow.
  prefs: []
  type: TYPE_NORMAL
- en: One popular approach is to flow from `master` to `staging` to `production`.
    So once some changes on `master` are ready to go live, you could merge them into
    `staging`. Once they have been approved on the staging server, you could then
    merge `staging` into `production`. While this makes logical sense, I dislike the
    clutter it creates (merges, merges everywhere). Also, if you have lots of features
    that need to be staged and pushed to production in different orders, this can
    get messy quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'I feel a better approach is to merge `master` into `staging` and, when you’re
    ready to go live with changes, then merge `master` into `production`. In this
    way, `staging` and `production` become less associated: you can even have multiple
    staging branches to experiment with different features before going live (and
    you can merge things other than `master` into them). Only when something has been
    approved for production do you merge it into `production`.'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you need to roll back changes? This is where things can get
    complicated. There are multiple techniques for undoing changes, such as applying
    the inverse of a commit to undo prior commits (`git revert`), these techniques
    not only are complicated, but also can can cause problems down the line. The typical
    way of handling this is to create tags (for example, `git tag v1.2.0` on your
    `production` branch) every time you make a deployment. If you need to roll back
    to a specific version, you always have that tag available.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it is up to you and your team to decide on a Git workflow. More
    important than the workflow you pick is the consistency with which you use it,
    and the training and communication surrounding it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ve already discussed the value of keeping your binary assets (multimedia
    and documents) separate from your code repository. Git-based deployment offers
    another incentive for this approach. If you have 4 GB of multimedia data in your
    repository, they’re going to take forever to clone, and you have an unnecessary
    copy of all of your data for every production server.
  prefs: []
  type: TYPE_NORMAL
- en: Manual Git-based deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re not ready yet to take the step of setting up CI/CD, you could start
    with a manual Git-based deployment. The advantage of this approach is that you’ll
    get comfortable with the steps and challenges involved in deployment, which will
    serve you well when you take the step of automation.
  prefs: []
  type: TYPE_NORMAL
- en: For each server you want to deploy to, you will have to clone the repository,
    check out the `production` branch, and then set up the infrastructure necessary
    to start/restart your app (which will be dependent on your choice of platform).
    When you update the `production` branch, you will have to go to each server, run
    `git pull --ff-only`, run `npm install --production`, and then restart the app.
    If your deployments aren’t often, and you don’t have very many servers, this may
    not represent a terrible hardship, but if you’re updating more often, this will
    get old fast, and you’ll want to find some way to automate the system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `--ff-only` argument to `git pull` allows only fast-forward pulls, preventing
    automatic merging or rebasing. If you know the pull is fast-forward only, you
    may safely omit it, but if you get in the habit of doing it, you will never accidentally
    invoke a merge or rebase!
  prefs: []
  type: TYPE_NORMAL
- en: In essence, what you are doing here is replicating the way you work in development,
    except you’re doing it on a remote server. Manual processes always run the risk
    of human error, and I recommend this approach only as a stepping stone toward
    more automated development.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying your website (especially for the first time) should be an exciting
    occasion. There should be champagne and cheering, but all too often, there is
    sweating, cursing, and late nights. I’ve seen far too many websites launched at
    three in the morning by an irritable, exhausted team. Fortunately, that’s changing,
    partly thanks to cloud deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what deployment strategy you choose, the most important thing you
    can do is to start production deployments early, before the site is ready to go
    live. You don’t have to hook up the domain, so the public doesn’t need to know.
    If you’ve already deployed the site to production servers half a dozen times before
    the day of launch, your chances of a successful launch will be much higher. Ideally,
    your functioning website will already be running on the production server long
    before launch: all you have to do is flip the switch from the old site to the
    new site.'
  prefs: []
  type: TYPE_NORMAL
